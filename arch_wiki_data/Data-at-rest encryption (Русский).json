{
  "title": "Data-at-rest encryption (Русский)",
  "url": "https://wiki.archlinux.org/title/Data-at-rest_encryption_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- dm-crypt (Русский)\n- VeraCrypt\n- eCryptfs (Русский)\n- EncFS\n- gocryptfs\n- fscrypt\n- Tomb\n- tcplay\n- GnuPG (Русский)\n- Self-encrypting drives\n\nВ этой статье рассматриваются программы для шифрования хранимых данных (данных в состоянии покоя, data at rest), которые на лету шифруют и дешифруют данные на блочном устройстве, разделе диска или в каталоге. Примеры блочных устройств — жёсткие диски, флэш-накопители и DVD.\n\nШифрование хранимых данных следует рассматривать только как дополнение к существующим механизмам безопасности операционной системы — сфокусированное на защите физического доступа, в то время как другие части системы обеспечивают такие вещи, как сетевая безопасность и контроль доступа пользователей.\n\nШифрование всего диска (full-disk encryption, FDE) описано в статье dm-crypt/Encrypting an entire system.\n\n"
    },
    {
      "title": "Зачем использовать шифрование?",
      "level": 2,
      "content": "Шифрование данных в состоянии покоя гарантирует, что файлы всегда хранятся на диске в зашифрованном виде. Файлы становятся доступными для операционной системы и приложений в читаемой форме, только когда система включена и разблокирована доверенным пользователем (данные в процессе использования — data in use, или в процессе перемещения — data in transit). Неавторизованный человек, просматривающий содержимое диска напрямую, вместо реальных файлов увидит лишь что-то похожее на случайный шум.\n\nНапример, это может предотвратить несанкционированный просмотр данных, когда компьютер или жёсткий диск:\n\n- расположен в месте, к которому могут получить доступ недоверенные лица, пока вас рядом нет\n- потерян или украден, как в случае с ноутбуками, нетбуками или внешними устройствами хранения данных\n- в ремонтной мастерской\n- выброшен после окончания срока службы\n\nКроме того, шифрование данных в состоянии покоя может использоваться для обеспечения защиты от несанкционированных попыток вмешательства в операционную систему — например, установки кейлоггеров или троянских программ злоумышленниками, которые могут получить физический доступ к системе во время вашего отсутствия.\n\nВы по-прежнему будете уязвимы:\n\n- к злоумышленникам, которые могут проникнуть в вашу систему (например, через интернет) во время её работы — после того, как вы уже разблокировали и смонтировали зашифрованные части диска;\n- к злоумышленникам, которые могут получить физический доступ к компьютеру во время его работы (даже если вы используете блокировщик экрана) — или даже вскоре после его работы, если у них есть ресурсы для проведения cold boot attack;\n- к правительственным организациям, которые не только обладают ресурсами для проведения вышеупомянутых атак, но и могут просто заставить вас отдать свои ключи/пароли, используя различные методы принуждения. В большинстве недемократических стран мира, а также в США и Великобритании, это может быть законно для правоохранительных органов, если у них есть подозрения, что вы можете скрывать что-то интересное;\n- к терморектальному криптоанализу. Смотрите также XKCD #538.\n\nЧтобы иметь шанс противостоять профессиональным злоумышленникам, способным вскрыть вашу систему перед её использованием, требуется очень мощная система шифрования диска (например, полное шифрование системы с проверкой подлинности и без незашифрованного загрузочного раздела). И даже в этом случае она не сможет предотвратить все типы взлома (например, аппаратные кейлоггеры). Лучшее, что можно сделать, — это аппаратное шифрование всего диска и доверенная загрузка (Trusted Computing).\n\n"
    },
    {
      "title": "Шифрование данных системы",
      "level": 2,
      "content": "Хотя шифрование только пользовательских данных (часто расположенных в домашнем каталоге или на съёмных носителях, например DVD с данными) является самым простым и наименее навязчивым методом, он имеет ряд существенных недостатков. В современных компьютерных системах существует множество фоновых процессов, которые могут кэшировать и хранить информацию о пользовательских данных или части самих данных в незашифрованных областях жёсткого диска, таких как:\n\n- подкачка (возможные способы решения: отключить подкачку или зашифровать её)\n- /tmp (временные файлы, создаваемые пользовательскими приложениями) (возможные способы решения: избегать таких приложений; монтировать /tmp как ram-диск)\n- /var (файлы журналов, базы данных и т.п.; например, locate хранит индекс всех имён файлов в /var/lib/plocate/plocate.db).\n\n- (возможные способы решения: отключить подкачку или зашифровать её)\n\n- (возможные способы решения: избегать таких приложений; монтировать /tmp как ram-диск)\n\nРешением является шифрование и системных, и пользовательских данных, что предотвращает несанкционированный физический доступ к секретным данным, которые могли осесть в кэшах системы. Недостаток такого подхода в том, разблокировка зашифрованных частей диска должна происходить ещё в начале загрузки. Также преимуществом шифрования данных системы является то, что оно усложняет установку вредоносных программ, таких как кейлоггеры или руткиты, злоумышленнику с физическим доступом.\n\n"
    },
    {
      "title": "Доступные методы",
      "level": 2,
      "content": "Все перечисленные здесь методы шифрования работают так, что даже если на диске хранятся зашифрованные данные, операционная система и приложения «видят» их как обычные доступные для чтения данные, пока криптографический контейнер (то есть, логическая часть диска, на которой хранятся зашифрованные данные) «разблокирован» и смонтирован.\n\nЧтобы это произошло, пользователь должен предоставить некоторую «секретную информацию» (обычно в виде файла ключа и/или пароля), из которой может быть получен ключ шифрования (и сохранён в списке ключей ядра на время жизни текущего сеанса).\n\nЕсли вы не знакомы с подобными операциями, прочтите также раздел #Как работает шифрование ниже.\n\nДоступные методы шифрования данных в состоянии покоя можно разделить на два типа по уровню их работы:\n\n"
    },
    {
      "title": "Шифрование поверх файловой системы",
      "level": 3,
      "content": "При шифровании поверх уже существующей файловой системы (stacked filesystem encryption) все файлы, записанные в папку с подключенным шифрованием, шифруются на лету, прежде чем базовая файловая система запишет их на диск, и расшифровываются каждый раз, когда файловая система считывает их с диска. Таким образом, файлы хранятся в файловой системе хоста в зашифрованном виде (это означает, что их содержимое, а также имена файлов/папок заменяются данными, выглядящими как случайный шум, примерно той же длины), но при этом в папке с подключенным шифрованием они выглядят так же, как и без шифрования, в виде обычных файлов / симлинков / хардлинков / и т. п.\n\nСпособ реализации такого метода заключается в том, что для разблокирования папки, хранящей файлы в зашифрованном виде в файловой системе хоста («нижний каталог»), она монтируется (с помощью специальной стековой файловой системы) в себя или, по желанию, в другое место («верхний каталог»), где те же файлы отображаются в читаемом виде — до тех пор, пока не будет выполнено размонтирование или система не будет выключена.\n\nТакими файловыми системами являются, например, eCryptfs и EncFS.\n\n"
    },
    {
      "title": "Оптимизированное для облачных хранилищ",
      "level": 4,
      "content": "Если вы используете шифрование поверх файловой системы, чтобы скрыть данные от используемых вами облачных хранилищ, стоит рассмотреть альтернативы файловым системам eCryptfs и EncFS, поскольку они не оптимизированы для передачи файлов через интернет. Существуют решения, разработанные специально для этой цели:\n\n- gocryptfs\n- cryptomatorAUR или cryptomator-binAUR (кроссплатформенный)\n- cryfs\n\nНекоторые облачные хралилища предоставляют свои приложения с поддержкой шифрования.\n\n"
    },
    {
      "title": "Шифрование блочного устройства",
      "level": 3,
      "content": "Методы шифрования блочных устройств, с другой стороны, работают ниже уровня файловой системы и обеспечивают шифрование всего, что записано на блочное устройство (то есть целый диск, раздел или файл, выступающий в качестве loop-устройства). Это означает, что пока блочное устройство не используется, всё его содержимое выглядит как большой кусок случайных данных, и нет возможности определить, какая файловая система и какие данные на нём содержатся. Доступ к данным происходит, опять же, путём монтирования защищённого контейнера (в данном случае блочного устройства) в произвольное место специальным образом.\n\nВ Arch Linux доступны следующие решения для шифрования блочных устройств:\n\n- LUKS, используемый по умолчанию, представляет собой дополнительный уровень удобства, который хранит всю необходимую информацию о настройках для dm-crypt на само́м диске и абстрагирует управление разделами и ключами с целью упрощения использования и повышения безопасности.\n- Простой (plain) режим dm-crypt, будучи оригинальной функциональностью ядра, не предоставляет дополнительных удобств. С ним сложнее получить ту же криптографическую стойкость. При этом используются более длинные ключи (пароли или файлы ключей). Однако у него есть преимущества, описанные в следующем разделе #Сравнение типов шифрования.\n\n#Сравнение типов шифрования описывает практические последствия выбора того или иного метода. Смотрите также сравнение в этой статье про eCryptfs. Список статей о используемых методах, а также инструментах, не включенных таблицу, доступен в Category:Encryption (Русский) (на английском языке: Category:Encryption).\n\n"
    },
    {
      "title": "Сравнение типов шифрования",
      "level": 3,
      "content": "Table content:\nАспект | Шифрование блочного устройства | Шифрование поверх файловой системы\nШифрует | блочное устройство целиком | файлы\nЗашифрованные данные могут храниться... | на диске целиком, на отдельном разделе или в файле, используемом как loop-устройство | в каталоге в уже существующей файловой системе\nСвязь с файловой системой | работает ниже уровня файловой системы: не имеет значения, является ли содержимое зашифрованного блочного устройства файловой системой, таблицей разделов, установкой LVM или чем-либо ещё | добавляет дополнительный уровень к существующей файловой системе для автоматического шифрования/дешифрования файлов при каждой операции записи/чтения\nШифрование метаданных (количество файлов, структура каталогов, размеры, права доступа, даты изменения и т.п.) | Да | Нет(хотя имена файлов и каталогов могут быть зашифрованы)\nВозможность шифрования жёсткого диска целиком (вместе с таблицей разделов) | Да | Нет\nШифрование подкачки | Да | Нет\nМожет использоваться без предварительного выделения фиксированного объёма под хранение зашифрованных данных | Нет | Да\nМожет использоваться для защиты существующих файловых систем без доступа к блочным устройствам, например, общих ресурсов NFS или Samba, облачных хранилищ и т.д. 1 | Нет | Да\nВозможность резервного копирования отдельных файлов без дешифровки | Нет | Да\n\n1. ну, в блочном шифровании можно использовать файл в качестве контейнера (loop-устройства), но возможности файловой системы всё равно не будут использоваться.\n\n"
    },
    {
      "title": "Сравнительная таблица",
      "level": 3,
      "content": "В столбце «dm-crypt +/- LUKS» указаны возможности dm-crypt как для режима шифрования LUKS («+»), так и для plain («-»). Если какая-то функция требует использования LUKS, это обозначается как «(с LUKS)». Аналогично «(без LUKS)» указывает на то, что использование LUKS является контрпродуктивным для достижения данной функции и следует использовать режим plain.\n\nTable content:\nОбщая информация | Loop-AES | dm-crypt +/- LUKS | VeraCrypt | ZFS | eCryptfs | EncFS | gocryptfs | fscrypt\nТип шифрования | блочное устройство | блочное устройство | блочное устройство | нативная ФС или блочное устройство | стековая ФС | стековая ФС | стековая ФС | нативная ФС\nПримечание | появился раньше других; возможно, самый быстрый; работает на старых системах | стандарт де-факто для шифрования блочных устройств в Linux; очень гибкий | форк TrueCrypt, может работать с томами TrueCrypt и VeraCrypt | функция шифрования относительно новая (2019); шифрованные блочные устройства предоставляет компания ZVOL | немного быстрее, чем EncFS; отдельные зашифр. файлы можно переносить между системами | самый простой в использовании; можно управлять без прав root | стремится стать преемником EncFS | по умолчанию для шифрования Chrome OS и Android\nДоступность в Arch Linux | требуется компиляция своего ядра | модули ядра: входит в состав стандартного ядра; инструменты: device-mapper, cryptsetup | veracrypt | ZFS#Installation | модуль ядра: входит в состав стандартного ядра; инструменты: ecryptfs-utils | encfs | gocryptfs | модуль ядра: входит в состав стандартного ядра; инструмент: fscrypt\nЛицензия | GPL | GPL | Apache License 2.0; некоторые части — TrueCrypt License v3.0 | CDDL | GPL | GPL | MIT | GPL (ядро), Apache 2.0 (инструменты)\nШифрование реализовано в... | пространстве ядра | пространстве ядра | пространстве ядра | пространстве ядра | пространстве ядра | пространстве пользователя (FUSE) | пространстве пользователя (FUSE) | пространстве ядра\nМетаданные шифрования хранятся в... | ? | с LUKS: заголовке LUKS | начале/конце (расшифр.) устройства (описание формата) | DSL (dataset & snapshot layer; talk/slides) | заголовке каждого зашифр. файла | файле настроек в зашифр. каталоге | ? | каталоге .fscrypt в корне каждой ФС\nКлюч шифрования хранится в... | ? | с LUKS: заголовке LUKS | начале/конце (расшифр.) устройства (описание формата) | DSL (dataset & snapshot layer; talk/slides) | файле ключа, который можно хранить где угодно | файле ключа, который можно хранить где угодно [1][2] | ? | каталоге .fscrypt в корне каждой ФС\nОсобенности использования | Loop-AES | dm-crypt +/- LUKS | VeraCrypt | ZFS | eCryptfs | EncFS | gocryptfs | fscrypt\nНе-root пользователи могут создавать или удалять зашифрованные контейнеры | Нет | Нет | Нет | Да | ограниченно | Да | Да | Да\nГрафический интерфейс | Нет | Нет | Да | Нет | Нет | Да опционально | Нет | Нет\nПоддержка автомонтирования при входе | ? | Да | Да с systemd и /etc/crypttab | ? | Да | Да | Да | Да\nАвтоматическое размонтирование при неактивности | ? | ? | ? | Нет | ? | Да | Да[3] | Нет\nБезопасность | Loop-AES | dm-crypt +/- LUKS | VeraCrypt | ZFS | eCryptfs | EncFS | gocryptfs | fscrypt\nПоддержка алгоритмов шифрования | AES | AES, Anubis, CAST5/6, Twofish, Serpent, Camellia, Blowfish,… (любые шифры, которые есть в Crypto API ядра) | AES, Twofish, Serpent, Camellia, Kuznyechik | AES | AES, Blowfish, Twofish... | AES, Blowfish, Twofish и любые другие доступные в системе шифры | AES | AES, ChaCha12\nПроверка целостности | нет | опционально в LUKS2 | нет | CCM, GCM | нет | нет (по умолчанию)HMAC (режим максимальной секретности) | GCM | нет\nПоддержка соли | ? | Да(с LUKS) | Да | Да | Да | ? | Да | Да\nПоддержка каскада из нескольких шифров | ? | Не в одном устройстве, но можно сделать каскад блочных устройств | Да AES-Twofish, AES-Twofish-Serpent, Serpent-AES, Serpent-Twofish-AES, Twofish-Serpent | Нет | ? | Нет | Нет | Нет\nSupport for key-slot diffusion | ? | Да(с LUKS) | ? | ? | ? | ? | ? | Нет\nProtection against key scrubbing | Да | Да(без LUKS) | ? | ? | ? | ? | ? | Нет\nПоддержка нескольких (независимых друг от друга) ключей для одних и тех же зашифрованных данных | ? | Да(с LUKS) | ? | Нет | ? | Нет | ? | Да\nСкорость | Loop-AES | dm-crypt +/- LUKS | VeraCrypt | ZFS | eCryptfs | EncFS | gocryptfs | fscrypt\nИспользование нескольких потоков | ? | Да[4] | Да | Да | ? | ? | Да | Да\nАппаратное ускорение шифрования | Да | Да | Да | Да | Да | Да[5] | Да | Да\nСпецифичное для шифрования блочных устройств | Loop-AES | dm-crypt +/- LUKS | VeraCrypt | ZFS | \nПоддержка (ручного) изменения размера зашифрованного блочного устройства на месте | ? | Да | Нет | Да\nСпецифичное для шифрования поверх ФС |  | ZFS | eCryptfs | EncFS | gocryptfs | fscrypt\nПоддержка файловых систем | ZFS | ext3, ext4, xfs (с оговорками), jfs, nfs... | ext3, ext4, xfs (с оговорками), jfs, nfs, cifs... [6] | любые | ext4, F2FS, UBIFS\nВозможность шифровать имена файлов | Даzfs(8) | Да | Да | Да | Да\nВозможность не шифровать имена файлов | Нет | Да | Да | Да[7] | Нет\nОптимизации для работы с разреженными (sparse) файлами | Да | Нет | Да | Да | Да\nСовместимость | Loop-AES | dm-crypt +/- LUKS | VeraCrypt | ZFS | eCryptfs | EncFS | gocryptfs | fscrypt\nПоддержка версий ядра Linux | 2.0 или новее | Режим CBC с 2.6.4, ESSIV 2.6.10, LRW 2.6.20, XTS 2.6.24 | ? | 2.6.32 или новее (в версии 0.8.3) | ? | 2.4 или новее | ? | 4.1 или новее\nДоступ к зашифрованным данным из Windows | ? | ? | Да | ДаOpenZFS on Windows (repo) | ? | Нет (нужны админ. права) | Да (порт cppcryptfs) | Нет\nДоступ к зашифрованным данным из macOS | ? | ? | Да | ДаOpenZFS on OS X (repo) | ? | Да[8] | Да (бета) | Нет\nДоступ к зашифрованным данным из FreeBSD | ? | ? | Да | ДаZFS on FreeBSD (нативно; repo) | ? | Да[9] | ? | Нет\nИспользуется в | ? | установщиках Debian и Ubuntu (шифрование системы)установщике Fedora | ? | ? | ? | ? | ? | Android, Chrome OS\n\n[1][2]\n\nопционально\n\nс systemd и /etc/crypttab\n\nAES-Twofish, AES-Twofish-Serpent, Serpent-AES, Serpent-Twofish-AES, Twofish-Serpent\n\n[6]\n\n"
    },
    {
      "title": "Выбор способа шифрования",
      "level": 3,
      "content": "Какой способ шифрования подойдёт вам, зависит от ваших целей (смотрите раздел #Зачем использовать шифрование?) и параметров системы.\n\nПомимо прочего, вам нужно будет ответить на следующие вопросы:\n\n- Случайный пользователь, шныряющий по вашему диску, когда компьютер выключен, украден и т.д.\n- Профессиональный криптоаналитик, который может получить долговременный доступ на чтение/запись к вашей системе до и после её использования\n- Любой промежуточный вариант\n\n- Только пользовательские данные\n- Систему и пользовательские данные\n- Только конфиденциальные данные, то есть часть данных\n\n- Отключить или смонтировать как ram-диск\n- Зашифровать подкачку Файл подкачки как часть шифрования всего диска Шифровать раздел подкачки отдельно\n\n- Файл подкачки как часть шифрования всего диска\n- Шифровать раздел подкачки отдельно\n\n- Пароль Такой же, как пароль для входа в систему Отличается от пароля для входа в систему\n- Файл ключа (например, на USB-накопителе, который вы храните в безопасном месте или носите с собой)\n- Оба варианта вместе\n\n- Такой же, как пароль для входа в систему\n- Отличается от пароля для входа в систему\n\n- Перед загрузкой\n- Во время загрузки\n- При входе в систему\n- Вручную по требованию (после входа в систему)\n\n- Никак\n- Использовать общий пароль (или файл ключа), известный каждому пользователю\n- Независимые друг от друга пароли (или файлы ключей) для одной и той же зашифрованной части диска\n- Отдельные зашифрованные части диска для разных пользователей\n\nОтветив на эти вопросы, вы сможете сделать необходимый технический выбор (смотрите раздел #Доступные методы выше и раздел #Как работает шифрование ниже), касающийся:\n\n- метода шифрования: шифрование поверх файловой системы или шифрование блочного устройства\n- управления ключами\n- алгоритма и режима шифрования\n- хранения метаданных\n- расположения «нижнего каталога» (при использовании стековой файловой системы)\n\n"
    },
    {
      "title": "Примеры",
      "level": 3,
      "content": "На практике это может выглядеть примерно так:\n\n- зашифрованные версии файлов хранятся на диске в каталоге ~/.Private\n- разблокируется по требованию с помощью отдельного пароля\n\n- разблокируется при входе пользователя с помощью пароля для входа в систему\n- разделы подкачки и /tmp зашифрованы с помощью dm-crypt с LUKS, с использованием автоматически генерируемого на каждый сеанс временного ключа\n- индексирование/кэширование содержимого раздела /home с помощью slocate (и подобных приложений) отключено.\n\n- разблокируется во время загрузки с помощью пароля или USB-накопителя с файлами ключей\n- Возможно, разные пароли/ключи для каждого пользователя — независимо отзываемые\n- Возможно шифрование нескольких дисков или гибкая разметка разделов с помощью LUKS on LVM\n\n- USB-загрузка с использованием отдельного пароля плюс USB-накопителя с файлом ключа\n- проверка целостности данных перед монтированием\n- раздел /boot располагается на вышеупомянутом USB-накопителе\n\n- Файл вроде ~/.volume.img шифруется с помощью dm-crypt/Encrypting a non-root file system#File container\n- Периодическое резервное копирование путём копирования всего контейнера на удалённый хост\n\nКонечно, возможны и многие другие комбинации. Тщательно обдумайте, какой способ организации шифрования лучше подходит для ваших задач.\n\n"
    },
    {
      "title": "Выбор надёжного пароля",
      "level": 3,
      "content": "Смотрите Безопасность#Надёжность пароля.\n\n"
    },
    {
      "title": "Подготовка диска",
      "level": 3,
      "content": "Перед установкой шифрования на диск (или часть диска), возможно, стоит выполнить безопасное стирание — перезапись всего диска или раздела нулевыми или случайными байтами. Это может понадобиться сделать по следующим причинам:\n\nШифрование диска не меняет того факта, что отдельные сектора перезаписываются только по необходимости, когда файловая система создаёт или изменяет данные, хранящиеся в этих секторах (смотрите раздел #Как работает шифрование ниже). Сектора, которые файловая система считает «неиспользуемыми в данный момент», остаются нетронутыми и могут содержать остатки данных от предыдущих файловых систем. Единственный способ убедиться, что все данные, которые вы ранее хранили на диске, не могут быть восстановлены, — стереть их вручную. Для этой цели не имеет значения, используются ли нулевые или случайные байты (хотя стирание нулевыми байтами будет намного быстрее).\n\nВ идеале вся зашифрованная часть диска должна быть неотличима от случайных данных с равномерным распределением. Таким образом никто из посторонних не сможет узнать, какие сектора содержат зашифрованные данные — что само по себе может быть желательной целью (как часть истинной конфиденциальности), а также служит дополнительным барьером против злоумышленников, пытающихся взломать шифрование. Для достижения этой цели очень важно стирать диск с использованием случайных байтов из высококачественного источника случайности.\n\nВторая цель имеет смысл только в сочетании с шифрованием блочных устройств, поскольку в случае шифрования поверх существующей файловой системы зашифрованные данные можно легко найти в любом случае (в виде отдельных зашифрованных файлов в файловой системе хоста). Также обратите внимание, что, даже если вы собираетесь зашифровать только определённую папку, вам всё равно придётся стереть весь раздел, если вы хотите избавиться от файлов, которые ранее хранились в этой папке в незашифрованном виде (из-за фрагментации данных на диске). Если на том же разделе есть другие папки, вам придётся сделать их резервную копию и затем перенести обратно.\n\nПосле того как вы определились, какой вид стирания диска использовать, обратитесь к статье Securely wipe disk для получения технических инструкций.\n\n"
    },
    {
      "title": "Как работает шифрование",
      "level": 2,
      "content": "Этот раздел предназначен для ознакомления с концепциями и процессами, которые лежат в основе обычных способов шифрования дисков.\n\nОн не углубляется в технические или математические детали (для этого обратитесь к соответствующей литературе), но стремится дать системному администратору приблизительное понимание того, как различные варианты настройки (особенно в плане управления ключами) могут повлиять на удобство использования и безопасность.\n\n"
    },
    {
      "title": "Базовый принцип",
      "level": 3,
      "content": "Для шифрования диска каждое блочное устройство (или отдельный файл в случае шифрования поверх файловой системы) делится на сектора равной длины, например 512 байт (4096 бит). Шифрование/дешифрование выполняется отдельно для каждого сектора, поэтому n-ый сектор блочного устройства или файла на диске будет хранить зашифрованную версию n-ого сектора исходных данных.\n\nКогда операционная система или приложение запрашивает какие-то данные из блочного устройства или файла, весь сектор (или сектора), содержащий нужные данные, считывается с диска, расшифровывается на лету и временно сохраняется в оперативной памяти:\n\n```\n╔═══════╗\n    сектор 1 ║\"???..\"║\n             ╠═══════╣         ╭┈┈┈┈┈┈╮\n    сектор 2 ║\"???..\"║         ┊ ключ ┊\n             ╠═══════╣         ╰┈┈┬┈┈┈╯\n             :       :            │\n             ╠═══════╣            ▼             ┣┉┉┉┉┉┉┉┫\n    сектор n ║\"???..\"║━━━━━━━(дешифровка)━━━━━━▶┋\"абв..\"┋ сектор n\n             ╠═══════╣                          ┣┉┉┉┉┉┉┉┫\n             :       :\n             ╚═══════╝\n\n зашифрованное блочное                          расшифрованные\n        устройство или                          данные в памяти\n         файл на диске\n```\n\nАналогично, при каждой операции записи все затронутые сектора должны быть заново зашифрованы (в то время как остальные сектора остаются нетронутыми).\n\nЧтобы иметь возможность (де)шифровать данные, система шифрования диска должна знать уникальный секретный «ключ», связанный с ними. Каждый раз, когда нужно смонтировать блочное устройство или папку с шифрованием, нужно предоставить соответствующий ключ (далее он называется «мастер-ключ»).\n\nЭнтропия ключа имеет огромное значение для безопасности шифрования. Случайно сгенерированная байтовая строка определённой длины, например, 32 байта (256 бит), обладает желаемыми свойствами, но её невозможно запомнить и ввести вручную во время монтирования.\n\nПоэтому вместо использования ключа напрямую используются две вспомогательные техники. Первая — это применение криптографии для повышения энтропийных свойств мастер-ключа, обычно с использованием отдельного пароля, удобного для человека. Соответствующие возможности различных типов шифрования приведены в разделе #Сравнительная таблица. Второй метод заключается в создании файла ключа с высокой энтропией и хранении его на носителе, отдельном от диска с зашифрованными данными.\n\nСмотрите также Wikipedia:Authenticated encryption.\n\n"
    },
    {
      "title": "Ключи, файлы ключей и пароли",
      "level": 3,
      "content": "Примеры хранения и защиты мастер-ключа с помощью файла ключей:\n\nОбычное хранение главного ключа в файле (в читаемой форме) является самым простым вариантом. Этот файл — так называемый «keyfile» — можно записать на USB-накопитель, который будет храниться в безопасном месте и подключаться к компьютеру только при необходимости смонтировать зашифрованные части диска (например, во время загрузки или при входе в систему).\n\nМастер-ключ (и, соответственно, зашифрованные данные) можно защитить паролем, который нужно будет запомнить и вводить каждый раз, когда нужно будет смонтировать блочное устройство или папку с шифрованием. Подробности описаны в разделе #Метаданные шифрования ниже.\n\nИногда, например, при шифровании подкачки или раздела /tmp, нет необходимости хранить постоянный мастер-ключ. Можно генерировать новый случайный ключ для каждого нового сеанса без вмешательства пользователя. Это означает, что после размонтирования все файлы, записанные в такой раздел, не смогут быть расшифрованы никем — что в данных конкретных случаях вполне нормально.\n\n"
    },
    {
      "title": "Метаданные шифрования",
      "level": 3,
      "content": "Часто в методах шифрования используются криптографические функции для повышения безопасности самого́ мастер-ключа. При монтировании зашифрованного устройства пароль или ключ пропускаются через эти функции, и только результат их выполнения позволяет разблокировать главный мастер-ключ, который позволит расшифровать данные.\n\nОбычно применяется так называемое «растяжение ключа» («key stretching») к паролю с помощью «функции формирования ключа» («key derivation function»), и полученный таким образом ключ используется для дешифровки главного мастер-ключа (который ранее хранился в зашифрованном виде):\n\n```\n╭┈┈┈┈┈┈┈┈╮                             ╭┈┈┈┈┈┈╮\n ┊ пароль ┊━━━━━⎛     функция      ⎞━━━▶┊ ключ ┊\n ╰┈┈┈┈┈┈┈┈╯  ,──⎝формирования ключа⎠    ╰┈┈┬┈┈┈╯\n ╭──────╮   ╱                              │\n │ соль │──´                               │\n ╰──────╯                                  │\n ╭───────────────────────────╮             ▼          ╭┈┈┈┈┈┈┈┈┈┈┈┈┈╮\n │ зашифрованный мастер-ключ │━━━━━━━━(дешифровка)━━━▶┊ мастер-ключ ┊\n ╰───────────────────────────╯                        ╰┈┈┈┈┈┈┈┈┈┈┈┈┈╯\n```\n\nФункция формирования ключа (например, PBKDF2 или scrypt) специально делается медленной (она применяет много итераций хэш-функции, например, 1000 итераций HMAC-SHA-512), так что узнать пароль путём перебора всех возможных вариантов становится невозможно в разумное время. При обычном использовании эта функция выполняется всего один раз, так что медленная её работа не является проблемой. Также в качестве аргумента функции передаётся дополнительный кусочек данных, так называемая «соль» — она генерируется случайным образом один раз во время начальной настройки шифрования диска и хранится в открытом виде как часть метаданных. Поскольку в разных установках значение соли будет разным, её использование лишает злоумышленников возможности использовать предварительно подготовленные («радужные») таблицы, которые позволили ли бы ускорить подбор пароля, если бы соли не было.\n\nЗашифрованный мастер-ключ можно хранить на диске вместе с зашифрованными данными. Таким образом, конфиденциальность зашифрованных данных полностью зависит от используемого пароля.\n\nДополнительной безопасности можно достичь, если хранить зашифрованный мастер-ключ в отдельном файле, например, на USB-накопителе. Это обеспечивает двухфакторную аутентификацию: для доступа к зашифрованным данным теперь требуется то, что вы знаете (пароль), и то, чем вы владеете (файл ключа).\n\nЕщё один способ реализации двухфакторной аутентификации — дополнение описанной выше схемы получения ключа математическим «комбинированием» пароля с байтовыми данными, считываемыми из одного или нескольких внешних файлов (расположенных на USB-накопителе или подобных устройствах), перед передачей их в функцию формирования ключа. Файлы могут быть любыми, например, обычными изображениями в формате JPEG, что позволит применить #Правдоподобное отрицание. Однако в данном контексте они всё равно называются «файлами ключей».\n\nПосле дешифровки главного мастер-ключа он надёжно хранится в памяти (например, в списке ключей ядра), пока зашифрованный контейнер остаётся примонтированным.\n\nОднако обычно он не используется для (де)шифровки данных на диске напрямую. Например, в случае шифрования поверх файловой системы для каждого файла может создаваться отдельный ключ шифрования. Когда файл читается или изменяется, этот ключ сначала нужно расшифровать с помощью мастер-ключа, после чего он может использоваться для (де)шифровки содержимого файла:\n\n```\n╭┈┈┈┈┈┈┈┈┈┈┈┈┈╮\n                       ┊ мастер-ключ ┊\n   файл на диске:      ╰┈┈┈┈┈┈┬┈┈┈┈┈┈╯\n  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ┐         │\n  ╎╭───────────────╮╎         ▼          ╭┈┈┈┈┈┈┈┈┈┈┈┈╮\n  ╎│ зашифрованный │━━━━(дешифровка)━━━━▶┊ ключ файла ┊\n  ╎│ ключ файла    │╎                    ╰┈┈┈┈┈┬┈┈┈┈┈┈╯\n  ╎╰───────────────╯╎                          │\n  ╎┌───────────────┐╎                          ▼          ┌┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┐\n  ╎│ зашифрованное │◀━━━━━━━━━━━━━━━━━━━━(де/шифровка)━━━▶┊ расшифрованное ┊\n  ╎│ содержимое    │╎                                     ┊ содержимое     ┊\n  ╎│ файла         │╎                                     ┊ файла          ┊\n  ╎└───────────────┘╎                                     └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘\n  └ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n```\n\nАналогичным образом можно использовать отдельный ключ (например, один на папку) для шифрования имён файлов в случае шифрования поверх файловой системы.\n\nПри шифровании блочного устройства используется один мастер-ключ на устройство и, следовательно, на все данные. Некоторые методы позволяют создать несколько паролей для одного устройства, некоторые — нет. Некоторые используют вышеупомянутые функции для защиты мастер-ключа, а другие предоставляют полный контроль над безопасностью ключа пользователю. Два примера объясняются криптографическими параметрами, используемыми dm-crypt в plain или LUKS режимах.\n\nПри сравнении параметров, используемых обоими режимами, можно заметить, что plain-режим dm-crypt имеет параметры, относящиеся к расположению ключа (например, --keyfile-size, --keyfile-offset). Для LUKS они не нужны, поскольку каждое блочное устройство содержит в начале заголовок с метаданными. В заголовке указаны используемый алгоритм шифрования, сам зашифрованный мастер-ключ и параметры для функции формирования ключа. Последние, в свою очередь, задаются опциями при начальном шифровании мастер-ключа (например, --iter-time, --use-random).\n\nПреимущества и недостатки различных техник можно узнать в сравнительной таблице или на конкретных страницах.\n\nСмотрите также:\n\n- Wikipedia:Passphrase\n- Wikipedia:ru:Ключ (криптография)\n- Wikipedia:ru:Управление ключами\n- Wikipedia:ru:Функция формирования ключа\n\n"
    },
    {
      "title": "Алгоритмы и режимы шифрования",
      "level": 3,
      "content": "Алгоритм, преобразующий незашифрованные фрагменты данных в зашифрованные (так называемые «открытый текст» и «шифротекст») и наоборот с использованием заданного ключа шифрования, называется «шифром».\n\nДля шифрования диска используются «блочные шифры», которые работают с блоками данных фиксированной длины, например, 16 байт (128 бит). На момент написания данной статьи наиболее распространёнными шифрами являются:\n\nTable content:\n | размер блока | размер ключа | комментарий\nAES | 128 бит | 128, 192 или 256 бит | одобрен АНБ для защиты информации «SECRET» и «TOP SECRET» правительства США (при использовании ключа размером 192 или 256 бит)\nBlowfish | 64 бита | 32–448 бит | один из первых беспатентных безопасных шифров, который стал общедоступным, поэтому очень хорошо зарекомендовал себя в Linux\nTwofish | 128 бит | 128, 192 или 256 бит | разработан как преемник Blowfish, но не получил столь широкого распространения\nSerpent | 128 бит | 128, 192 или 256 бит | Считается самым безопасным из пяти финалистов конкурса AES[10][11][12].\n\nШифрование/дешифрование сектора (#Базовый принцип) достигается путём разделения его на небольшие блоки, соответствующие размеру блока шифра, и следования определённому набору правил последовательного применения шифра к отдельным блокам (так называемый «режим шифрования»).\n\nПростое применение шифра к каждому блоку отдельно без изменений (так называемый «режим электронной кодовой книги» — «electronic codebook (ECB)») не будет безопасным, так как если одни и те же 16 байт открытого текста будут всегда давать одни и те же 16 байт шифротекста, то злоумышленник сможет легко распознать паттерны в шифротексте, хранящемся на диске.\n\nСамым простым (и распространённым) режимом шифрования, используемым на практике, является «режим сцепления блоков шифротекста» — «cipher-block chaining (CBC)». При шифровании сектора в этом режиме каждый блок данных открытого текста объединяется математическим способом с шифротекстом предыдущего блока перед его шифрованием. Для первого блока, так как перед ним нет предыдущего блока, используется специальный предварительно сгенерированный блок данных, хранящийся вместе с криптографическими метаданными сектора и называемый «вектор инициализации» — «initialization vector (IV)»:\n\n```\n╭─────────────╮\n                                          │вектор       │\n                                          │инициализации│\n                                          ╰───────┬─────╯\n                 ╭  ╠══════════╣       ╭─ключ     │      ┣┉┉┉┉┉┉┉┉┉┉┫\n                 │  ║          ║       ▼          ▼      ┋          ┋         . СТАРТ\n                 ┴  ║\"????????\"║◀━━━(шифр)━━━━━━━(+)━━━━━┋\"Привет, \"┋ блок   ╱╰────┐\n           сектор n ║          ║                         ┋          ┋ 1      ╲╭────┘\n     в файле или на ║          ║──────────────────╮      ┋          ┋         '\n блочном устройстве ╟──────────╢       ╭─ключ     │      ┠┈┈┈┈┈┈┈┈┈┈┨\n                 ┬  ║          ║       ▼          ▼      ┋          ┋\n                 │  ║\"????????\"║◀━━━(шифр)━━━━━━━(+)━━━━━┋\"мир !!! \"┋ блок\n                 │  ║          ║                         ┋          ┋ 2\n                 │  ║          ║──────────────────╮      ┋          ┋\n                 │  ╟──────────╢                  │      ┠┈┈┈┈┈┈┈┈┈┈┨\n                 │  ║          ║                  ▼      ┋          ┋\n                 :  :   ...    :        ...      ...     :   ...    : ...\n\n                      шифротекст                         открытый текст\n                        на диске                         в памяти\n```\n\nПри дешифровке процедура аналогичная, только в обратном порядке.\n\nСтоит обратить внимание на генерацию уникального вектора инициализации для каждого сектора. Самый простой вариант — вычислить его предсказуемым образом из легкодоступного значения, такого как номер сектора. Однако это может позволить злоумышленнику с постоянным доступом к системе выполнить watermarking attack. Чтобы предотвратить это, можно использовать метод под названием «Encrypted salt-sector initialization vector (ESSIV)» для генерации векторов инициализации таким образом, чтобы для потенциального злоумышленника они выглядели совершенно случайными.\n\nСуществует также ряд других, более сложных режимов для шифрования дисков, которые имеют встроенную защиту от таких атак (и, следовательно, не требуют ESSIV). Некоторые из них также могут дополнительно гарантировать подлинность зашифрованных данных (то есть подтвердить, что они не были изменены/повреждены кем-то, кто не имеет доступа к ключу).\n\nСмотрите также:\n\n- Wikipedia:ru:Теория шифрования диска\n- Wikipedia:ru:Блочный шифр\n- Wikipedia:ru:Режим шифрования\n\n"
    },
    {
      "title": "Правдоподобное отрицание",
      "level": 3,
      "content": "Смотрите Wikipedia:ru:Правдоподобное отрицание.\n\n"
    },
    {
      "title": "Сценарии резервного копирования зашифрованного диска",
      "level": 2,
      "content": "Создавайте резервные копии пользовательских данных, чтобы не потерять их. Как правило, резервная копия зашифрованных данных также должна быть зашифрована.\n\n"
    },
    {
      "title": "Шифрование блочного устройства",
      "level": 3,
      "content": "Есть несколько вариантов; можно создать резервную зашифрованного блочного устройства в виде образа, например, /dev/sdx, или создать резервную копию файловой системы внутри зашифрованного контейнера, например, /dev/mapper/dm_name, или создать резервную копию файлов, например, с помощью rsync. В следующих разделах описаны преимущества и недостатки каждого варианта.\n\n"
    },
    {
      "title": "Резервное копирование блочного устройства",
      "level": 4,
      "content": "Резервная копия блочного устройства:\n\n- зашифрована как есть с тем же уровнем безопасности, что и рабочая копия\n- содержит заголовок LUKS\n- всегда имеет такой же размер, как и исходное блочное устройство\n- не позволяет легко использовать расширенные стратегии резервного копирования, такие как инкрементное резервное копирование, сжатие или дедупликация\n- легко восстанавливается на новый диск\n\n"
    },
    {
      "title": "Резервное копирование файловой системы или файлов",
      "level": 4,
      "content": "Резервная копия файловой системы или файлов:\n\n- не зашифрована как есть\n- должна быть зашифрована перед передачей по сети или при сохранении на диск, что требует дополнительных усилий\n- не обязательно шифруется с тем же уровнем безопасности, что и рабочая копия\n- не содержит заголовок LUKS\n- может занимать лишь столько места, сколько занято в файловой системе; смотрите, например, partclone\n- позволяет использовать расширенные стратегии резервного копирования, такие как инкрементное резервное копирование, сжатие или дедупликация\n- требует ручного восстановления контейнера шифрования на новый диск, например, путём восстановления резервной копии заголовка LUKS\n\n"
    },
    {
      "title": "Резервное копирование заголовка LUKS",
      "level": 4,
      "content": "При использовании LUKS можно выполнить резервное копирование заголовков LUKS: может иметь смысл периодически проверять и синхронизировать эти резервные копии, особенно если выполнялся отзыв паролей.\n\nОднако, если у вас есть резервная копия данных и вы хотите восстановить их, можно воссоздать зашифрованный LUKS-раздел с нуля с помощью cryptsetup и затем восстановить данные, поэтому резервное копирование заголовков LUKS менее важно, чем резервное копирование данных.\n\n"
    }
  ]
}