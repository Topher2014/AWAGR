{
  "title": "Sysctl (Русский)",
  "url": "https://wiki.archlinux.org/title/Sysctl_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "sysctl — утилита, предназначенная для управления параметрами ядра на лету (пакет procps-ng из официальных репозиториев). sysctl реализован как часть procfs — виртуальной файловой системы, которую обычно монтируют в /proc/.\n\n"
    },
    {
      "title": "Настройка",
      "level": 2,
      "content": "Файл настроек sysctl может быть создан в /etc/sysctl.d/99-sysctl.conf. Для systemd, /etc/sysctl.d/ и /usr/lib/sysctl.d/ являются drop-in каталогами для sysctl-параметров ядра. Именование и исходный каталог определяют порядок обработки; параметры, обрабатываемые позже, могут отменить предыдущие параметры. Например, параметры из файла /usr/lib/sysctl.d/50-default.conf будут переопределены параметрами с теми же именами из /etc/sysctl.d/50-default.conf и любом файле, обработанном позже из обоих каталогов.\n\nЧтобы вручную загрузить параметры из всех файлов, выполните команду:\n\n```\n# sysctl --system\n```\n\nкоторая также выведет применённую иерархию. Можно указать параметр для явной загрузки только одного файла:\n\n```\n# sysctl --load=файл.conf\n```\n\nДополнительная информация доступна в sysctl.d(5) и the new configuration files.\n\nДоступные для изменения параметры представлены в каталоге /proc/sys/. Например, параметр kernel.sysrq соответствует файлу /proc/sys/kernel/sysrq в файловой системе. Команда sysctl --all отобразит значения всех доступных параметров.\n\nНастройки можно изменить путём редактирования файлов напрямую или вызова утилиты sysctl. Например, чтобы временно включить magic SysRq key:\n\n```\n# sysctl kernel.sysrq=1\n```\n\nилт:\n\n```\n# echo \"1\" > /proc/sys/kernel/sysrq\n```\n\nПодробности о kernel.sysrq доступны в документации ядра.\n\nЧтобы сделать изменения постоянными, добавьте или измените соответствующие строки в /etc/sysctl.d/99-sysctl.conf или другом подходящем файле в каталоге /etc/sysctl.d/.\n\n"
    },
    {
      "title": "Безопасность",
      "level": 2,
      "content": "Смотрите Безопасность#Ядро, а также следующие разделы в данной статье.\n\n"
    },
    {
      "title": "Увеличение длины очереди входящих пакетов",
      "level": 4,
      "content": "После получения пакетов из кольцевого буфера сетевой карты они помещаются в специальную очередь в ядре.\n\nПри использовании высокоскоростных сетевых карт увеличение размера очереди может помочь предотвратить потерю пакетов:\n\n```\nnet.core.netdev_max_backlog = 16384\n```\n\n"
    },
    {
      "title": "Увеличение максимального числа ожидающих соединений",
      "level": 4,
      "content": "Максимальное число входящих соединений, ожидающих приёма (accept) программой, на одном сокете:\n\n```\nnet.core.somaxconn = 8192\n```\n\n"
    },
    {
      "title": "Включение TCP Fast Open",
      "level": 4,
      "content": "TCP Fast Open — это расширение протокола управления передачей (TCP), которое помогает уменьшить задержки в сети, позволяя начать передачу данных сразу при отправке клиентом первого TCP SYN [3]. Значение 3 вместо стандартного 1 включит TCP Fast Open как для входящих, так и для исходящих соединений:\n\n```\nnet.ipv4.tcp_fastopen = 3\n```\n\n"
    },
    {
      "title": "Настройка обработки ожидающих соединений",
      "level": 4,
      "content": "tcp_max_syn_backlog задаёт максимальную длину очереди соединений в состоянии 'Waiting Acknowledgment'.\n\nВ случае DoS-атаки synflood эта очередь может быстро заполниться, и в этот момент сработает TCP SYN cookies, позволяя вашей системе продолжать отвечать на легитимный трафик и позволяя вам получить доступ к блокировке вредоносных IP.\n\nЕсли сервер страдает от перегрузок в пиковое время, можно попробовать немного увеличить это значение:\n\n```\nnet.ipv4.tcp_max_syn_backlog = 8192\n```\n\ntcp_max_tw_buckets — максимальное число сокетов в состоянии TIME_WAIT.\n\nПосле достижения этого числа система начнёт уничтожать сокеты, находящиеся в этом состоянии.\n\nУвеличение этого значения может помочь от простых DoS-атак:\n\n```\nnet.ipv4.tcp_max_tw_buckets = 2000000\n```\n\ntcp_tw_reuse задаёт, должен ли TCP повторно использовать существующее соединение в состоянии TIME-WAIT для нового исходящего соединения, если новая временная метка строго больше самой последней временной метки, записанной для предыдущего соединения.\n\nЭто помогает избежать исчерпания доступных сетевых сокетов:\n\n```\nnet.ipv4.tcp_tw_reuse = 1\n```\n\nУказывает, сколько секунд нужно ждать последнего FIN-пакета, прежде чем сокет будет принудительно закрыт. Это является нарушением спецификации TCP, но необходимо для предотвращения DoS-атак. В Linux 2.2 значение по умолчанию было 180 [4]:\n\n```\nnet.ipv4.tcp_fin_timeout = 10\n```\n\ntcp_slow_start_after_idle, будучи включенным, сбрасывает размер окна по умолчанию в долгоживущих TCP-соединениях, которые длительное время не использовались.\n\nОтключение этой опции приведёт к тому, что размер окна по умолчанию будет применяться только для новых соединений, что может улучшить производительность долгоживущих соединений:\n\n```\nnet.ipv4.tcp_slow_start_after_idle = 0\n```\n\n"
    },
    {
      "title": "Изменение параметров TCP keepalive",
      "level": 4,
      "content": "TCP keepalive — механизм TCP-соединений, который помогает определить потерю связи с другой стороной. TCP посылает запрос keepalive, содержащий нулевые данные, несколько раз после неактивности. Если другая сторона не отвечает, сокет автоматически закрывается. По умолчанию процесс TCP keepalive ожидает активности сокета в течение двух часов (7200 секунд) перед отправкой первого запроса keepalive, а затем повторно отправляет его каждые 75 секунд. Пока связь между сокетами TCP/IP продолжается и активна, пакеты keepalive не нужны.\n\n```\nnet.ipv4.tcp_keepalive_time = 60\nnet.ipv4.tcp_keepalive_intvl = 10\nnet.ipv4.tcp_keepalive_probes = 6\n```\n\n"
    },
    {
      "title": "Включение MTU probing",
      "level": 4,
      "content": "Чем больше maximum transmission unit (MTU), тем выше производительность, но хуже надёжность.\n\nЭто связано с тем, что потерянный пакет означает необходимость повторной передачи большего количества данных, а также с тем, что многие маршрутизаторы в интернете не могут передавать очень длинные пакеты:\n\n```\nnet.ipv4.tcp_mtu_probing = 1\n```\n\nСмотрите https://blog.cloudflare.com/path-mtu-discovery-in-practice/ для более подробной информации.\n\n"
    },
    {
      "title": "TCP timestamps",
      "level": 4,
      "content": "Отключение генерации временных меток в TCP-пакетах уменьшит пики и может дать прирост производительности в гигабитных сетях:\n\n```\nnet.ipv4.tcp_timestamps = 0\n```\n\n"
    },
    {
      "title": "Включение BBR",
      "level": 4,
      "content": "Алгоритм управления перегрузками BBR может помочь достичь более высокой пропускной способности и более низких задержек для интернет-трафика. Сначала загрузите модуль tcp_bbr.\n\n```\nnet.core.default_qdisc = cake\nnet.ipv4.tcp_congestion_control = bbr\n```\n\n"
    },
    {
      "title": "Увеличение диапазона динамических портов",
      "level": 4,
      "content": "Динамические (эфемерные) порты обычно используются в протоколах TCP, UDP и SCTP. Когда клиентское приложение не запрашивает привязку сокета к какому-то конкретному порту, система выдаёт ему произвольный порт из определённого диапазона. В некоторых специфических ситуациях размер этого диапазона может влиять на производительность установки соединения.\n\n```\nnet.ipv4.ip_local_port_range = 30000 65535\n```\n\n"
    },
    {
      "title": "Защита стека TCP/IP",
      "level": 3,
      "content": "Ниже приведён набор параметров для усиления сетевой безопасности ядра для протокола IPv4 и соответствующие параметры IPv6, если существует эквивалент.\n\nДля некоторых сценариев использования, например, при использовании системы в качестве маршрутизатора, могут быть полезны или необходимы и другие параметры.\n\n"
    },
    {
      "title": "Защита TCP SYN cookie",
      "level": 4,
      "content": "Помогает защититься от атак SYN flood. Срабатывает только при достижении значения net.ipv4.tcp_max_syn_backlog. Более подробную информацию можно найти, например, в [6]. Начиная с linux 5.10, это включено по умолчанию.\n\n```\nnet.ipv4.tcp_syncookies = 1\n```\n\n"
    },
    {
      "title": "TCP rfc1337",
      "level": 4,
      "content": "Защита от tcp time-wait assassination hazards, отбрасывание RST-пакетов для сокетов в состоянии time-wait. За пределами Linux поддерживается не очень широко, но соответствует RFC:\n\n```\nnet.ipv4.tcp_rfc1337 = 1\n```\n\n"
    },
    {
      "title": "Reverse path filtering",
      "level": 4,
      "content": "При включении reverse path filtering ядро будет проверять источник пакетов, полученных со всех интерфейсов машины. Это может защитить от злоумышленников, которые используют методы подмены IP-адресов для нанесения вреда.\n\nПо умолчанию стоит значение 0 (без проверки), но systemd поставляет /usr/lib/sysctl.d/50-default.conf, который устанавливает net.ipv4.conf.all.rp_filter в значение 2 (loose mode)[7].\n\nВключение строгого режима:\n\n```\nnet.ipv4.conf.default.rp_filter = 1\nnet.ipv4.conf.all.rp_filter = 1\n```\n\nВзаимосвязь и поведение net.ipv4.conf.default.*, net.ipv4.conf.interface.* и net.ipv4.conf.all.* описаны в ip-sysctl.html.\n\n"
    },
    {
      "title": "Журналирование марсианских пакетов",
      "level": 4,
      "content": "Марсианский пакет (martian packet) — это IP-пакет, который содержит адрес источника или получателя, зарезервированный IANA для специального использования (смотрите Reserved IP addresses).\n\nЧасто марсианские и немаршрутизируемые пакеты могут быть использованы в опасных целях. Запись этих пакетов в журнал для последующей проверки может быть полезной [8]:\n\n```\nnet.ipv4.conf.default.log_martians = 1\nnet.ipv4.conf.all.log_martians = 1\n```\n\n"
    },
    {
      "title": "Отключение перенаправлений ICMP",
      "level": 4,
      "content": "ICMP-пакеты типа 5 (Redirect) помогают оптимизировать маршрутизацию, однако из-за того, что они могут быть легко подделаны злоумышленником, они считаются проблемой безопасности и их лучше отключить. Подробнее об этом можно почитать здесь: What are ICMP redirects? Should they be blocked?\n\nОтключение приёма перенаправлений ICMP:\n\n```\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv4.conf.default.accept_redirects = 0\nnet.ipv4.conf.all.secure_redirects = 0\nnet.ipv4.conf.default.secure_redirects = 0\nnet.ipv6.conf.all.accept_redirects = 0\nnet.ipv6.conf.default.accept_redirects = 0\n```\n\nОтключение отправки перенаправлений ICMP на устройствах, не являющихся маршрутизаторами:\n\n```\nnet.ipv4.conf.all.send_redirects = 0\nnet.ipv4.conf.default.send_redirects = 0\n```\n\n"
    },
    {
      "title": "Игнорирование эхо-запросов ICMP",
      "level": 4,
      "content": "Чтобы система не отвечала на пинги:\n\n```\nnet.ipv4.icmp_echo_ignore_all = 1\nnet.ipv6.icmp.echo_ignore_all = 1\n```\n\n"
    },
    {
      "title": "Виртуальная память",
      "level": 2,
      "content": "Есть несколько ключевых параметров для настройки работы подсистемы виртуальной памяти ядра Linux и записи изменённых (dirty) данных на диск. Подробности в документации ядра Например:\n\n- vm.dirty_ratio = 10\n\n- vm.dirty_background_ratio = 5\n\nКак отмечено в комментариях к параметрам, при установке этих значений необходимо учитывать общий объём оперативной памяти. Например, упрощая, можно взять установленную системную оперативную память вместо доступной памяти:\n\nNote: Смотрите https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/ для более подробной информации.\n\n- Бо́льшие значения могут повысить производительность, но при этом повышается риск потери данных.\n- Установка этого значения в 0 может привести к увеличению задержки на дисках и подвисаниям.\n\nСмотрите https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/ для более подробной информации.\n\n- Согласно общепринятому мнению, установка vm.dirty_ratio на 10% от ОЗУ является разумным значением, если ОЗУ составляет, скажем, 1 ГБ (поэтому 10% — это 100 МБ). Но если машина имеет гораздо больше ОЗУ, скажем, 16 ГБ (10% — это 1.6 ГБ), этот процент оказывается непропропорционально большим, поскольку он превратится в несколько секунд записи на вращающиеся диски. Более разумным значением в этом случае может быть 3 (3% от 16 ГБ — это примерно 491 МБ).\n- Аналогично, установка vm.dirty_background_ratio на значение 5 может быть подходящим вариантом для небольших объёмов памяти, но опять же, учитывайте и настраивайте в соответствии с объёмом памяти конкретной системы.\n\n"
    },
    {
      "title": "Кэш VFS",
      "level": 3,
      "content": "Уменьшение значения параметра кэша virtual file system (VFS) может улучшить отзывчивость системы:\n\n- vm.vfs_cache_pressure = 50\n\n"
    },
    {
      "title": "MDADM",
      "level": 2,
      "content": "Смотрите RAID#Change sync speed limits.\n\n"
    },
    {
      "title": "Периодические маленькие подвисания системы",
      "level": 3,
      "content": "Попробуйте поставить максимальный объём изменённых в памяти данных (dirty bytes) поменьше (в данном примере 4 МиБ):\n\n```\nvm.dirty_background_bytes = 4194304\nvm.dirty_bytes = 4194304\n```\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- sysctl(8) и sysctl.conf(5)\n- Документация ядра: /proc/sys/\n- Документация ядра: IP Sysctl\n- Kernel network parameters for sysctl\n- sysctl-explorer.net – инициатива по облегчению доступа к справочной документации по sysctl в Linux\n- Disable Source Routing - Red Hat Customer Portal\n- SUSE handbook about Security Features in the Kernel\n\n"
    }
  ]
}