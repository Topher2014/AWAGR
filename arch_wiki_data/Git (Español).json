{
  "title": "Git (Español)",
  "url": "https://wiki.archlinux.org/title/Git_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2018-01-08** \n\nArtículos relacionados\n\n- Gitweb\n- Cgit\n- HTTP tunneling#Tunneling Git\n- Subversion\n- Concurrent Versions System\n\nGit es un software de control de versiones diseñado y desarrollado por Linus Torvalds, el creador del kernel de Linux. Git es usado para mantener los paquetes en AUR, y en bastantes proyectos, incluidas las fuentes para el kernel de Linux.\n\n"
    },
    {
      "title": "Instalación",
      "level": 2,
      "content": "Instale el paquete git. Para la versión en desarrollo instale el paquete git-gitAUR. Verifique los requerimientos opcionales al usar git svn, git gui and gitk.\n\n"
    },
    {
      "title": "Programas Gráficos",
      "level": 3,
      "content": "Véase también Clientes gráficos de Git.\n\n- Giggle — Cliente gráfico de git basado en GTK+.\n\n- Git Cola — Elegante y poderosa interfaz de usuario escrita en Python.\n\n- Git Extensions — Interfaz de usuario para git sin necesidad de usar la terminal.\n\n- gitg — Interfaz de GNOME para ver repositorios git.\n\n- git-gui — Interfaz gráfica de usuario basada en Tcl/Tk.\n\n- gitk — Navegador de repositorios git basada en Tcl/Tk.\n\n- QGit — Interfaz gráfica de usuario para navegar revisiones, historia, parches y cambios en archivos.\n\n- RabbitVCS — Grupo de herramientas gráficas hechas para proporcionar acceso simple a su sistema de control de versiones.\n\n- Tig — Interfaz para git basada en ncurses.\n\n- ungit — Proporciona facilidad en git para el usuario sin sacrificar la versatilidad.\n\n- GitHub Desktop — Iterfaz gráfica de usuario basada en Electron, escrita por Github.\n\n"
    },
    {
      "title": "Configuración",
      "level": 2,
      "content": "Para usar Git es necesario usar un usuario y correo electrónico:\n\n```\n$ git config --global user.name  \"Pablo Perez\"\n$ git config --global user.email \"pabloperez@ejemplo.com\"\n```\n\nVea #Trucos y consejos para mas configuraciones.\n\n"
    },
    {
      "title": "Uso",
      "level": 2,
      "content": "Este tutorial muestra como usar Git para controlar y revisar de manera básica distribuida un proyecto.\n\nGit es un sistema de control de versiones, lo cual quiere decir que la historia completa de los cambios hechos a un repositorio es guardada localmente, en una carpeta llamada ./.git en el directorio del proyecto. Los archivos del proyecto que son visibles al usuario constituyen el árbol de trabajo. Estos archivos pueden ser actualizados para coincidir con las revisiones guardadas en ./.git usando los comandos de git (v.g. git checkout), nuevas revisiones pueden ser creadas al modificar estos archivos y ejecutar el comando de git apropiado (e.g. git commit).\n\nVea gitglossary(7) para una definicion mas completa de los terminos usados en este tutorial.\n\nEl proceso de trabajo típico con Git es:\n\n1. Cree un proyecto nuevo o clone un proyecto remoto.\n1. Cree una rama para implementar cambios, y confirme (git commit) esos cambios.\n1. Consolide sus cambios para una mejor organización y entendimiento.\n1. Incorpore (git merge) sus cambios en la rama principal.\n1. (Opcional) Suba (git push) los cambios a un servidor remoto.\n\n"
    },
    {
      "title": "Preparación",
      "level": 4,
      "content": "Inicializar un nuevo repositorio. Esto creara e iniciará ./.git:\n\n```\n$ cd (su proyecto)/\n$ git init\n```\n\nPara guardar cambios en archivos del repositorio, estos tiene que ser agregados al index o área de preparación, esta operación también es conocida como preparar. Cuando se confirman los cambios usando git commit, son los archivos contenidos en el index los que se confirman en la rama actual, y no el contenido del árbol de trabajo.\n\nPara agregar archivos al index del árbol de trabajo:\n\n```\n$ git add archivo1 archivo2\n```\n\nEsto guarda el estado actual de los archivos. Si los archivos son modificados, se puede ejecutar git add de nuevo para \"agregar\" la nueva versión al index.\n\nAgregar todos los archivos:\n\n```\n$ git add .\n```\n\nNote: **ignorar** Vea gitignore(5) para más detalles.\n\n```\n.gitignore\n```\n\n```\n# Archivo que posiblemente borrare\ntest-script\n\n# Ignore todos los archivos .html, excepto 'importante.html'\n*.html\n!important.html\n\n# Ignore todos los archivos recursiva mente en el directorio 'NoIncluir'\nNoIncluir/**\n```\n\nVea gitignore(5) para más detalles.\n\nRemueva un archivo de la área de trabajo (--cached preserva el estado actual de los archivos):\n\n```\n$ git rm (--cached) archivo\n```\n\nRemueva todos los archivos:\n\n```\n$ git rm --cached -r .\n```\n\nO también:\n\n```\n$ git reset HEAD -- .\n```\n\nEn este caso, HEAD es una \"referencia simbólica\" a la revisión actual.\n\nRenombrar un archivo:\n\n```\n$ git mv archivo1 archivo2\n```\n\nListado de archivos:\n\n```\n$ git ls-files\n```\n\nPor defecto, este comando muestra los archivos en la área de trabajo, archivos --cached.\n\n"
    },
    {
      "title": "Confirmar cambios",
      "level": 4,
      "content": "Una vez el contenido a ser guardado esta preparado, confirme ejecutando:\n\n```\n$ git commit -m \"Primera confirmación.\"\n```\n\nEl parámetro -m (--message) es para un mensaje corto, si se omite el editor pre seleccionado abrirá para permitir un mensaje más extenso.\n\nNote: **agregar** \n\n- Siempre confirme cambios pequenos con mensajes significativos.\n- Para agregar todos los archivos modificados al index y confirmarlos en un solo comando, use el parametro -a (--all), \"todo\"):\n\n```\n$ git commit -am \"Primera confirmación.\"\n```\n\nModifique el mensaje de confirmación para la ultima confirmación. Esto también alterara la confirmación con los archivos que se preparado:\n\n```\n$ git commit --amend -m \"Mensaje.\"\n```\n\nAlgunos de los comandos en este articulo toman confirmaciones como argumentos. Una confirmación puede ser identificada por uno de los siguientes métodos:\n\n- El resumen criptográfico de 40 dígitos SHA-1 (usualmente los primeros 7 dígitos son suficientes para identificar la confirmación de manera única)\n- La etiqueta de la confirmación, ya sea la el nombre de la rama o la marca (tag)\n- La etiqueta del HEAD siempre se refiere la rama en la cual se encuentre actualmente (generalmente la ultima modificación de la rama, a menos que se haya usado git checkout para revisar una versión anterior)\n- Cualquier caso anterior más ~ para referirse a una confirmación anterior. Por ejemplo, HEAD~ se refiere a una confirmación antes de HEAD, y HEAD~5 se refiere a cinco confirmaciones antes de HEAD.\n\n"
    },
    {
      "title": "Ver cambios",
      "level": 4,
      "content": "Mostrar diferencias entre confirmaciones:\n\n```\n$ git diff HEAD HEAD~3\n```\n\no diferencias entre área de preparación y el árbol de trabajo:\n\n```\n$ git diff\n```\n\nObtenga un resumen general de los cambios:\n\n```\n$ git status\n```\n\nVer historico de cambios (donde \"-N\" es el numero de confirmaciones anteriores):\n\n```\n$ git log -p (-N)\n```\n\n"
    },
    {
      "title": "Ramas en un repositorio",
      "level": 4,
      "content": "Modificaciones y nuevas características son usualmente examinadas en ramas. Cuando los cambios son satisfactorios se pueden incorporar en la rama principal (master).\n\nCrear una rama, cuyo nombre refleja su propósito:\n\n```\n$ git branch agregar-seccion-ayuda\n```\n\nListado de ramas:\n\n```\n$ git branch\n```\n\nCambiar de rama:\n\n```\n$ git checkout rama\n```\n\nCrear y cambian:\n\n```\n$ git checkout -b rama\n```\n\nIncorporar una rama a la rama principal:\n\n```\n$ git checkout master\n$ git merge rama\n```\n\nLos cambios serán incorporados si no hay conflictos. En caso de haberlos, Git mostrara un mensaje de error, y anotara los archivos en el árbol de trabajo grabando los conflictos. Las anotaciones pueden ser vistas con git diff. Conflictos son resueltos modificando los archivos,removiendo las anotaciones y confirmando la versión final. Vea #Trabajando con fusiones en la parte de abajo.\n\nCuando se haya terminado el trabajo en una rama, bórrela con:\n\n```\n$ git branch -d branch\n```\n\n"
    },
    {
      "title": "Adoptando una buena etiqueta",
      "level": 4,
      "content": "- Cuando se considere contribuir a un proyecto existente, lea y entienda su licencia, ya que esta puede limitar excesivamente la habilidad para modificar el código. Algunas licencias pueden generar disputas sobre la autoría del código.\n- Piense sobre la comunidad del proyecto y que tan bien se puede encajar allí. Para tener un sentimiento del rumbo del proyecto, lea la documentación e incluso el histórico del repositorio.\n- Cuando se solicite incluir (pull) una confirmación, o se suba un parche, mantenga el cambio pequeño, conciso y documentado; esto ayudara a los mantenedores a entender sus cambios y decidir si los incorporan, o para preguntar por una corrección.\n- Si una contribución es rechazada, no se desanime, el proyecto es de ellos. Si es importante, discuta las razones para la contribución tan clara y pacientemente como sea posible: con este procedimiento una solución puede que eventualmente sea posible.\n\n"
    },
    {
      "title": "Clonar un repositorio",
      "level": 4,
      "content": "Para comenzar a contribuir a un proyecto, clone el repositorio de este:\n\n```\n$ git clone lugar directorio\n```\n\nlugar puede ser una ruta o dirección de Internet. Cuando la clonación haya terminado, el lugar sera guardado y solo se necesitara un git pull para actualizar el repositorio.\n\n"
    },
    {
      "title": "Solicitud de cambio",
      "level": 4,
      "content": "Después de hacer algunos cambios, un contribuidor puede preguntarle al autor original de incorporar dichos cambios. Esto se denomina una solicitud de cambio (pull request).\n\nPara obtener (pull):\n\n```\n$ git pull lugar master\n```\n\nEl comando pull combina los comandos recuperar (fetch) y fusionar (merge). Si hay conflictos (v.g. cuando el autor original hizo cambios la mismo tiempo), sera necesario solucionarlos manualmente.\n\nAlternativamente, el autor original puede seleccionar los cambios que quiere incorporar. Usando la opción fetch (y la opción log con un símbolo FETCH_HEAD especial), el contenido de la solicitud puede ser visto antes de ser incorporado:\n\n```\n$ git fetch lugar master\n$ git log -p HEAD..FETCH_HEAD\n$ git merge lugar master\n```\n\n"
    },
    {
      "title": "Usando remotos",
      "level": 4,
      "content": "Remotos son apodos para rastrear repositorios remotos. Una etiqueta es creada definiendo el lugar. Estas etiquetas son usadas para identificar repositorios de frecuente acceso.\n\nCrear un remoto:\n\n```\n$ git remote add etiqueta lugar\n```\n\nRecupere (fetch) un remoto:\n\n```\n$ git fetch etiqueta\n```\n\nMostrar diferencias entre la rama principal y la rama principal del remoto:\n\n```\n$ git log -p master..etiqueta/master\n```\n\nVer remotos del repositorio actual:\n\n```\n$ git remote -v\n```\n\nCuando se define un remoto que es el predecesor de una bifurcación (lideres del proyecto), se define como upstream (versión original).\n\n"
    },
    {
      "title": "Publicar en un repositorio",
      "level": 4,
      "content": "Después de tener acceso para modificar el repositorio, dado por los autores originales, publique (push) sus cambios con:\n\n```\n$ git push lugar rama\n```\n\nCuando se ejecute git clone, se guarda el lugar original y se le da el nombre remoto de origin.\n\nAsi, que lo que típicamente se ejecuta es:\n\n```\n$ git push origin master\n```\n\nSi se usa el parámetro -u (--set-upstream-to), el lugar va a ser guardado y la próxima vez simplemente git push es necesario.\n\n"
    },
    {
      "title": "Trabajando con fusiones",
      "level": 4,
      "content": "Vea Procedimiento para fusionar el el libro de Git para una explicación más extensa para solucionar conflictos en fusiones. Fusiones son generalmente reversibles. Si se desea cancelar una fusión, se puede usar el parámetro --abort (v.g. git merge --abort o git pull --abort).\n\n"
    },
    {
      "title": "Enviar un parche a una lista de correo",
      "level": 4,
      "content": "Si desea enviar parches directamente a una lista de correo, necesita instalar los siguientes paquetes: perl-authen-sasl, perl-net-smtp-ssl y perl-mime-tools.\n\nAsegúrese de tener su usuario y correo electrónica configurado, vea#Configuración.\n\nModifique la configuración de su e-mail:\n\n```\n$ git config --global sendemail.smtpserver smtp.gmail.com\n$ git config --global sendemail.smtpserverport 587\n$ git config --global sendemail.smtpencryption tls\n$ git config --global sendemail.smtpuser foobar@gmail.com\n```\n\nAhora debe ser posible enviar el parche a la lista de correo:\n\n```\n$ git add nombre-archivo\n$ git commit -s\n$ git send-email --to=nombre-lista@servidorlista.org --confirm=always -M -1\n```\n\n"
    },
    {
      "title": "Buscar en el histórico",
      "level": 4,
      "content": "git log mostrará el histórico con confirmaciones, resumen criptográfico, autor, fecha y el mensaje corto. El resumen-criptográfico es el \"nombre del objeto\" de una confirmación, típicamente 40 digitos SHA-1.\n\nPara el histórico con el mensaje extenso (el \"resumen-criptográfico\" puede ser truncado, mientras que se mantenga único):\n\n```\n$ git show (resumen-criptográfico)\n```\n\nBuscar por un modelo en los archivos que están siendo rastreados:\n\n```\n$ git grep modelo\n```\n\nBuscar en archivos terminados con .c y .h:\n\n```\n$ git grep modelo -- '*.[ch]'\n```\n\n"
    },
    {
      "title": "Revisiones para lanzamientos",
      "level": 4,
      "content": "Etiqueta (tag) de confirmaciones para revisiones:\n\n```\n$ git tag 2.14 resumen-criptográfico\n```\n\nEtiquetar se efectúa generalmente para lanzamientos/revisiones pero puede ser cualquier cadena de caracteres. Generalmente etiquetas anotadas son usadas, porque estas se agregan a la base de datos de Git.\n\nEtiquete la confirmación actual con:\n\n```\n$ git tag -a 2.14 -m \"Versión 2.14\"\n```\n\nListado de etiquetas:\n\n```\n$ git tag -l\n```\n\nBorrar una etiqueta:\n\n```\n$ git tag -d 2.08\n```\n\nActualizar etiqueta remota:\n\n```\n$ git push --tags\n```\n\n"
    },
    {
      "title": "Organizando confirmaciones",
      "level": 4,
      "content": "Antes de solicitar cambios en un repositorio, es deseable consolidar/reorganizar las confirmaciones. Esto se puede hacer con git rebase y el parámetro --interactive:\n\n```\n$ git rebase -i resumen-criptográfico\n```\n\nEste comando abrirá un editor de texto con un resumen de todas las confirmaciones en el rango especificado; en el caso del comando anterior, incluyendo la confirmación mas reciente (HEAD) y hasta, pero excluyendo la confirmación resumen-criptográfico. Es posible usar notación de numérica, use por ejemplo HEAD~3, el cual incluirá las ultimas tres confirmaciones:\n\n```\npick d146cc7 Test punto de montaje.\npick 4f47712 Explicación parámetro -o en el readme.\npick 8a4d479 Re nombrado de la documentación.\n```\n\nModificando la acción en la primera columna dictara como se hará la reorganización. Las opciones son:\n\n- pick — Use esta confirmación como esta (por defecto).\n- edit — Edite archivos y/o mensaje de confirmación.\n- reword — Edite mensaje de confirmación.\n- squash — Fusión/envuelva con la confirmación anterior.\n- fixup — Fusión/envuelva con la confirmación anterior descartando su mensaje.\n\nLas confirmaciones pueden ser re ordenadas o borradas del histórico (pero sea muy cuidadoso). Después de modificar un archivo, Git ejecutara la acción especificada; si se le pregunta resolver problemas, solucionelos y continue con git rebase --continue o cancele la reorganización con el comando git rebase --abort.\n\n"
    },
    {
      "title": "Usar git-config",
      "level": 3,
      "content": "Git lee su configuración de unos pocos archivos de configuración:\n\n- Cada repositorio contiene un archivo .git/config para configuracion especifica.\n- Cada usuario tiene un archivo $HOME/.gitconfig para configuraciones por defecto.\n- /etc/gitconfig es usado para configuraciones por defecto a nivel del sistema.\n\nEstos archivos pueden ser modificados directamente, pero la manera recomendada para hacerlo es con git config, como se muestra en el siguiente ejemplo:\n\nListado de las siguientes variables establecidas:\n\n```\n$ git config {--local,--global,--system} --list\n```\n\nEstablezca el editor de texto por defecto a vim o nano:\n\n```\n$ git config --global core.editor \"nano -w\"\n```\n\nEstablezca la acción de publicar por defecto:\n\n```\n$ git config --global push.default simple\n```\n\nEstablezca una herramienta diferente para git difftool (meld por defecto):\n\n```\n$ git config --global diff.tool vimdiff\n```\n\nVea git-config(1) y Configuración de Git para más información.\n\n"
    },
    {
      "title": "Acelerar verificación",
      "level": 3,
      "content": "Es deseable evitar tener que iniciar sesión interactiva mente en cada publicación al servidor Git.\n\n- Si se esta usando verificación con llaves SSH, use el agente de SSH. Vea tambien SSH#Acelerando SSh y SSH#Mantener la sesión activa.\n- Si se esta usando verificación con usuario y contrasena, cambie a llaves de SSH si el servidor es compatible con SSH. De otra manera intente con git-credential-cache o git-credential-store.\n\n"
    },
    {
      "title": "Valores por defecto del protocolo",
      "level": 3,
      "content": "Si se esta usando una conexión multiplexada, Git por SSH puede ser más rápido que por HTTPS. Algunos servidores (como AUR), solo admiten publicar con SSH. Por ejemplo, la siguiente configuración establecerá Git sobre SSH para cualquier repositorio alojado en AUR.\n\n```\n~/.gitconfig\n```\n\n```\n[url \"ssh://aur@aur.archlinux.org/\"]\n\tinsteadOf = https://aur.archlinux.org/\n\tinsteadOf = http://aur.archlinux.org/\n\tinsteadOf = git://aur.archlinux.org/\n```\n\n"
    },
    {
      "title": "Servidor Git",
      "level": 2,
      "content": "Como configurar la conexión a diferentes repositorios dependiendo en el protocolo usado.\n\n"
    },
    {
      "title": "SSH",
      "level": 3,
      "content": "Para usar el protocolo SSH, primero genere una llave publica; para ello siga la guía en llaves SSH. Para montar un servidor SSH, siga la guie en SSH.\n\nCon un servidor SSH funcional y llaves generadas, copie el contenido de ~/.ssh/id_rsa.pub a ~/.ssh/authorized_keys (asegúrese que sea una sola linea). Ahora puede acceder al repositorio Git ejecutando:\n\n```\n$ git clone usuario@ejemplo.com:mi_repositorio.git\n```\n\nAhora SSH le hará una pregunta de si/no, si se tiene la configuración StrictHostKeyChecking (por d efecto). Teclee yes seguido de Intro. Ahora se debe tener acceso al repositorio. Gracias a que la configuración es con SSH también debe tener derecho para hacer confirmaciones.\n\nPara modificar un repositorio existente para usar SSH, el lugar remoto debe ser re-definido:\n\n```\n$ git remote set-url origin git@localhost:mi_repositorio.git\n```\n\nConexiones en un puerto diferente al 22 pueden ser configuradas en base a cada servidor, en /etc/ssh/ssh_config o ~/.ssh/config. Para configurar puertos para un repositorio (en este ejemplo 443):\n\n```\n.git/config\n```\n\n```\n[remote \"origin\"]\n    url = ssh://usuario@ejemplo.com:443/~mi_repositorio/repo.git\n```\n\nEs posible proteger incluso más la cuenta de SSH del usuario, aceptando solo comandos de descarga (pull) o de publicación (push) para ese usuario. Esto se hace reemplazando la shell de inicio de sesión por defecto con git-shell. Descripción en Git en el servidor.\n\n"
    }
  ]
}