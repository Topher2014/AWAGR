{
  "title": "Accessibility (日本語)",
  "url": "https://wiki.archlinux.org/title/Accessibility_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "身体的または視覚的なハンディキャップを持っているユーザーのためにアクセシビリティを提供する方法は様々なものがあります。しかしながら、デスクトップ環境を使わない場合、きちんと使えるようにするまで設定に多少の手直しが必要になります。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 デスクトップ環境\n- 2 身体支援 2.1 キーボードの操作 2.1.1 コンソール 2.1.1.1 スティッキーキー 2.1.2 グラフィカル環境非依存 2.2 マウスの操作 2.2.1 グラフィカル環境非依存 2.2.1.1 ボタンのマッピング\n- 3 視覚支援 3.1 テキスト読み上げ 3.2 コンソールと仮想ターミナルエミュレータ\n- 4 問題\n- 5 アクセシビリティの無効化\n\n- 2.1 キーボードの操作 2.1.1 コンソール 2.1.1.1 スティッキーキー 2.1.2 グラフィカル環境非依存\n- 2.2 マウスの操作 2.2.1 グラフィカル環境非依存 2.2.1.1 ボタンのマッピング\n\n- 2.1.1 コンソール 2.1.1.1 スティッキーキー\n- 2.1.2 グラフィカル環境非依存\n\n- 2.1.1.1 スティッキーキー\n\n- 2.2.1 グラフィカル環境非依存 2.2.1.1 ボタンのマッピング\n\n- 2.2.1.1 ボタンのマッピング\n\n- 3.1 テキスト読み上げ\n- 3.2 コンソールと仮想ターミナルエミュレータ\n\n"
    },
    {
      "title": "デスクトップ環境",
      "level": 2,
      "content": "最近のデスクトップ環境は拡張機能のセットが付いており、その中にアクセシビリティのオプションを設定するツールも入っています。大抵は、'アクセシビリティ'とかそれぞれの入力デバイス (例: 'キーボード'や'マウス') の設定にオプションが存在します。\n\n"
    },
    {
      "title": "身体支援",
      "level": 2,
      "content": "音声認識については、音声認識を見て下さい。\n\n"
    },
    {
      "title": "キーボードの操作",
      "level": 3,
      "content": "点字については、TalkingArch を見て下さい。\n\n"
    },
    {
      "title": "コンソール",
      "level": 4,
      "content": "TTY でスティッキーキーを有効にするには、使用するキーのキーコードを知る必要があります。キーコードは xorg-xev や xkeycaps などのツールで確認することが可能です。または、(現在のキーマップが正しければ) dumpkeys の出力を調査することもできます。\n\n例えば、Logitech Ultra-X における修飾キーのキーコードは以下の通りです:\n\n```\nLCtrl = 29\nLShift = 42\nLAlt = 56\nRShift = 54\nRCtrl = 97\n```\n\n次に、dumpkeys を使ってキーコードの範囲を確認します:\n\n```\n# dumpkeys | head -1\nkeymaps 0-63\n```\n\n適当な名前 (例: \"stickyKeys\") で新しいファイルを作成して、好きなエディタを使って先に確認した情報と必要なキーの機能を組み合わせます。\n\n上に書かれたキーコードの場合、以下のようになります:\n\n```\nkeymaps 0-63\nkeycode 29 = SCtrl\nkeycode 42 = SShift\nkeycode 56 = SAlt\nkeycode 54 = SShift\nkeycode 97 = SCtrl\n```\n\nここで、修飾キーの前の \"S\" という文字はそのキーのスティッキーバージョンを使用することを示しています。\n\n次のコマンドを実行して新しいマッピングをロード:\n\n```\n# loadkeys ./stickyKeys\n```\n\n結果に満足したら、適当なディレクトリにファイルを移動して、起動時にロードされるようにします。上記のコマンドを /etc/rc.local に記述するか (古い方法)、または systemd のサービスを使います (推奨される方法)。\n\nsystemd の場合、サービスファイルは以下のようになります:\n\n```\n[Unit]\nDescription=\"load custom keymap (sticky keys)\"\n \n[Service]\nType=oneshot\nExecStart=/usr/bin/loadkeys /path/to/stickyKeys\nStandardInput=tty\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target emergency.target rescue.target\n```\n\n最後にファイル (例: loadkeys.service) を /usr/lib/systemd/system/ に移動して次を実行して有効にします:\n\n```\n# systemdctl enable loadkeys\n```\n\n"
    },
    {
      "title": "グラフィカル環境非依存",
      "level": 4,
      "content": "One method of enabling desktop environment-independent accessibility function is by passing it through X, given that it is build with XKB support. This can be done by setting parameters for the X server, as specified in its man page:\n\n```\n[+-]accessx [ timeout [ timeout_mask [ feedback [ options_mask ] ] ] ]\n              enables(+) or disables(-) AccessX key sequences (Sticky Keys).\n\n-ardelay milliseconds\n              sets the autorepeat delay (length of time in milliseconds  that\n              a key must be depressed before autorepeat starts).\n\n-arinterval milliseconds\n              sets  the  autorepeat  interval (length of time in milliseconds\n              that should elapse between autorepeat-generated keystrokes).\n```\n\n上記のパラメータは ~/.xserverrc ファイルに記述してください (ファイルは作成する必要があるかもしれません)。\n\nFor example, to enable Sticky Keys without timeout and without audible or visible feedback, the following can be used:\n\n```\nif [ -z \"$XDG_VTNR\" ]; then\n  exec /usr/bin/X -nolisten tcp \"$@\" +accessx 0 0x1e 0 0xcef\nelse\n  exec /usr/bin/X -nolisten tcp \"$@\" vt$XDG_VTNR +accessx 0 0x1e 0 0xcef\nfi\n```\n\nNote that once X has started, e.g. by executing startx, it still requires you to press the shift key 5 times to enable Sticky Keys. Unfortunately, this is needed each time X starts. Alternatively, a script can be used to automate this process.\n\nSimilar to most implementations, Sticky Keys can be disabled by pressing a modifier key and any other key at the same time.\n\n"
    },
    {
      "title": "グラフィカル環境非依存",
      "level": 4,
      "content": "xmodmap を使うことで、グラフィカル環境に依存しない形でマウスボタンに機能をマッピングすることができます。その場合、xorg-xev などのツールによってマウスの物理的なボタンがどのように認識されて読み込まれているのか確かめる必要があります。通常、左・中・右の物理ボタンが順番に読み込まれます。\n\nOnce you have acquired these, continue by creating a configuration file on a suitable location, e.g. ~/.mousekeys. Next, open the file with your favourite editor, and write the keyword pointer = followed by an enumeration of the previously-found number of mouse buttons.\n\nFor example, a three button mouse with a scroll wheel is able to provide five physical actions: left, middle, and right click, as well as scroll up and scroll down. This can be mapped to the same functions by using the following line in the configuration file:\n\n```\npointer = 1 2 3 4 5\n```\n\nHere, the location will tell the action required to perform an internal mouse-button function. For example, a mapping for left-handed people (left- and right button switched) might look like\n\n```\npointer = 3 2 1 4 5\n```\n\n設定が完了したら xmodmap を実行してマッピングをテストできます:\n\n```\n$ xmodmap ~/.mousekeys\n$ xmodmap -pp\n```\n\n設定に満足したら、~/.xinitrc に上記の最初の行を記述することで起動時に有効にできます。\n\n"
    },
    {
      "title": "視覚支援",
      "level": 2,
      "content": "身体支援と同じように、最近のデスクトップ環境にはシステムの視覚的な部分を調整できる拡張機能のセットがあります。大抵は、'アクセシビリティ'や'視覚支援'というようなところにオプションがあります。また、個別のアプリケーションの設定に有用なオプションがある場合もあります。\n\n"
    },
    {
      "title": "テキスト読み上げ",
      "level": 3,
      "content": "テキスト読み上げを見て下さい。\n\n"
    },
    {
      "title": "コンソールと仮想ターミナルエミュレータ",
      "level": 3,
      "content": "- /etc/vconsole.conf を編集。\n- ~/.Xresources を編集。\n\n"
    },
    {
      "title": "問題",
      "level": 2,
      "content": "- Wine, VirtualBox, QEMU など、ソフトウェアレイヤーを迂回するソフトウェアは入力デバイスの設定を認識しません。\n\n"
    },
    {
      "title": "アクセシビリティの無効化",
      "level": 2,
      "content": "アクセシビリティが不要で、少しでもプロセスを節約したければ、 NO_AT_BRIDGE=1とGTK_A11Y=noneを設定し、 systemctl --user mask at-spi-dbus-busを実行します。\n\n"
    }
  ]
}