{
  "title": "Joystick (日本語)",
  "url": "https://wiki.archlinux.org/title/Joystick_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "ゲームパッドを Linux で使うのには少し手間がかかるかもしれません。サポートが薄いためではなく、あなたのゲームパッドを動かすのにロードすべきモジュールを見つける必要があり、そしてそれがわかりづらいことがあるからです。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 ゲームパッド入力システム\n- 2 必要なモジュールの確認 2.1 アナログデバイスのモジュールのロード 2.2 USB ゲームパッド\n- 3 設定のテスト 3.1 Joystick API 3.2 evdev API\n- 4 デッドゾーンとキャリブレーションの設定 4.1 Wine のデッドゾーン 4.2 Xorg のデッドゾーン 4.3 Joystick API のデッドゾーン 4.4 evdev API のデッドゾーン\n- 5 ゲームパッドのマウス操作を無効にする\n- 6 ゲームパッドでキーストロークを送る 6.1 X.org\n- 7 特定のデバイス 7.1 ダンスパッド 7.2 Logitech Thunderpad Digital 7.3 Nintendo Gamecube コントローラー 7.4 PlayStation 3/4 コントローラー 7.4.1 Bluetooth で接続 7.5 iPEGA-9017s などの Bluetooth ゲームパッド 7.6 Steam コントローラー 7.6.1 Wine 7.7 Xbox 360 コントローラー 7.7.1 SteamOS の xpad 7.7.2 xboxdrv 7.7.2.1 xboxdrv で2つのコントローラーを使う 7.7.2.2 Xbox 360 コントローラーに偽装する 7.7.2.2.1 USB で接続した Playstation 3 コントローラー 7.7.2.2.2 Bluetooth で接続した Playstation 3 コントローラー 7.7.2.2.3 udev ルールを作成する 7.7.2.2.4 Playstation 2 アダプタ 7.7.2.2.5 Logitech Dual Action 7.7.2.2.6 Playstation 4 コントローラー\n- 8 ヒントとテクニック 8.1 ネットワークを介して Gamepad を使う\n- 9 トラブルシューティング 9.1 ゲームパッドでマウスが動く 9.2 FNA/SDL ベースのゲームでゲームパッドが機能しない 9.3 ゲームパッドがどのプログラムからも認識されない 9.4 Steam コントローラーがペアリングできない\n\n- 2.1 アナログデバイスのモジュールのロード\n- 2.2 USB ゲームパッド\n\n- 3.1 Joystick API\n- 3.2 evdev API\n\n- 4.1 Wine のデッドゾーン\n- 4.2 Xorg のデッドゾーン\n- 4.3 Joystick API のデッドゾーン\n- 4.4 evdev API のデッドゾーン\n\n- 6.1 X.org\n\n- 7.1 ダンスパッド\n- 7.2 Logitech Thunderpad Digital\n- 7.3 Nintendo Gamecube コントローラー\n- 7.4 PlayStation 3/4 コントローラー 7.4.1 Bluetooth で接続\n- 7.5 iPEGA-9017s などの Bluetooth ゲームパッド\n- 7.6 Steam コントローラー 7.6.1 Wine\n- 7.7 Xbox 360 コントローラー 7.7.1 SteamOS の xpad 7.7.2 xboxdrv 7.7.2.1 xboxdrv で2つのコントローラーを使う 7.7.2.2 Xbox 360 コントローラーに偽装する 7.7.2.2.1 USB で接続した Playstation 3 コントローラー 7.7.2.2.2 Bluetooth で接続した Playstation 3 コントローラー 7.7.2.2.3 udev ルールを作成する 7.7.2.2.4 Playstation 2 アダプタ 7.7.2.2.5 Logitech Dual Action 7.7.2.2.6 Playstation 4 コントローラー\n\n- 7.4.1 Bluetooth で接続\n\n- 7.6.1 Wine\n\n- 7.7.1 SteamOS の xpad\n- 7.7.2 xboxdrv 7.7.2.1 xboxdrv で2つのコントローラーを使う 7.7.2.2 Xbox 360 コントローラーに偽装する 7.7.2.2.1 USB で接続した Playstation 3 コントローラー 7.7.2.2.2 Bluetooth で接続した Playstation 3 コントローラー 7.7.2.2.3 udev ルールを作成する 7.7.2.2.4 Playstation 2 アダプタ 7.7.2.2.5 Logitech Dual Action 7.7.2.2.6 Playstation 4 コントローラー\n\n- 7.7.2.1 xboxdrv で2つのコントローラーを使う\n- 7.7.2.2 Xbox 360 コントローラーに偽装する 7.7.2.2.1 USB で接続した Playstation 3 コントローラー 7.7.2.2.2 Bluetooth で接続した Playstation 3 コントローラー 7.7.2.2.3 udev ルールを作成する 7.7.2.2.4 Playstation 2 アダプタ 7.7.2.2.5 Logitech Dual Action 7.7.2.2.6 Playstation 4 コントローラー\n\n- 7.7.2.2.1 USB で接続した Playstation 3 コントローラー\n- 7.7.2.2.2 Bluetooth で接続した Playstation 3 コントローラー\n- 7.7.2.2.3 udev ルールを作成する\n- 7.7.2.2.4 Playstation 2 アダプタ\n- 7.7.2.2.5 Logitech Dual Action\n- 7.7.2.2.6 Playstation 4 コントローラー\n\n- 8.1 ネットワークを介して Gamepad を使う\n\n- 9.1 ゲームパッドでマウスが動く\n- 9.2 FNA/SDL ベースのゲームでゲームパッドが機能しない\n- 9.3 ゲームパッドがどのプログラムからも認識されない\n- 9.4 Steam コントローラーがペアリングできない\n\n"
    },
    {
      "title": "ゲームパッド入力システム",
      "level": 2,
      "content": "Linux には異なる2つのゲームパッドの入力システムが存在します。オリジナルの 'Joystick' インターフェイスと新しい 'evdev' ベースのインターフェイスです。\n\n/dev/input/jsX は 'Joystick' API インターフェイスに /dev/input/event* は 'evdev' インターフェイス (こちらにはマウスやキーボードなど他の入力デバイスも含まれます) にそれぞれマップされています。また、これらのデバイスのシンボリックリンクが /dev/input/by-id/ と /dev/input/by-path/ に存在し、古い 'Joystick' API には -joystick という名前が付き、'evdev' には -event-joystick という名前が付きます。\n\nほとんどの新しいゲームは 'evdev' インターフェイスをデフォルトで使います。'evdev' インターフェイスの方がボタンや軸の詳しい情報を得ることができ、フォースフィードバックもサポートしているためです。\n\nSDL1.x はデフォルトで 'evdev' インターフェイスを使用しますが SDL_JOYSTICK_DEVICE=/dev/input/js0 環境変数を設定することで 'Joystick' API を使うように SDL を強制させることができます。これは X3 などのゲームで役に立ちます。SDL2.x は新しい 'evdev' インターフェイスだけをサポートしています。\n\n"
    },
    {
      "title": "必要なモジュールの確認",
      "level": 2,
      "content": "ゲームポートやプロプライエタリな USB プロトコルを使用する、旧時代のゲームパッドを使うというのでなければ、一般的な USB ヒューマンインターフェイスデバイス (HID) モジュールだけで足ります。\n\nLinux における全てのゲームパッド関連のモジュールの広範な外観を見るには、Linux カーネルのソースを紐解く必要があります -- 特に Documentation セクションがそれです。残念ながら、pacman のカーネルパッケージには必要なドキュメントが含まれていません。カーネルソースをダウンロードした場合、Documentation/input/joystick.txt を見て下さい。また、kernel.org から使用しているカーネルの \"cgit\" (git フロントエンド) リンクをクリックして、上部の \"tree\" リンクをクリックすることでカーネルのソースツリーをブラウズすることができます。こちらは 最新カーネルのドキュメント のリンクです。\n\nMicrosoft Sidewinder コントローラー (sidewinder) や Logitech デジタルコントローラー (adi) など、特定のモジュールを必要とするゲームパッドも存在します。多くの古いゲームパッドはシンプルな analog モジュールで動作します。サウンドカードによるゲームポートにゲームパッドを接続している場合、サウンドカードドライバーをロードする必要があります - しかしながら、カードによっては、Soundblaster Live など、特定のゲームポートドライバーを持っているものもあります (emu10k1-gp)。古い ISA サウンドカードは ns558 モジュールを必要とします。これは標準のゲームポートモジュールです。\n\nLinux でゲームパッドを動作させるのに関連するモジュールは多々あるため、ここでは全てを説明することはできません。詳細については上記のドキュメントを見るようにしてください。\n\n"
    },
    {
      "title": "アナログデバイスのモジュールのロード",
      "level": 3,
      "content": "ゲームポートのモジュール (ns558, emu10k1-gp, cs461x, など)、ゲームパッドのモジュール (analog, sidewinder, adi, など)、そしてカーネルジョイスティックデバイスドライバー (joydev) をロードする必要があります。これらを /etc/modules-load.d/ のファイルに追加するか、modprobe してください。gameport モジュールは他のモジュールの依存モジュールとして、自動でロードされるはずです。\n\n"
    },
    {
      "title": "USB ゲームパッド",
      "level": 3,
      "content": "USB を動作させて、ジョイスティックドライバーを modprobe する必要があります。usbhid と joydev です。USB マウスやキーボードを使っている場合、usbhid は既にロードされるので joydev モジュールだけをロードしてください。\n\n"
    },
    {
      "title": "設定のテスト",
      "level": 2,
      "content": "モジュールがロードされたら、新しいデバイスが認識されるはずです: /dev/input/js0。また、/dev/input/by-id ディレクトリに -event-joystick で終わるファイルが作られます。デバイスを cat することで動作するか確認できます。スティックを動かして、全てのボタンを押して下さい。画面に文字化けが表示されるはずです。\n\nWine での確認とテストは基本的に wine control joy.cpl で両方できます。\n\n"
    },
    {
      "title": "Joystick API",
      "level": 3,
      "content": "Joystick API をテストするアプリケーションはたくさんあります。joyutils パッケージの jstest が一番シンプルなアプリケーションです。一行では設定できないほどの多数のボタンや軸がある場合や、パッドに加速度センサが付いている場合は (何も起こってない時も新しいイベントを送り続けます) グラフィカルツールを使って下さい。KDE4 にはシステム設定の入力デバイスパネルにテスト用のツールが含まれています。また、jstest-gtk-gitAUR を使うこともできます。\n\njstest の使い方はとても簡単です。jstest /dev/input/js0 と実行すると軸 (倒していない状態で {-32767,32767}) とボタンの状態が全て出力されます。\n\njstest-gtk を実行すると、接続されているゲームパッドのリストが表示されるので、どれか一つを選択して Properties を押して下さい。\n\n"
    },
    {
      "title": "evdev API",
      "level": 3,
      "content": "新しい 'evdev' API は SDL2 のゲームパッドテストアプリケーションや community リポジトリに入っている evtest を使うことでテストできます。sdl2-jstest-gitAUR をインストールしてから sdl2-jstest --test 0 を実行してください。複数のコントローラーを接続している場合に他のコントローラーの ID を取得したいときは sdl2-jstest --list を使います。\n\nデバイスのフォースフィードバックをテストするには、linuxconsole パッケージに含まれている fftest を使って下さい:\n\n```\n$ fftest /dev/input/by-id/usb-*event-joystick\n```\n\n"
    },
    {
      "title": "デッドゾーンとキャリブレーションの設定",
      "level": 2,
      "content": "アナログ入力のデッドゾーンを設定したい (または完全にデッドゾーンを削除したい) ときは、xorg (マウス・キーボードエミュレート用) と Joystick API と evdev API で別に設定する必要があります。\n\n"
    },
    {
      "title": "Wine のデッドゾーン",
      "level": 3,
      "content": "以下のレジストリエントリを追加して 0 から 10000 までの値に設定してください (全ての軸に影響します):\n\n```\nHKEY_CURRENT_USER\\Software\\Wine\\DirectInput\\DefaultDeadZone\n```\n\nソース: UsefulRegistryKeys\n\n"
    },
    {
      "title": "Xorg のデッドゾーン",
      "level": 3,
      "content": "/etc/X11/xorg.conf.d/51-joystick.conf に以下のような行を追加してください (ファイルが存在しない場合、作成してください):\n\n```\n/etc/X11/xorg.conf.d/51-joystick.conf\n```\n\n```\nSection \"InputClass\"\n    Option \"MapAxis1\" \"deadzone=1000\"\nEndSection\n```\n\n1000 はデフォルトの値で、0 から 30000 の間で設定できます。軸番号を取得する方法はこの記事の #設定のテスト セクションを参照。問題の軸で既にオプションを設定している場合は、スペースで区切ったパラメータの最後に deadzone=value を入力してください。\n\n"
    },
    {
      "title": "Joystick API のデッドゾーン",
      "level": 3,
      "content": "一番簡単な方法は jstest-gtk-gitAUR の jstest-gtk を使うことです。編集したいコントローラーを選択して、ダイアログの下にある Calibration ボタンをクリックしてください (Start Calibration をクリックしてはいけません)。デッドゾーンの中心を指定する CenterMin と CenterMax の値や、デッドゾーンの終末を指定する RangeMin と RangeMax を設定します。キャリブレーション設定はアプリケーションがデバイスを開いたときに適用されるので、ゲームを再起動する必要があります。\n\nデッドゾーンを設定したら jscal を使って新しい値をシェルスクリプトに出力してください:\n\n```\n$ jscal -p /dev/input/jsX > jscal.sh # replace X with your joystick's number \n$ chmod +x jscal.sh\n```\n\nそして udev ルールを作成して (例えば /etc/udev/rules.d/85-jscal.rules) コントローラーを接続した時に自動的にスクリプトが実行されるようにします:\n\n```\nSUBSYSTEM==\"input\", ATTRS{idVendor}==\"054c\", ATTRS{idProduct}==\"c268\", ACTION==\"add\", RUN+=\"/usr/bin/jscal.sh\"\n```\n\nidVendor と idProduct を取得するには udevadm info --attribute-walk --name /dev/input/jsX を使って下さい。\n\n複数のコントローラーを使用する場合は `/dev/input/by-id/*-joystick` デバイス名を使います。\n\n"
    },
    {
      "title": "evdev API のデッドゾーン",
      "level": 3,
      "content": "evdev API のキャリブレーションを変更できるスタンドアロンのアプリケーションは存在しません。ただし VDrift ゲームと一緒に配布されている G25manage を使うことでセンターデッドゾーンを変更できます。\n\nG25manage を入手する一番簡単な方法は VDrift の github を開いて、全てのファイルをダウンロードして make を使ってビルドすることです。\n\nビルドしたら、次のコマンドでデバイスの設定を確認できます:\n\n```\n$ ./G25manage --showcalibration /dev/input/by-id/usb-*-event-joystick\n```\n\n軸のデッドゾーンを変更するには、次のコマンドを使います:\n\n```\n$ ./G25manage --evdev /dev/input/by-id/usb-*-event-joystick --axis 0 --deadzone 0\n```\n\nコントローラーが接続されたときに自動的に設定を行いたいときは udev ルールを使って下さい。\n\nカーネルの中では、値の名前は flatness となっており、EVIOCSABS ioctl を使って設定します。\n\nデフォルト設定は以下のようになります:\n\n```\n$ ./G25manage --showcalibration /dev/input/by-id/usb-Madcatz_Saitek_Pro_Flight_X-55_Rhino_Stick_G0000090-event-joystick\n```\n\n```\nSupported Absolute axes:\n   Absolute axis 0x00 (0) (X Axis) (min: 0, max: 65535, flatness: 4095 (=6.25%), fuzz: 255)\n   Absolute axis 0x01 (1) (Y Axis) (min: 0, max: 65535, flatness: 4095 (=6.25%), fuzz: 255)\n   Absolute axis 0x05 (5) (Z Rate Axis) (min: 0, max: 4095, flatness: 255 (=6.23%), fuzz: 15)\n   Absolute axis 0x10 (16) (Hat zero, x axis) (min: -1, max: 1, flatness: 0 (=0.00%), fuzz: 0)\n   Absolute axis 0x11 (17) (Hat zero, y axis) (min: -1, max: 1, flatness: 0 (=0.00%), fuzz: 0)\n```\n\n以下のようにすることで適切な設定ができます (他の軸でも同じコマンドを実行してください):\n\n```\n$ ./G25manage --evdev /dev/input/by-id/usb-Madcatz_Saitek_Pro_Flight_X-55_Rhino_Stick_G0000090-event-joystick --axis 0 --deadzone 512\n```\n\n```\nEvent device file: /dev/input/by-id/usb-Madcatz_Saitek_Pro_Flight_X-55_Rhino_Stick_G0000090-event-joystick\n Axis index to deal with: 0\n New dead zone value: 512\n Trying to set axis 0 deadzone to: 512\n   Absolute axis 0x00 (0) (X Axis) Setting deadzone value to : 512\n (min: 0, max: 65535, flatness: 512 (=0.78%), fuzz: 255)\n```\n\n"
    },
    {
      "title": "ゲームパッドのマウス操作を無効にする",
      "level": 2,
      "content": "コントローラーを使ってゲームを遊びたいとき、ゲームパッドによるマウスカーソルの操作を無効にすると良いかもしれません。無効にするには、以下のように /etc/X11/xorg.conf.d/51-joystick.conf を編集してください (ファイルが存在しない場合は作成してください):\n\n```\n/etc/X11/xorg.conf.d/51-joystick.conf\n```\n\n```\nSection \"InputClass\"\n        Identifier \"joystick catchall\"\n        MatchIsJoystick \"on\"\n        MatchDevicePath \"/dev/input/event*\"\n        Driver \"joystick\"\n        Option \"StartKeysEnabled\" \"False\"       #Disable mouse\n        Option \"StartMouseEnabled\" \"False\"      #support\nEndSection\n```\n\n"
    },
    {
      "title": "ゲームパッドでキーストロークを送る",
      "level": 2,
      "content": "qjoypadAUR や antimicroAUR[リンク切れ: パッケージが存在しません] などゲームパッドでキー操作するプログラムがあり、どれも X.org の設定をせずとも問題なく動作します。\n\n"
    },
    {
      "title": "X.org",
      "level": 3,
      "content": "Xorg の再起動をあまりしないような環境では、X の起動時にのみロードされる静的な設定なので良い設定手段でしょう。\n\nまず、xf86-input-joystickAUR をインストールします。そして、以下のように /etc/X11/xorg.conf.d/51-joystick.conf を作成:\n\n```\nSection \"InputClass\"\n  Identifier \"Joystick hat mapping\"\n  Option \"StartKeysEnabled\" \"True\"\n  #MatchIsJoystick \"on\"\n  Option \"MapAxis5\" \"keylow=113 keyhigh=114\"\n  Option \"MapAxis6\" \"keylow=111 keyhigh=116\"\n EndSection\n```\n\n"
    },
    {
      "title": "特定のデバイス",
      "level": 2,
      "content": "ほとんどのゲームパッド (特に USB を使っているコントローラー) は何も設定しなくても動作しますが、ゲームパッドによっては設定が必要な場合があります。最初に試してみて動かなかったときでも、諦めずにドキュメントを読んでみて下さい。\n\n"
    },
    {
      "title": "ダンスパッド",
      "level": 3,
      "content": "ほとんどのダンスパッドが動作しますが、一部のダンスパッド (特にアダプタを使用してビデオゲームコンソールと接続するタイプ) は矢印ボタンがジョイスティックとしてマッピングされてしまうことがあり、左右や上下を同時に押すことができなくなります。xpad で認識されるデバイスならモジュールオプションを使って挙動を修正できます:\n\n```\n# modprobe -r xpad\n# modprobe xpad dpad_to_buttons=1\n```\n\n"
    },
    {
      "title": "Logitech Thunderpad Digital",
      "level": 3,
      "content": "analog モジュールを使っている場合 Logitech Thunderpad Digital は全てのボタンを表示しません。このコントローラーを使う場合は adi モジュールを使って下さい。\n\n"
    },
    {
      "title": "Nintendo Gamecube コントローラー",
      "level": 3,
      "content": "Dolphin Emulator には公式の Nintendo USB アダプタと GameCube コントローラーを使う方法を説明した ページ を wiki に用意しています。この設定はスイッチを \"Wii U\" に設定した場合の Mayflash Controller Adapter でも使えます。\n\nデフォルトでは、コントローラーは udev で登録されますが、root ユーザーしか読み取ることができません。以下の udev ルールを追加することで修正できます:\n\n```\n/etc/udev/rules.d/51-gcadapter.rules\n```\n\n```\nSUBSYSTEM==\"usb\", ENV{DEVTYPE}==\"usb_device\", ATTRS{idVendor}==\"057e\", ATTRS{idProduct}==\"0337\", MODE=\"0666\"\n```\n\n上記は特定のベンダー・プロダクト ID (公式 USB アダプタ) の USB デバイスにマッチします。デバイスファイルのパーティションを 0666 に設定することで root で実行したプログラムでなくてもデバイスの入力を読み込めるようになります。\n\n以下を実行することで新しい設定で udev をリロードできます:\n\n```\n# udevadm control --reload-rules\n```\n\n"
    },
    {
      "title": "PlayStation 3/4 コントローラー",
      "level": 3,
      "content": "DualShock 3, DualShock 4, Sixaxis ゲームパッドは USB で接続された時に設定なしで動作します (操作を開始するには PS ボタンを押さなくてはなりません)。振動機能はカーネル 3.14 からサポートされています。また、Bluetooth でワイヤレスに使うことも可能です。\n\nSteam は PS3 パッドとして正しく認識し、PS ボタンで Big Picture を起動することが可能です。Big Picture やゲームによっては 360 コントローラーのように振る舞うことができます。ゲームパッドによるマウス操作はデフォルトでオンになっています。ゲームをプレイする前にオフにしたいときは、#ゲームパッドのマウス操作を無効にする を見て下さい。\n\nbluez, bluez-plugins, bluez-utils パッケージをインストールしてください。sixaxis プラグインが含まれています。そして bluetooth.service を起動して、USB でコントローラーを接続してください。プラグインが PC の bluetooth アドレスを自動的にコントローラーに書き込みます。\n\nまた、share ボタンと PlayStation ボタンを同時に押すことでゲームパッドをペアリングモードに移行して、通常通りにペアリングすることもできます。\n\nゲームを遊び終わったらコントローラは切断するようにしてください。コントローラが接続したままだとバッテリーが消費されます。\n\n"
    },
    {
      "title": "iPEGA-9017s などの Bluetooth ゲームパッド",
      "level": 3,
      "content": "Android や iOS デバイス向けに作られた iPEGA-9017s などの bluetooth ゲームパッドを使用したい場合 xboxdrvAUR, bluez, bluez-plugins, bluez-utils が必要です。ゲームパッドモードで接続する必要があります (他のモードがあった場合、ゲームパッドモードを選択してください)。技術的には使用できる状態でも、大抵のゲームはスマートフォン用ゲームパッドを認識しないため、アプリケーションごとに個別にマッピングしてやる必要があります。全てのアプリケーションで使いたい場合 xboxdrvAUR を使用して Microsoft X360 コントローラに偽装させるのが一番簡単です。接続したら udev ルールを作成して永続的な名前を割り当てることで、設定が楽になります。\n\n```\n/etc/udev/rules.d/99-btjoy.rules\n```\n\n```\n#Create a symlink to appropriate /dev/input/eventX at /dev/btjoy\nACTION==\"add\", SUBSYSTEM==\"input\", ATTRS{name}==\"Bluetooth Gamepad\", ATTRS{uniq}==\"00:17:02:01:ae:2a\", SYMLINK+=\"btjoy\"\n```\n\n\"Bluetooth Gampad\" は使用しているデバイスの名前、\"00:17:02:01:ae:2a\" はデバイスのアドレスに置き換えてください。\n\nそして、xboxdrvAUR 用の設定を以下のように作成します:\n\n```\n~/.config/xboxdrv/ipega.conf\n```\n\n```\n#iPEGA PG-9017S Config \n\n[xboxdrv]\nevdev-debug = true\nevdev-grab = true\nrumble = false\nmimic-xpad = true\n\n[evdev-absmap]\nABS_HAT0X = dpad_x\nABS_HAT0Y = dpad_y\n\nABS_X = X1\nABS_Y = Y1\n\nABS_Z  = X2\nABS_RZ = Y2\n\n[axismap]\n-Y1 = Y1\n-Y2 = Y2\n\n[evdev-keymap]\nBTN_EAST=a\nBTN_C=b\nBTN_NORTH=y\nBTN_SOUTH=x\nBTN_TR2=start\nBTN_TL2=back\nBTN_Z=rt\nBTN_WEST=lt\n\nBTN_MODE = guide\n```\n\n利用可能なオプションについては xboxdrv のマニュアルを参照してください。\n\n設定が完了してデバイスを接続したら以下のように xboxdrvAUR を起動します:\n\n```\n# xboxdrv --evdev /dev/btjoy --config .config/xboxdrv/ipega.conf\n```\n\nこれで xboxdrv が動作している間に bluetooth ゲームパッドを使えるようになります。\n\n"
    },
    {
      "title": "Steam コントローラー",
      "level": 3,
      "content": "steam パッケージ (バージョン 1.0.0.51-1 以上) はコントローラを認識して、Steam が起動している間、キーボード/マウス/ゲームパッドのエミュレーションを行います。ゲームパッドのエミュレーションを使うには Steam のゲーム内オーバーレイを有効にする必要があります。パッケージをインストールして Steam を起動してもコントローラが動作しない場合、root 権限で udevadm trigger を実行したりドングルを抜き差ししてみてください。どうやっても動作しない場合、ドングルを接続したままコンピュータを再起動してください。\n\nSteam コントローラを動作させることができなかった場合は#Steam コントローラーがペアリングできないを見てください。\n\npython-steamcontroller-gitAUR をインストールすることで、Steam がなくてもコントローラを使うことができます。また、sc-controllerAUR をインストールすれば Steam クライアントに付属しているような汎用の設定ツールを使うことができます。\n\n一部のデスクトップ環境ではオンスクリーンキーボードで文字を入力しようしたときにフリーズすることがあります。原因はウィンドウのフォーカスです。ウィンドウマネージャの設定から、新しいウィンドウを自動的にフォーカスしたり、マウスに従ってフォーカスすることができないか確認してください。\n\n"
    },
    {
      "title": "Wine",
      "level": 4,
      "content": "python-steamcontroller-gitAUR を使うことで Wine で動作するゲームでも Steam コントローラを利用することが可能です。xbox360cemu.v.3.0 (例: https://github.com/jacobmischka/ds4-in-wine/tree/master/xbox360cemu.v.3.0) アプリケーションをダウンロードしてください。そして dinput8.dll, xbox360cemu.ini, xinput1_3.dll, xinput_9_1_0.dll ファイルをゲームの実行ファイルがあるディレクトリにコピーしてください。xbox360cemu.ini を編集して [PAD1] の値を変更することで Steam コントローラを Xbox コントローラとしてマッピングできます。\n\n```\nxbox360cemu.ini\n```\n\n```\nRight Analog X=4\nRight Analog Y=-5\nA=1\nB=2\nX=3\nY=4\nBack=7\nStart=8\nLeft Thumb=10\nRight Thumb=11\nLeft Trigger=a3\nRight Trigger=a6\n```\n\n設定したら Xbox360 モードで python-steamcontroller を起動してください (sc-xbox.py start)。xbox360cemu.v.3.0 から XInputTest.exe を同一ディレクトリにコピーして Wine で起動することで、マッピングが正しいかどうかテストすることができます。ただしマウスやキーボードのエミュレーションは機能しません。\n\nまた、sc-controllerAUR (github) を使うことで steam の設定ツールと同じようにグラフィカルな設定が可能です。現時点ではバグが多少ありますが、簡単にコントローラの設定ができます。\n\n"
    },
    {
      "title": "Xbox 360 コントローラー",
      "level": 3,
      "content": "このコントローラーはパッケージを別にインストールしなくても動作しますが、無線コントローラーには無線レシーバーが必要です (charge-and-play ケーブルはコントローラとの通信に使えません)。有線コントローラーと無線レシーバーはどちらも xpad カーネルモジュールによってサポートされています。\n\nデフォルトで、コントローラーと関連付けられたデバイス (例: /dev/input/event14) は root に所有されます。これは root グループに入っており、所有者にしかデバイスを読み書きすることが許可されません (600)。結果として、アプリケーションはスーパーユーザー権限で実行しないかぎりコントローラーを使用できなくなります。これを修正するため、以下の udev ルールを作成してください。\n\n```\n/etc/udev/rules.d/50-event.rules\n```\n\n```\nKERNEL==\"event*\", GROUP=\"games\", MODE=\"660\"\n```\n\nこの udev ルールは games グループのメンバーであるユーザーがコントローラーを使えるようにします。\n\n残念ながら xpad には新しい無線コントローラーで問題が起こります:\n\n- ボタンマッピングがおかしい (discussion in Steam bugtracker)。\n- 同期が動作しない。4つの赤い LED が点滅しますが、コントローラーは動作します (discussion in Arch Forum)。\n\n解決方法は xboxdrvAUR を使うことです。これはユーザースペースで動作するもうひとつのドライバーです。システムサービスとして起動することができます。もしくは SteamOS のパッチがあたった xpad (steamos-xpad-dkmsAUR) も以上の問題を修正しています。\n\nコントローラーを使ってマウスの制御や、ボタンのキーへのマッピングなどをしたい場合、xf86-input-joystick パッケージを使う必要があります (設定のヘルプは man joystick で見れます)。マウスが隅で固まってしまうときは、/etc/X11/xorg.conf.d/50-joystick.conf の MatchDevicePath を /dev/input/event* から /dev/input/js* に変更すれば直るでしょう。\n\n"
    },
    {
      "title": "SteamOS の xpad",
      "level": 4,
      "content": "デフォルトの xpad カーネルモジュールで問題がおこる場合、AUR の steamos-xpad-dkmsAUR でインストールできる SteamOS バージョンを使うことができます。Xbox360 コントローラと GameMaker Studio で作成されたゲームには互換問題が存在します。この問題が発生したときは、xboxdrv を使うしかありません。YoYo Games はこの問題を彼らの製品のバグとして認めておらず、修正される見込みは僅かです。\n\nインストールする前に、DKMS をインストールして実行してください。それから修正版のカーネルモジュール steamos-xpad-dkmsAUR を AUR からインストールして下さい。インストール中に新しい xpad カーネルモジュールがカーネルに結び付けられるのが確認できると思います:\n\n```\nCreating symlink /var/lib/dkms/steamos-xpad-dkms/0.1/source ->\n                 /usr/src/steamos-xpad-dkms-0.1\n \nDKMS: add completed.\n \nKernel preparation unnecessary for this kernel.  Skipping...\n \nBuilding module:\ncleaning build area....\nmake KERNELRELEASE=3.12.8-1-ARCH KVERSION=3.12.8-1-ARCH....\ncleaning build area....\n```\n\n再起動すれば動作するようになります。\n\n"
    },
    {
      "title": "xboxdrv",
      "level": 4,
      "content": "xboxdrv は xpad の代わりとなるドライバーで、特定のコントローラでは多くの機能を提供します。ユーザー空間で動作し、システムサービスとして起動できます。\n\nxboxdrvAUR パッケージでインストールして、xboxdrv.service を起動・有効化してください。\n\nコントローラが認識されるのに Steam のゲームで機能しない場合やマッピングが間違っている場合、以下のように設定を修正してください:\n\n```\n/etc/default/xboxdrv/\n```\n\n```\n[xboxdrv]\nsilent = true\ndevice-name = \"Xbox 360 Wireless Receiver\"\nmimic-xpad = true\ndeadzone = 4000\n\n[xboxdrv-daemon]\ndbus = disabled\n```\n\n修正したら xboxdrv.service を再起動してください。\n\nxboxdrv は多数のコントローラーをサポートしていますが、デーモンモード でしか動作しません。 一番シンプルな方法はサービスとして xboxdrv をデーモンモードで起動して:\n\n```\nExecStart = /usr/bin/xboxdrv -D -c /etc/conf.d/xboxdrv\n```\n\n設定ファイルに2番目のコントローラーのサポートを追加することです:\n\n```\n[xboxdrv]\nsilent = true\nnext-controller = true\n[xboxdrv-daemon]\ndbus = disabled\n```\n\nxboxdrv を使うことで --mimic-xpad スイッチによってあらゆるコントローラーを Xbox 360 コントローラーとして登録することができます。Xbox 360 コントローラーをサポートしていて、他のゲームパッドでは問題がおこるゲームでありがたい機能です。\n\nまず、コントローラーのボタンやスティックの名前を確認する必要があります。evtest を使えば確認できます。evtest を実行してコントローラーに対応するデバイスのイベント ID 番号 (/dev/input/event*) を選択してください。コントローラーのボタンを押したりスティックを動かしてボタンやスティックの名前を調べます。\n\n以下は出力の例です:\n\n```\nEvent: time 1380985017.964843, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90003\nEvent: time 1380985017.964843, type 1 (EV_KEY), code 290 (BTN_THUMB2), value 1\nEvent: time 1380985017.964843, -------------- SYN_REPORT ------------\nEvent: time 1380985018.076843, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90003\nEvent: time 1380985018.076843, type 1 (EV_KEY), code 290 (BTN_THUMB2), value 0\nEvent: time 1380985018.076843, -------------- SYN_REPORT ------------\nEvent: time 1380985018.460841, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90002\nEvent: time 1380985018.460841, type 1 (EV_KEY), code 289 (BTN_THUMB), value 1\nEvent: time 1380985018.460841, -------------- SYN_REPORT ------------\nEvent: time 1380985018.572835, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90002\nEvent: time 1380985018.572835, type 1 (EV_KEY), code 289 (BTN_THUMB), value 0\nEvent: time 1380985018.572835, -------------- SYN_REPORT ------------\nEvent: time 1380985019.980824, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90006\nEvent: time 1380985019.980824, type 1 (EV_KEY), code 293 (BTN_PINKIE), value 1\nEvent: time 1380985019.980824, -------------- SYN_REPORT ------------\nEvent: time 1380985020.092835, type 4 (EV_MSC), code 4 (MSC_SCAN), value 90006\nEvent: time 1380985020.092835, type 1 (EV_KEY), code 293 (BTN_PINKIE), value 0\nEvent: time 1380985020.092835, -------------- SYN_REPORT ------------\nEvent: time 1380985023.596806, type 3 (EV_ABS), code 3 (ABS_RX), value 18\nEvent: time 1380985023.596806, -------------- SYN_REPORT ------------\nEvent: time 1380985023.612811, type 3 (EV_ABS), code 3 (ABS_RX), value 0\nEvent: time 1380985023.612811, -------------- SYN_REPORT ------------\nEvent: time 1380985023.708768, type 3 (EV_ABS), code 3 (ABS_RX), value 14\nEvent: time 1380985023.708768, -------------- SYN_REPORT ------------\nEvent: time 1380985023.724772, type 3 (EV_ABS), code 3 (ABS_RX), value 128\nEvent: time 1380985023.724772, -------------- SYN_REPORT ------------\n```\n\n上記の場合 BTN_THUMB, BTN_THUMB2, BTN_PINKIE がボタンで、ABS_RX が右アナログスティックの X 軸になります。 そしてこの名前を使って次のようなコマンドで Xbox 360 コントローラーにみせかけることができます:\n\n```\n$ xboxdrv --evdev /dev/input/event* --evdev-absmap ABS_RX=X2 --evdev-keymap BTN_THUMB2=a,BTN_THUMB=b,BTN_PINKIE=rt --mimic-xpad\n```\n\n上の例は不完全です。デモンストレーション用に1つの軸と3つのボタンしかマップしません。xboxdrv --help-button を使って Xbox コントローラーのボタンと軸を見て、上のコマンドに拡充してそれぞれ割り当てて下さい。軸のマッピングは --evdev--absmap の後に、ボタンのマッピングは --evdev-keymap の後に記述します (カンマで区切り、スペースは使いません)。\n\nデフォルトで、xboxdrv は全てのイベントをターミナルに出力します。これによってマッピングが正しいかどうかテストすることが可能です。--silent オプションを追加すると出力がされなくなります。\n\nPS3 コントローラーを使っていて USB で接続している場合、xboxdrv には初めから組み込まれたマッピングが存在します。次のプログラムを実行 (して動作中のドライバを取外) すれば動作するようになります。\n\n```\n# xboxdrv --silent --detach-kernel-driver\n```\n\nbluetooth を通してプレイステーション3のコントローラーを使うには sixpairAUR ユーティリティをインストールする必要があります。\n\nsixpair をインストールした後はコントローラーを USB ケーブルで接続して sixpair を実行してください:\n\n```\n# sixpair\n```\n\nUSB からコントローラーを切断して5分間待機してください (本当に待機する必要があるのかは定かでない)。\n\nそして bluez でペアリングを行います。bluez-utils と bluez-plugins パッケージが必要です。\n\n全ての bluetooth ユーティリティ (bluedevil や bluemon) を無効にしてください。\n\nbluetoothctl ユーティリティを実行します:\n\n```\n# bluetoothctl\n```\n\nbluetooth のプロンプトが表示されます。\n\nプレイステーションボタンを押して、接続・切断のメッセージを見てデバイスのアドレスをコピーしてください (例: 38:C0:96:56:4D:AA)。\n\nランプの点滅が止まるまで待って下さい。\n\nそして、以下を入力してください:\n\n```\nagent on\ndefault-agent\ndiscoverable on\npairable on\n```\n\nもう一度プレイステーションボタンを押して、点滅している間に次を入力します:\n\n```\nconnect <device_addr>\n```\n\nデバイスが利用可能にならない場合 (接続と切断を繰り返します) 以下のような表示がされるまで上のコマンドを試し続けてください:\n\n```\n[CHG] Device <device_addr> Modalias: usb:v054Cp0268d0100\n[CHG] Device <device_addr> UUIDs:\n       00001124-0000-1000-8000-00805f9b34fb\n       00001200-0000-1000-8000-00805f9b34fb\n```\n\nそしてデバイスを認証してください:\n\n```\ntrust <device_addr>\n```\n\nこれで完了です。\n\n次からはプレイステーションボタンを押せば自動的に接続されます。\n\nまた、無効にした bluetooth アプレット・モニターをもう一度有効にすることができます。.\n\nコントローラーを使わないときは切断するのを忘れないで下さい。接続したままにしておくと、バッテリーを消費します。\n\nxboxdrv を使って xbox360 コントローラーをエミュレートする場合は udev ルールを作成するのが良いでしょう。\n\n以下の内容で新しい udev ルールを作成してください (例えば 99 または 98-dualshock.rules を /etc/udev/rules.d/ に配置):\n\n```\nKERNEL==\"event*\", SUBSYSTEM==\"input\", ATTRS{uniq}==\"<device_addr_you_got_on_pairing>\", SYMLINK+=\"input/dualshock3\"\n```\n\nxboxdrv を新しいデバイスで実行します:\n\n```\nxboxdrv --evdev /dev/input/dualshock3 --mimic-xpad\n```\n\nmimic-xpad が動作しない場合は、xboxdrv [1] による設定ファイルを使用して xboxdrv セクションに以下を追加してください:\n\n```\nmimic-xpad = true\n```\n\nそして evdev 行を以下のように置き換えてください:\n\n```\nevdev = /dev/input/dualshock3 (or whatever other name you gave in the udev_rule)\n```\n\n設定したら、xboxdrv を実行します:\n\n```\n# xboxdrv -c config_file\n```\n\n楽しい時間をお過ごしください。\n\nPS2 デュアルアダプターのボタンマッピングを修正して Xbox コントローラーに見せかけるために、以下のコマンドを使うことができます:\n\n```\n# xboxdrv --evdev /dev/input/event* \\\n  --evdev-absmap ABS_X=x1,ABS_Y=y1,ABS_RZ=x2,ABS_Z=y2,ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \\\n  --axismap -Y1=Y1,-Y2=Y2 \\\n  --evdev-keymap   BTN_TOP=x,BTN_TRIGGER=y,BTN_THUMB2=a,BTN_THUMB=b,BTN_BASE3=back,BTN_BASE4=start,BTN_BASE=lb,BTN_BASE2=rb,BTN_TOP2=lt,BTN_PINKIE=rt,BTN_BASE5=tl,BTN_BASE6=tr \\\n  --mimic-xpad --silent\n```\n\nLogitech Dual Action ゲームパッドは PS2 のパッドと似ているマッピングを持っていますが、Xbox コントローラーのように使うにはいくつかのボタンとトリガーを交換する必要があります:\n\n```\n# xboxdrv --evdev /dev/input/event* \\\n  --evdev-absmap ABS_X=x1,ABS_Y=y1,ABS_RZ=x2,ABS_Z=y2,ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \\\n  --axismap -Y1=Y1,-Y2=Y2 \\\n  --evdev-keymap BTN_TRIGGER=x,BTN_TOP=y,BTN_THUMB=a,BTN_THUMB2=b,BTN_BASE3=back,BTN_BASE4=start,BTN_BASE=lt,BTN_BASE2=rt,BTN_TOP2=lb,BTN_PINKIE=rb,BTN_BASE5=tl,BTN_BASE6=tr \\\n  --mimic-xpad --silent\n```\n\nPS4 コントローラーのボタンマッピングを修正するために、xboxdrv で以下のコマンドを使用するか、または ds4drv プログラムを試すことができます:\n\n```\n# xboxdrv \\\n  --evdev /dev/input/by-id/usb-Sony_Computer_Entertainment_Wireless_Controller-event-joystick\\\n  --evdev-absmap ABS_X=x1,ABS_Y=y1                 \\\n  --evdev-absmap ABS_Z=x2,ABS_RZ=y2                \\\n  --evdev-absmap ABS_HAT0X=dpad_x,ABS_HAT0Y=dpad_y \\\n  --evdev-keymap BTN_A=x,BTN_B=a                   \\\n  --evdev-keymap BTN_C=b,BTN_X=y                   \\\n  --evdev-keymap BTN_Y=lb,BTN_Z=rb                 \\\n  --evdev-keymap BTN_TL=lt,BTN_TR=rt               \\\n  --evdev-keymap BTN_SELECT=tl,BTN_START=tr        \\\n  --evdev-keymap BTN_TL2=back,BTN_TR2=start        \\\n  --evdev-keymap BTN_MODE=guide                    \\\n  --axismap -y1=y1,-y2=y2                          \\\n  --mimic-xpad                                     \\\n  --silent\n```\n\n"
    },
    {
      "title": "ネットワークを介して Gamepad を使う",
      "level": 3,
      "content": "他のコンピュータからネットワークを介して Gamepad を使いたい場合、USB/IP または netstick-gitAUR を使用することで可能です。\n\n"
    },
    {
      "title": "ゲームパッドでマウスが動く",
      "level": 3,
      "content": "ときどき USB ゲームパッドが HID マウスとして認識されることがあります (X 内のみで、/dev/input/js0 としてもインストールされる)。カーソルがゲームパッドによって動いたり、接続した後に画面の右端に逃げていくのは既知の問題です。アプリケーションが自力でゲームパッドを検出できる場合は、xf86-input-joystick パッケージを削除することができます。\n\nもっと平和的な解決方法はゲームパッドのマウス操作を無効にすることです。\n\n"
    },
    {
      "title": "FNA/SDL ベースのゲームでゲームパッドが機能しない",
      "level": 3,
      "content": "マイナーなゲームパッドを使っていると、SDL ベースのゲームで、ゲームパッドが認識されないという問題が発生することがあります。2015年5月14日 から、FNA はゲームの実行フォルダに gamecontrollerdb.txt をおけるようになっています (例: SDL_GameControllerDB)。\n\n古いバージョンの FNA や SDL の場合の対処方法としては、http://libsdl.org/ から SDL のソースコードをダウンロードして自分でマッピングすることができます。/test/ を開いて、controllermap.c プログラムをコンパイル (あるいは controllermapAUR をインストール) してテストを実行してください。controllermap テストを完了すると、guid が生成されるので SDL_GAMECONTROLLERCONFIG 環境変数に設定することで SDL/FNA のゲームから使うことができます。例:\n\n```\n$ export SDL_GAMECONTROLLERCONFIG=\"030000008f0e00000300000010010000,GreenAsia Inc. USB Joystick,platform:Linux,x:b3,a:b2,b:b1,y:b0,back:b8,start:b9,dpleft:h0.8,dpdown:h0.0,dpdown:h0.4,dpright:h0.0,dpright:h0.2,dpup:h0.0,dpup:h0.1,leftshoulder:h0.0,leftshoulder:b6,lefttrigger:b4,rightshoulder:b7,righttrigger:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a3,righty:a2,\"\n```\n\n"
    },
    {
      "title": "ゲームパッドがどのプログラムからも認識されない",
      "level": 3,
      "content": "Steam など、ソフトウェアによっては最初に接続されたゲームパッドしか認識しないことがあります。Microsoft の無線周辺機器デバイスのドライバーにバグが存在するため、bluetooth ドングルでもこの問題が起こることがあります。/dev/input/js* や /dev/input/event* がキーボードの bluetooth トランシーバーに属していることが確認できたら /etc/udev/rules.d/99-btcleanup.rules を作成することで自動的に排除することができます:\n\n```\n/etc/udev/rules.d/99-btcleanup.rules\n```\n\n```\nACTION==\"add\", KERNEL==\"js[0-9]*\", SUBSYSTEM==\"input\", KERNELS==\"...\", ATTRS{bInterfaceSubClass}==\"00\", ATTRS{bInterfaceProtocol}==\"00\", ATTRS{bInterfaceNumber}==\"02\", RUN+=\"/usr/bin/rm /dev/input/js%n\"\nACTION==\"add\", KERNEL==\"event*\", SUBSYSTEM==\"input\", KERNELS==\"...\", ATTRS{bInterfaceSubClass}==\"00\", ATTRS{bInterfaceProtocol}==\"00\", ATTRS{bInterfaceNumber}==\"02\", RUN+=\"/usr/bin/rm /dev/input/event%n\"\n```\n\nKERNELS==\"...\" はあなたのデバイスに合わせて置き換えてください。次を実行することで正しい値が確認できます:\n\n```\n# udevadm info -an /dev/input/js0\n```\n\n問題のデバイスは /dev/input/js0 と仮定しています。ルールを記述したらルールをリロードしてください:\n\n```\n# udevadm control --reload\n```\n\nそして問題のデバイスを再接続します。joystick や event デバイスが外されても、番号は予約されています。ただしファイルは扱われます。\n\n"
    },
    {
      "title": "Steam コントローラーがペアリングできない",
      "level": 3,
      "content": "どんな状況に発生するのかは不明ですがパッケージに含まれている Steam コントローラの udev ルールが機能しないことがあります (FS#47330)。最も信頼性のある対応方法はコントローラを読み取り専用にすることです。/usr/lib/udev/rules.d/80-steam-controller-permission.rule ルールを /etc/udev/rules.d にコピーして MODE=\"0666\" を設定:\n\n```\n/etc/udev/rules.d/80-steam-controller-permission.rule\n```\n\n```\n#USB devices\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"28de\", MODE=\"0666\", TAG+=\"uaccess\"\nKERNEL==\"uinput\", SUBSYSTEM==\"misc\", OPTIONS+=\"static_node=uinput\", TAG+=\"uaccess\"\n```\n\n無線・有線接続のホットスワップやマイクロ USB ケーブルを使ってドングルの接続時に Steam コントローラが認識されるようにしたい場合、もっと複雑な udev ルールが必要です。上記のルールではコントローラが動作しなくなったりマウスやキーボードとして認識されてしまう可能性があります。Valve の開発者は以下のルールを提案しています [2]:\n\n```\n/etc/udev/rules.d/99-steam-controller-perms.rules\n```\n\n```\n# This rule is needed for basic functionality of the controller in Steam and keyboard/mouse emulation\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"28de\", MODE=\"0666\"\n\n# This rule is necessary for gamepad emulation\nKERNEL==\"uinput\", MODE=\"0660\", GROUP=\"steamcontroller\", OPTIONS+=\"static_node=uinput\"\n\n# DualShock 4 wired\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"054c\", ATTRS{idProduct}==\"05c4\", MODE=\"0666\"\n# DualShock 4 wireless adapter\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"054c\", ATTRS{idProduct}==\"0ba0\", MODE=\"0666\"\n# DualShock 4 slim wired\nSUBSYSTEM==\"usb\", ATTRS{idVendor}==\"054c\", ATTRS{idProduct}==\"09cc\", MODE=\"0666\"\n\n# Valve HID devices over USB hidraw\nKERNEL==\"hidraw*\", ATTRS{idVendor}==\"28de\", MODE=\"0666\"\n\n# Valve HID devices over bluetooth hidraw\nKERNEL==\"hidraw*\", KERNELS==\"*28DE:*\", MODE=\"0666\"\n\n# DualShock 4 over bluetooth hidraw\nKERNEL==\"hidraw*\", KERNELS==\"*054C:05C4*\", MODE=\"0666\"\n\n# DualShock 4 Slim over bluetooth hidraw\nKERNEL==\"hidraw*\", KERNELS==\"*054C:09CC*\", MODE=\"0666\"\n```\n\nSteam コントローラユーザーのグループを作成:\n\n```\n# groupadd steamcontroller\n```\n\n使用しているユーザーをグループに追加:\n\n```\n# gpasswd -a $USER steamcontroller\n```\n\n"
    }
  ]
}