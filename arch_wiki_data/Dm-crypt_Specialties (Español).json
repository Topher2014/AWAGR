{
  "title": "Dm-crypt/Specialties (Español)",
  "url": "https://wiki.archlinux.org/title/Dm-crypt/Specialties_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2018-11-22** \n\n"
    },
    {
      "title": "Asegurar la partición de arranque no cifrada",
      "level": 2,
      "content": "La partición /boot y el Master Boot Record son ​​las dos áreas del disco que no están cifradas, incluso en una configuración de raíz cifrada. Por lo general, no se pueden cifrar porque el gestor de arranque y la BIOS (respectivamente) no pueden desbloquear un contenedor dm-crypt para continuar el proceso de arranque. Una excepción es GRUB (Español), que tiene una función para desbloquear /boot cifrado —véase dm-crypt/Encrypting an entire system (Español)#Cifrar partición de arranque (GRUB)—.\n\nEsta sección describe los pasos que se pueden tomar para hacer que el proceso de arranque sea más seguro.\n\n"
    },
    {
      "title": "Arrancar desde un dispositivo extraíble",
      "level": 3,
      "content": "El uso de un dispositivo separado para iniciar un sistema es un procedimiento bastante sencillo y ofrece una mejora de seguridad significativa contra algunos tipos de ataques. En un sistema de archivos raíz cifrado hay dos partes que emplea el sistema que resultan vulnerables, estas son:\n\n- el Master Boot Record, y\n- la partición /boot.\n\nEstos deben almacenarse sin cifrar para que el sistema pueda iniciarse. Para protegerlos de manipulación indebida, es recomendable almacenarlos en un medio extraíble, como una unidad USB, y arrancar desde esa unidad en lugar del disco duro. Siempre que tenga su disco USB a buen recaudo, puede estar seguro de que esos componentes no han sido manipulados, lo que hace que la autenticación sea mucho más segura al desbloquear el sistema.\n\nSe supone que ya tiene su sistema configurado con una partición dedicada montada en /boot. Si no lo hace, siga los pasos indicados en dm-crypt/System configuration (Español)#Cargador de arranque, sustituyendo su disco duro por una unidad extraíble.\n\nPrepare la unidad extraíble (/dev/sdx).\n\n```\n# gdisk /dev/sdx #formatear si es necesario. Alternativamente, utilice cgdisk, fdisk, cfdisk, gparted...\n# mkfs.ext2 /dev/sdx1\n# mount /dev/sdx1 /mnt\n```\n\nCopie los contenidos existentes de /boot en el nuevo.\n\n```\n# cp -ai /boot/* /mnt/\n```\n\nMonte la nueva partición. No olvide actualizar su archivo fstab (Español) en consecuencia.\n\n```\n# umount /boot\n# umount /mnt\n# mount /dev/sdx1 /boot\n# genfstab -p -U / > /etc/fstab\n```\n\nActualice GRUB (Español). El script grub-mkconfig debería detectar el nuevo UUID de la partición automáticamente, pero es posible que las entradas del menú personalizado deban actualizarse manualmente.\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n# grub-install /dev/sdx #intalar en el dispositivo extraíble, no en el disco duro.\n```\n\nReinicie y pruebe la nueva configuración. Recuerde configurar en la BIOS o en Unified Extensible Firmware Interface (Español) el orden de inicio del dispositivo desde el que arrancar. Si el sistema no se inicia, aún debería poder iniciar desde el disco duro para corregir el problema.\n\n"
    },
    {
      "title": "chkboot",
      "level": 3,
      "content": "Note: **una prueba de comprobación posencendido** \n\nRemitiéndonos al artículo de ct-magazine (Número 3/12, página 146, 01.16.2012, [2]), el siguiente script comprueba los archivos presentes en /boot para cambios de hash SHA-1, inodo y bloques ocupados en el disco duro. También verifica el Master Boot Record. El script no puede evitar cierto tipo de ataques, pero otros muchos los hace más difíciles. Ninguna configuración del script en sí misma se almacena en /boot que no está cifrado. Con un sistema cifrado bloqueado/apagado, esto hace que sea más difícil para algunos atacantes porque no es evidente que se realice una comparación de suma de comprobación automática de la partición en el arranque. Sin embargo, un atacante que anticipe estas precauciones puede manipular el firmware para ejecutar su propio código en la parte superior del kernel e interceptar el acceso al sistema de archivos, por ejemplo, a boot, y este le presente los archivos no protegidos. En general, ninguna medida de seguridad por debajo del nivel del firmware puede garantizar la fiabilidad y la evidencia de falsificación.\n\nEl script con instrucciones de instalación está disponible (Author: Juergen Schmidt, ju at heisec.de; License: GPLv2), También hay un paquete chkbootAUR para instalar.\n\nDespués de la instalación, agregue un archivo de servicio (el paquete incluye uno basado en lo siguiente) y actívelo:\n\n```\n[Unit]\nDescription=Check that boot is what we want\nRequires=basic.target\nAfter=basic.target\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/chkboot.sh\n\n[Install]\nWantedBy=multi-user.target\n```\n\nHay una pequeña advertencia para systemd. Al momento de escribir (este artículo), el script original chkboot.sh suministrado contiene un espacio vacío al comienzo de #!/bin/bash que debe ser eliminado para que el servicio se inicie con éxito.\n\nComo /usr/local/bin/chkboot_user.sh debe ejecutarse justo después del inicio de sesión, debe agregarlo al inicio automático (por ejemplo, en KDE -> Configuración del sistema -> Inicio y apagado -> Autostart ; en GNOME 3: gnome-session-properties).\n\nCon Arch Linux, los cambios en /boot son bastante frecuentes, por ejemplo, con la incorporación de nuevos kernels. Por lo tanto, puede ser útil usar los scripts con cada actualización completa del sistema. Una forma de hacerlo sería:\n\n```\n#!/bin/bash\n#\n# Nota: inserte su <usuario> y ejecútelo con sudo para que pacman y chkboot funcionen automáticamente\n#\necho \"Pacman update [1] Quickcheck before updating\" & \nsudo -u <user> /usr/local/bin/chkboot_user.sh\t\t# insert your logged on <user> \n/usr/local/bin/chkboot.sh\nsudo -u <user> /usr/local/bin/chkboot_user.sh\t\t# insert your logged on <user> \necho \"Pacman update [2] Syncing repos for pacman\" \npacman -Syu\n/usr/local/bin/chkboot.sh\nsudo -u <user> /usr/local/bin/chkboot_user.sh\t\t# insert your logged on <user>\necho \"Pacman update [3] All done, let us roll on ...\"\n```\n\n"
    },
    {
      "title": "mkinitcpio-chkcryptoboot",
      "level": 3,
      "content": "mkinitcpio-chkcryptobootAUR es un hook de mkinitcpio (Español) que realiza verificaciones de integridad durante el primer espacio de usuario y aconseja al usuario que no ingrese su contraseña para desbloquear la partición raíz si el sistema parece estar comprometido. La seguridad se logra a través de una partición de arranque cifrada, que se desbloquea utilizando el módulo cryptodisk.mod para GRUB, y una partición del sistema de archivos raíz, que se cifra con una contraseña diferente de la anterior. De esta manera, Initramfs (Español) y el kernel (Español) están protegidos contra la manipulación fuera de línea, y la partición raíz puede permanecer segura incluso si la contraseña de la partición /boot se ingresa en un equipo comprometido (siempre que el hook chkcryptoboot detecte que el equipo se ha visto comprometido, y el mismo no se ha visto comprometido en tiempo de ejecución).\n\nEste hook requiere la versión >=2.00 del paquete grub para que funcione, y una partición dedicada, /boot cifrada con LUKS con su propia contraseña para que sea seguro.\n\n"
    },
    {
      "title": "Instalación",
      "level": 4,
      "content": "Instale mkinitcpio-chkcryptobootAUR y edite /etc/default/chkcryptoboot.conf. Si desea disponer de la capacidad de detectar si su partición de arranque se baipaseó (o puenteó), modifique las variables CMDLINE_NAME y CMDLINE_VALUE con valores que solo usted conozca. Puede seguir el consejo de usar dos funciones de hash como se sugiere, inmediatamente después de la instalación. Además, asegúrese de hacer los cambios apropiados en la línea de órdenes del kernel en /etc/default/grub. Edite la línea HOOKS= en /etc/mkinitcpio.conf, e inserte el hook chkcryptoboot antes de encrypt. Cuando haya terminado, regenere initramfs[enlace roto: sección no válida].\n\n"
    },
    {
      "title": "Descripción técnica",
      "level": 4,
      "content": "mkinitcpio-chkcryptobootAUR consiste en un hook de instalación y un hook en tiempo de ejecución para mkinitcpio. El hook de instalación se ejecuta cada vez que se reconstruye initramfs, y comprueba el hash del apéndice de EFI system partition (Español) de GRUB ($esp/EFI/grub_uefi/grubx64.efi) (en el caso de los sistemas Unified Extensible Firmware Interface (Español) ) o los primeros 446 bytes del disco en el que está instalado GRUB (en el caso de los sistemas BIOS), y almacena ese hash dentro de los initramfs ubicados dentro de la partición cifrada /boot. Cuando se inicia el sistema, GRUB solicita la contraseña para desbloquear /boot, luego el hook en tiempo de ejecución realiza la misma operación de comparación de hash antes de solicitar la contraseña de la partición raíz. Si no coinciden, el hook imprimirá un error como este:\n\n```\nCHKCRYPTOBOOT ALERT!\nCHANGES HAVE BEEN DETECTED IN YOUR BOOT LOADER EFISTUB!\nYOU ARE STRONGLY ADVISED NOT TO ENTER YOUR ROOT CONTAINER PASSWORD!\nPlease type uppercase yes to continue:\n```\n\nAdemás del hash del cargador de arranque, el hook también verifica los parámetros del kernel en ejecución con los configurados en /etc/default/chkcryptoboot.conf. Esto se comprueba tanto en tiempo de ejecución como después de que se realiza el proceso de arranque. Esto permite que el hook detecte si la configuración de GRUB no se baipaseó tanto en el tiempo de ejecución como después, para detectar si la partición /boot completa ha sido manipulada.\n\nPara los sistemas BIOS, el hook crea un hash del gestor de arranque de la primera etapa de GRUB (instalado en los primeros 446 bytes del dispositivo de arranque) para compararlo en los procesos de arranque posteriores. La segunda etapa principal del gestor de arranque GRUB, core.img, no será comprobado.\n\n"
    },
    {
      "title": "AIDE",
      "level": 3,
      "content": "Como alternativa a los scripts anteriores, se puede configurar una comprobación de hash con AIDE que se puede personalizar a través de un archivo de configuración muy flexible.\n\n"
    },
    {
      "title": "STARK",
      "level": 3,
      "content": "Si bien alguno de los métodos descritos arriba deberían dar respuesta a la demanda de la mayoría de los usuarios, los mismos no resuelven todos los problemas de seguridad que se pueden presentar asociados con /boot sin cifrar. Un enfoque que intenta proporcionar una cadena de arranque completamente autenticada fue publicado con POTTS como una tesis académica para implementar el marco de autenticación STARK\n\nLa prueba de concepto de POTTS utiliza Arch Linux como una distribución base e implementa una cadena de arranque del sistema con:\n\n- POTTS: un menú de inicio para un mensaje de autenticación de una sola vez.\n- TrustedGrub - una implementación de GRUB Legacy que autentica el kernel e initramfs contra los registros de chips TPM.\n- TRESOR: un parche del kernel que implementa AES pero mantiene la clave maestra no en la RAM sino en los registros de la CPU durante el tiempo de ejecución.\n\nComo parte de la tesis installation, se han publicado instrucciones basadas en Arch Linux (ISO a partir de 2013-01). Si desea probarlo, tenga en cuenta que estas herramientas no se encuentran en los repositorios estándar y que la solución llevará mucho tiempo de mantenimiento.\n\n"
    },
    {
      "title": "Utilizar archivos de claves cifrados con GPG, LUKS o OpenSSL",
      "level": 2,
      "content": "Las siguientes publicaciones del foro brindan instrucciones para usar dos factores de autenticación, archivos de claves cifrados con gpg o openssl, en lugar de un archivo de clave de texto plano descrito anteriormente en este artículo wiki System Encryption using LUKS with GPG encrypted keys:\n\n- GnuPG: Post regarding GPG encrypted keys Esta publicación tiene las instrucciones genéricas.\n- OpenSSL: Post regarding OpenSSL encrypted keys Esta publicación solo tiene los hooks ssldec.\n- OpenSSL: Post regarding OpenSSL salted bf-cbc encrypted keys Esta publicación tiene los hooks bfkf de initcpio, install y el script generador del archivo de claves cifrado.\n- LUKS: Post regarding LUKS encrypted keys con un hook lukskey de initcpio. O #/boot cifrado y un encabezado LUKS separado en USB a continuación con un hook encrypt personalizado para initcpio.\n\nTenga en cuenta que:\n\n- Puede seguir las instrucciones anteriores con solo dos particiones primarias, una partición de arranque (requerida debido al cifrado) y una partición LVM primaria. Dentro de la partición LVM puede tener tantas particiones como necesite, pero lo más importante es que contenga volumenes lógicos para, al menos, las particiones raíz, de intercambio y «home». Esto tiene la ventaja adicional de tener solo un archivo de claves para todas sus particiones y tener la capacidad de hibernar su equipo (suspender en disco) donde la partición de intercambio está encriptada. Si decide hacerlo, los hooks en /etc/mkinitcpio.conf deberían tener este aspecto: HOOKS=( ... usb usbinput (etwo o ssldec) encrypt (si se utiliza openssl) lvm2 resume ... ) y debe agregar resume=/dev/<NombredelGrupodeVolúmenes>/<NombredelVolumenLógicodeIntecambio> a sus parámetros del kernel.\n- Si necesita almacenar temporalmente el archivo de claves desencriptado en algún lugar, no lo almacene en un disco sin cifrado. Es mejor asegúrese de guardarlos en la memoria RAM como /dev/shm.\n- Si desea usar un archivo de claves encriptado con GPG, necesita usar una versión 1.4 de GnuPG compilada estáticamente o puede editar los hooks y usar este paquete AUR gnupg1AUR\n- Es posible que una actualización de OpenSSL pueda romper el hook ssldec personalizado, mencionada en la segunda publicación del foro.\n\n```\nHOOKS=( ... usb usbinput (etwo o ssldec) encrypt (si se utiliza openssl) lvm2 resume ... )\n```\n\n```\nresume=/dev/<NombredelGrupodeVolúmenes>/<NombredelVolumenLógicodeIntecambio>\n```\n\n"
    },
    {
      "title": "Desbloqueo remoto de la partición (u otro volumen) raíz",
      "level": 2,
      "content": "Si desea poder reiniciar un sistema totalmente cifrado con LUKS de forma remota, o iniciarlo con un servicio Wake-on-LAN (véase también), necesitará una forma de ingresar una frase de contraseña para la partición/volumen raíz en el inicio. Esto se puede lograr ejecutando un hook de mkinitcpio (Español) que configure una interfaz de red. Algunos de los paquetes que se enumeran a continuación contribuyen con varios hooks compilados de mkinitcpio para facilitar la configuración.\n\n- Tenga en cuenta que debe usar los nombres de dispositivos del kernel para la interfaz de red (por ejemplo, eth0) y no uno de udev (Español) (por ejemplo, enp1s0), ya que no funcionarán.\n- Podría ser necesario agregar el módulo de su tarjeta de red[enlace roto: sección no válida] a la matriz MODULES[enlace roto: sección no válida].\n\n"
    },
    {
      "title": "Desbloqueo remoto (hooks: systemd, systemd-tool)",
      "level": 3,
      "content": "El paquete de AUR mkinitcpio-systemd-tool proporciona un hook systemd pensado para mkinitcpio denominado systemd-tool con el siguiente conjunto de características para systemd en initramfs:\n\nTable content:\nCaracterísticas principales proporcionadas por el hook: configuración unificada systemd + mkinitcpio aprovisionamiento automático de recursos binarios y de configuración invocación bajo demanda de scripts mkinitcpio y funciones en línea | Características proporcionadas por las unidades de servicio incluidas: depuración de errores de initrd configuración de red temprana intérprete de órdenes de usuario interactiva acceso ssh remoto en initrd cryptsetup + agente de contraseña personalizada\n\nCaracterísticas principales proporcionadas por el hook:\n\n- configuración unificada systemd + mkinitcpio\n- aprovisionamiento automático de recursos binarios y de configuración\n- invocación bajo demanda de scripts mkinitcpio y funciones en línea\n\nCaracterísticas proporcionadas por las unidades de servicio incluidas:\n\n- depuración de errores de initrd\n- configuración de red temprana\n- intérprete de órdenes de usuario interactiva\n- acceso ssh remoto en initrd\n- cryptsetup + agente de contraseña personalizada\n\nEl paquete mkinitcpio-systemd-tool requiere el hook systemd. Para obtener más información, lea README del proyecto, así como el valor predeterminado proporcionado por defecto por systemd service unit files para comenzar.\n\nLos hooks recomendados son: base autodetect modconf block filesystems keyboard fsck systemd systemd-tool.\n\n"
    },
    {
      "title": "Desbloqueo remoto (hooks: netconf, dropbear, tinyssh, ppp)",
      "level": 3,
      "content": "Otra combinación de paquetes que proporciona inicios de sesión remotos para initcpio es mkinitcpio-netconf y/o mkinitcpio-pppAUR (para el desbloqueo remoto usando un Protocolo punto a punto (PPP) —en inglés Point-to-Point Protocol— de conexión a través de Internet) junto con un servidor OpenSSH (Español). Tiene la opción de usar mkinitcpio-dropbear o mkinitcpio-tinyssh. Esos hooks no instalan ningún intérprete de órdenes, por lo que también debe instalar el paquete mkinitcpio-utils. Las instrucciones a continuación se pueden utilizar con cualquier combinación de los paquetes anteriores. Cuando haya diferentes caminos, se advertirá.\n\n1. Si aún no tiene un par de claves SSH, genere uno[enlace roto: sección no válida] en el sistema cliente (el que se usará para desbloquear la máquina remota). Nota: tinyssh solo admite los tipos de claves Ed25519 y ECDSA. Si elige usar mkinitcpio-tinyssh, necesitará crear/usar una de estas.\n1. Inserte su clave pública SSH (es decir, la que normalmente coloca en los hosts para poder ingresar sin contraseña, o la que acaba de crear y que termina en .pub ) en el archivo /etc/dropbear/root_key o /etc/tinyssh/root_key del equipo remoto. Sugerencia: Este método se puede usar más adelante para agregar otras claves públicas SSH según sea necesario; en el caso de que simplemente esté copiando el contenido el archivo ~/.ssh/authorized_keys remoto, asegúrese de verificar que solo contenga las claves que desea utilizar para desbloquear la máquina remota. Si agrega claves adicionales, regenere initrd también usando mkinitcpio. Vea también Secure Shell (Español)#Protección.\n1. Agregue los tres hooks,<netconf y/o ppp> <dropbear o tinyssh> encryptssh antes de filesystems dentro de la matriz «HOOKS» en /etc/mkinitcpio.conf (el hook encryptssh reemplaza al hook encrypt). Después regenere initramfs[enlace roto: sección no válida]. Nota: El hook net proporcionado por mkinitcpio-nfs-utils no es necesario.\n1. Configure el parámetro cryptdevice= requerido y agregue el parámetro del kernel ip= a la configuración de su gestor de arranque con los argumentos apropiados. Por ejemplo, si el servidor DHCP no atribuye una IP estática a su sistema remoto, lo que dificultaría el acceso con SSH a través de reinicios, puede indicar explícitamente la IP que desea usar:ip=192.168.1.1:::::eth0:noneAlternativamente, también puede especificar la máscara de subred y la puerta de enlace requeridas por la red:ip=192.168.1.1::192.168.1.254:255.255.255.0::eth0:noneNota: A partir de la versión 0.0.4 de mkinitcpio-netconf, puede anidar múltiples parámetros ip= con el fin de configurar múltiples interfaces. No puede mezclarlo con ip=dhcp (ip=:::::eth0:dhcp) solo. Se debe especificar una interfaz.ip=ip=192.168.1.1:::::eth0:none:ip=172.16.1.1:::::eth1:nonePara una descripción detallada eche un vistazo a la sección de mkinitcpio[enlace roto: sección no válida]. Cuando termine, actualice la configuración de su gestor de arranque.\n1. Finalmente, reinicie el sistema remoto e intente ejecutar ssh para él, indicando explícitamente el nombre de usuario «root» (incluso si la cuenta de root está desactivada en la máquina, ya que este usuario root se utiliza solo en initrd con el propósito de desbloquear el sistema remoto). Si está utilizando el paquete mkinitcpio-dropbear y también tiene el paquete openssh instalado, lo más probable es que no reciba ninguna advertencia antes de iniciar sesión, ya que convierte y usa el mismo juego de claves openssh del host (excepto las claves Ed25519, ya que dropbear no las admite). En caso de que esté utilizando mkinitcpio-tinyssh, tiene la opción de instalar tinyssh-convert[enlace roto: replaced by tinyssh] o tinyssh-convert-gitAUR para que pueda usar las mismas claves que su instalación openssh (actualmente solo son claves Ed25519). En cualquier caso, debería haber ejecutado el demonio ssh al menos una vez, utilizando las unidades systemd suministradas, para que las claves se puedan generar primero. Después de reiniciar la máquina, se le solicitará que introduzca la contraseña para desbloquear el dispositivo raíz. El sistema completará su proceso de arranque y luego puede iniciar sesión en él como lo haría normalmente (con el usuario remoto que elija).\n\nNote: **no** \n\n```\nip=192.168.1.1:::::eth0:none\n```\n\n```\nip=192.168.1.1::192.168.1.254:255.255.255.0::eth0:none\n```\n\n```\nip=ip=192.168.1.1:::::eth0:none:ip=172.16.1.1:::::eth1:none\n```\n\n"
    },
    {
      "title": "Desbloqueo remoto a través de wifi (hooks: construya el suyo propio)",
      "level": 3,
      "content": "El hook net se usa normalmente con una conexión cableada. En caso de que desee configurar un equipo que solo dispone de conexión inalámbrica y desbloquearla a través de wifi, puede crear un hook personalizado para conectarse a una red wifi antes de ejecutar el hook de red, net.\n\nEl siguiente ejemplo muestra una configuración utilizando un adaptador wifi USB, que se conecta a una red wifi protegida con WPA2-PSK. En caso de que utilice, por ejemplo, WEP u otro, es posible que necesite cambiar algunas cosas.\n\n1. Modifique /etc/mkinitcpio.conf: Agregue el módulo del kernel necesario para su adaptador wifi específico. Incluya los archivos binarios wpa_passphrase y wpa_supplicant. Agregue un hook wifi (o el nombre que elija, este es el hook personalizado que se creará) antes del hook net. MODULES=(módulo)BINARIES=(wpa_passphrase wpa_supplicant)HOOKS=(base udev autodetect ... wifi net ... dropbear encryptssh ...)\n1. Cree el hook wifi en /etc/initcpio/hooks/wifi:run_hook (){ # demorar unos segundos, dejando que wlan0 sea configurado por kernel sleep 5 # configurar wlan0 a up ip link configurar wlan0 up # asociar con la red wifi # 1. guardar el archivo config temporal wpa_passphrase « network ESSID » « passrase »> /tmp/wifi # 2. crear asociación wpa_supplicant -B -D nl80211, wext -i wlan0 -c /tmp/wifi # demorar unos segundos para que wpa_supplicant termine de conectarse sleep 5 # wlan0 ahora debería estar conectado y listo para que el hook net pueda asignar una ip} run_cleanuphook (){ # wpa_supplicant que se ejecuta en segundo plano killall wpa_supplicant # configurar wlan0 link a down ip link set wlan0 down # wlan0 ahora debería estar completamente desconectado de la red wifi}\n1. Cree el archivo de instalación de hook en/etc/initcpio/install/wifi:build (){ add_runscript}help (){cat<<HELPEOF Activar wifi en el arranque, para desbloquear dropbear ssh del disco..HELPEOF}\n1. Agregue ip=:::::wlan0:dhcp a los parámetros del kernel. Elimine ip=:::::eth0:dhcp para que no entre en conflicto.\n1. Opcionalmente, cree una entrada de arranque adicional con el parámetro del kernel ip=:::::eth0:dhcp.\n1. Regenere initramfs[enlace roto: sección no válida].\n1. Actualice la configuración de su cargador de arranque.\n\n- Agregue el módulo del kernel necesario para su adaptador wifi específico.\n- Incluya los archivos binarios wpa_passphrase y wpa_supplicant.\n- Agregue un hook wifi (o el nombre que elija, este es el hook personalizado que se creará) antes del hook net. MODULES=(módulo)BINARIES=(wpa_passphrase wpa_supplicant)HOOKS=(base udev autodetect ... wifi net ... dropbear encryptssh ...)\n\n```\nMODULES=(módulo)BINARIES=(wpa_passphrase wpa_supplicant)HOOKS=(base udev autodetect ... wifi net ... dropbear encryptssh ...)\n```\n\n```\nrun_hook (){\t# demorar unos segundos, dejando que wlan0 sea configurado por kernel\tsleep 5\t# configurar wlan0 a up\tip link configurar wlan0 up\t# asociar con la red wifi\t# 1. guardar el archivo config temporal\twpa_passphrase « network ESSID » « passrase »> /tmp/wifi \t# 2. crear asociación\twpa_supplicant -B -D nl80211, wext -i wlan0 -c /tmp/wifi\t# demorar unos segundos para que wpa_supplicant termine de conectarse\tsleep 5\t# wlan0 ahora debería estar conectado y listo para que el hook net pueda asignar una ip}\trun_cleanuphook (){\t# wpa_supplicant que se ejecuta en segundo plano\tkillall wpa_supplicant\t# configurar wlan0 link a down \tip link set wlan0 down\t# wlan0 ahora debería estar completamente desconectado de la red wifi}\n```\n\n```\nbuild (){\tadd_runscript}help (){cat<<HELPEOF\tActivar wifi en el arranque, para desbloquear dropbear ssh del disco..HELPEOF}\n```\n\nRecuerde configurar wifi, de modo que pueda iniciar sesión una vez que el sistema haya arrancado completamente. En caso de que no pueda conectarse a la red wifi, intente aumentar los tiempos de demora un poco.\n\n"
    },
    {
      "title": "Soporte Discard/TRIM para unidades de estado sólido (SSD)",
      "level": 2,
      "content": "Los usuarios de unidades de estado sólido deben tener en cuenta que, de forma predeterminada, las órdenes TRIM no están activadas por el mapeador de dispositivos, es decir, los dispositivos de bloque se montan sin la opción discard a menos que anule el valor predeterminado.\n\nLos mantenedores de device-mapper han dejado claro que la compatibilidad con TRIM nunca se activará de forma predeterminada en los dispositivos dm-crypt debido a las posibles implicaciones de seguridad. [3][4] Es posible la fuga mínima de datos en forma de información liberada del bloque, tal vez suficiente para determinar el sistema de archivos en uso, en dispositivos con TRIM activado. Una ilustración y discusión de los problemas que surgen de la activación de TRIM está disponible en el blog de un desarrollador de «cryptsetup». Si le preocupan estos factores, también tenga en cuenta que las amenazas pueden aumentar: por ejemplo, si su dispositivo todavía está cifrado con el algoritmo de cifrado predeterminado anterior (cryptsetup <1.6.0) --cipher aes-cbc-essiv, es posible que se produzcan más fugas de información a partir de la observación del sector «trimmed», que con las actuales opciones de cifrado predeterminadas.\n\nSe distinguen los siguientes casos:\n\n- El dispositivo está cifrado con la modalidad LUKS de dm-crypt predeterminado: De forma predeterminada, el encabezado LUKS se almacena al comienzo del dispositivo y usar TRIM es útil para proteger las modificaciones del encabezado. Si, por ejemplo, se revoca una contraseña LUKS comprometida, sin TRIM activado, el encabezado anterior en general todavía estará disponible para leer hasta que otra operación lo sobrescriba; mientras tanto, si se roba la unidad, los atacantes podrían, en teoría, encontrar una manera de localizar el encabezado anterior y usarlo para descifrar el contenido con la contraseña comprometida. Consulte cryptsetup, sección 5.19 ¿Qué hay de las unidades de estado sólido, flash y unidades híbridas? y Cifrado de disco completo en un ssd. TRIM puede dejarse desactivado si los problemas de seguridad indicados en la parte superior de esta sección se consideran una amenaza peor que los indicados en la viñeta anterior.\n\n- De forma predeterminada, el encabezado LUKS se almacena al comienzo del dispositivo y usar TRIM es útil para proteger las modificaciones del encabezado. Si, por ejemplo, se revoca una contraseña LUKS comprometida, sin TRIM activado, el encabezado anterior en general todavía estará disponible para leer hasta que otra operación lo sobrescriba; mientras tanto, si se roba la unidad, los atacantes podrían, en teoría, encontrar una manera de localizar el encabezado anterior y usarlo para descifrar el contenido con la contraseña comprometida. Consulte cryptsetup, sección 5.19 ¿Qué hay de las unidades de estado sólido, flash y unidades híbridas? y Cifrado de disco completo en un ssd.\n- TRIM puede dejarse desactivado si los problemas de seguridad indicados en la parte superior de esta sección se consideran una amenaza peor que los indicados en la viñeta anterior.\n\n- El dispositivo está cifrado con la modalidad plain de dm-crypt, o el encabezado LUKS se almacena por separado: Si se requiere una negación plausible, TRIM nunca debe ser usado debido a las consideraciones dadas en la parte superior de esta sección, o el uso del cifrado se dará a conocer. Si no se requiere una negación plausible, se puede usar TRIM por sus mejoras de rendimiento, siempre que los peligros de seguridad descritos en la parte superior de esta sección no sean motivo de preocupación.\n\n- Si se requiere una negación plausible, TRIM nunca debe ser usado debido a las consideraciones dadas en la parte superior de esta sección, o el uso del cifrado se dará a conocer.\n- Si no se requiere una negación plausible, se puede usar TRIM por sus mejoras de rendimiento, siempre que los peligros de seguridad descritos en la parte superior de esta sección no sean motivo de preocupación.\n\nEn versiones 3.1 de linux y posteriores, el soporte para TRIM de dm-crypt se puede alternar al crear el dispositivo o montarlo con dmsetup. El soporte para esta opción también existe en la versión 1.4.0 de cryptsetup y superior. Para agregar soporte durante el arranque, deberá añadir :allow-discards a la opción cryptdevice. La opción TRIM puede verse así:\n\n```\ncryptdevice=/dev/sdaX:root:allow-discards\n```\n\nPara las opciones de configuración principales de cryptdevice antes de :allow-discards vea Dm-crypt/System configuration (Español).\n\nSi está utilizando initrd basado en systemd, debe pasar la opción:\n\n```\nrd.luks.options=discard\n```\n\nAdemás de la opción del kernel, también se requiere ejecutar periódicamente fstrim o montar el sistema de archivos (por ejemplo, /dev/mapper/root en este ejemplo) con la opción discard en /etc/fstab. Para obtener más información, consulte la página de TRIM.\n\nPara los dispositivos LUKS desbloqueados a través de /etc/crypttab use la opción discard, por ejemplo:\n\n```\n/etc/crypttab\n```\n\n```\nluks-123abcdef-etc UUID=123abcdef-etc none discard\n```\n\nCuando desbloquee manualmente los dispositivos en la consola, use --allow-discards.\n\nCon LUKS2 puede establecer allow-discards como un indicador predeterminado para un dispositivo abriéndolo una vez con la opción --persistent:\n\n```\n# cryptsetup --allow-discards --persistent open --type luks2 /dev/sdaX root\n```\n\nPuede confirmar que el indicador se ha establecido de forma permanente en el encabezado LUKS2 comprobando la salida de cryptsetup luksDump\n\n```\n# cryptsetup luksDump /dev/sdaX | grep Flags\n```\n\n```\nFlags:          allow-discards\n```\n\nEn cualquier caso, puede verificar si el dispositivo realmente se abrió con discards inspeccionando la salida de dmsetup table:\n\n```\n# dmsetup table\n```\n\n```\nluks-123abcdef-etc: 0 1234567 crypt aes-xts-plain64 000etc000 0 8:2 4096 1 allow_discards\n```\n\n"
    },
    {
      "title": "El hook encrypt y varios discos",
      "level": 2,
      "content": "El hook encrypt solo permite una única entrada cryptdevice= (FS#23182). En las configuraciones del sistema con múltiples unidades, esto puede ser limitante, ya que dm-crypt no tiene una función que permita exceder al dispositivo físico. Por ejemplo, tomemos «LVM sobre LUKS»: todo el volumen LVM existe dentro de un mapeado LUKS. Esto está perfectamente bien para un sistema de una sola unidad, ya que solo hay un dispositivo para descifrar. Pero, ¿qué sucede cuando desea aumentar el tamaño de LVM? No puede, al menos no sin modificar el hook encrypt.\n\nLas siguientes secciones muestran sucintamente las alternativas para superar dicha limitación. El primero trata sobre cómo expandir una configuración LUKS sobre LVM a un nuevo disco. El segundo consiste en la modificación del hook encrypt para poder desbloquear varios discos en las configuraciones LUKS sin LVM.\n\n"
    },
    {
      "title": "Expandir LVM en varios discos",
      "level": 3,
      "content": "La gestión de discos múltiples es una característica básica de LVM (Español) y una de las principales razones para su flexibilidad de particionado. También se puede utilizar con dm-crypt, pero solo si se emplea LVM como primer mapeador. En tal configuración LUKS sobre LVM los dispositivos encriptados se crean dentro de los volúmenes lógicos (con una clave/contraseña por volumen). Lo siguiente cubre los pasos para saber cómo expandir esa configuración a otro disco.\n\nNote: **pueden** \n\n"
    },
    {
      "title": "Añadir una nueva unidad",
      "level": 4,
      "content": "Primero, prepare un nuevo disco de acuerdo con dm-crypt/Drive preparation (Español). Segundo, partíciónelo como un LVM, por ejemplo, asigne todo el espacio a /dev/sdY1 con el tipo de partición 8E00 (Linux LVM). Y tercero, adjunte el nuevo disco/partición al grupo de volúmenes LVM existente, por ejemplo:\n\n```\n# pvcreate /dev/sdY1\n# vgextend MyStorage /dev/sdY1\n```\n\n"
    },
    {
      "title": "Extender el volumen lógico",
      "level": 4,
      "content": "El siguiente paso, consiste en la asignación final del nuevo espacio del disco al el volumen lógico que se va a extender, para lo cual dicho volumen lógico tiene que ser desmontado. Se puede realizar para la partición raíz cryptdevice, pero en este caso el procedimiento se debe realizar desde una imagen ISO de instalación de Arch.\n\nEn este ejemplo, se supone que el volumen lógico para /home (nombre del volúmen lógico homevol) se expandirá al espacio del disco nuevo:\n\n```\n# umount /home\n# fsck /dev/mapper/home\n# cryptsetup luksClose /dev/mapper/home\n# lvextend -l +100%FREE MyStorage/homevol\n```\n\nAhora, una vez extendido el volumen lógico, el contenedor LUKS viene a continuación:\n\n```\n# cryptsetup open /dev/MyStorage/homevol home\n# umount /home      # Como seguridad, para el caso de que fuera automática remontar\n# cryptsetup --verbose resize home\n```\n\nFinalmente, redimensionamos el sistema de archivos:\n\n```\n# e2fsck -f /dev/mapper/home\n# resize2fs /dev/mapper/home\n```\n\n¡Hecho! Si este era su plan, /home se puede volver a montar y ahora incluirá el espacio del nuevo disco:\n\n```\n# mount /dev/mapper/home /home\n```\n\nTenga en cuenta que la acción cryptsetup resize no afecta a las claves de cifrado y, por tanto, estas no habrán cambiado.\n\n"
    },
    {
      "title": "Sistema de archivos raíz que abarca múltiples particiones",
      "level": 4,
      "content": "Es posible modificar el hook encrypt para permitir descifrar múltiples unidades de disco duro raíz (/) en el arranque. En un solo paso:\n\n```\n# cp /usr/lib/initcpio/install/encrypt /etc/initcpio/install/encrypt2\n# cp /usr/lib/initcpio/hooks/encrypt  /etc/initcpio/hooks/encrypt2\n# sed -i \"s/cryptdevice/cryptdevice2/\" /etc/initcpio/hooks/encrypt2\n# sed -i \"s/cryptkey/cryptkey2/\" /etc/initcpio/hooks/encrypt2\n```\n\nAgregue cryptdevice2= a sus opciones de arranque (y cryptkey2= si es necesario), y agregue el hook encrypt2 a mkinitcpio.conf antes de regenerarlo. Vea dm-crypt/System configuration (Español).\n\n"
    },
    {
      "title": "Múltiples particiones no root",
      "level": 4,
      "content": "Tal vez tenga la necesidad de usar el hook encrypt en una partición no root. Arch no admite esto de forma automática sino que necesita intervención manual, sin embargo, puede cambiar fácilmente los valores de cryptdev y cryptname en /lib/initcpio/hooks/encrypt (el primero en su partición /dev/sd*, el segundo para el nombre que desea atribuirle). Eso debería bastar.\n\nLa gran ventaja es que puede tener todo automatizado, mientras que configurar /etc/crypttab con un archivo de claves externa (es decir, el archivo de claves no está en ninguna partición interna del disco duro) puede ser una molestia. Asegúrese de que el dispositivo USB/FireWire/... se monte antes que la partición encriptada, lo que significa que debe cambiar el orden de /etc/fstab (al menos).\n\nPor supuesto, si se actualiza el paquete cryptsetup, tendrá que cambiar este script nuevamente. A diferencia de /etc/crypttab, solo se admite una partición, pero con un poco más de picardía se pueden desbloquear varias particiones.\n\nSi desea implementar esto en una partición RAID por software, hay una cosa más que debe hacer. No basta con configurar el dispositivo /dev/mdX en /lib/initcpio/hooks/encrypt; el hook encrypt fallará al no poder encontrar la clave por algún motivo y tampoco mostrará un prompt para pedirle una contraseña. Parece que los dispositivos RAID no se activan hasta que se ejecuta el hook encrypt. Puede resolver esto colocando la matriz RAID en /boot/grub/menu.lst, así:\n\n```\nkernel /boot/vmlinuz-linux md=1,/dev/hda5,/dev/hdb5\n```\n\nSi configura su partición raíz como un RAID, advertirá avisos similares con esa configuración. GRUB (Español) puede manejar múltiples definiciones de matriz muy bien:\n\n```\nkernel /boot/vmlinuz-linux root=/dev/md0 ro md=0,/dev/sda1,/dev/sdb1 md=1,/dev/sda5,/dev/sdb5,/dev/sdc5\n```\n\n"
    },
    {
      "title": "Sistema cifrado usando un encabezado LUKS separado",
      "level": 2,
      "content": "Este ejemplo sigue la misma configuración que en dm-crypt/Encrypting an entire system (Español)#Modalidad plain de dm-crypt, que debería leer primero antes de seguir esta guía.\n\nAl utilizar un encabezado separado, el dispositivo de bloque cifrado solo transporta datos cifrados, lo que proporciona cifrado denegable siempre que los atacantes no conozcan la existencia de un encabezado. Es similar a usar la modalidad plain de dm-crypt, pero con las ventajas de LUKS como la posibilidad de usar varias contraseñas para desbloquear la clave maestra y la función de derivación de la clave. Además, el uso de un encabezado separado ofrece una forma de autenticación de dos factores con una configuración más fácil que usar un achivo de claves cifrado con GPG u OpenSSL, ya que tendrá un prompt solicitando la contraseña que permite reintentos múltiples. Consulte Disk encryption (Español)#Metadatos criptográficos para obtener más información.\n\nConsulte dm-crypt/Device encryption (Español)#Opciones de cifrado para la modalidad LUKS para ver las opciones de cifrado antes de realizar el primer paso para configurar la partición del sistema cifrado y crear un archivo de encabezado para usar con cryptsetup:\n\n```\n# dd if=/dev/zero of=header.img bs=4M count=1 conv=notrunc\n# cryptsetup luksFormat --type luks2 /dev/sdX --align-payload 8192 --header header.img\n```\n\nAbra el contenedor:\n\n```\n# cryptsetup open --header header.img /dev/sdX enc\n```\n\nAhora siga los pasos de la configuración de LVM sobre LUKS según sus necesidades. Lo mismo se aplica a la preparación de la partición de arranque en el dispositivo extraíble (porque de lo contrario, no tiene sentido tener un archivo de encabezado separado para desbloquear el cifrado disco). Luego mueva el header.img sobre él:\n\n```\n# mv header.img /mnt/boot\n```\n\nSiga el procedimiento de instalación hasta el paso mkinitcpio (ahora debería realizar arch-chroot dentro del sistema cifrado).\n\nHay dos opciones para que initramfs admita un encabezado LUKS separado.\n\n"
    },
    {
      "title": "Utilizar el hook systemd",
      "level": 3,
      "content": "Primero cree /etc/crypttab.initramfs y agregue el dispositivo cifrado a él. La sintaxis se define en crypttab(5)\n\n```\n/etc/crypttab.initramfs\n```\n\n```\nenc\t/dev/disk/by-id/your-disk_id\tnone\theader=/boot/header.img\n```\n\nModifique /etc/mkinitcpio.conf para usar systemd[enlace roto: sección no válida] y agregue la imagen header a FILES.\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\n...\nFILES=(/boot/header.img)\n...\nHOOKS=(base systemd autodetect keyboard sd-vconsole modconf block sd-encrypt sd-lvm2 filesystems fsck)\n...\n```\n\nRegenerar initramfs[enlace roto: sección no válida] y listo.\n\n"
    },
    {
      "title": "Modificar el hook encrypt",
      "level": 3,
      "content": "Este método muestra cómo modificar el hook encrypt para usar un encabezado LUKS separado. Ahora el hook encrypt debe modificarse para que cryptsetup use el encabezado separado (FS#42851; fuente base e idea para estos cambios publicado en BBS). Haga una copia para que no se sobrescriba en una actualización de mkinitcpio (Español):\n\n```\n# cp /usr/lib/initcpio/hooks/encrypt /etc/initcpio/hooks/encrypt2\n# cp /usr/lib/initcpio/install/encrypt /etc/initcpio/install/encrypt2\n```\n\n```\n/etc/initcpio/hooks/encrypt2 (around line 52)\n```\n\n```\nwarn_deprecated() {\n    echo \"The syntax 'root=${root}' where '${root}' is an encrypted volume is deprecated\"\n    echo \"Use 'cryptdevice=${root}:root root=/dev/mapper/root' instead.\"\n}\n\nlocal headerFlag=false\nfor cryptopt in ${cryptoptions//,/ }; do\n    case ${cryptopt} in\n        allow-discards)\n            cryptargs=\"${cryptargs} --allow-discards\"\n            ;;  \n        header)\n            cryptargs=\"${cryptargs} --header /boot/header.img\"\n            headerFlag=true\n            ;;\n        *)  \n            echo \"Encryption option '${cryptopt}' not known, ignoring.\" >&2 \n            ;;  \n    esac\ndone\n\nif resolved=$(resolve_device \"${cryptdev}\" ${rootdelay}); then\n    if $headerFlag || cryptsetup isLuks ${resolved} >/dev/null 2>&1; then\n        [ ${DEPRECATED_CRYPT} -eq 1 ] && warn_deprecated\n        dopassphrase=1\n```\n\nAhora edite el archivo mkinitcpio.conf para agregar los hooks encrypt2 y lvm2 a HOOKS, el archivo header.img a FILES y el modulo loop a MODULES, aparte de otras configuraciones que requiera el sistema:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\n...\nMODULES=(loop)\n...\nFILES=(/boot/header.img)\n...\nHOOKS=(base udev autodetect keyboard keymap consolefont modconf block encrypt2 lvm2 filesystems fsck)\n...\n```\n\nEsto es necesario para que el encabezado LUKS esté disponible en el arranque y permita el descifrado del sistema, eximiéndonos de una configuración más complicada como montar otro dispositivo USB separado para acceder al encabezado. Después de esta configuración se creará initramfs[enlace roto: sección no válida].\n\nA continuación, configure el cargador de arranque para especificar cryptdevice= pasando también la nueva opción header a dicha configuración:\n\n```\ncryptdevice=/dev/disk/by-id/your-disk_id:enc:header\n```\n\nPara finalizar, seguimos dm-crypt/Encrypting an entire system (Español)#Posinstalación que es particularmente útil con una partición /boot en un medio de almacenamiento USB.\n\n"
    },
    {
      "title": "/boot cifrado y un encabezado LUKS separado en USB",
      "level": 2,
      "content": "En lugar de incrustar la imagen header.img y el archivo de claves en initramfs, esta configuración hará que su sistema dependa completamente de la llave usb en lugar de tan solo la imagen de arranque, y del archivo de claves cifrado que contiene la partición de arranque cifrada. Como el encabezado y el archivo de claves no están embebidos en la imagen initramfs y el hook encrypt personalizado está específicamente para by-id, literalmente necesitará la llave usb para arrancar.\n\nPara la unidad usb, ya que está cifrando la unidad y el archivo de claves en su interior, es preferible colocar en cascada los algoritmos de cifrado para no usar el mismo dos veces. Es discutible si un ataque de intermediario sería realmente factible. Puede ser twofish-serpent o serpent-twofish.\n\n"
    },
    {
      "title": "Preparar las particiones de los discos",
      "level": 3,
      "content": "Se asumirá que sdb es la unidad USB, y que sda es el disco duro principal.\n\nPrepare los dispositivos de acuerdo con dm-crypt/Drive preparation (Español).\n\n"
    },
    {
      "title": "Preparar la llave USB",
      "level": 4,
      "content": "Utilice gdisk para particionar el disco según el diseño mostrado aquí, con la excepción de que solo debe incluir las dos primeras particiones. De este modo:\n\n```\n# gdisk /dev/sdb\n```\n\n```\nNumber  Start (sector)    End (sector)  Size       Code  Name\n   1            2048         1050623   512.0 MiB   EF00  EFI System\n   2         1050624         1460223   200.0 MiB   8300  Linux filesystem\n```\n\nAntes de ejecutar cryptsetup, consulte opciones de cifrado para la modalidad LUKS y algoritmos de cifrado y modalidades de operación .\n\nPrepare la partición de arranque pero no ejecute mount sobre ninguna partición todavía y formatee la partición del sistema EFI.\n\n```\n# mount /dev/mapper/cryptboot /mnt\n# dd if=/dev/urandom of=/mnt/key.img bs=tamaño_del_archivo count=1\n# cryptsetup --align-payload=1 luksFormat /mnt/key.img\n# cryptsetup open /mnt/key.img lukskey\n```\n\nEl tamaño_del_archivo está en bytes pero puede ir seguido de un sufijo como M. Tener un archivo demasiado pequeño le dará un desagradable error Requested offset is beyond real size of device /dev/loop0. Como referencia aproximada, la creación de un archivo de 4M lo cifrará correctamente. Debe hacer que el archivo sea más grande que el espacio necesario, ya que el dispositivo loop cifrado será un poco más pequeño que el tamaño del archivo.\n\nCon un archivo grande, puede usar --keyfile-offset=desplazamiento y --keyfile-size=tamaño para navegar a la posición correcta. [5]\n\nAhora debería tener lukskey abierto en un dispositivo loop (en /dev/loop1), mapeado como /dev/mapper/lukskey.\n\n"
    },
    {
      "title": "Preparar la unidad principal",
      "level": 4,
      "content": "```\n# truncate -s 2M /mnt/header.img\n# cryptsetup --key-file=/dev/mapper/lukskey --keyfile-offset=desplazamiento --keyfile-size=tamaño luksFormat /dev/sda --align-payload 4096 --header /mnt/header.img\n```\n\nElija un desplazamiento y un tamaño en bytes (8192 bytes es el tamaño máximo de archivo de claves para cryptsetup).\n\n```\n# cryptsetup open --header /mnt/header.img --key-file=/dev/mapper/lukskey --keyfile-offset=offset --keyfile-size=size /dev/sda enc \n# cryptsetup close lukskey\n# umount /mnt\n```\n\nSiga con los pasos para la preparación de los volúmenes lógicos para configurar LVM sobre LUKS.\n\nConsulte Partitioning (Español)#Particiones dedicadas[enlace roto: sección no válida] para obtener recomendaciones sobre el tamaño de sus particiones.\n\nUna vez que su partición raíz esté montada, realice mount sobre su partición de arranque cifrada como /mnt/boot y su partición del sistema EFI como /mnt/efi.\n\n"
    },
    {
      "title": "Procedimiento de instalación y personalización del hook encrypt",
      "level": 3,
      "content": "Siga la installation guide (Español) hasta el paso mkinitcpio pero no lo haga todavía, y omita los pasos de partición, formateo y montaje como ya se han hecho.\n\nPara que la configuración cifrada funcione, necesita crear su propio hook, que afortunadamente es fácil de hacer y aquí está el código que necesita. Tendrá que seguir Persistent block device naming (Español)#by-id y by-path para averiguar sus propios valores by-id para el disco usb y para el disco principal (están vinculados -> a sda o sdb).\n\nDebería usar by-id en lugar de sda o sdb porque sdX puede cambiar, y aquel garantiza que sea el dispositivo correcto .\n\nPuede nombrar customencrypthook como quiera, y los hooks de compilación personalizados se pueden colocar en las carpetas hooks e install de /etc/initcpio. Mantenga una copia de seguridad de ambos archivos (cp a la partición /home o al directorio /home de su usuario después de crearlos). /usr/bin/ash no es un error tipográfico.\n\n```\n/etc/initcpio/hooks/customencrypthook\n```\n\n```\n#!/usr/bin/ash\n\nrun_hook() {\n    modprobe -a -q dm-crypt >/dev/null 2>&1\n    modprobe loop\n    [ \"${quiet}\" = \"y\" ] && CSQUIET=\">/dev/null\"\n\n    while [ ! -L '/dev/disk/by-id/usbdrive-part2' ]; do\n     echo 'Waiting for USB'\n     sleep 1\n    done\n\n    cryptsetup open /dev/disk/by-id/usbdrive-part2 cryptboot\n    mkdir -p /mnt\n    mount /dev/mapper/cryptboot /mnt\n    cryptsetup open /mnt/key.img lukskey\n    cryptsetup --header /mnt/header.img --key-file=/dev/mapper/lukskey --keyfile-offset=''offset'' --keyfile-size=''size'' open /dev/disk/by-id/harddrive enc\n    cryptsetup close lukskey\n    umount /mnt\n}\n```\n\nusbdrive es su unidad USB by-id, y harddrive su unidad de disco duro principal by-id.\n\n```\n# cp /usr/lib/initcpio/install/encrypt /etc/initpcio/install/customencrypthook\n```\n\nAhora edite el archivo copiado y elimine la sección help() ya que no es necesaria.\n\n```\n/etc/mkinitcpio.conf (edite solo esta parte, no lo reemplace, estos son solo extractos de las partes necesarias)\n```\n\n```\nMODULES=(loop)\n...\nHOOKS=(base udev autodetect modconf block customencrypthook lvm2 filesystems keyboard fsck)\n```\n\nLas matrices files=() y binaries=() están vacías, y no debería tener que reemplazar la matriz HOOKS=(...) completa, basta colocar customencrypthook lvm2 después de block y antes de filesystems, y asegúrese de systemd, sd-lvm2 y encrypt son quitados.\n\n"
    },
    {
      "title": "Cargador de arranque",
      "level": 4,
      "content": "Finalice la guía de instalación desde el paso mkinitcpio. Para arrancar, necesitaría GRUB (Español) o Unified Extensible Firmware Interface (Español)#efibootmgr. Tenga en cuenta que puede usar GRUB (Español) para admitir los discos encriptados mediante la configuración del cargador de arranque, pero modificar la línea GRUB_CMDLINE_LINUX no es necesario para esta configuración.\n\nO use Direct UEFI Secure boot para generar claves con cryptbootAUR, firmando luego initramfs y el kernel y creando un archivo de arranque .efi para la partición del sistema EFI con sbupdate-gitAUR. Antes de usar cryptboot o sbupdate, observe este extracto de Secure Boot#Using your own keys:\n\n```\n# efibootmgr -c -d /dev/device -p partition_number -L \"Arch Linux Signed\" -l \"EFI\\Arch\\linux-signed.efi\"\n```\n\nConsulte efibootmgr(8) para obtener una explicación de las opciones.\n\nAsegúrese de que el orden de inicio ponga Arch Linux Signed primero. Si no es así, cámbielo con efibootmgr -o XXXX,YYYY,ZZZZ.\n\n"
    },
    {
      "title": "Cambiar el archivo de claves LUKS",
      "level": 3,
      "content": "```\n# cryptsetup --header /boot/header.img --key-file=/dev/mapper/lukskey --keyfile-offset=offset --keyfile-size=size luksChangeKey /dev/mapper/enc /dev/mapper/lukskey2 --new-keyfile-size=newsize --new-keyfile-offset=newoffset\n```\n\nDespués, ejecute cryptsetup close lukskey, haga shred o dd sobre el archivo de claves antiguo con datos aleatorios antes de borrarlo, y asegúrese de que el nuevo archivo de claves tenga el mismo nombre que el anterior: key.img u otro nombre.\n\n"
    }
  ]
}