{
  "title": "Makepkg (日本語)",
  "url": "https://wiki.archlinux.org/title/Makepkg_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- パッケージの作成\n- PKGBUILD\n- .SRCINFO\n- Arch User Repository\n- pacman\n- 公式リポジトリ\n- Arch Build System\n\nmakepkg はパッケージのビルドを自動化するスクリプトです。makepkg スクリプトを使用するにはビルドができる Unix プラットフォームと PKGBUILD が必要です。\n\nmakepkg は pacman パッケージの中に入っています。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 設定 1.1 パッケージ作成者の情報 1.2 パッケージの出力 1.3 署名チェック\n- 2 使用方法\n- 3 最適化 3.1 パフォーマンス関連の変更 3.2 最適化されたバイナリの構築 3.3 ビルド時間を短縮する 3.3.1 並列コンパイル 3.3.2 メモリ内のファイルからビルドする 3.3.3 コンパイルキャッシュの使用 3.3.4 mold linker の使用 3.3.5 デバッグパッケージと LTO を無効にする 3.4 圧縮 3.4.1 他の圧縮アルゴリズムを使用する 3.4.2 マルチコアを利用して圧縮する 3.4.3 圧縮レベルの変更\n- 4 ヒントとテクニック 4.1 ソースのダウンロードと抽出の時間を短縮する 4.1.1 ソースの場所の定義 4.2 新しいチェックサムを生成する 4.3 ローカルのソースファイルからビルドする 4.4 特定のパッケージ作成者によるパッケージを表示 4.5 64ビット環境で32ビットのパッケージをビルド 4.6 署名の無いパッケージ 4.7 Magnet URIs 4.8 systemd コントロールグループでの makepkg の実行 4.9 アイドルスケジュールポリシーで実行 4.10 各パッケージディレクトリ内の相対パス\n- 5 トラブルシューティング 5.1 QMAKE を使用するパッケージのインストールディレクトリを指定する 5.2 WARNING: Package contains reference to $srcdir 5.3 プロキシの背後にある時、makepkg は依存関係のダウンロードに失敗します 5.3.1 XferCommand で URL を設定して、プロキシを有効にする 5.3.2 sudoer の env_keep を介してプロキシを有効にする 5.4 makepkg は失敗するが、make は成功する\n- 6 参照\n\n- 1.1 パッケージ作成者の情報\n- 1.2 パッケージの出力\n- 1.3 署名チェック\n\n- 3.1 パフォーマンス関連の変更\n- 3.2 最適化されたバイナリの構築\n- 3.3 ビルド時間を短縮する 3.3.1 並列コンパイル 3.3.2 メモリ内のファイルからビルドする 3.3.3 コンパイルキャッシュの使用 3.3.4 mold linker の使用 3.3.5 デバッグパッケージと LTO を無効にする\n- 3.4 圧縮 3.4.1 他の圧縮アルゴリズムを使用する 3.4.2 マルチコアを利用して圧縮する 3.4.3 圧縮レベルの変更\n\n- 3.3.1 並列コンパイル\n- 3.3.2 メモリ内のファイルからビルドする\n- 3.3.3 コンパイルキャッシュの使用\n- 3.3.4 mold linker の使用\n- 3.3.5 デバッグパッケージと LTO を無効にする\n\n- 3.4.1 他の圧縮アルゴリズムを使用する\n- 3.4.2 マルチコアを利用して圧縮する\n- 3.4.3 圧縮レベルの変更\n\n- 4.1 ソースのダウンロードと抽出の時間を短縮する 4.1.1 ソースの場所の定義\n- 4.2 新しいチェックサムを生成する\n- 4.3 ローカルのソースファイルからビルドする\n- 4.4 特定のパッケージ作成者によるパッケージを表示\n- 4.5 64ビット環境で32ビットのパッケージをビルド\n- 4.6 署名の無いパッケージ\n- 4.7 Magnet URIs\n- 4.8 systemd コントロールグループでの makepkg の実行\n- 4.9 アイドルスケジュールポリシーで実行\n- 4.10 各パッケージディレクトリ内の相対パス\n\n- 4.1.1 ソースの場所の定義\n\n- 5.1 QMAKE を使用するパッケージのインストールディレクトリを指定する\n- 5.2 WARNING: Package contains reference to $srcdir\n- 5.3 プロキシの背後にある時、makepkg は依存関係のダウンロードに失敗します 5.3.1 XferCommand で URL を設定して、プロキシを有効にする 5.3.2 sudoer の env_keep を介してプロキシを有効にする\n- 5.4 makepkg は失敗するが、make は成功する\n\n- 5.3.1 XferCommand で URL を設定して、プロキシを有効にする\n- 5.3.2 sudoer の env_keep を介してプロキシを有効にする\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "makepkg の設定オプションについて詳しくは makepkg.conf(5) を参照してください。\n\n/etc/makepkg.conf が makepkg のメインの設定ファイルです。ユーザー個別の設定は $XDG_CONFIG_HOME/pacman/makepkg.conf または ~/.makepkg.conf で可能です。パッケージをビルドする前に makepkg の設定オプションを微調整するとよいでしょう。\n\n"
    },
    {
      "title": "パッケージ作成者の情報",
      "level": 3,
      "content": "パッケージにはメタデータが付与されておりパッケージ作成者を識別することができます。デフォルトでは、ユーザーがコンパイルしたパッケージは Unknown Packager となります。システム上の複数のユーザーがパッケージをコンパイルする場合、あるいはパッケージを他者に配布する場合、実際の連絡先を入力すると便利です。makepkg.conf の PACKAGER 変数で設定することができます。\n\nインストールしたパッケージの作成者情報を確認するには:\n\n```\n$ pacman -Qi package\n```\n\n```\n[...]\nPackager       : John Doe <john@doe.com>\n[...]\n```\n\n生成したパッケージに自動的に署名するには makepkg.conf で GPGKEY 変数を設定してください。\n\n"
    },
    {
      "title": "パッケージの出力",
      "level": 3,
      "content": "デフォルトでは makepkg はパッケージ tarball を作業ディレクトリに作成し、ソースデータを src/ ディレクトリに直接ダウンロードします。カスタムパスを設定することで、例えばビルドしたパッケージを ~/build/packages/ に、ソースを全て ~/build/sources/ に保存することができます。\n\n必要に応じて以下の makepkg.conf 変数を設定してください:\n\n- PKGDEST — 生成したパッケージを保存するディレクトリ。\n- SRCDEST — ソース データを保存するディレクトリ (別の場所を指定すると src/ へのシンボリックリンクが作成されます)\n- SRCPKGDEST — 生成したソースパッケージを保存するディレクトリ (makepkg -S でビルド)\n\n"
    },
    {
      "title": "署名チェック",
      "level": 3,
      "content": ".sig または .asc の形式の署名ファイルが PKGBUILD ソース配列の一部である場合、makepkg は自動的に 検証 を試みます。ユーザーのキーリングに署名の検証に必要な公開鍵が含まれていない場合、makepkg は PGP 鍵を検証できなかったというメッセージを表示してインストールを中止します。\n\nパッケージに必要な公開鍵が欠落している場合、PKGBUILD には必要な鍵 ID を持つ validpgpkeys エントリが含まれている可能性が高くなります。その場合手動で インポート 、または 鍵サーバー上 で見つけてそこからインポートします。署名チェックを一時的に無効にするには、--skippgpcheck オプションを指定して makepkg を実行します。\n\n"
    },
    {
      "title": "使用方法",
      "level": 2,
      "content": "続行する前に、base-devel グループを インストール してください。このグループに属するパッケージは、PKGBUILD ファイルでビルド時の依存関係 (makedepends) としてリストする必要はありません。\n\n- pacman に渡されるコマンドに対して sudo が適切に設定されていることを確認してください。\n- makepkg 自体を root として実行することは 許可されていません.[2] PKGBUILD に任意のコマンドが含まれる可能性があることに加えて、root としてビルドすることは一般的に安全ではないと考えられています。[3] 通常のユーザー アカウントにアクセスできないユーザーは、nobody user として makepkg を実行する必要があります。\n\nパッケージをビルドするには、パッケージの作成 で説明されているように、まず PKGBUILD またはビルド スクリプトを作成する必要があります。既存のスクリプトは、Arch Build System (ABS) ツリーまたは AUR から入手できます。 PKGBUILD を取得したら、それが保存されているディレクトリに移動し、次のコマンドを実行してパッケージをビルドします。\n\n```\n$ makepkg\n```\n\n必要な依存関係が欠落している場合、makepkg は失敗する前に警告を発します。パッケージをビルドして必要な依存関係をインストールするには、フラグ -s/--syncdeps を追加します。\n\n```\n$ makepkg --syncdeps\n```\n\n-r/--rmdeps フラグを追加すると、makepkg は後で不要になった make 依存関係を削除します。常にパッケージをビルドしている場合は、Pacman ヒント#使用していないパッケージ (孤立したパッケージ) の削除 を時々使用することを検討してください。\n\n- これらの依存関係は、構成されたリポジトリで利用可能である必要があります。詳細は pacman#リポジトリとミラー を参照してください。または、ビルドの前に依存関係を手動でインストールすることもできます (pacman -S --asdeps dep1 dep2)\n- 依存関係をインストールするときは、グローバル値のみが使用されます。つまり、分割パッケージのパッケージング関数で行われたオーバーライドは使用されません。\n\nすべての依存関係が満たされ、パッケージが正常にビルドされると、パッケージファイル (pkgname-pkgver.pkg.tar.zst) が作業ディレクトリに作成されます。インストールするには、-i/--install を使用します (pacman -U pkgname-pkgver.pkg.tar.zst):\n\n```\n$ makepkg --install\n```\n\n$srcdir に抽出されたファイルなど、残りのファイルとディレクトリをクリーンアップするには、オプション -c/--clean を追加します。これは、同じビルド ディレクトリを使用しながら、同じパッケージの複数のビルドやパッケージバージョンの更新に役立ちます。古いファイルや残りのファイルが新しいビルドに引き継がれるのを防ぎます。\n\n```\n$ makepkg --clean\n```\n\n詳細については、makepkg(8) を参照してください。\n\n"
    },
    {
      "title": "最適化",
      "level": 2,
      "content": "デフォルトのオプションは、devtools が 公式リポジトリ のパッケージを構築するために使用するオプションと一致します。[4] したがって、エンドユーザーは、ローカル環境に合わせて次のオプションを微調整することで、多かれ少なかれ大きなメリットを実感できる可能性があります。\n\n"
    },
    {
      "title": "パフォーマンス関連の変更",
      "level": 3,
      "content": "Commit 90bf367e (pacman 6.0.2-9 2024年2月から) ローカル パッケージのビルド パフォーマンスに重要な影響を与える可能性がある 2 つの設定変更が実装されており、特にユーザーによるレビューが推奨されます。:\n\n- debug フラグと lto フラグを有効にする: #デバッグパッケージと LTO を無効にする を参照してください。\n- デフォルトの zstd 圧縮アルゴリズムレベルを --ultra -20 に設定: #圧縮レベルの変更 を参照\n\nさらに詳しいコンテキストについては、Archlinux/packaging/packages/pacman!1 および archlinux/packaging/packages/pacman#23 を参照してください。\n\n"
    },
    {
      "title": "最適化されたバイナリの構築",
      "level": 3,
      "content": "makepkg のデフォルトでは、様々なマシンでインストールできるような一般的なパッケージを生成するようにオプションが設定されています。ホストマシンにあわせてコンパイラの最適化を有効化することで、パッケージ化するソフトウェアの性能を向上させることができます。ただし特定のプロセッサアーキテクチャにあわせてパッケージをコンパイルした場合、他のマシンでは正しく動作しなくなります。x86_64 のマシンでは、時間を投資して公式のパッケージをリビルドすることでそれに見合うだけのパフォーマンスの向上を得られることは稀です。\n\n標準外のコンパイラフラグを使うことでパフォーマンスが劣化する可能性も十分あります。ほとんどのコンパイラオプションは特定の状況でのみ有効であり、無差別に全てのパッケージに適用しないほうが良いでしょう。何かが速くなると確認・ベンチマークできない限り、無駄にコンパイラオプションを使わないことを推奨します。Gentoo の コンパイル最適化ガイド や 安全な CFLAGS 記事にはコンパイラの最適化に関する詳しい解説が載っています。\n\nC/C++ コンパイラ (例: gcc や clang) に渡されるオプションは CFLAGS, CXXFLAGS, CPPFLAGS 環境変数で制御されます。同じように make ビルドシステムは MAKEFLAGS を使います。Arch のビルドシステムでは makepkg.conf の設定オプションとして makepkg はこれらの環境変数を使用します。デフォルト値は幅広いマシンにインストールできる汎用のパッケージを作成するように設定されています。\n\n- すべてのビルドシステムが makepkg.conf で設定された変数を使用するわけではないことに注意してください。たとえば、cmake はプリプロセッサオプション環境変数 CPPFLAGS を無視します。したがって、多くの PKGBUILD には、パッケージ化されたソフトウェアで使用されるビルドシステムに固有のオプションを使用した回避策が含まれています。\n- Makefile のソースコードまたはコンパイルコマンドラインの特定の引数で指定された設定が優先され、makepkg.conf の設定がオーバーライドされる可能性があります。\n\nGCC はアーキテクチャ固有の最適化を自動で認識・有効化することができます。自動最適化を使用するには、-march と -mtune フラグを全て削除してから -march=native を追加してください。例:\n\n```\n/etc/makepkg.conf\n```\n\n```\nCFLAGS=\"-march=native -O2 -pipe ...\"\nCXXFLAGS=\"${CFLAGS} ...\"\n```\n\nmarch=native フラグによってどのフラグが有効になるのか確認するには、次のコマンドを実行してください:\n\n```\n$ gcc -march=native -v -Q --help=target\n```\n\npacman バージョン 5.2.2 以降、makepkg.conf には、Rust コンパイラに与えられるフラグの RUSTFLAGS 環境変数のオーバーライドも含まれています。Rust コンパイラは、指定された RUSTFLAGS 値に -C target-cpu=native を追加することで、アーキテクチャ固有の最適化を検出して有効にすることもできます。\n\n```\n/etc/makepkg.conf\n```\n\n```\nRUSTFLAGS=\"-C opt-level=2 -C target-cpu=native\"\n```\n\nこれにより有効になる CPU 機能を確認するには、次のコマンドを実行します。\n\n```\n$ rustc -C target-cpu=native --print cfg\n```\n\n-C target-cpu=native を指定せずに --print cfg を実行すると、デフォルトの設定が出力されます。opt-level パラメータは、必要に応じて、3、s、または z に変更できます。詳細については、Rust コンパイラのドキュメント を参照してください。\n\n"
    },
    {
      "title": "並列コンパイル",
      "level": 4,
      "content": "make ビルドシステムは、MAKEFLAGS 環境変数 を使用して、make の追加オプションを指定します。 変数は、 makepkg.conf ファイルでも設定できます。\n\nマルチコア/マルチプロセッサシステムを使用しているユーザーは、同時に実行するジョブの数を指定できます。 これは、 nproc を使用して使用可能なプロセッサの数を決定することで実現できます。 MAKEFLAGS=\"-j $(nproc)\" 一部の PKGBUILD は、特定のバージョンの競合状態のため、または単に最初からサポートされていないため、これを -j1 で具体的にオーバーライドします。 このためにビルドに失敗したパッケージは、エラーが実際に発生していることを確認した後、バグトラッカー(またはAURパッケージの場合はパッケージメンテナ)に 報告 して下さい MAKEFLAGS が原因です。\n\n使用可能なオプションの完全なリストについては、 make(1) を参照してください。\n\n"
    },
    {
      "title": "メモリ内のファイルからビルドする",
      "level": 4,
      "content": "コンパイルには多くの I/O 操作と小さなファイルの処理が必要なため、作業ディレクトリを tmpfs に移動すると、ビルド時間が早くなる可能性があります。\n\nBUILDDIR 変数を一時的に makepkg にエクスポートして、ビルドディレクトリを既存の tmpfs に設定できます。例えば:\n\n```\n$ BUILDDIR=/tmp/makepkg makepkg\n```\n\n永続的な設定は、デフォルトの /etc/makepkg.conf ファイルの BUILDENVIRONMENT セクションの最後にある BUILDDIR オプションのコメントを外すことで行うことができます。この値をたとえば BUILDDIR=/tmp/makepkg に設定すると、 Arch のデフォルトの /tmp テンポラリ・ファイル・システムが使用されます。\n\n- メモリ不足を防ぐために、 tmpfs で大きなパッケージをコンパイルすることは避けてください。\n- tmpfs フォルダーは、 noexec オプションなしでマウントする必要があります。そうしないと、ビルドされたバイナリが実行されなくなります。\n- tmpfs でコンパイルされたパッケージは、再起動後も保持されないことに注意してください。 PKGDEST オプションを適切に設定して、ビルドされたパッケージを永続ディレクトリに自動的に移動することを検討してください。\n\n"
    },
    {
      "title": "コンパイルキャッシュの使用",
      "level": 4,
      "content": "ccache を使うことでコンパイル結果をキャッシュしてビルド時間を短縮できます。\n\n"
    },
    {
      "title": "mold linker の使用",
      "level": 4,
      "content": "mold は、ld/lld リンカーのドロップイン代替品であり、大幅に高速化されていると主張しています。\n\nmold を使用するには、-fuse-ld=mold を LDFLAGS に追加します。例えば:\n\n```\n/etc/makepkg.conf\n```\n\n```\nLDFLAGS=\"... -fuse-ld=mold\"\n```\n\n追加のオプションを mold に渡すには、それらを LDFLAGS に追加します。例えば:\n\n```\n/etc/makepkg.conf\n```\n\n```\nLDFLAGS=\"... -fuse-ld=mold -Wl,--separate-debug-file\"\n```\n\nRust パッケージに mold を使用するには、-C link-arg=-fuse-ld=mold を RUSTFLAGS に追加します。例えば:\n\n```\n/etc/makepkg.conf\n```\n\n```\nRUSTFLAGS=\"... -C link-arg=-fuse-ld=mold\"\n```\n\n"
    },
    {
      "title": "デバッグパッケージと LTO を無効にする",
      "level": 4,
      "content": "pacman 6.0.2-9 2024 年 2 月以降の pacman 6.0.2-9 に含まれる コミット 90bf367e では、debug と lto オプションがデフォルトで有効になりました。\n\nデバッグパッケージをビルドすると、公式リポジトリがユーザーの問題をトラブルシューティングするためのツールが提供できるようになります (archlinux.org/archlinux/packaging/packages/pacman/-/issues/23#note_173528) ただし、パッケージを独自にビルドする場合は必要なく、速度が低下します。ビルドプロセス archlinux.org/archlinux/packaging/packages/pacman/-/issues/23#note_173782 を参照してください。\n\nLink-time optimization により最適化されたバイナリが生成されますが、ビルドプロセスは大幅に長くなります (archlinux.org/archlinux/packaging/packages/pacman/-/issues/23#note_173678)\n\nこれらのオプションを無効にするには、OPTIONS=() 配列内で ! を文字の前に追加してください。例えば、OPTIONS=(...!debug !lto...) のようにします。\n\n"
    },
    {
      "title": "他の圧縮アルゴリズムを使用する",
      "level": 4,
      "content": "パッケージ アーカイブが大きくなる代わりに、パッケージングとインストールの両方を高速化するには、PKGEXT を変更します。\n\nたとえば、次の例ではパッケージ ファイルの圧縮がスキップされ、インストール で展開する必要がなくなります。\n\n```\n$ PKGEXT='.pkg.tar' makepkg\n```\n\n別の例として、以下は速度に重点を置いた LZ4 アルゴリズムを使用しています。\n\n```\n$ PKGEXT='.pkg.tar.lz4' makepkg\n```\n\n上記の設定を永続化するには /etc/makepkg.conf で PKGEXT を設定します。\n\n"
    },
    {
      "title": "マルチコアを利用して圧縮する",
      "level": 4,
      "content": "zstd は、圧縮を高速化するために、-T/--threads フラグを介して 対称型マルチプロセッシング(SMP) をサポートしています。/etc/makepkg.conf の COMPRESSZST 配列には、-T0 フラグがデフォルトで含まれており、これにより zstd はパッケージの圧縮に物理 CPU コア数と同じ数のスレッドを使用できます。使用するスレッド数は、--auto-threads=logical フラグを使用して、zstd に論理 CPU 数に基づいてスレッド数を決定するように指示することで、さらに増やすことができます。\n\n```\nCOMPRESSZST=(zstd -c -T0 --auto-threads=logical -)\n```\n\nlz4 および xz はデフォルトでマルチスレッド化されているため、/etc/makepkg.conf で変更する必要はありません。\n\npigz は gzip のドロップイン並列実装であり、デフォルトですべての利用可能な CPU コアを使用します (-p/--processes フラグを使用してコア数を減らすことができます)\n\n```\nCOMPRESSGZ=(pigz -c -f -n)\n```\n\npbzip2 は bzip2 のドロップイン並列実装であり、デフォルトですべての利用可能な CPU コアを使用します。-p# フラグを使用してコア数を減らすことができます (注: -p とコア数の間にスペースはありません)\n\n```\nCOMPRESSBZ2=(pbzip2 -c -f)\n```\n\nlbzip2 は bzip2 のもう 1 つのドロップイン並列実装であり、デフォルトですべての利用可能な CPU コアを使用します。-n フラグを使用してコア数を減らすことができます。\n\n```\nCOMPRESSBZ2=(lbzip2 -c -f)\n```\n\nplzipAUR は lzip のマルチスレッド実装であり、デフォルトですべての利用可能な CPU コアを使用します。-n/--threads フラグを使用してコア数を減らすことができます。\n\n```\nCOMPRESSLZ=(plzip -c -f)\n```\n\n"
    },
    {
      "title": "圧縮レベルの変更",
      "level": 4,
      "content": "いくつかの圧縮アルゴリズム (zstd および xz を含む) は、速度、メモリ、圧縮効率の間のトレードオフを定義する圧縮レベルの設定をサポートしています。\n\n"
    },
    {
      "title": "ソースの場所の定義",
      "level": 4,
      "content": "特に VCSパッケージ をビルドするときに SRCDEST を利用すると、以降のリビルドでソースの取得や展開にかかる時間を短縮できます。\n\n"
    },
    {
      "title": "新しいチェックサムを生成する",
      "level": 3,
      "content": "pacman-contrib をインストールし、PKGBUILD ファイルと同じディレクトリで次のコマンドを実行して、新しいチェックサムを生成します:\n\n```\n$ updpkgsums\n```\n\nupdpkgsums は makepkg --geninteg を使用してチェックサムを生成します。詳細については、このフォーラムディスカッション を参照してください。\n\nチェックサムは、例えば sha256sum などを使用して手動で取得し、sha256sums 配列に追加することもできます。\n\n"
    },
    {
      "title": "ローカルのソースファイルからビルドする",
      "level": 3,
      "content": "ソース コードに変更を加えたい場合は、-o, --nobuild ファイルのみをダウンロードして抽出する オプションを使用すると、パッケージをビルドせずにソースコードをダウンロードできます。\n\n```\n$ makepkg -o\n```\n\nこれで、ソースに変更を加えてから、-e, --noextract ソースファイルを抽出しない (既存の $srcdir/ dir を使用) オプションを使用してパッケージをビルドできるようになりました。すでにビルドされているパッケージと既存のパッケージを上書きするには、-f オプションを使用します。\n\n```\n$ makepkg -ef\n```\n\n"
    },
    {
      "title": "特定のパッケージ作成者によるパッケージを表示",
      "level": 3,
      "content": "以下のコマンドはシステムにインストールされているパッケージの中から packagername という名前のパッケージ作成者によって作られたパッケージを全て表示します:\n\n```\n$ expac \"%n %p\" | grep \"packagername\" | column -t\n```\n\n以下のコマンドは /etc/makepkg の PACKAGER 変数に設定されている値とパッケージ作成者が一致するパッケージを表示します (/etc/pacman.conf に定義されているリポジトリに含まれているパッケージだけが対象):\n\n```\n$ . /etc/makepkg.conf; grep -xvFf <(pacman -Qqm) <(expac \"%n\\t%p\" | grep \"$PACKAGER$\" | cut -f1)\n```\n\n"
    },
    {
      "title": "64ビット環境で32ビットのパッケージをビルド",
      "level": 3,
      "content": "まず multilib リポジトリを有効にして multilib-devel をインストールしてください。gcc や gcc-libs パッケージを削除するかどうかきかれたら yes と答えてください。gcc-multilib は64ビットと32ビット両方のソフトウェアをビルドすることができます。\n\nそれから32ビットの設定ファイルを作成:\n\n```\n~/.makepkg.i686.conf\n```\n\n```\nCARCH=\"i686\"\nCHOST=\"i686-unknown-linux-gnu\"\nCFLAGS=\"-m32 -march=i686 -mtune=generic -O2 -pipe -fstack-protector-strong\"\nCXXFLAGS=\"${CFLAGS}\"\nLDFLAGS=\"-m32 -Wl,-O1,--sort-common,--as-needed,-z,relro\"\n```\n\nそして makepkg を以下のように実行してください:\n\n```\n$ linux32 makepkg --config ~/.makepkg.i686.conf\n```\n\n"
    },
    {
      "title": "署名の無いパッケージ",
      "level": 3,
      "content": "Jenkins などの自動ビルド環境で署名に使用される gpg 秘密鍵のパスフレーズを提供できる人がいない場合があります。パスフレーズなしでシステムに秘密の gpg キーを保存することはお勧めできません。\n\nmakepkg で作成された結果の zst パッケージは、作成後に署名することができます。\n\n```\n$ gpg --detach-sign --pinentry-mode loopback --passphrase --passphrase-fd 0 --output NewlyBuilt.pkg.tar.zst.sig --sign NewlyBuilt.pkg.tar.zst\n```\n\nGPG パスフレーズは、選択したオートメーションスイートによって安全に提供され、隠蔽されます。\n\n出来上がった zst と sig ファイルは有効な署名を期待する pacman クライアントや、あなた自身のリポジトリをホストするときに repo-add --sign で作成したリポジトリから参照することができます。\n\n"
    },
    {
      "title": "Magnet URIs",
      "level": 3,
      "content": "magnet:// のプレフィックスを持つ magnet URIs リソースのサポートは transmission-dlagentAUR ダウンロードエージェントを使って追加することができます。\n\n"
    },
    {
      "title": "systemd コントロールグループでの makepkg の実行",
      "level": 3,
      "content": "ビルドしているパッケージが、デフォルトの make フラグ (他のほとんどのパッケージでは適切に設定されている) を使用してビルドするには多くのリソースを必要とする場合は、そのパッケージを独自の コントロールグループ で実行してみて下さい。makepkg-cgAUR は、systemd コントロールグループを介してこれを実現する makepkg のラッパーです (systemd.resource-control(5) を参照)\n\n"
    },
    {
      "title": "アイドルスケジュールポリシーで実行",
      "level": 3,
      "content": "パッケージのビルドプロセスは、特に #並列コンパイル の場合に CPU 使用率が高くなる可能性があります。CPU 負荷が高い場合、nice(1) の値が最も高くても、システムの速度が大幅に低下し、使用できなくなる可能性があります。ユーザーインターフェイスとフォアグラウンドアプリケーションが途切れたり、応答しなくなったりすることがあります。\n\nこれは、makepkg を実行する前に、スケジューリングポリシーを SCHED_IDLE に変更することで回避できます。これにより、パッケージ構築プロセスが通常のタスクに干渉せず、残りの未使用の CPU 時間のみが利用されることが保証されます。\n\nsched(7) § SCHED_IDLE: Scheduling very low priority jobs から:\n\nSCHED_IDLE ポリシーは、-i フラグを指定して <codechrt>1 コマンドを実行し、優先度 0 (SCHED_IDLE の唯一の有効なオプション) を指定して設定できます。) を使用し、現在のシェルの PID を指定します。\n\nほとんどのシェルの場合:\n\n```\n$ chrt -iap 0 $$\n```\n\nfish シェルの場合、$$ が設定されていない場合:\n\n```\n$ chrt -iap 0 %self\n```\n\n"
    },
    {
      "title": "各パッケージディレクトリ内の相対パス",
      "level": 3,
      "content": "パッケージ出力オプション に絶対パスを使用する代わりに、各パッケージディレクトリ内に相対パスを設定することもできます。\n\nたとえば、次のように makepkg.conf ファイルでターゲットパスを定義できます。$startdir 変数は、パッケージをビルドするときに PKGBUILD が配置されるディレクトリを参照します。\n\n```\nPKGDEST=\"$startdir/build/packages/\"\nSRCDEST=\"$startdir/build/sources/\"\nSRCPKGDEST=\"$startdir/build/srcpackages/\"\nLOGDEST=\"$startdir/logs/\"\n```\n\nこれにより、次のような結果が得られます。\n\n- ビルドされたパッケージは、\"パッケージ ディレクトリ\"/build/packages/ に保存されます。\n- ダウンロードされたすべてのソースファイルは、\"パッケージ ディレクトリ\"/build/sources/ に保存されます。\n- ビルドされたソースパッケージは、\"パッケージ ディレクトリ\"/build/srcpackages/ に保存されます。\n- すべてのログは、\"パッケージ ディレクトリ\"/logs/ に保存されます。\n\nmakepkg は通常どおりに src/ および pkg/ ディレクトリを作成するため、これは予期された動作です。\n\n"
    },
    {
      "title": "QMAKE を使用するパッケージのインストールディレクトリを指定する",
      "level": 3,
      "content": "qmake によって生成される makefile は INSTALL_ROOT 環境変数を使ってプログラムをインストールするディレクトリを指定します。したがって package 関数を以下のようにしてください:\n\n```\nPKGBUILD\n```\n\n```\n...\n\npackage() {\n\tcd \"$srcdir/${pkgname%-git}\"\n\tmake INSTALL_ROOT=\"$pkgdir\" install\n}\n\n...\n```\n\nまた、qmake を正しく設定する必要があります。例えば .pro ファイルに以下を記述してください:\n\n```\nYourProject.pro\n```\n\n```\n...\n\ntarget.path = /usr/local/bin\nINSTALLS += target\n\n...\n```\n\n"
    },
    {
      "title": "WARNING: Package contains reference to $srcdir",
      "level": 3,
      "content": "リテラル文字列 $srcdir か $pkgdir があなたのパッケージ内のインストールされたファイルのどれかに含まれています。\n\nファイルを確認するには、makepkg のビルドディレクトリから次のコマンドを実行してください:\n\n```\n$ grep -R \"$(pwd)/src\" pkg/\n```\n\n詳しくは こちら を参照。\n\n"
    },
    {
      "title": "プロキシの背後にある時、makepkg は依存関係のダウンロードに失敗します",
      "level": 3,
      "content": "makepkg が依存関係を呼び出すと、 pacman を呼び出してパッケージをインストールします。これには、 sudo を介した管理者権限が必要です。ただし、 sudoは 環境変数を特権環境に渡さず、プロキシ関連の変数 ftp_proxy、 http_proxy、 https_proxy、 および no_proxy\n\nプロキシの背後で makepkg を機能させるには、次のいずれかの方法を実行する必要があります。\n\n"
    },
    {
      "title": "XferCommand で URL を設定して、プロキシを有効にする",
      "level": 4,
      "content": "XferCommandは、 /etc/pacman.conf で目的のプロキシURLを使用するように設定できます。 pacman.conf [8] に次の行を追加するか、コメントを解除します。\n\n```\n/etc/pacman.conf\n```\n\n```\n...\nXferCommand = /usr/bin/curl -x http://username:password@proxy.proxyhost.com:80 -L -C - -f -o %o %u\n...\n```\n\n"
    },
    {
      "title": "sudoer の env_keep を介してプロキシを有効にする",
      "level": 4,
      "content": "あるいは、sudoer の env_keep オプションを使用することもできます。これにより、特定の変数を特権環境に保持できます。詳細については、 sudo#環境変数 を参照してください。\n\n"
    },
    {
      "title": "makepkg は失敗するが、make は成功する",
      "level": 3,
      "content": "make を使用して手動でコンパイルできても、makepkg で失敗する場合、それはほぼ確実に /etc/makepkg.conf がコンパイル変数を通常は機能する合理的なものに設定されていますが、それは コンパイルしているものと互換性がありません。 これらのフラグを PKGBUILD options 配列に追加してみてください。\n\n!buildflags、 デフォルトの CPPFLAGS、 CFLAGS、 CXXFLAGS、 および LDFLAGS を防ぐため。\n\n!makeflags、 並列ビルドを有効にするために /etc/makepkg.conf を編集した場合に、デフォルトの MAKEFLAGS を防ぐため。\n\n!debug、 デフォルトの DEBUG_CFLAGS を防ぐため、および DEBUG_CXXFLAGS (パッケージがデバッグビルドの場合)\n\nこれらのいずれかで問題が修正された場合、問題の原因となっているフラグを正確に特定すれば、アップストリームでバグを報告できる可能性があります。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- makepkg(8) マニュアルページ\n- makepkg.conf(5) マニュアルページ\n- gcccpuopt: 現在の CPU にあわせた gcc の cpu オプションを表示するスクリプト\n- makepkg のソースコード\n\n"
    }
  ]
}