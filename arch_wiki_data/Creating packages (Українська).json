{
  "title": "Creating packages (Українська)",
  "url": "https://wiki.archlinux.org/title/Creating_packages_(%D0%A3%D0%BA%D1%80%D0%B0%D1%97%D0%BD%D1%81%D1%8C%D0%BA%D0%B0)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Повʼязані статті\n\n- Arch Build System (Українська)\n- Arch packaging standards (Українська)\n- Arch User Repository (Українська)\n- Creating packages for other distributions (Українська)\n- makepkg (Українська)\n- pacman (Українська)\n- Patching in ABS (Українська)\n- PKGBUILD (Українська)\n- .SRCINFO (Українська)\n- DeveloperWiki:Building in a Clean Chroot (Українська)\n\nЦя стаття має на меті допомогти користувачам створити власні пакети, використовуючи \"портоподібну\" Arch Linux систему збірки, також для надсилання в AUR. Він охоплює створення PKGBUILD (Українська) - файлу опису збірки пакета, породженого makepkg для створення бінарного пакету з початкового коду. Якщо у вас вже є PKGBUILD, див. makepkg (Українська). Інструкції щодо існуючих правил та способів поліпшення якості пакування див. Вказівки щодо Arch пакетів.\n\n"
    },
    {
      "title": "Огляд",
      "level": 2,
      "content": "Пакети в Arch Linux складаються за допомогою утиліти makepkg та інформації, що зберігається у файлі PKGBUILD. Коли makepkg запускається, він шукає PKGBUILD у поточному каталозі та виконує вказівки в ньому для отримання необхідних файлів та/або компілювання їх для упаковки у файл пакету (pkgname.pkg.tar.xz). Отриманий пакет містить бінарні файли та інструкції з установки, готові до встановлення pacman-ом.\n\nПакет Arch - це не більше ніж архів tar, або 'tarball', стиснений за допомогою xz(1), який містить такі файли, що згенеровані makepkg:\n\n- Бінарні файли для встановлення.\n- .PKGINFO: містить усі метадані, необхідні pacman для роботи з пакетами, залежностями тощо.\n- .BUILDINFO: містить інформацію, необхідну для відтворюваних збірок. Цей файл присутній лише в тому випадку, якщо пакет створений з pacman 5.1 або новішою версією.\n- .MTREE: містить хеші та часові позначки файлів, які входять у локальну базу даних, щоб pacman міг перевірити цілісність пакету.\n- .INSTALL: необов'язковий файл, який використовується для виконання команд після етапу встановлення/оновлення/видалення. (Цей файл присутній лише в тому випадку, якщо вказано в PKGBUILD.)\n- .Changelog: необов'язковий файл, що зберігається утримувачем пакета, що документує зміни пакету. (Він присутній не у всіх пакунках.)\n\n"
    },
    {
      "title": "Необхідне програмне забезпечення",
      "level": 3,
      "content": "По-перше, переконайтеся, що необхідні інструменти встановленні: група пакетів base-devel має бути достатньою, вона включає make та додаткові інструменти, необхідні для компіляції з джерела.\n\nКлючовим інструментом для створення пакетів є makepkg (надається pacman), який виконує наступні дії:\n\n1. Перевіряє, чи встановлено залежність пакета.\n1. Завантажує вихідні файл (файли) з вказаного сервера.\n1. Розпаковує вихідний файл(и).\n1. Складає програмне забезпечення та встановлює його під фальшивим середовищем.\n1. Смуги символів із бінарних файлів та бібліотек.\n1. Генерує мета-файл пакунка, який входить до кожного пакету.\n1. Стискає середовище підроблених файлів у файл пакету.\n1. Зберігає файл пакунків у налаштованому каталозі призначення, який за замовчуванням є поточним робочим каталогом.\n\n"
    },
    {
      "title": "Завантажте та протестуйте інсталяцію",
      "level": 3,
      "content": "Завантажте вихідний тарбол програмного забезпечення, яке ви хочете упакувати, витягніть його та виконайте кроки автора для встановлення програми. Запишіть усі команди та / або кроки, необхідні для його складання та встановлення. Ви будете повторювати ті самі команди у файлі PKGBUILD.\n\nБільшість авторів програмного забезпечення дотримуються тришагового циклу збірки:\n\n```\n./configure\nmake\nmake install\n```\n\nЦе хороший час, щоб переконатися, що програма працює правильно.\n\n"
    },
    {
      "title": "Створення PKGBUILD",
      "level": 2,
      "content": "Коли makepkg запускається, він шукає файл PKGBUILD у поточному робочому каталозі. Якщо він знайде його, він завантажує вихідний код програмного забезпечення та компілює його відповідно до інструкцій, визначених у файлі PKGBUILD. Інструкції повинні бути повністю інтерпретовані оболонкою Bash. Після успішного завершення отримані бінарні файли та метадані пакета, тобто версія пакета та залежності, упаковуються у файл pkgname.pkg.tar.xz. Новостворений пакет можна встановити, просто скориставшись makepkg --install, який викличе pacman у фоновому режимі, або безпосередньо за допомогою pacman -U pkgname.pkg.tar.xz .\n\nЩоб розпочати створення нового пакета, спершу створіть нову директорію для цього пакета та змініть поточний каталог у цей. Тоді потрібно створити файл PKGBUILD: прототип PKGBUILD, знайдений у / usr / share / pacman /, може бути використаний, або ви можете почати з PKGBUILD з іншого пакету. Останнє може бути хорошим вибором, якщо подібний пакет вже існує.\n\n"
    },
    {
      "title": "Визначення змінних PKGBUILD",
      "level": 3,
      "content": "Приклад PKGBUILD розташований у / usr / share / pacman /. Пояснення можливих змінних PKGBUILD можна знайти в статті PKGBUILD.\n\nmakepkg визначає дві змінні, які слід використовувати у складі процесу збирання та встановлення:\n\nВони містять \"абсолютні\" шляхи, це означає, що вам не доведеться турбуватися про свою робочу директорію, якщо ви правильно використовуєте ці змінні.\n\n"
    },
    {
      "title": "PKGBUILD функції",
      "level": 3,
      "content": "Створюючи пакет, makepkg буде викликати наступні п'ять функцій, якщо вони були визначені в PKGBUILD. Функція package () необхідна в кожному PKGBUILD і завжди буде викликана. Якщо будь-яка з інших функцій не визначена, makepkg просто пропустить виклик цієї функції.\n\nПід час збирання функції викликаються в тому порядку, в якому вони перераховані тут.\n\n"
    },
    {
      "title": "prepare ()",
      "level": 4,
      "content": "За допомогою цієї функції запускаються команди, які використовуються для підготовки джерел для побудови, наприклад патч. Ця функція запускається відразу після вилучення пакета, перед pkgver () та функцією збирання. Якщо видобуток пропущено ( makepkg - noextract), то prep () не запускається.\n\n"
    },
    {
      "title": "pkgver ()",
      "level": 4,
      "content": "pkgver () працює після отримання джерел, вилучення та виконання #prepare (). Таким чином, ви можете оновити змінну pkgver під час етапу makepkg.\n\nЦе особливо корисно, якщо ви виготовляєте git / svn / hg / тощо). пакети, де процес збирання може залишатися колишнім, але джерело може оновлюватися щодня, навіть щогодини. Старий спосіб цього полягав у тому, щоб ввести дату в поле pkgver, яке, якщо програмне забезпечення не буде оновлено, makepkg все одно відновить його, думаючи, що версія змінилася. Деякі корисні команди для цього є git description, hg Identi -ni тощо. Будь ласка, протестуйте їх перед тим, як подати PKGBUILD, як збій у pkgver () Функція може зупинити збірку на своїх треках.\n\n"
    },
    {
      "title": "build ()",
      "level": 4,
      "content": "Тепер вам потрібно реалізувати функцію build() у файлі PKGBUILD. Ця функція використовує загальні команди оболонки в синтаксисі Bash для автоматичного компілювання програмного забезпечення та створення каталогу під назвою pkg для встановлення програмного забезпечення. Це дозволяє makepkg пакувати файли без просіювання вашої файлової системи.\n\nПерший крок у функції build() - це перейти в каталог, створений розтисканням вихідної тарілки. makepkg змінить поточний каталог на $srcdir перед виконанням функції build(). Тому в більшості випадків, як запропоновано в /usr/share/pacman/PKGBUILD.proto, перша команда буде виглядати так:\n\ncd \"$pkgname-$pkgver\"\n\nТепер вам потрібно перерахувати ті самі команди, які використовувались при ручному компілюванні програмного забезпечення. Функція build () по суті автоматизує все, що ви зробили вручну, і компілює програмне забезпечення у середовищі підробленої збірки. Якщо програмне забезпечення, яке ви упаковуєте, використовує сценарій налаштування, то для створення пакетів для Pacman добре використовувати практику - префікс = / usr. Багато програмного забезпечення встановлює файли відносно каталогу / usr / local, що слід робити лише в тому випадку, якщо ви створюєте вручну з джерела. Усі пакети Arch Linux повинні використовувати каталог / usr. Як видно з файлу /usr/share/pacman/PKGBUILD.proto, наступні два рядки часто виглядають так:\n\n```\n./configure --prefix=/usr\nmake\n```\n\n"
    },
    {
      "title": "check()",
      "level": 4,
      "content": "Місце для викликів make check та подібних процедур тестування. Настійно рекомендується мати check (), оскільки це допомагає переконатися, що програмне забезпечення було побудовано правильно та справно працює зі своїми залежностями.\n\nКористувачі, які цього не потребують (а іноді і ті, хто не може виправити пакет для передачі цього пакета), можуть відключити його за допомогою BUILDENV+=('!check') в PKGBUILD/makepkg.conf або викликати makepkg із прапором --nocheck.\n\n"
    },
    {
      "title": "package()",
      "level": 4,
      "content": "Останній крок - помістити скомпільовані файли в каталог, де makepkg може отримати їх для створення пакету. Це за замовчуванням каталог pkg - просте середовище підробки. Каталог pkg копіює ієрархію кореневої файлової системи шляхів інсталяції програмного забезпечення. Якщо вам потрібно вручну розмістити файли під коренем вашої файлової системи, слід встановити їх у каталог pkg під тією ж структурою каталогу. Наприклад, якщо ви хочете встановити файл у /usr/bin, його замість цього слід розмістити під $pkgdir/usr/bin. Дуже мало процедур встановлення вимагає від користувача копіювання десятків файлів вручну. Натомість для більшості програмного забезпечення виклик make install зробить це. Фінальний рядок повинен виглядати наступним чином, щоб правильно встановити програмне забезпечення у каталозі pkg:\n\n```\nmake DESTDIR=\"$pkgdir/\" install\n```\n\nmakepkg --repackage runs only the package() function, so it creates a package without building. This may save time e.g. if you have changed just the depends variable of the package.\n\n"
    },
    {
      "title": "Тестування PKGBUILD і пакета",
      "level": 2,
      "content": "Коли ви пишете функцію build (), ви хочете часто перевіряти свої зміни, щоб уникнути помилок. Це можна зробити за допомогою команди makepkg в каталозі, що містить файл PKGBUILD. При правильному форматі PKGBUILD makepkg створить пакет; зі зламаною або незавершеною PKGBUILD, це призведе до помилки.\n\nЯкщо makepkg завершиться успішно, він розмістить файл з ім'ям pkgname-pkgver.pkg.tar.xz у вашому робочому каталозі. Цей пакет можна встановити за допомогою команди pacman -U. Однак, лише тому, що створений файл пакету, не випливає, що він є повністю функціональним. Можливо, він може містити лише каталог і жодних файлів, якщо, наприклад, префікс був вказаний неправильно. Ви можете використовувати функції запиту pacman для відображення списку файлів, що містяться в пакеті, і залежностей, які він вимагає, для pacman -Qlp [file file] та pacman -Qip [file file] відповідно .\n\nЯкщо пакет виглядає здоровим, то ви готові! Однак, якщо ви плануєте випустити файл PKGBUILD, обов'язково потрібно перевірити та повторно перевірити вміст масиву зависи.\n\nТакож переконайтесь, що двійкові файли пакетів справді працюють бездоганно! Дратівливо випускати пакет, який містить усі необхідні файли, але виходить з ладу через деякий незрозумілий варіант конфігурації, який не дуже добре працює з рештою системи. Якщо ви збираєтеся лише збирати пакети для вашої власної системи, вам не потрібно надто турбуватися про цей крок забезпечення якості, адже ви єдина людина, яка страждає від помилок.\n\n"
    },
    {
      "title": "Перевірка розумності пакета",
      "level": 3,
      "content": "Після тестування функціональності пакета перевірте його на наявність помилок за допомогою namcap:\n\n```\n$ namcap PKGBUILD\n$ namcap <package file name>.pkg.tar.xz\n```\n\nNamcap буде робити наступне:\n\n1. Перевіряти вміст PKGBUILD на наявність поширених помилок та ієрархію файлів пакунків на наявність зайвих / неправильних файлів\n1. Сканувати всі файли ELF в пакеті за допомогою ldd, автоматично повідомляючи про те, які пакети з необхідними спільними бібліотеками відсутні від залежить, а які можна пропустити як перехідні залежності\n1. Евристично шукати відсутні і залежні залежності\n\nта багато іншого.\n\nУвійдіть у звичку перевіряти ваші пакунки за допомогою namcap, щоб уникнути необхідності виправляти найпростіші помилки після подання пакету.\n\n"
    },
    {
      "title": "Подання пакетів AUR",
      "level": 2,
      "content": "Будь ласка, прочитайте Архівний користувальницький архів # Пакети подання для детального опису процесу подання.\n\n"
    },
    {
      "title": "Підсумок",
      "level": 2,
      "content": "1. Завантажте вихідний тарбол програмного забезпечення в пакет.\n1. Спробуйте скласти пакунок та встановити його у довільний каталог.\n1. Скопіюйте прототип /usr/share/pacman/PKGBUILD.proto та перейменуйте його на PKGBUILD у тимчасовому робочому каталозі.\n1. Відредагуйте PKGBUILD відповідно до потреб вашого пакету.\n1. Запустіть makepkg і перевірте, чи правильно складено пакет.\n1. Якщо ні, повторіть попередні два кроки.\n\n"
    },
    {
      "title": "Попередження",
      "level": 3,
      "content": "- Перш ніж ви зможете автоматизувати процес складання пакету, ви повинні зробити це вручну хоча б один раз, якщо ви не знаєте \"\" точно \"\" що ви робите \"\" заздалегідь \", і в цьому випадку ви б не читали цього в першому місці. На жаль, хоча велика кількість авторів програми дотримуються 3-ступінкового циклу збірки \" ./configure; make; make install\", це не завжди так, і все може стати справді некрасивим, якщо вам доведеться застосовувати патчі, щоб все взагалі працювало. Правило: Якщо ви не можете отримати програму для компіляції з вихідного tarball і змусити її встановити себе у визначений тимчасовий підкаталог, вам навіть не потрібно намагатися упакувати її. У makepkg немає жодної чарівної пилі пиксі, яка б усувала проблеми з джерелом.\n- У кількох випадках пакети навіть недоступні як джерело, і вам доведеться використовувати щось на зразок sh installer.run, щоб змусити його працювати. Вам доведеться провести досить небагато досліджень (прочитати README, INSTALL інструкції, керівництво сторінок, можливо, побудувати у Gentoo чи інших інсталяторів пакетів, можливо, навіть MAKEFILE або вихідний код), щоб працювати. У деяких дійсно поганих випадках вам доведеться редагувати вихідні файли, щоб вони взагалі працювали. Однак makepkg повинен бути повністю автономним, без введення користувача. Тому якщо вам потрібно відредагувати файли, можливо, вам доведеться зв’язати спеціальний патч із PKGBUILD та встановити його всередині функції prep (), або, можливо, доведеться випустити деякі sed команди зсередини функції prep ().\n\n"
    },
    {
      "title": "Детальніші вказівки",
      "level": 2,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Font – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel modules – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust - Security – Shell – VCS – Web – Wine\n\n"
    },
    {
      "title": "генератори PKGBUILD",
      "level": 2,
      "content": "PKGBUILD для деяких пакетів можна генерувати автоматично.\n\n- Go: go-makepkg\n- Haskell: cblrepo\n- Node.js: nodejs-npm2archAUR npm2arch\n- Python: pipman-gitAUR, pip2arch-gitAUR, python-pypi2pkgbuildAUR\n- Ruby: gem2archAUR, pacgemAUR\n- Rust: cargo-pkgbuildAUR\n\n"
    },
    {
      "title": "Дивіться також",
      "level": 2,
      "content": "- How to correctly create a patch file.\n- Arch Linux Classroom IRC Logs of classes about creating PKGBUILDs.\n- Fakeroot approach for package installation\n\n"
    }
  ]
}