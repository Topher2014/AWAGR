{
  "title": "Ядро",
  "url": "https://wiki.archlinux.org/title/%D0%AF%D0%B4%D1%80%D0%BE",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Модули ядра\n- Compile kernel module\n- Kernel Panics\n- sysctl\n\nИз Википедии:\n\nДистрибутив Arch Linux основан на ядре Linux. Помимо основной стабильной (stable) версии в Arch Linux можно использовать некоторые альтернативные ядра. В статье описываются доступные в официальных репозиториях версии ядер, возможные патчи, а также способы, которыми пользователи могут скомпилировать собственное ядро.\n\nПакет ядра устанавливается в файловую систему в каталоге /boot/. Для загрузки нужного ядра при запуске системы необходимо соответствующим образом настроить загрузчик.\n\n"
    },
    {
      "title": "Официальные ядра",
      "level": 2,
      "content": "Помощь при работе с официальными ядрами можно найти на форуме и в баг-трекере.\n\n- Stable — \"ванильное\" ядро Linux с модулями и некоторыми патчами.\n\n- Hardened — ориентированное на безопасность ядро Linux с набором патчей, защищающих от эксплойтов ядра и пространства пользователя. Содержит больше защитных особенностей, чем linux.\n\n- Longterm — ядро и модули с долгосрочной поддержкой (Long Term Support, LTS).\n\n- Zen Kernel — результат коллективных усилий исследователей с целью создать лучшее из возможных ядер Linux для систем общего назначения. Подробности проекта можно найти на сайте liquorix.net (там же можно скачать двоичные файлы Zen-ядра для Debian).\n\n"
    },
    {
      "title": "Компиляция",
      "level": 2,
      "content": "Скомпилировать собственное ядро можно двумя способами:\n\n- Нестандартное ядро чревато всевозможными проблемами в плане надёжности и стабильности работы, поэтому настоятельно рекомендуется использовать резервное копирование.\n- Arch Linux поддерживает только #Официальные ядра. Если вы работаете с другим ядром, то не забывайте упоминать это в запросах в поддержку.\n\nNote: Файлы конфигурации пакетов с ядрами Arch можно найти в исходниках (например, файл [1] из linux). Если включена опция ядра CONFIG_IKCONFIG_PROC, то файл /proc/config.gz содержит настройки ядра, которое работает на вашей машине в данный момент.\n\n- Лучший способ повысить производительность — адаптировать ядро под свою систему, в первую очередь под архитектуру и тип процессора.\n- Если оставить в ядре только действительно нужные вам функции, то удастся уменьшить его размер и, следовательно, время сборки. Например, удалите из него Bluetooth, Video4Linux, 1000Mbit Ethernet и прочие вещи, которые на вашей машине точно не понадобятся.\n\nФайлы конфигурации пакетов с ядрами Arch можно найти в исходниках (например, файл [1] из linux). Если включена опция ядра CONFIG_IKCONFIG_PROC, то файл /proc/config.gz содержит настройки ядра, которое работает на вашей машине в данный момент.\n\nНекоторые из перечисленных пакетов могут быть также доступны в двоичном виде в неофициальных репозиториях.\n\n"
    },
    {
      "title": "Ядра kernel.org",
      "level": 3,
      "content": "- Git — ядро Linux, собранное из файлов с исходным кодом из git-репозитория Линуса Торвальдса.\n\n- Mainline — ядра, в которых появляются все нововведения. Выходят каждые 2-3 месяца.\n\n- Next — самые новейшие ядра, с улучшениями, которые будут добавлены в следующий mainline-выпуск.\n\n- Longterm 4.19 — LTS-ядро версии 4.19.\n\n- Longterm 5.4 — LTS-ядро версии 5.4.\n\n- Longterm 5.10 — LTS-ядро версии 5.10.\n\n- Longterm 5.15 — LTS-ядро версии 5.15.\n\n"
    },
    {
      "title": "Неофициальные ядра",
      "level": 3,
      "content": "- Ck — патч от Con Kolivas, повышение быстродействия для настольных систем с любым типом нагрузки.\n\n- Clear — патчи проекта Clear Linux от Intel. Содержит улучшения производительности и безопасности.\n\n- GalliumOS — ядро Linux с патчами GalliumOS для Хромбуков.\n\n- Libre — без проприетарных или обфусцированных драйверов устройств.\n\n- Liquorix — ядро, собранное из исходного кода Zen с настройками для Debian. Разработан для настольных, мультимедийных и игровых систем, часто используется в качестве замены основному ядру Debian. Создатель патча Liquorix, Damentz, также является разработчиком набора патчей Zen.\n\n- pf-kernel — набор неплохих улучшений, не вошедших в mainline. Сопровождается разработчиком ядра. Предоставляет порты улучшений для новых версий ядра, если они не были выпущены официально. Наиболее важные нововведения — UKSM.\n\n- Репозиторий, linux-pfAUR от разработчика pf-kernel, post-factum.\n\n- Realtime kernel — поддерживается небольшой группой разработчиков, возглавляемой Ingo Molnar. Патч позволяет применять kernel preemption практически ко всему ядру за исключением небольших участков кода (\"raw_spinlock critical regions\"). Этого удалось добиться за счёт замены большинства спинлоков ядра на мьютексы с поддержкой наследования приоритета, а также перемещением всех прерываний (в том числе и программных) в потоки ядра.\n\n- Tkg — ядро с набором патчей для планировщиков PDS и Project C / BMQ. Стандартный планировщик CFS также доступен. Изменения нацелены на улучшение баланса интерактивность/производительность в играх. Автор и сопроводитель — Etienne Juvigny (Tk-Glitch).\n\n- VFIO — патч ядра от Alex Williamson с поддержкой PCI Passthrough для KVM на некоторых машинах.\n\n- XanMod — улучшение производительности ядер рабочих станций, игровых компьютеров, медиацентров и других систем. Включает планировщик MuQSS, планировщик ввода-вывода BFQ, алгоритм дедупликации памяти в реальном времени UKSM, алгоритм управления перегрузками TCP BBR, расширенный набор команд для архитектуры x86_64 и другие изменения.\n\n"
    },
    {
      "title": "Паника ядра",
      "level": 3,
      "content": "Паника ядра (kernel panic) возникает, когда ядро Linux попадает в состояние невосстановимого сбоя. Это состояние обычно возникает из-за ошибок в драйверах оборудования, в результате чего система попадает в deadlock, не реагирует на запросы и требует перезагрузки. Непосредственно перед deadlock генерируется диагностическое сообщение, состоящее из: состояния компьютера, когда произошел сбой, трассировки (call trace), ведущей к функции ядра, распознавшей сбой, и списка загруженных в данный момент модулей. К счастью, паники ядра случаются нечасто при использовании основных версий ядра — таких, которые поставляются из официальных репозиториев — но когда они случаются, необходимо знать, как с ними бороться.\n\n"
    },
    {
      "title": "Изучение сообщения паники",
      "level": 4,
      "content": "Если паника ядра происходит очень рано в процессе загрузки, вы можете увидеть в консоли сообщение \"Kernel panic - not syncing:\", но после запуска systemd сообщения ядра обычно перехватываются и записываются в системный журнал. Однако, когда возникает паника, диагностическое сообщение, выдаваемое ядром, почти никогда не записывается в файл журнала на диске, потому что компьютер попадает в deadlock до того, как system-journald получит шанс записать журнал. Поэтому единственный способ просмотреть сообщение о панике — это просмотреть его на консоли в момент возникновения (не прибегая к установке kdump crashkernel). Вы можете сделать это, загрузившись со следующими параметрами ядра и попытавшись воспроизвести панику на tty1:\n\n```\nsystemd.journald.forward_to_console=1 console=tty1\n```\n\nМожно сделать предположение о том, какая подсистема или модуль вызывает панику, используя информацию в диагностическом сообщении. В этом сценарии мы имеем панику на некотором воображаемом компьютере во время загрузки. Обратите внимание на строки, выделенные жирным:\n\n```\nkernel: BUG: unable to handle kernel NULL pointer dereference at (null) [1]\nkernel: IP: fw_core_init+0x18/0x1000 [firewire_core] [2]\nkernel: PGD 718d00067\nkernel: P4D 718d00067\nkernel: PUD 7b3611067\nkernel: PMD 0\nkernel:\nkernel: Oops: 0002 [#1] PREEMPT SMP\nkernel: Modules linked in: firewire_core(+) crc_itu_t cfg80211 rfkill ipt_REJECT nf_reject_ipv4 nf_log_ipv4 nf_log_common xt_LOG nf_conntrack_ipv4 ... [3]\nkernel: CPU: 6 PID: 1438 Comm: modprobe Tainted: P           O    4.13.3-1-ARCH #1\nkernel: Hardware name: Gigabyte Technology Co., Ltd. H97-D3H/H97-D3H-CF, BIOS F5 06/26/2014\nkernel: task: ffff9c667abd9e00 task.stack: ffffb53b8db34000\nkernel: RIP: 0010:fw_core_init+0x18/0x1000 [firewire_core]\nkernel: RSP: 0018:ffffb53b8db37c68 EFLAGS: 00010246\nkernel: RAX: 0000000000000000 RBX: 0000000000000000 RCX: 0000000000000000\nkernel: RDX: 0000000000000000 RSI: 0000000000000008 RDI: ffffffffc16d3af4\nkernel: RBP: ffffb53b8db37c70 R08: 0000000000000000 R09: ffffffffae113e95\nkernel: R10: ffffe93edfdb9680 R11: 0000000000000000 R12: ffffffffc16d9000\nkernel: R13: ffff9c6729bf8f60 R14: ffffffffc16d5710 R15: ffff9c6736e55840\nkernel: FS:  00007f301fc80b80(0000) GS:ffff9c675dd80000(0000) knlGS:0000000000000000\nkernel: CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\nkernel: CR2: 0000000000000000 CR3: 00000007c6456000 CR4: 00000000001406e0\nkernel: Call Trace:\nkernel:  do_one_initcall+0x50/0x190 [4]\nkernel:  ? do_init_module+0x27/0x1f2\nkernel:  do_init_module+0x5f/0x1f2\nkernel:  load_module+0x23f3/0x2be0\nkernel:  SYSC_init_module+0x16b/0x1a0\nkernel:  ? SYSC_init_module+0x16b/0x1a0\nkernel:  SyS_init_module+0xe/0x10\nkernel:  entry_SYSCALL_64_fastpath+0x1a/0xa5\nkernel: RIP: 0033:0x7f301f3a2a0a\nkernel: RSP: 002b:00007ffcabbd1998 EFLAGS: 00000246 ORIG_RAX: 00000000000000af\nkernel: RAX: ffffffffffffffda RBX: 0000000000c85a48 RCX: 00007f301f3a2a0a\nkernel: RDX: 000000000041aada RSI: 000000000001a738 RDI: 00007f301e7eb010\nkernel: RBP: 0000000000c8a520 R08: 0000000000000001 R09: 0000000000000085\nkernel: R10: 0000000000000000 R11: 0000000000000246 R12: 0000000000c79208\nkernel: R13: 0000000000c8b4d8 R14: 00007f301e7fffff R15: 0000000000000030\nkernel: Code: <c7> 04 25 00 00 00 00 01 00 00 00 bb f4 ff ff ff e8 73 43 9c ec 48\nkernel: RIP: fw_core_init+0x18/0x1000 [firewire_core] RSP: ffffb53b8db37c68\nkernel: CR2: 0000000000000000\nkernel: ---[ end trace 71f4306ea1238f17 ]---\nkernel: Kernel panic - not syncing: Fatal exception [5]\nkernel: Kernel Offset: 0x80000000 from 0xffffffff810000000 (relocation range: 0xffffffff800000000-0xfffffffffbffffffff\nkernel: ---[ end Kernel panic - not syncing: Fatal exception\n```\n\n- [1] Указывает тип ошибки, вызвавшей панику. В данном случае это была ошибка программиста.\n- [2] Указывает, что паника произошла в функции под названием fw_core_init в модуле firewire_core.\n- [3] Указывает, что firewire_core был последним загруженным модулем.\n- [4] Указывает, что функция, вызвавшая функцию fw_core_init, была do_one_initcall.\n- [5] Указывает на то, что это сообщение oops на самом деле является паникой ядра, и система ушла в deadlock.\n\nМы можем предположить, что паника произошла во время инициализации модуля firewire_core при его загрузке. (Тогда можно предположить, что аппаратное обеспечение компьютера несовместимо с данной версией модуля драйвера firewire из-за ошибки программиста, и придётся ждать новой версии). Тем временем, самый простой способ заставить компьютер снова работать — это предотвратить загрузку проблемного модуля. Это можно сделать одним из двух способов:\n\n- Если модуль загружается в процессе работы initramfs, перезагрузитесь с параметром ядра rd.blacklist=firewire_core.\n- Иначе перезагрузитесь с параметром ядра module_blacklist=firewire_core.\n\n"
    },
    {
      "title": "Отладка регрессий",
      "level": 3,
      "content": "См. General troubleshooting#Debugging regressions.\n\nПрежде всего проверьте ядро linux-mainlineAUR на предмет того, не была ли проблема уже решена. В прикреплённом комментарии указан репозиторий с уже собранными ядрами, так что собирать ядро вручную не придётся.\n\nЕсли проблема проявляется не слишком часто, то имеет смысл попробовать LTS-ядро (linux-lts). Старые версии LTS-ядер можно найти в архиве Arch Linux.\n\nЕсли избавиться от проблемы не удалось, попробуйте локализовать баг в linux-gitAUR, после чего сообщите о нём в баг-трекер ядра. Важно проверять ванильное непропатченное ядро, чтобы убедиться, что причиной ошибки является не патч. Если проблемы вызывает патч, то сообщите об этом его автору.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- O'Reilly — Linux Kernel in a Nutshell — электронная книга \"Ядро Linux в двух словах\".\n- Какую из stable-версий ядра лучше использовать? от Greg Kroah-Hartman.\n- Документация ядра Linux\n\n"
    }
  ]
}