{
  "title": "Systemd (Italiano)",
  "url": "https://wiki.archlinux.org/title/Systemd_(Italiano)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Articoli correlati\n\n- /User (Italiano)\n- /Timers (Italiano)\n- /Journal (Italiano)\n- /FAQ (Italiano)\n- init (Italiano)\n- udev (Italiano)\n- Improving performance (Italiano)/Boot process (Italiano)\n- Allow users to shutdown (Italiano)\n\nDalla pagina web del progetto:\n\nStoricamente, ciò che è chiamato \"servizio\" da systemd era in precedenza conosciuto come demone: qualunque programma che sia in esecuzione come processo in \"background\" (in assenza di un terminale o di un'interfaccia utente), che di norma rimane in attesa che si verifichino specifici eventi e offre servizi. Un buon esempio è un server web che attende una richiesta per fornire una pagina, o un server ssh che attende che qualcuno tenti di effettuare il login. Mentre in questi casi si tratta di applicazioni complete, sono presenti demoni il cui lavoro non è visibile. I demoni vengono utilizzati per compiti quali la scrittura di messaggi in un file di log (ad es. syslog, metalog) o il mantenimento di valori accurati per l'ora di sistema (ad es. ntpd). Per maggiori informazioni vedere daemon(7).\n\n"
    },
    {
      "title": "Utilizzo di base di systemctl",
      "level": 2,
      "content": "Il comando principale utilizzato per analizzare e controllare systemd è systemctl. Le sue funzioni sono esaminare lo stato del sistema e gestire il sistema stesso e i relativi servizi. Vedere systemctl(1) per maggiori dettagli.\n\n- È possibile utilizzare tutti i seguenti comandi systemctl con lo switch -H user@host per controllare un'istanza systemd su una macchina remota. Questa funzione utilizzerà SSH per connettersi all'istanza remota di systemd.\n- Gli utenti Plasma possono installare systemdgenie come interfaccia grafica per systemctl. Una volta installato, il modulo verrà aggiunto nella categoria di programmi Sistema.\n\n"
    },
    {
      "title": "Utilizzo delle unità",
      "level": 3,
      "content": "Le unità includono di norma, tra gli altri, servizi (.service), punti di mount (.mount), dispositivi (.device) e socket (.socket).\n\nQuando si utilizza systemctl, è generalmente necessario specificare il nome completo del file dell'unità, incluso il suffisso, ad esempio sshd.socket. Sono tuttavia disponibili alcune forme abbreviate per specificare l'unità nei seguenti comandi systemctl:\n\n- Se non si specifica il suffisso, systemctl darà per sottinteso il suffisso .service. Ad esempio, netctl e netctl.service sono equivalenti.\n- I punti di mount verranno tradotti automaticamente nell'appropriata unità .mount. Ad esempio, specificare /home è equivalente a home.mount.\n- Analogamente ai punti di mount, i dispositivi vengono automaticamente tradotti nell'unità .device appropriata, pertanto specificare /dev/sda2 è equivalente a dev-sda2.device.\n\nVedere systemd.unit(5) per maggiori dettagli.\n\nI comandi riportati nella tabella di seguito operano sulle unità di sistema dal momento che --system è sottinteso come impostazione di default per systemctl. Per operare invece sulle unità utente (per lutente che effettua la chiamata), utilizzare systemctl --user senza privilegi di root. Vedere anche systemd (Italiano)/User (Italiano)#Configurazione di base per abilitare/disabilitare le unità utente per tutti gli utenti.\n\n- La maggior parte dei comandi funziona anche specificando unità multiple, vedere systemctl(1) per maggiori informazioni.\n- Lo switch --now può essere utilizzato in associazione con enable, disable, e mask rispettivamente per avviare, arrestare o mascherare l'unità immediatamente anziché dopo il reboot.\n- Un pacchetto può offrire unità per diverse finalità. Se si è appena installato un pacchetto, è possibile utilizzare il comando pacman -Qql pacchetto | grep -Fe .service -e .socket per verificare la presenza di dette unità.\n\nTable content:\nAzione | Comando | Nota\nAnalisi dello stato del sistema\nMostra lo stato del sistema | systemctl status | \nElenca le unità in esecuzione | systemctl oppuresystemctl list-units | \nElenca le unità con errori | systemctl --failed | \nElenca il file unità installati1 | systemctl list-unit-files | \nMostra lo stato del processo per un PID | systemctl status pid | cgroup slice, memoria e parent\nControllo dello stato dell'unità\nMostra una pagina del manuale associata a un'unità | systemctl help unità | se supportato dall'unità\nStato di un'unità | systemctl status unità | inclusa l'indicazione se l'unità è in esecuzione o no\nVerifica dell'abilitazione di un'unità | systemctl is-enabled unità | \nAvvio, riavvio, ricaricamento di un'unità\nAvvio immediato di un'unità | systemctl start unità come root | \nArresto immediato di un'unità | systemctl stop unità come root | \nRiavvio di un'unità | systemctl restart unità come root | \nRicaricaemnto di un'unità e della relativa configurazione | systemctl reload unità come root | \nRicaricamento della configurazione di systemd manager2 | systemctl daemon-reload come root | scansione alla ricerca di unità nuove o modificate\nAbilitazione di un'unità\nAbilitazione di un'unità per l'avvio automatico al boot | systemctl enable unità come root | \nAbilitazione di un'unità per l'avvio automatico al boot e suo avvio immediato | systemctl enable --now unità come root | \nDisabilitazione di un'unità affinché non si avvi più al boot | systemctl disable unità come root | \nRi-abilitazione di un'unità3 | systemctl reenable unità come root | disabilitazione e nuova abilitazione\nMascheratura di un'unità\nMascheratura di un'unità per renderne impossibile l'avvio4 | systemctl mask unità come root | \nEliminazione della maschera da un'unità | systemctl unmask unità come root | \n\n1. Vedere systemd.unit(5) § UNIT FILE LOAD PATH per informazioni sulle cartelle in cui sono contenuti i file unità.\n1. Questo comando non chiede alle unità modificate di ricaricare le proprie configurazioni (vedere l'azione Ricaricamento).\n1. Ad esempio nel caso la sezione [Install] dell'unità sia cambiata dopo la sua ultima abilitazione.\n1. Sia manualmente che come dipendenza, motivo per cui la mascheratura risulta una pratica pericolosa. Verificare l'eventuale presenza di unità mascherate con il comando: $ systemctl list-unit-files --state=masked\n\n```\n$ systemctl list-unit-files --state=masked\n```\n\n"
    },
    {
      "title": "Gestione energetica",
      "level": 3,
      "content": "polkit è necessario per la gestione energetica come utente senza privilegi. Se ci si trova in una sessione utente systemd-logind locale e non è presente nessun'altra sessione attiva, i seguenti comandi funzioneranno senza privilegi. In caso contrario (ad esempio, poiché un altro utente ha eseguito il login in un tty), systemd richiederà automaticamente la password di root.\n\nTable content:\nAzione | Comando\nArresto e reboot del sistema | systemctl reboot\nArresto e spegnimento del sistema | systemctl poweroff\nSospensione del sistema | systemctl suspend\nIbernazione del sistema (scrittura della ram su disco) | systemctl hibernate\nIl sistema viene messo in uno stato ibrido di sospensione (noto anche come suspend-to-both, che salva la RAM sul disco per poi procedere alla sospensione) | systemctl hybrid-sleep\nPrima sospende il sistema, dopodiché lo riattiva dopo un tempo configurato solo per poi ibernarlo | systemctl suspend-then-hibernate\n\n"
    },
    {
      "title": "Scrittura dei file unità",
      "level": 2,
      "content": "La sintassi dei file unità systemd (systemd.unit(5)) è ispirata da quella dei XDG Desktop Entry Specification file .desktop i quali, a loro volta, si ispirano ai file . ini di Microsoft Windows. I file unità vengono caricati da diverse posizioni (per un elenco completo, eseguire systemctl show --property=UnitPath), ma le principali sono (riportate in ordine crescente di precedenza):\n\n- /usr/lib/systemd/system/: unità fornite dai pacchetti installati\n- /etc/systemd/system/: unità installate dall'amministratore di sistema\n\n- I percorsi di caricamento sono completamente diversi quando si esegue systemd in modalità utente.\n- i nomi unità systemd possono contenere solo caratteri alfanumerici ASCII, underscore e punti. Tutti gli altri caratteri devono essere sostituiti da stringhe escape \"\\x2d\" in stile C, o in alternativa è possibile utilizzare la rispettiva semantica predefinita ('@', '-'). Vedere systemd.unit(5) e systemd-escape(1) per maggiori informazioni.\n\nPer visualizzare degli esempi, analizzare le unità installate dai pacchetti nel proprio sistema o vedere systemd.service(5) § EXAMPLES.\n\n"
    },
    {
      "title": "Gestione delle dipendenze",
      "level": 3,
      "content": "Con systemd, le dipendenze possono essere risolte strutturando in modo corretto i file unità. Il caso più tipico è rappresentato dall'unità A che necessita che l'unità B sia in esecuzione prima che A possa essere avviata. In questo caso aggiungere Requires=B e After=B alla sezione [Unit] di A. Se la dipendenza è opzionale, aggiungere invece Wants=B e After=B. Notare che Wants= e Requires= non implicano After=. Ciò significa che se After= non viene specificato, le due unità verranno avviate in parallelo.\n\nLe dipendenze vengono tipicamente definite nei servizi e non nei target. Ad esempio, network.target è richiamato da qualunque servizio si occupi della configurazione delle interfacce di rete, pertanto definire la propria unità personalizzata affinché si avvi dopo di esso è sufficiente, dal momento che network.target viene avviato in ogni caso.\n\n"
    },
    {
      "title": "Tipi di servizi",
      "level": 3,
      "content": "Sono diverse le tipologie di avvio da considerare quando si scrive un file personalizzato per un servizio. La tipologia è definita dal parametro Type= nella sezione [Service]:\n\n- Type=simple (default): systemd considera il servizio per l'avvio immediato. Il processo non deve essere eseguito come fork. Non utilizzare questa tipologia qualora altri servizi debbano essere ordinati sulla base di questo servizio, a meno che non sia attivato da un socket.\n- Type=forking: systemd considera il servizio per l'avvio nel momento in cui il processo si avvia come fork e il processo parent viene terminato. A meno che non si sia certi che non risulta necessario, per i demoni classici utilizzare questa tipologia. È opportuno specificare anche PIDFile= in modo che systemd possa tenere traccia del processo principale.\n- Type=oneshot: questa tipologia è utile per gli script che eseguono un singolo job per poi essere terminati. Può essere opportuno impostare anche RemainAfterExit=yes, in modo che systemd continui a considerare il servizio attivo anche dopo che è stato terminato. L'impostazione di RemainAfterExit=yes è appropriata per le unità che modificano lo stato del sistema (ad es., montaggio di una partizione).\n- Type=notify: identico a Type=simple, ma con la condizione che il demone invierà un segnale a systemd quando è pronto. L'implementazione di riferimento per questa notifica è fornita da libsystemd-daemon.so.\n- Type=dbus: il servizio è considerato pronto quando il BusName specificato compare nel bus di sistema di DBus.\n- Type=idle: systemd ritarderà l'esecuzione del file binario del servizio fino a quando tutti i job sono stati avviati. A parte questo è molto simile a Type=simple.\n\nVedere la pagina del manuale systemd.service(5) § OPTIONS per una spiegazione più dettagliata dei valori Type.\n\n"
    },
    {
      "title": "Modifica delle unità fornite",
      "level": 3,
      "content": "Per evitare conflitti con pacman, è opportuno evitare di modificare direttamente i file unità forniti dai pacchetti. Ci sono due modi per modificare in sicurezza un'unità senza intervenire sul file originale: creare un nuovo file unità che abbia la precedenza sull'unità originale o creare file drop-in che vengono applicati al di sopra dell'unità originale. Con entrambi i metodi è necessario ricaricare l'unità per applicare le modifiche apportate. Per farlo è possibile modificare l'unità con il comando systemctl edit (che ricarica l'unità automaticamente) o ricaricando tutte le unità con:\n\n```\n# systemctl daemon-reload\n```\n\n- È possibile utilizzare systemd-delta per visualizzare quali file unità siano interessati da file con precedenza su di essi o da estensioni, e cosa sia effettivamente stato cambiato.\n- Utilizzare systemctl cat unità per visualizzare il contenuto di un file unità e di tutti i file di drop-in associati.\n\n"
    },
    {
      "title": "File unità sostitutivi",
      "level": 4,
      "content": "Per sostituire il file unità /usr/lib/systemd/system/unità, creare il file /etc/systemd/system/unità e riabilitare l'unità per aggiornare i link simbolici.\n\nIn alternativa, eseguire:\n\n```\n# systemctl edit --full unità\n```\n\nQuesto comando apre il file /etc/systemd/system/unità nel proprio editor di testo (copiando la versione installata se non ancora esistente) e ricaricandola automaticamente una volta terminate le modifiche.\n\n"
    },
    {
      "title": "File di drop-in",
      "level": 4,
      "content": "Per creare file di drop in per il file unità /usr/lib/systemd/system/unità, creare la cartella /etc/systemd/system/unità.d/ e inserirvi file con estensione .conf per sovrascrivere le opzioni del file unità originale o aggiungerne di nuove. systemd leggerà e applicherà il contenuto di questi file in modo prioritario rispetto all'unità originale.\n\nIl modo più facile per adottare questo approccio è eseguendo il comando:\n\n```\n# systemctl edit unità --drop-in=nome_drop_in\n```\n\nQuesto comando apre il file /etc/systemd/system/unit.d/nome_drop_in.conf nel proprio editor di testo (creandolo se necessario) e ricarica automaticamente l'unità una volta terminate le modifiche. Omettendo l'opzione --drop-in=, systemd utilizzerà il nome file di default override.conf .\n\n- Rimane invariata la necessità di inserire la chiave nella sezione appropriata del file di override.\n- Non tutte le chiavi possono essere sovrascritte mediante file di drop-in. Ad esempio, per modificare la chiave Conflicts= è necessaria la sostituzione del file unità originale.\n\n"
    },
    {
      "title": "Tornare alla versione fornita in origine",
      "level": 4,
      "content": "Per annullare ogni modifica applicata a un file unità utilizzando il comando systemctl edit eseguire:\n\n```\n# systemctl revert unità\n```\n\n"
    },
    {
      "title": "Esempi",
      "level": 4,
      "content": "Ad esempio, se si desidera semplicemente aggiungere una dipendenza opzionale a un'unità, è possibile creare il seguente file:\n\n```\n/etc/systemd/system/unità.d/customdependency.conf\n```\n\n```\n[Unit]\nRequires=nuova dipendenza\nAfter=nuova dipendenza\n```\n\nA titolo di ulteriore esempio, per sostituire l'istruzione ExecStart, creare il seguente file:\n\n```\n/etc/systemd/system/unità.d/customexec.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=nuovo comando\n```\n\nNotare come sia necessario azzerare ExecStart prima che sia possibile riassegnarvi un altro valore [1]. Lo stesso principio si applica a qualunque elemento che possa essere specificato più volte, ad es. OnCalendar per i timer.\n\nUn ulteriore esempio per riavviare automaticamente un servizio:\n\n```\n/etc/systemd/system/unità.d/restart.conf\n```\n\n```\n[Service]\nRestart=always\nRestartSec=30\n```\n\n"
    },
    {
      "title": "Target",
      "level": 2,
      "content": "systemd utilizza i target per raggruppare le unità per mezzo delle dipendenze e come punti di sincronizzazione standardizzati. La loro funzione è simile a quelle dei runlevel ma agiscono in modo leggermente diverso. A ciascun target è associato un nome anziché un numero e ognuno di essi è concepito per svolgere una specifica funzione con la possibilità di averne pi di uno attivo allo stesso tempo. Alcuni target sono implementati ereditando tutti i servizi di un altro target e aggiungendone di altri. Sono presenti dei \"target\" systemd riproducono i comuni runlevel SystemVinit in modo da consentire di passare da un \"target\" all'altro utilizzando il comando telinit RUNLEVEL familiare.\n\n"
    },
    {
      "title": "Rilevare i target attualmente in uso",
      "level": 3,
      "content": "In systemd è preferibile utilizzare il seguente comando in luogo di runlevel:\n\n```\n$ systemctl list-units --type=target\n```\n\n"
    },
    {
      "title": "Creazione di un target personalizzato",
      "level": 3,
      "content": "I runlevel che possedevano un significato definito in sysvinit (vale a dire 0, 1, 3, 5, e 6) possiedono una mappatura 1:1 con un \"target\" systemd specifico. Sfortunatamente non è disponibile alcuna soluzione ottimale per adottare il medesimo approccio per i runlevel definiti dall'utente quali 2 e 4. Nel caso si utilizzi uno di questi ultimi, si suggerisce di creare un \"target\" systemd con un nuovo nome come /etc/systemd/system/proprio target che prenda uno dei runlevel esistenti come base (è possibile visualizzare /usr/lib/systemd/system/graphical.target come esempio), creare una directory /etc/systemd/system/proprio target.wants, e inserirvi i link simbolici ai servizi aggiuntivi presenti in /usr/lib/systemd/system/ che si desidera abilitare.\n\n"
    },
    {
      "title": "Mappatura tra i runlevel SysV e i target systemd",
      "level": 3,
      "content": "Table content:\nRunlevel SysV | Target systemd | Note\n0 | runlevel0.target, poweroff.target | Arresta il sistema.\n1, s, single | runlevel1.target, rescue.target | Modalità utente singolo.\n2, 4 | runlevel2.target, runlevel4.target, multi-user.target | Runlevel definiti dall'utente/specifici per il sito. Per impostazione predefinita, identici a 3.\n3 | runlevel3.target, multi-user.target | Multi-utente, non grafico. Gli utenti possono di norma effettuare il login tramite console multiple o via rete.\n5 | runlevel5.target, graphical.target | Multi-utente, grafico. Di norma possiede tutti i servizi del runlevel 3 più un login grafico.\n6 | runlevel6.target, reboot.target | Riavvio\nemergency | emergency.target | Shell di emergenza\n\n"
    },
    {
      "title": "Cambiare il target attualmente in uso",
      "level": 3,
      "content": "In systemd, i target vengono esposti mediante target unit. È possibile modificarli come segue:\n\n```\n# systemctl isolate graphical.target\n```\n\nQuesto comando si limiterà a cambiare il target attuale, senza alcun effetto sul boot successivo. Equivale a comandi quali telinit 3 o telinit 5 in Sysvinit.\n\n"
    },
    {
      "title": "Modifica del target di default in cui effettuare il boot",
      "level": 3,
      "content": "Il target standard è default.target, che è un link simbolico a graphical.target. A grandi linee corrisponde al vecchio runlevel 5.\n\nPer verificare il target attuale con systemctl:\n\n```\n$ systemctl get-default\n```\n\nPer modificare il target di default in cui eseguire il boot modificare il link simbolico default.target. Con systemctl:\n\n```\n# systemctl set-default multi-user.target\n```\n\n```\nRemoved /etc/systemd/system/default.target.\nCreated symlink /etc/systemd/system/default.target -> /usr/lib/systemd/system/multi-user.target.\n```\n\nIn alternativa, aggiungere i seguenti parametri del kernel al proprio boot loader:\n\n- systemd.unit=multi-user.target (che corrisponde a grandi linee al vecchio runlevel 3),\n- systemd.unit=rescue.target (che corrisponde a grandi linee al vecchio runlevel 1).\n\n"
    },
    {
      "title": "Ordine del target di default",
      "level": 3,
      "content": "systemd sceglie il default.target sulla base del seguente ordine di priorità:\n\n1. Il parametro del kernel precedentemente indicato\n1. Link simbolico di /etc/systemd/system/default.target\n1. Link simbolico di /usr/lib/systemd/system/default.target\n\n"
    },
    {
      "title": "Componenti di systemd",
      "level": 2,
      "content": "Alcuni componenti (elenco non esaustivo) di systemd sono:\n\n- kernel-install — uno script utilizzato per spostare automaticamente i kernel e le rispettive immagini initramfs nella partizione di boot;\n- systemd-boot — semplice boot boot manager UEFI;\n- systemd-creds — per conservare in modo sicuro e recuperare le credenziali utilizzate dalle unità systemd;\n- systemd-cryptenroll — registra i token/dispositivi PKCS#11, FIDO2, TPM2 nei volumi con cifratura LUKS2;\n- systemd-firstboot — inizializzazione di base delle impostazioni di sistema prima del primo boot;\n- systemd-homed — account utente umano portatili;\n- systemd-logind(8) — gestione della sessione;\n- systemd-networkd — gestione della configurazione di rete;\n- systemd-nspawn — contenitore namespace leggero;\n- systemd-resolved — risoluzione del nome di rete;\n- systemd-stub(7) — uno stub per il boot UEFI utilizzato per la creazione di unified kernel image;\n- systemd-sysusers(8) — crea gli utenti e i gruppi di sistema e aggiunge gli utenti ai gruppi in fase di installazione dei pacchetti o in fase di boot;\n- systemd-timesyncd — sincronizzazione dell'ora di sistema all'interno della rete;\n- systemd/Journal — creazione dei log di sistema;\n- systemd/Timers — timer monotonici o in tempo reale per controllare file .service o eventi, alternativa ragionevole a cron.\n\n"
    },
    {
      "title": "Montaggio systemd.mount",
      "level": 3,
      "content": "systemd è responsabile del montaggio delle partizioni e dei file system specificati in /etc/fstab. Il systemd-fstab-generator(8) traduce tutte le voci presenti in /etc/fstab in unità systemd; questa operazione viene eseguita al momento del boot e ogniqualvolta la configurazione del gestore di sistema viene ricaricata.\n\nsystemd estende le comuni funzionalità di fstab e offre ulteriori opzioni di montaggio. Queste opzioni hanno effetto sulle dipendenze dell'unità di montaggio. Ad esempio, assicurano che un montaggio sia eseguito solo dopo che la rete è attiva o solo quando un'altra partizione è stata a sua volta montata. L'elenco specifico delle opzioni di montaggio di systemd, che tipicamente si presentano con prefisso x-systemd., è riportato in dettaglio in systemd.mount(5) § FSTAB.\n\nUn esempio di queste opzioni di montaggio è automounting, che fa sì che il montaggio venga effettuato solo quando la risorsa viene richiesta anziché al boot. Questa opzione è descritta inoltre alla pagina fstab.\n\n"
    },
    {
      "title": "Montaggio automatico di una partizione GPT",
      "level": 4,
      "content": "Nei sistemi avviati in modalità UEFI, nel caso vengano soddisfatte determinate condizioni, systemd-gpt-auto-generator(8) eseguirà il montaggio automatico delle partizioni GPT seguendo le specifiche sulle partizioni individuabili. Le partizioni montate automaticamente possono pertanto essere omesse da fstab, e se la partizione root è montata automaticamente, sarà possibile omettere root= dalla linea di comando del kernel.\n\nI prerequisiti sono:\n\n- Il boot loader deve impostare la variabile EFI LoaderDevicePartUUID, in modo tale da consentire l'identificazione della partizione di sistema EFI. Questa funzione è supportata da systemd-boot, systemd-stub(7), GRUB (grub.cfg generato con grub-mkconfig; un eventuale grub.cfg personalizzato richiede il caricamento del modulo bli) e rEFInd (non abilitata di default). La presenza di questa condizione può essere verificata eseguendo bootctl e controllando lo stato di Boot loader sets ESP information o lo stato di Stub sets ESP information quando si esegue il boot via Unified kernel image.\n- La partizione di root deve essere sul medesimo disco fisico della partizione di sistema EFI. Le altre partizioni che verranno montate automaticamente devono essere sul medesimo disco fisico della partizione di root. Ciò significa quindi che tutte le partizioni montate automaticamente devono essere sul medesimo disco fisso della partizione ESP.\n- Il punto di montaggio /efi deve essere creato manualmente (se lo si desidera), in caso contrario systemd-gpt-auto-generator utilizzerà /boot.\n\nAffinché il montaggio automatico di /var funzioni, il PARTUUID deve corrispondere all'hash HMAC SHA256 dell'UUID del tipo di partizione (4d21b016-b534-45c2-a9fb-5c16e091fd2d) come da chiave dell'ID macchina. Il necessario PARTUUID può essere ottenuto utilizzando:\n\n```\n$ systemd-id128 -u --app-specific=4d21b016-b534-45c2-a9fb-5c16e091fd2d machine-id\n```\n\n"
    },
    {
      "title": "systemd-sysvcompat",
      "level": 3,
      "content": "Il ruolo principale di systemd-sysvcompat (richiesto da base) è di fornire il file binario init tradizionale di linux. Per i sistemi controllati da systemd, init è semplicemente un link simbolico al rispettivo eseguibile systemd.\n\nInoltre fornisce quattro pratiche scorciatoie alle quali gli utenti SysVinit potrebbero essere abituati. Queste pratiche scorciatoie sono halt(8), poweroff(8), reboot(8) e shutdown(8). Ciascuno di questi comandi è un link simbolico a systemctl, ed è governato dal comportamento di systemd. Pertanto si applica quanto discusso in #Gestione energetica.\n\nI sistemi basati su systemd possono rinunciare a questi metodi di compatibilità con System V utilizzando il parametro di boot init= (vedere, ad esempio, /bin/init is in systemd-sysvcompat ?) e gli argomenti di comando systemctl nativi di systemd.\n\n"
    },
    {
      "title": "systemd-tmpfiles - file temporanei",
      "level": 3,
      "content": "systemd-tmpfiles crea, cancella e pulisce i file e le directory temporanei e volatili. Legge i file di configurazione in /etc/tmpfiles.d/ e /usr/lib/tmpfiles.d/ per individuare le azioni da eseguire. I file di configurazione nella prima directory hanno precedenza su quelli nella seconda.\n\nI file di configurazione sono di norma forniti unitamente ai file dei relativi servizi, e il loro nome segue di norma questo schema /usr/lib/tmpfiles.d/programma.conf. Ad esempio, il demone Samba richiede che la directory /run/samba sia presente e configurata con i permessi corretti. Pertanto, il pacchetto samba viene fornito con la seguente configurazione:\n\n```\n/usr/lib/tmpfiles.d/samba.conf\n```\n\n```\nD /run/samba 0755 root root\n```\n\nI file di configurazione possono anche essere utilizzati per scrivere valori all'interno di determinati file al boot. Ad esempio, nel caso si sia fatto ricorso a /etc/rc.local per disabilitare il wakeup da dispositivi USB con echo USBE > /proc/acpi/wakeup è possibile, come alternativa, utilizzare il seguente tmpfile:\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Path                  Mode UID  GID  Age Argument\nw    /proc/acpi/wakeup     -    -    -    -   USBE\n```\n\nVedere le pagine del manuale systemd-tmpfiles(8) e tmpfiles.d(5) per maggiori dettagli.\n\n"
    },
    {
      "title": "Trucchi e suggerimenti",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n"
    },
    {
      "title": "Strumenti GUI di configurazione",
      "level": 3,
      "content": "- systemadm — Browser grafico per le unità systemd. Permette di visualizzare l'elenco delle unità, eventualmente filtrate per tipo.\n\n- SystemdGenie — Strumento di gestione di systemd basato su tecnologie KDE.\n\n"
    },
    {
      "title": "Esecuzione di servizi dopo l'attivazione della rete",
      "level": 3,
      "content": "Per ritardare l'esecuzione di un servizio fino al momento in cui la rete è attiva, includere le seguenti dipendenze nel file .service:\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target\n...\n```\n\nÈ inoltre necessario abilitare il servizio di attesa della rete del gestore di rete in uso in modo tale che network-online.target rifletta in modo appropriato lo stato della rete.\n\n- Se si utilizza NetworkManager, NetworkManager-wait-online.service andrebbe abilitato unitamente a NetworkManager.service. Verificare l'avvenuta attivazione con il comando systemctl is-enabled NetworkManager-wait-online.service. In caso contrario, riabilitare NetworkManager.service.\n- Nel caso di netctl, abilitare il servizio netctl-wait-online.service (a meno che non si utilizzi netctl-auto; vedere FS#75836).\n- Se si utilizza systemd-networkd, systemd-networkd-wait-online.service andrebbe abilitato unitamente a systemd-networkd.service. Verificare l'avvenuta attivazione con il comando systemctl is-enabled systemd-networkd-wait-online.service. In caso contrario, riabilitare systemd-networkd.service.\n\nPer spiegazioni maggiormente dettagliate, vedere la discussione nella pagina relativa ai punti di sincronizzazione della configurazione di rete.\n\nSe un servizio necessita di effettuare delle query DNS, andrebbe inoltre eseguito dopo nss-lookup.target:\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target nss-lookup.target\n...\n```\n\nVedere systemd.special(7) § unità di sistema speciali passive.\n\nPer avere effetto, nss-lookup.target necessita di un servizio che lo richiami tramite Wants=nss-lookup.target e che si ponga prima di esso nell'ordine di esecuzione con Before=nss-lookup.target. Tipicamente questa funzione viene svolta dai DNS resolver locali.\n\nPer controllare quale servizio attivo, se presente, richiami nss-lookup.target eseguire il comando:\n\n```\n$ systemctl list-dependencies --reverse nss-lookup.target\n```\n\n"
    },
    {
      "title": "Abilitazione delle unità installate come impostazione predefinita",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nArch Linux viene fornito con /usr/lib/systemd/system-preset/99-default.preset contenente disable *. Ciò fa sì che systemctl preset disabiliti tutte le unità per impostazione predefinita. Di conseguenza, quando viene installato un nuovo pacchetto, deve essere l'utente ad abilitare manualmente l'unità.\n\nQualora si desideri modificare questo comportamento, è sufficiente creare un link simbolico da /etc/systemd/system-preset/99-default.preset a /dev/null per inibire l'azione del file di configurazione. Ciò farà sì che systemctl preset abiliti tutte le unità che vengono installate, indipendentemente dal loro tipo, a meno che non sia diversamente specificato in un altro file in una delle directory di configurazione di systemctl preset. Le unità utente non sono interessate. Vedere systemd.preset(5) per maggiori informazioni.\n\n"
    },
    {
      "title": "Sandboxing degli ambienti applicazione",
      "level": 3,
      "content": "Note: **This article or section is a candidate for moving to systemd/Sandboxing.** This article or section is a candidate for moving to systemd/Sandboxing.\n\nThis article or section is a candidate for moving to systemd/Sandboxing.\n\nÈ possibile creare un file unità come sandbox al fine di isolare le applicazioni e i relativi processi all'interno di un ambiente virtuale rinforzato. systemd sfrutta i namespace, un elenco di capability e gruppi di controllo consentiti/proibiti per i processi dei contenitori, per mezzo di una configurazione estesa dell'ambiente di esecuzione systemd.exec(5).\n\nL'ottimizzazione di un file unità systemd esistente con il sandboxing dell'applicazione necessita tipicamente di un processo di apprendimento per tentativi ed errori, accompagnato da un uso intensivo di strace, stderr, logging degli errori in journalctl(1), e lettura degli output. È consigliabile dapprima effettuare una ricerca nella documentazione upstream per verificare l'esistenza di test già effettuati sui quali basare i propri tentativi. Per ottenere un punto di partenza per le possibili opzioni di rafforzamento, eseguire\n\n```\n$ systemd-analyze security unità\n```\n\nAlcuni esempi sulle modalità di implementazione del sandboxing con systemd:\n\n- CapabilityBoundingSet definisce un elenco di capabilities(7) consentite o proibite per un'unità. Vedere systemd.exec(5) § CAPABILITIES. La capability CAP_SYS_ADM, ad esempio, che dovrebbe essere uno degli obiettivi di un sandbox sicuro: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n- La capability CAP_SYS_ADM, ad esempio, che dovrebbe essere uno degli obiettivi di un sandbox sicuro: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n"
    },
    {
      "title": "Notifiche di fallimento dei servizi",
      "level": 3,
      "content": "Note: **This article or section is a candidate for merging with systemd/Timers#MAILTO.** This article or section is a candidate for merging with systemd/Timers#MAILTO.\n\nThis article or section is a candidate for merging with systemd/Timers#MAILTO.\n\nPer consentire l'invio di notifiche sui fallimenti dei servizi, è necessario aggiungere una direttiva OnFailure= ai rispettivi file servizio, ad esempio utilizzando un file di drop-in di configurazione. È possibile aggiungere questa direttiva a ogni unità servizio con un file di drop-in di configurazione di livello top. Per maggior dettagli sui file di drop-in di livello top, vedere systemd.unit(5).\n\nCreare un file di drop-in di livello top per i servizi:\n\n```\n/etc/systemd/system/service.d/toplevel-override.conf\n```\n\n```\n[Unit]\nOnFailure=failure-notification@%n\n```\n\nIn questo modo viene aggiunto OnFailure=failure-notification@%n a ogni file servizio. Se si verifica il fallimento di una_unità_servizio, verrà avviato failure-notification@una_unità_servizio per gestire la consegna della notifica (o qualunque compito sia configurato per eseguire).\n\nCreare l'unità modello failure-notification@:\n\n```\n/etc/systemd/system/failure-notification@.service\n```\n\n```\n[Unit]\nDescription=Send a notification about a failed systemd unit\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=/percorso/a/failure-notification.sh %i\n```\n\nÈ possibile creare lo script failure-notification.sh e definire le azioni da eseguire o la modalità di invio delle notifiche (mail, gotify, xmpp, ecc.). %i sarà il nome dell'unità di servizio interessata dal fallimento che verrà passato come argomento allo script.\n\nAl fine di prevenire la ricorsività delle istanze in avvio di failure-notification@.service in caso di fallimento dell'avvio, creare un file di drop-in di configurazione vuoto con il medesimo nome del file di drop-in di livello top (il file di configurazione vuoto a livello di servizio ha precedenza rispetto a quello di livello top inibendone l'azione):\n\n```\n# mkdir -p /etc/systemd/system/failure-notification@.service.d\n# touch /etc/systemd/system/failure-notification@.service.d/toplevel-override.conf\n```\n\n"
    },
    {
      "title": "Spegnimento automatico di un hard disk esterno all'arresto",
      "level": 3,
      "content": "Note: **This article or section is a candidate for merging with Udisks#Troubleshooting.** This article or section is a candidate for merging with Udisks#Troubleshooting.\n\nThis article or section is a candidate for merging with Udisks#Troubleshooting.\n\nSe un hard disk esterno non viene correttamente spento al momento dell'arresto del sistema, potrebbe risultare opportuno risolvere questo problema. La soluzione più pratica è utilizzare a tal fine udisks.\n\nAbilitare udisks2.service.\n\nUn servizio che invochi il nostro script potrebbe essere:\n\n```\n/etc/systemd/system/handle_external_hdds.service\n```\n\n```\n[Unit]\nRequires=udisks2.service\nRequires=graphical.target\nAfter=graphical.target\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStop=/usr/local/bin/handle_external_hdds.sh\n[Install]\nWantedBy=graphical.target\n```\n\nAbilitare handle_external_hdds.service\n\nRicaricare il demone di systemd per applicare la nuova impostazione.\n\nEseguire il reboot o riavviare graphical.target per verificare il corretto funzionamento.\n\nUn esempio di script per gestire un numero arbitrario di partizioni su un singolo disco:\n\n```\n/usr/local/bin/handle_external_hdds.sh\n```\n\n```\n#!/bin/bash -u\n\ndeclare -a uuids=(uuid_list)\n\n# Only proceed if the drive is present.\nif [[ ! -L \"/dev/disk/by-uuid/${uuids[0]}\" ]]; then\n  exit 0\nfi\n\nfor uuid in \"${uuids[@]}\"; do\n  if findmnt \"/dev/disk/by-uuid/$uuid\"; then\n    umount \"/dev/disk/by-uuid/$uuid\"\n  fi\ndone\n\n# udisksctl powers off proper drive even if its partition is supplied\nudisksctl power-off -b \"/dev/disk/by-uuid/${uuids[0]}\"\n```\n\nuuid_list è un elenco di UUID delimitati da spazi, corrispondenti alle partizioni del dispositivo da verificare, ad es. \"uuid_1\" \"uuid_2\".\n\n"
    },
    {
      "title": "Indagare sui servizi falliti",
      "level": 3,
      "content": "Per individuare quali servizi systemd non si siano avviati eseguire:\n\n```\n$ systemctl --state=failed\n```\n\nPer scoprire il motivo del mancato avvio, esaminare il rispettivo output di log. Vedere systemd/Journal#Filtering output per maggiori dettagli.\n\n"
    },
    {
      "title": "Diagnosi dei problemi di boot",
      "level": 3,
      "content": "systemd offre diverse opzioni per la diagnosi dei problemi che interessano in processo di boot. Vedere boot debugging per istruzioni più generali e opzioni per catturare i messaggi di boot prima che systemd prenda il controllo del processo di boot. Vedere anche freedesktop.org's documentazione di debug di systemd.\n\n"
    },
    {
      "title": "Diagnosi di un servizio",
      "level": 3,
      "content": "Se un servizio systemd mostra un comportamento non conforme o se si desidera ottenere maggiori informazioni su cosa si sta verificando, impostare la variabile d'ambiente SYSTEMD_LOG_LEVEL su debug. Ad esempio, per eseguire il demone systemd-networkd in modalità di debug:\n\nAggiungere un file di drop-in per il servizio inserendo le seguenti due linee:\n\n```\n[Service]\nEnvironment=SYSTEMD_LOG_LEVEL=debug\n```\n\nOppure, in modo equivalente, impostare manualmente la variabile d'ambiente:\n\n```\n# SYSTEMD_LOG_LEVEL=debug /lib/systemd/systemd-networkd\n```\n\ndopodiché riavviare systemd-networkd e visualizzare il journal relativo al servizio con l'opzione -f/--follow.\n\n"
    },
    {
      "title": "Lo spegnimento/il riavvio impiega un tempo eccessivamente lungo",
      "level": 3,
      "content": "Se il processo di spegnimento richiede un tempo particolarmente lungo (o sembra bloccarsi), con ogni probabilità ciò è da attribuirsi a un servizio che non si arresta. systemd attende per un po' di tempo prima di tentare di forzarne l'arresto. Per verificare se si è interessati da questo problema, vedere Shutdown completes eventually nella wiki di systemd.\n\nUn problema comune è uno spegnimento in stallo o un processo di sospensione. È possibile eseguire entrambi i seguenti comandi e analizzare il rispettivo output per accertarsi della presenza di questo problema\n\n```\n# systemctl poweroff\n```\n\n```\nFailed to power off system via logind: There's already a shutdown or sleep operation in progress\n```\n\n```\n# systemctl list-jobs\n```\n\n```\nJOB UNIT                    TYPE  STATE\n...\n21593 systemd-suspend.service start running\n21592 suspend.target          start waiting\n..\n```\n\nLa soluzione a questo problema è annullare questi processi eseguendo\n\n```\n# systemctl cancel\n# systemctl stop systemd-suspend.service\n```\n\ndopodiché provare a eseguire nuovamente lo spegnimento o il riavvio.\n\n"
    },
    {
      "title": "I processi con breve tempo di esecuzione non registrano alcun output nel log",
      "level": 3,
      "content": "Se l'esecuzione di journalctl -u foounit come utente root non mostra alcun output per un servizio con breve tempo di esecuzione, provare con il PID. Ad esempio, se systemd-modules-load.service fallisce, e systemctl status systemd-modules-load indica che è stato eseguito come PID 123, potrebbe essere possibile visualizzare l'output nel journal per questo PID, ad es. eseguendo journalctl -b _PID=123 come utente root. I campi dei metadati per il journal quali _SYSTEMD_UNIT e _COMM sono rilevati in modo asincrono e fanno affidamento sull'esistenza della directory /proc per il processo. La risoluzione di questo problema richiede di intervenire sul kernel per far sì che questi dati vengano forniti mediante connessione socket, similmente a SCM_CREDENTIALS. In breve, si tratta di un bug. Tenere in considerazione che, per scelta progettuale di systemd, i servizi che falliscono immediatamente potrebbero non generare alcun output nel journal.\n\n"
    },
    {
      "title": "Il tempo di boot aumenta nel tempo",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nDopo aver usato systemd-analyze un numero elevato di utenti ha notato un aumento significativo del proprio tempo di boot rispetto al passato. L'utilizzo di systemd-analyze blame ha mostrato come NetworkManager impieghi un tempo insolitamente lungo per l'avvio.\n\nIl problema, per alcuni utenti, era dovuto alle dimensioni eccessive raggiunte dal file /var/log/journal. Ciò potrebbe incidere anche sulle prestazioni ad esempio di systemctl status o journalctl. Pertanto la soluzione è rimuovere ogni file dalla cartella (idealmente effettuandone prima un backup, almeno come accorgimento temporaneo) per poi impostare un limite per le dimensioni del file del journal come descritto in Systemd/Journal#Journal size limit.\n\n"
    },
    {
      "title": "systemd-tmpfiles-setup.service non si avvia al boot",
      "level": 3,
      "content": "A partire dalla versione 219 di systemd, /usr/lib/tmpfiles.d/systemd.conf specifica gli attributi ACL per le directory in /var/log/journal e, pertanto, richiede l'abilitazione del supporto ACL per il file system che ospita il journal.\n\nVedere Access Control Lists#Enable ACL per le istruzioni su come abilitare ACL nel file system su cui è salvato /var/log/journal.\n\n"
    },
    {
      "title": "Disabilitazione delle modalità di emergenza sulla macchina remota",
      "level": 3,
      "content": "Si potrebbe desiderare disabilitare la modalità di emergenza in una macchina remota, ad esempio una macchina virtuale con hosting su Azure o Google Cloud. Questo in quanto, se viene attivata la modalità di emergenza, ciò impedirà alla macchina di connettersi alla rete.\n\nPer disabilitare questa modalità mascherare emergency.service e emergency.target.\n\n"
    },
    {
      "title": "Vedere anche",
      "level": 2,
      "content": "- Wikipedia:systemd\n- Sito web ufficiale Ottimizzazioni di systemd FAQ su systemd Trucchi e suggerimenti su systemd\n- systemd(1)\n- Altre distribuzioni Gentoo:Systemd Fedora:Systemd Fedora:How to debug Systemd problems Fedora:SysVinit to Systemd Cheatsheet Debian:systemd\n- Storia del blog di Lennart, aggiornamento 1, aggiornamento 2, aggiornamento 3, sommario\n- Debug dei servizi di systemd\n- systemd per amministratori (PDF)\n- Come utilizzare systemctl per gestire i servizi e le unità systemd\n- Gestione della sessione con systemd-logind\n- Syntax highlighting in Emacs per i file systemd\n- Articolo introduttivo in due parti sul magazine The H Open.\n\n- Ottimizzazioni di systemd\n- FAQ su systemd\n- Trucchi e suggerimenti su systemd\n\n- Gentoo:Systemd\n- Fedora:Systemd\n- Fedora:How to debug Systemd problems\n- Fedora:SysVinit to Systemd Cheatsheet\n- Debian:systemd\n\n"
    }
  ]
}