{
  "title": "Data-at-rest encryption (Español)",
  "url": "https://wiki.archlinux.org/title/Data-at-rest_encryption_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2019-09-18** \n\nArtículos relacionados\n\n- dm-crypt (Español)\n- TrueCrypt\n- eCryptfs\n- EncFS\n- gocryptfs\n- Tomb\n- tcplay\n- GnuPG\n- Self-Encrypting Drives\n\nEste artículo trata sobre el software de cifrado de discos, que cifra/descifra sobre la marcha los datos escritos en/desde un dispositivo de bloque, partición o directorio. Ejemplos de dispositivos de bloque son discos duros, unidades flash y DVD.\n\nEl cifrado de disco solo debe ser visto como un complemento a los mecanismos de seguridad existentes en el sistema operativo — se enfoca a asegurar el acceso físico fuera de línea —, al tiempo que se delega en otras partes del sistema que proporcinan elementos confiables como la seguridad de la red y la seguridad del usuario basada en el control de acceso.\n\nPara el cifrado de disco completo (siglas en inglés FDE Full-disk encryption), vea dm-crypt (Español)/Encrypting an entire system (Español).\n\n"
    },
    {
      "title": "¿Por qué utilizar la criptografía?",
      "level": 2,
      "content": "El cifrado de discos garantiza que los archivos siempre se almacenan en el disco de forma cifrada. Los archivos solo están disponibles en forma legible para el sistema operativo y las aplicaciones, mientras el sistema está funcionando y desbloqueado por un usuario de confianza. Una persona no autorizada que mire el contenido del disco directamente solo encontrará datos aleatorios confusos en lugar de los archivos reales.\n\nPor ejemplo, esto sirve para evitar la visualización no autorizada de los datos cuando el ordenador o el disco duro se encuentre:\n\n- situado en un lugar donde personas que no son de confianza pueden tener acceso a él mientras se está ausente,\n- perdido o robado, cosa que puede ocurrir a portátiles, netbooks o dispositivos de almacenamiento externo,\n- en el taller de reparaciones,\n- desechados después del final de su vida útil.\n\nAdemás, el cifrado del disco también se puede utilizar para añadir un plus de seguridad frente a los intentos no autorizados de manipulación del sistema operativo, por ejemplo, instalando keyloggers o troyanos por hacker que pueden tener acceso físico al sistema, mientras se está ausente.\n\nNote: ** no** \n\nSe seguirá siendo vulnerable a:\n\n- Los atacantes que pueden irrumpir en su sistema (por ejemplo, a través de Internet) mientras se está funcionando y después de que se han desbloqueado y montado las partes cifradas del disco.\n- Los atacantes que son capaces de tener acceso físico al ordenador mientras está en ejecución (incluso si se utiliza un screenlocker), o muy poco después de haberlo ejecutado, si tienen los recursos para llevar a cabo un ataque de arranque en frío.\n- Una entidad gubernamental, que no solo cuenta con los recursos para realizar fácilmente los ataques anteriores, sino que también puede simplemente obligar a renunciar a sus claves/frases de acceso mediante diversas técnicas de coerción. En la mayoría de los países no democráticos de todo el mundo, así como en los EE.UU. y el Reino Unido, puede ser legal para las agencias de seguridad acceder si tienen sospechas de que se podría estar ocultando algo de interés.\n\nSe requiere una fuerte configuración de cifrado de disco (por ejemplo, el cifrado completo del sistema con comprobación de su autenticidad y sin partición de arranque en modo texto plano) para tener una cierta ventaja contra los atacantes profesionales que son capaces de alterar el sistema antes de que lo utilice. Y aun así no es seguro de que realmente se pueda prevenir todo tipo de manipulación (por ejemplo, keyloggers tipo hardware). El mejor remedio podría ser el hardware-based full-disk encryption|cifrado de disco completo basado en hardware]] y la computación confiable.\n\n"
    },
    {
      "title": "Cifrar datos del sistema",
      "level": 2,
      "content": "Cuando solo se cifra los datos del propio usuario (a menudo situado en el directorio /home o en un medio extraíble como un DVD de datos), el cifrado de datos es el uso más simple y menos intrusivo del cifrado de discos, pero tiene algunos inconvenientes significativos. En los sistemas informáticos modernos, hay muchos procesos ejecutados en segundo plano que puede almacenar, por ejemplo en caché, información sobre los datos del usuario o partes de datos en zonas no cifrados del disco duro, como:\n\n- particiones swap (posibles remedios: desactivar swap o realizar el cifrado del espacio de intercambio también)\n- /tmp ( archivos temporales creados por las aplicaciones del usuario) (posibles remedios: evitar este tipo de aplicaciones; montar /tmp dentro de ramdisk)\n- /var (archivos de registros, bases de datos y similares; por ejemplo, locate almacena un índice de todos los nombres de los archivos en /var/lib/plocate/plocate.db)\n\n- (posibles remedios: desactivar swap o realizar el cifrado del espacio de intercambio también)\n\n- (posibles remedios: evitar este tipo de aplicaciones; montar /tmp dentro de ramdisk)\n\nLa solución es cifrar los datos del sistema y del usuario, evitando el acceso físico no autorizado a los datos privados que el sistema puede almacenar en la memoria caché. Sin embargo, esto tiene la desventaja de que el desbloqueo de las partes cifradas del disco tiene que ocurrir en el momento del arranque. Otro beneficio del cifrado de datos del sistema es que complica la instalación de malware como keyloggers o rootkits para alguien con acceso físico.\n\n"
    },
    {
      "title": "Métodos disponibles",
      "level": 2,
      "content": "Todos los métodos de cifrado de discos operan de tal manera que a pesar de que el disco en realidad posee los datos cifrados, el sistema operativo y las aplicaciones los «ven» como sus correspondientes datos legibles normales, siempre y cuando el contenedor cifrado (es decir, la parte lógica del disco que contiene los datos cifrados) haya sido «desbloqueado» y montado.\n\nPara que esto suceda, cierta «información secreta» (por lo general en forma de un archivo de claves y/o frase de acceso) debe ser suministrada por el usuario, de la cual, se deriva la clave de cifrado real (y se almacena en el llavero del kernel mientras dure la sesión).\n\nSi no se está completamente familiarizado con este tipo de operaciones, lea también la sección siguiente #Cómo funciona el cifrado.\n\nLos métodos de cifrado del disco disponibles se pueden separar en dos tipos por su capa de operación:\n\n"
    },
    {
      "title": "Cifrar sistemas de archivos apilados",
      "level": 3,
      "content": "Las soluciones del cifrado del sistema de archivos apilados se implementan como una capa que se superpone en la parte superior de un sistema de archivos existente, haciendo que todos los archivos escritos a una carpeta habilitada para cifrarlos se cifren sobre la marcha antes de que el sistema de archivos subyacente los grabe en el disco, y se descifran cuando el sistema de archivos los lee desde el disco. De esta manera, los archivos se almacenan en el sistema de archivos anfitrión en forma cifrada (lo que significa que sus contenidos y, por lo general, también sus nombres de archivo/carpeta, se sustituyen por datos aleatorios de más o menos la misma longitud), pero, aparte, siguen existiendo en ese sistema de archivos como lo harían sin cifrar, a modo de archivos normales / enlaces simbólicos / enlaces duros / etc.\n\nLa forma en que se implementa consiste en que para desbloquear la carpeta donde se almacenan los archivos cifrados en bruto en el sistema de archivos anfitrión («directorio inferior»), ésta debe montarse ( utilizando un pseudo sistema de archivos apilados especial) sobre sí misma u, opcionalmente, en una ubicación diferente («directorio superior» ), donde los mismos archivos aparecen entonces en forma legible — hasta que se desmonta de nuevo o se apaga el sistema —.\n\nLas soluciones disponibles en esta categoría son eCryptfs y EncFS.\n\n"
    },
    {
      "title": "Optimizar el almacenamiento en la nube",
      "level": 4,
      "content": "Si está implementando un sistema de cifrado de archivos apilados para lograr una sincronización con prueba de conocimiento nulo (en inglés «Zero-Knowledge») en ubicaciones controladas por terceros[*], como los servicios de almacenamiento en la nube, es posible que desee considerar alternativas a eCryptfs y EncFS, ya que no están optimizados para la transmisión de archivos a través de Internet. Hay algunas soluciones diseñadas para este propósito en su lugar:\n\n- gocryptfs\n- cryptomatorAUR (multiplataforma)\n- cryfs\n\nTenga en cuenta que algunos servicios de almacenamiento en la nube ofrecen cifrado con prueba de conocimiento nulo directamente a través de su propia aplicaciones de cliete.\n\n"
    },
    {
      "title": "Cifrar dispositivos de bloques",
      "level": 3,
      "content": "Los métodos de cifrado de dispositivo de bloque, por el contrario, operan como una capa debajo del sistema de archivos y se aseguran que todo lo escrito en un determinado dispositivo de bloques (es decir, un disco completo o una partición o un archivo que actúa como un dispositivo loop) quede cifrado. Esto significa que mientras el dispositivo de bloque no está en línea, todo su contenido se parece a una amalgama de datos aleatorios, y no hay forma de determinar qué tipo de sistema de archivos y qué datos contiene. El acceso a los datos ocurre, de nuevo, mediante el montaje del contenedor protegido (en este caso el dispositivo de bloque) a una ubicación arbitraria con un método especial.\n\nLas siguientes soluciones de «cifrado de dispositivos de bloques» están disponibles en Arch Linux:\n\n- LUKS, utilizado por defecto, es una capa adicional eficaz que almacena toda la información necesaria de configuración para dm-crypt, la partición abstacta y la gestión de las claves, en el propio disco en un intento de mejorar la facilidad de uso y la seguridad criptográfica.\n- la modalidad plain de dm-crypt, aun siendo la funcionalidad original del kernel, no tiene la misma capa de eficacia. Es más difícil de obtener la misma fuerza criptográfica con ella. Para lograrlo, las claves deben ser más largas (frases de acceso, archivos de claves) para conseguir dicho resultado. Sin embargo, tiene otras ventajas, que se describen en la sección #Cifrar dispositivo de bloques vs cifrar de sistema de archivos apilados.\n\nPara conocer las implicaciones prácticas de la capa de operación elegida, consulte la siguiente tabla comparativa, así como el escrito general para eCryptfs. Vea Category:Encryption (Español) para el contenido disponible de los métodos comparados más abajo, así como otras herramientas no incluidas en la tabla.\n\n"
    },
    {
      "title": "Cifrar dispositivo de bloques vs cifrar de sistema de archivos apilados",
      "level": 3,
      "content": "Table content:\nAspecto | Cifrar dispositivos de bloques | Cifrar sistemas de archivos apilados\nCifrados | dispositivos de bloque completo | archivos\nEl contenedor para datos encriptados puede ser... | un disco o partición de disco / un archivo que actúa como una partición virtual | un directorio en un sistema de archivos existente\nRelación con el sistema de archivos | opera debajo de la capa del sistema de archivos: no le importa si el contenido del dispositivo de bloque cifrado es un sistema de archivos, una tabla de particiones, una configuración de LVM o cualquier otra cosa | agrega una capa adicional a un sistema de archivos existente, para cifrar/descifrar automáticamente los archivos cada vez que se escriben/leen\nLos metadatos del archivo (número de archivos, estructura de directorios, tamaños de archivos, permisos, mtimes, etc.) están cifrados | Sí | No(los nombres de archivo y directorios pueden estar encriptados)\nSe puede utilizar para cifrar de forma personalizada unidades de disco duro completas (incluidas las tablas de particionado) | Sí | No\nSe puede utilizar para cifrar el espacio de intercambio | Sí | No\nSe puede utilizar sin asignar previamente una cantidad fija de espacio para el contenedor de datos cifrados | No | Sí\nSe puede utilizar para proteger sistemas de archivos existentes sin acceso a dispositivos de bloque, por ejemplo, NFS o Samba, almacenamiento en la nube, etc. | No | Sí\nPermite realizar copias de seguridad de archivos cifrados sin conexión | No | Sí\n\n"
    },
    {
      "title": "Cuadro comparativo",
      "level": 3,
      "content": "La columna «dm-crypt +/- LUKS» denota características de dm-crypt tanto para la modalidad de cifrado LUKS («+») como plain («-»). Si una característica específica requiere el uso de LUKS, esto se indica con «(con LUKS). De la misma manera «(sin LUKS)» indica que el uso de LUKS es contraproducente para lograr la función y el modo plain es el aconsejado.\n\nTable content:\nResumen | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFS | gocryptfs\nTipo de cifrado | cifrado de dispositivos de bloques | cifrado de dispositivos de bloques | cifrado de dispositivos de bloques | cifrado de dispositivos de bloques | cifrado de sistemas de archivos apilados | cifrado de sistemas de archivos apilados | cifrado de sistemas de archivos apilados\nNota | el más longevo; posiblemente el más rápido; funciona en sistemas antiguos | estándar de hecho para el cifrado de dispositivos de bloques en Linux; muy flexible | solución muy portable, bien pulida y controlada pero abandonada | bifurcación mantenida de TrueCrypt | ligeramente más rápido respecto a EncFS; cifra archivos singulares portables a otros sistemas | fácil de usar; permite la adminitración por usuario normal | aspiring successor of EncFS\nDisponibilidad en Arch Linux | necesita compilar manualmente un kernel personalizado | módulos del kernel: ya cargados por el kernel por defecto; herramientas: device-mapper, cryptsetup | truecryptAUR[enlace roto: package not found] | veracrypt | módulos del kernel: ya cargados por el kernel por defecto; herramientas: ecryptfs-utils | encfs | gocryptfs\nLicencia | GPL | GPL | TrueCrypt License 3.1 | Apache License 2.0, partes sujetas a la licencia de TrueCrypt v3.0 | GPL | GPL | MIT\nCifrado implementado en... | en el espacio del kernel | en el espacio del kernel | en el espacio del kernel | en el espacio del kernel | en el espacio del kernel | en el espacio del usuario (utilizando FUSE) | en el espacio del usuario (utilizando FUSE)\nMetadatos criptográficos almacedados en... | ? | con LUKS: en la cabecera de LUKS | al principio/final del dispositivo (descifrado) | al principio/final del dispositivo (descifrado) (formato específico) | en la cabecera de cada archivo cifrado | en el archivo de control al principio de cada contenedor EncFs\nClave de cifrado almacenada en... | ? | con LUKS: encabezado LUKS | al principio/final del dispositivo | al principio/final del dispositivo (formato específico) | el archivo de claves se puede almacenar en cualquier lugar | el archivo de claves se puede almacenar en cualquier lugar [1][2]\nCaracterísticas de usabilidad | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs | gocryptfs\nLos usuarios normales pueden crear/eliminar los contenedores para datos cifrados | No | No | No | No | limitada | Sí | Sí\nProporciona una interfaz gráfica | No | No | Sí | Sí | No | Sí opcional | No\nSoporte para montarse automáticamente al iniciar sesión | ? | Sí | Sí con systemd y /etc/crypttab | Sí con systemd y /etc/crypttab | Sí | Sí\nSoporte para desmontarse automáticamente en caso de inactividad | ? | ? | ? | ? | ? | Sí | ?\nCaracterísticas de seguridad | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs | gocryptfs\nAlgoritmos de cifrado soportados | AES | AES, Anubis, CAST5/6, Twofish, Serpent, Camellia, Blowfish,… (cada algoritmo de cifrado es ofrecido por el Crypto API del kernel) | AES, Twofish, Serpent | AES, Twofish, Serpernt, Camellia, Kuznyechik | AES, Blowfish, Twofish... | AES, Blowfish, Twofish, y cualquier otro algoritmo de cifrado disponible en el sistema | AES\nIntegridad | ninguna | opcional en LUKS2 | ninguna | ninguna | ninguna | ninguna (modo por defecto)HMAC (modo paranoia) | GCM\nSoporte para salting | ? | Sí(con LUKS) | Sí | Sí | Sí | ? | Sí\nSoporte para múltiples sistemas de cifrado en cascada | ? | No en un solo dispositivo, pero permite conectarse a dispositivos de bloques en cascada | Sí AES-Twofish, AES-Twofish-Serpent, Serpent-AES, Serpent-Twofish-AES, Twofish-Serpent | Sí AES-Twofish, AES-Twofish-Serpent, Serpent-AES, Serpent-Twofish-AES, Twofish-Serpent | ? | No | No\nSoporte para la difusión del key-slot | ? | Sí(con LUKS) | ? | ? | ? | ? | ?\nProtección contra el forzado de clave | Sí | Sí(sin LUKS) | ? | ? | ? | ? | ?\nSoporte para múltiples claves (revocables independientemente) para los mismos datos cifrados | ? | Sí(con LUKS) | ? | ? | ? | No\nCaracterísticas de rendimiento | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs | gocryptfs\nSoporte multithreading | ? | Sí[3] | Sí | Sí | ? | ? | Sí\nSoporte para cifrado de hardware acelerado | Sí | Sí | Sí | Sí | Sí | Sí[4] | Sí\nEspecífico del cifrado de dispositivos de bloques | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | \nSoporte para redimensionar (manualmente) el dispositivo de bloque cifrado in situ | ? | Sí | No | No | No\nEspecífico del cifrado de sistemas de archivos apilados |  | eCryptfs | EncFs | gocryptfs\nSistemas de archivos soportados | ext3, ext4, xfs (con salvedades), jfs, nfs... | ext3, ext4, xfs (con salvedades), jfs, nfs, cifs... [5] | cualquiera\nCapacidad para cifrar los nombres de los archivos | Sí | Sí | Sí\nCapacidad para no cifrar los nombres de los archivos | Sí | Sí | No\nOptimizado para el manejo de archivos dispersos | No | Sí | Sí\ncompatibilidad y prevalencia | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs | gocryptfs\nVersiones del kernel de Linux que lo soportan | 2.0 o posterior | modalidad CBC a partir de 2.6.4, ESSIV 2.6.10, LRW 2.6.20, XTS 2.6.24 | ? | ? | ? | ? | 2.4 o posterior\nLos datos cifrados también pueden ser leídos desde Windows | ? | ? | Sí | Sí | ? | Sí[6] | Sí (puerto cppcryptfs\nLos datos cifrados también pueden ser leídos desde Mac OS X | ? | ? | Sí | Sí | ? | Sí[7] | Sí (beta quality)\nLos datos cifrados también pueden ser leídos desde FreeBSD | ? | ? | Sí (con VeraCrypt) | Sí | ? | Sí[8] | ?\nUtilizado por | ? | Instalador de Debian/Ubuntu (cifrado del sistema)Instalador de Fedora | ? | ? | Instalador de Ubuntu (cifrado del directorio home)Chromium OS (cifrado de los datos del usuario en la memoria caché [9]) | ? | ?\n\n[1][2]\n\nopcional\n\ncon systemd y /etc/crypttab\n\ncon systemd y /etc/crypttab\n\nAES-Twofish, AES-Twofish-Serpent, Serpent-AES, Serpent-Twofish-AES, Twofish-Serpent\n\nAES-Twofish, AES-Twofish-Serpent, Serpent-AES, Serpent-Twofish-AES, Twofish-Serpent\n\n[5]\n\n(con VeraCrypt)\n\n1. Un solo archivo en esos sistemas de archivos podría usarse como un contenedor (dispositivo loop virtual) pero en realidad uno ya no estaría usando el sistema de archivos (y las características que proporciona)\n\n"
    },
    {
      "title": "Elegir una configuración",
      "level": 3,
      "content": "Qué configuración de cifrado de disco es apropiada para cada usuario dependerá de los propósitos del usuario (léase #¿Por qué utilizar la criptografía? más arriba) y de los parámetros del sistema.\n\nEntre otras, tendrá que responder a las siguientes preguntas:\n\n- Usuario ocasional de ordenador husmeando el disco cuando el sistema está apagado / robado / etc.\n- Criptoanalista profesional que puede conseguir acceso de lectura/escritura repetidamente al sistema antes y después de usarse\n- Ninguno de los anteriores\n\n- Cifrado de datos\n- Cifrado del sistema\n- Cualquiera de los anteriores\n\n- Ignorar, y con la esperanza de que no se hayan filtrado datos\n- Desactivar o montar como disco de memoria\n- Cifrar (como parte del cifrado del disco completo o por separado)\n\n- Con contraseña/frase de acceso (igual que la contraseña de inicio de sesión, o por separado)\n- Con archivo de claves (por ejemplo, en una memoria USB, que se mantenga en un lugar seguro o portarlo uno mismo)\n- Con ambas\n\n- Antes del arranque\n- Durante del arranque\n- Al iniciar sesión\n- Manualmente bajo demanda (después de iniciar sesión)\n\n- No hacer nada\n- Usar una clave/frase de acceso compartida\n- Usar claves/frases de acceso emitidas de forma independiente y revocables para la misma parte del disco cifrado\n- Crear partes cifradas separadas del disco para los diferentes usuarios\n\nA continuación, se puede pasar a tomar las decisiones técnicas necesarias (vea #Métodos disponibles más arriba, y #Cómo funciona el cifrado más adelante), en relación con:\n\n- elegir entre cifrar sistemas de archivos apilados versus cifrar dispositivos de bloques\n- la gestión de las claves\n- el algoritmo de cifrado y la modalidad de la operación\n- el almacenamiento de los metadatos\n- la ubicación del «directorio inferior» (en caso de cifrado de sistemas de archivos apilados)\n\n"
    },
    {
      "title": "Ejemplos",
      "level": 3,
      "content": "En la práctica, podría resultar algo así:\n\n- las versiones cifradas de los archivos serán almacenadas en la carpeta ~/.Private del disco\n- desbloqueada bajo demanda con una frase de acceso dedicada\n\n- desbloqueado por el respectivo usuario al iniciar sesión, utilizando la frase de acceso\n- las particiones swap and /tmp serán cifradas con dm-crypt (Español), utilizando una clave de un solo uso generada automáticamente para casa sesión\n- indexación/caché de contenidos de /home por slocate (y aplicaciones similares) desactivada.\n\n- desbloqueado durante el arranque, mediante frases de contraseña o desde una memoria USB con un archivo de claves\n- se pueden tener diferentes frases/claves por usuario, independientes y revocables\n- el cifrado puede abarcar múltiples unidades o permitir flexibilidad en el esquema de particionado con LUKS sobre LVM\n\n- arranque desde USB, usando frase de acceso dedicada + lápiz USB que almacena un archivo de claves\n- datos revisados ​​antes de montar la partición\n- /boot se encuentra en la mencionada memoria USB\n\nOtras muchas combinaciones son posibles, por supuesto. Se debe planificar cuidadosamente qué tipo de configuración será la apropiada para su sistema.\n\n"
    },
    {
      "title": "Elegir una frase de acceso sólida",
      "level": 3,
      "content": "Véase Security#Passwords.\n\n"
    },
    {
      "title": "Preparar el disco",
      "level": 3,
      "content": "Antes de configurar el cifrado de un disco (o parte de él), considere realizar previamente un borrado seguro. Esto consiste en sobrescribir todo el disco o la partición con un flujo de bytes cero o bytes aleatorios, y se hace por una o ambas de las siguientes razones:\n\nEl cifrado del disco no cambia el hecho de que los distintos sectores del mismo solo se sobrescriben bajo demanda, esto es, cuando el sistema de archivos crea o modifica los datos contenidos en esos sectores (véase #Cómo funciona el cifrado a continuación). Los sectores que el sistema de archivos considera que «no se están utilizando actualmente» no los toca, y todavía pueden contener restos de datos del sistemas de archivos anterior. La única manera de asegurarse de que todos los datos guardados previamente en la unidad no pueden ser recuperados, es borrarlos manualmente. Para este propósito, no importa si se utilizan bytes cero o bytes aleatorios (aunque limpiando con bytes cero será mucho más rápido).\n\nLo ideal sería que toda la parte cifrada del disco fuera indistinguible desde la uniformidad de datos aleatorios. De esta manera, ninguna persona no autorizada podría saber cuáles y cuántos sectores contienen realmente datos cifrados — que puede ser un objetivo deseable en sí mismo (como parte de la verdadera confidencialidad) —, y que también sirve como una barrera adicional contra los atacantes que traten de romper el cifrado. Para satisfacer este objetivo, limpiar el disco utilizando bytes aleatorios de alta calidad es crucial.\n\nEl segundo objetivo solo tiene sentido en combinación con el cifrado de dispositivos de bloques, ya que en el caso del cifrado de sistemas de archivos apilados, los datos cifrados se pueden localizar fácilmente de todos modos (en forma de archivos cifrados distintos en el sistema de archivos anfitrión). También tenga en cuenta que, incluso si solo se va a cifrar una carpeta en particular, tendrá que borrar la partición entera si quiere deshacerse de los archivos que estaban almacenados previamente en esa carpeta sin cifrar (debido a la fragmentación del disco). Si hay otras carpetas en la misma partición, habrá que hacerles una copia de respaldo y restablecerlas de nuevo más tarde.\n\nUna vez que haya decidido qué tipo de borrado de disco desea realizar, remítase al artículo Securely wipe disk para conocer instrucciones más técnicas.\n\n"
    },
    {
      "title": "Cómo funciona el cifrado",
      "level": 2,
      "content": "Esta sección pretende ser una introducción general a los conceptos y procesos que se encuentran en el corazón de las configuraciones habituales del cifrado de discos.\n\nNo se entra en detalles técnicos o matemáticos (consulte la literatura apropiada para ello), sino que desea proporcionar a un administrador del sistema una comprensión general sobre cómo las diferentes opciones de configuración (en especial en relación con la gestión de claves) pueden afectar a su usabilidad y seguridad.\n\n"
    },
    {
      "title": "Principio básico",
      "level": 3,
      "content": "A los efectos del cifrado de discos, cada dispositivo de bloque (o archivo individual en el caso del cifrado de sistemas de archivos apilados) se divide en sectores de igual longitud, por ejemplo, 512 bytes (4.096 bits). El cifrado/descifrado se realiza después en función de cada sector, por lo que el sector n del archivo/dispositivo de bloque en el disco almacenará la versión cifrada del sector n de los datos originales.\n\nCada vez que el sistema operativo o una aplicación solicita un determinado fragmento de datos del archivo/dispositivo de bloque, todo el sector (o sectores) que contienen los datos serán leídos desde el disco, descifrados sobre la marcha y almacenados temporalmente en la memoria:\n\n```\n╔═══════╗\n    sector 1 ║\"???..\"║\n             ╠═══════╣        ╭┈┈┈┈┈┈┈╮\n    sector 2 ║\"???..\"║        ┊ clave ┊\n             ╠═══════╣        ╰┈┈┈┬┈┈┈╯\n             :       :            │\n             ╠═══════╣            ▼             ┣┉┉┉┉┉┉┉┫\n    sector n ║\"???..\"║━━━━━━━(descifrado)━━━━━━▶┋\"abc..\"┋ sector n\n             ╠═══════╣                          ┣┉┉┉┉┉┉┉┫\n             :       :\n             ╚═══════╝\n  \n Dispositivo de bloque                          datos no cifrados\n     o archivo cifrado                          en memoria RAM\n           en el disco\n```\n\nDel mismo modo, en cada operación de escritura, todos los sectores que se ven afectados deben ser cifrados de nuevo completamente (mientras que el resto de los sectores permanecen intactos).\n\nCon el fin de ser capaz de descifrar/cifrar los datos, el sistema de cifrado del disco necesita saber la «clave» única secreta asociada a él. Cada vez que el dispositivo de bloque o la carpeta en cuestión debe ser montada, su clave correspondiente (llamada a partir de ahora «llave maestra») debe ser suministrada.\n\nLa entropía de la clave es de suma importancia para la seguridad del cifrado. Una cadena de bytes generada al azar, de una cierta longitud, por ejemplo, 32 bytes (256 bits), reúne las propiedades deseables, pero no es fácil de recordar ni de aplicar manualmente durante el montaje.\n\nPor esa razón se utilizan dos técnicas auxiliares. La primera es la aplicación de la criptografía para aumentar las propiedades entrópicas de la llave maestra, que, generalmente, incluye una frase de acceso separada legible por los humanos. Para los diferentes tipos de cifrado consulte sus características propias en la lista del #Cuadro comparativo. El segundo método consiste en crear un archivo de claves con alta entropía y almacenarlo en un medio separado de la unidad que contiene los datos cifrados.\n\nVéase también Wikipedia:Authenticated encryption.\n\n"
    },
    {
      "title": "Claves, archivo de claves y frase de acceso",
      "level": 3,
      "content": "Los siguientes son ejemplos de cómo almacenar y asegurar criptográficamente una llave maestra con un archivo de claves:\n\nAlmacenar simplemente la llave maestra en un archivo (en formato legible) es la opción más sencilla. El archivo — llamado un «keyfile» o «archivo de claves» — se puede colocar en una memoria USB mantenida en un lugar seguro y que se conecte al ordenador cuando se quieran montar las partes cifradas del disco (por ejemplo, durante el arranque o el inicio de sesión).\n\nLa llave maestra (y, por lo tanto, los datos cifrados con ella) se puede proteger con una contraseña secreta, que tendrá que recordar e introducir cada vez que desea montar el dispositivo de bloque o carpeta. Véase #Metadatos criptográficos a continuación para obtener más detalles.\n\nEn algunos casos, por ejemplo, al cifrar el espacio de intercambio o la partición /tmp, no es necesario tener una llave maestra permanente en absoluto. Se puede generar de forma aleatoria una llave nueva para un solo uso para cada sesión, sin necesidad de interacción del usuario. Esto significa que una vez desmontada, todos los archivos guardados en la partición en cuestión nunca pueden ser descifrados de nuevo por nadie — que para estos casos particulares está perfectamente bien —.\n\n"
    },
    {
      "title": "Metadatos criptográficos",
      "level": 3,
      "content": "Con frecuencia las técnicas de cifrado utilizan funciones criptográficas para mejorar la seguridad de la llave maestra en sí. En el montaje de los dispositivos cifrados, la contraseña o el archivo de claves se hace pasar a través de dichas funciones y solo el resultado puede desbloquear la llave maestra para descifrar los datos.\n\nUna configuración común es aplicar la llamada «key stretching» («que podríamos traducir como prolongar la clave») para la frase de acceso (a través de la «función derivadora de claves»), y utiliza el resultado mejorado como clave de montaje para descifrar la llave maestra vigente (que se ha almacenado previamente de forma cifrada):\n\n```\n╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮                               ╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮\n ┊ frase de acceso de montaje ┊━━━━━━⎛función derivadora⎞━━━━▶┊ clave de montaje ┊\n ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯  ,───⎝     de clave     ⎠     ╰┈┈┈┈┈┈┈┈┬┈┈┈┈┈┈┈┈┈╯\n ╭──────╮                       ╱                                      │\n │ sal  │──────────────────────´                                       │\n ╰──────╯                                                              │\n ╭────────────────────────────╮                                        ▼          ╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮\n │ llave maestra cifrada      │━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━(descifrado)━━━▶┊ llave maestra ┊\n ╰────────────────────────────╯                                                   ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯\n```\n\nLa función derivadora de claves (por ejemplo PBKDF2 o scrypt) es deliberadamente lenta (se aplican muchas iteraciones de una función hash, por ejemplo, 1.000 iteraciones de HMAC-SHA-512), de modo que los posibles ataques de fuerza bruta destinados a encontrar la frase de acceso se presentan inviables. Para el caso de su utilización normal por un usuario autorizado, solo será necesario realizar el cálculo una vez por sesión, por lo que la pequeña desaceleración no es un problema. También toma un blob adicional de datos, que se denomina «sal», como un argumento — este se genera aleatoriamente una vez durante la puesta en marcha del cifrado del disco y se almacena sin protección como parte de los metadatos criptográficos —. Debido a que será un valor diferente para cada configuración, esto hace que sea imposible para los atacantes acelerar los ataques de fuerza bruta usando tablas precalculadas para acceder a la función derivadora de claves.\n\nLa llave maestra cifrada se puede almacenar en el disco junto con los datos cifrados. De esta manera, la confidencialidad de los datos cifrados depende completamente de la frase secreta.\n\nPara aumentar la seguridad se puede almacenar la llave maestra cifrada en un archivo de claves, por ejemplo, en una memoria USB. Esto proporciona dos factores de autenticación, a saber: el acceso a los datos cifrados ahora requiere algo que solo usted sabe (la frase de acceso), y, además, algo que solo usted tiene (el archivo de claves).\n\nOtra forma de lograr un doble factor de autenticación es aumentar el esquema de obtención de claves, previo a su matematización, «combinando» la frase de acceso con la lectura de datos de byte en uno o más archivos externos (situados en una memoria USB o similar), antes de pasarla por la función derivadora de claves.Los archivos en cuestión pueden ser cualquier cosa, por ejemplo, imágenes JPEG normales, lo que puede ser beneficioso para la #Negabilidad plausible. Estos, sin embargo, todavía se llaman «keyfiles» en el presente contexto.\n\nDespués de que la llave maestra se haya derivado con éxito, esta se almacena de forma segura en la memoria (por ejemplo, en un anillo de claves del kernel), durante el tiempo que esté montado el dispositivo de bloque o carpeta.\n\nPor lo general, sin embargo, no se utiliza para cifrar/descifrar los datos del disco directamente. Por ejemplo, en el caso de cifrado del sistema de archivos apilados, cada archivo puede asignarse automáticamente su propia clave de cifrado. Cada vez que el archivo ha de ser leído/modificado, esta clave del archivo debe primero ser descifrada usando la llave maestra, antes de que pueda ser utilizada por sí para cifrar/descifrar el contenido del archivo:\n\n```\n╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮\n                                ┊ llave maestra ┊\n   archivo en disco:            ╰┈┈┈┈┈┈┈┬┈┈┈┈┈┈┈╯\n  ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐         │\n  ╎╭─────────────────────────╮╎         ▼         ╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮\n  ╎│ archivo de clave cifrado│━━━━(descifrado)━━━▶┊archivo de clave┊\n  ╎╰─────────────────────────╯╎                   ╰┈┈┈┈┈┈┈┬┈┈┈┈┈┈┈┈╯\n  ╎┌─────────────────────────┐╎                           ▼                  ┌┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┐\n  ╎│ contenidos del          │◀━━━━━━━━━━━━━━━━━━(cifrado/descifrado)━━━━━━━▶┊ contenidos del  ┊\n  ╎│ archivo cifrados        │╎                                              ┊ archivo legibles┊\n  ╎└─────────────────────────┘╎                                              └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘\n  └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n```\n\nDe una manera similar, una clave separada (por ejemplo, una por cada carpeta) se puede utilizar para el cifrado de nombres de archivos en el caso del cifrado de sistemas de archivos apilados.\n\nEn el caso de dispositivos de bloques cifrados se utiliza una llave maestra por dispositivo y, por lo tanto, para todos los datos del mismo. Algunos métodos ofrecen características para asignar múltiples frases de acceso/archivos de claves para el mismo dispositivo, y otros métodos, en cambio, no. Algunos métodos utilizan funciones mencionadas más arriba para asegurar la llave maestra y otros dan el control sobre la seguridad de la llave completamente al usuario. Se explican dos ejemplos para los parámetros criptográficos usados ​​por dm-crypt en las modalidades plain o LUKS.\n\nAl comparar los parámetros utilizados por ambas modalidades se deduce que el modo plain de dm-crypt tiene parámetros relacionados con la forma de localizar el archivo de claves (por ejemplo, --keyfile-size, --keyfile-offset). El modo LUKS de dm-crypt no necesita esto, ya que cada dispositivo de bloque contiene un encabezado con los metadatos criptográficos al principio. La cabecera incluye el sistema de cifrado utilizado, la llave maestra cifrada en sí y los parámetros necesarios para su derivación para descifrarla. Los últimos parámetros sirven para cambiar el resultado de las opciones que usará la llave maestra durante su cifrado incicial (por ejemplo --iter-time, --use-random).\n\nPara conocer las ventajas/desventajas de las diferentes técnicas, remítase al anterior #Cuadro comparativo o visite páginas más específicas.\n\nVéase también:\n\n- Wikipedia:es:Frase de contraseña\n- Wikipedia:es:Criptografía asimétrica\n- Wikipedia:Key management\n- Wikipedia:Key derivation function\n\n"
    },
    {
      "title": "Algoritmos de cifrado y modalidades de operación",
      "level": 3,
      "content": "El algoritmo real utilizado para servir de traductor entre las piezas de datos no cifradas y las cifradas (llamado «texto plano» y «texto cifrado», respectivamente), que se interrelacionan entre sí a través de una clave de cifrado dada, se llama un «algoritmo de cifrado».\n\nEl cifrado de discos emplea «algoritmos de cifrado de bloques», que operan sobre bloques de datos de una longitud fija, por ejemplo 16 bytes (128 bits). En el momento de escribir estas líneas, los más usados son:\n\nTable content:\n | tamaño bloque | tamaño clave | comentario\nAES | 128 bits | 128, 192 o 256 bits | aprobado por la NSA para la protección de información clasificada «SECRET» y «TOP SECRET» por el gobierno de EE.UU. (cuando se utiliza con un tamaño de clave de 192 o 256 bits)\nBlowfish | 64 bits | 32–448 bits | uno de los primeros sistemas de cifrado seguro con licencia libre que se puso a disposición del público, por lo tanto, muy bien consolidado en Linux\nTwofish | 128 bits | 128, 192 o 256 bits | desarrollado como sucesor de Blowfish, pero sin haber alcanzado un uso tan amplio\nSerpent | 128 bits | 128, 192 o 256 bits | Considerado el más seguro de los cinco finalistas de la competición AES[10][11][12].\n\nCifrar/descifrar un sector (véase más arriba) se consigue mediante su división en pequeños bloques, haciéndolos coincidir con el tamaño del bloque cifrado, y siguiendo, después, cierto conjunto de reglas (que antes hemos llamado «modalidad de operación») que informan sobre cómo aplicar el algoritmo de cifrado a los bloques individuales.\n\nAplicar el algoritmo de cifrado sin más a cada bloque por separado sin modificaciones (denominada modalidad «electronic codebook (ECB)») no sería seguro, ya que si los mismos 16 bytes de texto plano siempre producen los mismos 16 bytes de texto cifrado, un atacante podría reconocer fácilmente los patrones en el texto cifrado que se almacenan en el disco.\n\nLa modalidad más básica (y común) de operar utilizada en la práctica es la denominada «cipher-block chaining (CBC)». Al cifrar un bloque de un sector con esta modalidad, cada bloque de datos de texto plano se combina de forma matemática con el texto cifrado del bloque anterior antes de cifrarlo, utilizando el algoritmo de cifrado. Para el primer bloque, ya que no tiene texto cifrado anterior que usar, se utiliza un bloque de datos pregenerado especial almacenado con los metadatos criptográficos del sector y llamado «vector de inicialización (siglas en inglés IV)»:\n\n```\n╭──────────────╮\n                                                   │vector de     │\n                                                   │inicialización│\n                                                   ╰──────┬───────╯\n           ╭     ╠══════════╣              ╭─clave        │           ┣┉┉┉┉┉┉┉┉┉┉┫        \n           │     ║          ║              ▼              ▼           ┋          ┋          . INICIO\n           ┴     ║\"????????\"║◀━━(algoritmo de cifrado)━━━(+)━━━━━━━━━━┋\"Hello, W\"┋ bloque  ╱╰────┐\n      sector n   ║          ║                                         ┋          ┋ 1       ╲╭────┘\n   del archivo   ║          ║─────────────────────────────╮           ┋          ┋          ' \n         o del   ╟──────────║              ╭─clave        │           ┠┈┈┈┈┈┈┈┈┈┈┨\n   dispositivo   ║          ║              ▼              ▼           ┋          ┋\n     de bloque   ║\"????????\"║◀━━(algoritmo de cifrado)━━━(+)━━━━━━━━━━┋\"orld !!!\"┋ bloque\n           ┬     ║          ║                                         ┋          ┋ 2\n           │     ║          ║──────────────────╮                      ┋          ┋\n           │     ╟──────────╢                  │                      ┠┈┈┈┈┈┈┈┈┈┈┨\n           │     ║          ║                  ▼                      ┋          ┋\n           :     :   ...    :        ...      ...      ...    ...     :   ...    : ...\n  \n                texto cifrado                                         texto plano\n                     en disco                                         en RAM\n```\n\nAl descifrar, el procedimiento se invierte de forma análoga.\n\nUna cosa a destacar es la generación del vector de inicialización único para cada sector. La opción más sencilla consiste en calcularlo de una manera predecible a partir de un valor fácilmente disponible, como puede ser el número del sector. Sin embargo, esto podría permitir que un atacante con acceso reiterado al sistema pudiera realizar el llamado watermarking attack. Para evitar esto, un método llamado «Encrypted salt-sector initialization vector (ESSIV)» se puede utilizar para generar vectores de inicialización de una manera que hace que se vean completamente aleatorios por un atacante potencial.\n\nTambién hay otras opciones disponibles, modalidades de operación más complicadas para cifrar el disco, que ya ofrecen seguridad integrada contra este tipo de ataques (y, por lo tanto, no requieren ESSIV). Otras opciones también pueden garantizar, además, la autenticidad de los datos cifrados (es decir, confirmar que no se han modificado/corrompido por alguien que no tiene acceso a la clave).\n\nVéase también:\n\n- Wikipedia:Disk encryption theory\n- Wikipedia:es:Cifrado por bloques\n- Wikipedia:es:Modos de operación de una unidad de cifrado por bloques\n\n"
    },
    {
      "title": "Negabilidad plausible",
      "level": 3,
      "content": "Véase Wikipedia:Plausible deniability\n\n"
    }
  ]
}