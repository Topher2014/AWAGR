{
  "title": "Depuração de inicialização",
  "url": "https://wiki.archlinux.org/title/Depura%C3%A7%C3%A3o_de_inicializa%C3%A7%C3%A3o",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- Diretrizes de relatórios de erro\n- Guia de depuração passo a passo\n- Depuração - Obtendo Rastros\n\nEste artigo explica alguns métodos para solução de problemas gerais. Para problemas específicos do aplicativo, consulte a página wiki específica desse programa.\n\n"
    },
    {
      "title": "Procedimentos gerais",
      "level": 2,
      "content": "É crucial ler sempre todas as mensagens de erro que aparecem. Às vezes, pode ser difícil, por exemplo, com aplicativos gráficos, obter uma mensagem de erro adequada.\n\n1. Execute a aplicação em um terminal para que seja possível inspecionar a saída. Aumente a verbosidade (geralmente --verbose/-v/-V ou --debug/- d) se ainda não houver informações suficientes para depurar. Às vezes não existe tal parâmetro e ele precisa ser especificado como uma diretiva no arquivo de configuração das aplicações. Um aplicativo também pode usar arquivos de log, que geralmente estão localizados em /var/log, $HOME/.cache ou $HOME/.local Se não houver como aumentar a verbosidade, sempre é possível executar strace e similares.\n1. Verifique o journal. É possível que um erro também deixe rastros no journal, principalmente se depender de outros aplicativos. dmesg lê do buffer de anel do kernel. Isso é útil se o disco estiver inacessível por algum motivo, mas também pode resultar em logs incompletos porque o buffer de anel do kernel não tem tamanho infinito. Use journalctl se possível. journalctl tem mais opções de filtragem que dmesg e usa timestamps legíveis por padrão.\n1. É sempre recomendável verificar os rastreadores de problemas relevantes para ver se há problemas conhecidos com soluções já existentes. Dependendo das escolhas dos upstreams, geralmente há um rastreador de problemas e às vezes também um fórum ou até mesmo um canal de IRC. Existe o Arch Linux bugtracker, que deve ser usado principalmente para empacotar bugs.\n\n1. Aumente a verbosidade (geralmente --verbose/-v/-V ou --debug/- d) se ainda não houver informações suficientes para depurar.\n1. Às vezes não existe tal parâmetro e ele precisa ser especificado como uma diretiva no arquivo de configuração das aplicações.\n1. Um aplicativo também pode usar arquivos de log, que geralmente estão localizados em /var/log, $HOME/.cache ou $HOME/.local\n1. Se não houver como aumentar a verbosidade, sempre é possível executar strace e similares.\n\n1. dmesg lê do buffer de anel do kernel. Isso é útil se o disco estiver inacessível por algum motivo, mas também pode resultar em logs incompletos porque o buffer de anel do kernel não tem tamanho infinito. Use journalctl se possível.\n1. journalctl tem mais opções de filtragem que dmesg e usa timestamps legíveis por padrão.\n\n1. Dependendo das escolhas dos upstreams, geralmente há um rastreador de problemas e às vezes também um fórum ou até mesmo um canal de IRC.\n1. Existe o Arch Linux bugtracker, que deve ser usado principalmente para empacotar bugs.\n\n"
    },
    {
      "title": "Suporte adicional",
      "level": 3,
      "content": "Se você precisar de qualquer suporte adicional, você pode perguntar nos fóruns ou no IRC.\n\nAo pedir suporte, poste o output/log completo, não apenas o que você acha que são as seções significativas. As fontes de informação incluem:\n\n- Saída completa de qualquer comando envolvido - não selecione apenas o que você acha que é relevante.\n- Journal do systemd. Para uma saída mais extensa, use o parâmetro de inicialização systemd.log_level=debug. Isso produzirá uma quantidade enorme de saída, portanto, ative-o apenas se for realmente necessário. Não use o parâmetro -x porque isso sobrecarrega desnecessariamente a saída e dificulta a leitura. Use -b a menos que você precise de logs de uma inicialização anterior. Não especificar isso pode levar a pastas extremamente grandes que podem até ser grandes demais para qualquer pastebin.\n- Arquivos de configuração relevantes\n- Drivers envolvidos\n- Versões dos pacotes envolvidos\n- Kernel: journalctl -k ou dmesg (ambos com privilégios de root).\n- Xorg: dependendo da configuração, o gerenciador de exibição em uso também é relevante aqui. Xorg.log pode estar localizado em um dos vários lugares: o diário (journal) do sistema, /var/log/ ou $HOME/.local/share/xorg/. Alguns gerenciadores de exibição como LightDM também podem colocar o Xorg.log em seu próprio diretório de log.\n- Pacman: Se uma atualização recente quebrou algo, procure em /var/log/pacman.log. Pode ser útil usar o parâmetro --debug do pacman.\n\n- Para uma saída mais extensa, use o parâmetro de inicialização systemd.log_level=debug. Isso produzirá uma quantidade enorme de saída, portanto, ative-o apenas se for realmente necessário.\n- Não use o parâmetro -x porque isso sobrecarrega desnecessariamente a saída e dificulta a leitura.\n- Use -b a menos que você precise de logs de uma inicialização anterior. Não especificar isso pode levar a pastas extremamente grandes que podem até ser grandes demais para qualquer pastebin.\n\n- Xorg.log pode estar localizado em um dos vários lugares: o diário (journal) do sistema, /var/log/ ou $HOME/.local/share/xorg/.\n- Alguns gerenciadores de exibição como LightDM também podem colocar o Xorg.log em seu próprio diretório de log.\n\n- Pode ser útil usar o parâmetro --debug do pacman.\n\nUma das melhores maneiras de postar esta informação é usar um pastebin.\n\nSerá então gerado um link que você pode colar no fórum ou IRC.\n\nAlém disso, você pode revisar como relatar problemas corretamente antes de perguntar.\n\n"
    },
    {
      "title": "Problemas de inicialização",
      "level": 2,
      "content": "Ao diagnosticar problemas de inicialização, é muito importante saber em qual estágio a inicialização falha.\n\n1. Firmware (UEFI ou BIOS) Normalmente só tem ferramentas muito básicas para depuração. Certifique-se de que o Secure Boot está desativado.\n1. Gerenciador de boot Uma das coisas mais comuns feitas aqui é a alteração dos parâmetros do kernel.\n1. initramfs Geralmente fornece um shell de emergência. Dependendo dos hooks escolhidos, o dmesg ou o journal estarão disponíveis dentro dele.\n1. O sistema real Dependendo do quanto ele está quebrado, uma simples invocação do shell de depuração pode ser suficiente aqui.\n\n1. Normalmente só tem ferramentas muito básicas para depuração.\n1. Certifique-se de que o Secure Boot está desativado.\n\n1. Uma das coisas mais comuns feitas aqui é a alteração dos parâmetros do kernel.\n\n1. Geralmente fornece um shell de emergência.\n1. Dependendo dos hooks escolhidos, o dmesg ou o journal estarão disponíveis dentro dele.\n\n1. Dependendo do quanto ele está quebrado, uma simples invocação do shell de depuração pode ser suficiente aqui.\n\nInfelizmente, as ferramentas de depuração fornecidas por qualquer estágio podem não ser suficientes para corrigir o componente quebrado. O archiso pode ser usado para recuperar neste caso.\n\n"
    },
    {
      "title": "Mensagens do console",
      "level": 3,
      "content": "Após o processo de inicialização, a tela é limpa e o prompt de login é exibido, deixando os usuários incapazes de ler a saída de inicialização e as mensagens de erro. Esse comportamento padrão pode ser modificado usando métodos descritos nas seções abaixo.\n\nObserve que, independentemente da opção escolhida, as mensagens do kernel podem ser exibidas para inspeção após a inicialização usando journalctl -k ou dmesg. Para exibir todos os logs da inicialização atual, use journalctl -b.\n\n"
    },
    {
      "title": "Controle de fluxo",
      "level": 4,
      "content": "Este é o gerenciamento básico que se aplica à maioria dos emuladores de terminal, incluindo consoles virtuais (VC):\n\n- Pressione Ctrl+s para pausar a saída.\n- E Ctrl+q para continuar.\n\nIsso pausa não apenas a saída, mas também os programas que tentam imprimir no terminal, pois eles bloquearão as chamadas write() enquanto a saída estiver pausada. Se o seu init parecer congelado, certifique-se de que o console do sistema não esteja pausado.\n\nPara ver as mensagens de erro que já são exibidas, consulte getty#Mantenha as mensagens de inicialização em tty1.\n\n"
    },
    {
      "title": "Depuração de saída",
      "level": 4,
      "content": "A maioria das mensagens do kernel ficam ocultas durante a inicialização. Você pode ver mais dessas mensagens adicionando diferentes parâmetros do kernel. Os mais simples são:\n\n- debug habilita mensagens de depuração para o kernel e systemd\n- ignore_loglevel força a impressão de todas as mensagens do kernel\n\nOutros parâmetros que você pode adicionar e que podem ser úteis em determinadas situações são:\n\n- earlyprintk=vga,keep imprime mensagens do kernel muito cedo no processo de inicialização, caso o kernel falhe antes que a saída seja mostrada. Você deve alterar vga para efi para sistemas EFI.\n- log_buf_len=16M aloca um buffer de mensagem do kernel maior (16 MiB), para garantir que a saída de depuração não seja substituída.\n\nHá também vários parâmetros de depuração separados para habilitar a depuração em subsistemas específicos, por exemplo, bootmem_debug, sched_debug. Além disso, initcall_debug pode ser útil para investigar congelamentos de inicialização. (Procure por chamadas que não retornaram.) Verifique a documentação de parâmetros do kernel para obter informações específicas.\n\n"
    },
    {
      "title": "netconsole",
      "level": 4,
      "content": "netconsole é um módulo do kernel que envia todas as mensagens de log do kernel (ou seja, dmesg) pela rede para outro computador, sem envolver o espaço do usuário (por exemplo, syslogd). O nome \"netconsole\" é um nome impróprio porque não é realmente um \"console\", mais como um serviço de registro remoto.\n\nEle pode ser usado embutido ou como um módulo. O netconsole integrado inicializa imediatamente após as placas NIC e exibirá a interface especificada o mais rápido possível. O módulo é usado principalmente para capturar a saída do kernel panic de uma máquina sem periféricos ou em outras situações em que o espaço do usuário não é mais funcional.\n\n"
    },
    {
      "title": "Shells de recuperação",
      "level": 3,
      "content": "Obter um shell interativo em algum estágio do processo de inicialização pode ajudá-lo a identificar exatamente onde e por que algo está falhando. Existem vários parâmetros do kernel para fazer isso, mas todos eles lançam um shell normal que você pode sair (exit) para deixar o kernel retomar o que estava fazendo:\n\n- rescue inicia um shell logo após o sistema de arquivos raiz ser remontado leitura/gravação\n- emergency inicia um shell ainda mais cedo, antes que a maioria dos sistemas de arquivos seja montada\n- init=/bin/sh (como último recurso) altera o programa init para um shell raiz. rescue e emergency ambos dependem do systemd, mas isso deve funcionar mesmo se o systemd estiver quebrado.\n\nOutra opção é o shell de depuração do systemd que adiciona um shell raiz em tty9 (acessível com Ctrl+Alt+F9). Ele pode ser ativado adicionando systemd.debug_shell aos parâmetros do kernel ou habilitando debug-shell.service.\n\n"
    },
    {
      "title": "Depurando módulos do kernel",
      "level": 3,
      "content": "Veja Módulos de kernel#Obtendo informações.\n\n"
    },
    {
      "title": "Depurando hardware",
      "level": 3,
      "content": "- Você pode exibir informações extras de depuração sobre seu hardware seguindo udev#Debug output.\n- Certifique-se de que as atualizações do microcódigo sejam aplicadas em seu sistema.\n- Para testar a RAM, consulte Stress testing#MemTest86+.\n- Para ver se seu sistema está superaquecendo, use lm_sensors.\n- Para verificar a integridade do armazenamento, consulte S.M.A.R.T.\n\n"
    },
    {
      "title": "Depurando congelamentos",
      "level": 2,
      "content": "Infelizmente, os congelamentos são geralmente difíceis de depurar e alguns deles levam muito tempo para serem reproduzidos. Existem alguns tipos de congelamentos que são mais fáceis de depurar do que outros:\n\n- O som ainda está tocando? Nesse caso, apenas a tela pode estar congelada. Isso pode ser um problema com o driver de vídeo.\n- A máquina ainda está respondendo? Tente via SSH se mudar para outro TTY não funcionar.\n- O LED de atividade do disco (se houver) está indicando que um lote está sendo gravado no disco? A troca pesada pode congelar temporariamente o sistema. Consulte essa resposta do StackExchange para obter informações sobre congelamentos em gravações grandes.\n\nSe nada mais ajudar, tente um desligamento limpo. Pressionar o botão liga/desliga uma vez pode descongelar o sistema e mostrar a clássica \"tela de desligamento\" que exibe todas as unidades que estão sendo interrompidas. Como alternativa, usar as teclas mágicas SysRq também pode ajudar a obter um desligamento limpo. Isso é muito importante porque o journal pode conter dicas de por que a máquina travou. O journal não pode ser gravado no disco em um desligamento não limpo. Congelamentos rígidos nos quais toda a máquina não é responsável são mais difíceis de depurar, pois os logs não podem ser gravados no disco a tempo.\n\nO registro remoto pode ajudar se o congelamento não permitir gravar nada no disco. Uma solução de registro remoto bruta, que precisa ser invocada de outro dispositivo, pode ser usada para depuração básica:\n\n```\n$ ssh host_congelado journalctl -f\n```\n\nMuitos congelamentos fatais nos quais todo o sistema não responde mais e exigem um desligamento forçado podem estar relacionados a firmware, drivers ou hardware com erros. Tentar um kernel diferente (consulte Kernel#Debugging regressions) ou mesmo uma distribuição ou sistema operacional Linux diferente, atualizar o firmware e executar o diagnóstico de hardware, pode ajudar a encontrar o problema.\n\nSe um congelamento não permitir a coleta de nenhum tipo de log ou outra informação necessária para depuração, tente reproduzir o congelamento em um ambiente ativo. Se for necessário um ambiente gráfico para reproduzir o congelamento ou se o congelamento puder ser reproduzido no archiso, use o ambiente live de uma distribuição diferente, que de preferência não é baseada no Arch Linux, para eliminar a possibilidade de que o congelamento esteja relacionado à versão ou patches do kernel. Se o congelamento ainda ocorrer em um ambiente ativo, as chances são de que pode estar relacionado ao hardware. Se isso não acontecer mais, é preciso estar atento às diferenças de ambos os sistemas. Diferentes configurações, diferenças nas versões e parâmetros do kernel e outras alterações semelhantes podem ter corrigido o congelamento.\n\nNo entanto, um LED de caps lock piscando pode indicar um kernel panic. Algumas configurações podem não mostrar o TTY quando ocorreu um kernel panic, o que pode ser confuso e pode ser interpretado como outro tipo de congelamento.\n\n"
    },
    {
      "title": "Depurando regressões",
      "level": 2,
      "content": "Se uma atualização causa um problema, mas o downgrade do pacote específico o corrige, é provável que seja uma regressão. Se isso aconteceu após uma atualização normal do sistema completo, verifique seu pacman.log para determinar qual(is) pacote(s) pode(m) ter causado o problema. A parte mais importante da depuração de regressões é verificar se o problema já foi corrigido, pois isso pode economizar muito tempo. Para fazer isso, primeiro certifique se o aplicativo está totalmente atualizado (por exemplo, certifique se o aplicativo é da mesma versão dos repositórios oficiais). Se já estiver ou se a atualização não corrigir o problema, tente usar a versão mais recente, geralmente uma versão -git, que pode já estar empacotado no AUR. Se isso corrigir o problema e a versão com as correções ainda não estiver nos repositórios oficiais, espere até que a nova versão chegue neles e depois volte para ela.\n\nSe o problema ainda persistir, depure o problema e/ou bisect o aplicativo e relate o bug no rastreador de bugs upstream para que ele possa ser corrigido.\n\n"
    },
    {
      "title": "Não é possível usar novos periféricos após a atualização do kernel",
      "level": 2,
      "content": "Isso se manifestará comumente (mas provavelmente não apenas) como:\n\n- dispositivos de armazenamento USB recém-conectados aparecendo com dmesg, mas não em /dev/,\n- a incapacidade de usar uma conexão com fio/sem fio em um laptop se ainda não foi usada antes da atualização do kernel,\n- FATAL: Module módulo not found in directory /lib/module/versão_do_kernel ao usar modprobe para carregar um módulo que ainda não foi usado antes da atualização do pacote do kernel.\n\nConforme parcialmente coberto em Manutenção do sistema#Reinicialize após atualizações, o kernel não é atualizado quando você atualiza o pacote, mas apenas quando você reinicializa posteriormente. Enquanto isso, os módulos do kernel, localizados em /usr/lib/module/vers/ são removidos pelo pacman ao instalar o novo kernel. Conforme explicado em FS#16702, essa abordagem evita deixar arquivos no sistema não manipulados pelo gerenciador de pacotes, mas leva aos sintomas mencionados acima. Para corrigi-los, reinicie sistematicamente após atualizar o kernel. A evolução a longo prazo, ainda a ser implementada, será usar pacotes de kernel versionados: o principal bloqueador é como lidar com a remoção das versões anteriores do kernel, uma vez que não são mais necessárias.\n\nOutra solução está disponível como kernel-modules-hook, onde dois hooks do pacman usam rsync para manter os módulos do kernel no sistema de arquivos após a atualização do kernel e um serviço systemd remove os módulos antigos quatro semanas depois.\n\n"
    },
    {
      "title": "Gerenciamento de pacotes",
      "level": 2,
      "content": "Veja pacman#Solução de problemas para tópicos gerais, e Pacman/Assinatura de pacote#Solução de problemas para problemas com chaves PGP.\n\n"
    },
    {
      "title": "Consertando um sistema quebrado",
      "level": 3,
      "content": "Se uma atualização parcial foi realizada, tente atualizar todo o seu sistema. Uma reinicialização pode ser necessária.\n\n```\n# pacman -Syu\n```\n\nSe você normalmente inicializa em uma interface gráfica e isso está falhando, talvez você possa pressionar Ctrl+Alt+F1 a Ctrl+Alt+F6 e chegar a um tty funcional para executar o pacman.\n\nSe o sistema estiver quebrado o suficiente para que você não consiga executar o pacman, inicialize usando um Arch ISO mensal de uma unidade flash USB, um disco óptico ou uma rede com PXE. (Não siga o restante do guia de instalação.)\n\nMonte a raiz do seu sistema de arquivos:\n\n```\n[ISO] # mount /dev/dispositivo_da_raiz_do_sistema_de_arquivos /mnt\n```\n\nMonte quaisquer outras partições que você criou separadamente, adicionando o prefixo /mnt a todas elas, ou seja:\n\n```\n[ISO] # mount /dev/dispositivo_do_boot /mnt/boot\n```\n\nTente usar o pacman do seu sistema:\n\n```\n[ISO] # arch-chroot /mnt\n[chroot] # pacman -Syu\n```\n\nSe isso falhar, saia do chroot e tente:\n\n```\n[ISO] # pacman -Syu --sysroot /mnt\n```\n\nSe isso falhar, tente:\n\n```\n[ISO] # pacman -Syu --root /mnt --cachedir /mnt/var/cache/pacman/pkg\n```\n\n"
    },
    {
      "title": "fuser",
      "level": 2,
      "content": "fuser é um utilitário de linha de comando para identificar processos usando recursos como arquivos, sistemas de arquivos e portas TCP/UDP.\n\nfuser é fornecido pelo pacote psmisc, que já deve estar instalado como uma dependência do metapacote base. Veja fuser(1) para detalhes.\n\n"
    },
    {
      "title": "Permissões de sessão",
      "level": 2,
      "content": "Primeiro, certifique-se de ter uma sessão local válida no X:\n\n```\n$ loginctl show-session $XDG_SESSION_ID\n```\n\nIsso deve conter Remote=no e Active=yes na saída. Caso contrário, certifique-se de que o X seja executado no mesmo tty em que ocorreu o login. Isso é necessário para preservar a sessão de logind.\n\nAs ações básicas do polkit não requerem configuração adicional. Algumas ações do polkit requerem autenticação adicional, mesmo com uma sessão local. Um agente de autenticação polkit precisa estar em execução para que isso funcione. Consulte polkit#Authentication agents para obter mais informações sobre isso.\n\n"
    },
    {
      "title": "Mensagem: \"erro ao carregar bibliotecas compartilhadas\"",
      "level": 2,
      "content": "Se, ao usar um programa, você receber um erro semelhante a:\n\n```\nerror while loading shared libraries: libusb-0.1.so.4: cannot open shared object file: No such file or directory\n```\n\nUse pacman ou pkgfile para procurar o pacote que possui a biblioteca ausente:\n\n```\n$ pacman -F libusb-0.1.so.4\n```\n\n```\nextra/libusb-compat 0.1.5-1\n    usr/lib/libusb-0.1.so.4\n```\n\nNeste caso, o pacote libusb-compat precisa ser instalado. Alternativamente, o programa que solicita a biblioteca pode precisar ser reconstruído após um soname bump.\n\nO erro também pode significar que o pacote que você usou para instalar seu programa não lista a biblioteca como uma dependência em seu PKGBUILD: se for um pacote oficial, reporte o bug; se for um pacote AUR, reporte-o ao mantenedor usando sua página no site do AUR.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- A how-to in troubleshooting for newcomers\n- Lista de ferramentas para UBCD - Ferramentas similares ao Memtest para adicionar ao grub.cfg, no UltimateBootCD.com\n- Wikipedia:BIOS Boot partition\n- REISUB\n- Debug Logging to a Serial Console no Freedesktop.org\n- How to Isolate Linux ACPI Issues no Archive.org\n\n"
    }
  ]
}