{
  "title": "Fstab (Français)",
  "url": "https://wiki.archlinux.org/title/Fstab_(Fran%C3%A7ais)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Persistent block device naming (Français)\n- File systems\n- tmpfs (Français)\n- Swap (Français)\n\nLe fichier fstab(5) peut être utilisé pour définir comment les partitions de disque, les autres périphériques de type blocs ou les systèmes de fichiers distants doivent être montés dans le système de fichiers.\n\nChaque système de fichiers est décrit dans une ligne séparée. Ces définitions seront converties en unités de montage Systemd dynamiquement lors du démarrage, et lorsque la configuration du gestionnaire de système est rechargée. La configuration par défaut va automatiquement utiliser fsck puis monter les systèmes de fichiers avant de démarrer les services qui nécessitent qu'ils soient montés.\n\nPar exemple, Systemd s'assure automatiquement que les montages système de fichiers distants comme NFS ou Samba ne sont lancés qu'après la configuration du réseau. Par conséquent, les montages de systèmes de fichiers locaux et distants spécifiés dans /etc/fstab doivent fonctionner immédiatement. Consultez systemd.mount(5) pour plus de détails.\n\nLa commande mount utilisera fstab, si un seul répertoire ou périphérique est donné, pour saisir la valeur de l'autre paramètre. Dans ce cas, les options de montage répertoriées dans fstab seront également utilisées.\n\n"
    },
    {
      "title": "Utilisation",
      "level": 2,
      "content": "Un /etc/fstab simple, utilisant les UUIDs du système de fichiers :\n\n```\n/etc/fstab\n```\n\n```\n# <device>                                <dir> <type> <options> <dump> <fsck>\nUUID=0a3407de-014b-458b-b5c1-848e92a327a3 /     ext4   defaults  0      1\nUUID=f9fe0b69-a280-415d-a03a-a32752370dee none  swap   defaults  0      0\nUUID=b411dc99-f0a0-4c87-9e05-184977be8539 /home ext4   defaults  0      2\n```\n\n- <device> décrit le périphérique spécial de type bloc ou le système de fichiers distant à monter ; consultez #Identification des systèmes de fichiers.\n- <dir> décrit le répertoire de montage.\n- <type> le type de système de fichiers.\n- <options> les options de montage associées ; consultez mount(8) § FILESYSTEM-INDEPENDENT_MOUNT_OPTIONS et ext4(5) § MOUNT_OPTIONS.\n- <dump> est vérifié par l'utilitaire dump(8). Ce champ a généralement la valeur 0, ce qui désactive la vérification.\n- <fsck> définit l'ordre de vérification du système de fichiers au démarrage ; consultez fsck(8). Pour le périphérique racine, il doit être 1. Pour les autres partitions, il doit être 2, ou 0 pour désactiver la vérification.\n\n- Le type auto permet à la commande mount de deviner quel type de système de fichiers est utilisé. Ceci est utile pour les supports optiques (CD/DVD/Blu-ray).\n- Si la partition racine est de type btrfs ou XFS, l'option fsck devrait être réglée sur 0. Consultez fsck.btrfs(8) et fsck.xfs(8).\n\nTous les périphériques spécifiés dans /etc/fstab seront automatiquement montés au démarrage et lorsque le le paramètre -a est utilisé avec mount(8), sauf si l'option noauto est spécifiée. Les périphériques répertoriés et non présents entraîneront une erreur sauf si l'option nofail est utilisée.\n\nConsultez fstab(5) § DESCRIPTION pour plus de détails.\n\n"
    },
    {
      "title": "Identification des systèmes de fichiers",
      "level": 2,
      "content": "Il existe différentes façons d'identifier les systèmes de fichiers qui seront montés dans /etc/fstab: le descripteur de nom du noyau, l'étiquette, l'UUID du système de fichier, les étiquettes GPT et les UUID de la partition pour les disques GPT. L'UUID doit être privilégié par rapport aux descripteurs de noms et aux étiquettes du noyau. Consultez Nommage persistant des périphériques de type bloc pour plus d'explications. Il est recommandé de lire cet article avant de continuer.\n\nDans cette section, nous décrirons comment monter des systèmes de fichiers en utilisant toutes les méthodes de montage disponibles par des exemples. La sortie des commandes lsblk -f et blkid utilisées dans les exemples suivants sont disponible dans l'article Nommage persistant des périphériques de type bloc. Pour utiliser les descripteurs de noms du noyau, utilisez /dev/sdxy dans la première colonne.\n\n"
    },
    {
      "title": "Descripteurs de noms du noyau",
      "level": 3,
      "content": "Exécutez lsblk -f pour lister les partitions et préfixer les valeurs dans la colonne NAME avec /dev/.\n\n```\n/etc/fstab\n```\n\n```\n# <device>        <dir>        <type>        <options>        <dump> <fsck>\n/dev/sda1         /boot        vfat          defaults         0      2\n/dev/sda2         /            ext4          defaults         0      1\n/dev/sda3         /home        ext4          defaults         0      2\n/dev/sda4         none         swap          defaults         0      0\n```\n\n"
    },
    {
      "title": "Étiquettes du système de fichiers",
      "level": 3,
      "content": "Exécutez lsblk -f pour lister les partitions et préfixez les valeurs de la colonne LABEL par LABEL= ou exécutez blkid et utilisez les valeurs LABEL sans les guillemets :\n\n```\n/etc/fstab\n```\n\n```\n# <device>        <dir>        <type>        <options>        <dump> <fsck>\nLABEL=ESP         /boot        vfat          defaults         0      2\nLABEL=System      /            ext4          defaults         0      1\nLABEL=Data        /home        ext4          defaults         0      2\nLABEL=Swap        none         swap          defaults         0      0\n```\n\n"
    },
    {
      "title": "UUIDs du système de fichiers",
      "level": 3,
      "content": "Exécutez lsblk -f pour lister les partitions, et préfixez les valeurs de la colonne UUID avec UUID= ou alternativement exécutez blkid et utilisez les valeurs UUID sans les guillemets :\n\n```\n/etc/fstab\n```\n\n```\n# <device>                                <dir> <type> <options> <dump> <fsck>\nUUID=CBB6-24F2                            /boot vfat   defaults  0      2\nUUID=0a3407de-014b-458b-b5c1-848e92a327a3 /     ext4   defaults  0      1\nUUID=b411dc99-f0a0-4c87-9e05-184977be8539 /home ext4   defaults  0      2\nUUID=f9fe0b69-a280-415d-a03a-a32752370dee none  swap   defaults  0      0\n```\n\n"
    },
    {
      "title": "Étiquettes de partition GPT",
      "level": 3,
      "content": "Exécutez blkid pour lister les partitions, et utilisez les valeurs PARTLABEL sans les guillemets :\n\n```\n/etc/fstab\n```\n\n```\n# <device>                           <dir> <type> <options> <dump> <fsck>\nPARTLABEL=EFI\\040system\\040partition /boot vfat   defaults  0      2\nPARTLABEL=GNU/Linux                  /     ext4   defaults  0      1\nPARTLABEL=Home                       /home ext4   defaults  0      2\nPARTLABEL=Swap                       none  swap   defaults  0      0\n```\n\n"
    },
    {
      "title": "UUIDs de partition GPT",
      "level": 3,
      "content": "Exécutez blkid pour lister les partitions, et utilisez les valeurs PARTUUID sans les guillemets :\n\n```\n/etc/fstab\n```\n\n```\n# <device>                                    <dir> <type> <options> <dump> <fsck>\nPARTUUID=d0d0d110-0a71-4ed6-936a-304969ea36af /boot vfat   defaults  0      2\nPARTUUID=98a81274-10f7-40db-872a-03df048df366 /     ext4   defaults  0      1\nPARTUUID=7280201c-fc5d-40f2-a9b2-466611d3d49e /home ext4   defaults  0      2\nPARTUUID=039b6c1c-7553-4455-9537-1befbc9fbc5b none  swap   defaults  0      0\n```\n\n"
    },
    {
      "title": "Montage automatique avec systemd",
      "level": 3,
      "content": "Consultez systemd.mount(5) pour toutes les options de montage de systemd.\n\n"
    },
    {
      "title": "Partition locale",
      "level": 4,
      "content": "Dans le cas d'une grande partition, il peut être plus efficace de permettre aux services qui ne dépendent pas d'elle de démarrer pendant qu'elle est vérifiée par fsck. Ceci peut être réalisé en ajoutant les options suivantes à l'entrée /etc/fstab de la partition :\n\n```\nnoauto,x-systemd.automount\n```\n\nCela permettra de vérifier et de monter la partition uniquement lors de son premier accès, et le noyau mettra en mémoire tampon tous les accès aux fichiers jusqu'à ce qu'elle soit prête. Cette méthode peut être utile si l'on a, par exemple, une partition /home de taille importante.\n\n"
    },
    {
      "title": "Système de fichiers distant",
      "level": 4,
      "content": "La même chose s'applique aux montages de systèmes de fichiers distants. Si vous voulez qu'ils soient montés uniquement lors de l'accès, vous devrez utiliser les paramètres noauto,x-systemd.automount. De plus, vous pouvez utiliser l'option x-systemd.mount-timeout= pour spécifier combien de temps systemd doit attendre la fin de la commande de montage. Enfin, l'option _netdev garantit que systemd comprend que le montage dépend du réseau et le commande une fois que le réseau est en ligne.\n\n```\nnoauto,x-systemd.automount,x-systemd.mount-timeout=30,_netdev\n```\n\n"
    },
    {
      "title": "Système de fichiers chiffrés",
      "level": 4,
      "content": "Si vous avez des systèmes de fichiers chiffrés avec des fichiers de clés (keyfiles), vous pouvez également ajouter le paramètre noauto aux entrées correspondantes dans /etc/crypttab. systemd n'ouvrira alors pas le périphérique chiffré au démarrage, mais attendra qu'il soit réellement accédé et l'ouvrira automatiquement avec le fichier de clé spécifié avant de le monter. Cela peut faire gagner quelques secondes au démarrage si vous utilisez un périphérique RAID chiffré par exemple, car systemd n'a pas à attendre que le périphérique soit disponible. Par exemple :\n\n```\n/etc/crypttab\n```\n\n```\n].\ndata /dev/md0 /root/key noauto\n```\n\n"
    },
    {
      "title": "Démontage automatique",
      "level": 4,
      "content": "Vous pouvez également spécifier un délai d'inactivité pour un montage avec l'indicateur x-systemd.idle-timeout. Par exemple :\n\n```\nnoauto,x-systemd.automount,x-systemd.idle-timeout=1min\n```\n\nCeci fera que systemd démontera le montage après qu'il soit resté inactif pendant 1 minute.\n\n"
    },
    {
      "title": "Périphériques externes",
      "level": 3,
      "content": "Les périphériques externes qui doivent être montés lorsqu'ils sont présents mais ignorés s'ils sont absents peuvent nécessiter l'option nofail. Cela évite que des erreurs soient signalées au démarrage. Par exemple:\n\n```\n/etc/fstab\n```\n\n```\n/dev/sdg1        /media/backup    jfs    defaults,nofail,x-systemd.device-timeout=1    0  2\n```\n\nL'option nofail se combine de préférence avec l'option x-systemd.device-timeout. En effet, le délai d'expiration par défaut du périphérique est de 90 secondes, de sorte qu'un périphérique externe déconnecté avec seulement nofail fera prendre à votre démarrage 90 secondes de plus, à moins que vous ne reconfiguriez le délai d'expiration comme indiqué. Assurez-vous de ne pas régler le délai d'attente sur 0, car cela se traduit par un délai d'attente infini.\n\n"
    },
    {
      "title": "Espaces dans les chemins de fichiers",
      "level": 3,
      "content": "Comme les espaces sont utilisés dans fstab pour délimiter les champs, si un champ (PARTLABEL, LABEL ou le point de montage) contient des espaces, ils doivent être remplacés par des caractères d'échappement suivis par un code octal à 3 chiffres, soit \\040:\n\n```\n/etc/fstab\n```\n\n```\nUUID=47FA-4071     /home/username/Camera\\040Pictures   vfat  defaults       0  0\n/dev/sda7          /media/100\\040GB\\040(Storage)       ext4  defaults,user  0  2\n```\n\n"
    },
    {
      "title": "Options atime",
      "level": 3,
      "content": "Les options ci-dessous peuvent affecter les performances du lecteur.\n\n- L'option strictatime met à jour le temps d'accès des fichiers chaque fois qu'ils sont consultés. C'est plus utile lorsque Linux est utilisé pour les serveurs; il n' a pas beaucoup de valeur pour l'utilisation du bureau. L'inconvénient de l'option strictatime est que même la lecture d'un fichier dans le cache de la page (lecture à partir de la mémoire au lieu du lecteur) entraînera toujours une écriture!\n\n- L'option noatime désactive complètement les temps d'accès aux fichiers d'écriture sur le lecteur chaque fois que vous lisez un fichier. Cela fonctionne bien pour presque toutes les applications, sauf pour celles qui ont besoin de savoir si un fichier a été lu depuis sa dernière modification. Les informations de temps d'écriture d'un fichier continueront à être mises à jour chaque fois que le fichier est écrit avec cette option activée.\n\n- L'option nodiratime désactive l'écriture des temps d'accès aux fichiers uniquement pour les répertoires alors que d'autres fichiers ont encore des temps d'accès écrits. Note: noatime implique nodiratime. Vous n'avez pas besoin de préciser les deux.\n\n- relatime met à jour le temps d'accès uniquement si le temps d'accès précédent était antérieur à l'heure de modification ou de changement en cours. En outre, depuis Linux 2.6.30, le temps d'accès est toujours mis à jour si le temps d'accès précédent remontait à plus de 24 heures. Cette option est utilisée lorsque aucune valeur de l'option atime n'est spécifiée, ou que celle ci est default (ce qui signifie utiliser l'option par défaut du noyau, qui est relatime; voir mount(8) et wikipedia: Stat (appel système)).\n\nLorsque vous utilisez Mutt (en) ou d'autres applications qui ont besoin de savoir si un fichier a été lu depuis la dernière fois qu'il a été modifié, l'option noatime ne doit pas être utilisée; utiliser l'option relatime est acceptable et fournit quand même une amélioration de performance.\n\nDepuis le noyau 4.0 il y a une autre option connexe:\n\n- lazytime réduit les écritures sur le disque en maintenant les changements aux horodatages des inodes (temps d'accès, de modification et de création) uniquement en mémoire. Les horodatages sur le disque ne sont mis à jour que lorsque (1) l'inode du fichier a besoin d'être mis à jour pour certains changements non liés aux horodatages du fichier, (2) une synchronisation sur disque se produit, (3) une inode non supprimée est expulsée de la mémoire ou (4) si plus de 24 heures se sont écoulées depuis la dernière fois que la copie en mémoire a été écrite sur le disque. Attention: En cas de panne du système, les temps d'accès et de modification sur le disque dur peuvent être dépassés jusqu'à 24 heures.\n\n"
    },
    {
      "title": "Remontage de la partition racine",
      "level": 3,
      "content": "Si, pour une raison quelconque, la partition racine a été incorrectement montée en lecture seule, remontez la partition racine avec un accès en lecture-écriture avec la commande suivante:\n\n```\n# mount -o remount,rw /\n```\n\n"
    },
    {
      "title": "Montage automatique des partitions GPT",
      "level": 3,
      "content": "Lorsque vous utilisez UEFI/GPT, il est possible d'omettre certaines partitions de /etc/fstab en partitionnant selon la Discoverable Partitions Specification et de faire monter les partitions par systemd-gpt-auto-generator(8). Consultez Systemd (Français)#Montage automatique d'une partition GPT.\n\n"
    },
    {
      "title": "Voir également",
      "level": 2,
      "content": "- Liste complète des périphériques, y compris le périphérique de bloc.\n- Système de fichiers hiérarchie standard.\n- Cache 30x plus rapide et vitesse du site avec TMPFS\n- Ajout de partage Samba dans /etc/fstab\n\n"
    }
  ]
}