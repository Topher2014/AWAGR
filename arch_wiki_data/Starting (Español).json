{
  "title": "Starting (Español)",
  "url": "https://wiki.archlinux.org/title/Starting_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2018-12-09** \n\nArtículos relacionados\n\n- systemd/User (Español)\n- systemd/Timers (Español)\n- systemd FAQ (Español)\n- init\n- Daemons (Español)\n- udev (Español)\n- Improving performance/Boot process (Español)\n- Allow users to shutdown (Español)\n\nDe la página web del proyecto:\n\n"
    },
    {
      "title": "Utilización básica de systemctl",
      "level": 2,
      "content": "La principal orden usada para conocer y controlar systemd es systemctl. Algunos de los posibles usos son el examen del estado del sistema y la gestión del sistema o de los servicios. Consulte systemctl(1) para conocer más detalles.\n\n- Puede utilizar las siguientes órdenes systemctl con el parámetro -H usario@host para controlar una instancia de systemd en una máquina remota. Esto utilizará SSH para conectarse a la instancia systemd remota;\n- Lo usuarios de Plasma pueden instalar systemd-kcmAUR[enlace roto: package not found] como una interfaz gráfica para systemctl. Después de instalar el módulo se agregará a Administración del sistema.\n\n"
    },
    {
      "title": "Analizar el estado del sistema",
      "level": 3,
      "content": "Para mostrar el estado del sistema utilice:\n\n```\n$ systemctl status\n```\n\nPara listar unidades en ejecución:\n\n```\n$ systemctl\n```\n\no:\n\n```\n$ systemctl list-units\n```\n\nPara listar unidades que han fallado:\n\n```\n$ systemctl --failed\n```\n\nLos archivos de las unidades disponibles se pueden ver en /usr/lib/systemd/system/ y /etc/systemd/system/ (este último tiene prioridad). Puede ver un listado de las unidades instaladas con:\n\n```\n$ systemctl list-unit-files\n```\n\n"
    },
    {
      "title": "Utilizar las unidades",
      "level": 3,
      "content": "Las unidades pueden ser, por ejemplo, services (.service), mount points (.mount), devices (.device) o sockets (.socket).\n\nCuando se usa systemctl, por lo general, tiene que especificar el nombre completo de la unidad, incluyendo el sufijo, por ejemplo, sshd.socket. Sin embargo, hay unos pocos atajos cuando se especifica la unidad en las siguientes órdenes systemctl:\n\n- Si no se especifica el sufijo, systemctl asumirá que es .service. Por ejemplo, netctl y netctl.service se consideran equivalentes.\n- Los puntos de montaje se traducirán automáticamente en la correspondiente unidad .mount. Por ejemplo, si especifica /home será equivalente a home.mount.\n- Similar a los puntos de montaje, los dispositivos se traducen automáticamente en la correspondiente unidad .device, por lo tanto, la especificación /dev/sda2 es equivalente a dev-sda2.device.\n\nVéase systemd.unit(5) para más detalles.\n\nNote: Para ser más precisos, antes de probar inicializar una instancia de unidad de plantilla name@.suffix, systemd buscará una unidad con el nombre del archivo name@string.suffix exacto, aunque por convención, tal «conflicto» ocurre raramente, es decir, la mayoría de los archivos de unidades que contienen un signo @ son plantillas. Además, si se llama a una unidad de plantilla sin un identificador de instancia, simplemente fallará, ya que el especificador %i no puede ser sustituido.\n\nPara ser más precisos, antes de probar inicializar una instancia de unidad de plantilla name@.suffix, systemd buscará una unidad con el nombre del archivo name@string.suffix exacto, aunque por convención, tal «conflicto» ocurre raramente, es decir, la mayoría de los archivos de unidades que contienen un signo @ son plantillas. Además, si se llama a una unidad de plantilla sin un identificador de instancia, simplemente fallará, ya que el especificador %i no puede ser sustituido.\n\nActiva una unidad de inmediato:\n\n```\n# systemctl start unidad\n```\n\nDetiene una unidad de inmediato:\n\n```\n# systemctl stop unidad\n```\n\nReinicia la unidad:\n\n```\n# systemctl restart unidad\n```\n\nHace que una unidad recargue su configuración:\n\n```\n# systemctl reload unidad\n```\n\nMuestra el estado de una unidad, incluso si se está ejecutando o no:\n\n```\n$ systemctl status unidad\n```\n\nComprueba si la unidad ya está activada o no:\n\n```\n$ systemctl is-enabled unidad\n```\n\nActiva una unidad para inicarse en el arranque:\n\n```\n# systemctl enable unidad\n```\n\nActiva una unidad para inicarse en el arranque y lo inicia inmediatamente:\n\n```\n# systemctl enable --now unidad\n```\n\nDesactiva el inicio automático durante el arranque:\n\n```\n# systemctl disable unidad\n```\n\nEnmascara una unidad para que sea imposible iniciarla (tanto de forma manual como de dependencia, lo que hace que el enmascaramiento sea peligroso):\n\n```\n# systemctl mask unidad\n```\n\nDesenmascara una unidad:\n\n```\n# systemctl unmask unidad\n```\n\nMuestre la página del manual asociada a una unidad (esto debe ser compatible con el archivo de la unidad):\n\n```\n$ systemctl help unidad\n```\n\nRecarga la configuración de systemd, buscando unidades nuevas o modificadas:\n\n```\n# systemctl daemon-reload\n```\n\n"
    },
    {
      "title": "Gestionar la energía",
      "level": 3,
      "content": "polkit es necesario para gestionar la energía. Si se encuentra en una sesión local de systemd-logind y ninguna otra sesión está activa, las órdenes siguientes funcionarán sin requerir privilegios de root. Si no es así (por ejemplo, debido a que otro usuario ha iniciado otra sesión tty), systemd automáticamente le requerirá la contraseña de root.\n\nApagado y reinicio del sistema:\n\n```\n$ systemctl reboot\n```\n\nApagado del sistema:\n\n```\n$ systemctl poweroff\n```\n\nSuspensión del sistema:\n\n```\n$ systemctl suspend\n```\n\nPoner el sistema en hibernación:\n\n```\n$ systemctl hibernate\n```\n\nPoner el sistema en estado de reposo híbrido — «hybrid-sleep» — (o suspensión combinada — «suspend-to-both» —):\n\n```\n$ systemctl hybrid-sleep\n```\n\n"
    },
    {
      "title": "Escribir archivos de unidad",
      "level": 2,
      "content": "La sintaxis de los archivos de unidad de systemd (systemd.unit(5)) está inspirada en los archivos .desktop de la Especificación de Entrada del Escritorio XDG que a su vez están inspirados en los archivos .ini de Microsoft Windows. Los archivos de unidad se cargan desde varias ubicaciones (para ver la lista completa, ejecute systemctl show --property=UnitPath), pero los principales son (enumerados desde la prioridad más baja a la más alta):\n\n- /usr/lib/systemd/system/: unidades proporcionadas por los paquetes instalados.\n- /etc/systemd/system/: unidades instaladas por el administrador del sistema.\n\n- Las rutas de carga son completamente diferentes cuando se ejecuta systemd en momdo usuario.\n- Los nombres de las unidades del sistema solo pueden contener caracteres alfanuméricos ASCII, guiones bajos y puntos. Todos los demás caracteres deben reemplazarse por escapes «\\x2d» de estilo C, o emplear su semántica predefinida ('@','-'). Consulte systemd.unit(5) y systemd-escape(1) para obtener más información.\n\nMire las unidades instaladas por sus paquetes para obtener ejemplos, así como la systemd.service(5) § EXAMPLES.\n\n"
    },
    {
      "title": "Manejar las dependencias",
      "level": 3,
      "content": "Con systemd las dependencias pueden ser resueltas diseñando la unidad correctamente. El caso más típico es que la unidad A requiere la unidad B para poder funcionar, por lo que esta última debe iniciarse antes que A. En ese caso, agregue Requires=B y After=B a la sección [Unit] de A. Si la dependencia es opcional agregue, en su lugar, Wants=B y After=B. Tenga en cuenta que Wants= y Requires= no incluyen After=, lo que significa que si After= no esté especificado, las dos unidades se iniciarán en paralelo.\n\nLas dependencias se colocan normalmente en los archivos .service y no en los #Targets. Por ejemplo, network.target es llamado por cualquiera que sea el servicio que configure las interfaces de red, por lo tanto, la solicitud que hace después la propia unidad personalizada es suficiente, ya que network.target se inicia de todos modos.\n\n"
    },
    {
      "title": "Tipos de servicios",
      "level": 3,
      "content": "Existen diferentes tipos de arranque a tener en cuenta cuando se escribe un archivo de servicio personalizado. Esto se configura mediante el parámetro Type= en la sección [Service].\n\n- Type=simple (por defecto): systemd considera que el servicio debe iniciarse inmediatamente. El proceso no debe romperse. No utilice este tipo si otros servicios tienen que ser llamados por ese servicio, a menos que no sea activado por el socket.\n- Type=forking: systemd considera que el servicio debe ser iniciado antes que el proceso se rompa y el antecesor se haya terminado. Para los demonios clásicos use este tipo a menos que sepa que no es necesario, ya que la mayoría de los demonios usan doble bifurcación para indicar que están listos. Debe especificar también PIDFile= para que systemd puede realizar un seguimiento del proceso principal.\n- Type=oneshot: esto es útil para los scripts que hacen un solo trabajo y luego concluyen. Es posible que desee también establecer RemainAfterExit=yes de modo que systemd sigue considerando el servicio como activo después de que el proceso haya terminado.\n- Type=notify: igual que Type=simple, pero con la condición de que el demonio va a enviar una señal a systemd cuando esté listo. Esto requiere del código específico proporcionado por libsystemd-daemon.so.\n- Type=dbus: el servicio se considera listo cuando el BusName especificado aparece en el bus del sistema DBus.\n- Type=idle: systemd retrasará la ejecución del binario del servicio hasta que se envíen todos los trabajos. Un comportamiento por cierto muy similar a Type=simple.\n\nConsulte la página del manual systemd.service(5) § OPTIONS para obtener una explicación más detallada de los valores Type.\n\n"
    },
    {
      "title": "Modificar los archivos de unidad suministrados",
      "level": 3,
      "content": "Para evitar conflictos con pacman, los archivos de unidad proporcionados por los paquetes no deben editarse directamente. Hay dos formas seguras de modificar una unidad sin tocar el archivo original: crear un nuevo archivo de unidad que sobrescriba la unidad original o crear fragmentos para insertarlos que se aplican sobre la unidad original. Para ambos métodos, debe volver a cargar la unidad posteriormente para que los cambios surtan efectos. Esto se puede hacer editando la unidad con systemctl edit (que recarga la unidad automáticamente) o recargando todas las unidades con:\n\n```\n# systemctl daemon-reload\n```\n\n- Puede usar systemd-delta para ver qué archivos de la unidad se han sobrescrito o ampliado y qué se ha cambiado exactamente.\n- Utilice systemctl cat unidad para ver el contenido de un archivo de unidad y todos los fragmentos insertados asociados.\n\n"
    },
    {
      "title": "Reemplazar los archivos de unidad",
      "level": 4,
      "content": "Para reemplazar el archivo de unidad /usr/lib/systemd/system/unit, cree el archivo /etc/systemd/system/unit y reactive la unidad para actualizar los enlaces simbólicos:\n\n```\n# systemctl reenable unidad\n```\n\nAlternativamente, ejecute:\n\n```\n# systemctl edit --full unidad\n```\n\nEsto abre /etc/systemd/system/unit en su editor (copiando la versión instalada si aún no existe) y la vuelve a cargar automáticamente cuando termina de editar.\n\n"
    },
    {
      "title": "Archivos insertados",
      "level": 4,
      "content": "Para crear fragmentos de archivos para insertar en el archivo de unidad /usr/lib/systemd/system/unit, cree el directorio /etc/systemd/system/unit.d/ y coloque los archivos .conf allí para sobrescribir o agregar nuevas opciones. systemd analizará y aplicará estos archivos con preferencia a la unidad original.\n\nLa forma más fácil de hacer esto es ejecutar:\n\n```\n# systemctl edit unidad\n```\n\nEsto abre el archivo /etc/systemd/system/unit.d/override.conf en su editor de texto (creándolo si es necesario) y vuelve a cargar automáticamente la unidad cuando haya terminado de editarla.\n\n"
    },
    {
      "title": "Volver a la versión del proveedor",
      "level": 4,
      "content": "Para revertir cualquier cambio en una unidad realizada utilizando systemctl edit, ejecute:\n\n```\n# systemctl revert unidad\n```\n\n"
    },
    {
      "title": "Ejemplos",
      "level": 4,
      "content": "Por ejemplo, si simplemente desea agregar una dependencia adicional a una unidad, puede crear el siguiente archivo:\n\n```\n/etc/systemd/system/unit.d/customdependency.conf\n```\n\n```\n[Unit]\nRequires=dependencia nueva\nAfter=dependencia nueva\n```\n\nOtro ejemplo, para reemplazar la directiva ExecStart para una unidad que no sea del tipo oneshot, cree el siguiente archivo:\n\n```\n/etc/systemd/system/unit.d/customexec.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=orden nueva\n```\n\nObserve como ExecStart debe quedar límpio antes de volver a reasignarse [1]. Lo mismo se aplica a cada elemento que se puede especificar varias veces, por ejemplo OnCalendar para los temporizadores.\n\nUn ejemplo más para reiniciar automáticamente un servicio:\n\n```\n/etc/systemd/system/unit.d/restart.conf\n```\n\n```\n[Service]\nRestart=always\nRestartSec=30\n```\n\n"
    },
    {
      "title": "Targets",
      "level": 2,
      "content": "systemd utiliza targets («objetivos») que sirven a un propósito similar a los runlevels («niveles de ejecución»), pero que tienen un comportamiento un poco diferente. Cada target se nomina, en lugar de numerarse, y está destinado a servir a un propósito específico con la posibilidad de realizar más de una acción al mismo tiempo. Algunos targets son activados heredando todos los servicios de otro target e implementando servicios adicionales. Como hay targets de systemd que imitan los runlevels de SystemVinit, es, por tanto, posible pasar de un target a otro utilizando la orden telinit RUNLEVEL.\n\n"
    },
    {
      "title": "Conocer los targets presentes",
      "level": 3,
      "content": "La siguiente orden debe ser utilizada bajo systemd, en lugar de runlevel:\n\n```\n$ systemctl list-units --type=target\n```\n\n"
    },
    {
      "title": "Crear un target personalizado",
      "level": 3,
      "content": "Los niveles de ejecución («runlevels») que tenían un significado definido bajo sysvinit (es decir, 0, 1, 3, 5 y 6), tienen una correlación de 1:1 con un específico target de systemd. Desafortunadamente, no hay una buena manera de hacer lo mismo para los niveles de ejecución definidos por el usuario como son el 2 y el 4. Si se hace uso de estos últimos, se sugiere dar un nuevo nombre al target de systemd como /etc/systemd/system/su target que tome como base uno de los runlevels existentes (vea /usr/lib/systemd/system/graphical.target como ejemplo), cree un directorio /etc/systemd/system/su target.wants, y haga un enlace a los servicios adicionales de /usr/lib/systemd/system/ que desea activar.\n\n"
    },
    {
      "title": "Correlación entre los niveles de ejecución de SysV y los targets de systemd",
      "level": 3,
      "content": "Table content:\nNivel de ejecución de SysV | Target de systemd | Notas\n0 | runlevel0.target, poweroff.target | Detiene el sistema.\n1, s, single | runlevel1.target, rescue.target | Modalidad de usuario único.\n2, 4 | runlevel2.target, runlevel4.target, multi-user.target | Definidos por el usuario/específico del sistio. Preconfigurados a 3.\n3 | runlevel3.target, multi-user.target | Multiusuario, no gráfica. Los usuarios, por lo general, pueden acceder a través de múltiples consolas o a través de la red.\n5 | runlevel5.target, graphical.target | Multiusuario, gráfica. Por lo general, tiene todos los servicios del nivel de ejecución 3, además de un inicio de sesión gráfica.\n6 | runlevel6.target, reboot.target | Reinicia el sistema.\nemergency | emergency.target | Consola de emergencia.\n\n"
    },
    {
      "title": "Cambiar el target vigente",
      "level": 3,
      "content": "En systemd los targets quedan expuestos a través de «target units». Se pueden cambiar de esta manera:\n\n```\n# systemctl isolate graphical.target\n```\n\nEsto solo cambiará el target actual, y no tendrá ningún efecto sobre el siguiente arranque. Esto es equivalente a las órdenes telinit 3 o telinit 5 en Sysvinit.\n\n"
    },
    {
      "title": "Cambiar el target predeterminado para arrancar",
      "level": 3,
      "content": "El target estándar es default.target, que es un enlace simbólico para graphical.target. Este se corresponde con el antiguo nivel de ejecución 5.\n\nPara verificar el target actual con systemctl, ejecute:\n\n```\n$ systemctl get-default\n```\n\nPara cambiar el target predeterminado para arrancar, cambie el enlace simbólico default.target. Con systemctl:\n\n```\n# systemctl set-default multi-user.target\n```\n\n```\nRemoved /etc/systemd/system/default.target.\nCreated symlink /etc/systemd/system/default.target -> /usr/lib/systemd/system/graphical.target.\n```\n\nComo alternativa, agregue uno de los siguientes parámetros del kernel a su cargador de arranque:\n\n- systemd.unit=multi-user.target (que corresponde aproximadamente al anterior nivel de ejecución 3),\n- systemd.unit=rescue.target (que corresponde aproximadamente al anterior nivel de ejecución 1).\n\n"
    },
    {
      "title": "Orden de los target por defecto",
      "level": 3,
      "content": "Systemd elige el default.target de acuerdo con el siguiente orden:\n\n1. El parámetro del kernel se muestra arriba\n1. Enlace simbólico de /etc/systemd/system/default.target\n1. Enlace simbólico de /usr/lib/systemd/system/default.target\n\n"
    },
    {
      "title": "Archivos temporales",
      "level": 2,
      "content": "«systemd-tmpfiles crea, elimina y limpia archivos y directorios volátiles y temporales.» Lee los archivos de configuración en /etc/tmpfiles.d/ y /usr/lib/tmpfiles.d/ para descubrir qué acciones realizar. Los archivos de configuración del primer directorio tienen prioridad sobre los del último directorio.\n\nLos archivos de configuración son proveídos normalmente junto con los archivos de servicio, y reciben su nombre en el estilo /usr/lib/tmpfiles.d/programa.conf. Por ejemplo, el demonio Samba espera que el directorio /run/samba exista para obtener los permisos adecuados. Por tanto, el paquete samba viene con esta configuración:\n\n```\n/usr/lib/tmpfiles.d/samba.conf\n```\n\n```\nD /run/samba 0755 root root\n```\n\nLos archivos de configuración también pueden ser usados para escribir en el arranque valores en ciertos archivos. Por ejemplo, si usa /etc/rc.local para dehabilitar la reactivación del sistema («wakeup») a través de dispositivos USB con la orden echo USBE > /proc/acpi/wakeup, se puede utilizar, en su lugar, el siguiente tmpfile:\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Path                  Mode UID  GID  Age Argument\nw    /proc/acpi/wakeup     -    -    -    -   USBE\n```\n\nConsulte las páginas de los manuales systemd-tmpfiles(8) y tmpfiles.d(5) para obtener más detalles.\n\n"
    },
    {
      "title": "Temporizadores",
      "level": 2,
      "content": "Un temporizador es un archivo de configuración de unidad cuyo nombre termina en .timer y codifica información sobre un temporizador controlado y supervisado por systemd, para la activación basada en plazos de tiempo. Consulte systemd/Timers.\n\n"
    },
    {
      "title": "Montaje",
      "level": 2,
      "content": "systemd se encarga de montar las particiones y los sistemas de archivos especificados en /etc/fstab. El script systemd-fstab-generator(8) traduce todas las entradas presentes en /etc/fstab en unidades de systemd, esto se realiza en el momento del arranque y cada vez que se vuelve a cargar la configuración del gestor del sistema.\n\nsystemd extiende las habituales capacidades de fstab y ofrece opciones de montaje adicionales. Esto afecta a las dependencias de la unidad de montaje; por ejemplo, se puede garantizar que un montaje se realice solo una vez que la red esté activa o solo cuando se monte otra partición. La lista completa de las opciones de montaje específicas de systemd, que generalmente llevan el prefijo x-systemd., se detalla en systemd.mount(5) § FSTAB.\n\nEn Montaje automático con systemd se proporciona un ejemplo de estas opciones de montaje en el contexto del automontaje, pensando en aquellos recursos que se deben montar tan solo cuando se les requiere en lugar de automáticamente en el momento del arranque.\n\n"
    },
    {
      "title": "Montaje automático de particiones GPT",
      "level": 3,
      "content": "En un disco particionado con GPT, el script systemd-gpt-auto-generator(8) montará particiones siguiendo la especificación de particiones detectables , por lo tanto, las mismas se pueden omitir de fstab.\n\nEl montaje automático de una partición se puede desactivar cambiando el tipo GUID de la partición o configurando el atributo 63 \"do not automount\" para la partición en cuestión, véase gdisk#Prevent GPT partition automounting.\n\n"
    },
    {
      "title": "Ejecutar servicios después de que la conexión de red esté activa",
      "level": 3,
      "content": "Para demorar la ejecución de un servicio hasta depués de que la red esté funcionando, incluya las siguientes dependencias en el archivo .service:\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target\n...\n```\n\nEl servicio de espera de red de la particular aplicación que gestiona la conexión la red también debe activarse para que network-online.target refleje adecuadamente el estado de la red.\n\n- Para los que usan NetworkManager, active NetworkManager-wait-online.service.\n- Si se usa systemd-networkd, systemd-networkd-wait-online.service se activa automáticamente de forma predeterminada cada vez que systemd-networkd.service está activado; compruebe que este es el caso con systemctl is-enabled systemd-networkd-wait-online.service, lo cual hará que no se necesite ninguna otra acción.\n\nPara obtener explicaciones más detalladas, consulte: Network configuration synchronization points.\n\n"
    },
    {
      "title": "Activar las unidades instaladas por defecto",
      "level": 3,
      "content": "Arch Linux se entrega con /usr/lib/systemd/system-preset/99-default.preset que contiene disable *. Esto hace que systemctl preset desactive todas las unidades de forma predeterminada, de modo que cuando se instala un nuevo paquete, el usuario debe activar la unidad manualmente.\n\nSi este comportamiento no es deseado, simplemente cree un enlace simbólico de /etc/systemd/system-preset/99-default.preset a /dev/null para anular el archivo de configuración . Esto hará que systemctl preset active todas las unidades que se instalan, independientemente del tipo de unidad, a menos que se especifique otra cosa en otro archivo ubicado en uno de los directorios de configuración de systemctl preset. Las unidades de usuario no se verán afectadas. Vea systemd.preset(5) para más información.\n\n"
    },
    {
      "title": "Entornos seguros para probar aplicaciones",
      "level": 3,
      "content": "Un archivo de unidad se puede crear como un sandbox para aislar aplicaciones y sus procesos dentro de un entorno virtual reforzado. systemd aprovecha los espacio de nombres, las listas blancas/negras basadas en Capabilities y los grupos de control para contener procesos a través de una extensa configuración de entornos de ejecución—systemd.exec(5).\n\nEl aprovisionamiento de un archivo de unidad systemd existente con la aplicación sandboxing, generalmente requiere de pruebas de ensayo y error acompañadas del uso generoso de strace, stderr, registro de errores de journalctl(1) y de salida de recursos. Es posible que desee buscar primero en la documentación anterior los test ya realizados a partir de los cuales realizar la pruebas.\n\nAlgunos ejemplos sobre cómo se puede implementar el sandboxing con systemd:\n\n- CapabilityBoundingSet define un conjunto en lista blanca de capacidades permitidas, pero también se puede usar para incluir en una lista negra una capacidad específica para una unidad. La capacidad CAP_SYS_ADM, por ejemplo, que debería ser uno de los objetivos de un sandbox seguro: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n- La capacidad CAP_SYS_ADM, por ejemplo, que debería ser uno de los objetivos de un sandbox seguro: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n"
    },
    {
      "title": "Investigar errores de systemd",
      "level": 3,
      "content": "Como ejemplo, vamos a investigar un error con el servicio systemd-modules-load:\n\n1. Vamos a determinar los servicios de systemd que fallan al inicio:\n\n```\n$ systemctl --state=failed\n```\n\n```\nsystemd-modules-load.service   loaded failed failed  Load Kernel Modules\n```\n\nOtra forma es ver los mensajes en vivo del registro de systemd:\n\n```\n$ journalctl -fp err\n```\n\n2. Encontramos un problema con el servicio systemd-modules-load. Indaguemos un poco más:\n\n```\n$ systemctl status systemd-modules-load\n```\n\n```\nsystemd-modules-load.service - Load Kernel Modules\n   Loaded: loaded (/usr/lib/systemd/system/systemd-modules-load.service; static)\n   Active: failed (Result: exit-code) since So 2013-08-25 11:48:13 CEST; 32s ago\n     Docs: man:systemd-modules-load.service(8).\n           man:modules-load.d(5)\n  Process: 15630 ExecStart=/usr/lib/systemd/systemd-modules-load (code=exited, status=1/FAILURE)\n```\n\nSi el Process ID no está en la lista, simplemente reinicie el servicio fallido con systemctl restart systemd-modules-load\n\n3. Ahora tenemos el identificador del proceso (PID) para investigar este error en profundidad. Escribimos la siguiente orden con el Process ID (en este caso: 15630):\n\n```\n$ journalctl _PID=15630\n```\n\n```\n-- Logs begin at Sa 2013-05-25 10:31:12 CEST, end at So 2013-08-25 11:51:17 CEST. --\nAug 25 11:48:13 mypc systemd-modules-load[15630]: Failed to find module 'blacklist usblp'\nAug 25 11:48:13 mypc systemd-modules-load[15630]: Failed to find module 'install usblp /bin/false'\n```\n\n4. Vemos que algunos de los ajustes del módulo del kernel tienen valores erróneos. Por lo tanto, echemos un vistazo a estos valores en /etc/modules-load.d/:\n\n```\n$ ls -Al /etc/modules-load.d/\n```\n\n```\n...\n-rw-r--r--   1 root root    79  1. Dez 2012  blacklist.conf\n-rw-r--r--   1 root root     1  2. Mär 14:30 encrypt.conf\n-rw-r--r--   1 root root     3  5. Dez 2012  printing.conf\n-rw-r--r--   1 root root     6 14. Jul 11:01 realtek.conf\n-rw-r--r--   1 root root    65  2. Jun 23:01 virtualbox.conf\n...\n```\n\n5. El mensaje del error Failed to find module 'blacklist usblp' puede estar relacionado con un mal ajuste de blacklist.conf. Podemos desactivarlo insertando un signo # delante de cada opción que hemos descubierto que falla por medio del paso 3:\n\n```\n/etc/modules-load.d/blacklist.conf\n```\n\n```\n# blacklist usblp\n# install usblp /bin/false\n```\n\n6. Ahora, intente iniciar systemd-modules-load:\n\n```\n$ systemctl start systemd-modules-load.service\n```\n\nSi ha tenido éxito, no debe mostrarse ningún prompt. Si ve algún error, volveremos al paso 3 y utilizaremos el nuevo PID para solucionar los errores que aparecen en la izquierda.\n\nSi todo está bien, se puede verificar que el servicio se ha iniciado satisfactoriamente con:\n\n```\n$ systemctl status systemd-modules-load\n```\n\n```\nsystemd-modules-load.service - Load Kernel Modules\n   Loaded: loaded (/usr/lib/systemd/system/systemd-modules-load.service; static)\n   Active: active (exited) since So 2013-08-25 12:22:31 CEST; 34s ago\n     Docs: man:systemd-modules-load.service(8)\n           man:modules-load.d(5)\n Process: 19005 ExecStart=/usr/lib/systemd/systemd-modules-load (code=exited, status=0/SUCCESS)\nAug 25 12:22:31 mypc systemd[1]: Started Load Kernel Modules.\n```\n\n"
    },
    {
      "title": "Diagnosticar problemas de arranque",
      "level": 3,
      "content": "systemd tiene varias opciones para diagnosticar problemas con el proceso de arranque. Véase depuración del arranque para obtener instrucciones y opciones más generales para capturar mensajes de inicio antes de que systemd se haga cargo del proceso de arranque. Véase también ña documentación de depuración de errores de systemd.\n\n"
    },
    {
      "title": "Diagnosticar un servicio",
      "level": 3,
      "content": "Si algún servicio systemd se comporta mal o si desea obtener más información sobre lo que está sucediendo, configure la variable de entorno SYSTEMD_LOG_LEVEL a debug. Por ejemplo, para ejecutar el demonio systemd-networkd en modo de depuración de errores:\n\nAgregue un fragmento de archivo para el servicio agregando las dos líneas siguientes:\n\n```\n[Service]\nEnvironment=SYSTEMD_LOG_LEVEL=debug\n```\n\nO, de igual modo, establezca la variable de entorno manualmente:\n\n```\n# SYSTEMD_LOG_LEVEL=debug /lib/systemd/systemd-networkd\n```\n\nluego reinicie systemd-networkd y observe jopurnal para el servicio con la opción -f/--follow.\n\n"
    },
    {
      "title": "Apagar/reiniciar se hace terriblemente largo",
      "level": 3,
      "content": "Si el proceso de apagado tarda un tiempo muy largo (o parece congelarse), lo más probable es que un servicio no existente tenga la culpa. systemd espera un tiempo para iniciar cada servicio antes de tratar de acabar con él. Para averiguar si este es su caso, consulte este artículo.\n\n"
    },
    {
      "title": "Los procesos de corta duración parecen no registrar ninguna salida",
      "level": 3,
      "content": "Si systemctl -u foounit.service no muestra ninguna salida para un servicio de breve duración, compruebe el PID. Por ejemplo, si systemd-modules-load.service falla, y systemctl status systemd-modules-load muestra que es seguido con PID 123, entonces es posible ver la salida de journal para dicho PID, por ejemplo journalctl -b _PID=123. Los campos con metadatos para journal, como _SYSTEMD_UNIT y _COMM, se recogen en modo asíncrono y se basan en la carpeta /proc para el proceso existente. La reparación de este proceso requiere la reparación del kernel para proporcionar estos datos por medio de una conexión socket, de forma similar a SCM_CREDENTIALS. En resumen, es un bug. Tenga en cuenta que los servicios que fallan de inmediato pueden no imprimir nada en journal según el diseño de systemd.\n\n"
    },
    {
      "title": "El tiempo de arranque aumenta con el tiempo",
      "level": 3,
      "content": "Después de usar systemd-analyze varios usuarios advirtieron que su tiempo de arranque había aumentado significativamente en comparación con lo que solía ser. Después de usar systemd-analyze blame se informa que NetworkManager (Español) toma un tiempo inusualmente grande para comenzar.\n\nEl problema para algunos usuarios se debe a que /var/log/journal es demasiado grande. Esto puede tener otros impactos en el rendimiento, como para systemctl status o journalctl. Como tal, la solución es eliminar todos los archivos dentro de la carpeta (lo ideal sería hacer una copia de seguridad en algún lugar, al menos temporalmente) y luego establecer un límite de tamaño del archivo journal como se describe en Systemd (Español)/Journal (Español)#Límite del tamaño de journal.\n\n"
    },
    {
      "title": "systemd-tmpfiles-setup.service no se inicia en el arranque",
      "level": 3,
      "content": "A partir de systemd 219, /usr/lib/tmpfiles.d/systemd.conf especifica los atributos de ACL para los directorios en /var/log/journal y, por lo tanto, requiere que el soporte de ACL sea activado para el sistema de archivos en el que reside journal.\n\nVéase Access Control Lists#Enable ACL para obtener instrucciones sobre cómo activar la ACL en el sistema de archivos que aloja /var/log/journal.\n\n"
    },
    {
      "title": "La versión de systemd impresa en el arranque no es la misma que la versión del paquete instalado",
      "level": 3,
      "content": "Debe regenerar initramfs y las versiones deberían coincidir.\n\n"
    },
    {
      "title": "Desactivar el modo de emergencia en la máquina remota",
      "level": 3,
      "content": "Es posible que desee desactivar el modo de emergencia en una máquina remota, por ejemplo, una máquina virtual alojada en Azure o Google Cloud. Esto se debe a que, si se activa el modo de emergencia, la máquina no podrá conectarse a la red.\n\n```\n# systemctl mask emergency.service\n# systemctl mask emergency.target\n```\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- Wikipedia article\n- systemd Official web site systemd optimizations systemd FAQ systemd Tips and tricks\n- systemd(1)\n- Otras distribuciones Gentoo Wiki systemd page Fedora Project - About systemd Fedora Project - How to debug systemd problems Fedora Project - SysVinit to systemd cheatsheet Debian Wiki systemd page\n- Lennart's blog story, update 1, update 2, update 3, summary\n- systemd for Administrators (PDF)\n- How To Use Systemctl to Manage Systemd Services and Units\n- Session management with systemd-logind\n- Emacs Syntax highlighting for Systemd files\n- Two part introductory article in The H Open magazine.\n\n- systemd optimizations\n- systemd FAQ\n- systemd Tips and tricks\n\n- Gentoo Wiki systemd page\n- Fedora Project - About systemd\n- Fedora Project - How to debug systemd problems\n- Fedora Project - SysVinit to systemd cheatsheet\n- Debian Wiki systemd page\n\n"
    }
  ]
}