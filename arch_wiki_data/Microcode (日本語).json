{
  "title": "Microcode (日本語)",
  "url": "https://wiki.archlinux.org/title/Microcode_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "プロセッサの製造者はプロセッサマイクロコードに安定性とセキュリティのアップデートをリリースしています。そのようなアップデートには、システムの安定性に深く関わるバグフィックスが含まれています。これがないと、追跡困難な疑わしいクラッシュや予期しないシステム停止を引き起こす場合があります。\n\nAMD や Intel CPU を持つすべてのユーザは、システムの安定性を確保するためにマイクロコードのアップデートをインストールすべきです。仮想マシンやコンテナ内では、マイクロコードのアップデートはゲストシステムではなく、ホストに属します。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 マイクロコードをロードする 2.1 早期ロード 2.1.1 カスタムビルドされたカーネル 2.1.2 マイクロコード initramfs とメインの initramfs を1つのファイルに一緒にパックする 2.1.2.1 mkinitcpio 2.1.2.2 dracut 2.1.3 別個のマイクロコード initramfs ファイルを使う 2.1.3.1 GRUB 2.1.3.2 systemd-boot 2.1.3.3 EFISTUB 2.1.3.4 rEFInd 2.1.3.4.1 手動でブートオプションを記述する 2.1.3.5 Syslinux 2.1.3.6 LILO 2.1.3.7 Limine 2.2 遅延ロード 2.2.1 マイクロコードのアップデートの遅延ロード\n- 3 起動時にマイクロコードのアップデートがされたか確認する\n- 4 マイクロコードのアップデートができる CPU 4.1 マイクロコードのアップデートが必要かどうか確認する\n- 5 マイクロコードローダーを無効化する\n- 6 参照\n\n- 2.1 早期ロード 2.1.1 カスタムビルドされたカーネル 2.1.2 マイクロコード initramfs とメインの initramfs を1つのファイルに一緒にパックする 2.1.2.1 mkinitcpio 2.1.2.2 dracut 2.1.3 別個のマイクロコード initramfs ファイルを使う 2.1.3.1 GRUB 2.1.3.2 systemd-boot 2.1.3.3 EFISTUB 2.1.3.4 rEFInd 2.1.3.4.1 手動でブートオプションを記述する 2.1.3.5 Syslinux 2.1.3.6 LILO 2.1.3.7 Limine\n- 2.2 遅延ロード 2.2.1 マイクロコードのアップデートの遅延ロード\n\n- 2.1.1 カスタムビルドされたカーネル\n- 2.1.2 マイクロコード initramfs とメインの initramfs を1つのファイルに一緒にパックする 2.1.2.1 mkinitcpio 2.1.2.2 dracut\n- 2.1.3 別個のマイクロコード initramfs ファイルを使う 2.1.3.1 GRUB 2.1.3.2 systemd-boot 2.1.3.3 EFISTUB 2.1.3.4 rEFInd 2.1.3.4.1 手動でブートオプションを記述する 2.1.3.5 Syslinux 2.1.3.6 LILO 2.1.3.7 Limine\n\n- 2.1.2.1 mkinitcpio\n- 2.1.2.2 dracut\n\n- 2.1.3.1 GRUB\n- 2.1.3.2 systemd-boot\n- 2.1.3.3 EFISTUB\n- 2.1.3.4 rEFInd 2.1.3.4.1 手動でブートオプションを記述する\n- 2.1.3.5 Syslinux\n- 2.1.3.6 LILO\n- 2.1.3.7 Limine\n\n- 2.1.3.4.1 手動でブートオプションを記述する\n\n- 2.2.1 マイクロコードのアップデートの遅延ロード\n\n- 4.1 マイクロコードのアップデートが必要かどうか確認する\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "更新されたマイクロコードを入手するには、プロセッサに応じて以下のパッケージのどれかをインストールしてください:\n\n- amd-ucode: AMD プロセッサ。\n- intel-ucode: Intel プロセッサ。\n\nmkinitcpio と dracut はデフォルトで、(メインの initramfs とマイクロコードを) 混合した initramfs ファイルを生成します。マイクロコードはブート時に自動的にロードされます。Booster は混合 initramfs の生成をサポートしていません。#別個のマイクロコード initramfs ファイルを使う で説明されている、必要なブートローダー設定を参照してください。\n\n"
    },
    {
      "title": "マイクロコードをロードする",
      "level": 2,
      "content": "通常、マイクロコードのアップデートはマザーボードのファームウェアに同梱されており、ファームウェアの初期化中に適用されます。しかし、OEM はファームウェアのアップデートをタイムリーにリリースしないかもしれない上、古いシステムでは新しいファームウェアアップデートは全くリリースされないので、起動中に CPU マイクロコードアップデートを適用する機能が Linux カーネルに追加されました。Linux マイクロコードローダは3つの方法をサポートします:\n\n1. 組み込みマイクロコード は、カーネルに組み込んでコンパイルし、早期ローダ (early loader) を使って適用することができます。\n1. 早期ロード は、起動中の非常に早い段階 (initramfs ステージよりも前) でマイクロコードをアップデートします。遅延ロードよりもこちらが推奨されます。Intel の Haswell や Broadwell プロセッサファミリのように CPU に深刻なハードウェアバグが存在する場合、早期ロードが必須です。\n1. 遅延ロード (場合によっては危険) は、起動後にマイクロコードをアップデートします。CPU が欠陥のある命令の使用をすでに試みたかもしれないので、これでは遅すぎる可能性があります。「早期ロード」をすでに使用している場合でも、「遅延ロード」を使用して再起動せずに新しいマイクロコードのアップデートを適用できます。\n\n"
    },
    {
      "title": "早期ロード",
      "level": 3,
      "content": "マイクロコードは、カーネルに組み込まない場合、早期ローダ (early loader) によって読み込む必要があります。\n\n早期ローダは、マイクロコードのアップデートファイルが未圧縮 CPIO アーカイブ (initramfs イメージ) 内の /kernel/x86/microcode/GenuineIntel.bin または /kernel/x86/microcode/AuthenticAMD.bin として存在していることを期待します。\n\n早期 initramfs イメージ (マイクロコードのアップデートファイル) は、メインの initramfs イメージと合体して1つのファイルにし、(ブートローダーで initrd= カーネルコマンドラインオプションを使うか、ユニファイドカーネルイメージ内にパックして) 単一の initramfs ファイルとしてカーネルに渡すこともできますし、個別のファイルとして使用することもできます (この場合、initrd= カーネルコマンドラインオプションを複数回使用する必要があります)。いずれにせよ、マイクロコードを含んでいる未圧縮 CPIO アーカイブはメインの initramfs より前に配置しなければなりません。\n\n注意点として、ユーザーの初期ブート構成は多様なので、Arch のデフォルトの設定ではマイクロコードのアップデートは自動的にトリガーされません。\n\n"
    },
    {
      "title": "カスタムビルドされたカーネル",
      "level": 4,
      "content": "早期ローダーをカスタムカーネルで動作させるには、\"CPU microcode loading support\" を、モジュールとしてコンパイルせずに、カーネルに組み込む必要があります。これにより \"Early load microcode\" プロンプトが有効化され、これを Y に設定する必要があります。\n\n```\nCONFIG_BLK_DEV_INITRD=Y\nCONFIG_MICROCODE=y\nCONFIG_MICROCODE_INTEL=Y\nCONFIG_MICROCODE_AMD=y\n```\n\n"
    },
    {
      "title": "マイクロコード initramfs とメインの initramfs を1つのファイルに一緒にパックする",
      "level": 4,
      "content": "未圧縮のマイクロコード CPIO は initramfs の先頭に追加することが可能であり、単一の initramfs ファイルとして利用できるようになります。この方法は、追加のブートパラメータの設定が必要ないため、#別個のマイクロコード initramfs ファイルを使う の方法よりも推奨されます。\n\nmkinitcpio でマイクロコードを含んでいる initramfs ファイルを生成するには、/etc/mkinitcpio.conf の HOOKS 配列に microcode フックが含まれていることを確認してください。\n\nautodetect フックが microcode フックよりも前にある場合、現在使用している CPU のマイクロコードのみが追加されます。システム上に存在する全ての CPU マイクロコードファイルを追加するには、microcode フックを autodetect フックより前に移動するか、autodetect フックを削除してください。\n\nInitramfs の生成時に mkinitcpio は以下のようなメッセージを表示します:\n\n```\n-> Early uncompressed CPIO image generation successful\n```\n\nlsinitcpio(1) コマンドを使えば、マイクロコードのアップデートファイルが initramfs 内に存在していることを確認できます。例えば:\n\n```\n# lsinitcpio --early /boot/initramfs-linux.img | grep microcode\n```\n\n```\nkernel/x86/microcode/\nkernel/x86/microcode/AuthenticAMD.bin\n```\n\ndracut に関しては dracut.conf(5) § DESCRIPTION を見てください。\n\n"
    },
    {
      "title": "別個のマイクロコード initramfs ファイルを使う",
      "level": 4,
      "content": "先の方法を用いない場合、マイクロコードの早期アップデートは /boot/amd-ucode.img や /boot/intel-ucode.img をブートローダーの設定ファイルで最初の initrd として追加することで有効化する必要があります。マイクロコードの initrd は通常の initrd ファイルよりも前に来る必要があります。一般的なブートローダーにおける手順は以下を参照してください。\n\n以下の章では、cpu_manufacturer という記述はあなたの CPU の製造業者名 (つまり、amd か intel) に置き換えてください。\n\ngrub-mkconfig はマイクロコードのアップデートを自動的に検出し、GRUB を適切に設定します。マイクロコードのインストール後に以下を実行して GRUB 設定ファイルを再生成し、マイクロコードアップデートのロードを有効化してください:\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\nあるいは、GRUB 設定ファイルを手動で管理しているユーザは、以下のように /boot/cpu_manufacturer-ucode.img を追加できます(別のパーティションに /boot がある場合は /cpu_manufacturer-ucode.img):\n\n```\n/boot/grub/grub.cfg\n```\n\n```\n...\necho 'Loading initial ramdisk'\ninitrd\t/boot/cpu_manufacturer-ucode.img /boot/initramfs-linux.img\n...\n```\n\nそれぞれのメニュエントリに対してこれを行ってください。\n\n以下のように、マイクロコードを読み込むオプションを初期 RAM ディスクより前に使用してください:\n\n```\n/boot/loader/entries/entry.conf\n```\n\n```\ntitle   Arch Linux\nlinux   /vmlinuz-linux\ninitrd  /cpu_manufacturer-ucode.img\ninitrd  /initramfs-linux.img\n...\n```\n\n最新のマイクロコード cpu_manufacturer-ucode.img は起動時に EFI システムパーティション (ESP) に存在していなければなりません。amd-ucode または intel-ucode を更新したときはマイクロコードが更新されるように /boot に ESP をマウントしてください。もしくは、マイクロコードパッケージのアップデートがあるたびに ESP に /boot/cpu_manufacturer-ucode.img をコピーしてください。\n\n2つの initrd= オプションを末尾に追加してください:\n\n```\ninitrd=\\cpu_manufacturer-ucode.img initrd=\\initramfs-linux.img\n```\n\n/boot/refind_linux.conf のブートオプションを編集し、マイクロコードイメージをロードするための initrd= オプションを最初の initrd 引数として追加してください。/boot 内のファイルが別のパーティションの直下にあるかどうかに応じて、initrd=boot\\cpu_manufacturer-ucode.img か initrd=cpu_manufacturer-ucode.img のどちらかを使ってください。\n\nマイクロコードは、ブートオプションのリストの中で最初に宣言された initramfs でなければなりません。例えば:\n\n```\n\"Boot using default options\"  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\cpu_manufacturer-ucode.img initrd=boot\\initramfs-%v.img\"\n```\n\n手動で esp/EFI/refind/refind.conf にカーネルを定義している場合は、initrd= パラメータを追加して、ブートパーティション内の適切なパスに設定する必要があります。このパラメータは options 行の一部である必要があり、設定のメインの部分ではありません。例:\n\n```\noptions  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\cpu_manufacturer-ucode.img\"\n```\n\n/boot/syslinux/syslinux.cfg で複数の initrd をカンマで区切って指定できます:\n\n```\nLABEL arch\n    MENU LABEL Arch Linux\n    LINUX ../vmlinuz-linux\n    INITRD ../cpu_manufacturer-ucode.img,../initramfs-linux.img\n...\n```\n\nLILO は複数の初期 RAM ディスクイメージの読み込みをサポートしておらず、他の古いブートローダーも同じくサポートしていない可能性があります。代わりに #マイクロコード initramfs とメインの initramfs を1つのファイルに一緒にパックする で説明されている方法に従ってください。\n\nLimine においては、limine.conf ファイル内の MODULE_PATH オプションにマイクロコードへのパスを追加するだけで良いです。以下は例です:\n\n```\nlimine.conf\n```\n\n```\ndefault_entry: 1\ntimeout: 3\n\n/Arch\n    comment: Arch Linux\n\n    protocol: linux\n    kernel_path: boot():/vmlinuz-linux\n    kernel_cmdline: root=UUID=c0748521-eca9-4f38-989c-43811b6e39a1 rw loglevel=3\n    module_path: boot():/cpu_manufacturer-ucode.img\n    module_path: boot():/initramfs-linux.img\n```\n\n"
    },
    {
      "title": "遅延ロード",
      "level": 3,
      "content": "マイクロコードアップデートの遅延ロードは、システムが起動し終わった後に行われます。その時、/usr/lib/firmware/amd-ucode/ と /usr/lib/firmware/intel-ucode/ にあるファイルが使用されます。AMD CPU と Intel CPU のマイクロコードのアップデートファイルは、それぞれ amd-ucode と intel-ucode によって提供されています。\n\n遅延ロードを行うには、CONFIG_MICROCODE_LATE_LOADING=y でビルドされたカーネルが必要です。現時点では、Arch の公式サポートカーネルはこのフラグが有効化されていません。[2]\n\n"
    },
    {
      "title": "マイクロコードのアップデートの遅延ロード",
      "level": 4,
      "content": "実行中のシステムで手動でマイクロコードをアップデートするには (例: /usr/lib/firmware/amd-ucode/ か /usr/lib/firmware/intel-ucode/ 内のマイクロコードファイルをアップデートした後に):\n\n```\n# echo 1 > /sys/devices/system/cpu/microcode/reload\n```\n\nこれにより、システムを再起動せずに新しいマイクロコードのアップデートを適用できます。\n\n"
    },
    {
      "title": "起動時にマイクロコードのアップデートがされたか確認する",
      "level": 2,
      "content": "マイクロコードがアップデートされたかどうか確認するには journalctl でカーネルメッセージを確認してください:\n\n```\n# journalctl -k --grep='microcode:'\n```\n\nブート時に毎回以下のような出力がなされるはずです (以下ではマイクロコードが非常に早い段階でアップデートされていることを示しています):\n\n```\nkernel: microcode: Current revision: 0x00000012\nkernel: microcode: Updated early from: 0x0000000e\n```\n\n場合によっては (特に最新のハードウェアの場合)、対象 CPU に対するマイクロコードのアップデートが無い場合もあります。\n\nAMD システムで遅延ロードを使用すると、新しいマイクロコードが再読み込みされる前の古い方のバージョンが表示されます。\n\n"
    },
    {
      "title": "マイクロコードのアップデートができる CPU",
      "level": 2,
      "content": "特定のモデルがサポートされているのかどうかは以下のリンクから Intel のサイトや AMD の Gentoo Wiki サイトで確認することができます:\n\n- Gentoo:AMD microcode#Microcode firmware files。\n- Intel のダウンロードセンター。\n\n"
    },
    {
      "title": "マイクロコードのアップデートが必要かどうか確認する",
      "level": 3,
      "content": "Intel CPU の場合は、iucode_tool(8) コマンドを使うことで、現在使用中の CPU 向けのマイクロコードが /usr/lib/firmware/intel-ucode/ に含まれているかどうかを確認することができます。\n\n1. intel-ucode と iucode-tool をインストールしてください。\n1. cpuid カーネルモジュールをロード: # modprobe cpuid\n1. 該当する cpuid を検索: $ iucode_tool -lS /usr/lib/firmware/intel-ucode/\n1. アップデートが存在する場合は、selected microcodes の下に表示されます。\n1. メーカーの BIOS にマイクロコードが既に含まれていてロードされたことが dmesg に表示されていない可能性もあります。grep microcode /proc/cpuinfo を実行して現在のマイクロコードを比較してください。\n\n```\n# modprobe cpuid\n```\n\n```\n$ iucode_tool -lS /usr/lib/firmware/intel-ucode/\n```\n\nAMD CPU の場合、手動により確認することができます。\n\n1. CPU のファミリ、モデル、ステッピングを調べてください。例えば、# journalctl -k --grep='CPU0:' の出力を見ると (family: 0x15, model: 0x10, stepping: 0x1) といった部分があります。\n1. これらの値を amd-ucode README から見つけてください。\n1. 合うものが見つかったら、実行中のマイクロコードの現在のリビジョンと README に載っている Patch の値とを比べてください。\n\n```\n# journalctl -k --grep='CPU0:'\n```\n\n"
    },
    {
      "title": "マイクロコードローダーを無効化する",
      "level": 2,
      "content": "更新後の CPU マイクロコードが問題を引き起こす場合、一時的にマイクロコードローダーを無効化してブートできるようにし、パッケージをダウングレードする必要がある場合があります。カーネルのマイクロコードローダーを無効化するには、dis_ucode_ldr カーネルパラメータを指定してください。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Updating microcodes – Experiences in the community\n- Intel マイクロコードアップデートのノート – Ben Hawkes\n- カーネルマイクロコードローダ – カーネルドキュメント\n- Haswell/Broadwell で見つかったエラッタ – AnandTech\n- iucode-tool GitLab プロジェクト\n\n"
    }
  ]
}