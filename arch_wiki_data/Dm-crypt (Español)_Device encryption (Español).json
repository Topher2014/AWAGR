{
  "title": "Dm-crypt (Español)/Device encryption (Español)",
  "url": "https://wiki.archlinux.org/title/Dm-crypt_(Espa%C3%B1ol)/Device_encryption_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2019-09-18** \n\nEsta sección explica cómo utilizar manualmente dm-crypt desde la línea de órdenes para cifrar un sistema.\n\n"
    },
    {
      "title": "Preparación",
      "level": 2,
      "content": "Antes de usar cryptsetup, debe asegurarse de que el módulo del kernel dm_crypt esté cargado.\n\n"
    },
    {
      "title": "Utilización de cryptsetup",
      "level": 2,
      "content": "Cryptsetup es la herramienta de línea de órdenes para interactuar con dm-crypt, para crear, acceder y gestionar dispositivos cifrados. La herramienta se expandió posteriormente para admitir diferentes tipos de cifrado que dependen de los módulos del kernel de Linux device-mapper y cryptographic. La expansión más notable fue para la extensión de configuración de clave unificada de Linux («Linux Unified Key Setup» siglas en inglés LUKS), que almacena toda la información de configuración necesaria para dm-crypt en el propio disco y abstrae la partición y la gestión de claves en un intento por mejorar la facilidad de uso. Los dispositivos a los que se accede a través de device-mapper se denominan dispositivos de bloque. Para obtener más información, consulte Disk encryption (Español)#Cifrar dispositivos de bloques.\n\nLa herramienta se utiliza de la siguiente manera:\n\n```\n# cryptsetup <OPCIONES> <acción> <opciones-específicas-de-la-acción> <dispositivo> <nombre_dispositivo_mapeado>\n```\n\nCryptsetup tiene valores predeterminados en su compilación para las opciones y el modo de cifrado, que se utilizarán si no se especifican otros en la línea de órdenes. Mire esto:\n\n```\n$ cryptsetup --help\n```\n\nque enumera las opciones, las acciones y los parámetros predeterminados para los modos de cifrado en ese orden. Una lista completa de opciones se puede encontrar en la página del manual. Como los diferentes parámetros son obligatorios u opcionales, según el modo de encriptación y la acción, las siguientes secciones señalan las diferencias más destacadas. El cifrado de dispositivos de bloques es rápido, pero la velocidad también importa mucho. Debido a que es difícil cambiar el algoritmo de cifrado de un dispositivo de bloque después de la configuración, es importante verificar el rendimiento de dm-crypt para los parámetros individuales de antemano:\n\n```\n$ cryptsetup benchmark\n```\n\npuede proporcionar orientación sobre la decisión de un algoritmo de cifrado y un tamaño de clave antes de su instalación. Si ciertos cifrados AES sobresalen con un rendimiento considerablemente mayor, estos son probablemente los que tienen soporte de hardware en la CPU.\n\n"
    },
    {
      "title": "Contraseñas y claves de cryptsetup",
      "level": 3,
      "content": "Un dispositivo de bloque encriptado está protegido por una clave. Una clave es, o bien:\n\n- una frase de contraseña, ver Security (Español)#Contraseñas; o bien,\n- un archivo de claves, ver #Archivos de claves.\n\nAmbos tipos de clave tienen tamaños máximos predeterminados: las frases de contraseña (o simplemente, contraseña) pueden tener hasta 512 caracteres y los archivos de clave hasta 8192kiB.\n\nUna distinción importante de LUKS que se debe tener en cuenta en este punto es que la clave se utiliza para desbloquear la clave maestra de un dispositivo cifrado con LUKS y se puede cambiar con acceso de privilegios de root. Otros modos de cifrado no admiten el cambio de la clave después de la configuración, ya que no emplean una clave maestra para el cifrado. Consulte Disk encryption (Español)#Cifrar dispositivos de bloques para más detalles.\n\n"
    },
    {
      "title": "Opciones de cifrado con dm-crypt",
      "level": 2,
      "content": "Cryptsetup admite diferentes modos de operación de cifrado para usar con dm-crypt:\n\n- --type luks para usar la versión de formato LUKS predeterminada (LUKS1 con cryptsetup < 2.1.0, LUKS2 con cryptsetup ≥ 2.1.0),\n- --type luks1 para usar LUKS1, la versión más común de LUKS,\n- --type luks2 para usar LUKS2, la última versión disponible de LUKS que permite extensiones adicionales,\n- --type plain para usar el modo plain de dm-crypt,\n- --type loopaes, para un modo heredado de loopaes,\n- --type tcrypt, para un modo de compatibilidad con TrueCrypt.\n\nLas opciones criptográficas básicas para algoritmo de cifrado y funciones hash disponibles se pueden utilizar para todos las modalidades y se basan en las características del backend criptográfico del kernel. Todos los que se cargan en tiempo de ejecución y disponible para usar como opciones se pueden ver con:\n\n```\n$ less /proc/crypto\n```\n\nA continuación se presentan las opciones de cifrado para los modos luks, luks1, luks2 y plain. Tenga en cuenta que las tablas enumeran las opciones utilizadas en los ejemplos respectivos de este artículo y no todas las disponibles.\n\n"
    },
    {
      "title": "Opciones de cifrado para la modalidad LUKS",
      "level": 3,
      "content": "La acción cryptsetup para configurar un nuevo dispositivo dm-crypt en la modalidad de cifrado LUKS es luksFormat. El nombre es engañoso pues no formatea el dispositivo, pero configura el encabezado del dispositivo LUKS y cifra la clave maestra con las opciones criptográficas deseadas.\n\nComo LUKS es el modo de cifrado predeterminado, todo lo que necesita para crear un nuevo dispositivo LUKS con parámetros predeterminados (-v es opcional) es:\n\n```\n# cryptsetup -v luksFormat dispositivo\n```\n\nPara que sirva de comparación, podemos especificar las opciones predeterminadas manualmente también:\n\n```\n# cryptsetup -v --type luks --cipher aes-xts-plain64 --key-size 256 --hash sha256 --iter-time 2000 --use-urandom --verify-passphrase luksFormat dispositivo\n```\n\nLos valores predeterminados se comparan con un ejemplo de especificación criptográficamente superior en la tabla siguiente, que se acompañan de comentarios:\n\nTable content:\nOpciones | Cryptsetup 2.1.0 por defecto | Ejemplo | Comentario\n--cipher -c | aes-xts-plain64 | aes-xts-plain64 | Release 1.6.0 cambió los valores predeterminados a un algoritmo de cifrado AES en modo XTS (ver elemento 5.16 de FAQ). Se recomienda no utilizar el valor predeterminado anterior --cipher aes-cbc-essiv debido a su conocido problema y prácticos ataques contra ellos.\n--key-size -s | 256 (512 para XTS) | 512 | Por defecto, se utiliza un tamaño de clave de 512 bits para algoritmo de cifrado XTS. Sin embargo, tenga en cuenta que XTS divide la clave suministrada a la mitad, así que esto da como resultado el uso de AES-256.\n--hash -h | sha256 | sha512 | Algoritmo de hash utilizado para derivación de clave. La versión 1.7.0 cambió los valores predeterminados de sha1 a sha256 «no por razones de seguridad [sino] principalmente para evitar problemas de compatibilidad en sistemas endurecidos donde SHA1 ya está [siendo] eliminado»[1]. El antiguo valor predeterminado de sha1 todavía se puede utilizar para la compatibilidad con versiones anteriores de cryptsetup, ya que es considerado seguro (ver elemento 5.20).\n--iter-time -i | 2000 | 5000 | Número de milisegundos para gastar con el procesamiento de la frase de contraseña PBKDF2. La versión 1.7.0 cambió los valores predeterminados de 1000 a 2000 paraa «tratar de mantener el recuento de iteraciones PBKDF2 lo suficientemente alto y también aceptable para los usuarios.»[2]. Esta opción solo es relevante para las operaciones LUKS que establecen o cambien frases de contraseña, como luksFormat o luksAddKey. Al especificar 0 como parámetro, se selecciona el valor predeterminado compilado.\n--use-{u,}random | --use-urandom | --use-random | Selecciona qué generador de números aleatorios usar. Por citar la página del manual de cryptsetup: «En una situación de baja entropía (por ejemplo, en un sistema integrado), ambas selecciones son problemáticas. El uso de /dev/urandom puede dar lugar a claves débiles. El uso de /dev/random puede bloquear mucho tiempo, potencialmente para siempre, si no es suficiente la entropía puede ser cosechada por el kernel».\n--verify-passphrase -y | Sí | - | Por defecto solo para luksFormat y luksAddKey. No hay necesidad de escribir para Arch Linux con la modalidad LUKS en este momento.\n\n-c\n\n-s\n\n-h\n\n-i\n\n-y\n\nLas propiedades y características de LUKS se describen en la especificación de LUKS1 (pdf) y en las especificaciones de LUKS2 (pdf).\n\n"
    },
    {
      "title": "Opciones de cifrado para la modalidad plain",
      "level": 3,
      "content": "En la modalidad plain de dm-crypt, no hay una clave maestra en el dispositivo, por lo tanto, no es necesario configurarla. En su lugar, las opciones de cifrado que se emplearán se utilizan directamente para crear la asignación entre un disco cifrado y un dispositivo con nombre. El mapeado se puede crear frente a una partición o a un dispositivo completo. En este último caso, ni siquiera se necesita una tabla de particiones.\n\nPara crear una mapeado de modo plain con los parámetros predeterminados de cryptsetup:\n\n```\n# cryptsetup <opciones> open --type plain <dispositivo> <nombre-dispositivo-mapeado>\n```\n\nAl ejecutarlo se le pedirá una contraseña, que debería tener una entropía muy alta. A continuación, se muestra la comparación de los parámetros predeterminados con el ejemplo en dm-crypt/Encrypting an entire system (Español)#Modalidad plain de dm-crypt\n\nTable content:\nOpción | Cryptsetup 2.1.0 por defecto | Ejemplo | Comentario\n--hash -h | ripemd160 | - | El hash se utiliza para crear la clave desde la frase de contraseña; no se utiliza en un archivo de claves.\n--cipher -c | aes-cbc-essiv:sha256 | aes-xts-plain64 | El cifrado consta de tres partes: generador cipher-chainmode-IV (vector de inicialización). Consulte Disk encryption (Español)#Algoritmos de cifrado y modalidades de operación para obtener una explicación de esta configuración, y la DMCrypt documentación para algunas de las opciones disponibles.\n--key-size -s | 256 | 512 | El tamaño de la clave (en bits). El tamaño dependerá del algoritmo que se use y también del modo de cadena (chainmode) en uso. El modo Xts requiere el doble del tamaño que la clave de cbc.\n--size -b | tamaño real del disco de destino | 2048 (el dispositivo mapeado será de 512B×2048=1MiB) | Limite del tamaño máximo del dispositivo (en sectores de 512 bytes).\n--offset -o | 0 | 0 | El desplazamiento desde el principio del disco de destino (en sectores de 512 bytes) a partir del cual se inicia el mapeado\n--skip -p | 0 | 2048 (512B×2048=1MiB se saltará) | El número de sectores de datos cifrados de 512 bytes que se omiten al principio.\n--key-file -d | por defecto utiliza una frase de contraseña | /dev/sdZ (o, por ejemplo, /boot/keyfile.enc) | El dispositivo o archivo que se utilizará como clave. Consulte #Archivos de claves para más detalles.\n--keyfile-offset | 0 | 0 | Desplazamiento desde el principio del archivo donde se inicia la clave (en bytes). Esta opción es compatible desde cryptsetup 1.6.7 en adelante.\n--keyfile-size -l | 8192kB | - (se aplica por defecto) | Limita los bytes leídos del archivo clave. Esta opción es compatible desde cryptsetup 1.6.7 en adelante.\n\n-h\n\n-c\n\n-s\n\n-b\n\n-o\n\n-p\n\n-d\n\n-l\n\nUtilizando el dispositivo /dev/sdX, la columna de ejemplo de arriba daría como resultado:\n\n```\n# cryptsetup --cipher=aes-xts-plain64 --offset=0 --key-file=/dev/sdZ --key-size=512 open --type=plain /dev/sdX enc\n```\n\nA diferencia del cifrado con LUKS, la orden anterior debe ejecutarse en su totalidad siempre que el mapeado deba restablecerse, por lo que es importante recordar los datos de cifrado, el hash y el archivo claves. Ahora podemos comprobar que el mapeo se ha realizado:\n\n```\n# fdisk -l\n```\n\nDebería existir una entrada para /dev/mapper/enc.\n\n"
    },
    {
      "title": "Cifrar dispositivos con cryptsetup",
      "level": 2,
      "content": "Esta sección muestra cómo emplear las opciones para crear nuevos dispositivos de bloques encriptados y acceder a ellos manualmente.\n\n"
    },
    {
      "title": "Formatear particiones LUKS",
      "level": 4,
      "content": "Para configurar una partición como una partición cifrada con LUKS, ejecute:\n\n```\n# cryptsetup luksFormat dispositivo\n```\n\nA continuación, se le solicitará que ingrese una contraseña y la verifique.\n\nConsulte #Opciones de cifrado para la modalidad LUKS para ver las opciones de la línea de órdenes.\n\nPuede consultar los resultados con:\n\n```\n# cryptsetup luksDump dispositivo\n```\n\nNotará que el volcado no solo muestra la información del algoritmo de cifrado del encabezado, sino también las ranuras de claves en uso para la partición LUKS.\n\nEl siguiente ejemplo creará una partición raíz cifrada en /dev/sda1 utilizando el algoritmo de cifrado AES predeterminado en modo XTS con un cifrado efectivo de 256 bits:\n\n```\n# cryptsetup -s 512 luksFormat /dev/sda1\n```\n\nAl crear una nueva partición encriptada con LUKS, se puede asociar un archivo de claves con la partición al crearla, ejecutando:\n\n```\n# cryptsetup luksFormat dispositivo /ruta/a/archivo_de_claves\n```\n\nConsulte #Archivos de claves para obtener instrucciones sobre cómo generar y gestionar archivos de claves.\n\n"
    },
    {
      "title": "Desbloquear/mapear particiones LUKS con el mapeador de dispositivos",
      "level": 4,
      "content": "Una vez que se han creado las particiones LUKS, se pueden desbloquear.\n\nEl proceso de desbloqueo asignará a las particiones un nuevo nombre de dispositivo utilizando el mapeador de dispositivos («device mapper»). Esto alerta al kernel de que el dispositivo es, en realidad, un dispositivo cifrado y debe redireccionarlo a través de LUKS utilizando /dev/mapper/nombre_dispositivo_mapeado para no sobrescribir los datos encriptados. Para protegerse contra la sobrescritura accidental, lea acerca de las posibilidades para realizar una copia de seguridad del encabezado cifrado después de finalizar la configuración.\n\nPara abrir una partición cifrada con LUKS ejecute:\n\n```\n# cryptsetup open dispositivo nombre_dispositivo_mapeado\n```\n\nA continuación, se le solicitará la contraseña para desbloquear la partición. Por lo general, el nombre del dispositivo mapeado es descriptivo de la función de la partición que se le asigna. Por ejemplo, la siguiente orden desbloquea una partición /dev/sda1 cifrada con luks y le asignamos un dispositivo mapeado llamado cryptroot:\n\n```\n# cryptsetup open /dev/sda1 cryptroot\n```\n\nUna vez abierta, la dirección del dispositivo de la partición raíz será /dev/mapper/cryptroot, en lugar de la partición en sí (por ejemplo, /dev/sda1).\n\nPara configurar LVM sobre la capa de cifrado, el dispositivo para el grupo de volúmenes descifrados sería algo como /dev/mapper/cryptroot, en lugar de /dev/sda1. LVM le dará nombres adicionales a todos los volúmenes lógicos creados, por ejemplo, /dev/lvmpool/root y /dev/lvmpool/swap.\n\nPara escribir datos encriptados en la partición se debe acceder a través del nombre mapeado del dispositivo. El primer paso de acceso generalmente será crear un sistema de archivos. Por ejemplo:\n\n```\n# mkfs -t ext4 /dev/mapper/cryptroot\n```\n\nEl dispositivo /dev/mapper/cryptroot puede ser montado como cualquier otra partición.\n\nPara cerrar el contenedor luks, desmonte la partición y escriba:\n\n```\n# cryptsetup close cryptroot\n```\n\n"
    },
    {
      "title": "Cifrar dispositivos con la modalidad plain",
      "level": 3,
      "content": "La creación y el acceso subsiguiente de un cifrado en modo plain de dm-crypt no requieren más que usar la acción cryptsetup open con los parámetros correctos. Lo siguiente muestra dos ejemplos de dispositivos que no son raíz, pero agrega una peculiaridad al apilar ambos (es decir, el segundo se crea dentro del primero). Obviamente, apilar el cifrado duplica la sobrecarga. El caso usado aquí es simplemente para ilustrar otro ejemplo de la utilzación de la opción del algoritmo de cifrado.\n\nSe crea un primer mapeado con los valores predeterminados del modo plain de cryptsetup, como se describe en la columna izquierda de la tabla de arriba\n\n```\n# cryptsetup --type plain -v open /dev/sdaX plain1\n```\n\n```\nEnter passphrase:\nCommand successful.\n```\n\nAhora agregamos el segundo dispositivo de bloque en su interior, utilizando diferentes parámetros de cifrado y con un desplazamiento —offset— (opcional), creamos un sistema de archivos y lo montamos:\n\n```\n# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10  open /dev/mapper/plain1 plain2\n```\n\n```\nEnter passphrase:\n```\n\n```\n# lsblk -p\n```\n\n```\nNAME\n /dev/sda\n ├─/dev/sdaX\n │ └─/dev/mapper/plain1\n │   └─/dev/mapper/plain2\n ...\n```\n\n```\n# mkfs -t ext2 /dev/mapper/plain2\n# mount -t ext2 /dev/mapper/plain2 /mnt\n# echo \"This is stacked. one passphrase per foot to shoot.\" > /mnt/stacked.txt\n```\n\nCerramos la pila para comprobar que funciona el acceso:\n\n```\n# cryptsetup close plain2\n# cryptsetup close plain1\n```\n\nPrimero, intentemos abrir el sistema de archivos directamente:\n\n```\n# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/sdaX plain2\n```\n\n```\n# mount -t ext2 /dev/mapper/plain2 /mnt\n```\n\n```\nmount: wrong fs type, bad option, bad superblock on /dev/mapper/plain2,\n      missing codepage or helper program, or other error\n```\n\n¿Por qué no ha funcionado? Porque el bloque de inicio de «plain2» (10) todavía está cifrado con el algoritmo de cifrado de «plain1». Solo se puede acceder a través del mapeador apilado. El error es arbitrario, sin embargo, daría el mismo resultado si probráramos con una contraseña incorrecta o con las opciones de cifrado incorrectas. Para la modalidad plain de dm-crypt, la acción open no generará errores.\n\nIntentémoslo de nuevo en el orden correcto:\n\n```\n# cryptsetup close plain2 # mapeador disfuncional del intento anterior\n```\n\n```\n# cryptsetup --type plain open /dev/sdaX plain1\n```\n\n```\nEnter passphrase:\n```\n\n```\n# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/mapper/plain1 plain2\n```\n\n```\nEnter passphrase:\n```\n\n```\n# mount /dev/mapper/plain2 /mnt && cat /mnt/stacked.txt\n```\n\n```\nThis is stacked. one passphrase per foot to shoot.\n```\n\ndm-crypt también manejará el cifrado apilado con algunos modos mixtos. Por ejemplo, el modo LUKS podría apilarse sobre el mapeador «plain1». Su encabezado se cifraría dentro de «plain1» cuando se cierra.\n\nDisponible solo para la modalidad plain está la opción --shared. Con ella, un solo dispositivo se puede segmentar en diferentes mapeadores no superpuestos. Lo hacemos en el siguiente ejemplo, usando un modo de algoritmo de cifrado compatible con loopaes, para «plain2» esta vez:\n\n```\n# cryptsetup --type plain --offset 0 --size 1000 open /dev/sdaX plain1\n```\n\n```\nEnter passphrase:\n```\n\n```\n# cryptsetup --type plain --offset 1000 --size 1000 --shared --cipher=aes-cbc-lmk --hash=sha256 open /dev/sdaX plain2\n```\n\n```\nEnter passphrase:\n```\n\n```\n# lsblk -p\n```\n\n```\nNAME\ndev/sdaX\n├─/dev/sdaX\n│ ├─/dev/mapper/plain1\n│ └─/dev/mapper/plain2\n...\n```\n\nComo muestra el árbol del dispositivo, ambos dispositivos mapeados residen en el mismo nivel, es decir, no están apilados y «plain2» se puede abrir individualmente.\n\n"
    },
    {
      "title": "Gestión de claves",
      "level": 3,
      "content": "Es posible definir hasta 8 claves diferentes por partición LUKS. Esto permite al usuario crear claves de acceso para guardar una copia de respaldo: es lo que llamamos custodia de clave, una clave se usa para el uso diario, otra se mantiene en custodia para obtener acceso a la partición en caso de que se olvide la frase de contraseña diaria o o se pierda/dañe un archivo de claves. También se podría usar una ranura de claves diferente para otorgar acceso a una partición a un usuario emitiéndole una segunda clave y luego revocándosela.\n\nUna vez que se ha creado una partición cifrada, se crea con ella la ranura de claves inicial 0 (si no se ha especificado ninguna otra forma manual). Las ranuras de claves adicionales están numeradas del 1 al 7. Las ranuras de claves utilizadas se pueden ver emitiendo:\n\n```\n# cryptsetup luksDump /dev/<dispositivo> | grep BLED\n```\n\n```\nKey Slot 0: ENABLED\nKey Slot 1: ENABLED\nKey Slot 2: ENABLED\nKey Slot 3: DISABLED\nKey Slot 4: DISABLED\nKey Slot 5: DISABLED\nKey Slot 6: DISABLED\nKey Slot 7: DISABLED\n```\n\nDonde <dispositivo> es el volumen que contiene el encabezado LUKS. Esta y las demás órdenes en esta sección también funcionan en los archivos de respaldo del encabezado.\n\n"
    },
    {
      "title": "Añadir claves LUKS",
      "level": 4,
      "content": "Agregar nuevas ranuras de claves («keylot») se logra usando cryptsetup con la acción luksAddKey. Por razones de seguridad, se solicitará siempre una clave válida existente («any passphrase») antes de que se pueda ingresar otra nueva, lo cual es aplicable también para dispositivos ya desbloqueados:\n\n```\n# cryptsetup luksAddKey /dev/<dispositivo> (/ruta/a/<archivo_de_claves_adicional>)\n```\n\n```\nEnter any passphrase:\nEnter new passphrase for key slot:\nVerify passphrase:\n```\n\nSi se proporciona la /ruta/al/<archivo_de_claves_adicional>, cryptsetup agregará una nueva ranura de claves para el <archivo_de_claves_adicional>. De lo contrario, se le pedirá una nueva frase de contraseña dos veces. Para usar un archivo de claves existente que autorice la acción, la opción --key-file o -d seguida de la opción «antiguo» <archivo_de_claves> intentará desbloquear todas las ranuras de archivos de claves disponibles:\n\n```\n# cryptsetup luksAddKey /dev/<dispositivo> (/ruta/a/<archivo_de_claves_adicional>) -d /ruta/a/<archivo_de_claves>\n```\n\nSi está decidido a usar varias claves y cambiarlas o revocarlas después, la opción --key-slot o -S se puede usar para especificar la ranura en cuestión:\n\n```\n# cryptsetup luksAddKey /dev/<dispositivo> -S 6\n```\n\n```\nEnter any passphrase:\nEnter new passphrase for key slot:\nVerify passphrase:\n```\n\n```\n# cryptsetup luksDump /dev/sda8 | grep 'Slot 6'\n```\n\n```\nKey Slot 6: ENABLED\n```\n\nPara mostrar una acción asociada en este ejemplo, decidimos cambiar la clave de inmediato:\n\n```\n# cryptsetup luksChangeKey /dev/<dispositivo> -S 6\n```\n\n```\nEnter LUKS passphrase to be changed:\nEnter new LUKS passphrase:\n```\n\nAntes de continuar retirándolo.\n\n"
    },
    {
      "title": "Eliminar claves LUKS",
      "level": 4,
      "content": "Hay tres acciones diferentes para eliminar claves del encabezado:\n\n- luksRemoveKey se usa para eliminar una clave al especificar su contraseña/archivo de claves.\n- luksKillSlot puede usarse para eliminar una clave de una ranura de clave específica (usando otra clave). Obviamente, esto es extremadamente útil si ha olvidado una frase de contraseña, perdió un archivo de claves o no tiene acceso a él.\n- luksErase se usa para eliminar rápidamente todas las claves activas.\n\nNote: **no** \n\n- ¡Todas las acciones anteriores se pueden usar para eliminar irrevocablemente la última clave activa para un dispositivo cifrado!\n- La orden luksErase se agregó en la versión 1.6.4 para acceder rápidamente al dispositivo. ¡Esta acción no pedirá una frase de contraseña válida! No limpia el encabezado de LUKS, sino todos los conjuntos de claves de una vez y, por lo tanto, no podrá recuperar el acceso a menos que tenga una copia de seguridad válida del encabezado de LUKS .\n\nPara la advertencia anterior, es bueno saber que la clave que queremos mantener es válida. Una comprobación fácil es desbloquear el dispositivo con la opción -v, que especificará qué ranura ocupa:\n\n```\n# cryptsetup -v open /dev/<dispositivo> testcrypt\n```\n\n```\nEnter passphrase for /dev/<dispositivo>:\nKey slot 1 unlocked.\nCommand successful.\n```\n\nAhora podemos eliminar la clave agregada en la subsección anterior usando su frase de contraseña:\n\n```\n# cryptsetup luksRemoveKey /dev/<dispositivo>\n```\n\n```\nEnter LUKS passphrase to be deleted:\n```\n\nSi hubiéramos usado la misma frase de contraseña para dos ranuras de claves, la primera ranura se borraría ahora. Solo ejecutándolo de nuevo eliminaría la segunda.\n\nAlternativamente, podemos especificar la ranura de la clave:\n\n```\n# cryptsetup luksKillSlot /dev/<dispositivo> 6\n```\n\n```\nIngrese cualquier frase de contraseña LUKS restante:\n```\n\nTenga en cuenta que en ambos casos, no se requerirá confirmación.\n\n```\n# cryptsetup luksKillSlot /dev/<dispositivo> 6\n```\n\n```\nEnter any remaining LUKS passphrase:\n```\n\nPara repetir la advertencia anterior: si se hubiera utilizado la misma frase de contraseña para las ranuras de claves 1 y 6, ambas se habrían eliminado.\n\n"
    },
    {
      "title": "Copia de seguridad y restauración",
      "level": 3,
      "content": "Si el encabezado de una partición encriptada con LUKS se destruye, no podrá descifrar sus datos. Es un dilema tan grande como olvidar la frase de contraseña o dañar un archivo de claves utilizado para desbloquear la partición. Puede dañarse por un fallo propio al volver a particionar el disco posteriormente o por programas de terceros que malinterpretan la tabla de particiones. Por lo tanto, tener una copia de seguridad del encabezado y almacenarlo en otro disco puede ser una buena idea.\n\n"
    },
    {
      "title": "Realizar copia de seguridad utilizando cryptsetup",
      "level": 4,
      "content": "La acción luksHeaderBackup de Cryptsetup almacena una copia de seguridad binaria de la cabecera LUKS y del área de ranuras de claves:\n\n```\n# cryptsetup luksHeaderBackup /dev/<dispositivo> --header-backup-file /mnt/<backup>/<file>.img\n```\n\ndonde <dispositivo> es la partición que contiene el volumen LUKS.\n\n```\n# mkdir /root/<tmp>/\n# mount ramfs /root/<tmp>/ -t ramfs\n# cryptsetup luksHeaderBackup /dev/<dispositivo> --header-backup-file /root/<tmp>/<file>.img\n# gpg2 --recipient <User ID> --encrypt /root/<tmp>/<file>.img\n# cp /root/<tmp>/<file>.img.gpg /mnt/<backup>/\n# umount /root/<tmp>\n```\n\n"
    },
    {
      "title": "Restaurar utilizando cryptsetup",
      "level": 4,
      "content": "Con el fin de evitar la restauración de un encabezado incorrecto, puede asegurarse de que funciona si lo usa primero como un --header remoto:\n\n```\n# cryptsetup -v --header /mnt/<backup>/<file>.img open /dev/<dispositivo> test\n```\n\n```\nKey slot 0 unlocked.\nCommand successful.\n```\n\n```\n# mount /dev/mapper/test /mnt/test && ls /mnt/test\n# umount /mnt/test\n# cryptsetup close test\n```\n\nAhora que la comprobación se realizó correctamente, la restauración se puede realizar:\n\n```\n# cryptsetup luksHeaderRestore /dev/<dispositivo> --header-backup-file ./mnt/<backup>/<file>.img\n```\n\nAhora que todas las áreas de las ranuras de claves están sobrescritas; solo las ranuras de claves activas del archivo de respaldo estarán disponibles después de emitir la orden.\n\n"
    },
    {
      "title": "Copia de seguridad y restauración manuales",
      "level": 4,
      "content": "El encabezado siempre reside al comienzo del dispositivo y también se puede realizar una copia de seguridad sin acceso a cryptsetup. Primero tiene que averiguar el desplazamiento («offset») de la carga útil de la partición encriptada:\n\n```\n# cryptsetup luksDump /dev/<dispositivo> | grep \"Payload offset\"\n```\n\n```\nPayload offset:\t4040\n```\n\nSegundo, controle el tamaño del sector de la unidad:\n\n```\n# fdisk -l /dev/<dispositivo> | grep \"Sector size\"\n```\n\n```\nSector size (logical/physical): 512 bytes / 512 bytes\n```\n\nAhora que conoce los valores, puede hacer una copia de seguridad del encabezado con una simple orden dd:\n\n```\n# dd if=/dev/<dispositivo> of=/ruta/a/<archivo>.img bs=512 count=4040\n```\n\ny almacenarlo de forma segura.\n\nLuego, se puede realizar una restauración utilizando los mismos valores que los usados cuando se realizó la copia de seguridad:\n\n```\n# dd if=./<archivo>.img of=/dev/<dispositivo> bs=512 count=4040\n```\n\n"
    },
    {
      "title": "Volver a cifrar dispositivos",
      "level": 3,
      "content": "El paquete cryptsetup contiene la herramienta cryptsetup-reencrypt. Se puede usar para convertir un sistema de archivos sin cifrar existente a uno LUKS cifrado (opción --new) y eliminar permanentemente el cifrado LUKS (--decrypt) de un dispositivo. Como su nombre sugiere, también se puede usar para volver a cifrar un dispositivo cifrado con LUKS existente, sin embargo, no es posible volver a cifrarlo para un encabezado LUKS separado u otras modalidades de cifrado (por ejemplo, modo plain). Para volver a cifrar es posible cambiar las #Opciones de cifrado para la modalidad LUKS. Las acciones cryptsetup-reencrypt solo se pueden realizar en dispositivos sin montar. Consulte cryptsetup-reencrypt(8) para obtener más información.\n\nUna aplicación del recifrado puede ser asegurar los datos nuevamente después de que una frase de contraseña o #Archivos de claves hayan sido comprometidos y no se puede estar seguro de que no se haya obtenido una copia del encabezado LUKS. Por ejemplo, si solo se ha utilizado el sistema cifrado por una frase de contraseña pero no se ha tenido acceso físico/lógico al dispositivo, sería suficiente cambiar solo la frase de contraseña/clave respectiva (#Gestión de claves.\n\nNote: **copia de seguridad fiable** \n\nA continuación se muestra un ejemplo para cifrar una partición del sistema de archivos sin cifrar, así como un nuevo cifrado de un dispositivo cifrado con LUKS existente.\n\n"
    },
    {
      "title": "Cifrar un sistema de archivos no cifrado",
      "level": 4,
      "content": "Un encabezado de cifrado LUKS siempre se almacena al principio del dispositivo. Como a un sistema de archivos existente generalmente se le asignarán todos los sectores de partición, el primer paso es reducirlo para hacer espacio para el encabezado LUKS.\n\nLas algoritmos de cifrado predeterminado para cifrar LUKS requieren 4096 sectores de 512 bytes. Verificamos el espacio y lo mantenemos simple al reducir el sistema de archivos ext4 existente en /dev/sdaX a su mínimo actual posible:\n\n```\n# umount /mnt\n```\n\n```\n# e2fsck -f /dev/sdaX\n```\n\n```\ne2fsck 1.43-WIP (18-May-2015)\nPass 1: Checking inodes, blocks, and sizes\n...\n/dev/sda6: 12/166320 files (0.0% non-contiguous), 28783/665062 blocks\n```\n\n```\n# resize2fs -M /dev/sdaX\n```\n\n```\nresize2fs 1.43-WIP (18-May-2015)\nResizing the filesystem on /dev/sdaX to 26347 (4k) blocks.\nThe filesystem on /dev/sdaX is now 26347 (4k) blocks long.\n```\n\nAhora lo ciframos, utilizando el algoritmo de cifrado predeterminado, el cual no tenemos que especificarlo explícitamente.\n\n```\n# cryptsetup-reencrypt /dev/sdaX --new  --reduce-device-size 4096S\n```\n\n```\nEnter new passphrase:\nVerify passphrase:\nFinished, time 00:05.126,  952 MiB written, speed 185,7 MiB/s\n```\n\nUna vez finalizado, el cifrado se habrá realizado en la partición completa, es decir, no solo el espacio al que se redujo el sistema de archivos (sdaX tiene 2.6GiB y la CPU utilizada en el ejemplo no tiene instrucciones AES de hardware). Como paso final, extendemos nuevamente el sistema de archivos del dispositivo ahora encriptado para que ocupe el espacio disponible:\n\n```\n# cryptsetup open /dev/sdaX recrypt\n```\n\n```\nEnter passphrase for /dev/sdaX:\n...\n```\n\n```\n# resize2fs /dev/mapper/recrypt\n```\n\n```\nresize2fs 1.43-WIP (18-May-2015)\nResizing the filesystem on /dev/mapper/recrypt to 664807 (4k) blocks.\nThe filesystem on /dev/mapper/recrypt is now 664807 (4k) blocks long.\n```\n\n```\n# mount /dev/mapper/recrypt /mnt\n```\n\ny ya estará hecho.\n\n"
    },
    {
      "title": "Recifrar una partición LUKS existente",
      "level": 4,
      "content": "En este ejemplo, se vuelve a cifrar un dispositivo LUKS existente.\n\nNote: **copia de seguridad fiable** \n\nPara volver a cifrar un dispositivo con sus opciones de cifrado existentes, no es necesario especificarlas. Un simple:\n\n```\n# cryptsetup-reencrypt /dev/sdaX\n```\n\n```\nEnter passphrase for key slot 0:\nProgress: 100,0%, ETA 00:00, 2596 MiB written, speed  36,5 MiB/s\n```\n\nlo realiza.\n\nUn posible caso de uso es volver a cifrar los dispositivos LUKS que tienen opciones de cifrado no actuales. Además de la advertencia anterior sobre la especificación de las opciones correctamente, la capacidad de cambiar el encabezado LUKS también puede verse limitada por su tamaño. Por ejemplo, si el dispositivo se cifró inicialmente utilizando un algoritmo de cifrado del modo CBC y un tamaño de clave de 128 bits, el encabezado LUKS tendrá la mitad del tamaño de los 4096 sectores mencionados anteriormente:\n\n```\n# cryptsetup luksDump /dev/sdaX |grep -e \"mode\" -e \"Payload\" -e \"MK bits\"\n```\n\n```\nCipher mode:   \tcbc-essiv:sha256\nPayload offset:\t2048\nMK bits:       \t128\n```\n\nSi bien es posible actualizar el cifrado de un dispositivo de este tipo, actualmente solo es posible en dos pasos. Primero, vuelva a encriptar con las mismas opciones de encriptación, pero use la opción --reduce-device-size para hacer el espacio del encabezado LUKS más grande. En segundo lugar, vuelva a cifrar todo el dispositivo con el cifrado deseado. Por este motivo y por el hecho de que se debe crear una copia de seguridad en cualquier caso, la creación de un nuevo dispositivo cifrado para restaurar es siempre la opción más rápida.\n\n"
    },
    {
      "title": "Cambiar el tamaño de dispositivos cifrados",
      "level": 2,
      "content": "Si un dispositivo de almacenamiento cifrado con dm-crypt se clona (con una herramienta como dd) a otro dispositivo más grande, el dispositivo dm-crypt subyacente debe redimensionarse para usar todo el espacio.\n\nEl dispositivo de destino es /dev/sdX2 en este ejemplo, se utilizará todo el espacio disponible adyacente a la partición:\n\n```\n# cryptsetup luksOpen /dev/sdX2 sdX2\n# cryptsetup resize sdX2\n```\n\nEntonces el sistema de archivos subyacente debe ser redimensionado.\n\n"
    },
    {
      "title": "Sistema de archivos de loopback",
      "level": 3,
      "content": "Suponga que un sistema de archivos loopback cifrado está almacenado en un archivo /bigsecret, vinculado a /dev/loop0, mapeado a secret y montado en /mnt/secret, como en el ejemplo en dm-crypt (Español)/Encrypting a non-root file system (Español)#Dispositivo loop.\n\nSi el archivo contenedor está actualmente mapeado y/o montado, desmóntelo y/o ciérrelo:\n\n```\n# umount /mnt/secret\n# cryptsetup close secret\n# losetup -d /dev/loop0\n```\n\nA continuación, expanda el archivo contenedor con el tamaño de los datos que desea agregar. En este ejemplo, el archivo se expandirá con 1M * 1024, que es 1G.\n\nNote: **dos** \n\n```\n# dd if=/dev/urandom bs=1M count=1024 | cat - >> /bigsecret\n```\n\nAhora mapee el contenedor al dispositivo de loop:\n\n```\n# losetup /dev/loop0 /bigsecret\n# cryptsetup open /dev/loop0 secret\n```\n\nDespués de esto, cambie el tamaño de la parte cifrada del contenedor al nuevo tamaño máximo del archivo contenedor:\n\n```\n# cryptsetup resize secret\n```\n\nFinalmente, realice una comprobación del sistema de archivos y, si está bien, cambie su tamaño (ejemplo para ext2/3/4):\n\n```\n# e2fsck -f /dev/mapper/secret\n# resize2fs /dev/mapper/secret\n```\n\nAhora puede montar el contenedor de nuevo:\n\n```\n# mount /dev/mapper/secret /mnt/secret\n```\n\n"
    },
    {
      "title": "Archivos de claves",
      "level": 2,
      "content": "¿Qué es un archivo de claves?\n\nUn archivo de claves es un archivo cuyos datos se utilizan como frase de contraseña para desbloquear un volumen cifrado. Eso significa que si un archivo de este tipo se pierde o se modifica, ya no será posible descifrar el volumen.\n\n¿Por qué usar un archivo de claves?\n\nHay muchos tipos de archivos de claves. Cada tipo de archivo de claves utilizado tiene ventajas y desventajas que se resumen a continuación:\n\n"
    },
    {
      "title": "Frase de contraseña",
      "level": 4,
      "content": "Este es un archivo de claves que contiene una frase de contraseña simple. El beneficio de este tipo de archivo de claves es que si se pierde el archivo, los datos que contiene son conocidos y, con suerte, recordados fácilmente por el propietario del volumen cifrado. Sin embargo, la desventaja es que esto no agrega ninguna seguridad al ingresar una frase de contraseña durante la fase inicial del sistema.\n\nEjemplo: 1234\n\n```\n# echo -n 'your_passphrase' > /ruta/a/<archivo_de_claves>\n# chown root:root /ruta/a/<archivo_de_claves>; chmod 400 /ruta/a/<archivo_de_claves>\n```\n\n"
    },
    {
      "title": "Texto aleatorio",
      "level": 4,
      "content": "Este es un archivo de claves que contiene un bloque de caracteres aleatorios. La ventaja de este tipo de archivo de claves es que es mucho más resistente a los ataques de diccionario que una simple frase de contraseña. Se puede utilizar una fuerza adicional de archivos de claves en esta situación, que es la longitud de los datos utilizados. Dado que no se trata de una cadena que debe memorizar una persona para su entrada, es intrascendente crear archivos que contengan miles de caracteres aleatorios como clave. La desventaja es que si este archivo se pierde o cambia, lo más probable es que no sea posible acceder al volumen cifrado sin una frase de contraseña de respaldo.\n\nEjemplo: fjqweifj830149-57 819y4my1-38t1934yt8-91m 34co3;t8y;9p3y-\n\n"
    },
    {
      "title": "Binario",
      "level": 4,
      "content": "Este es un archivo binario que se ha definido como un archivo de claves. Al identificar archivos como candidatos para un archivo de claves, se recomienda elegir archivos que sean relativamente estáticos, como fotos, música, videoclips. La ventaja de estos archivos es que cumplen una doble función que puede dificultar su identificación como archivos de claves. En lugar de tener un archivo de texto con una gran cantidad de texto aleatorio, el archivo de claves se verá como un archivo de imagen normal o un clip de música para el observador casual. La desventaja es que si este archivo se pierde o cambia, lo más probable es que no sea posible acceder al volumen cifrado sin una frase de contraseña de respaldo. Además, existe una pérdida teórica de aleatoriedad en comparación con un archivo de texto generado aleatoriamente. Esto se debe al hecho de que las imágenes, los videos y la música tienen alguna relación intrínseca entre los bits de datos vecinos que no existe para un archivo de texto aleaotorio. Sin embargo, esto es controvertido y nunca ha sido explotado públicamente.\n\nEjemplo: imágenes, texto, video, ...\n\n"
    },
    {
      "title": "Almacenar el archivo de claves en un sistema de archivos",
      "level": 4,
      "content": "Un archivo de claves puede ser de contenido y tamaño arbitrario.\n\nAquí dd se utiliza para generar un archivo de claves de 2048 bytes aleatorios, almacenándolo en el archivo /etc/mi_archivo_de_claves:\n\n```\n# dd bs=512 count=4 if=/dev/random of=/etc/mi_archivo_de_claves iflag=fullblock\n```\n\nSi planea almacenar el archivo de claves en un dispositivo externo, también puede simplemente cambiar el archivo de salida al directorio correspondiente:\n\n```\n# dd bs=512 count=4 if=/dev/random of=/media/usbstick/mi_archivo_de_claves iflag=fullblock\n```\n\nPara denegar cualquier acceso para otros usuarios, entonces limítelo a root:\n\n```\n# chmod 600 /etc/mi_archivo_de_claves\n```\n\nSi almacenó su archivo de claves temporalmente en un dispositivo de almacenamiento físico y desea eliminarlo, recuerde no solo eliminar el archivo de claves sin más, sino usar algo como:\n\n```\n# shred --remove --zero mi_archivo_de_claves\n```\n\npara sobrescribirlo de forma segura. Para sistemas de archivos tradicionales como FAT o ext2, esto será suficiente, mientras que en el caso de sistemas de archivos con registro por diario, hardware de memoria flash y otros casos, se recomienda encarecidamente limpiar todo el dispositivo.\n\n"
    },
    {
      "title": "Almacenar el archivo de claves en ramfs",
      "level": 4,
      "content": "Alternativamente, puede montar un ramfs para almacenar el archivo de claves temporalmente:\n\n```\n# mkdir /root/myramfs\n# mount ramfs /root/myramfs/ -t ramfs\n# cd /root/myramfs\n```\n\nLa ventaja es que reside en la memoria RAM y no en un disco físico, por lo que no se puede recuperar después de desmontar la ramfs. Después de copiar el archivo de claves en otro sistema de archivos seguro y persistente, desmonte la ramfs nuevamente con:\n\n```\n# umount /root/myramfs\n```\n\n"
    },
    {
      "title": "Configurar LUKS para que haga uso del archivo de claves",
      "level": 3,
      "content": "Agregue una ranura de claves para el archivo de claves al encabezado LUKS:\n\n```\n# cryptsetup luksAddKey /dev/sda2 /etc/mi_archivo_de_claves\n```\n\n```\nEnter any LUKS passphrase:\nkey slot 0 unlocked.\nCommand successful.\n```\n\n"
    },
    {
      "title": "Desbloquear manualmente una partición usando un archivo de claves",
      "level": 3,
      "content": "Utilice la opción --key-file al abrir el dispositivo LUKS:\n\n```\n# cryptsetup open /dev/sda2 nombre_dispositivo_mapeado --key-file /etc/mi_archivo_de_claves\n```\n\n"
    },
    {
      "title": "Desbloquear la partición raíz en el arranque",
      "level": 3,
      "content": "Esto es simplemente cuestión de configurar mkinitcpio (Español) para incluir los módulos o archivos necesarios y configurar el parámetro del kernel cryptkey para saber dónde encontrar el archivo de claves.\n\nDos casos se tratan a continuación:\n\n1. usar un archivo de claves almacenado en un medio externo (aquí una memoria USB);\n1. usar un archivo de claves incrustado en initramfs.\n\n"
    },
    {
      "title": "Con un archivo de claves almacenado en un medio externo",
      "level": 4,
      "content": "Debe agregar un módulo en /etc/mkinitcpio.conf para el sistema de archivos de la unidad (el módulo vfat en el siguiente ejemplo):\n\n```\nMODULES=(vfat)\n```\n\nEn este ejemplo, se supone que utiliza una unidad USB con formato FAT (módulo vfat). Reemplace esos nombres de módulos si usa otro sistema de archivos en su memoria USB (por ejemplo, ext2) u otra página de códigos. Si el sistema se queja de la existencia de un superbloque defectuoso y una página de códigos incorrecta en el arranque, entonces necesita un módulo de página de códigos adicional para cargar. Por ejemplo, es posible que necesite el módulo nls_iso8859-1 para la página de códigos iso8859-1.\n\nSi tiene un teclado no estadounidense, puede resultar útil cargar la distribución del teclado antes de que se le solicite ingresar la contraseña para desbloquear la partición raíz en el inicio. Para esto, necesitará el hook keymap antes de encrypt.\n\nregenere initramfs.\n\nAgregue las siguientes opciones a los parámetros del kernel si usa el hook encrypt. Si usa sd-encrypt vea dm-crypt (Español)/System configuration (Español)#Utilizar el hook sd-encrypt.\n\n```\ncryptdevice=/dev/<partición1>:root cryptkey=/dev/<partición2>:<tipo-de-sistema-de-archivos>:<ruta>\n```\n\nPor ejemplo:\n\n```\ncryptdevice=/dev/sda3:root cryptkey=/dev/sdb1:vfat:/keys/secretkey\n```\n\nLa elección de un nombre de archivo plano para su clave proporciona un bit de «seguridad por oscuridad», pero tenga en cuenta que la línea de órdenes del kernel se registra en el log del kernel (dmesg). El archivo de claves no puede ser un archivo oculto, lo que significa que el nombre de archivo no puede comenzar con un punto, o el hook encrypt no podrá encontrar el archivo de claves durante el proceso de arranque. Alternativamente, se podría ocultar el archivo de claves entre las particiones y usarlo:\n\n```\ncryptkey=/dev/sdb1:offset:size\n```\n\nComo ventaja, es más difícil eliminar la clave accidentalmente.\n\nNo se garantiza que la denominación de nodos de dispositivos como /dev/sdb1 permanezca igual en todos los reinicios. En su lugar, es más fiable acceder al dispositivo con los nombre de dispositivo de bloque persistente de udev. Para asegurarse de que el hook encrypt encuentre su archivo de claves al leerlo desde un dispositivo de almacenamiento externo, se deben usar nombres de dispositivos de bloques persistentes. Consulte el artículo persistent block device naming (Español).\n\n"
    },
    {
      "title": "Con un archivo de clave incrustado en initramfs",
      "level": 4,
      "content": "Note: **solo** \n\nEste método permite usar un archivo de claves con un nombre especial que se incrustará en initramfs y se rescatará por el hook encrypt para desbloquear el sistema de archivos raíz (cryptdevice) automáticamente. Puede ser útil aplicar cuando se usa la función cifrar GRUB en fase temprana, para evitar el ingreso de dos frases de contraseña durante el inicio.\n\nEl hook encrypt permite al usuario especificar un archivo de claves con el parámetro del kernel cryptkey: en el caso de initramfs, la sintaxis es rootfs:ruta. Consulte dm-crypt (Español)/System configuration (Español)#cryptkey. Además, este parámetro del kernel utiliza de manera predeterminada /crypto_keyfile.bin, y si initramfs contiene una clave válida con este nombre, el descifrado se producirá automáticamente sin necesidad de configurar el parámetro cryptkey.\n\nSi usa sd-encrypt en lugar de encrypt, especifique la ubicación del archivo de claves con el parámetro del kernel rd.luks.key. Consulte dm-crypt (Español)/System configuration (Español)#rd.luks.key.\n\nGenere el archivo de claves, otórguele los permisos adecuados y agréguelo como una clave LUKS:\n\n```\n# dd bs=512 count=4 if=/dev/random of=/crypto_keyfile.bin iflag=fullblock\n# chmod 600 /crypto_keyfile.bin\n# chmod 600 /boot/initramfs-linux*\n# cryptsetup luksAddKey /dev/sdX# /crypto_keyfile.bin\n```\n\nIncluya la clave en la matriz de FILES de mkinitcpio:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nFILES=(/crypto_keyfile.bin)\n```\n\nFinalmente regenere initramfs.\n\nEn el siguiente reinicio, solo debe ingresar la frase de contraseña de descifrado del contenedor una vez.\n\n(fuente)\n\n"
    }
  ]
}