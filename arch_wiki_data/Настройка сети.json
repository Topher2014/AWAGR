{
  "title": "Настройка сети",
  "url": "https://wiki.archlinux.org/title/%D0%9D%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0_%D1%81%D0%B5%D1%82%D0%B8",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Network Debugging\n- Межсетевой экран\n- Раздача интернета\n- Router\n\nВ статье описана настройка сетевого подключения на 3-м уровне модели OSI и выше. Вещи, специфичные для конкретного способа подключения, рассматриваются на подстраницах /Ethernet (для проводной сети) и /Wireless (для беспроводной).\n\n"
    },
    {
      "title": "Проверка подключения",
      "level": 2,
      "content": "При проблемах с подключением к сети последовательно проверьте, что:\n\n1. Сетевой интерфейс обнаружен и включён. В противном случае проверьте драйвер устройства – см. /Ethernet#Драйвер устройства и /Wireless#Драйвер устройства.\n1. Вы подключены к сети: воткнут сетевой кабель или есть подключение к беспроводной сети.\n1. Сетевому интерфейсу присвоен IP-адрес.\n1. Правильно настроена таблица маршрутизации.\n1. Возможно пропинговать локальный IP-адрес (например, шлюз по умолчанию).\n1. Возможно пропинговать публичный IP-адрес (например, 9.9.9.9 — DNS-сервер Quad9 Foundation, имеющий удобный для тестирования адрес).\n1. Работает разрешение доменных имён (например, archlinux.org).\n\n"
    },
    {
      "title": "Ping",
      "level": 3,
      "content": "Для проверки достижимости хоста используется утилита ping.\n\n```\n$ ping www.example.com\n```\n\n```\nPING www.example.com (93.184.216.34) 56(84) bytes of data.\n64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=1 ttl=56 time=11.632 ms\n64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=2 ttl=56 time=11.726 ms\n64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=3 ttl=56 time=10.683 ms\n...\n```\n\nДля каждого полученного ответа ping выводит строку, подобную приведённым выше. Для остановки используйте Ctrl+c. Подробнее см. ping(8). Учтите, что удалённый хост может быть настроен игнорировать ICMP-запросы [1].\n\nЕсли вместо ответов вы получаете ошибку (смотрите ping error indications) или не получаете ничего, это может быть связано с настройками сети, но также могут быть проблемы со шлюзом по умолчанию или интернет-провайдером. Воспользуйтесь утилитой traceroute для диагностики маршрута к хосту.\n\n"
    },
    {
      "title": "Управление сетевым подключением",
      "level": 2,
      "content": "Для настройки сетевого подключения сделайте следующее:\n\n1. Убедитесь, что сетевой интерфейс обнаружен и включён.\n1. Подключитесь к сети. Вставьте Ethernet-кабель или подключитесь к беспроводной сети.\n1. Настройте сетевое подключение: Большинство сетей использует Dynamic Host Configuration Protocol для настройки. Клиенты автоматически получают динамический или статический IP-адрес от DHCP-сервера с помощью отдельного DHCP-клиента или сетевого менеджера. Если сеть не использует DHCP-сервер, вы можете настроить статический IP-адрес, маршруты, шлюз по умолчанию и DNS-серверы вручную.\n\n- Большинство сетей использует Dynamic Host Configuration Protocol для настройки. Клиенты автоматически получают динамический или статический IP-адрес от DHCP-сервера с помощью отдельного DHCP-клиента или сетевого менеджера.\n- Если сеть не использует DHCP-сервер, вы можете настроить статический IP-адрес, маршруты, шлюз по умолчанию и DNS-серверы вручную.\n\n- systemd-networkd в качестве DHCP-клиента для всех типов сетевых интерфейсов — Ethernet, WLAN и WWAN, и\n- systemd-resolved для работы с DNS, смотрите systemd-resolved (Русский)#DNS.\n\n"
    },
    {
      "title": "iproute2",
      "level": 4,
      "content": "iproute2 (зависимость мета-пакета base) предоставляет утилиту командной строки ip(8) для управления сетевыми интерфейсами, IP-адресами и таблицей маршрутизации. Учтите, что сделанные с помощью ip настройки исчезнут после перезагрузки. Для задания постоянных настроек используйте сетевой менеджер или автоматизируйте ip-команды с помощью сценариев или юнитов systemd. Также обратите внимание, что многие команды ip имеют сокращённую форму, но в этой статье для ясности они указываются полностью.\n\n"
    },
    {
      "title": "Статический IP-адрес",
      "level": 4,
      "content": "Настройка статического IP-адреса производится либо посредством сетевого менеджера, либо с помощью демона dhcpcd.\n\nЧтобы настроить статический IP-адрес вручную, добавьте IP-адрес по рекомендациям в разделе #IP-адреса, настройте таблицу маршрутизации и DNS-сервер.\n\n"
    },
    {
      "title": "IP-адреса",
      "level": 4,
      "content": "Для управления IP-адресами используется команда ip-address(8).\n\nПоказать существующие IP-адреса:\n\n```\n$ ip address show\n```\n\nДобавить IP-адрес к сетевому интерфейсу:\n\n```\n# ip address add адрес/длина_префикса broadcast + dev интерфейс\n```\n\n- адрес указывается в CIDR-нотации с маской подсети;\n- спецсимвол + говорит утилите ip вычислить широковещательный адрес на основе IP-адреса и маски подсети.\n\nУдалить IP-адрес интерфейса:\n\n```\n# ip address del адрес/длина_префикса dev интерфейс\n```\n\nУдалить все адреса определённого интерфейса:\n\n```\n# ip address flush dev интерфейс\n```\n\n"
    },
    {
      "title": "Таблицы маршрутизации",
      "level": 4,
      "content": "Таблица маршрутизации определяет, можно ли связаться с удалённым хостом напрямую или нужно использовать какой-то шлюз (маршрутизатор). Если подходящего маршрута в таблице нет, то используется шлюз по умолчанию.\n\nНастройка таблицы маршрутизации производится командой ip-route(8).\n\nВ примерах ниже значение ПРЕФИКС либо указывается в CIDR-нотации, либо принимает значение default для шлюза по умолчанию.\n\nПоказать маршруты IPv4:\n\n```\n$ ip route show\n```\n\nПоказать маршруты IPv6:\n\n```\n$ ip -6 route show\n```\n\nДобавить маршрут:\n\n```\n# ip route add ПРЕФИКС via адрес dev интерфейс\n```\n\nУдалить маршрут:\n\n```\n# ip route del ПРЕФИКС via адрес dev интерфейс\n```\n\n"
    },
    {
      "title": "Автоматически",
      "level": 3,
      "content": "Автоматическая настройка сети осуществляется с помощью Dynamic Host Configuration Protocol (DHCP). DHCP-сервер в сети назначает IP-адреса, сообщает IP-адреса шлюза по умолчанию и, как вариант, DNS-серверы по запросу DHCP-клиента.\n\nСравнительная таблица DHCP-серверов приведена в разделе Router#DNS and DHCP.\n\n"
    },
    {
      "title": "Сетевые менеджеры",
      "level": 3,
      "content": "Сетевой менеджер позволяет создавать т.н. «сетевые профили» с настройками подключений, что облегчает переключение между сетями.\n\nTable content:\nПрограмма | Тип соединения | Аутентификация Wi-Fi | IP-адреса, маршруты и DNS | Интерфейс\nEthernet | PPPoE | Мобильный интернет | WPA/WPA2 | WPA3 | Статический IP | DHCP-клиент | Разрешение доменных имён | CLI | TUI | GUI\ndhclient1 | Да | Нет | Нет | Нет2 | Да | встроенный | Да (записывает /etc/resolv.conf) | Нет | Нет | Нет\ndhcpcd | Да | Нет | Нет | Запускает wpa_supplicant3 | Да | встроенный | Да (использует resolvconf или записывает /etc/resolv.conf) | Нет | Нет | dhcpcd-uiAUR\nConnMan | Да | [устаревшая ссылка 2023-10-29 ⓘ] Нет | Да (через ofonoAUR) | Да (через wpa_supplicant или iwd) | Да | встроенный | Да (запускает встроенный распознаватель и записывает /etc/resolv.conf) | connmanctl(1) | Да | Да\nnetctl | Да | Да (через ppp) | Да (через ppp) | Да (через wpa_supplicant) | Нет | Да | dhcpcd или dhclient | Да (использует resolvconf) | netctl(1) | wifi-menu(1)4 | Нет\nNetworkManager | Да | Да (через rp-pppoe) | Да (через modemmanager) | Да (через wpa_supplicant или iwd) | Да | встроенный, dhclient или dhcpcd | Да (использует systemd-resolved, resolvconf или записывает /etc/resolv.conf) | nmcli(1) | nmtui(1) | Да\nsystemd-networkd | Да | Нет | Нет | Нет2 | Да | встроенный | Да (использует systemd-resolved) | networkctl(1) | Нет | Нет\nwpa_supplicant | IEEE 802.1X | Нет | Нет | Да | Да | Нет | wpa_cli(8) | Нет | wpa_supplicant_guiAUR\niwd | IEEE 802.1X | Нет | Нет | Да | Да | Да | встроенный | Да (использует systemd-resolved или resolvconf) | iwctl(1) | Нет | iwgtkAUR\n\n1. Не поддерживается с 2022 года. ISC не рекомендует использовать его.\n1. Беспроводная аутентификация может быть настроена отдельно с помощью wpa_supplicant или iwd.\n1. Беспроводная аутентификация должна быть настроена отдельно с помощью wpa_supplicant.\n1. Позволяет управлять только Wi-Fi соединениями.\n\n"
    },
    {
      "title": "Сетевые интерфейсы",
      "level": 2,
      "content": "udev назначает имена сетевых интерфейсов в соответствии со схемой именования, в которой тип устройства обозначается двухбуквенным префиксом: en (проводной/Ethernet), wl (беспроводной/WLAN) или ww (WWAN). Подробнее см. systemd.net-naming-scheme(7).\n\n"
    },
    {
      "title": "Обнаружение сетевых интерфейсов",
      "level": 3,
      "content": "Имена как проводных, так и беспроводных интерфейсов можно узнать командами ls /sys/class/net и ip link. Имейте в виду, что префиксом lo обозначается петлевое устройство, которое не используется для сетевых соединений.\n\nИмена беспроводных устройств можно узнать командой iw dev. См. также /Wireless#Определение имени интерфейса.\n\nЕсли сетевой интерфейс не обнаружен, убедитесь, что его драйвер был загружен (cм. /Ethernet#Драйвер устройства и /Wireless#Драйвер устройства).\n\n"
    },
    {
      "title": "Включение и отключение сетевых интерфейсов",
      "level": 3,
      "content": "Включение и выключение интерфейса производится командой ip link set интерфейс up|down (подробнее см. ip-link(8)).\n\nДля проверки текущего состояния интерфейса (например, enp2s0) выполните:\n\n```\n$ ip link show dev enp2s0\n```\n\n```\n2: enp2s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master br0 state DOWN mode DEFAULT qlen 1000\n...\n```\n\nНа состояние интерфейса указывает UP в <BROADCAST,MULTICAST,UP,LOWER_UP>, а не state DOWN.\n\n"
    },
    {
      "title": "Смена имени интерфейса",
      "level": 3,
      "content": "Вы можете изменить имя устройства, установив его вручную с помощью файла systemd.link(5). Например:\n\n```\n/etc/systemd/network/10-net0.link\n```\n\n```\n[Match]\nPermanentMACAddress=aa:bb:cc:dd:ee:ff\n\n[Link]\nName=net0\n```\n\nВ качестве альтернативы можно использовать правило udev:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTR{address}==\"aa:bb:cc:dd:ee:ff\", NAME=\"net0\"\n```\n\nЭти правила будут применяться автоматически при загрузке. Чтобы применить изменения сразу, запустите trigger вручную для подсистемы net:\n\n```\n# udevadm trigger --verbose --subsystem-match=net --action=add\n```\n\nПроверить созданное правило из пространства пользователя можно командой udevadm --debug test /sys/class/net/*.\n\n- Приоритет Name ниже чем NamePolicy, поэтому убедитесь, что последний параметр не установлен или пуст, иначе имя не будет изменено. 99-default.link устанавливает NamePolicy, из чего следует, что пользовательская конфигурация должна находиться по порядку перед этим файлом, то есть должна иметь числовой префикс.\n- Перед изменением имени сетевой интерфейс должен быть отключен. [3]\n- Чтобы получить MAC-адрес каждой карты, выполните команду ip link.\n- Убедитесь, что в правилах udev используются шестнадцатеричные значения в нижнем регистре. Он не любит верхний регистр.\n\nЕсли сетевой интерфейс имеет динамический MAC-адрес, можно использовать Path (узнать который можно с помощью networkctl status интерфейс):\n\n```\n/etc/systemd/network/10-net1.link\n```\n\n```\n[Match]\nPath=pci-0000:01:00.0\n\n[Link]\nName=net1\n```\n\nДля правила udev можно использовать DEVPATH:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", DEVPATH==\"/devices/pci*/*1c.0/*/net/*\", NAME=\"net1\"\n```\n\nDEVPATH подключённых устройств можно узнать по символическим ссылкам в каталоге /sys/class/net/:\n\n```\n$ file /sys/class/net/*\n```\n\n```\n/sys/class/net/enp0s20f0u4u1: symbolic link to ../../devices/pci0000:00/0000:00:14.0/usb2/2-4/2-4.1/2-4.1:1.0/net/enp0s20f0u4u1\n/sys/class/net/enp0s31f6:     symbolic link to ../../devices/pci0000:00/0000:00:1f.6/net/enp0s31f6\n/sys/class/net/lo:            symbolic link to ../../devices/virtual/net/lo\n/sys/class/net/wlp4s0:        symbolic link to ../../devices/pci0000:00/0000:00:1c.6/0000:04:00.0/net/wlp4s0\n```\n\nПаттерн пути устройства (DEVPATH) должен подходить для обоих названий устройств, и нового, и старого, поскольку одно и то же правило udev может срабатывать несколько раз в процессе загрузки. Например, во втором правиле в примере выше шаблон \"/devices/pci*/*1c.0/*/net/en*\" будет ошибочным, поскольку после изменения имени на net1 он перестанет совпадать, и если после этого сработает системное правило по умолчанию, то вернётся старое имя.\n\nЕсли вы используете USB-интерфейс (например, подключаясь через Android-смартфон) с динамическим MAC-адресом и хотите иметь возможность использовать разные USB-порты, можно создать правило на основе данных о производителе и ID устройства:\n\n```\n/etc/systemd/network/20-net2.link\n```\n\n```\n[Match]\nProperty=ID_VENDOR_ID=12ab ID_MODEL_ID=3cd4\n\n[Link]\nName=net2\n```\n\nили\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTRS{idVendor}==\"12ab\", ATTRS{idProduct}==\"3cd4\", NAME=\"net2\"\n```\n\nNote: **вы должны избегать использования формата \"ethX\" и \"wlanX\"** \n\n"
    },
    {
      "title": "Традиционные названия интерфейсов",
      "level": 3,
      "content": "Если вы предпочитаете традиционные названия интерфейсов вроде eth0, отключите назначение предсказуемых имён интерфейсов, изменив NamePolicy для net_setup_link из udev:\n\n```\n/etc/systemd/network/99-default.link.d/traditional-naming.conf\n```\n\n```\n[Link]\nNamePolicy=keep kernel\n```\n\nИли можно полностью отключить net_setup_link, создав маску для правила udev.\n\n```\n# ln -s /dev/null /etc/udev/rules.d/80-net-setup-link.rules\n```\n\nДругой способ — добавить net.ifnames=0 в параметры ядра.\n\n"
    },
    {
      "title": "Установка MTU и длины очереди",
      "level": 3,
      "content": "Вы можете изменить MTU и длину очереди для устройства, определив их вручную с помощью настроек в systemd.link(5). Например:\n\n```\n/etc/systemd/network/30-mtu.link\n```\n\n```\n[Match]\nType=wlan\n\n[Link]\nMTUBytes=1500\nTransmitQueueLength=2000\n```\n\nИли с помощью правила udev:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"net\", KERNEL==\"wl*\", ATTR{mtu}=\"1500\", ATTR{tx_queue_len}=\"2000\"\n```\n\nMTUBytes: Значение выше 1500 (т.н. jumbo-кадры) может значительно повысить скорость передачи информации. Имейте в виду, что указанное значение MTU должны поддерживать все сетевые интерфейсы, в том числе коммутаторы в локальной сети, иначе передача jumbo-кадров завершится неудачно. Для PPPoE величина MTU не должна превышать 1492. Также значение MTU можно задать посредством systemd.netdev(5).\n\nTransmitQueueLength: Малые значения — для медленных устройств с высокой задержкой (ADSL, ISDN). Большие значения рекомендованы для высокоскоростных соединений с серверами, где предполагается передача значительных объёмов данных.\n\n"
    },
    {
      "title": "Имя хоста",
      "level": 2,
      "content": "Имя хоста — уникальное имя-идентификатор машины в сети. Имя хоста хранится в файле /etc/hostname (см. hostname(5) и hostname(7)). В файле также может храниться доменное имя системы, если таковое имеется. Чтобы задать имя хоста, добавьте в файл /etc/hostname одну строку:\n\n```\n/etc/hostname\n```\n\n```\nимя-хоста\n```\n\nВ качестве альтернативы имя хоста можно задать утилитой hostnamectl(1):\n\n```\n# hostnamectl set-hostname имя-хоста\n```\n\nУтилита hostname(1) из пакета inetutils позволяет задать имя хоста временно, до первой перезагрузки:\n\n```\n# hostname имя-хоста\n```\n\nСмотрите machine-info(5) о том, как настроить «красивое» имя машины и другие метаданные.\n\n"
    },
    {
      "title": "Разрешение имён в локальной сети",
      "level": 3,
      "content": "Чтобы машина была доступна по локальной сети по имени хоста, следует выбрать один из вариантов:\n\n- отредактировать файл /etc/hosts на каждом устройстве вашей локальной сети, см. hosts(5);\n- выбрать DNS-сервер для разрешения вашего имени хоста и настроить все машины в локальной сети использовать его (например, посредством DHCP);\n- использовать Zeroconf-сервис, автоматически создающий IP-сети без необходимости выполнения ручных настроек. Можно выбрать одну из двух реализаций: NetBIOS. Разработан компанией Microsoft, входит в состав Samba. Всё, что необходимо — запустить nmb.service. Машины с операционными системами Windows, macOS или Linux и работающим nmb смогут найти ваш компьютер в сети; mDNS. Возможны два варианта использования: Avahi и systemd-resolved. Компьютеры с macOS или Linux, на которых запущен Avahi или systemd-resolved, смогут обнаружить ваш хост. Windows не имеет встроенного mDNS клиента или демона. Старый Win32 API не поддерживает mDNS, что может помешать старым приложениям Windows получить доступ к вашей системе.\n\n- NetBIOS. Разработан компанией Microsoft, входит в состав Samba. Всё, что необходимо — запустить nmb.service. Машины с операционными системами Windows, macOS или Linux и работающим nmb смогут найти ваш компьютер в сети;\n- mDNS. Возможны два варианта использования: Avahi и systemd-resolved. Компьютеры с macOS или Linux, на которых запущен Avahi или systemd-resolved, смогут обнаружить ваш хост. Windows не имеет встроенного mDNS клиента или демона. Старый Win32 API не поддерживает mDNS, что может помешать старым приложениям Windows получить доступ к вашей системе.\n\n"
    },
    {
      "title": "Объединение сетевых интерфейсов (bonding) или LAG",
      "level": 3,
      "content": "Бондинг — объединение нескольких сетевых интерфейсов в одно логическое устройство. См. статьи netctl, systemd-networkd и Wireless bonding.\n\n"
    },
    {
      "title": "Псевдонимы для IP-адресов",
      "level": 3,
      "content": "Псевдонимы (aliases) необходимы для назначения нескольких IP-адресов одному сетевому интерфейсу. Благодаря этому один узел сети может иметь несколько подключений, каждое из которых будет использоваться для конкретной цели. Типичное применение этой возможности — виртуальный хостинг Web- и FTP-серверов или реорганизация серверов без необходимости обновления каких-либо других машин (особенно полезно для серверов имен).\n\n"
    },
    {
      "title": "Пример",
      "level": 4,
      "content": "Чтобы вручную назначить псевдоним для определенного сетевого интерфейса (например, enp2s0) используйте утилиту ip из пакета iproute2:\n\n```\n# ip addr add 192.168.2.101/24 dev enp2s0 label enp2s0:1\n```\n\nДля удаления псевдонима выполните:\n\n```\n# ip addr del 192.168.2.101/24 dev enp2s0:1\n```\n\nПо умолчанию для исходящих из определённой подсети пакетов используется основной псевдоним устройства. Если же отправитель находится в подсети вторичного псевдонима, то IP-адрес отправителя в заголовке пакета будет соответствующим. В случае наличия более чем одного сетевого интерфейса маршруты по умолчанию можно узнать командой ip route.\n\n"
    },
    {
      "title": "Promiscuous mode",
      "level": 3,
      "content": "Promiscuous mode («неразборчивый» режим) предполагает, что (беспроводной) сетевой интерфейс перенаправляет весь входящий трафик ядру операционной системы для дальнейшей обработки. Это противоположность «нормальному» режиму, при котором интерфейс отбрасывает пакеты, которые не ожидались быть полученными. Чаще всего эта возможность используется для решения сетевых проблем и анализа пакетов.\n\n```\n/etc/systemd/system/promiscuous@.service\n```\n\n```\n[Unit]\nDescription=Set %i interface in promiscuous mode\nAfter=network.target\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/ip link set dev %i promisc on\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n\nЧтобы включить «неразборчивый» режим для интерфейса enp2s0, включите promiscuous@enp2s0.service.\n\n"
    },
    {
      "title": "Получение информации о сокетах",
      "level": 3,
      "content": "Входящая в состав пакета iproute2 утилита ss используется для вывода информации о сокетах. Обладает схожим функционалом со считающейся устаревшей утилитой netstat.\n\nПримеры использования:\n\nПоказать все TCP-сокеты с названиями сервисов:\n\n```\n$ ss -at\n```\n\nПоказать все TCP-сокеты с номерами портов:\n\n```\n$ ss -atn\n```\n\nПоказать все UDP-сокеты:\n\n```\n$ ss -au\n```\n\nЗа подробной информацией обращайтесь к справочной странице ss(8).\n\n"
    },
    {
      "title": "Проблема масштабирования TCP window",
      "level": 3,
      "content": "Заголовок TCP-пакета содержит поле «Window», которое определяет, какое количество данных может быть прислано в ответ другим хостом. Ширина поля составляет 16 бит, следовательно, размер окна не может превышать 64 КиБ. С учётом кэширования пакетов, связанного с необходимостью восстановить их исходный порядок, значение окна легко может быть превышено.\n\nВ 1992 году ввиду того, что объём памяти, доступной компьютерам, всё увеличивался, был разработан RFC:1323, призванный решить проблему с помощью масштабирования окна (Window Scaling). Содержащееся в заголовке пакета значение «Window» корректировалось коэффициентом масштабирования (Scale Factor), который определялся один раз в начале подключения. Этот 8-битный коэффициент позволяет увеличить исходное окно размером 64 КиБ в 32 раза.\n\nНекоторые сломанные маршрутизаторы и межсетевые экраны переопределяют это значение на 0, что вызывает недопонимание между хостами. В ядре Linux версии 2.6.17 была введена в действие новая методика вычисления коэффициента масштабирования, в результате чего проблема с неправильно настроенными маршрутизаторами и экранами стала проявляться очень ярко.\n\nВ итоге соединение в лучшем случае очень медленное или часто прерывается.\n\n"
    },
    {
      "title": "Диагностика",
      "level": 4,
      "content": "Прежде всего, необходимо пояснить: это довольно странная проблема. В некоторых случаях вы вообще не сможете использовать соединения TCP (HTTP, FTP и т. д.), в других — сможете обращаться к некоторым узлам (почти ни к каким).\n\nЕсли у вас появилась такая проблема, вывод dmesg будет нормальным, логи — чистыми, а ip addr сообщит о нормальном состоянии... Всё будет выглядеть нормально.\n\nЕсли вы не можете просматривать никакие веб-сайты, но можете отправлять запросы ping на некоторые узлы, высока вероятность, что у вас именно эта проблема: ping использует ICMP, поэтому проблемы TCP на него не влияют.\n\nС помощью Wireshark можно будет увидеть, что UDP- и ICMP-соединения работают, а TCP-соединение с внешними узлами установить не удаётся.\n\n"
    },
    {
      "title": "Способы решения проблемы",
      "level": 4,
      "content": "Плохой способ заключается в изменении значения tcp_rmem, на основе которого вычисляется коэффициент масштабирования. Скорее всего, это решит проблему, кроме случая связи с особо удалёнными хостами.\n\n```\n# echo \"4096 87380 174760\" > /proc/sys/net/ipv4/tcp_rmem\n```\n\nПросто отключите масштабирование. Эта функция — довольно приятное дополнение к стандартному TCP, и без неё может быть некомфортно, особенно если вы не имеете возможности перенастроить неправильно работающий маршрутизатор. Есть несколько способов отключения масштабирования, и, кажется, наиболее надёжный из них (работает с большинством ядер) — добавить следующую строку в файл /etc/sysctl.d/99-disable_window_scaling.conf (смотрите также статью sysctl (Русский)):\n\n```\nnet.ipv4.tcp_window_scaling = 0\n```\n\nПроблема вызвана неправильно работающим маршрутизатором/межсетевыми экранами, поэтому просто замените его. Некоторые пользователи отмечали, что таким маршрутизатором был их собственный маршрутизатор DSL.\n\n"
    },
    {
      "title": "Дополнительная информация",
      "level": 4,
      "content": "Этот раздел основывается на статье LWN TCP window scaling and broken routers и архивной статье Kernel Trap Window Scaling on the Internet.\n\nНа странице LKML есть также несколько ссылок по теме.\n\n"
    },
    {
      "title": "Нет подключения к локальной сети через мост",
      "level": 3,
      "content": "Первый компьютер подключён к двум локальным сетям. Второй — к одной локальной сети и первому компьютеру. Выполните следующие команды, чтобы дать второму компьютеру доступ к сети за мостовым интерфейсом (на первой машине):\n\n```\n# sysctl net.bridge.bridge-nf-filter-pppoe-tagged=0\n# sysctl net.bridge.bridge-nf-filter-vlan-tagged=0\n# sysctl net.bridge.bridge-nf-call-ip6tables=0\n# sysctl net.bridge.bridge-nf-call-iptables=0\n# sysctl net.bridge.bridge-nf-call-arptables=0\n```\n\n"
    },
    {
      "title": "Разрешение имени localhost выполняется через сеть",
      "level": 3,
      "content": "Модуль nss-myhostname(8) входящей в состав systemd службы NSS (включен по умолчанию в /etc/nsswitch.conf) позволяет выполнять разрешение имени локально без обращения к файлу /etc/hosts. Однако следует иметь в виду, что некоторые программы всё же полагаются на файл /etc/hosts. [4], [5]\n\nЧтобы такие программы не пытались выполнить разрешение имени localhost через сеть (что небезопасно), добавьте следующие строки в файл hosts(5):\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n```\n\nЧтобы выполнять разрешение локального имени хоста, добавьте в файл hosts(5) и его тоже:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n127.0.1.1        имя-хоста\n```\n\nЕсли хост использует статический IP-адрес, то его следует указать вместо 127.0.1.1. Если у системы есть fully qualified domain name (FQDN), вставьте его перед именем хоста (обоснование описано здесь). Например:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n203.0.113.45     host1.fqdomain.example host1\n```\n\nВ результате используются обе записи:\n\n```\n$ getent hosts\n```\n\n```\n127.0.0.1       localhost\n127.0.0.1       localhost\n127.0.1.1       имя-хоста\n```\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Linux Network Administrators Guide\n- Debian Reference: Network setup\n- RHEL7: Networking Guide\n- Monitoring and tuning the Linux Networking Stack: Receiving data\n- Monitoring and tuning the Linux Networking Stack: Sending data\n- Tracing a packet journey using tracepoints, perf and eBPF\n\n"
    }
  ]
}