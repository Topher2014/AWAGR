{
  "title": "SSH (Русский)",
  "url": "https://wiki.archlinux.org/title/SSH_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Ключи SSH\n- Pam abl\n- fail2ban (Русский)\n- sshguard\n- SSHFS (Русский)\n- Syslog-ng\n- SFTP chroot\n- SCP and SFTP\n- VPN over SSH\n\nOpenSSH (OpenBSD Secure Shell) — набор программ, предоставляющих шифрование сеансов связи в компьютерных сетях по протоколу SSH (Secure Shell). OpenSSH разработан в рамках возглавляемого Тео де Раадтом (Theo de Raadt) проекта OpenBSD как открытая альтернатива проприетарному Secure Shell компании SSH Communications Security.\n\nOpenSSH иногда путают с OpenSSL; они разрабатываются разными командами и имеют различное назначение. Определённая схожесть в названиях возникла из-за приверженности обоих проектов принципам открытого программного обеспечения (open software).\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Установите пакет openssh.\n\n"
    },
    {
      "title": "Клиент",
      "level": 2,
      "content": "Чтобы установить соединение с сервером, выполните:\n\n```\n$ ssh -p порт пользователь@адрес-сервера\n```\n\nЕсли на сервере разрешена аутентификация только по открытому ключу, см. Ключи SSH.\n\n"
    },
    {
      "title": "Настройка",
      "level": 3,
      "content": "Настройки клиента делятся на две категории: общие для всех исходящих соединений и относящиеся к соединениям только с определёнными хостами. Например:\n\n```\n~/.ssh/config\n```\n\n```\n# глобальные настройки\nUser пользователь\n\n# настройки отдельного хоста\nHost мой-сервер\n    HostName адрес-сервера\n    Port     порт\n```\n\nС такими настройками следующие команды будут иметь одинаковый эффект:\n\n```\n$ ssh -p порт пользователь@адрес-сервера\n$ ssh мой-сервер\n```\n\nПодробнее см. руководство ssh_config(5).\n\nНекоторые настройки не имеют флагов-аналогов для командной строки, но можно указать необходимые опции с помощью флага -o. Например, -oKexAlgorithms=+diffie-hellman-group1-sha1.\n\n"
    },
    {
      "title": "Сервер",
      "level": 2,
      "content": "sshd — демон сервера OpenSSH, который управляется службой sshd.service в соответствии с настройками в файле /etc/ssh/sshd_config. Если вы собираетесь изменить настройки, то стоит сначала запустить sshd в тестовом режиме, чтобы убедиться, что демон запустится без проблем. Отсутствие вывода означает рабочую конфигурацию.\n\n```\n# sshd -t\n```\n\n"
    },
    {
      "title": "Настройка",
      "level": 3,
      "content": "Чтобы изменить настройки, нужно отредактировать/добавить нужные строки в файле настроек, например:\n\nПредоставить доступ отдельным пользователям:\n\n```\nAllowUsers    пользователь1 пользователь2\n```\n\nПредоставить доступ группам пользователей:\n\n```\nAllowGroups   группа1 группа2\n```\n\nПараметр Banner позволяет настроить приветственное сообщение (например, сохранённое в файле /etc/issue):\n\n```\nBanner /etc/issue\n```\n\nПары открытых и закрытых ключей генерируются службой sshdgenkeys и сохраняются в файле /etc/ssh. Если какие-то ключи отсустствуют, то они создаются заново, даже если опция HostKeyAlgorithms в файле sshd_config разрешает не все алгоритмы шифрования. Всего создаётся четыре пары ключей на основе алгоритмов dsa, rsa, ecdsa и ed25519. Чтобы sshd мог использовать конкретный ключ, укажите следующую опцию:\n\n```\nHostKey /etc/ssh/ssh_host_rsa_key\n```\n\nЕсли сервер находится в глобальной (WAN) сети, рекомендуется также сменить порт со стандартного 22 на случайное значение, например:\n\n```\nPort 39901\n```\n\n- Альтернативный порт лучше выбирать из числа не занятых другими службами. Инфомацию о портах можно найти в файле /etc/services, а также в статье Список портов TCP и UDP. Смена порта снизит количество попыток входа, выполняемых автоматизированными сканерами и скриптами, которые обычно ожидают SSH-соединение на порте 22. Чтобы полностью исключить такие попытки, можно настроить port knocking.\n- В целях безопасности рекомендуется полностью отключить вход по паролю. Другие полезные способы повышения защищённости SSH-соединения описаны в разделе #Безопасность.\n- OpenSSH может прослушивать несколько портов одновременно. Для этого укажите несколько параметров Port номер-порта в файле настроек.\n- Можно сгенерировать новые пары ключей в дополнение (или взамен) к тем, которые были созданы изначально. Удалите ненужные пары ключей из файлов в каталоге /etc/ssh, после чего выполните команду ssh-keygen -A с правами root.\n\n"
    },
    {
      "title": "Управление демоном",
      "level": 3,
      "content": "Запустите/включите службу sshd.service. Демон SSH будет работать в фоновом режиме и выполнять форк (fork) для каждого входящего соединения [1].\n\n- Юнит sshd.socket может внезапно прекратить работу (например, из-за исчерпания свободной памяти), а опцию Restart=always для юнитов сокетов задать нельзя [2].\n- Использовании активации сокета может привести к отказу в обслуживании (denial of service), если слишком большое количество соединений приведёт к невозможности новых запусков службы (см. FS#62248).\n\n"
    },
    {
      "title": "Безопасность",
      "level": 3,
      "content": "Удалённый вход в систему через SSH удобен для осуществления административных задач, но представляет определённую проблему с точки зрения безопаности. SSH часто подвергается атакам полным перебором и нуждается в соответствующей конфигурации, чтобы не дать посторонним войти в систему.\n\nssh-audit предлагает автоматизированный анализ серверных и клиентских настроек. Следующие статьи и инструменты могут также быть полезными:\n\n- Статья Mozilla Infosec Team\n- Утилита ssh_scan\n- SSH Hardening Guides\n\n"
    },
    {
      "title": "Вход только по открытому ключу",
      "level": 4,
      "content": "Если клиент не может выполнить вход по открытому ключу, SSH-сервер по умолчанию предоставляет возможность аутентификации по паролю. Это позволяет злоумышленнику получить доступ с помощью полного перебора паролей. Самый надёжный способ защиты от такой атаки — полностью отключить вход по паролю и оставить только аутентификацию с помощью ключей SSH. Для этого нужно отключить следующую опцию в файле настроек демона:\n\n```\n/etc/ssh/sshd_config\n```\n\n```\nPasswordAuthentication no\n```\n\n"
    },
    {
      "title": "Двухфакторная аутентификация и открытые ключи",
      "level": 4,
      "content": "С помощью опции AuthenticationMethods можно настроить использование различных способов аутентификации, например, применение открытых ключей совместно с двухфакторной аутентификацией.\n\nВ статье Google Authenticator описана настройка Google Authenticator.\n\nДля Duo установите duo_unixAUR, в котором есть полная поддержка модуля pam_duo.so. Подробнее о настройке параметров доступа (Integration Key, Secret Key, API Hostname) см. документацию Duo Unix.\n\nДля использования PAM с OpenSSH, отредактируйте следующий файл:\n\n```\n/etc/ssh/sshd_config\n```\n\n```\nChallengeResponseAuthentication yes\nAuthenticationMethods publickey keyboard-interactive:pam\n```\n\nПосле этого можно будет выполнять вход в систему или по открытому ключу, или в соответствии настройками аутентификации PAM.\n\nНаоборот, если вы хотите настроить вход по открытому ключу и через PAM, используйте в качестве разделителя AuthenticationMethods запятую, а не пробел:\n\n```\n/etc/ssh/sshd_config\n```\n\n```\nChallengeResponseAuthentication yes\nAuthenticationMethods publickey,keyboard-interactive:pam\n```\n\nПри входе по ключу и PAM аутентификацию по паролю можно отключить:\n\n```\n/etc/pam.d/sshd\n```\n\n```\n#отключение удалённного root\nauth      required  pam_securetty.so\n\n#требуется google authenticator\nauth      required  pam_google_authenticator.so\n\n#но пароль не нужен\n#auth      include   system-remote-login\naccount   include   system-remote-login\npassword  include   system-remote-login\nsession   include   system-remote-login\n```\n\n"
    },
    {
      "title": "Защита от атак полным перебором",
      "level": 4,
      "content": "Принцип атаки полным перебором прост: атакующий многократно пытается выполнить вход на страницу или веб-сервер, используя большое количество случайных комбинаций имён пользователей и паролей.\n\nПодробнее см. ufw#Rate limiting with ufw и Настройка межсетевого экрана#Атака полным перебором в случае экрана iptables\n\nКроме того, программы вроде fail2ban или sshguard помогают защититься от атак перебором, блокируя попытки подбора паролей.\n\n- Разрешайте входящие SSH-соединения только для доверенных адресов\n- Используйте fail2ban или sshguard для автоматической блокировки IP-адресов, которые провалили попытку аутентификации слишком много раз.\n- Используйте pam_shield для блокировки IP-адресов, которые выполняют слишком большое количество попыток входа за определённый период времени. В отличие от fail2ban и sshguard, pam_shield не различает успешными и неудачными попытками входа.\n\n"
    },
    {
      "title": "Ограничение входа от имени суперпользователя",
      "level": 4,
      "content": "Note: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nПредоставление возможности входа через SSH от имени суперпользователя без какой-либо защиты считается плохой практикой. Существует два способа ограничения этой возможности для повышения безопасности.\n\nУтилита sudo выборочно предоставляет права суперпользователя для действий, которым они необходимы, без входа в учётную запись root. Благодаря этому можно заблокировать аккаунт root, чтобы отключить возможность входа в него через SSH. Это потенциально является средством защиты от атак перебором, поскольку атакующему придётся подбирать ещё и имя учётной записи в дополнение к паролю.\n\nЧтобы отключить вход от имени суперпользователя через SSH, получите его права и отредактируйте секцию \"Authentication\" файла /etc/ssh/sshd_config. Просто измените значение #PermitRootLogin yes на no и раскомментируйте строку:\n\n```\n/etc/ssh/sshd_config\n```\n\n```\nPermitRootLogin no\n...\n```\n\nПерезапустите демон SSH.\n\nТеперь вы не сможете войти в систему через SSH от имени суперпользователя, но по-прежнему будете иметь возможность входить от имени обычного пользователя и использовать команды su и sudo для администрирования.\n\nНекоторые автоматические задачи, вроде удалённого резервного копирования системы, требуют полного root-доступа. Чтобы иметь возможность безопасно его использовать, вместо отключения укажите конкретные команды. Для этого отредактируйте файл ~root/.ssh/authorized_keys, создав префиксы для соответствующих ключей, например:\n\n```\ncommand=\"/usr/lib/rsync/rrsync -ro /\" ssh-rsa …\n```\n\nТеперь при входе с использованием соответствующего ключа пользователь получит права root, но сможет выполнять только те команды, которые перечислены между кавычками.\n\nПри этом остаётся возможность входа в систему с использованием имени суперпользователя. Это можно исправить, добавив следующую строку в файл sshd_config:\n\n```\nPermitRootLogin forced-commands-only\n```\n\nЭто не только ограничит список команд, которые могут выполняться через SSH от имени суперпользователя, но и отключит использование паролей, оставляя возможность входа в root-аккаунт только по ключу.\n\nЕсть альтернатива, вводящая меньше ограничений, которая позволит выполнять любые команды от имени суперпользователя, но сделает невозможной атаку перебором благодаря отключению входа по паролю. Для этого пропишите:\n\n```\nPermitRootLogin prohibit-password\n```\n\n"
    },
    {
      "title": "Защита файла authorized_keys",
      "level": 4,
      "content": "Для дополнительной защиты можно запретить пользователям добавлять новые открытые ключи, по которым можно будет выполнить соединение.\n\nЗадайте файлу authorized_keys права только на чтение для владельца и отключите остальные:\n\n```\n$ chmod 400 ~/.ssh/authorized_keys\n```\n\nЧтобы не позволить пользователям вернуть разрешения, установите бит неизменяемости на файл authorized_keys. После этого пользователь может попытаться перемеименовать каталог ~/.ssh и создать новый каталог с таким же именем и файлом authorized_keys. Чтобы не дать ему это сделать, установите бит неизменяемости и на каталог ~/.ssh.\n\n"
    },
    {
      "title": "Шифрованный туннель SOCKS",
      "level": 3,
      "content": "Эта возможность будет полезна для обладателей ноутбуков, которые часто подключаются к небезопасным беспроводным сетям в общественных местах. Для создания туннеля необходимо предварительно запустить сервер SSH в каком-нибудь безопасном месте, например, дома или на работе. Также будет весьма кстати какая-нибудь служба динамического DNS вроде DynDNS, которая избавит вас от необходимости запоминать IP-адрес.\n\n"
    },
    {
      "title": "Шаг 1: установить соединение",
      "level": 4,
      "content": "Для установления соединения необходимо лишь выполнить команду:\n\n```\n$ ssh -TND 4711 пользователь@хост\n```\n\nгде пользователь — ваше имя пользователя на сервере SSH, работающием на машине хост. Сервер запросит пароль, после чего будет установлено соединение. Флаг N отключает интерактивное приглашение командной строки, а флаг D позволяет пользователю выбрать локальный порт для прослушивания. Флаг T означает, что сервер не станет выделять псевдо-терминал для данного соединения.\n\nТакже стоит указать флаг -v, который сделает вывод команды более многословным. В частности, по выводу можно будет понять, что соединение действительно было установлено.\n\n"
    },
    {
      "title": "Шаг 2 (вариант А): настроить браузер (или другие программы)",
      "level": 4,
      "content": "Чтобы установленное соединение (см. выше) было хоть как-то полезно, нужно настроить браузер и другие программы на использование туннеля SOCKS. В настоящее время SSH поддерживает как SOCKSv4, так и SOCKSv5, вы можете выбрать любой из них.\n\n- Для Firefox: Preferences > General > Settings.... В открывшемся окне выберите пункт Manual proxy configuration, введите localhost в поле SOCKS host и номер порта в поле Port (4711 для примера выше).\n\n- Для Chromium: SOCKS можно настроить через переменные окружения или опции командной строки. Например, выберите одну из следующих функций и добавьте её в файл .bashrc:\n\n```\nfunction secure_chromium {\n    port=4711\n    export SOCKS_SERVER=localhost:$port\n    export SOCKS_VERSION=5\n    chromium &\n    exit\n}\n```\n\nили\n\n```\nfunction secure_chromium {\n    port=4711\n    chromium --proxy-server=\"socks://localhost:$port\" &\n    exit\n}\n```\n\nТеперь откройте терминал, выполните\n\n```\n$ secure_chromium\n```\n\nи наслаждайтесь защищённым туннелем!\n\n"
    },
    {
      "title": "Шаг 2 (вариант Б): настроить TUN-интерфейс",
      "level": 4,
      "content": "Этот вариант выглядит несколько более запутанным по сравнению с предыдущим, но зато вам не придётся настраивать работу через SOCKS-прокси для каждого приложения по отдельности. Данное решение подразумевает настройку локального TUN-интерфейса и перенаправление всего трафика на него.\n\nПодробнее см. VPN over SSH#Set up badvpn and tunnel interface.\n\n"
    },
    {
      "title": "Проброс X11",
      "level": 3,
      "content": "Проброс Х11 — механизм, который позволяет графическим интерфейсам программ удаленной машины-сервера отображаться на локальной машине-клиенте. При этом нет необходимости устанавливать на удаленном узле всю систему Х11, но надо установить хотя бы xauth. xauth — утилита, которая поддерживает конфигурации Xauthority, используемые сервером и клиентом для аутентификации сессии X11 [3].\n\n"
    },
    {
      "title": "Настройка",
      "level": 4,
      "content": "На удалённой системе:\n\n- Установите пакеты xorg-xauth и xorg-xhost;\n- В файле /etc/ssh/sshd_config: Задайте для опции X11Forwarding значение yes; Убедитесь, что заданы значения AllowTcpForwarding yes, X11UseLocalhost yes и X11DisplayOffset 10 (значения по умолчанию, если ничего не менялось, см. sshd_config(5));\n- Перезапустите службу sshd.\n\n- Задайте для опции X11Forwarding значение yes;\n- Убедитесь, что заданы значения AllowTcpForwarding yes, X11UseLocalhost yes и X11DisplayOffset 10 (значения по умолчанию, если ничего не менялось, см. sshd_config(5));\n\nНа клиенте:\n\n- Установите пакет xorg-xauth;\n- включите опцию ForwardX11 либо добавив флаг -X в командной строке, либо задав в файле настроек клиента параметр ForwardX11 yes.\n\n"
    },
    {
      "title": "Использование",
      "level": 4,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nВыполните удалённый вход как обычно, добавив флаг -X, если опция ForwardX11 не включена в конфигурационном файле клиента:\n\n```\n$ ssh -X пользователь@хост\n```\n\nЕсли вы получаете ошибки при запуске графических приложений, попробуйте опцию ForwardX11Trusted:\n\n```\n$ ssh -Y пользователь@хост\n```\n\nТеперь вы можете запустить любую программу с графическим интерфейсом пользователя на удаленном сервере, и ее вывод будет перенаправлен в вашу локальную сессию:\n\n```\n$ xclock\n```\n\nЕсли вы получите ошибки \"Cannot open display\", попробуйте выполнить следующую команду от имени обычного пользователя:\n\n```\n$ xhost +\n```\n\nэта команда позволит выполнять проброс приложений X11 любому пользователю. Чтобы ограничить проброс конкретным хостом:\n\n```\n$ xhost +имя-хоста\n```\n\nгде имя-хоста - это имя конкретного хоста. Подробнее см. xhost(1).\n\nБудьте осторожны с некоторыми приложениями, так как они могут проверять локальную машину на предмет уже работающего приложения. Один из примеров - Firefox: либо закройте работающий Firefox, либо используйте следующий параметр запуска:\n\n```\n$ firefox --no-remote\n```\n\nЕсли вы получите ошибку X11 forwarding request failed on channel 0 при подключении (и лог-файл сервера /var/log/errors.log будет содержать строку Failed to allocate internet-domain X11 display socket), удостоверьтесь, что пакет xorg-xauth установлен. Если его установка не поможет, попробуйте сделать одно из двух:\n\n- Включить опцию AddressFamily any в файле sshd_config на сервере;\n- Задать опции AddressFamily в sshd_config на сервере значение inet. Присвоение значения inet может исправить проблемы с клиентами Ubuntu при использовании IPv4.\n\nДля запуска приложений X от имени других пользователей на сервере SSH вам необходимо добавить (команда xauth add) строку аутентификации, взятую из вывода команды xauth list пользователя, вошедшего в систему.\n\n"
    },
    {
      "title": "Проброс других портов",
      "level": 3,
      "content": "В дополнение к встроенной поддержке SSH X11 также можно установить безопасный туннель для любого соединения TCP с использованием локального или удаленного проброса.\n\nЛокальный проброс открывает на локальной машине порт, подключения к которому будут перенаправлены на удаленный хост, а оттуда - по заданному направлению. Очень часто этим направлением будет сам удаленный хост, предоставляющий secure shell и, например, безопасное соединение VNC для этой же машины. Локальный проброс осуществляется при помощи ключа -L и задания спецификации проброса в следующей форме: <порт туннеля>:<адрес назначения>:<порт назначения>.\n\nНапример:\n\n```\n$ ssh -L 1000:mail.google.com:25 192.168.0.100\n```\n\nбудет использовать SSH для входа в систему и открытия шелла на 192.168.0.100, а также создаст туннель от порта 1000 локальной машины на порт 25 mail.google.com. В результате подключения к localhost:1000 будут перенаправлены на порт Gmail SMTP. Для Google всё будет выглядеть так, будто соединение (но вовсе не обязательно — передаваемые по нему данные) исходит от 192.168.0.100; данные будут в безопасности между локальной машиной и 192.168.0.100, но не между 192.168.0.100 и Google, если не предпринять дополнительных мер.\n\nТакже:\n\n```\n$ ssh -L 2000:192.168.0.100:6001 192.168.0.100\n```\n\nбудет принимать подключения к localhost:2000, которые будут перенаправлены на порт 6001 удаленного хоста. Этот пример хорош для VNC-соединений с помощью утилиты vncserver. Утилита входит в пакет TigerVNC, и, несмотря на очевидную полезность, имеет некоторые проблемы с безопасностью.\n\nУдаленный проброс позволяет удаленному хосту подключаться к произвольному хосту через туннель SSH и локальную машину, предоставляя функционал, обратный локальному пробросу. Это полезно в ситуациях, когда, например, удаленный хост ограничен фаерволлом. Он включается ключом -R и заданием спецификаций проброса в следующей форме: <порт туннеля>:<адрес назначения>:<порт назначения>.\n\nНапример:\n\n```\n$ ssh -R 3000:irc.libera.chat:6667 192.168.0.200\n```\n\nподнимет шелл на 192.168.0.200, и соединения из 192.168.0.200 к своему же порту 3000 (т.е. localhost:3000 удалённого хоста) будут посланы через туннель на локальную машину, а затем на irc.libera.chat, порт 6667, что в данном примере позволит использовать программы IRC на удаленном хосте, даже если обычно порт 6667 будет для них заблокирован.\n\nОба вида проброса могут быть использованы для предоставления безопасного \"шлюза\", позволяющего другим компьютерам получить преимущества туннеля SSH без непосредственно работающего SSH или демона SSH, при использовании bind-адреса в начале туннеля как части спецификации проброса, например, <адрес туннеля>:<порт туннеля>:<адрес назначения>:<порт назначения>. <адрес туннеля> может быть любым адресом на машине, localhost, * (или blank), который, соответственно, пропускает соединения через заданный адрес, интерфейс loopback или любой интерфейс. По умолчанию проброс ограничен соединениями от машины в начале туннеля, <адрес туннеля> установлен в localhost. Локальный проброс не требует дополнительной настройки, в то время как удаленный проброс ограничен конфигурацией демона SSH удаленного сервера. Смотрите описание опции GatewayPorts на справочной странице sshd_config(5) и опции -L address в руководстве ssh(1) для получения дополнительной информации.\n\n"
    },
    {
      "title": "Jump-хост",
      "level": 3,
      "content": "Может случиться так, что у вас не будет возможности установить связь с удалённой машиной напрямую. В этом случае используется jump-сервер или узел-бастион. Следовательно, необходимо соединить два или более SSH-туннеля в цепочку. Разумеется, ваши ключи должны позволять выполнить авторизацию на каждом из серверов в цепи. Для этого SSH запускается с опциями пересылки аутентификационных данных (-A) и выделения псевдотерминала (-t):\n\n```\n$ ssh -A -t -l пользователь1 бастион1 \\\n  ssh -A -t -l пользователь2 промежуточный-узел2 \\\n  ssh -A -t -l пользователь3 целевой-узел\n```\n\nНесколько проще то же самое можно сделать с флагом -J:\n\n```\n$ ssh -J пользователь1@бастион1,пользователь2@промежуточный-узел2 пользователь3@целевой-узел\n```\n\nПромежуточные хосты в директиве -J разделяются запятыми и располагаются в порядке установления соединения. Часть пользователь...@ необязательна. При работе с опцией -J используется стандартный файл настроек SSH, поэтому при необходимости в нём можно указать настройки соединения для каждого хоста в отдельности.\n\nОпция ProxyJump в файле настроек эквивалентyна флагу командной строки -J, см. ssh_config(5).\n\n"
    },
    {
      "title": "Обратный SSH через промежуточный узел",
      "level": 3,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nИдея заключается в том, чтобы подключиться к серверу через промежуточный узел, причём сервер соединяется с этим узлом через обратный SSH-туннель. Например, это может быть полезно, когда сервер находится за NAT, а промежуточный узел представляет собой публичный SSH-сервер, используемый в качестве прокси. При этом:\n\n- у клиента должны быть ключи для авторизации и на промежуточном узле, и на целевом сервере;\n- у сервера должны быть ключи дла авторизации на промежуточном узле.\n\nНиже приведён пример настройки соединения через промежуточный узел. Предполагается, что пользователь1 — аккаунт на клиентской машине, пользователь2 — на промежуточном узле и пользователь3 — на сервере. Сначала необходимо создать обратный туннель:\n\n```\nssh -R 2222:localhost:22 -N пользователь2@промежуточный-узел\n```\n\nЭто действие можно автоматизировать с помощью скрипта, службы systemd или autossh.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nСоединение со стороны клиента устанавливается командой:\n\n```\nssh -t пользователь1@промежуточный-узел ssh пользователь3@localhost -p 2222\n```\n\nУдалённую команду для создания соединения с обратным туннелем можно добавить в файл ~/.ssh/authorized_keys на промежуточном узле. Для этого воспользуйтесь полем command:\n\n```\ncommand=\"ssh пользователь3@localhost -p 2222\" ssh-rsa KEY2 пользователь1@клиент\n```\n\nТогда установить соединение можно командой:\n\n```\nssh пользователь2@промежуточный-узел\n```\n\nОбратите внимание, что функция автодополнения SCP в терминале клиента работать не будет, а на некоторых конфигурациях не будет работать и сама передача данных по протоколу SCP.\n\n"
    },
    {
      "title": "Мультиплексирование",
      "level": 3,
      "content": "Демон SSH обычно прослушивает порт 22. Однако трафик, который адресован не на стандартные порты HTTP/S (80 и 443 соответственно), на публичных серверах часто блокируется. Следовательно, в таком случае SSH-соединение невозможно. В качестве возможного решения можно указать демону sshd прослушивать один из портов в белом списке:\n\n```\n/etc/ssh/sshd_config\n```\n\n```\nPort 22\nPort 443\n```\n\nПоскольку порт 443 уже прослушивается веб-сервером в ожидании HTTPS-пакетов, в данном случае имеет смысл воспользоваться мультиплексором вроде sslh. Он будет прослушивать мультиплексированный порт и переадресовывать пакеты разным сервисам в зависимости от их назначения.\n\n"
    },
    {
      "title": "Увеличение скорости SSH",
      "level": 3,
      "content": "Среди настроек клиента есть некоторые, которые позволяют увеличить скорость соединения либо глобально, либо для отдельных хостов. Полное описание этих опций можно найти в руководстве ssh_config(5).\n\n- Используйте быстрый алгоритм шифрования: в современных процессорах с инструкциями AESNI алгоритмы aes128-gcm@openssh.com и aes256-gcm@openssh.com гораздо более производительны, чем стандартный алгоритм OpenSSH, chacha20-poly1305@openssh.com. Выбрать алгоритм можно флагом -c. Чтобы сделать изменения постоянными, добавьте пункт Ciphers в файл ~/.ssh/config, перечислив алгоритмы в порядке уменьшения предпочтительности, например: Ciphers aes128-gcm@openssh.com,aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\n\n```\nCiphers aes128-gcm@openssh.com,aes256-gcm@openssh.com,chacha20-poly1305@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr\n```\n\n- Включите или выключите сжатие: сжатие может увеличить скорость для медленных соединений, оно включается параметром Compression yes или флагом -C. Однако в качестве алгоритма сжатия используется относительно медленный gzip(1), который в быстрых сетях становится узким местом. Поэтому в локальных и быстрых сетях лучше отключить сжатие параметром Compression no.\n\n- Объединение соединений: в случае нескольких одновременных сессий к одному хосту можно объединить их в одно соединение: ControlMaster auto ControlPersist yes ControlPath ~/.ssh/sockets/socket-%r@%h:%p\n\n```\nControlMaster auto\nControlPersist yes\nControlPath ~/.ssh/sockets/socket-%r@%h:%p\n```\n\n- Параметр ControlPersist позволяет задать время ожидания после момента разрыва исходного соединения. Возможны следующие значения: no — соединение разрывается сразу же после отключения предыдущего клиента; время ожидания в секундах; yes — бесконечное ожидание, соединение автоматически разрываться не будет.\n\n- no — соединение разрывается сразу же после отключения предыдущего клиента;\n- время ожидания в секундах;\n- yes — бесконечное ожидание, соединение автоматически разрываться не будет.\n\n- Время входа можно сократить, если пропустить поиск заголовков IPv6. Для этого используйте опции AddressFamily inet или флаг -4.\n\n- Наконец, если вы собираетесь использовать SSH для SFTP или SCP, High Performance SSH/SCP поможет значительно увеличить пропускную способность с помощью динамического изменения размера буфера SSH. Установите пакет openssh-hpn-gitAUR[ссылка недействительна: package not found], чтобы использовать OpenSSH с этим расширением.\n\n"
    },
    {
      "title": "Монтирование удалённых файловых систем при помощи SSHFS",
      "level": 3,
      "content": "В статье SSHFS описано, как использовать SSH для монтирования удалённых файловых систем в локальный каталог, чтобы иметь возможность выполнять любые операции над смонтированными файлами (копирование, переименование, редактирование в vim и т.д.). Предпочтительнее использовать sshfs, а не shfs, поскольку последний не обновлялся с 2004 года.\n\n"
    },
    {
      "title": "Поддержание подключения",
      "level": 3,
      "content": "По умолчанию сеанс связи SSH автоматически разрывается, если соединение не использовалось в течение какого-то времени. Чтобы сохранить сеанс, клиент может посылать сигналы серверу, если не было получено никаких данных за последнее время, или наоборот, сервер может посылать сообщения через определённые временные интервалы, если он не получал данных от клиента.\n\n- На сервере параметр ClientAliveInterval задаёт время ожидания в секундах, по истечении которого при отсутствии данных от клиента sshd пошлёт последнему запрос. Значение по умолчанию — 0, \"не посылать сообщений\". Например, чтобы запрашивать ответ от клиента каждые 60 секунд, задайте параметр ClientAliveInterval 60 в настройках сервера. Также обратите внимание на параметры ClientAliveCountMax и TCPKeepAlive.\n- На клиенте параметр ServerAliveInterval задаёт временной промежуток между запросами на сервер. Например, чтобы посылать запросы каждые 120 секунд, задайте параметр ServerAliveInterval 120 в настройках клиента. Также обратите внимание на параметры ServerAliveCountMax и TCPKeepAlive.\n\n"
    },
    {
      "title": "Автоматический перезапуск туннелей SSH с помощью systemd",
      "level": 3,
      "content": "systemd может автоматически создавать SSH-соединения при загрузке/входе в систему, а также перезапускать их при внезапном разрыве соединения.\n\nНиже представлен пример службы, которая будет создавать SSH-туннель в соответствии с настройками SSH. Если соединение было по какой-то причине разорвано, служба подождёт 10 секунд и перезапустит его:\n\n```\n~/.config/systemd/user/tunnel.service\n```\n\n```\n[Unit]\nDescription=SSH tunnel to myserver\n\n[Service]\nType=simple\nRestart=always\nRestartSec=10\nExecStart=/usr/bin/ssh -F %h/.ssh/config -N myserver\n```\n\nзапустите/включите пользовательскую службу systemd. В разделе #Поддержание подключения описано, как предотвратить разрыв соединения из-за превышения времени ожидания. Если вы захотите запускать туннель при загрузке системы, то придётся переписать юнит, чтобы сделать его системным.\n\n"
    },
    {
      "title": "Autossh - автоматический перезапуск сессий и туннелей SSH",
      "level": 3,
      "content": "Если сессия или туннель не может поддерживаться в активном состоянии, например, из-за плохого подключения к сети и связанных с ним отключений, используйте autossh для автоматического перезапуска.\n\nПримеры использования:\n\n```\n$ autossh -M 0 -o \"ServerAliveInterval 45\" -o \"ServerAliveCountMax 2\" имя_пользователя@example.com\n```\n\nСовместно с SSHFS:\n\n```\n$ sshfs -o reconnect,compression=yes,transform_symlinks,ServerAliveInterval=45,ServerAliveCountMax=2,ssh_command='autossh -M 0' имя_пользователя@example.com: /mnt/example\n```\n\nПодключение через SOCKS-прокси, сконфигурированный при помощи настроек proxy:\n\n```\n$ autossh -M 0 -o \"ServerAliveInterval 45\" -o \"ServerAliveCountMax 2\" -NCD 8080 имя_пользователя@example.com\n```\n\nПри помощи опции -f autossh может быть запущен в качестве фонового процесса. Однако, в этом случае вы не сможете вводить пароль в интерактивном режиме.\n\nСессия будет завершена, как только вы введете команду exit, иначе процесс autossh получит сигнал SIGTERM, SIGINT или SIGKILL.\n\n"
    },
    {
      "title": "Автозапуск Autossh при загрузке системы при помощи systemd",
      "level": 4,
      "content": "Если вы хотите, чтобы autossh запускался автоматически, вы можете использовать systemd. Например, вы можете создать файл юнита, подобный этому:\n\n```\n/etc/systemd/system/autossh.service\n```\n\n```\n[Unit]\nDescription=AutoSSH service for port 2222\nAfter=network.target\n\n[Service]\nEnvironment=\"AUTOSSH_GATETIME=0\"\nExecStart=/usr/bin/autossh -M 0 -NL 2222:localhost:2222 -o TCPKeepAlive=yes foo@bar.com\n\n[Install]\nWantedBy=multi-user.target\n```\n\nЗдесь AUTOSSH_GATETIME=0 — это переменная окружения, указывающая, как долго ssh должен быть поднят, прежде чем autossh утвердит успешное подключение. Установка значения 0 укажет autossh игнорировать неудачное подключение ssh. Это может быть полезно при добавлении autossh в автозагрузку. Другие переменные окружения доступны на справочной странице autossh(1). Конечно, вы можете сделать этот юнит более комплексным, если вам это необходимо (для получения дополнительных подробностей смотрите документацию systemd); очевидно, вы можете использовать ваши собственные опции для autossh, но учтите, что флаг -f, подразумевающий AUTOSSH_GATETIME=0, не работает с systemd.\n\nНе забудьте запустить и/или включить службу.\n\nМы также можете отключить ControlMaster, например:\n\n```\nExecStart=/usr/bin/autossh -M 0 -o ControlMaster=no -NL 2222:localhost:2222 -o TCPKeepAlive=yes foo@bar.com\n```\n\n"
    },
    {
      "title": "Альтернатива на случай невозможности запустить демон SSH",
      "level": 3,
      "content": "Для удалённых или headless-серверов, которые полагаются исключительно на SSH, сбой запуска демона SSH (например, после обновления системы) может означать невозможность осуществлять администрирование. Systemd в этом случае может помочь, если воспользоваться опцией OnFailure.\n\nПредположим, что на сервере работает sshd, а качестве запасного варианта выбран telnet. Создайте файл, который показан ниже. Включать telnet.socket не надо!\n\n```\n/etc/systemd/system/sshd.service.d/override.conf\n```\n\n```\n[Unit]\nOnFailure=telnet.socket\n```\n\nЭто всё. Telnet не будет работать, если запущен sshd. Если же sshd не запустится, то можно будет создать сеанс telnet для устранения неисправностей.\n\n"
    },
    {
      "title": "Настройка цвета фона терминала для удалённого хоста",
      "level": 3,
      "content": "Чтобы проще было понять, на каком хосте вы сейчас работаете, можно задать фон терминала для каждой машины.\n\nК сожалению, это работает не для всех терминалов (только для Zsh).\n\n"
    },
    {
      "title": "Настройка для работы в конкретной сети",
      "level": 3,
      "content": "С помощью параметра Match exec можно создавать настройки хостов для работы в конктретных сетях.\n\nНапример, если используется nmcli и соединение настроено (вручную или с помощью DHCP) на использование search-domain:\n\n```\nMatch exec \"nmcli | grep domains: | grep example.com\"\n  CanonicalDomains example.com\n  # Should you use a different username on this network\n  #User username\n  # Use a different known_hosts file (for private network or synchronisation)\n  #UserKnownHostsFile <network>_known_hosts\n```\n\n"
    },
    {
      "title": "Проверка ключей хостов в локальных сетях",
      "level": 3,
      "content": "У серверов, находящихся в разных приватных сетях, IP-адреса могут совпадать. Нужен какой-то способ их различать.\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nЛучшим решением будет воспользоваться рекомендациями из раздела #Настройка для работы в конкретной сети и использовать разные параметры UserKnownHostsFile для разных сетей. Второй способ лучше использовать, если вы работаете в новых или экспериментальных сетях — просто игнорируйте ключи хостов (hostkeys) для приватных сетей:\n\n```\nHost 10.* 192.168.*.* 172.31.* 172.30.* 172.2?.* 172.1?.*\n    # Disable HostKey verification\n    # Trust HostKey automatically\n    StrictHostKeyChecking no\n    # Do not save the HostKey\n    UserKnownHostsFile=/dev/null\n    # Do not display: \"Warning: Permanently Added ...\"\n    LogLevel Error\n```\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\n"
    },
    {
      "title": "Выполнение команд во время входа",
      "level": 3,
      "content": "Если вы работаете в интерактивном сеансе, существует несколько способов выполнить команду при входе в систему:\n\n- отредактируйте файл authorized_keys на удалённом хосте (см. sshd(8) § AUTHORIZED_KEYS FILE FORMAT);\n- отредактируйте файл ~/.ssh/rc на удалённом хосте, если сервер работает с включённой опцией PermitUserRC;\n- отредактируйте файл настроек командной оболочки, например, .bashrc.\n\n"
    },
    {
      "title": "Проброс SSH-агента",
      "level": 3,
      "content": "Проброс SSH-агента позволяет использовать ваши локальные ключи при подключении к серверу. Рекомендуется включать проброс агента только для отдельных хостов.\n\n```\n~/.ssh/config\n```\n\n```\nHost мойсервер.com\n    ForwardAgent yes\n```\n\nПосле этого настройте агент SSH и добавьте ваши локальные ключи утилитой ssh-add.\n\nТеперь после подключения к удалённому серверу вы сможете работать с другими службами с помощью локальных ключей.\n\n"
    },
    {
      "title": "Проверка",
      "level": 3,
      "content": "Проверьте следующие моменты, прежде чем искать решение проблем.\n\n1. Каталог с настройками ~/.ssh и его содержимое должно быть доступно только пользователю (проверьте и клиент, и сервер), а также права на запись в домашнем каталоге должны быть только у пользователя: $ chmod go-w ~ $ chmod 700 ~/.ssh $ chmod 600 ~/.ssh/* $ chown -R $USER ~/.ssh\n1. Убедитесь, что открытый ключ клиента (например, id_rsa.pub) указан в файле ~/.ssh/authorized_keys на сервере;\n1. Убедитесь, что вы не ограничили доступ через SSH параметрами AllowUsers и AllowGroups в настройках сервера;\n1. Проверьте, установил ли пользователь пароль. Иногда новые пользователи не устанавливают пароль до первого входа в систему;\n1. Добавьте параметр LogLevel DEBUG в файл /etc/ssh/sshd_config;\n1. Изучите вывод команды journalctl -xe (запускается с правами root) на предмет сообщений об ошибках;\n1. Перезапустите демон sshd и выполните выход/вход на клиенте и сервере.\n\n```\n$ chmod go-w ~\n$ chmod 700 ~/.ssh\n$ chmod 600 ~/.ssh/*\n$ chown -R $USER ~/.ssh\n```\n\n"
    },
    {
      "title": "Проброс портов",
      "level": 4,
      "content": "Если ваша машина находится за NAT или маршрутизатором (скорее всего так и есть, если речь не идёт о VPS или хосте с публичным IP-адресом), убедитесь, что маршрутизатор пробрасывает входящие SSH-соединения на неё. Узнайте внутренний IP-адрес сервера командой ip addr и настройте маршрутизатор пробрасывать TCP на SSH-порт этого адреса. Подробности смотри на portforward.com.\n\n"
    },
    {
      "title": "SSH запущен и прослушивает?",
      "level": 4,
      "content": "Утилита ss покажет все процессы, прослушивающие TCP-порты:\n\n```\n$ ss --tcp --listening\n```\n\nЕсли в выводе окажется, что система не прослушивает порт ssh, то SSH не запущен: проверьте журнал на предмет сообщений об ошибках.\n\n"
    },
    {
      "title": "Имеются ли правила фаервола, блокирующие соединения?",
      "level": 4,
      "content": "Iptables может блокировать подключения к порту 22. Проверьте это следующей командой:\n\n```\n# iptables -nvL\n```\n\nПросмотрите вывод на предмет правил, которые могут блокировать нужные вам пакеты (цепочка INPUT). Затем, если необходимо, разблокируйте порт командой вида:\n\n```\n# iptables -I INPUT 1 -p tcp --dport 22 -j ACCEPT\n```\n\nИнформацию по настройке межсетевых экранов можно найти в разделе Файрвол.\n\n"
    },
    {
      "title": "Трафик доходит до вашего компьютера?",
      "level": 4,
      "content": "Запустите дамп трафика на компьютере, с которым возникли проблемы:\n\n```\n# tcpdump -lnn -i any port ssh and tcp-syn\n```\n\nБудет показана некоторая базовая информация. Подождите совпадения. После этого попробуйте подключиться вновь. Если вы не видите никакого вывода команды, когда вы пытаетесь подключиться, это значит, что что-то вне вашего компьютера блокирует трафик (это может быть аппаратный фаерволл, роутер NAT и т.д.).\n\n"
    },
    {
      "title": "Ваш провайдер или кто-то еще блокирует нужный порт?",
      "level": 4,
      "content": "Note: **знаете** \n\nВ некоторых случаях провайдер может блокировать порт по умолчанию (SSH порт 22). Чтобы это проверить, создайте сервер на всех интерфейсах (0.0.0.0) и подключитесь удаленно.\n\nЕсли вы получите сообщение об ошибке вроде этого:\n\n```\nssh: connect to host www.inet.hr port 22: Connection refused\n```\n\nэто означает, что порт не был заблокирован провайдером: просто на сервере не запущен SSH для этого порта (смотрите статью Безопасность через неясность).\n\nОднако, если вы получите сообщение об ошибке вроде этого:\n\n```\nssh: connect to host 111.222.333.444 port 22: Operation timed out\n```\n\nэто означает, что что-то отклоняет ваш трафик TCP, предназначенный для порта 22. Как правило, этот порт скрыт либо вашим фаерволлом, либо третьей стороной (например, провайдером, блокирующим и/или отклоняющим входящий трафик на порт 22). Если вы знаете, что фаерволл на вашем компьютере не запущен и Гремлины не размножаются на ваших роутерах и свитчах, это означает, что провайдер блокирует трафик.\n\nЧтобы убедиться в этом, вы можете запустить Wireshark на сервере и \"прослушать\" трафик, предназначенный для порта 22. Поскольку Wireshark является утилитой анализа трафика на уровне 2 , а TCP/UDP используют уровень 3 и выше (смотрите статью TCP/IP), если вы ничего не получаете при создании удаленного подключения, вероятнее всего, что третья сторона блокирует трафик для этого порта на вашем сервере.\n\nУстановите либо tcpdump, либо Wireshark из пакета wireshark-cli.\n\nДля tcpdump:\n\n```\n# tcpdump -ni интерфейс \"port 22\"\n```\n\nДля Wireshark:\n\n```\n$ tshark -f \"tcp port 22\" -i интерфейс\n```\n\nгде интерфейс — сетевой интерфейс для соединения WAN (для проверки выполните ip a). Если вы не получаете никаких пакетов при попытке удаленного подключения, можете быть уверены, что ваш провайдер блокирует входящий на порт 22 трафик.\n\nВы можете просто использовать другой порт, который провайдером не блокируется. Откройте файл /etc/ssh/sshd_config и укажите другой порт. Например, добавьте:\n\n```\nPort 22\nPort 1234\n```\n\nТакже удостоверьтесь, что другие строки \"Port\" закомментированы. Если просто закомментировать строку \"Port 22\" и прописать \"Port 1234\", проблема не будет решена, поскольку sshd будет прослушивать лишь порт 1234. Используйте обе строки для запуска сервера SSH на обоих портах.\n\nПерезапустите сервер sshd.service. Готово! Теперь вам необходимо настроить ваш(и) клиент(ы) на использование другого порта.\n\n"
    },
    {
      "title": "Read from socket failed: connection reset by peer",
      "level": 4,
      "content": "Последние версии openssh иногда выдают подобное сообщение при попытке подключения к старым SSH-серверам. Это можно обойти с помощью различных параметров клиента (подробнее см. ssh_config(5)).\n\nПричиной проблемы может быть алгоритм эллиптических кривых ecdsa-sha2-nistp*-cert-v01@openssh. Его можно отключить, удалив название алгоритма из списка HostKeyAlgorithms.\n\nЕсли это не помогло, возможно, список алгоритмов слишком длинен. Укажите в параметре Ciphers менее длинный список (короче 80 символов). Аналогично можно попробовать сократить список MACs.\n\nТакже стоит изучить обсуждение[устаревшая ссылка 2024-07-30 ⓘ] на форуме openssh.\n\n"
    },
    {
      "title": "\"[ваша командная оболочка]: No such file or directory\" / ssh_exchange_identification problem",
      "level": 3,
      "content": "Одна из возможных причин - необходимость найти абсолютный путь (который возвращает команда whereis -b [ваша командная оболочка], например) в $SHELL, даже если бинарный пакет вашего интерпретатора находится в одной из записей $PATH.\n\n"
    },
    {
      "title": "Ошибки \"Terminal unknown\" и \"Error opening terminal\"",
      "level": 3,
      "content": "Если вы получаете одну из таких ошибок во время входа, это значит, что сервер не может распознать ваш терминал. Приложения ncurses вроде nano могут не запуститься, выдав сообщение \"Error opening terminal\".\n\nПравильным решением будет установить файл terminfo клиентского терминала на сервер. Тогда консольные программы на сервере будут знать, как правильно взаимодействовать с вашим терминалом. Информацию о текущем terminfo можно получить с помощью команды infocmp, после чего нужно выяснить, какому пакету он принадлежит.\n\nЕсли установить файл нормально не удаётся, скопируйте его в домашний каталог на сервере:\n\n```\n$ ssh myserver mkdir -p  ~/.terminfo/${TERM:0:1}\n$ scp /usr/share/terminfo/${TERM:0:1}/$TERM myserver:~/.terminfo/${TERM:0:1}/\n```\n\nПосле выхода и отключения от сервера проблема должна решиться.\n\n"
    },
    {
      "title": "Хак $TERM",
      "level": 4,
      "content": "Можно задать переменную окружения сервера TERM=xterm (например, в файле .bash_profile). Это заглушит сообщения об ошибках и позволит запуститься приложениям ncurses, но результатом может стать странное поведение и графические баги — кроме случая, если контрольные последовательности вашего терминала совпадают с таковыми у xterm.\n\n"
    },
    {
      "title": "Ошибка Connection closed by x.x.x.x [preauth]",
      "level": 3,
      "content": "Если вы получили такое сообщение об ошибке, убедитесь, что настроен верный HostKey:\n\n```\nHostKey /etc/ssh/ssh_host_rsa_key\n```\n\n"
    },
    {
      "title": "id_dsa не используется в OpenSSH 7.0",
      "level": 3,
      "content": "OpenSSH 7.0 прекратил использование открытых ключей DSA из соображений безопасности. Если вам очень нужно именно эти ключи, воспольуйтесь опцией PubkeyAcceptedKeyTypes +ssh-dss (на странице https://www.openssh.com/legacy.html она не упомянута).\n\n"
    },
    {
      "title": "Не удаётся подобрать способ обмена ключами в OpenSSH 7.0",
      "level": 3,
      "content": "OpenSSH 7.0 прекратил использование алгоритма diffie-hellman-group1-sha1, поскольку он ненадёжный и теоретически может быть взломан т.н. атакой Logjam (см. https://www.openssh.com/legacy.html). Если этот алгоритм будет нужен какому-то хосту, ssh выдаст соощение об ошибке следующего содержания:\n\n```\nUnable to negotiate with 127.0.0.1: no matching key exchange method found.\nTheir offer: diffie-hellman-group1-sha1\n```\n\nЛучшим решением будет обновить сервер и отключить использование устаревших алгоритмов. Если это сделать невозможно, вы можете заставить клиент включить алгоритм параметром KexAlgorithms +diffie-hellman-group1-sha1.\n\n"
    },
    {
      "title": "Сеанс tmux/screen прерывается при разрыве соединения SSH",
      "level": 3,
      "content": "Если ваши процессы прерываются при завершении сеанса SSH, возможно, что вы используете активацию сокета и systemd принудительно её убивает. В этом случае есть два решения. Первый — не использовать активацию сокета и заменить ssh.socket на ssh.service. Второй — задать параметр KillMode=process в разделе Service файла ssh@.service.\n\nПараметр KillMode=process может также быть полезен при работе с классическим ssh.service, т.к. он не позволяет убить процесс сессии SSH или процессы screen и tmux при остановке или перезагрузке сервера.\n\n"
    },
    {
      "title": "Сеанс SSH не отвечает",
      "level": 3,
      "content": "SSH реагирует на команды управления XON и XOFF. Он остановится, если вы случайно нажали Ctrl+s. Нажмите Ctrl+q, чтобы продолжить сеанс.\n\n"
    },
    {
      "title": "Broken pipe",
      "level": 3,
      "content": "Если вы пытаетесь установить соединение и получаете ответ Broken pipe на packet_write_wait, попробуйте подключиться в режиме отладки. Посмотрите, если ли в выводе сообщений об ошибках:\n\n```\ndebug3: send packet: type 1\npacket_write_wait: Connection to A.B.C.D port 22: Broken pipe\n```\n\nСтрочка send packet указывает на то, что ответный пакет получен не был. Следовательно, проблема заключается в QoS. Чтобы уменьшить потерю пакетов, задайте значение параметра IPQoS:\n\n```\n/etc/ssh/ssh_config\n```\n\n```\nHost *\n    IPQoS reliability\n```\n\nЗначение reliability (0x04) должно решить проблему. Также можно задать значения 0x00 и throughput (0x08).\n\n"
    },
    {
      "title": "Демон медленно запускается после перезагрузки",
      "level": 3,
      "content": "Если демон запускается необычно долго после перезагрузки (несколько минут), особенно для headless- и виртуализированных серверов, это может быть связано с нехваткой энтропии [8]. Для решения этой проблемы установите Rng-tools или Haveged. Однако обратите внимание на вопросы безопасности, которые обсуждаются в посвящённых этим утилитам статьях.\n\n"
    },
    {
      "title": "Завершение неотвечающего SSH-соединения",
      "level": 3,
      "content": "Если клиентский сеанс больше не отвечает и не завершается командами вызвавшей программы (например, командной оболочки), то завершить его можно последовательным нажатием клавиш Enter, ~ и ..\n\n~ является управляющей последовательностью псевдотерминала (см. ssh(1) § ESCAPE CHARACTERS), которую можно нажимать несколько раз в зависимости от того, какой сеанс необходимо завершить. Например, если вы установили соединение от А к Б, а затем от Б к В, и сеанс Б-В больше не отзывается, завершить его можно нажав Enter и введя ~~.. После этого останется только рабочий сеанс с Б.\n\n"
    },
    {
      "title": "WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!",
      "level": 3,
      "content": "Если клиент выдаёт предупреждение, что ключ ssh-сервера изменился, убедитесь, что новый ключ действительно принадлежит оператору сервера. Если всё в порядке, удалите старый ключ из файла known_hosts командой ssh-keygen -R $SSH_HOST и используйте новый.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Защита от атак перебором\n- Управление ключами OpenSSH: Часть 1 на IBM developerWorks, Часть 2 и Часть 3 на funtoo.org\n- Secure Secure Shell\n\n"
    }
  ]
}