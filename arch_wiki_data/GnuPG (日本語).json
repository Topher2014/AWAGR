{
  "title": "GnuPG (日本語)",
  "url": "https://wiki.archlinux.org/title/GnuPG_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- pacman/パッケージの署名\n- 保存データ暗号化\n- アプリケーション一覧/セキュリティ#暗号化, 署名, ステガノグラフィー\n- OpenPGP\n\n公式サイト によれば:\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 設定 2.1 設定ファイルのディレクトリ 2.2 設定ファイル 2.3 新規ユーザーのデフォルトオプション\n- 3 使い方 3.1 鍵ペアの作成 3.2 鍵一覧 3.3 公開鍵のエクスポート 3.4 公開鍵のインポート 3.5 鍵サーバーを使用する 3.5.1 鍵の送信 3.5.2 鍵の検索と受信 3.5.3 鍵サーバー 3.6 Web Key Directory 3.7 暗号化と復号化 3.7.1 非対称 3.7.2 対称 3.7.3 ディレクトリ\n- 4 鍵の管理 4.1 秘密鍵のバックアップ 4.2 失効証明書のバックアップ 4.3 鍵の編集 4.4 副鍵のエクスポート 4.5 有効期限の延長 4.6 サブキーのローテーション 4.7 鍵の取り消し\n- 5 署名 5.1 署名の作成 5.1.1 ファイルに署名する 5.1.2 ファイルやメッセージにクリア署名 5.1.3 分離署名を作成する 5.1.4 署名の検証 5.2 署名の確認\n- 6 gpg-agent 6.1 設定 6.2 エージェントのリロード 6.3 pinentry 6.4 パスワードのキャッシュ 6.5 無人のパスフレーズ 6.6 SSH エージェント 6.6.1 SSH_AUTH_SOCK の設定 6.6.2 適切な TTY を使うように pinentry を設定 6.6.3 SSH 鍵の追加 6.6.4 SSH 認証に PGP 鍵を使用する\n- 7 スマートカード 7.1 GnuPG のみ設定 7.2 GnuPG と pcscd (PCSC Lite) 7.2.1 常に pcscd を使う 7.2.2 pcscd との共有アクセス 7.2.2.1 マルチアプレットスマートカード 7.2.2.2 SSH 経由でリモートクライアント上のスマートカードを使用する\n- 8 OpenPGP の互換性\n- 9 ヒントとテクニック 9.1 サポートされていない AEAD メカニズムを無効にする 9.2 他のアルゴリズム 9.3 パスワードの暗号化 9.4 信頼モデルの変更 9.5 受取人の id を全て隠す 9.6 キーサインパーティで caff を使う 9.7 長い ID やフィンガープリントを毎回表示する 9.8 カスタム機能\n- 10 トラブルシューティング 10.1 su 10.2 エージェントがファイルの終末についてエラーを表示する 10.3 KGpg 設定のパーミッション 10.4 GNOME on Wayland で SSH エージェントのソケットが上書きされる 10.5 mutt 10.6 gnupg バージョン 2.1 にアップグレードすると鍵が\"消失\"する 10.7 (鍵を受信しようとすると) どの鍵サーバーでも gpg がフリーズする 10.8 スマートカードが検出されない 10.9 gpg: WARNING: server 'gpg-agent' is older than us (x < y) 10.10 IPC 接続の呼び出しに失敗 10.11 汚染された PGP 証明書の軽減 10.12 IPC 応答が無効であり、デバイスの ioctl が不適切 10.13 キーブロックのリソースが存在しません 10.14 サブキーが機能制限されて作成される\n- 11 参照\n\n- 2.1 設定ファイルのディレクトリ\n- 2.2 設定ファイル\n- 2.3 新規ユーザーのデフォルトオプション\n\n- 3.1 鍵ペアの作成\n- 3.2 鍵一覧\n- 3.3 公開鍵のエクスポート\n- 3.4 公開鍵のインポート\n- 3.5 鍵サーバーを使用する 3.5.1 鍵の送信 3.5.2 鍵の検索と受信 3.5.3 鍵サーバー\n- 3.6 Web Key Directory\n- 3.7 暗号化と復号化 3.7.1 非対称 3.7.2 対称 3.7.3 ディレクトリ\n\n- 3.5.1 鍵の送信\n- 3.5.2 鍵の検索と受信\n- 3.5.3 鍵サーバー\n\n- 3.7.1 非対称\n- 3.7.2 対称\n- 3.7.3 ディレクトリ\n\n- 4.1 秘密鍵のバックアップ\n- 4.2 失効証明書のバックアップ\n- 4.3 鍵の編集\n- 4.4 副鍵のエクスポート\n- 4.5 有効期限の延長\n- 4.6 サブキーのローテーション\n- 4.7 鍵の取り消し\n\n- 5.1 署名の作成 5.1.1 ファイルに署名する 5.1.2 ファイルやメッセージにクリア署名 5.1.3 分離署名を作成する 5.1.4 署名の検証\n- 5.2 署名の確認\n\n- 5.1.1 ファイルに署名する\n- 5.1.2 ファイルやメッセージにクリア署名\n- 5.1.3 分離署名を作成する\n- 5.1.4 署名の検証\n\n- 6.1 設定\n- 6.2 エージェントのリロード\n- 6.3 pinentry\n- 6.4 パスワードのキャッシュ\n- 6.5 無人のパスフレーズ\n- 6.6 SSH エージェント 6.6.1 SSH_AUTH_SOCK の設定 6.6.2 適切な TTY を使うように pinentry を設定 6.6.3 SSH 鍵の追加 6.6.4 SSH 認証に PGP 鍵を使用する\n\n- 6.6.1 SSH_AUTH_SOCK の設定\n- 6.6.2 適切な TTY を使うように pinentry を設定\n- 6.6.3 SSH 鍵の追加\n- 6.6.4 SSH 認証に PGP 鍵を使用する\n\n- 7.1 GnuPG のみ設定\n- 7.2 GnuPG と pcscd (PCSC Lite) 7.2.1 常に pcscd を使う 7.2.2 pcscd との共有アクセス 7.2.2.1 マルチアプレットスマートカード 7.2.2.2 SSH 経由でリモートクライアント上のスマートカードを使用する\n\n- 7.2.1 常に pcscd を使う\n- 7.2.2 pcscd との共有アクセス 7.2.2.1 マルチアプレットスマートカード 7.2.2.2 SSH 経由でリモートクライアント上のスマートカードを使用する\n\n- 7.2.2.1 マルチアプレットスマートカード\n- 7.2.2.2 SSH 経由でリモートクライアント上のスマートカードを使用する\n\n- 9.1 サポートされていない AEAD メカニズムを無効にする\n- 9.2 他のアルゴリズム\n- 9.3 パスワードの暗号化\n- 9.4 信頼モデルの変更\n- 9.5 受取人の id を全て隠す\n- 9.6 キーサインパーティで caff を使う\n- 9.7 長い ID やフィンガープリントを毎回表示する\n- 9.8 カスタム機能\n\n- 10.1 su\n- 10.2 エージェントがファイルの終末についてエラーを表示する\n- 10.3 KGpg 設定のパーミッション\n- 10.4 GNOME on Wayland で SSH エージェントのソケットが上書きされる\n- 10.5 mutt\n- 10.6 gnupg バージョン 2.1 にアップグレードすると鍵が\"消失\"する\n- 10.7 (鍵を受信しようとすると) どの鍵サーバーでも gpg がフリーズする\n- 10.8 スマートカードが検出されない\n- 10.9 gpg: WARNING: server 'gpg-agent' is older than us (x < y)\n- 10.10 IPC 接続の呼び出しに失敗\n- 10.11 汚染された PGP 証明書の軽減\n- 10.12 IPC 応答が無効であり、デバイスの ioctl が不適切\n- 10.13 キーブロックのリソースが存在しません\n- 10.14 サブキーが機能制限されて作成される\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "gnupg をインストールしてください。\n\ngnupg をインストールすると、GnuPG がパスフレーズエントリに使用するシンプルな PIN やパスフレーズエントリダイアログのコレクションである pinentry もインストールされます。シェルスクリプト /usr/bin/pinentry は #pinentry で説明されている順番で、どの pinentry ダイアログを使用するかを決定します。\n\nグラフィカルフロントエンドや GnuPG と連携するプログラムを使いたい場合はアプリケーション一覧/セキュリティ#暗号化, 署名, ステガノグラフィーを参照してください。\n\n"
    },
    {
      "title": "設定ファイルのディレクトリ",
      "level": 3,
      "content": "GnuPG では $GNUPGHOME によって全ての設定ファイルを保存するディレクトリが指定されます。デフォルトでは $GNUPGHOME は設定されておらず、代わりに $HOME が使われます。そのためインストール直後は ~/.gnupg ディレクトリが確認できます。スタートアップファイルに次の行を記述することでデフォルト設定を変更できます:\n\n```\nexport GNUPGHOME=\"/path/to/directory\"\n```\n\n"
    },
    {
      "title": "設定ファイル",
      "level": 3,
      "content": "デフォルトの設定ファイルは ~/.gnupg/gpg.conf と ~/.gnupg/dirmngr.conf です。\n\nデフォルトでは、gnupg ディレクトリのパーミッションは 700 に設定されており、ディレクトリのファイルのパーミッションは 600 に設定されています。ファイルの読み書きやアクセスの権限を持っているのはディレクトリの所有者だけです (r,w,x)。これはセキュリティ上の理由で設定されていることなので変更してはいけません。ディレクトリやファイルがこのセキュリティ対策に従っていない場合、ファイルやホームディレクトリのパーミッションが安全ではないという警告が表示されます。\n\nどんな長いオプションも設定ファイルに追加します。2つのダッシュを書かないで、オプションや必要な引数の名前を書いて下さい。スケルトンファイルは /usr/share/doc/gnupg/ にあります。gpg がなんらかの操作のため最初に起動されたとき、~/.gnupg が存在しなければこれらのファイルが ~/.gnupg にコピーされます。#参照 に他の例があります。\n\nまた、pacman がパッケージの署名の検証に使用する設定ファイルは別に存在します。詳しくは pacman-key を見てください。\n\n"
    },
    {
      "title": "新規ユーザーのデフォルトオプション",
      "level": 3,
      "content": "新規ユーザーのデフォルトオプションを設定したい場合、/etc/skel/.gnupg/ に設定ファイルを配置してください。新しいユーザーが追加されると、/etc/skel/.gnupg/ から GnuPG のホームディレクトリにファイルがコピーされます。既存のユーザーのために新しい GnuPG ホームディレクトリを作成できる addgnupghome というスクリプトも存在します:\n\n```\n# addgnupghome user1 user2\n```\n\n上記のコマンドは /home/user1/.gnupg と /home/user2/.gnupg を作成してスケルトンディレクトリからファイルをコピーします。既に GnuPG のホームディレクトリが存在するユーザーはスキップされます。\n\n"
    },
    {
      "title": "鍵ペアの作成",
      "level": 3,
      "content": "鍵ペアを生成するにはターミナルに次を入力:\n\n```\n$ gpg --full-gen-key\n```\n\n上記のコマンドを実行すると複数の質問がきかれます。大抵の場合、以下の設定が必要になります:\n\n- RSA (署名のみ) と RSA (暗号化のみ) 鍵。\n- 鍵長は2048ビットで十分です。4096ビットを使ったところで \"大した効果はありませんし、無駄に時間がかかるようになるだけです\" 。\n- 副鍵の有効期限の設定は技術的には必須ではありませんが、設定することは悪くありません。標準的なユーザーなら、1年間で十分でしょう。たとえ鍵束へのアクセスを失っても、他の人が有効でないことを知ることができるようになります。鍵を作成した後、新しい鍵を再発行しなくても満了日は延長することができます。\n- 名前とメールアドレス。後で同じ鍵に別の識別子を追加できます (複数のメールアドレスが存在する場合など)。\n- コメントは必要ありません。コメントフィールドのセマンティクスは 定義があやふや なため、識別子としては限定的です。\n- 安全なパスフレーズを選ぶようにしてください (セキュリティ#パスワードの管理を参照)。\n\n"
    },
    {
      "title": "鍵一覧",
      "level": 3,
      "content": "- 公開鍵束の鍵の一覧:\n\n```\n$ gpg --list-keys\n```\n\n- 秘密鍵束の鍵の一覧:\n\n```\n$ gpg --list-secret-keys\n```\n\n"
    },
    {
      "title": "公開鍵のエクスポート",
      "level": 3,
      "content": "公開鍵暗号で交換されたメッセージの機密性を保証するのが gpg の主な利用法です。互いの鍵束の公開鍵を交換して、メッセージを暗号化するときに使用します。秘密鍵は必ず漏洩しないようにしてください。機密性が破れてしまいます。\n\n他の人があなたに暗号化したメッセージを送れるようにするには、彼らがあなたの公開鍵を知っている必要があります。\n\n(メールで送る場合などのために) ASCII 版の公開鍵を public.key ファイルとして生成するには:\n\n```\n$ gpg --output public.key --armor --export user-id\n```\n\nあるいは、鍵サーバーで鍵を共有する方法もあります。\n\n- --no-emit-version を使うか、これを設定ファイルに書くことでバージョン番号の表示を抑制できます。\n- user-id を省略して、キーリング内のすべての公開鍵をエクスポートできます。これは、一度に複数の ID を共有したい場合や、別のアプリケーションにインポートする場合に便利です。例: Thunderbird。\n\n"
    },
    {
      "title": "公開鍵のインポート",
      "level": 3,
      "content": "メッセージを暗号化して他の人に送るには、彼らの公開鍵が必要です。公開鍵 (public.key) を自分の公開鍵リングにインポートするには:\n\n```\n$ gpg --import public.key\n```\n\nあるいは、鍵サーバーで公開鍵を見つけます。\n\n特定の Arch Linux パッケージをインストールするためにキー ID をインポートしたい場合は、キーリングの管理 と Makepkg#署名チェック を参照してください。\n\n"
    },
    {
      "title": "鍵の送信",
      "level": 4,
      "content": "自分の公開鍵を公共の PGP 鍵サーバーに登録することで、他の人があなたに直接連絡することなしにあなたの鍵を入手できるようになります:\n\n```\n$ gpg --send-keys user-id\n```\n\n"
    },
    {
      "title": "鍵の検索と受信",
      "level": 4,
      "content": "鍵サーバーの鍵の情報を確認したい場合、次のコマンドを実行:\n\n```\n$ gpg --search-keys user-id\n```\n\n鍵サーバーから鍵をインポートするには:\n\n```\n$ gpg --recv-keys key-id\n```\n\n- 誰でも鍵サーバーに鍵を送ることができます。そのため、ダウンロードした鍵が本当にその人のものであると信用してはいけません。入手した鍵の指紋を、持ち主が別の場所(ブログ、サイト、メール・電話で連絡するなど)で公開している指紋と比較してその鍵の真正性を確かめるべきです。複数の情報源を使うことでその鍵の信頼性は増します。Wikipedia:Public key fingerprint を参照。\n- ID が短いと衝突する可能性があります。インポートされた鍵には全て短い ID が割り当てられます。鍵を受け取るときに完全な指紋か長い鍵 ID を使うことで衝突を回避できます [2]。\n\n"
    },
    {
      "title": "鍵サーバー",
      "level": 4,
      "content": "最も一般的な鍵サーバーは次の通りです:\n\n- Ubuntu Keyserver: 分散型、検証なし、キーは削除不可。\n- Mailvelope Keyserver: 中央型、E メール ID の検証、キーは削除可能。\n- keys.openpgp.org: 中央型、E メール ID の検証、キーは削除可能。サードパーティの署名無し (つまり、Web of Trust のサポートは無し)。\n\nWikipedia:Key server (cryptographic)#Keyserver examples にその他の鍵サーバもあります。\n\n代替の鍵サーバは、#設定ファイルのうちどれかで keyserver オプションを使用することによって指定することができます。例えば:\n\n```\n~/.gnupg/dirmngr.conf\n```\n\n```\nkeyserver hkp://keyserver.ubuntu.com\n```\n\nいつも使用しているサーバが思うように動かない時に、一時的に別のサーバを使用すると便利です。例えば、以下のようにして別のサーバを使用できます:\n\n```\n$ gpg --keyserver hkps://keys.openpgp.org/ --search-keys user-id\n```\n\n- デフォルトの hkps 鍵サーバプールを使用していて、gpg: keyserver receive failed: General error というメッセージで失敗する場合、dirmngr.conf 内で hkp-cacert /usr/share/gnupg/sks-keyservers.netCA.pem を使用して HKPS プールの検証証明書を設定し、古い dirmngr プロセスを kill してください。\n- gpg: keyserver receive failed: Connection refused というメッセージで失敗する場合、別の DNS サーバを使ってみてください。\n- Tor#Torsocks で Tor 経由で鍵サーバに接続することもできます。また、--use-tor コマンドラインオプションもあります。詳細は [3] を参照してください。\n- http_proxy 環境変数を設定し、dirmngr.conf 内で honor-http-proxy を設定すれば、プロキシを使って鍵サーバに接続することもできます。また、設定ファイル内で http-proxy host[:port] を使えば、先の環境変数をオーバーライドすることができます。変更を適用するには、dirmngr.service ユーザーユニットを再起動してください。\n- gpg: keyserver receive failed: Server indicated a failure というメッセージで鍵サーバに接続できない場合、別のポートを使用するように gpg を設定する必要があるのかもしれません。例えば、Ubuntu の鍵サーバで80番ポートを使用するには、keyserver hkp://keyserver.ubuntu.com:80 と設定してください。\n\n"
    },
    {
      "title": "Web Key Directory",
      "level": 3,
      "content": "Web Key Service (WKS) プロトコルは、鍵配布のための新しい 標準で、電子メールドメインが Web Key Directory (WKD) という独自の鍵サーバーを提供するものです。電子メールアドレス (例 : user@example.com) に暗号化するとき、GnuPG (>=2.1.16) は、公開鍵をローカル鍵束にまだ持っていなければ、 HTTPS でそのドメイン (example.com) に照会します。オプション auto-key-locate は、このメールアドレスのローカル鍵束に鍵がない場合、WKD プロトコルを使って鍵を探します。\n\n```\n# gpg --recipient user@example.org --auto-key-locate --encrypt doc\n```\n\nWKD をサポートしているメールプロバイダーの一覧は GnuPG Wiki を参照してください。メールアドレスのドメインを自分で管理している場合は、このガイドに従って、自分のドメインで WKD を有効にすることができます。あなたの鍵が WKD で見つかるかどうかを確認するには、このウェブインターフェイスが使用できます。\n\n"
    },
    {
      "title": "非対称",
      "level": 4,
      "content": "暗号化や復号化をするときは複数の秘密鍵を使用することが可能です。複数の鍵を使うときは使用する鍵を選択する必要があります。-u <user-id> オプションや --local-user <user-id> オプションを使うことで選択できます。このオプションを使うとデフォルトの鍵を使用する代わりに指定された鍵を使用します。先に#鍵の作成が必要です。\n\n(テキストでメッセージをコピー&ペーストするのに適している) ASCII armor を使ってファイルを暗号化するには、次を使用:\n\n```\n$ gpg --encrypt --armor secret.txt\n```\n\n単に暗号化だけしたいときは --armor は不要です。\n\n- 受取人を変更したい場合は -r <user-id> (または --recipient <user-id>) オプションで変更できます。\n- 暗号メッセージに受取人の鍵 ID を入れたくないときは --recipient のかわりに -R <user-id> または --hidden-recipient <user-id> を追加してください。メッセージの受取人を隠蔽して、トラフィックの解析に対する対抗策になります。\n- バージョン番号を出力したくないときは --no-emit-version を追加してください。または設定ファイルに同じ設定を追加してください。\n\nファイルを復号化するには、次のコマンドを使用:\n\n```\n$ gpg --decrypt secret.txt.asc\n```\n\nパスフレーズの入力が求められます。復号化するには送信者の公開鍵をインポートしてある必要があります。\n\n"
    },
    {
      "title": "対称",
      "level": 4,
      "content": "対称暗号化では鍵を生成する必要がなくパスフレーズだけでデータを暗号化できます。対称暗号化を使用するするには --symmetric または -c を使用します:\n\n```\n$ gpg -c doc\n```\n\n例:\n\n- パスフレーズを使って対称暗号で doc を暗号化。\n- AES-256 暗号アルゴリズムを使ってパスフレーズを暗号化。\n- SHA-512 ダイジェストアルゴリズムを使ってパスフレーズをハッシュ化。\n- 65536回繰り返しパスフレーズをハッシュ化。\n\n```\n$ gpg -c --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-count 65536 doc\n```\n\n対称暗号化された doc.gpg をパスフレーズで復号化して doc として同じディレクトリに出力するには:\n\n```\n$ gpg --output doc --decrypt doc.gpg\n```\n\n"
    },
    {
      "title": "ディレクトリ",
      "level": 4,
      "content": "ディレクトリの暗号化・復号化は gpgtar(1) で行うことができます。\n\n暗号化:\n\n```\n$ gpgtar -c -o dir.gpg dir\n```\n\n復号化:\n\n```\n$ gpgtar -d dir.gpg\n```\n\n"
    },
    {
      "title": "秘密鍵のバックアップ",
      "level": 3,
      "content": "秘密鍵をバックアップするには以下を実行:\n\n```\n$ gpg --export-secret-keys --armor <user-id> > privkey.asc\n```\n\ngpg のリリース 2.1 からデフォルトの挙動が変わっており、たとえ鍵の作成時にパスワードを設定しなかった場合でも上記のコマンドを実行したときにパスフレーズによる保護が必須になっています。エクスポートされたファイルを入手してしまえば、パスフレーズを知らなくてもファイルを暗号化したり署名を加えることができてしまうためです。\n\n秘密鍵のバックアップをインポートするには:\n\n```\n$ gpg --import privkey.asc\n```\n\n"
    },
    {
      "title": "失効証明書のバックアップ",
      "level": 3,
      "content": "失効証明書は、新しく生成されたキーに対して自動的に生成されます。これらはデフォルトで ~/.gnupg/openpgp-revocs.d/ にあります。証明書のファイル名は、取り消すキーのフィンガープリントです。 失効証明書は、ユーザーが後で次を使用して手動で生成することもできます。\n\n```\n$ gpg --gen-revoke --armor --output revcert.asc user-id\n```\n\nこの証明書は、紛失または侵害された場合に #鍵の取り消し に使用できます。バックアップは、秘密鍵にアクセスできなくなったため、上記のコマンドで新しい失効証明書を生成できない場合に役立ちます。必要に応じて印刷して手で入力できるほど短いです。\n\n"
    },
    {
      "title": "鍵の編集",
      "level": 3,
      "content": "- gpg --edit-key <user-id> コマンドを実行するとメニューが表示され、鍵管理に関連するほとんどの作業を行うことができます。以下は満了日を設定する例です:\n\n```\n$ gpg --edit-key <user-id>\n> key number\n> expire yyyy-mm-dd\n> save\n> quit\n```\n\n便利なコマンド:\n\n```\n> passwd       # change the passphrase\n> clean        # compact any user ID that is no longer usable (e.g revoked or expired)\n> revkey       # revoke a key\n> addkey       # add a subkey to this key\n> expire       # change the key expiration time\n```\n\n- 公開鍵の ASCII バージョンを生成 (例: メールなどで配るため):\n\n```\n$ gpg --armor --output public.key --export <user-id>\n```\n\n- PGP 公開鍵サーバーに鍵を登録して、他の人があなたに直接連絡しなくても鍵を取得できるようにする:\n\n```\n$ gpg  --keyserver pgp.mit.edu --send-keys <key-id>\n```\n\n- ユーザー Bob あてに署名と暗号化:\n\n```\n$ gpg -se -r Bob file\n```\n\n- クリアテキスト署名を作成:\n\n```\n$ gpg --clearsign file\n```\n\n"
    },
    {
      "title": "副鍵のエクスポート",
      "level": 3,
      "content": "複数のデバイスで同じ鍵を使い回す場合、マスター鍵を分離させて、セキュリティが低いシステムでは暗号化に必要な副鍵だけを使いたいという状況が考えられます。\n\nまず、エクスポートしたい副鍵を確認してください:\n\n```\n$ gpg -K\n```\n\nエクスポートする副鍵だけを選択:\n\n```\n$ gpg -a --export-secret-subkeys [subkey id]! > /tmp/subkey.gpg\n```\n\nここで作業を終えても良いですが、パスフレーズの変更もしておくと安全です。一時フォルダに鍵をインポートします:\n\n```\n$ gpg --homedir /tmp/gpg --import /tmp/subkey.gpg\n$ gpg --homedir /tmp/gpg --edit-key <user-id>\n> passwd\n> save\n$ gpg --homedir /tmp/gpg -a --export-secret-subkeys [subkey id]! > /tmp/subkey.altpass.gpg\n```\n\nこれで、他のデバイスで /tmp/subkey.altpass.gpg を使うことができます。\n\n"
    },
    {
      "title": "有効期限の延長",
      "level": 3,
      "content": "副鍵を設定して一定期間後に満了したら、新しい副鍵を作成できます。他のユーザーが鍵束を更新できるように数週間前に行うようにしましょう。\n\n- 新しい副鍵を作成 (署名と暗号化の鍵の両方)\n\n```\n$ gpg --edit-key <user-id>\n> addkey\n```\n\nそして質問に答えて下さい (推奨される設定については前のセクションを参照)。\n\n- 変更を保存:\n\n```\n> save\n```\n\n- 鍵サーバーにアップデート:\n\n```\n$ gpg  --keyserver pgp.mit.edu --send-keys <user-id>\n```\n\nまた、この鍵を複数のコンピュータで使用する場合は、公開鍵(新しい署名付き有効期限付き)をエクスポートして、それらのマシンでインポートすることもできます。\n\n```\n$ gpg --export --output pubkey.gpg user-id\n$ gpg --import pubkey.gpg\n```\n\n秘密鍵の再エクスポートやバックアップの更新は必要ありません。マスター秘密鍵自体に有効期限がなく、公開鍵やサブ鍵に残された有効期限の署名があればよいのです。\n\n"
    },
    {
      "title": "サブキーのローテーション",
      "level": 3,
      "content": "また、期限切れのサブキーを完全に使用しないようにすることもできます。その場合、新しいサブキーを作成します。キーリングの更新期間を考慮し、数週間前に行うことを推奨します。\n\n新しいサブキーの作成(署名用と暗号化用の両方に対して実行)\n\n```\n$ gpg --edit-key user-id\n> addkey\n```\n\nその後、表示される質問に答えます(推奨設定については #鍵ペアの作成 を参照)\n\n変更の保存\n\n```\n> save\n```\n\nキーサーバーへの更新\n\n```\n$ gpg --keyserver pgp.mit.edu --send-keys user-id\n```\n\nまた、秘密鍵のバックアップのために、新しい秘密鍵のコピーをエクスポートする必要があります。詳細は #秘密鍵のバックアップ を参照してください。\n\n"
    },
    {
      "title": "鍵の取り消し",
      "level": 3,
      "content": "鍵が侵害された、置き換えられた、使用されなくなった、またはパスフレーズを忘れた場合は、キーの取り消しを実行する必要があります。これは、鍵を鍵の失効証明書とマージすることによって行われます。\n\n鍵ペアにアクセスできなくなった場合は、まず#公開鍵のインポートして独自の鍵をインポートします。 次に、キーを失効させるために、#失効証明書のバックアップ で保存したファイルをインポートします。\n\n```\n$ gpg --import revcert.asc\n```\n\nここで、取り消しを公開する必要があります。 #鍵サーバーを使用するで過去に PGP サーバーを使用したことがある場合は、取り消された鍵を公開 PGP サーバーに送信します。それ以外の場合は、取り消された鍵をファイルにエクスポートし、通信パートナーに配布します。\n\n"
    },
    {
      "title": "署名",
      "level": 2,
      "content": "署名は文章を証明します。文章が改変された場合、署名の検証に失敗します。公開鍵を使用して文章を暗号化する暗号化とは違って、署名はユーザーの秘密鍵を使って作成されます。署名された文章を受け取った人は送り主の公開鍵を使って署名を検証できます。\n\n"
    },
    {
      "title": "ファイルに署名する",
      "level": 4,
      "content": "ファイルに署名するには --sign または -s フラグを使います:\n\n```\n$ gpg --output doc.sig --sign doc\n```\n\n上記のコマンドは暗号化も行ってファイルをバイナリ形式で保存します。\n\n"
    },
    {
      "title": "ファイルやメッセージにクリア署名",
      "level": 4,
      "content": "バイナリ形式に圧縮しないでファイルに署名するには:\n\n```\n$ gpg --clearsign doc\n```\n\n上記のコマンドは文章を ASCII-armored 署名でラッピングしますが、文章に変更は加えられません。\n\n"
    },
    {
      "title": "分離署名を作成する",
      "level": 4,
      "content": "文章やファイルとは別に署名ファイルを作成したい場合、--detach-sig フラグを使ってください:\n\n```\n$ gpg --output doc.sig --detach-sig doc\n```\n\n上記の方法はソフトウェアプロジェクトを配布するときによく用いられます。署名書を検証することで第三者によってファイルが改竄されていないことが確認できます。\n\n"
    },
    {
      "title": "署名の検証",
      "level": 4,
      "content": "署名を検証するには --verify フラグを使います:\n\n```\n$ gpg --verify doc.sig\n```\n\ndoc.sig は検証したい署名に置き換えてください。\n\nファイルの検証と復号化を同時に行いたいお場合、--decrypt フラグを使ってください。\n\n分離署名を検証する場合、ファイルと署名の両方が必要になります。例えば、Arch Linux の ISO を検証する場合:\n\n```\n$ gpg --verify archlinux-version.iso.sig\n```\n\narchlinux-version.iso が同じディレクトリに存在していなければなりません。\n\n"
    },
    {
      "title": "署名の確認",
      "level": 3,
      "content": "署名を確認するには、--verify フラグを使用します。\n\n```\n$ gpg --verify doc.sig\n```\n\nここで doc.sig は、検証したい署名を含む署名付きファイルです。\n\n分離された署名を検証する場合、署名されたデータファイルと署名ファイルの両方が検証時に存在する必要があります。例えば、Arch Linux の最新の iso を検証する場合、次のようになります。\n\n```\n$ gpg --verify archlinux-version.iso.sig\n```\n\nここで archlinux-version.iso は同じディレクトリにある必要があります。\n\nまた、第2引数で署名付きデータファイルを指定することも可能です。\n\n```\n$ gpg --verify archlinux-version.iso.sig /path/to/archlinux-version.iso\n```\n\n署名に加えて暗号化されている場合は、復号化を行うだけで署名も検証されます。\n\n"
    },
    {
      "title": "gpg-agent",
      "level": 2,
      "content": "gpg-agent はキーチェインにパスワードをリクエストしたりキャッシュしたりするのに使われるデーモンです。メールクライアントなど外部のプログラムから GnuPG を利用する場合に便利です。gnupg には systemd ユーザーソケットが付属しており、デフォルトで有効になります: gpg-agent.socket, gpg-agent-extra.socket, gpg-agent-browser.socket, gpg-agent-ssh.socket, dirmngr.socket。\n\n- gpg はメインの gpg-agent.socket を使って gpg-agent デーモンに接続します。\n- gpg-agent-extra.socket はリモート環境から Unix ドメインソケットの転送を設定します。秘密鍵をリモート環境に移さなくてもリモート環境で gpg が使えるようになります。詳しくは gpg-agent(1) を参照。\n- The gpg-agent-browser.socket allows web browsers to access the gpg-agent daemon.\n- SSH は gpg-agent-ssh.socket を使って ssh-add プログラムによって追加された SSH 鍵をキャッシュします。必要な設定は #SSH エージェントを見てください。\n- dirmngr.socket は鍵サーバーへの接続を処理する GnuPG デーモンを起動します。\n\n"
    },
    {
      "title": "設定",
      "level": 3,
      "content": "gpg-agent は ~/.gnupg/gpg-agent.conf ファイルで設定することができます。設定オプションは gpg-agent(1) に記載されています。例えば、未使用の鍵の cache ttl を変更することができます:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\ndefault-cache-ttl 3600\n```\n\n```\n$ /usr/lib/gnupg/gpg-preset-passphrase --preset XXXXXX\n```\n\nXXXX は鍵輪に置き換えてください。鍵輪の値は gpg --with-keygrip -K を実行することで取得できます。パスフレーズは gpg-agent が再起動されるまで保存されます。default-cache-ttl の値を設定した場合、そちらが優先されます。\n\n"
    },
    {
      "title": "エージェントのリロード",
      "level": 3,
      "content": "設定を変更した後は、gpg-connect-agent でエージェントをリロードしてください:\n\n```\n$ gpg-connect-agent reloadagent /bye\n```\n\nシェルに OK と出力されます。\n\nしかし、エージェント設定に keep-screen が追加されている場合など、再起動だけでは十分でないこともあります。 この場合、まず進行中の gpg-agent プロセスを kill してから、上記で説明したように再起動する必要があります。\n\n"
    },
    {
      "title": "pinentry",
      "level": 3,
      "content": "gpg-agent は pinentry-program stanza を使用して、パスフレーズの入力を促す際に、特定の pinentry ユーザーインターフェイスを使用するように設定できます。例えば、以下の通りです。\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\npinentry-program /usr/bin/pinentry-curses\n```\n\n他のも様々な pinentry プログラムがあります。pacman -Ql pinentry | grep /usr/bin/ を参照してください。\n\n変更を行った後は、エージェントのリロードを忘れないでください。\n\n"
    },
    {
      "title": "パスワードのキャッシュ",
      "level": 3,
      "content": "GnuPG のパスワードをセッションの間だけ記憶させたい場合、max-cache-ttl と default-cache-ttl を高い値に設定してください:\n\n```\ngpg-agent.conf\n```\n\n```\nmax-cache-ttl 60480000\ndefault-cache-ttl 60480000\n```\n\n詳しくは #gpg-agent を参照。\n\n"
    },
    {
      "title": "無人のパスフレーズ",
      "level": 3,
      "content": "GnuPG 2.1.0 から gpg-agent と pinentry の利用が必須になりました。これによって --passphrase-fd 0 コマンドラインオプションによって STDIN からパイプで渡されたパスフレーズの後方互換性が損ねられています。古いリリースと同じような機能を使うには2つのことをする必要があります:\n\nまず、gpg-agent の設定を編集して loopback pinentry モードを許可してください:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\nallow-loopback-pinentry\n```\n\ngpg-agent プロセスが実行している場合は再起動して変更を適用します。\n\n次に、更新する必要があるアプリケーションに以下のようにコマンドラインパラメータを含めて loopback モードを使用します:\n\n```\n$ gpg --pinentry-mode loopback ...\n```\n\nもしくは、コマンドラインで設定ができない場合、オプションを設定に追加します:\n\n```\n~/.gnupg/gpg.conf\n```\n\n```\npinentry-mode loopback\n```\n\n"
    },
    {
      "title": "SSH エージェント",
      "level": 3,
      "content": "gpg-agent には OpenSSH エージェントのエミュレーション機能が存在します。既に GnuPG スイートを使っているのであれば、SSH 鍵をキャッシュするのに使うことが可能です。さらに、パスフレーズを管理するのに GnuPG エージェントの PIN エントリダイアログを使えます。\n\n"
    },
    {
      "title": "SSH_AUTH_SOCK の設定",
      "level": 4,
      "content": "SSH が ssh-agent の代わりに gpg-agent を使うように SSH_AUTH_SOCK を設定してください。シェルのタイプに関係なくプロセスが gpg-agent インスタンスを使うようにするには pam_env を使用します:\n\n```\n~/.pam_environment\n```\n\n```\nSSH_AGENT_PID\tDEFAULT=\nSSH_AUTH_SOCK\tDEFAULT=\"${XDG_RUNTIME_DIR}/gnupg/S.gpg-agent.ssh\"\n```\n\n- SSH_AUTH_SOCK を手動で設定する場合、GNUPGHOME をカスタマイズしているときはソケットの場所が異なる可能性があるので注意してください。以下の bash の例を使用するか、SSH_AUTH_SOCK を gpgconf --list-dirs agent-ssh-socket の値に変更してください。\n- GNOME Keyring がインストールされている場合、 その ssh コンポーネントを無効化する必要があります。そうしないと、SSH_AUTH_SOCK を上書きしてしまいます。\n\nまたは、Bash を使う場合:\n\n```\n~/.bashrc\n```\n\n```\nunset SSH_AGENT_PID\nif [ \"${gnupg_SSH_AUTH_SOCK_by:-0}\" -ne $$ ]; then\n  export SSH_AUTH_SOCK=\"$(gpgconf --list-dirs agent-ssh-socket)\"\nfi\n```\n\n"
    },
    {
      "title": "適切な TTY を使うように pinentry を設定",
      "level": 4,
      "content": "gpg-agent(1) にあるように、ユーザーを X セッションに切り替えた場合は GPG_TTY も設定して TTY を更新してください。例:\n\n```\n~/.bashrc\n```\n\n```\n# Set GPG TTY\nexport GPG_TTY=$(tty)\n\n# Refresh gpg-agent tty in case user switches into an X session\ngpg-connect-agent updatestartuptty /bye >/dev/null\n```\n\n複数の端末を同時に使用し、ssh コマンドを実行した同じ端末から pinentry-curses で gpg-agent がパスフレーズを要求するようにしたい場合、SSH 設定ファイルに以下を追加してください。これにより、ssh コマンドを実行するたびに TTY がリフレッシュされるようになります [6]。\n\n```\n~/.ssh/config\n```\n\n```\nMatch host * exec \"gpg-connect-agent UPDATESTARTUPTTY /bye\"\n```\n\nなお、環境変数 GPG_TTY が設定されていないと動作しません。\n\n"
    },
    {
      "title": "SSH 鍵の追加",
      "level": 4,
      "content": "gpg-agent が起動していれば ssh-agent と同じように ssh-add で鍵を追加できます。追加された鍵は ~/.gnupg/sshcontrol ファイルに保存されます。パスフレーズが必要になったときは毎回 pinentry ダイアログが表示されます。パスフレーズのキャッシュは ~/.gnupg/gpg-agent.conf ファイルで制御します。以下の例では gpg-agent で鍵を3時間キャッシュします:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\ndefault-cache-ttl-ssh 10800\nmax-cache-ttl-ssh 10800\n```\n\n"
    },
    {
      "title": "SSH 認証に PGP 鍵を使用する",
      "level": 4,
      "content": "PGP 鍵を SSH 鍵として使うこともできます。鍵のメンテナンスを楽にして SSH 鍵をキーカードに保存できます。認証機能を有効にして鍵を作成する必要があります (#カスタム機能を参照)。SSH 認証に PGP 鍵を使用することで得られる様々な利点があります。\n\n- SSH キーを維持する必要がなくなるため、キーのメンテナンスが削減されます。\n- 認証キーをスマートカードに保存する能力。GnuPG はカードが利用可能なときにキーを自動的に検出し、エージェントに追加します(ssh-add -l または ssh-add -L で確認)。キーのコメントは次のようなものであるべきです:openpgp:key-id または cardno:card-id。\n\nGPG/SSH キーの公開キー部分を取得するには、gpg --export-ssh-key gpg-key を実行します。キーが認証可能であっても、このコマンドが \"Unusable public key\" で失敗する場合は、! サフィックスを追加します ([7])。\n\nGPG キーをキーカードに持っていない場合、SSH キーとして認識されるように $GNUPGHOME/sshcontrol にキーを追加する必要があります。キーがキーカードにある場合、その keygrip は sshcontrol に暗黙的に追加されます。そうでない場合、次の方法でキーの keygrip を取得します:\n\n```\n$ gpg --list-keys --with-keygrip\n```\n\n```\nsub   rsa4096 2018-07-25 [A]\n      Keygrip = 1531C8084D16DC4C36911F1585AF0ACE7AAFD7E7\n```\n\nその後、sshcontrol をこのように編集します。keygrip を追加するのは一度だけの操作です。追加のキーを追加する場合を除いて、ファイルを再度編集する必要はありません。\n\n```\n$GNUPGHOME/sshcontrol\n```\n\n```\n1531C8084D16DC4C36911F1585AF0ACE7AAFD7E7\n```\n\n"
    },
    {
      "title": "スマートカード",
      "level": 2,
      "content": "GnuPG は、スマートカードリーダとのインターフェイスとして scdaemon を使用します。詳細は scdaemon(1) man ページを参照してください。\n\n"
    },
    {
      "title": "GnuPG のみ設定",
      "level": 3,
      "content": "GnuPG ベース以外のカードを使う予定がない場合は、~/.gnupg/scdaemon.conf の reader-port パラメータを確認してください。'0' が最初に利用できるシリアルポートリーダーを、'32768' (デフォルト) が最初の USB リーダーを示しています。\n\n"
    },
    {
      "title": "GnuPG と pcscd (PCSC Lite)",
      "level": 3,
      "content": "pcscd(8) は、スマートカードへのアクセスを管理するデーモンです (SCard API)。(GnuPG の内臓の CCID サポートを使うなどして) GnuPG の scdaemon でスマートカードと直接接続できない場合、このデーモンは PCSC Lite ドライバを使用するスマートカードを見つけようとします。\n\npscsd を使うには、pcsclite と ccid をインストールしてください。そして、pcscd.service を開始し、(このサービスを永続的に使用する場合は) 有効化してください。あるいは、pcscd.socket を開始/有効化することで、必要なときにだけデーモンをアクティブ化させることもできます。\n\n"
    },
    {
      "title": "常に pcscd を使う",
      "level": 4,
      "content": "opensc ドライバを使用するスマートカード (一部の国々の ID カードがこれに該当します) を使う場合は、GnuPG の設定に注意する必要があります。特に設定しないと、gpg --card-status を実行した時に以下のようなメッセージが表示されるかもしれません:\n\n```\ngpg: selecting openpgp failed: ec=6.108\n```\n\nデフォルトでは、scdaemon はデバイスに直接接続しようとします。カードリーダが他のプロセスによって使用されている場合、この接続は失敗します。例えば、pcscd デーモンが OpenSC によって使用されている場合などです。この問題を解決するには、scdaemon と opensc が互いにうまく機能するようにするために、opensc のものと同じドライバを使用する必要があります。scdaemon が pcscd を使用するようにするには、~/.gnupg/scdaemon.conf から reader-port を削除し、libpcsclite.so ライブラリへのパスを指定し、pcscd を確実に使用させるために ccid を無効化する必要があります:\n\n```\n~/.gnupg/scdaemon.conf\n```\n\n```\npcsc-driver /usr/lib/libpcsclite.so\ncard-timeout 5\ndisable-ccid\n```\n\nOpenSC を使用しない場合は、scdaemon(1) を確認してください。\n\n"
    },
    {
      "title": "pcscd との共有アクセス",
      "level": 4,
      "content": "GnuPG scdaemon は、pcscd への接続時に PCSC_SHARE_EXCLUSIVE フラグを使用する唯一の一般的な pcscd クライアントです。電子識別 にリストされているブラウザやプログラムで使用される OpenSC PKCS#11 などの他のクライアントは、単一のスマートカードへの同時アクセスを許可する PCSC_SHARE_SHARED を使用しています。pcscd は、他のクライアントが接続されている間はスマートカードへの排他的アクセスを与えません。これは、GnuPG スマートカード機能を使用するには、開いているブラウザウィンドウをすべて閉じるか、その他の不便な操作を行う必要があることを意味します。バージョン 2.2.28 LTS および 2.3.0 以降では、scdaemon.conf ファイルを変更し、その行末に pcsc-shared を追加することで共有アクセスを有効にできます。\n\nOpenSC PKCS#11 で YubiKey または他のマルチアプレット USB ドングルを使用すると、OpenSC が Yubikey を OpenPGP から PIV アプレットに切り替えて、scdaemon が壊れるという問題が発生する可能性があります。\n\nOpenSC に OpenPGP アプレットも使用させることで、この問題を回避できます。/etc/opensc.conf ファイルを開き、Yubikey を検索して、driver = \"PIV-II\"; 行を driver = \"openpgp\"; に変更します。そのようなエントリがない場合は、pcsc_scan を使用します。リセットするための答えを検索して ATR: 12 34 56 78 90 AB CD ... 次に、新しいエントリを作成します。\n\n```\n/etc/opensc.conf\n```\n\n```\n...\ncard_atr 12:23:34:45:67:89:ab:cd:... {\n    name = \"YubiKey Neo\";\n    driver = \"openpgp\"\n}\n...\n```\n\nその後、pkcs11-tool -O --login を使用して、OpenPGP アプレットがデフォルトで選択されていることをテストします。この変更を適用するには、ブラウザなどの他の PKCS#11 クライアントを再起動する必要があります。\n\nSSH 経由でマシンにログインし、pcscd 経由で接続されたデバイスを使用しようとすると、次のようなエラーが発生します:\n\n```\ngpg: selecting card failed: No such device\ngpg: OpenPGP card not available: No such device\n```\n\nこれは、Polkit がローカル クライアントへのアクセスを制限しているためです。これを修正するには、特定のユーザーを許可するルールを追加します。以下のルールにより、wheel グループ内のすべてのユーザーが pcscd 経由でデバイスにアクセスできます:\n\n```\n/etc/polkit-1/rules.d/99-pcscd.rules\n```\n\n```\npolkit.addRule(function(action, subject) {\n    if (action.id == \"org.debian.pcsc-lite.access_card\" &&\n        subject.isInGroup(\"wheel\")) {\n        return polkit.Result.YES;\n    }\n});\npolkit.addRule(function(action, subject) {\n    if (action.id == \"org.debian.pcsc-lite.access_pcsc\" &&\n        subject.isInGroup(\"wheel\")) {\n        return polkit.Result.YES;\n    }\n});\n```\n\nファイルを作成したら、必ず polkit.service を 再起動 してください。\n\n"
    },
    {
      "title": "OpenPGP の互換性",
      "level": 2,
      "content": "GnuPG は OpenPGP 形式の実装として始まりました。現在、プロジェクトは RFC 4880 に基づいており、RFC 9580 (RFC 4880 に代わる) はサポートしていません。\n\nただし、バージョン 2.4.0 (2022 年 12 月以降) 以降、GnuPG は IETF プロセスの外でフォーマットへの変更と拡張をロールアウトすることを選択しました (draft-koch-librepgp を参照)\n\nGnuPG 独自の形式 (OpenPGP 標準 から分岐したもの) のほとんどは \"バージョン 5\" を採用しており (このバージョンは IETF OpenPGP 標準では使用されていません)、非互換性が生じます。\n\n- GnuPG の \"バージョン 5\" キーは、異なるフィンガープリントを使用します (SHA-256 を使用しているため、より長くなります)\n- 新しい対称的に暗号化されたデータパケット形式 (OCB Encrypted Data Packet))が追加されました。この形式のサポートは、デフォルトで積極的に有効になっている \"機能フラグ\" によって通知されます。 #サポートされていない AEAD メカニズムを無効にする を参照してください。\n- 新しい Post-Quantum Cryptography 形式 これも IETF プロセスから分岐したものです ([8])\n\n外部レビューでは、GnuPG による形式拡張の健全性について懸念が生じています (\"A Summary of Known Security Issues in LibrePGP\" を参照)\n\nGnuPG 固有のフォーマット変更に関する懸念事項のより詳細な議論については、\"A Critique on “A Critique on the OpenPGP Updates” を参照してください。\n\nArch Linux の立場は、OpenPGP 標準との互換性を優先しています。 この目的のために、デフォルトで RFC4880bis を戻す などの gnupg パッケージにパッチが適用されます。 これにより、他の OpenPGP 実装との長期的な互換性が保証され、デフォルトでベンダーロックインが回避されます。\n\n"
    },
    {
      "title": "サポートされていない AEAD メカニズムを無効にする",
      "level": 3,
      "content": "gnupg 2.4 では、gpg は GnuPG 固有の AEAD 暗号化メカニズム (OCB に基づく) のサポートを通知するキーを生成します。ただし、AEAD のこのフレーバーは、他の OpenPGP 実装ではサポートされていません。\n\n多くのダウンストリームは GnuPG ソースにパッチを適用 してこの新しいデフォルトを削除しようとしますが、--full-gen-key OCB ベースのカスタム AEAD 暗号化メカニズムが新しいキーに設定されています。\n\nGnuPG のカスタム AEAD がキーに設定されているかどうかは、gpg 自体を使用して検査できます:\n\n```\n$ gpg --expert --edit-key <FINGERPRINT>\ngpg> showpref\n[ultimate] (1). Foobar McFooface (test) <foobar@mcfooface.com>\n    Cipher: AES256, AES192, AES, 3DES\n    AEAD: OCB\n    Digest: SHA512, SHA384, SHA256, SHA224, SHA1\n    Compression: ZLIB, BZIP2, ZIP, Uncompressed\n    Features: MDC, AEAD, Keyserver no-modify\n```\n\nこのメカニズムは次のように無効にできます:\n\n```\ngpg> setpref AES256 AES192 AES SHA512 SHA384 SHA256 SHA224 ZLIB BZIP2 ZIP\nSet preference list to:\n    Cipher: AES256, AES192, AES, 3DES\n    AEAD:\n    Digest: SHA512, SHA384, SHA256, SHA224, SHA1\n    Compression: ZLIB, BZIP2, ZIP, Uncompressed\n    Features: MDC, Keyserver no-modify\nReally update the preferences? (y/N) y\n```\n\n"
    },
    {
      "title": "他のアルゴリズム",
      "level": 3,
      "content": "強力なアルゴリズムを使用したい場合:\n\n```\n~/.gnupg/gpg.conf\n```\n\n```\n...\n\npersonal-digest-preferences SHA512\ncert-digest-algo SHA512\ndefault-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed\npersonal-cipher-preferences TWOFISH CAMELLIA256 AES 3DES\n```\n\nGnuPG の最新版では、デフォルトのアルゴリズムとして SHA256 と AES が使われており、どちらも殆どの場合安全です。しかしながら、2.1 以前の古い GnuPG を使っている場合や、さらに高いセキュリティを求めたい場合、上記のように設定するようにしてください。\n\n"
    },
    {
      "title": "パスワードの暗号化",
      "level": 3,
      "content": "パスワードを暗号化すれば、設定ファイルに平文で書き込まれなくなります。メールのパスワードなどが良い例でしょう。\n\nまずパスワードを記述したファイルを作成してください。パスワードの後に空行を一行だけ追加しておく必要があります。そうしないとファイルを評価するときに gpg がエラーメッセージを返します。\n\nそして次を実行:\n\n```\n$ gpg -e -a -r <user-id> your_password_file\n```\n\n-e は encrypt、-a は armor (ASCII 出力)、-r は受取人のユーザー ID です。\n\n新しく your_password_file.asc ファイルが作られます。\n\n"
    },
    {
      "title": "信頼モデルの変更",
      "level": 3,
      "content": "デフォルトでは GnuPG は信頼モデルとして Web of Trust を使います。Web of Trust から Trust on First に変更することが可能です。鍵を追加するときに --trust-model=tofu を追加するか GnuPG の設定ファイルにオプションを追加してください。詳細は GnuPG メーリングリストのメール を参照。\n\n"
    },
    {
      "title": "受取人の id を全て隠す",
      "level": 3,
      "content": "デフォルトでは暗号メッセージには受取人の鍵 ID が含まれます。hidden-recipient <user-id> を使うことで暗号化するときに ID は削除することが可能です。全ての受取人で ID を削除するには設定ファイルに throw-keyids を追加してください。この設定によってメッセージの受取人を隠すことができ、トラフィックの解析に対抗することができます (ソーシャルエンジニアリングを使うことでメッセージを復号化できてしまえば誰が受取人なのか確認される可能性があります)。欠点としては、暗号鍵を全て試すことになるので復号化が遅くなります (--try-secret-key <user-id>)。\n\n"
    },
    {
      "title": "キーサインパーティで caff を使う",
      "level": 3,
      "content": "鍵サーバーやキーリングにある鍵の正当性をユーザーが確認 (つまり鍵の持ち主が本人であることを確認) できるように、PGP/GPG はいわゆる信頼の輪 (\"Web of Trust\") を利用しています。信頼の輪を維持するために様々なハッカーイベントが開かれており、キーサインパーティはそのひとつです。Zimmermann-Sassaman 鍵署名プロトコルはキーサインパーティを効果的に行うための方式です。こちら にハウツー記事があります。\n\nキーサインパーティの後、鍵に署名したり所有者に署名を送るのを簡略化するために、caff というツールを使うことができます。AUR のパッケージ caff-svnAUR でインストールすることができます。\n\n所有者に署名を送信するには MTA が必要です。MTA を設定していない場合、msmtp をインストールして下さい。\n\n"
    },
    {
      "title": "長い ID やフィンガープリントを毎回表示する",
      "level": 3,
      "content": "長い鍵 ID を表示させるには設定ファイルに keyid-format 0xlong を追加してください。鍵の指紋を完全に表示するには、設定ファイルに with-fingerprint を追加してください。\n\n"
    },
    {
      "title": "カスタム機能",
      "level": 3,
      "content": "鍵にカスタム機能を設定することができます。以下の機能を使うことが可能です:\n\n- Certify (マスター鍵のみ) - 副鍵の作成ができるようになります。\n- Sign - 公開鍵で検証することができる暗号化署名が作成可能になります。\n- Encrypt - 公開鍵でデータを暗号化して、秘密鍵で復号化することができます。\n- Authenticate - GnuPG 以外のプログラムで鍵を使って認証できます。SSH 鍵として使用することができるようになります。\n\nマスター鍵の機能は以下のコマンドで指定できます:\n\n```\n$ gpg --full-generate-key --expert\n```\n\nオプションを選択して機能を設定することができます。\n\n副鍵にカスタム機能を指定したい場合、gpg --edit-key に --expert フラグを追加してください。詳しくは#鍵の編集を参照。\n\n"
    },
    {
      "title": "su",
      "level": 3,
      "content": "pinentry を使う場合、使用するターミナルデバイス (例: /dev/tty1) の適切なパーミッションが必要です。しかしながら、su (または sudo) を使用すると、所有権は元のユーザーに残り、新しいユーザーにはなくなります。これでは pinentry はたとえ root であっても起動しません。pinentry を使用する (つまりエージェントで gpg を使用する) 前にデバイスのパーミッションを同じ所に変更する必要があります。root で gpg を実行する場合、gpg を使用する直前に所有者を root に変更してください:\n\n```\n# chown root /dev/ttyN  # where N is the current tty\n```\n\nそして gpg を使用した後に元に戻して下さい。おそらく /dev/pts/ と同じのが正しいです。\n\n```\n# script -q -c \"gpg --gen-key\" /dev/null\n```\n\n"
    },
    {
      "title": "エージェントがファイルの終末についてエラーを表示する",
      "level": 3,
      "content": "デフォルトの pinentry プログラムは pinentry-gtk-2 であり、D-Bus セッションバスを正しく実行する必要があります。詳しくは一般的なトラブルシューティング#セッションのパーミッションを見て下さい。\n\nもしくは、pinentry-qt を使うこともできます。#pinentry を参照。\n\n"
    },
    {
      "title": "KGpg 設定のパーミッション",
      "level": 3,
      "content": "kgpg には ~/.gnupg/ のオプションが使えないという問題がありました。非推奨となった options ファイルが原因です。バグ レポートを参照してください。\n\n"
    },
    {
      "title": "GNOME on Wayland で SSH エージェントのソケットが上書きされる",
      "level": 3,
      "content": "Wayland のセッションでは、gnome-session によって SSH_AUTH_SOCK が標準の gnome-keyring ソケット $XDG_RUNTIME_DIR/keyring/ssh に設定されます。このため ~/.pam_environmment や systemd のユニットファイルで設定した値が上書きされてしまいます。\n\nこの挙動を無効化するには GSM_SKIP_AGENT_WORKAROUND 変数を設定してください:\n\n```\n~/.pam_environment\n```\n\n```\nSSH_AGENT_PID\tDEFAULT=\nSSH_AUTH_SOCK\tDEFAULT=\"${XDG_RUNTIME_DIR}/gnupg/S.gpg-agent.ssh\"\nGSM_SKIP_SSH_AGENT_WORKAROUND\tDEFAULT=\"true\"\n```\n\n"
    },
    {
      "title": "mutt",
      "level": 3,
      "content": "Mutt は gpg-agent を正しく使用できないため、mutt を使う場合は GPG_AGENT_INFO 環境変数を設定する必要があります (中身は何でもかまいません)。パスワードのキャッシュも有効化してください。\n\n詳しくは フォーラムスレッド を参照してください。\n\n"
    },
    {
      "title": "gnupg バージョン 2.1 にアップグレードすると鍵が\"消失\"する",
      "level": 3,
      "content": "gpg --list-keys を実行しても以前まで使っていた鍵が表示されない場合、また、アプリケーションが鍵を見つけられないまたは鍵が不正だとエラーを吐く場合、鍵が新しいフォーマットに移行できていない可能性があります。\n\nGnuPG invalid packet workaround を読んで下さい。要約すると、旧式の pubring.gpg と secring.gpg ファイルの鍵にはバグが存在しており、新しい pubring.kbx ファイルと private-keys-v1.d/ サブディレクトリ、そしてディレクトリのファイルによって置き換えられたということが書かれています。以下のコマンドを実行することで消失した鍵を復旧させることができるかもしれません:\n\n```\n$ cd\n$ cp -r .gnupg gnupgOLD\n$ gpg --export-ownertrust > otrust.txt\n$ gpg --import .gnupg/pubring.gpg\n$ gpg --import-ownertrust otrust.txt\n$ gpg --list-keys\n```\n\n"
    },
    {
      "title": "(鍵を受信しようとすると) どの鍵サーバーでも gpg がフリーズする",
      "level": 3,
      "content": "特定の鍵サーバーで鍵を受信しようとして gpg がフリーズしている場合、dirmngr を kill して (問題が起こっていない) 他の鍵サーバーにアクセスできるようにする必要があります。そうしないと全ての鍵サーバーでフリーズしてしまいます。\n\n"
    },
    {
      "title": "スマートカードが検出されない",
      "level": 3,
      "content": "スマートカードにアクセスするための権限がない場合、カードを正しく設定して接続しても、card error が表示されることがあります。\n\nスマートカードにアクセスする必要があるユーザーに scard を追加することで解決できます。追加したら、以下のような udev ルールを作って下さい:\n\n```\n/etc/udev/rules.d/71-gnupg-ccid.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"usb\", ENV{ID_VENDOR_ID}==\"1050\", ENV{ID_MODEL_ID}==\"0116|0111\", MODE=\"660\", GROUP=\"scard\"\n```\n\nVENDOR と MODEL は lsusb の出力にあわせて変更する必要があります。上記は YubikeyNEO の例です。\n\n"
    },
    {
      "title": "gpg: WARNING: server 'gpg-agent' is older than us (x < y)",
      "level": 3,
      "content": "gnupg をアップグレードしたのに古い gpg-agent が動作し続けていると警告が表示されます。ユーザーの gpg-agent.socket を再起動してください (再起動するときに --user フラグを使ってください)。\n\n"
    },
    {
      "title": "IPC 接続の呼び出しに失敗",
      "level": 3,
      "content": "killall gpg-agent dirmngr と $GNUPGHOME/crls.d/ フォルダの権限が 700 になっていて、gpg-agent と dirmngr が起動していないことを確認してください.\n\nデフォルトでは、gnupg パッケージは、ソケットのために /run/user/$UID/gnupg/ ディレクトリを使用します。GnuPG documentation には、このディレクトリが望ましいと書かれています (すべてのファイルシステムがソケットに対応しているわけではありません)。あなたの agent-socket の設定が、適切なファイルシステムを持つパスを指定しているかどうか確認してください。ic|agent-socket}} のパス設定は、 gpgconf --list-dirs agent-socket を実行することで確認することができます。\n\ngpg-agent が正常に起動するか、gpg-agent --daemon でテストしてください。\n\n"
    },
    {
      "title": "汚染された PGP 証明書の軽減",
      "level": 3,
      "content": "2019 年 6 月、未知の攻撃者が数万(または数十万)の署名を持つ複数の高プロファイル PGP 証明書をスパム送信し(CVE-2019-13050)、これらの署名を SKS 鍵サーバーにアップロードしていました。 これらの汚染された証明書がキーリングに存在すると、gpg は以下のメッセージを表示してハングします。\n\n```\ngpg: removing stale lockfile (created by 7055)\n```\n\nこの場合、ブログポストにあるように、汚染された証明書を削除することで軽減できる可能性があります。\n\n"
    },
    {
      "title": "IPC 応答が無効であり、デバイスの ioctl が不適切",
      "level": 3,
      "content": "デフォルトの pinentry プログラムは、/usr/bin/pinentry-gtk-2 です。gtk2 が使用できない場合、pinentry は/usr/bin/pinentry-cursesにフォールバックし、署名に失敗します。\n\n```\ngpg: signing failed: Inappropriate ioctl for device\ngpg: [stdin]: clear-sign failed: Inappropriate ioctl for device\n```\n\npinentry プログラム /usr/bin/pinentry-tty と /usr/bin/pinentry-curses を使用するには、環境変数 GPG_TTY を設定する必要があります。\n\n```\n$ export GPG_TTY=$(tty)\n```\n\n"
    },
    {
      "title": "キーブロックのリソースが存在しません",
      "level": 3,
      "content": "鍵をインポートしようとしたときに、このようなエラーが発生した場合、\n\n```\ngpg: keyblock resource 'gnupg_home/pubring.kbx': No such file or directory\n```\n\nこれは GnuPG がホームディレクトリを作成しないためです。単に手動で作成してください。\n\n```\n$ mkdir -m 700 gnupg_home\n```\n\n"
    },
    {
      "title": "サブキーが機能制限されて作成される",
      "level": 3,
      "content": "場合によっては、カスタムの機能セットを使用してサブキーを作成すると、サブキーが \"制限付き\" としてマークされることがあります。これは、対話型プロンプトで機能が切り替わるときに、オプション 7 または 8 (\"set your own capabilities\") を指定した addkey コマンドで発生します。回避策は、機能の選択を求められたときに、個々の機能を切り替えるのではなく、目的の機能セットを文字列として直接入力することです。たとえば、認証機能のみを持つサブキーを作成するには、\"=A\" と入力します。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- GNU Privacy Guard ホームページ\n- Alan Eliasen's GPG Tutorial\n- RFC 4880 — \"OpenPGP Message Format\"\n- gpg.conf recommendations and best practices\n- Fedora:Creating GPG Keys\n- Debian:Subkeys\n- Protecting code integrity with PGP\n- A more comprehensive gpg Tutorial\n- /r/GPGpractice - a subreddit to practice using GnuPG.\n\n"
    }
  ]
}