{
  "title": "KMS (日本語)",
  "url": "https://wiki.archlinux.org/title/KMS_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- ATI\n- Intel Graphics\n- Nouveau\n\nカーネルモード設定 (KMS) は、ユーザースペースではなくカーネル空間でディスプレイの解像度・色深度を設定する方法です。\n\nLinux カーネルの KMS 実装により、フレームバッファでのネイティブ解像度や素早いコンソール (tty) 切り替えができるようになります。また、アーティファクトの軽減や 3D パフォーマンスの向上、カーネル空間での省電力機能を補助する新しい技術 (DRI2 など) も可能にします。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 背景\n- 2 設定 2.1 KMS の遅延開始 2.2 KMS の早期開始 2.2.1 mkinitcpio 2.2.2 Booster\n- 3 トラブルシューティング 3.1 フォントが小さすぎる\n- 4 モードと EDID を強制する 4.1 モードを強制する\n- 5 モード設定を無効にする\n\n- 2.1 KMS の遅延開始\n- 2.2 KMS の早期開始 2.2.1 mkinitcpio 2.2.2 Booster\n\n- 2.2.1 mkinitcpio\n- 2.2.2 Booster\n\n- 3.1 フォントが小さすぎる\n\n- 4.1 モードを強制する\n\n"
    },
    {
      "title": "背景",
      "level": 2,
      "content": "以前は、ビデオカードをセットアップするのは X サーバーの仕事でした。このため、仮想コンソールで派手なグラフィックを使うことは簡単ではありませんでした。また、X から 仮想コンソール へ切り替えると (Ctrl+Alt+F2)、X サーバーはカーネルにビデオカードのコントロールを移さなくてはならず、動作が重くなりチラツキが生じていました。同じ\"痛々しい\"挙動はコントロールを X サーバーに戻す (X が VT7 で動作している場合 Alt+F7 ときも起こりました。\n\nカーネルモード設定 (KMS) によって、現在カーネルはビデオカードのモードを設定することができます。これによって、起動段階での派手なグラフィックや、仮想コンソールと X の早い切り替えなどが可能になりました。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "まず、どの 方法を使うにせよ、以下を 常時 無効にする必要があります:\n\n- ブートローダ内のあらゆる vga= オプション。KMS によるネイティブ解像度と衝突します。\n- フレームバッファを有効にするあらゆる video= 行。ドライバと衝突します。\n- 他のフレームバッファドライバ (uvesafb など)。\n\n"
    },
    {
      "title": "KMS の遅延開始",
      "level": 3,
      "content": "Intel、Nouveau、ATI、AMDGPU のドライバでは全てのチップセットで、KMS が自動的に有効になるように既になっています。そのため、何もする必要はありません。\n\nプロプライエタリな NVIDIA ドライバは KMS をサポートしています (364.12 以降)。ただし、手動で有効化する必要があります。\n\n"
    },
    {
      "title": "KMS の早期開始",
      "level": 3,
      "content": "通常 KMS は initramfs ステージよりも後に初期化されます。しかし、initramfs ステージで KMS を有効化することもできます。ビデオドライバが必要とするモジュールを initramfs の設定ファイルに追加してください:\n\n- AMDGPU の場合は amdgpu。レガシーな ATI ドライバを使用している場合は radeon\n- Intel Graphics の場合は i915\n- オープンソースな Nouveau ドライバの場合は nouveau\n- out-of-tree の nvidia ドライバや nvidia-open ドライバの場合は nvidia nvidia_modeset nvidia_uvm nvidia_drm 詳細は NVIDIA#DRM カーネルモード設定 を見てください。\n\n- Matrox グラフィックスの場合は mgag200\n- 使用している QEMU グラフィックスに依存します (qemu のオプション -vga type あるいは libvirt <video><model type='type'> [1]): std (qemu) と vga/bochs (libvirt) の場合は bochs virtio の場合は virtio-gpu qxl の場合は qxl vmware (qemu) と vmvga (libvirt) の場合は vmwgfx cirrus の場合は cirrus\n- VirtualBox のグラフィックスコントローラに依存します: VMSVGA の場合は vmwgfx VBoxVGA と VBoxSVGA の場合は vboxvideo\n\n- std (qemu) と vga/bochs (libvirt) の場合は bochs\n- virtio の場合は virtio-gpu\n- qxl の場合は qxl\n- vmware (qemu) と vmvga (libvirt) の場合は vmwgfx\n- cirrus の場合は cirrus\n\n- VMSVGA の場合は vmwgfx\n- VBoxVGA と VBoxSVGA の場合は vboxvideo\n\nInitramfs の設定手順は、使用する initramfs ジェネレータによって若干異なります。\n\n"
    },
    {
      "title": "mkinitcpio",
      "level": 4,
      "content": "In-tree なモジュールの場合、/etc/mkinitcpio.conf の HOOKS 配列に kms フックが含まれていることを確認してください (これは mkinitcpio v33 以降デフォルトです)。\n\nout-of-tree なモジュールの場合、MODULES 配列にモジュール名を追加してください。例えば、NVIDIA グラフィックドライバの early KMS を有効化するには:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nMODULES=(... nvidia nvidia_modeset nvidia_uvm nvidia_drm ...)\n```\n\n#モードと EDID を強制する の方法をとっている場合、そのカスタムファイルを initramfs にも埋め込む必要があります:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nFILES=(/usr/lib/firmware/edid/your_edid.bin)\n```\n\nそして、initramfs を再生成してください。\n\n"
    },
    {
      "title": "Booster",
      "level": 4,
      "content": "Booster を使用している場合、以下の設定変更で必要なモジュールをロードすることができます:\n\n```\n/etc/booster.yaml\n```\n\n```\nmodules_force_load: i915\n```\n\nイメージにファイルを追加する場合:\n\n```\n/etc/booster.yaml\n```\n\n```\nextra_files: /usr/lib/firmware/edid/your_edid.bin\n```\n\nそして、ブースターイメージを 再生成 してください。\n\n"
    },
    {
      "title": "フォントが小さすぎる",
      "level": 3,
      "content": "コンソールフォントを大きくする方法については Linux コンソール#フォント を見てください。Terminus フォント (terminus-font) には ter-132b など様々なサイズが含まれています。\n\nもしくはモード設定を無効化して解像度を下げることで相対的にフォントは大きくなります。\n\n"
    },
    {
      "title": "モードと EDID を強制する",
      "level": 2,
      "content": "ネイティブな解像度が自動的に設定されなかったり、ディスプレイが全く検出されなかったりする場合、モニタが EDID ファイルを送信していなかったり、間違った EDID を送信しているのかもしれません。カーネルはこのようなケースを検出し、最も典型的な解像度のどれかを設定します。\n\nモニタの EDID ファイルを持っているならば、そのファイルを明示的に強制するだけで済みます (以下を参照)。しかし、大抵はまともな EDID ファイルへ直接アクセスできないので、既存の EDID ファイルを抽出するか、新しいものを生成する必要があります。\n\n上流のドキュメントに従うことで (短いガイドはこのページを参照してください)、カーネルのコンパイル中に様々な解像度や構成の EDID バイナリを生成することができます。他の解決策はこの記事で詳細に説明されています。\n\n既存の EDID ファイルを抽出することは、大抵のケースで簡単です。例えば、あなたのモニタが Windows でうまく動作するならば、対応するドライバから EDID を抽出することができます。また、まともな設定のある似たようなモニタが動作するのであれば、read-edid パッケージの get-edid(1) を使うことができます。また、/sys/class/drm/*/edid から探してみることもできます。\n\nEDID の準備ができたら、何かしらのディレクトリ (例えば、/usr/lib/firmware 内の edid ディレクトリ) 内に置き、そこへバイナリをコピーしてください。\n\nEDID をブート時にロードするには、以下のカーネルコマンドラインを指定してください:\n\n```\ndrm.edid_firmware=edid/your_edid.bin\n```\n\n4.13 より前のカーネルでは、代わりに以下のカーネルパラメータを使用してください:\n\n```\ndrm_kms_helper.edid_firmware=edid/your_edid.bin\n```\n\n特定のコネクタに対してのみ EDID を適用するには、以下を使用してください:\n\n```\ndrm.edid_firmware=VGA-1:edid/your_edid.bin\n```\n\n複数の EDID ファイルを使用したい場合は、以下を使用してください:\n\n```\ndrm.edid_firmware=VGA-1:edid/your_edid.bin,VGA-2:edid/your_other_edid.bin\n```\n\n組み込みの解像度の場合は、以下の表を参照してください。名前 列は、その解像度を構成するために使用する必要がある名前です。\n\nTable content:\n解像度 | 名前\n800x600 | edid/800x600.bin\n1024x768 | edid/1024x768.bin\n1280x1024 | edid/1280x1024.bin\n1600x1200 (カーネル 3.10 以上) | edid/1600x1200.bin\n1680x1050 | edid/1680x1050.bin\n1920x1080 | edid/1920x1080.bin\n\n早期 KMSを行っている場合は、カスタムの EDID ファイルを initramfs 内に含めなければなりません。さもないと、問題が発生します。\n\ndrm.edid_firmware パラメータの値は、/sys/module/drm/parameters/edid_firmware に書き込むことで、ブート後にも変更することができます:\n\n```\n# echo edid/your_edid.bin > /sys/module/drm/parameters/edid_firmware\n```\n\nこれは、新しく接続されたディスプレイにしか影響せず、すでに接続されている画面は引き続き既存の EDID 設定を使用します。外部ディスプレイの場合は、ディスプレイのケーブルを抜き差しすることで、新しい EDID を使用させることができます。\n\nカーネル 3.15 から、カーネルがロックダウンモードになっていない場合、カーネルコマンドラインパラメータではなく debugfs を使って ブート後に EDID をロードできます。これは、1つのコネクタに接続されているモニタを交換する場合や、単にテストをしたい場合に便利です。上記のとおりに EDID ファイルを手に入れたら、以下を実行してください:\n\n```\n# cat correct-edid.bin > /sys/kernel/debug/dri/0/HDMI-A-2/edid_override\n```\n\nEDID を無効化するには:\n\n```\n# echo -n reset > /sys/kernel/debug/dri/0/HDMI-A-2/edid_override\n```\n\nモニターがホットプラグに対応している場合、ホットプラグをトリガーすることで、(edid_override などに) ロードした新しい EDID をモニターに使用させることができます。この場合、モニターを物理的に再接続したり、再起動したりする必要がありません:\n\n```\n# echo 1 > /sys/kernel/debug/dri/0/HDMI-A-2/trigger_hotplug\n```\n\n"
    },
    {
      "title": "モードを強制する",
      "level": 3,
      "content": "the nouveau wiki より:\n\n- https://docs.kernel.org/fb/modedb.html\n- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/drm_fb_helper.c\n\nフォーマットは\n\n```\nvideo=<conn>:<xres>x<yres>[M][R][-<bpp>][@<refresh>][i][m][eDd]\n```\n\n- <conn>: コネクタ、例: DVI-I-1、使用可能なコネクタは /sys/class/drm/ を参照\n- <xres> x <yres>: 解像度\n- M: CVT モードを計算?\n- R: ブランキングを減らす?\n- -<bpp>: 色深度\n- @<refresh>: リフレッシュレート\n- i: インターレース (非CVTモード)\n- m: 余白?\n- e: 出力は強制的にオンにする\n- d: 出力は強制的にオフにされる\n- D: デジタル出力を強制的にオン (例:DVI-I コネクタ)\n\n例えば、video= を複数回使って、DVI を1024x768、85 Hzに、TV-out をオフに強制する、といったように複数の出力モードをオーバーライドすることが可能です:\n\n```\nvideo=DVI-I-1:1024x768@85 video=TV-1:d\n```\n\nコネクタの名前と現在の状態を取得するには、以下のシェルワンライナーを使用できます:\n\n```\n$ for p in /sys/class/drm/*/status; do con=${p%/status}; echo -n \"${con#*/card?-}: \"; cat $p; done\n```\n\n```\nDVI-I-1: connected\nHDMI-A-1: disconnected\nVGA-1: disconnected\n```\n\n"
    },
    {
      "title": "モード設定を無効にする",
      "level": 2,
      "content": "様々な理由で KMS を無効化したい場合があるでしょう。KMS を無効化するには、nomodeset をカーネルパラメータに追加してください。詳細は カーネルパラメータ を見てください。\n\nnomodeset カーネルパラメータと共に、Intel グラフィックカードの場合は i915.modeset=0 も、Nvidia グラフィックカードの場合は nouveau.modeset=0 も追加する必要があります。Nvidia Optimus のデュアルグラフィック環境では、これら3つのカーネルパラメータをすべて追加する必要があります (つまり、\"nomodeset i915.modeset=0 nouveau.modeset=0\")。\n\n"
    }
  ]
}