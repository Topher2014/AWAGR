{
  "title": "Nftables (Español)",
  "url": "https://wiki.archlinux.org/title/Nftables_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2018-09-03** \n\nArtículos relacionados\n\n- iptables\n\nnftables es un proyecto de netfilter que tiene como objetivo reemplazar el marco existente de tablas{ip,ip6,arp,eb}. Proporciona un nuevo marco de filtrado de paquetes, una nueva utilidad en el espacio de usuario (nft) y una capa de compatibilidad para las tablas{ip,ip6}. Utiliza los hooks existentes, el sistema de seguimiento de la conexiones, los componentes de la línea de espera de los paquetes de red («packet queues») del espacio de usuario y el subsistema de registro de netfilter.\n\nConsta de tres componentes principales: una implementación del kernel, la comunicación de la biblioteca libnl con netlink y un frontend de nftables en el espacio de usuario («nft») . El kernel proporciona una interfaz para la configuración del enlace de red («netlink»), así como una evaluación del conjunto de reglas en tiempo de ejecución; libnl contiene las funciones de bajo nivel para comunicarse con el kernel, y, por último, el frontend nft proporciona interacción al usuario con nftables.\n\nPara obtener más información también puede visitar la página oficial de la wiki de nftables .\n\n"
    },
    {
      "title": "Instalación",
      "level": 2,
      "content": "Instale las utilidades para el espacio de usuario proporcionadas por el paquete nftables o su versión git nftables-gitAUR.\n\n"
    },
    {
      "title": "Utilización",
      "level": 2,
      "content": "nftables hace una distinción entre las reglas temporales realizadas en la línea de órdenes y aquellas otras permanentes cargadas o guardadas en un archivo. El archivo predeterminado es /etc/nftables.conf, que ya contiene una tabla simple de cortafuegos para ipv4/ipv6 llamada «inet filter».\n\nPara utilizarlo, inicie/active el servicio nftables.service.\n\nPuede consultar el conjunto de reglas con:\n\n```\n# nft list ruleset\n```\n\n```\n$ lsmod | grep '^nf'\n```\n\n"
    },
    {
      "title": "Configuración",
      "level": 2,
      "content": "La utilidad de nftable en el espacio de usuario, nft, realiza la mayor parte de la evaluación del conjunto de reglas antes de pasarlas al kernel. Las reglas se almacenan en cadenas, que a su vez se almacenan en tablas. Las siguientes secciones indican cómo crear y modificar estos elementos.\n\nTodos los cambios explicados a continuación son temporales. Para que los cambios permanezcan, guarde el conjunto de reglas en el archivo /etc/nftables.conf, que será cargado por el servicio nftables.service:\n\n```\n# nft list ruleset > /etc/nftables.conf\n```\n\nPara leer la entrada de un archivo, use el indicador -f:\n\n```\n# nft -f nombre_del_archivo\n```\n\nTenga en cuenta que las reglas ya cargadas no se ejecutan automáticamente.\n\nConsulte nft(8) para obtener una lista completa de todas las órdenes.\n\n"
    },
    {
      "title": "Tablas",
      "level": 3,
      "content": "Las tablas alojan #Cadenas. A diferencia de las tablas en iptables, no hay tablas integradas en nftables. La cantidad de tablas y sus nombres depende del usuario. Sin embargo, cada tabla solo tiene una familia de direcciones y solo se aplica a los paquetes de red de esa familia. Las tablas pueden tener una de las cinco familias que se especifican:\n\nTable content:\nFamilia de nftables | Utilidad iptables\nip | iptables\nip6 | ip6tables\ninet | iptables and ip6tables\narp | arptables\nbridge | ebtables\n\nip (es decir, IPv4) es la familia predeterminada y se usará si no se especifica la familia.\n\nPara crear una regla que se aplique tanto a IPv4 como a IPv6, utilice inet. inet permite la unificación de las familias ip y ip6 para que las reglas que las defines sean más sencillas para ambas.\n\nConsulte la sección ADDRESS FAMILIES en nft(8) para obtener una descripción completa de las familias de direcciones.\n\nEn todos los casos, <familia> es opcional y, si no se especifica, se decanta por ip.\n\n"
    },
    {
      "title": "Crear una tabla",
      "level": 4,
      "content": "La siguiente orden añade una nueva tabla:\n\n```\n# nft add table <familia> <tabla>\n```\n\n"
    },
    {
      "title": "Listar las tablas",
      "level": 4,
      "content": "Para enumerar todas las tablas:\n\n```\n# nft list tables\n```\n\n"
    },
    {
      "title": "Listar las cadenas y las reglas de una tabla",
      "level": 4,
      "content": "Para enumerar todas las cadenas y reglas de una tabla especificada, escriba lo siguiente:\n\n```\n# nft list table <familia> <tabla>\n```\n\nPor ejemplo, para enumerar todas las reglas de la tabla filter de la familia inet:\n\n```\n# nft list table inet filter\n```\n\n"
    },
    {
      "title": "Borrar una tabla",
      "level": 4,
      "content": "Para eliminar una tabla, escriba lo siguiente:\n\n```\n# nft delete table <familia> <tabla>\n```\n\nLas tablas solo se pueden eliminar si no contienen cadenas.\n\n"
    },
    {
      "title": "Vaciar una tabla",
      "level": 4,
      "content": "Para eliminar todas las reglas de una tabla, escriba lo siguiente:\n\n```\n# nft flush table <familia> <tabla>\n```\n\n"
    },
    {
      "title": "Cadenas",
      "level": 3,
      "content": "El propósito de las cadenas es alojar #Reglas. A diferencia de las cadenas en iptables, no hay cadenas integradas en nftables. Esto significa que si ninguna cadena utiliza ningún tipo o hook en el marco de netfilter, los paquetes de red que fluyan a través de esas cadenas no serán tocados por nftables, a diferencia de iptables.\n\nLas cadenas son de dos tipos. Una cadena base que es un punto de entrada para los paquetes de la pila de red, donde se especifica un valor de enlace. Y una cadena normal que puede usarse como un objetivo de salto («jump») para una mejor organización.\n\nEn todo lo que sigue, la familia es opcional y, si no se especifica, esta se define como ip.\n\n"
    },
    {
      "title": "Crear una cadena",
      "level": 4,
      "content": "A continuación, agregaremos una cadena normal, llamada <cadena>, a la tabla denominada <tabla>:\n\n```\n# nft add chain <familia> <tabla> <cadena>\n```\n\nPor ejemplo, para añadir una cadena normal llamada tcpchain, a la tabla filter, de la familia de direcciones inet, escribiremos lo siguiente:\n\n```\n# nft add chain inet filter tcpchain\n```\n\nPara añadir una cadena base, especificaremos los valores de hook y de priority:\n\n```\n# nft add chain <familia> <tabla> <cadena> { type tipo hook hook priority prioridad \\; }\n```\n\ntype puede ser filter, route, o nat.\n\nPara familias de direcciones IPv4/IPv6/Inet el hook puede ser prerouting, input, forward, output, o postrouting. Consulte nft(8)para obtener una lista de los hooks para otras familias.\n\npriority toma un valor entero. Las cadenas con números más bajos se procesan primero y pueden ser negativos. [1]\n\nPor ejemplo, para añadir una cadena base que filtre los paquetes de entrada:\n\n```\n# nft add chain inet filter input { type filter hook input priority 0\\; }\n```\n\nReemplace add con create en cualquiera de las órdenes anteriores para añadir una nueva cadena, pero tenga en cuenta que devolvera un error si la cadena ya existe.\n\n"
    },
    {
      "title": "Listar las reglas",
      "level": 4,
      "content": "A continuación enumeraremos todas las reglas de una cadena:\n\n```\n# nft list chain <familia> <tabla> <cadena>\n```\n\nPor ejemplo, la siguiente orden listará las reglas de la cadena llamada output, presentes en la tabla inet llamada filter:\n\n```\n# nft list chain inet filter output\n```\n\n"
    },
    {
      "title": "Modificar una cadena",
      "level": 4,
      "content": "Para modificar una cadena, bastará con llamarla por su nombre y definiremos las reglas que deseamos cambiar.\n\n```\n# nft chain <tabla> <familia> <cadena> { [ type <tipo> hook <hook> device <dispositivo> priority <prioridad> \\; policy <política> \\; ] }\n```\n\nSi, por ejemplo, solo deseamos cambiar la política de la cadena de entrada («input») de la tabla predeterminada, de «accept» a «drop», escribiremos:\n\n```\n# nft chain inet filter input { policy drop \\; }\n```\n\n"
    },
    {
      "title": "Borrar una cadena",
      "level": 4,
      "content": "Para eliminar una cadena escribiremos:\n\n```\n# nft delete chain <familia> <tabla> <cadena>\n```\n\nLa cadena no debe contener ninguna regla, ni tener un objetivo «jump».\n\n"
    },
    {
      "title": "Eliminar las reglas de una cadena",
      "level": 4,
      "content": "Para eliminar las reglas de una cadena, haremos lo siguiente:\n\n```\n# nft flush chain <familia> <tabla> <cadena>\n```\n\n"
    },
    {
      "title": "Reglas",
      "level": 3,
      "content": "Las reglas se construyen, bien a partir de expresiones («expressions») o bien a partir de declaraciones («statements»), y están contenidas dentro de cadenas.\n\n"
    },
    {
      "title": "Añadir una regla",
      "level": 4,
      "content": "Para añadir una regla a una cadena, escribiremos:\n\n```\n# nft add rule <familia> <tabla> <cadena> handle <identificador> <statement>\n```\n\nLa regla se agrega con handle, que es opcional. Si no se especifica, la regla se agrega al final de la cadena.\n\nPara anteponer la regla de posición, escriba:\n\n```\n# nft insert rule <familia> <tabla> <cadena> handle <identificador> <statement>\n```\n\nSi el <identificador> (handle) no se especifica, la regla se antepone a la cadena.\n\nPor lo general, un statement incluye alguna expresión de coincidencia (como «condición») y, luego, una «declaración» que resuelva (si coinciden). Las declaraciones resolutivas incluyen accept, drop, queue, continue, return, <cadena> jump, y <cadena> goto. Son posibles otros «statement» que contengan otras declaraciones resolutivas. Consulte nft(8) para obtener más información.\n\nHay varias expresiones disponibles en nftables y, en su mayor parte, coinciden con sus contrapartes de iptables. La diferencia más notable es que no hay coincidencias genéricas o implícitas. Una coincidencia genérica siempre estuvo disponible, como era el caso de --protocol o --source. Las coincidencias implícitas eran específicas del protocolo, tales como --sport cuando se verificaba que un paquete era TCP.\n\nHe aquí es una lista no exhaustiva de las coincidencias disponibles:\n\n- meta (meta propiedades, por ejemplo, interfaces)\n- icmp (protocolo ICMP)\n- icmpv6 (protocolo ICMPv6)\n- ip (protocolo IP)\n- ip6 (protocolo IPv6)\n- tcp (protocolo TCP)\n- udp (protocolo UDP)\n- sctp (protocolo SCTP)\n- ct (seguimiento de la conexión)\n\nHe aquí una lista no exhaustiva de los argumentos de coincidencia (para una lista más completa, vea nft(8)):\n\n```\nmeta:\n  oif <INDICE de la interfaz de salida>\n  iif <INDICE de la interfaz de entrada>\n  oifname <NOMBRE de la interfaz de salida>\n  iifname <NOMBRE de la interfaz de entrada>\n\n  (oif y iif aceptan argumentos de cadena y se convierten en índices de interfaz)\n  (oifname y iifname son más dinámicos, pero más lentos debido a la coincidencia de cadenas)\n\nicmp:\n  type <tipo icmp>\n\nicmpv6:\n  type <tipo icmpv6>\n\nip:\n  protocol <protocolo>\n  daddr <dirección de destino>\n  saddr <dirección de origen>\n\nip6:\n  daddr <dirección de destino>\n  saddr <dirección de origen>\n\ntcp:\n  dport <puerto de destino>\n  sport <puerto de origen>\n\nudp:\n  dport <puerto de destino>\n  sport <puerto de origen>\n\nsctp:\n  dport <puerto de destino>\n  sport <puerto de origen>\n\nct:\n  state <new | established | related | invalid>\n```\n\n"
    },
    {
      "title": "Eliminación",
      "level": 4,
      "content": "Las reglas individuales solo se pueden eliminar mediante sus identificadores («handle»). La orden nft --handle list se puede usar para determinar los identificadores de las reglas. Advierta que el modificador --handle le dice a nft que liste los identificadores en la salida.\n\nLas siguientes órdenes determinan, primero, el identificador de una regla y, luego, borra dicha regla. El argumento --number es útil para que vuelque algún resultado numérico, como las direcciones IP no resueltas.\n\n```\n# nft --handle --numeric list chain filter input\n```\n\n```\ntable ip fltrTable {\n     chain input {\n          type filter hook input priority 0;\n          ip saddr 127.0.0.1 accept # handle 10\n     }\n}\n```\n\n```\n# nft delete rule fltrTable input handle 10\n```\n\nTodas las cadenas en una tabla se pueden limpiar con la orden nft flush table. Las cadenas individuales pueden eliminarse utilizando las órdenes nft flush chain o nft delete rule.\n\n```\n# nft flush table foo\n# nft flush chain foo bar\n# nft delete rule ip6 foo bar\n```\n\nLa primera orden, limpia todas las cadenas en la tabla ip foo. La segunda, limpia la cadena bar en la tabla ip foo. La tercera, borra todas las reglas en la cadena bar en la tabla ip6 foo.\n\n"
    },
    {
      "title": "Recargar todo",
      "level": 3,
      "content": "Vacíe el conjunto de reglas actuales:\n\n```\n# echo \"flush ruleset\" > /tmp/nftables\n```\n\nVuelque el conjunto de reglas actuales:\n\n```\n# nft list ruleset >> /tmp/nftables\n```\n\nAhora puede editar /tmp/nftables y aplicar los cambios con:\n\n```\n# nft -f /tmp/nftables\n```\n\n"
    },
    {
      "title": "Estación de trabajo",
      "level": 3,
      "content": "```\n/etc/nftables.conf\n```\n\n```\nflush ruleset\n\ntable inet filter {\n        chain input {\n                type filter hook input priority 0;\n\n                # aceptar cualquier tráfico de localhost\n                iif lo accept\n\n                # aceptar tráfico originado por nosotros\n                ct state established,related accept\n\n\t\t# aceptar ICMP y IGMP\n\t\tip6 nexthdr icmpv6 icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem, mld-listener-query, mld-listener-report, mld-listener-reduction, nd-router-solicit, nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert, ind-neighbor-solicit, ind-neighbor-advert, mld2-listener-report } accept\n\t\tip protocol icmp icmp type { destination-unreachable, router-solicitation, router-advertisement, time-exceeded, parameter-problem } accept\n\t\tip protocol igmp accept\n\n                # descomentar la siguiente línea para aceptar servicios locales comunes\n                #tcp dport { 22, 80, 443 } ct state new accept\n\n                # cuenta y descarta cualquier otro tráfico\n                counter drop\n        }\n}\n```\n\n"
    },
    {
      "title": "Cortafuegos simple con IPv4/IPv6",
      "level": 3,
      "content": "```\ncortafuegos.rules\n```\n\n```\n# A simple cortafuegos\n\nflush ruleset\n\ntable inet filter {\n\tchain input {\n\t\ttype filter hook input priority 0; policy drop;\n\n\t\t# conexiones establecidas/relacionadas\n\t\tct state established,related accept\n\n\t\t# conexiones no válidas\n\t\tct state invalid drop\n\t\t\n\t\t# interfaz loopback\n\t\tiif lo accept\n\n\t\t# ICMP y IGMP\n\t\tip6 nexthdr icmpv6 icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem, mld-listener-query, mld-listener-report, mld-listener-reduction, nd-router-solicit, nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert, ind-neighbor-solicit, ind-neighbor-advert, mld2-listener-report } accept\n\t\tip protocol icmp icmp type { destination-unreachable, router-solicitation, router-advertisement, time-exceeded, parameter-problem } accept\n\t\tip protocol igmp accept\n\n\t\t# SSH (puerto 22)\n\t\ttcp dport ssh accept\n\n\t\t# HTTP (puertos 80 y 443)\n\t\ttcp dport { http, https } accept\n\t}\n\n\tchain forward {\n\t\ttype filter hook forward priority 0; policy drop;\n\t}\n\n\tchain output {\n\t\ttype filter hook output priority 0; policy accept;\n\t}\n\n}\n```\n\n"
    },
    {
      "title": "Tipo de límite del cortafuegos IPv4/IPv6",
      "level": 3,
      "content": "```\ncortafuegos.2.rules\n```\n\n```\ntable inet filter {\n\tchain input {\n\t\ttype filter hook input priority 0; policy drop;\n\n\t\tct state invalid drop\n\n\t\tiif lo accept\n\n\t\t# sin saturación de ping:\n\t\tip protocol icmp icmp type echo-request limit rate over 10/second burst 4 packets  drop\n\t\tip6 nexthdr icmpv6 icmpv6 type echo-request limit rate over 10/second burst 4 packets drop\n\n\t\tct state established,related accept\n\n\t\t# ICMP y IGMP\n\t\tip6 nexthdr icmpv6 icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem, mld-listener-query, mld-listener-report, mld-listener-reduction, nd-router-solicit, nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert, ind-neighbor-solicit, ind-neighbor-advert, mld2-listener-report } accept\n\t\tip protocol icmp icmp type { destination-unreachable, router-solicitation, router-advertisement, time-exceeded, parameter-problem } accept\n\t\tip protocol igmp accept\n\n\t\t# evitar la fuerza bruta en ssh:\n\t\ttcp dport ssh ct state new limit rate 15/minute accept\n\n\t}\n\n\tchain forward {\n\t\ttype filter hook forward priority 0; policy drop;\n\t}\n\n\tchain output {\n\t\ttype filter hook output priority 0; policy accept;\n\t}\n\n}\n```\n\n"
    },
    {
      "title": "Jump",
      "level": 3,
      "content": "Al usar saltos (jump) en el archivo de configuración, primero es necesario definir la cadena target. De lo contrario, nos podríamos encontrar con el error Error: Could not process rule: No such file or directory.\n\n```\njump.rules\n```\n\n```\ntable inet filter {\n    chain web {\n        tcp dport http accept\n        tcp dport 8080 accept\n    }\n    chain input {\n        type filter hook input priority 0;\n        ip saddr 10.0.2.0/24 jump web\n        drop\n    }\n}\n```\n\n"
    },
    {
      "title": "Diferentes reglas para diferentes interfaces",
      "level": 3,
      "content": "Si su equipo tiene más de una interfaz de red y le gustaría usar diferentes reglas para las diferentes interfaces, puede usar una cadena de filtros «dispatching», y luego cadenas de filtros específicas para cada interfaz. Por ejemplo, supongamos que tiene un equipo que actúa como un enrutador doméstico, y desea ejecutar un servidor web accesible a través de la LAN (interfaz nsp3s0), pero no desde Internet público (interfaz enp2s0), es posible que desee considerar una estructura como esta:\n\n```\ntable inet filter {\n  chain input { # esta cadena sirve como despachador\n    type filter hook input priority 0;\n\n    iif lo accept # always accept loopback\n    iifname enp2s0 jump input_enp2s0\n    iifname enp3s0 jump input_enp3s0\n\n    reject with icmp type port-unreachable # refuse traffic from all other interfaces\n  }\n  chain input_enp2s0 { # reglas aplicables a la interfaz de acceso pública\n    ct state {established,related} accept\n    ct state invalid drop\n    udp dport bootpc accept\n    tcp dport bootpc accept\n    reject with icmp type port-unreachable # todo el tráfico restante\n  }\n  chain input_enp3s0 {\n    ct state {established,related} accept\n    ct state invalid drop\n    udp dport bootpc accept\n    tcp dport bootpc accept\n    tcp port http accept\n    tcp port https accept\n    reject with icmp type port-unreachable # todo el tráfico restante\n  }\n  chain ouput { # dejamos que todo salga\n    type filter hook output priority 0;\n    accept\n  }\n }\n```\n\nDe forma alternativa, podría elegir solo una declaración iifname, a modo de interfaz única ascendente, y colocar las reglas predeterminadas para todas las demás interfaces en un solo lugar, en vez de enviarlas para cada interfaz.\n\n"
    },
    {
      "title": "Enmascaramiento",
      "level": 3,
      "content": "nftables tiene una palabra clave especial masquerade «donde la dirección de origen se configura automáticamente hacia la dirección de la interfaz de salida» (source). Esto es particularmente útil para situaciones en las que la dirección IP de la interfaz es impredecible o inestable, como la interfaz de los enrutadores que se conectan a muchos ISP. Sin esta opción, las reglas de traducción de las direcciones de red tendrían que actualizarse cada vez que cambiara la dirección IP de la interfaz.\n\nPara usarlo:\n\n- asegúrese de que el enmascaramiento esté activado en el kernel (true (verdadero) si se utiliza el kernel predeterminado); de lo contrario, durante la configuración del kernel, defínalo:\n\n```\nCONFIG_NFT_MASQ=m\n```\n\n- la palabra clave masquerade solo se puede usar en cadenas de tipo nat, las cuales no se pueden combinar en una tabla con la familia inet. Utilice una tabla con la familia ip y/o ip6 en su lugar.\n\n- el enmascaramiento es un tipo de fuente NAT, por lo que solo funciona en la ruta de salida.\n\nEjemplo para un equipo con dos interfaces: LAN conectada a nsp3s0, e Internet pública conectada a enp2s0:\n\n```\ntable ip nat {\n  chain prerouting {\n    type nat hook prerouting priority 0;\n  }\n  chain postrouting {\n    type nat hook postrouting priority 0;\n    oifname \"enp0s2\" masquerade\n  }\n}\n```\n\n"
    },
    {
      "title": "Cortafuegos stateful simple",
      "level": 3,
      "content": "Consulte Simple stateful firewall (Español) para obtener más información.\n\n"
    },
    {
      "title": "Proteger un único equipo",
      "level": 4,
      "content": "Vacíe el conjunto de reglas actuales:\n\n```\n# nft flush ruleset\n```\n\nAñada una tabla:\n\n```\n# nft add table inet filter\n```\n\nAñada las cadenas base: input, forward y output. La política de input y forward será drop. La política de output será accept.\n\n```\n# nft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n# nft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\n# nft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n```\n\nAñada dos cadenas normales que se asociarán con tcp y udp:\n\n```\n# nft add chain inet filter TCP\n# nft add chain inet filter UDP\n```\n\nEl tráfico relacionado («related») y el ya establecido («established») será aceptado («accept»):\n\n```\n# nft add rule inet filter input ct state related,established accept\n```\n\nSe aceptará todo el tráfico procedente de la interfaz loopback:\n\n```\n# nft add rule inet filter input iif lo accept\n```\n\nSe establecerá la política de descartar («drop») para cualquier tráfico no válido:\n\n```\n# nft add rule inet filter input ct state invalid drop\n```\n\nSe aceptarán nuevas solicitudes de echo (pings):\n\n```\n# nft add rule inet filter input ip protocol icmp icmp type echo-request ct state new accept\n```\n\nEl nuevo tráfico upd saltará («jump») a la cadena UDP:\n\n```\n# nft add rule inet filter input ip protocol udp ct state new jump UDP\n```\n\nEl nuevo tráfico tcp saltará («jump») a la cadena TCP:\n\n```\n# nft add rule inet filter input ip protocol tcp tcp flags \\& \\(fin\\|syn\\|rst\\|ack\\) == syn ct state new jump TCP\n```\n\nSe rechazará («reject») todo el tráfico no procesado por la restantes reglas:\n\n```\n# nft add rule inet filter input ip protocol udp reject\n# nft add rule inet filter input ip protocol tcp reject with tcp reset\n# nft add rule inet filter input counter reject with icmp type prot-unreachable\n```\n\nEn este punto, debe decidir qué puertos desea abrir para las conexiones entrantes, que son manejadas por las cadenas TCP y UDP. Por ejemplo, para abrir conexiones para un servidor web, añada:\n\n```\n# nft add rule inet filter TCP tcp dport 80 accept\n```\n\nPara aceptar conexiones HTTPS de un servidor web en el puerto 443:\n\n```\n# nft add rule inet filter TCP tcp dport 443 accept\n```\n\nPara aceptar el tráfico SSH en el puerto 22:\n\n```\n# nft add rule inet filter TCP tcp dport 22 accept\n```\n\nPara aceptar solicitudes de DNS entrantes:\n\n```\n# nft add rule inet filter TCP tcp dport 53 accept\n# nft add rule inet filter UDP udp dport 53 accept\n```\n\nAsegúrese de hacer que sus cambios permanezcan cuando esté satisfecho.\n\n"
    },
    {
      "title": "Evitar ataques de fuerza bruta",
      "level": 3,
      "content": "Sshguard es un programa que puede detectar ataques de fuerza bruta y modificar el cortafuegos en función de las direcciones IP temporalmente bloqueadas. Consulte Sshguard#nftables sobre cómo configurar nftables para usarlo con Sshguard.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- netfilter nftables wiki\n- debian:nftables\n- gentoo:nftables\n- First release of nftables\n- nftables quick howto\n- The return of nftables\n- What comes after ‘iptables’? Its successor, of course: `nftables`\n\n"
    }
  ]
}