{
  "title": "Unified Extensible Firmware Interface (日本語)",
  "url": "https://wiki.archlinux.org/title/Unified_Extensible_Firmware_Interface_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Master Boot Record\n- EFI システムパーティション\n- GUID Partition Table\n- セキュアブート\n- ユニファイドカーネルイメージ\n\nUnified Extensible Firmware Interface (UEFI) はオペレーティングシステムとファームウェア間のインターフェイスです。オペレーティングシステムを起動したり、プリブートアプリケーション用の標準的な環境を提供します。\n\nUEFI は BIOS システムで一般的に使われている MBR ブートコードメソッドとは異なります。これらの違いや UEFI を用いた起動プロセスについては Arch ブートプロセス を見てください。UEFI ブートローダをセットアップするには ブートローダー を見てください。\n\n- 初期のベンダー UEFI 実装は BIOS のものよりも多くのバグを含んでいる場合があります。そのようなシステムで解決不可能な問題に直面した場合は、レガシー BIOS を使用して起動することを検討してください。\n- Apple の EFI 実装は標準に従っていません。以下の手順は明白に書かれている部分を除き、一般的な UEFI を対象としており、場合によっては手順のいくつかは Mac では動かなかったり違っていたりする可能性があります。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 UEFI ファームウェアのビット数 1.1 UEFI ファームウェアのビット数を調べる 1.1.1 Linux で 1.1.2 macOS で 1.1.3 Microsoft Windows で\n- 2 UEFI 変数 2.1 Linux カーネルでの UEFI 変数のサポート 2.2 UEFI 変数のサポートを正しく動作させるための必要条件 2.2.1 efivarfs のマウント 2.3 ユーザースペースツール 2.3.1 efibootmgr 2.4 UEFI 変数へのアクセスを無効化\n- 3 UEFI シェル 3.1 UEFI シェルを入手する 3.2 UEFI シェルの起動 3.3 重要な UEFI シェルコマンド 3.3.1 bcfg 3.3.2 map 3.3.3 edit\n- 4 UEFI ドライバ\n- 5 UEFI ブータブルメディア 5.1 光学メディアから UEFI ブートサポートを削除する\n- 6 ネイティブサポートのない環境で UEFI をテストする 6.1 仮想マシン用の OVMF 6.2 BIOS システム専用の DUET\n- 7 トラブルシューティング 7.1 Windows で固まった際に Arch Linux に戻る 7.2 ファンクションキー無しでファームウェアセットアップに入る 7.3 ユーザスペースのツールが UEFI 変数のデータを変更できない 7.4 efibootmgr でブートエントリを新規作成できない 7.5 Windows によってブート順序が変わってしまう 7.6 USB メディアが黒画面で固まる 7.7 ファームウェアのメニューに UEFI ブートローダーが表示されない 7.7.1 リムーバブルドライブのデフォルトブートパス 7.7.2 Microsoft Windows ブートローダの場所 7.8 UEFI/BIOS がロード画面で固まる 7.9 efibootmgr で作成したブートエントリが UEFI に表示されない 7.10 UEFI ブートエントリが、参照するドライブを取り外すと消える 7.11 ブートエントリがランダムに削除される\n- 8 参照\n\n- 1.1 UEFI ファームウェアのビット数を調べる 1.1.1 Linux で 1.1.2 macOS で 1.1.3 Microsoft Windows で\n\n- 1.1.1 Linux で\n- 1.1.2 macOS で\n- 1.1.3 Microsoft Windows で\n\n- 2.1 Linux カーネルでの UEFI 変数のサポート\n- 2.2 UEFI 変数のサポートを正しく動作させるための必要条件 2.2.1 efivarfs のマウント\n- 2.3 ユーザースペースツール 2.3.1 efibootmgr\n- 2.4 UEFI 変数へのアクセスを無効化\n\n- 2.2.1 efivarfs のマウント\n\n- 2.3.1 efibootmgr\n\n- 3.1 UEFI シェルを入手する\n- 3.2 UEFI シェルの起動\n- 3.3 重要な UEFI シェルコマンド 3.3.1 bcfg 3.3.2 map 3.3.3 edit\n\n- 3.3.1 bcfg\n- 3.3.2 map\n- 3.3.3 edit\n\n- 5.1 光学メディアから UEFI ブートサポートを削除する\n\n- 6.1 仮想マシン用の OVMF\n- 6.2 BIOS システム専用の DUET\n\n- 7.1 Windows で固まった際に Arch Linux に戻る\n- 7.2 ファンクションキー無しでファームウェアセットアップに入る\n- 7.3 ユーザスペースのツールが UEFI 変数のデータを変更できない\n- 7.4 efibootmgr でブートエントリを新規作成できない\n- 7.5 Windows によってブート順序が変わってしまう\n- 7.6 USB メディアが黒画面で固まる\n- 7.7 ファームウェアのメニューに UEFI ブートローダーが表示されない 7.7.1 リムーバブルドライブのデフォルトブートパス 7.7.2 Microsoft Windows ブートローダの場所\n- 7.8 UEFI/BIOS がロード画面で固まる\n- 7.9 efibootmgr で作成したブートエントリが UEFI に表示されない\n- 7.10 UEFI ブートエントリが、参照するドライブを取り外すと消える\n- 7.11 ブートエントリがランダムに削除される\n\n- 7.7.1 リムーバブルドライブのデフォルトブートパス\n- 7.7.2 Microsoft Windows ブートローダの場所\n\n"
    },
    {
      "title": "UEFI ファームウェアのビット数",
      "level": 2,
      "content": "UEFI においては、すべてのプログラムはオペレーティングシステムローダーであろうとユーティリティ (メモリテストやリカバリツールなど) であろうと、UEFI ファームウェアのビット数/アーキテクチャに対応する EFI アプリケーションである必要があります。\n\n最近の Apple Mac を含む x86_64 システムの大部分は x64 (64 ビット) UEFI ファームウェアを使用します。IA32 (32ビット) の UEFI を使うことが知られているデバイスは古い(2008年以前) Apple Mac や Intel Atom System-on-Chip システム(2013年11月2日現在)[1]、そして Intel EFI 1.10 ファームウェア上で動作することが知られている一部の古い Intel のサーバーボードだけです。\n\nx64 UEFI ファームウェアは 32ビットの EFI アプリケーションの起動をサポートしません(x86_64 Linux とそのようなサポートを含む Windows のバージョン とは違って)。それゆえ、EFI アプリケーションは特定のファームウェアプロセッサのビット数/アーキテクチャ用にコンパイルされなければなりません。\n\n"
    },
    {
      "title": "UEFI ファームウェアのビット数を調べる",
      "level": 3,
      "content": "ファームウェアのビット数は起動されたオペレーティングシステムから確認できます。\n\n"
    },
    {
      "title": "Linux で",
      "level": 4,
      "content": "Linux カーネル 4.0 以上が走るディストリビューションでは、UEFI ファームウェアのビット数は sysfs インターフェイスを通して確認できます。以下を実行してください:\n\n```\n$ cat /sys/firmware/efi/fw_platform_size\n```\n\nこのコマンドは、64ビット (x64) UEFI の場合は 64、32ビット(IA32) UEFI の場合は 32 を返します。このファイルが存在しない場合は UEFI モードで起動していないということです。\n\n"
    },
    {
      "title": "macOS で",
      "level": 4,
      "content": "2008年以前のほとんどの Mac は i386-efi ファームウェアを使っています。一方、2008年以降の Mac のファームウェアはほとんど x64 EFI です。Mac OS X Snow Leopard を動かすことのできる全ての Mac は x64 EFI 1.x ファームウェアを使っています。\n\nMac の efi ファームウェアのアーキテクチャを知るには、Mac OS X の端末に次のコマンドを入力してください:\n\n```\n$ ioreg -l -p IODeviceTree | grep firmware-abi\n```\n\nコマンドの返事が EFI32 なら、IA32 (32ビット) EFI 1.x ファームウェアです。EFI64 と返ってくるなら、x64 EFI ファームウェアです。ほとんどの Mac は UEFI 2.x ファームウェアを持っていません、Apple の EFI 実装は UEFI 2.x の仕様に完全には準拠していないからです。\n\n"
    },
    {
      "title": "Microsoft Windows で",
      "level": 4,
      "content": "64ビット Windows は 32ビット UEFI からの起動をサポートしていません。なので、UEFI モードで 32ビット Windows を起動している場合は 32ビット UEFI を使用しているということになります。\n\nビット数を調べるには msinfo32.exe を実行してください。システムの要約を開き、\"システムの種類\"と\"BIOS モード\"の値を見てください。\n\n64ビット UEFI 上で動作している 64ビット Windows では システムの種類: x64-ベース PC、BIOS モード: UEFI となります。32ビット UEFI 上で動作する 32ビット Windows では システムの種類: x86-ベース PC、BIOS モード: UEFI となります。もし、\"BIOS モード\" が UEFI でない場合、Windows は UEFI モードで起動していないということです。\n\n"
    },
    {
      "title": "UEFI 変数",
      "level": 2,
      "content": "UEFI はオペレーティングシステムとファームウェアが情報を交換できるように変数を定義しています。UEFI ブート変数はブートローダやオペレーティングシステムによって初期のシステムスタートアップのためにだけに使われます。UEFI ランタイム変数によってオペレーティングシステムが UEFI ブートマネージャなどのファームウェアの設定や UEFI Secure Boot プロトコルなどのキーの管理ができるようになっています。次を実行することでリストを取得できます:\n\n```\n$ efivar --list\n```\n\n"
    },
    {
      "title": "Linux カーネルでの UEFI 変数のサポート",
      "level": 3,
      "content": "Linux カーネルは efivarfs (EFI VARiable FileSystem) インターフェイスを通して UEFI 変数のデータをユーザスペースに公開します (CONFIG_EFIVAR_FS)。このインターフェイスは efivarfs カーネルモジュールを使って /sys/firmware/efi/efivars にマウントされます。変数ごとの最大サイズ制限は無く、UEFI Secure Boot 変数をサポートします。これはカーネル 3.8 で導入されました。\n\n"
    },
    {
      "title": "UEFI 変数のサポートを正しく動作させるための必要条件",
      "level": 3,
      "content": "1. カーネルが EFI ブートスタブ (任意で ブートマネージャー) を通して、またはブートローダーによって UEFI モードで起動している必要があります。BIOS や CSM、(同じく CSM の) Apple の Boot Camp を通して起動してはいない必要があります。\n1. EFI Runtime Services サポートがカーネルに存在する必要があります (CONFIG_EFI=y)。zgrep CONFIG_EFI /proc/config.gz で確認できます。\n1. カーネルコマンドラインでカーネルの EFI Runtime Services を無効にしてはいけません。つまり noefi カーネルコマンドラインは使わないで下さい。\n1. efivarfs ファイルシステムが /sys/firmware/efi/efivars にマウントされている必要があります。マウントされていない時は下の #efivarfs のマウント セクションに従って下さい。\n1. efivar はエラーを出さずに EFI 変数をリストアップ (-l/--list オプション) するはずです。\n\n上記の条件が満たされても EFI 変数のサポートが動かないときは、以下の回避策を試して下さい:\n\n1. UEFI 変数のリストアップ(efivar -l)の際に efivar: error listing variables: Function not implemented と言うメッセージが出て、かつ、システムがリアルタイムカーネルで起動する場合、カーネルパラメータに efi=runtime を追加して再起動してください(これらのカーネルでは efivarfs 機能がデフォルトで無効化されています)。\n1. さらなるドラブルシューティング手順は #ユーザスペースのツールが UEFI 変数のデータを変更できない を見てください。\n\n"
    },
    {
      "title": "efivarfs のマウント",
      "level": 4,
      "content": "efivarfs が起動中にsystemd によって自動的に /sys/firmware/efi/efivars にマウントされない場合、UEFI 変数を efibootmgr のようなユーザースペースツールに公開するために efivarfs を手動でマウントする必要があります:\n\n```\n# mount -t efivarfs efivarfs /sys/firmware/efi/efivars\n```\n\nカーネルドキュメントの efivarfs.html を参照してください。\n\n"
    },
    {
      "title": "ユーザースペースツール",
      "level": 3,
      "content": "UEFI 変数を表示・変更することができるツールがいくつかあります、即ち\n\n- efivar — UEFI 変数を操作するためのライブラリとツール (vathpela の efibootmgr によって使われます)\n\n- efibootmgr — UEFI Firmware Boot Manager の設定を操作するツール\n\n- uefivars — EFI 変数と追加の PCI 関連情報を表示します (内部で efibootmgr のコードを使っています)。\n\n- efitools — UEFI セキュアブートプラットフォームを操作するための UEFI ツール\n\n- Ubuntu's Firmware Test Suite — Intel/AMD PC のファームウェア上でサニティチェックを行うためのテストスイート\n\n"
    },
    {
      "title": "efibootmgr",
      "level": 4,
      "content": "efibootmgr パッケージをインストールする必要があります。\n\n- あなたの環境で efibootmgr が完全に動かない場合、再起動して #UEFI シェル に入り bcfg コマンドを使ってブートローダのブートエントリを作成してください。\n- efibootmgr を使えない場合、UEFI BIOS によっては BIOS から直接 uefi のブートオプションを管理できることがあります。例えば、ASUS の BIOS には \"Add New Boot Option\" からローカルの EFI System Partition を選択して直接 EFI スタブの位置を入力できます (例えば \\EFI\\refind\\refind_x64.efi)。\n- 下のコマンドではサンプルとして rEFInd ブートローダを使っています。\n\nefibootmgr を使って新しいブートオプションを追加するには、以下の3つを知っている必要があります:\n\n1. EFI システムパーティション (ESP) を含むディスク (例: /dev/sda /dev/nvme0n1)。\n1. そのディスク上にある ESP のパーティション番号。/dev/sdaY や /dev/nvme0n1pY の Y の部分のことです。\n1. EFI アプリケーションへのパス (ESP のルートからの相対パス)\n\n例えば、/efi が ESP のマウントポイントである場合に /efi/EFI/refind/refind_x64.efi 用のブートオプションを追加したい場合、以下を実行してください:\n\n```\n$ findmnt /efi\n```\n\n```\nTARGET SOURCE    FSTYPE OPTIONS\n/efi   /dev/sda1 vfat   rw,flush,tz=UTC\n```\n\nこの例では、findmnt(8) コマンドは、ESP がディスク /dev/sda 上にあり、そのパーティション番号が 1 であることを示しています。EFI アプリケーションへの、ESP をルートとした相対パスは /EFI/refind/refind_x64.efi となっています。故に、ブートエントリを以下のように作成することになります:\n\n```\n# efibootmgr --create --disk /dev/sda --part 1 --loader '\\EFI\\refind\\refind_x64.efi' --label 'rEFInd Boot Manager' --unicode\n```\n\nすべてのブートエントリを見るには:\n\n```\n# efibootmgr --unicode\n```\n\nブート順序を設定するには:\n\n```\n# efibootmgr --bootorder XXXX,XXXX --unicode\n```\n\nXXXX の部分は、前の efibootmgr コマンドの出力に出てきた番号です。\n\n不必要なエントリを削除するには:\n\n```\n# efibootmgr --delete-bootnum --bootnum XXXX --unicode\n```\n\nさらなる情報は efibootmgr(8) または efibootmgr README を見てください。\n\n"
    },
    {
      "title": "UEFI 変数へのアクセスを無効化",
      "level": 3,
      "content": "UEFI へのアクセスはオペレーティングシステムの実行レベルを超えて害を及ぼす可能性があります。実際、悪意のあるアクターがマシンの完全な制御を奪うことのできる LogoFAIL という危険な UEFI エクスプロイトが存在します。貧弱な UEFI 実装では場合によってはハードウェアレベルで起動不可能にすることも可能です。[2]\n\nゆえに、UEFI 変数へのアクセスは日常的なシステム使用において必要とされないので、潜在的なセキュリティ違反や偶発的な害を防ぐために無効化しておくことをおすすめします。\n\n可能な方法は:\n\n- efivars を fstab を用いて読み取り専用モードでマウントする。例えば: efivarfs /sys/firmware/efi/efivars efivarfs ro,nosuid,nodev,noexec 0 0\n- noefi カーネルパラメータを使用して、OS から UEFI へのアクセスを完全に無効化する。\n\n```\nefivarfs /sys/firmware/efi/efivars efivarfs ro,nosuid,nodev,noexec 0 0\n```\n\n"
    },
    {
      "title": "UEFI シェル",
      "level": 2,
      "content": "UEFI シェルは、uefi ブートローダを含む、uefi アプリケーションを起動するためのファームウェア用のシェル/ターミナルです。それとは別に、シェルは、システムやファームウェアのメモリーマップ (memmap) などの様々な情報を取得したり、ブートマネージャ変数を変更したり (bcfg)、パーティションプログラムを実行したり (diskpart)、uefi ドライバをロードしたり、テキストファイルを編集したり (edit) するのにも使われます。\n\n"
    },
    {
      "title": "UEFI シェルを入手する",
      "level": 3,
      "content": "Tianocore EDK2 プロジェクトから BSD ライセンスの UEFI シェルをダウンロードできます:\n\n- Shell v2: Arch インストールメディアの /shellx64.efi。ISO がビルドされたときの /usr/share/edk2-shell/x64/Shell_Full.efi のコピーです。 edk2-shell パッケージ - x64 (64ビット) UEFI 環境用の x64 シェルと IA32 (32ビット) UEFI 環境用の IA32 シェルを提供します - 最新の Tianocore EDK2 リリースから直接コンパイル uefi-shell-gitAUR パッケージ - x64 (64ビット) UEFI 環境用の x64 シェルと IA32 (32ビット) UEFI 環境用の IA32 シェルを提供します - 最新の Tianocore EDK2 ソースから直接コンパイル\n\n- Arch インストールメディアの /shellx64.efi。ISO がビルドされたときの /usr/share/edk2-shell/x64/Shell_Full.efi のコピーです。\n- edk2-shell パッケージ - x64 (64ビット) UEFI 環境用の x64 シェルと IA32 (32ビット) UEFI 環境用の IA32 シェルを提供します - 最新の Tianocore EDK2 リリースから直接コンパイル\n- uefi-shell-gitAUR パッケージ - x64 (64ビット) UEFI 環境用の x64 シェルと IA32 (32ビット) UEFI 環境用の IA32 シェルを提供します - 最新の Tianocore EDK2 ソースから直接コンパイル\n\n- Shell v1: TianoCore 由来の プリコンパイル済み UEFI Shell v1 バイナリ (2014/1/10 から上流は一度もアップデートされていません)。\n\n- TianoCore 由来の プリコンパイル済み UEFI Shell v1 バイナリ (2014/1/10 から上流は一度もアップデートされていません)。\n\n- 派生版: プリコンパイル済み UEFI Shell v2 バイナリと、UEFI pre-2.3 ファームウェアで動くように変更された bcfg[リンク切れ 2023-07-30] - Clover EFI ブートローダ由来。 広い範囲のファームウェアと互換性のあるプリコンパイル済み UEFI Shell v2 バイナリ - OpenCore ブートローダ由来。リリースアーカイブでは: EFI/OC/Tools/OpenShell.efi。\n\n- プリコンパイル済み UEFI Shell v2 バイナリと、UEFI pre-2.3 ファームウェアで動くように変更された bcfg[リンク切れ 2023-07-30] - Clover EFI ブートローダ由来。\n- 広い範囲のファームウェアと互換性のあるプリコンパイル済み UEFI Shell v2 バイナリ - OpenCore ブートローダ由来。リリースアーカイブでは: EFI/OC/Tools/OpenShell.efi。\n\nShell v2 は UEFI 2.3 以上のシステム上でだけ動作します。UEFI 2.3 以上のシステムでは Shell v1 より v2 を使うことが推奨されます。Shell v1 はスペックに関係なく全ての UEFI システムで動作するはずです。詳しくは ShellPkg や Inclusion of UEFI shell in Linux distro iso を見て下さい。\n\n"
    },
    {
      "title": "UEFI シェルの起動",
      "level": 3,
      "content": "数少ない Asus や他の AMI Aptio x64 UEFI ファームウェアベースのマザーボード (Sandy Bridge 以降) では、Launch EFI Shell from filesystem device と呼ばれるオプションが提供されています。これらのマザーボードでは、x64 UEFI Shell を EFI システムパーティション のルートに shellx64.efi という名前で コピーしてください。\n\n- Arch Linux インストールメディアにはボリュームのルートに shellx64.efi があります。\n- rEFInd と systemd-boot は、shellx64.efi が EFI システムパーティションのルートにある場合、自動的に UEFI シェルのブートメニューエントリを追加します。\n\nPhoenix SecureCore Tiano UEFI ファームウェアを使っているシステムには UEFI シェルが組み込まれていることが知られており F6, F11, F12 キーのどれかで起動できます。\n\n"
    },
    {
      "title": "重要な UEFI シェルコマンド",
      "level": 3,
      "content": "UEFI シェルコマンドはそれぞれのページの出力ごとにポーズを入れる -b オプションをサポートしています。利用できるコマンドを表示するには help -b を実行してください。\n\n詳しい情報は Intel Scripting Guide 2008[リンク切れ 2023-07-30] と Intel \"Course\" 2011[リンク切れ 2023-07-30] を見てください。\n\n"
    },
    {
      "title": "bcfg",
      "level": 4,
      "content": "bcfg コマンドは UEFI NVRAM エントリを修正して、ブートエントリやドライバオプションを変更できるようにするために使われます。このコマンドについては UEFI Shell Specification 2.2 ドキュメントの 96 ページ (Section 5.3) で詳しく説明されています。\n\n- efibootmgr が上手くブートエントリを作成できないときだけ bcfg を使うことが推奨されています。\n- UEFI Shell v1 の公式バイナリは bcfg コマンドをサポートしていません。#UEFI シェルを入手する を見て、UEFI pre-2.3 ファームウェアで動作する、修正された UEFI Shell v2 バイナリを入手してください。\n\n現在のブートエントリのリストを出力するには:\n\n```\nShell> bcfg boot dump -v\n```\n\n4番目の（番号は0から始まります）オプションとしてブートメニューに rEFInd (例) のブートメニューエントリを追加するには:\n\n```\nShell> bcfg boot add 3 FS0:\\EFI\\refind\\refind_x64.efi \"rEFInd Boot Manager\"\n```\n\nFS0: は EFI System Partition に、FS0:\\EFI\\refind\\refind_x64.efi は起動するファイルにそれぞれ適切にマッピングしてください。\n\nブートローダ無しでシステムを直接ブートするエントリを追加する方法については、EFI ブートスタブ#bcfg を見てください。\n\n4番目のブートオプションを削除するには:\n\n```\nShell> bcfg boot rm 3\n```\n\nブートオプション #3 を #0 (つまり UEFI ブートメニューの最初のエントリ) に移動するには:\n\n```\nShell> bcfg boot mv 3 0\n```\n\nbcfg のヘルプを見るには\n\n```\nShell> help bcfg -v -b\n```\n\nもしくは\n\n```\nShell> bcfg -? -v -b\n```\n\n"
    },
    {
      "title": "map",
      "level": 4,
      "content": "map はデバイスマッピング (つまり、利用可能なファイルシステム (FS0) とストレージデバイス (blk0) の名前) の一覧を表示します。\n\ncd や ls などのファイルシステムコマンドを実行する前に、ファイルシステムの名前を入力してシェルを適切なファイルシステムに変更する必要があります:\n\n```\nShell> fs0:\nfs0:\\> cd EFI/\n```\n\n"
    },
    {
      "title": "edit",
      "level": 4,
      "content": "edit コマンドは nano テキストエディタに似たベーシックなテキストエディタを提供します、ただし機能は少なくなっています。EDIT コマンドのテキストエディタは UTF-8 エンコードや LF と CRLF の改行コードを扱うことができます。\n\n例として、システムパーティションの rEFInd の refind.conf を編集するには (ファームウェア内の FS0:)\n\n```\nShell> edit FS0:\\EFI\\refind\\refind.conf\n```\n\nヘルプを出すには Ctrl+e を押して下さい。\n\n"
    },
    {
      "title": "UEFI ドライバ",
      "level": 2,
      "content": "UEFI ドライバとは、なんらかの機能をサポートするためのソフトウェアのことです。例えば、NTFS でフォーマットされたパーティションは通常 UEFI シェルからアクセスできません。efifs パッケージには、EFI シェル内から多くのファイルシステムを読み込めるようにするドライバが含まれています。使用例を挙げましょう。そのようなドライバを UEFI シェルからアクセス可能なパーティションにコピーして、UEFI シェルから以下のようなコマンドを実行します:\n\n```\nShell> load ntfs_x64.efi\nShell> map -r\n```\n\nmap コマンドを実行したあと、ユーザは NTFS でフォーマットされたパーティションに UEFI シェル内からアクセスできるようになっているはずです。\n\n- systemd-boot は esp/EFI/systemd/drivers/ から UEFI ドライバを自動的に読み込みます。\n- rEFInd は、ESP 上の rEFInd インストール先ディレクトリのサブディレクトリ drivers と drivers_x64 (例: esp/EFI/refind/drivers_x64/) から UEFI ドライブを自動的に読み込みます。他のディレクトリをスキャンするように設定することも可能です。\n\n"
    },
    {
      "title": "光学メディアから UEFI ブートサポートを削除する",
      "level": 3,
      "content": "- このセクションでは USB フラッシュドライブではなく CD/DVD (EL Torito からブートする光学メディア) から UEFI ブートサポートを削除する方法を説明しています。\n- USB スティック上の UEFI 機構を隠すには、ISO をフラッシュドライブにコピーしたあとでパーティションエディタを使ってください。EF タイプのパーティションを削除してください。GPT に変換するか尋ねられたときはいいえと答えてください。\n\nほとんどの32ビット EFI Mac と一部の64ビット EFI Mac は UEFI(X64)+BIOS ブータブル CD/DVD からの起動を拒否します。光学メディアを使ってインストールをしたい場合、まず UEFI サポートを削除する必要があるかもしれません。\n\nUEFI 特有のディレクトリを除いて ISO を展開してください:\n\n```\n$ mkdir extracted_iso\n$ bsdtar -x --exclude=EFI/ --exclude=loader/ -f archlinux-version-x86_64.iso -C extracted_iso\n```\n\nそして、libisoburn の xorriso(1) を使って ISO を再ビルドしてください。この時、UEFI 光学メディアのブートサポートを除いてください。正しいボリュームラベルを設定してください(例えば ARCH_202103)。ボリュームラベルは、オリジナルの ISO に対して file(1) を使うことで得られます。\n\n```\n$ xorriso -as mkisofs \\\n    -iso-level 3 \\\n    -full-iso9660-filenames \\\n    -joliet \\\n    -joliet-long \\\n    -rational-rock \\\n    -volid \"ARCH_YYYYMM\" \\\n    -appid \"Arch Linux Live/Rescue CD\" \\\n    -publisher \"Arch Linux <https://archlinux.org>\" \\\n    -preparer \"prepared by $USER\" \\\n    -eltorito-boot syslinux/isolinux.bin \\\n    -eltorito-catalog syslinux/boot.cat \\\n    -no-emul-boot -boot-load-size 4 -boot-info-table \\\n    -isohybrid-mbr \"extracted_iso/syslinux/isohdpfx.bin\" \\\n    -output archlinux-version-x86_64-noUEFI.iso extracted_iso/\n```\n\narchlinux-version-x86_64-noUEFI.iso を光学メディアに焼いて、通常のインストールを続けてください。\n\n"
    },
    {
      "title": "仮想マシン用の OVMF",
      "level": 3,
      "content": "OVMF は仮想マシンで UEFI サポートを有効にする TianoCore プロジェクトです。OVMF には QEMU 用のサンプル UEFI ファームウェアが含まれています。\n\nedk2-ovmf をインストールできます。\n\n仮想マシンの非揮発性変数のローカルコピーを作成することが推奨されています:\n\n```\n$ cp /usr/share/edk2/x64/OVMF_VARS.4m.fd my_OVMF_VARS.4m.fd\n```\n\nOVMF ファームウェアとこの変数を使うには、以下を QEMU コマンドに追加してください:\n\n```\n-drive if=pflash,format=raw,readonly,file=/usr/share/edk2/x64/OVMF_CODE.4m.fd \\\n-drive if=pflash,format=raw,file=my_OVMF_VARS.4m.fd\n```\n\n例えば:\n\n```\n$ qemu-system-x86_64 -enable-kvm -m 1G -drive if=pflash,format=raw,readonly,file=/usr/share/edk2/x64/OVMF_CODE.4m.fd -drive if=pflash,format=raw,file=my_OVMF_VARS.4m.fd …\n```\n\n"
    },
    {
      "title": "BIOS システム専用の DUET",
      "level": 3,
      "content": "DUET は、BIOS のオペレーティングシステムブートと同じような方法で、BIOS 環境から完全な UEFI 環境をチェーンロードできるようにする TianoCore プロジェクトです。この方法については広く議論されています。ビルド済み DUET イメージは、いくつかのリポジトリ[リンク切れ 2023-04-07]のどれかからダウンロードできます。DUET をセットアップする特定の方法については、特定の指示[リンク切れ 2023-04-07]を読んでください。しかし、2018年11月に DUET のコードが TianoCore git リポジトリから削除されました。\n\nまた、修正 DUET イメージを提供する Clover を試すことも可能です。特定環境の修正が含まれており gitlab リポジトリと比べて頻繁に更新されています。\n\n"
    },
    {
      "title": "Windows で固まった際に Arch Linux に戻る",
      "level": 3,
      "content": "Windows で固まった際に Arch Linux に戻るには、Windows PowerShell コマンド shutdown /r /o、または Settings > Update & Security > Recovery > Advanced startup の Restart now を選んで Windows の Advanced startup に進んでください。Advanced startup メニューに行き着いた際に、Use a device を選んでください。これには実際の UEFI ブートオプションが含まれています(USB や CD に限らず、ハードドライブ内の OS も起動できます)。そして、\"Arch Linux\" を選んでください。\n\n"
    },
    {
      "title": "ファンクションキー無しでファームウェアセットアップに入る",
      "level": 3,
      "content": "en:Lenovo XiaoXin 15are 2020 のような一部のノート PC では、F2 や F12 のようなキーを使用しても何も起こりません。OEM にノート PC を返却しメインボード情報の修復を行えばおそらく修正可能ですが、時々これが不可能である、または望ましくない場合があります。しかし、ファームウェアセットアップに入る他の方法が存在します:\n\n- systemctl を使用: $ systemctl reboot --firmware-setup これによりコンピュータが再起動され、ファームウェアセットアップに入ります。\n- GRUB を使用: コマンドラインに入るために c を押し、GRUB コマンドラインで fwsetup を使用してファームウェアセットアップに入る。\n- Windows で: Advanced Startup に入る。#Windows で固まった際に Arch Linux に戻る を見てください。\n\n```\n$ systemctl reboot --firmware-setup\n```\n\n"
    },
    {
      "title": "ユーザスペースのツールが UEFI 変数のデータを変更できない",
      "level": 3,
      "content": "如何なるユーザスペースツールを持ってしても UEFI 変数のデータを変更できない場合、/sys/firmware/efi/efivars/dump-* ファイルが存在するかどうかを確認してください。存在する場合、それらを削除し、再起動して再び試してみてください。\n\nこの手順でもこの問題を解決できない場合、efi_no_storage_paranoia カーネルパラメータを使用して起動してみてください(このカーネルパラメータは、UEFI 変数の書き込み/変更を妨げてしまうカーネル UEFI 変数ストレージスペースチェックを無効化します)。\n\n"
    },
    {
      "title": "efibootmgr でブートエントリを新規作成できない",
      "level": 3,
      "content": "カーネルと efibootmgr のバージョンの組み合わせによっては、ブートエントリの新規作成ができなるなるかもしれません。これは NVRAM の空き領域の不足によるものであることがあります。#ユーザスペースのツールが UEFI 変数のデータを変更できない の解決策を試すことができます。\n\nまた、efibootmgr をバージョン 0.11.0 までダウングレードしてみることもできます。このバージョンは Linux バージョン 4.0.6 で機能します。詳細はバグのディスカッション FS#34641、特に closing comment を見てください。\n\n"
    },
    {
      "title": "Windows によってブート順序が変わってしまう",
      "level": 3,
      "content": "Windows と Arch のデュアルブートをしていて、マザーボードがあなたの選んだ EFI アプリケーションではなく Windows を即座に起動する場合、いくつかのあり得る原因と回避策があります。\n\n- 高速スタートアップが Windows の電源オプションで無効化されていることを確認してください。\n- セキュアブートがファームウェアで無効化されていることを確認してください(署名済みのブートローダを使用していない場合)。\n- UEFI のブート順序で Windows Boot Manager が1番めに設定されていないことを確認してください(例: efibootmgr を使用)。一部のマザーボードは、Windows によって efibootmgr を使って設定したものを検出するとデフォルトで上書きします。これは Packard Bell ノート PC で確認されています。\n- マザーボードがデフォルトブートパス (\\EFI\\BOOT\\BOOTx64.EFI) を起動する場合、このファイルは Windows ブートローダで上書きされる場合があります。efibootmgr などを使用して、正しい\n\nブートパスを設定してみてください。\n\n- 前の手順でうまく行かなかった場合、Windows ブートローダに異なる EFI アプリケーションを実行するように指示することができます。Windows 管理者コマンドプロンプトから bcdedit /set \"{bootmgr}\" path \"\\EFI\\path\\to\\app.efi\"。\n- または、efibootmgr -A -b bootnumber を root として実行することで Windows Boot Manager を無効化する。bootnumber の部分は実際の Windows Boot Manager のブート番号に置き換えてください。efibootmgr をオプション足で実行することでブート番号を確認できます。\n- または、Windows を起動するたびにブート順序が正しく設定されているかを確認するスタートアップスクリプトを Windows で設定することができます。 管理者権限でコマンドプロンプトを開き、bcdedit /enum firmware を実行して、お望みのブートエントリを見つけてください。 カッコも含めて識別子をコピーしてください。例: {31d0d5f4-22ad-11e5-b30b-806e6f6e6963} 次のコマンドを含むバッチファイルを作成してください: bcdedit /set \"{fwbootmgr}\" DEFAULT \"{コピーしたブート識別子}\" gpedit.msc を開き、Local Computer Policy > Computer Configuration > Windows Settings > Scripts (Startup/Shutdown) にある Startup をクリックしてください。 Scripts タブに行き、Add ボタンをクリックし、そのバッチファイルを選択してください。\n\n1. 管理者権限でコマンドプロンプトを開き、bcdedit /enum firmware を実行して、お望みのブートエントリを見つけてください。\n1. カッコも含めて識別子をコピーしてください。例: {31d0d5f4-22ad-11e5-b30b-806e6f6e6963}\n1. 次のコマンドを含むバッチファイルを作成してください: bcdedit /set \"{fwbootmgr}\" DEFAULT \"{コピーしたブート識別子}\"\n1. gpedit.msc を開き、Local Computer Policy > Computer Configuration > Windows Settings > Scripts (Startup/Shutdown) にある Startup をクリックしてください。\n1. Scripts タブに行き、Add ボタンをクリックし、そのバッチファイルを選択してください。\n\n- または、Windows でスタートアップするクリプトを実行するためにタスクスケジューラを使用することができます: 上記の1から3の手順に従って、バッチファイルを作成してください。 taskschd.msc を実行し、Action メニュから Create Task... を選んでください。 General タブで: 適当な任意の Name と Description を入力してください。 選択したユーザアカウントが \"Administrator\" (管理者)であることを確認してください。\"Standard User\" であってはなりません。 \"Run whether user is logged in or not\" を選択してください。 \"Run with highest privileges\" を選択してください。 Triggers タブで、メニューから \"At startup\" を選択して、その後 OK を押してください。 Actions タブで、New... をクリックし、Browse... をクリックし、手順1 で作成したバッチファイルを選択してください。 Conditions tab タブで、Power オプションのチェックを解除してください。そうすれば、バッテリ駆動時にスクリプトが実行されます(ラップトップの場合)。\n\n1. 上記の1から3の手順に従って、バッチファイルを作成してください。\n1. taskschd.msc を実行し、Action メニュから Create Task... を選んでください。\n1. General タブで: 適当な任意の Name と Description を入力してください。 選択したユーザアカウントが \"Administrator\" (管理者)であることを確認してください。\"Standard User\" であってはなりません。 \"Run whether user is logged in or not\" を選択してください。 \"Run with highest privileges\" を選択してください。\n1. Triggers タブで、メニューから \"At startup\" を選択して、その後 OK を押してください。\n1. Actions タブで、New... をクリックし、Browse... をクリックし、手順1 で作成したバッチファイルを選択してください。\n1. Conditions tab タブで、Power オプションのチェックを解除してください。そうすれば、バッテリ駆動時にスクリプトが実行されます(ラップトップの場合)。\n\n1. OK をクリックして、パスワードのプロンプトが表示された場合は手順4で選択したユーザアカウントのパスワードを入力してください。\n\n- OK をクリックして、パスワードのプロンプトが表示された場合は手順4で選択したユーザアカウントのパスワードを入力してください。\n\n"
    },
    {
      "title": "USB メディアが黒画面で固まる",
      "level": 3,
      "content": "この問題は KMS の問題によって起こることがあります。USB を起動するときは KMS を無効化してみて下さい。\n\n"
    },
    {
      "title": "ファームウェアのメニューに UEFI ブートローダーが表示されない",
      "level": 3,
      "content": "一部のファームウェアはカスタムのブートエントリをサポートしていません。そのようなファームウェアはハードコードされたブートエントリからしか起動しません。\n\n典型的な回避策は、NVRAM のブートエントリに頼るのではなく、EFI システムパーティション内の共通フォールバックパスの一つにブートローダーをインストールすることです。\n\n以下のセクションではそのフォールバックパスについて説明しています。\n\n"
    },
    {
      "title": "リムーバブルドライブのデフォルトブートパス",
      "level": 4,
      "content": "UEFI 仕様では、リムーバブルメディアから起動するための EFI バイナリのデフォルトファイルパスが定義されています。関連するものとしては:\n\n- esp/EFI/BOOT/BOOTx64.EFI - x64 UEFI 用\n- esp/EFI/BOOT/BOOTIA32.EFI - IA32 UEFI 用\n\n仕様では、これらはリムーバブルドライブのみ用であると定義されている一方、ほとんどのファームウェアはこれらの起動をすべてのドライブでサポートしています。\n\nブートローダーをデフォルト/フォールバックブートパスにインストール/統合する方法については適切なブートローダーの記事を見てください。\n\n"
    },
    {
      "title": "Microsoft Windows ブートローダの場所",
      "level": 4,
      "content": "Itenl Z77 チップセット搭載の一部のボードのような特定の UEFI マザーボードでは、UEFI シェルから efibootmgr/bcfg を使用してエントリを追加することができません。NVRAM に追加したあとにエントリがブートメニューに表示されないためです。\n\nこの問題はマザーボードが Microsoft Windows しか読み込めないため発生します。これを解決するには、Windows が使用する場所に .efi ファイルを配置する必要があります。\n\nArch Linux インストールメディア(FSO:) からハードドライブ(FS1:)上の ESP パーティション内の Microsoft ディレクトリへ BOOTx64.EFI ファイルをコピーしてください。EFI シェルを起動し、以下を実行してください:\n\n```\nShell> mkdir FS1:\\EFI\\Microsoft\nShell> mkdir FS1:\\EFI\\Microsoft\\Boot\nShell> cp FS0:\\EFI\\BOOT\\BOOTx64.EFI FS1:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\n```\n\n再起動後、NVRAM に追加したエントリがブートメニュに表示されるはずです。\n\n"
    },
    {
      "title": "UEFI/BIOS がロード画面で固まる",
      "level": 3,
      "content": "これは Acer のノート PC で繰り返し起きる問題です。.efi ファイルが手動で承認されていない場合に発生します。ノートパソコン/Acer#Linux のインストール後にファームウェアのセットアップ画面にアクセスできなくなった を参照してください。\n\n"
    },
    {
      "title": "efibootmgr で作成したブートエントリが UEFI に表示されない",
      "level": 3,
      "content": "efibootmgr は EDD 3.0 の検出に失敗する可能性があり、その結果、NVRAM に利用不可能なブートエントリを作成してしまいます。詳細は efibootmgr issue 86 を見てください。\n\nこれを回避するには、ブートエントリを手動で作成する際に、-e 3 オプションを efibootmgr コマンドに追加してください。例:\n\n```\n# efibootmgr --create --disk /dev/sda --part 1 --loader '\\EFI\\refind\\refind_x64.efi' --label 'rEFInd Boot Manager' --unicode -e 3\n```\n\ngrub-install や refind-install のようなブートローダインストーラを修復するには、/usr/local/bin/efibootmgr ラッパースクリプトを作成し、それを実行可能にしてください:\n\n```\n/usr/local/bin/efibootmgr\n```\n\n```\n#!/bin/sh\n\nexec /usr/bin/efibootmgr -e 3 \"$@\"\n```\n\n"
    },
    {
      "title": "UEFI ブートエントリが、参照するドライブを取り外すと消える",
      "level": 3,
      "content": "一部のファームウェアは、参照されているドライブが起動中に存在しない場合、そのブートエントリを削除します。これは、ドライブを頻繁に取り付け/取り外ししたり、リムーバブルドライブから起動する際に問題となりえます。\n\n解決策は、ブートローダーをデフォルト/フォールバックブートパスにインストールすることです。\n\n"
    },
    {
      "title": "ブートエントリがランダムに削除される",
      "level": 3,
      "content": "一部のマザーボードは、NVRAM の空き領域が足りない場合、ブートエントリの作成時にエラーを表示せずに、ブートエントリを削除してしまうことがあります。これを防ぐには、エントリの作成プロセスを最小限にして、追加されるブートエントリの数を減らし、さらに、UEFI 設定から Compatibility Support Module (CSM) を無効化して、自動ドライブブートエントリの数も減らしてください。BBS#1608838 を参照してください。\n\nブートエントリが削除されてしまう他の原因として、UEFI 仕様では「NVRAM メンテナンス」をブート中に実行することが OEM に許可されていることも挙げられます。そのようなメーカーのデバイスは、事前定義されハードコードされているデバイス上のパスで EFI アプリケーションを探索するだけです。何も見つけられなかった場合、デバイス上にはオペレーティングシステムが存在しないと結論づけ、NVRAM 上に破損しているまたは古いデータが存在すると推測し、そのデバイスと関連する NVRAM からすべてのブートエントリを消してしまいます。Windows をインストールする予定がなく、ファームウェアから Linux カーネルを直接ロードしたい場合、解決策として空のファイル esp/EFI/BOOT/BOOTx64.EFI を作成するというものがあります:\n\n```\n# mkdir -p esp/EFI/BOOT \n# touch esp/EFI/BOOT/BOOTx64.EFI\n```\n\nそして、削除されたブートエントリを作り直してください。これで、再起動すれば、マザーボードは「偽のOS」を検出し、NVRAM から他のブートエントリを削除しなくなるはずです。この偽のオペレーティングシステムローダは実際の EFI アプリケーションに自由に変更することもできます。もちろん、標準のフォールバック名を使い続ける限りです。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- UEFI Forum - 公式の UEFI の仕様書 - GUID Partition Table は UEFI の仕様に含まれています\n- UEFI boot: how does that actually work, then? - AdamW によるブログ記事\n- Linux カーネルの x86_64 プラットフォーム向け UEFI ドキュメント\n- Intel の EFI に関するページ\n- Intel Architecture Firmware Resource Center[リンク切れ 2023-07-30]\n- Matt Fleming - The Linux EFI Boot Stub\n- Matt Fleming - Accessing UEFI Variables from Linux\n- Rod Smith - Linux on UEFI: クイックインストールガイド\n- 一部の新しいマシンでの UEFI ブート問題 (LKML)\n- LPC 2012 Plumbing UEFI into Linux\n- LPC 2012 UEFI チュートリアル : part 1\n- LPC 2012 UEFI チュートリアル : part 2\n- Intel の Tianocore プロジェクト 直接 BIOS で起動するための DuetPkg や QEMU や Oracle VirtualBox で使用される OvmfPkg が含まれているオープンソースの UEFI ファームウェア\n- FGA: The EFI boot process\n- Microsoft の Windows と GPT の FAQ\n- 再インストールせずに Windows x64 を BIOS-MBR モードから UEFI-GPT モードに移行\n- Linux BIOS+UEFI と Windows x64 BIOS+UEFI ブータブル USB ドライブの作成\n- Rod Smith - A BIOS to UEFI Transformation\n- - Intel ドキュメント\n- UEFI Shell - Intel ドキュメント\n- UEFI Shell - bcfg コマンドの情報\n- The bootstrap process on EFI systems\n\n"
    }
  ]
}