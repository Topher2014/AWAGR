{
  "title": "GRUB (日本語)",
  "url": "https://wiki.archlinux.org/title/GRUB_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Arch ブートプロセス\n- Master Boot Record\n- GUID Partition Table\n- Unified Extensible Firmware Interface\n- GRUB Legacy\n- GRUB/EFI サンプル\n- GRUB/ヒントとテクニック\n- マルチブート USB ドライブ\n\nGRUB (GRand Unified Bootloader) はブートローダーです。現在の GRUB は GRUB 2 とも呼ばれています。元の GRUB (GRUB Legacy) はバージョン 0.9x に対応しています。このページでは GRUB 2 についてのみ説明します。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 サポートされているファイルシステム\n- 2 UEFI システム 2.1 インストール 2.2 セキュアブートサポート 2.2.1 CA 鍵 2.2.2 Shim-lock 2.2.3 セキュアブートを使用する\n- 3 BIOS システム 3.1 GUID Partition Table (GPT) 特有の手順 3.2 Master Boot Record (MBR) 特有の手順 3.3 インストール\n- 4 設定 4.1 grub.cfg の生成 4.1.1 メイン設定ファイルの生成 4.1.2 他の OS の検出 4.1.2.1 Windows 4.1.3 追加引数 4.1.4 トップレベルのメニューエントリを設定する 4.1.5 LVM 4.1.6 RAID 4.1.7 暗号化された /boot 4.1.7.1 LUKS2 4.2 grub.cfg のカスタマイズ 4.2.1 LoaderDevicePartUUID 4.2.2 ブートメニューエントリの例 4.2.2.1 GRUB コマンド 4.2.2.1.1 \"Shutdown\" メニューエントリ 4.2.2.1.2 \"Restart\" メニューエントリ 4.2.2.1.3 \"UEFI Firmware Settings\" メニューエントリ 4.2.2.2 EFI バイナリ 4.2.2.2.1 UEFI シェル 4.2.2.2.2 gdisk 4.2.2.2.3 ユニファイドカーネルイメージをチェインロード 4.2.2.3 デュアルブート 4.2.2.3.1 GNU/Linux 4.2.2.3.2 UEFI/GPT モードでインストールされた Windows 4.2.2.3.3 BIOS/MBR モードでインストールされた Windows 4.2.2.4 ラベルを使う\n- 5 コマンドシェルを使う 5.1 ページャのサポート 5.2 コマンドシェル環境を使ってオペレーティングシステムを起動する 5.2.1 パーティションの VBR をチェインロード 5.2.2 ディスクの MBR やパーティションレスディスクの VBR をチェインロード 5.2.3 UEFI モードでインストールされた Windows/Linux のチェインロード 5.2.4 通常のロード 5.3 rescue コンソールを使う\n- 6 GRUB を消去 6.1 UEFI システム 6.2 BIOS システム\n- 7 トラブルシューティング 7.1 サポートのないファイルシステム 7.2 デバッグメッセージを有効にする 7.3 msdos-style エラーメッセージ 7.4 UEFI 7.4.1 よくあるインストール時のエラー 7.4.2 ファームウェアブートマネージャーに GRUB エントリを作成する 7.4.3 レスキューシェルが起動する 7.4.4 GRUB UEFI がロードされない 7.4.5 デフォルト/フォールバックのブートパス 7.5 Invalid signature 7.6 起動中にフリーズする 7.7 他の OS から Arch が見つからない 7.8 chroot でインストールした時に警告が表示される 7.9 GRUB のロードが遅い 7.10 error: unknown filesystem 7.11 grub-reboot で再設定されない 7.12 古い Btrfs のせいでインストールができない 7.13 Windows 8/10 が認識されない 7.14 grub-rescue プロンプトと暗号化済み /boot 7.15 GRUB をインストールしたが起動時にメニューが表示されない\n- 8 参照\n\n- 2.1 インストール\n- 2.2 セキュアブートサポート 2.2.1 CA 鍵 2.2.2 Shim-lock 2.2.3 セキュアブートを使用する\n\n- 2.2.1 CA 鍵\n- 2.2.2 Shim-lock\n- 2.2.3 セキュアブートを使用する\n\n- 3.1 GUID Partition Table (GPT) 特有の手順\n- 3.2 Master Boot Record (MBR) 特有の手順\n- 3.3 インストール\n\n- 4.1 grub.cfg の生成 4.1.1 メイン設定ファイルの生成 4.1.2 他の OS の検出 4.1.2.1 Windows 4.1.3 追加引数 4.1.4 トップレベルのメニューエントリを設定する 4.1.5 LVM 4.1.6 RAID 4.1.7 暗号化された /boot 4.1.7.1 LUKS2\n- 4.2 grub.cfg のカスタマイズ 4.2.1 LoaderDevicePartUUID 4.2.2 ブートメニューエントリの例 4.2.2.1 GRUB コマンド 4.2.2.1.1 \"Shutdown\" メニューエントリ 4.2.2.1.2 \"Restart\" メニューエントリ 4.2.2.1.3 \"UEFI Firmware Settings\" メニューエントリ 4.2.2.2 EFI バイナリ 4.2.2.2.1 UEFI シェル 4.2.2.2.2 gdisk 4.2.2.2.3 ユニファイドカーネルイメージをチェインロード 4.2.2.3 デュアルブート 4.2.2.3.1 GNU/Linux 4.2.2.3.2 UEFI/GPT モードでインストールされた Windows 4.2.2.3.3 BIOS/MBR モードでインストールされた Windows 4.2.2.4 ラベルを使う\n\n- 4.1.1 メイン設定ファイルの生成\n- 4.1.2 他の OS の検出 4.1.2.1 Windows\n- 4.1.3 追加引数\n- 4.1.4 トップレベルのメニューエントリを設定する\n- 4.1.5 LVM\n- 4.1.6 RAID\n- 4.1.7 暗号化された /boot 4.1.7.1 LUKS2\n\n- 4.1.2.1 Windows\n\n- 4.1.7.1 LUKS2\n\n- 4.2.1 LoaderDevicePartUUID\n- 4.2.2 ブートメニューエントリの例 4.2.2.1 GRUB コマンド 4.2.2.1.1 \"Shutdown\" メニューエントリ 4.2.2.1.2 \"Restart\" メニューエントリ 4.2.2.1.3 \"UEFI Firmware Settings\" メニューエントリ 4.2.2.2 EFI バイナリ 4.2.2.2.1 UEFI シェル 4.2.2.2.2 gdisk 4.2.2.2.3 ユニファイドカーネルイメージをチェインロード 4.2.2.3 デュアルブート 4.2.2.3.1 GNU/Linux 4.2.2.3.2 UEFI/GPT モードでインストールされた Windows 4.2.2.3.3 BIOS/MBR モードでインストールされた Windows 4.2.2.4 ラベルを使う\n\n- 4.2.2.1 GRUB コマンド 4.2.2.1.1 \"Shutdown\" メニューエントリ 4.2.2.1.2 \"Restart\" メニューエントリ 4.2.2.1.3 \"UEFI Firmware Settings\" メニューエントリ\n- 4.2.2.2 EFI バイナリ 4.2.2.2.1 UEFI シェル 4.2.2.2.2 gdisk 4.2.2.2.3 ユニファイドカーネルイメージをチェインロード\n- 4.2.2.3 デュアルブート 4.2.2.3.1 GNU/Linux 4.2.2.3.2 UEFI/GPT モードでインストールされた Windows 4.2.2.3.3 BIOS/MBR モードでインストールされた Windows\n- 4.2.2.4 ラベルを使う\n\n- 4.2.2.1.1 \"Shutdown\" メニューエントリ\n- 4.2.2.1.2 \"Restart\" メニューエントリ\n- 4.2.2.1.3 \"UEFI Firmware Settings\" メニューエントリ\n\n- 4.2.2.2.1 UEFI シェル\n- 4.2.2.2.2 gdisk\n- 4.2.2.2.3 ユニファイドカーネルイメージをチェインロード\n\n- 4.2.2.3.1 GNU/Linux\n- 4.2.2.3.2 UEFI/GPT モードでインストールされた Windows\n- 4.2.2.3.3 BIOS/MBR モードでインストールされた Windows\n\n- 5.1 ページャのサポート\n- 5.2 コマンドシェル環境を使ってオペレーティングシステムを起動する 5.2.1 パーティションの VBR をチェインロード 5.2.2 ディスクの MBR やパーティションレスディスクの VBR をチェインロード 5.2.3 UEFI モードでインストールされた Windows/Linux のチェインロード 5.2.4 通常のロード\n- 5.3 rescue コンソールを使う\n\n- 5.2.1 パーティションの VBR をチェインロード\n- 5.2.2 ディスクの MBR やパーティションレスディスクの VBR をチェインロード\n- 5.2.3 UEFI モードでインストールされた Windows/Linux のチェインロード\n- 5.2.4 通常のロード\n\n- 6.1 UEFI システム\n- 6.2 BIOS システム\n\n- 7.1 サポートのないファイルシステム\n- 7.2 デバッグメッセージを有効にする\n- 7.3 msdos-style エラーメッセージ\n- 7.4 UEFI 7.4.1 よくあるインストール時のエラー 7.4.2 ファームウェアブートマネージャーに GRUB エントリを作成する 7.4.3 レスキューシェルが起動する 7.4.4 GRUB UEFI がロードされない 7.4.5 デフォルト/フォールバックのブートパス\n- 7.5 Invalid signature\n- 7.6 起動中にフリーズする\n- 7.7 他の OS から Arch が見つからない\n- 7.8 chroot でインストールした時に警告が表示される\n- 7.9 GRUB のロードが遅い\n- 7.10 error: unknown filesystem\n- 7.11 grub-reboot で再設定されない\n- 7.12 古い Btrfs のせいでインストールができない\n- 7.13 Windows 8/10 が認識されない\n- 7.14 grub-rescue プロンプトと暗号化済み /boot\n- 7.15 GRUB をインストールしたが起動時にメニューが表示されない\n\n- 7.4.1 よくあるインストール時のエラー\n- 7.4.2 ファームウェアブートマネージャーに GRUB エントリを作成する\n- 7.4.3 レスキューシェルが起動する\n- 7.4.4 GRUB UEFI がロードされない\n- 7.4.5 デフォルト/フォールバックのブートパス\n\n"
    },
    {
      "title": "サポートされているファイルシステム",
      "level": 2,
      "content": "GRUB には複数のファイルシステム (特に重要なものとしては FAT32、ext4、Btrfs、XFS) に対する独自のサポートがあります。注意事項に関しては #サポートのないファイルシステム 章を見てください。\n\n"
    },
    {
      "title": "UEFI システム",
      "level": 2,
      "content": "- 次のページを読んで理解しておくことをおすすめします: Unified Extensible Firmware Interface、パーティショニング#GUID Partition Table、Arch ブートプロセス#UEFI_2。\n- UEFI を使うようにインストールする場合、Arch のインストールメディアを UEFI モードで起動することが重要です。さもないと、efibootmgr が GRUB の UEFI ブートエントリを追加できません。フォールバックブートパスへのインストールは NVRAM を使用しないため、BIOS モードでも可能です。\n- UEFI を使用してディスクから起動するには EFI システムパーティションが必要です。EFI システムパーティション#既存のパーティションの確認 に従って、すでに EFI システムパーティションが存在するかどうかを確認してください。存在しない場合は作成する必要があります。\n- この記事全体で、insmod を使って追加の GRUB2 モジュールを挿入可能であると仮定しています。#Shim-lock で議論されているように、これはセキュアブートが有効化されている UEFI システムには当てはまりません。セキュアブートシステム上で標準の GRUB EFI ファイル grubx64.efi に含まれていない追加の GRUB モジュールを使用したい場合は、grub-mkstandalone を使って追加の GRUB モジュールを含めた GRUB EFI grubx64.efi を再生成しなければなりません。\n\n"
    },
    {
      "title": "インストール",
      "level": 3,
      "content": "- UEFI の実装はマザーボード製造者ごとに異なっています。以下で説明されている手順は広い範囲の UEFI システムで動作するように意図されています。しかし、この方法を適用しているにも関わらず問題が発生する場合は、あなたのハードウェア固有のケースにおける詳細な情報を (可能であれば解決策も) 共有することが推奨されます。そのようなケースのために GRUB/EFI サンプル の記事が提供されています。\n- このセクションでは、あなたが x64 (64 ビット) UEFI のシステムに対して GRUB をインストールしようとしていると仮定します。IA32 (32 ビット) UEFI の場合は (32 ビット CPU と混同しないでください)、適切な場所で x86_64-efi を i386-efi に置き換えてください。Unified Extensible Firmware Interface#UEFI ファームウェアのビット数を調べる の手順を見て、UEFI のビット数を調べてください。\n\nまず、grub と efibootmgr をインストールしてください。GRUB はブートローダである一方、efibootmgr はブートエントリを NVRAM に書き込むために GRUB のインストールスクリプトによって使用されます。\n\nそして、以下の手順に従って GRUB をディスクにインストールしてください:\n\n1. EFI システムパーティションをマウントしてください。そして、このセクションの後の部分で出てくる esp という記述をそのマウントポイントに置き換えてください。\n1. ブートローダの識別子を選んでください、ここでは仮に GRUB としましょう。esp/EFI/ にあなたが選んだものと同じ名前のディレクトリが作成され、そこに EFI バイナリが格納されます。その名前が UEFI ブートメニューの GRUB ブートエントリの名前になります。\n1. 以下のコマンドを実行して、GRUB EFI アプリケーション grubx64.efi を esp/EFI/GRUB/ に、モジュールを /boot/grub/x86_64-efi/ にインストールしてください。\n\n- GRUB をブートローダとしてインストールするシステム内でパッケージをインストールし、grub-install を実行してください。つまり、ライブインストール環境から起動している場合、grub-install は (インストール先の) chroot 環境の中で実行する必要があるということです。何らかの理由で、インストールされたシステムの外で grub-install を実行する必要がある場合、マウントした /boot ディレクトリへのパスを --boot-directory= オプションに渡してください。例: --boot-directory=/mnt/boot\n- 一部のマザーボードは、空白を含む bootloader-id を扱うことができません。\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB\n```\n\n上記のインストール作業が完了した後、メインの GRUB ディレクトリが /boot/grub/ に作成されています。別の場所を指定する方法については GRUB/ヒントとテクニック#代替インストール方法 を見てください。grub-install はファームウェアのブートマネージャにもエントリを作成しようとすることに注意してください。その名前は上記の例では GRUB となります。しかし、ブートエントリが埋まっていると、これは失敗します。この場合は efibootmgr を使って必要ないエントリを削除してください。\n\n設定を確定したあとにメインの設定ファイルを生成することを忘れないでください。\n\n- --efi-directory と --bootloader-id は GRUB UEFI 専用です。--efi-directory は、非推奨となった --root-directory を置き換えます。\n- grub-install コマンドに device_path オプション (例えば /dev/sda) が無いことに気付いたかもしれません。実際、device_path は GRUB EFI インストールスクリプトによって無視されます。UEFI ブートローダーは MBR ブートコードもパーティションブートセクタも全く使用しないのです。\n\n問題が発生した場合は UEFI のトラブルシューティング を見て下さい。加えて GRUB/ヒントとテクニック#UEFI の詳細情報 も参照してください。\n\n"
    },
    {
      "title": "セキュアブートサポート",
      "level": 3,
      "content": "GRUB は、CA 鍵か shim のいずれかを使用するセキュアブートを完全にサポートしています。しかし、インストールのコマンドは、どちらを使用するかによって異なります。\n\n- セキュアブートを不適切に設定すると、システムが起動不能になる可能性があります。セキュアブートを有効化した後に何らかの理由により起動できなくなった場合、ファームウェアでセキュアブートを無効化し、システムを再起動する必要があります。\n- ブートローダで不必要なモジュールをロードすると、セキュリティリスクを発生させる可能性があります。これらのコマンドは、必要なときにだけ使用してください。\n\n"
    },
    {
      "title": "CA 鍵",
      "level": 4,
      "content": "CA 鍵を使うには、インストールのコマンドは次のようになります:\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB --modules=\"tpm\" --disable-shim-lock\n```\n\n"
    },
    {
      "title": "Shim-lock",
      "level": 4,
      "content": "Shim-lock を使用する場合、GRUB をセキュアブートモードでブートさせるには、vmlinuz と initramfs のイメージが含まれているファイルシステムを読むために必要なモジュール全てが GRUB のバイナリに含まれていなければなりません。\n\nGRUB バージョン 2.06.r261.g2f4430cc0 から、セキュアブートモードで insmod を使ってモジュールをロードすることは許可されなくなりました (任意のコードをサイドロードできてしまう可能性があるからです)。GRUB モジュールが EFI バイナリ内に組み込まれていない場合、GRUB はそれらのモジュールをサイドロード/insmod しようと試み、その結果、以下のようなメッセージにより GRUB の起動が失敗します:\n\n```\nerror: prohibited by secure boot policy\n```\n\nUbuntu の公式ビルドスクリプトによると、Ubuntu では以下の GRUB モジュールが署名済み GRUB EFI バイナリ grubx64.efi に組み込まれています:\n\n- \"基本\" モジュール。CD や簡単にパーティショニングされたディスクからブートするために必要: all_video、boot、btrfs、cat、chain、configfile、echo、efifwsetup、efinet、ext2、fat、font、gettext、gfxmenu、gfxterm、gfxterm_background、gzio、halt、help、hfsplus、iso9660、jpeg、keystatus、loadenv、loopback、linux、ls、lsefi、lsefimmap、lsefisystab、lssal、memdisk、minicmd、normal、ntfs、part_apple、part_msdos、part_gpt、password_pbkdf2、png、probe、reboot、regexp、search、search_fs_uuid、search_fs_file、search_label、sleep、smbios、squash4、test、true、video、xfs、zfs、zfscrypt、zfsinfo\n- x84_64-efi アーキテクチャ用の \"プラットフォーム固有\" のモジュール。例えば: play: ブート中に音を鳴らす cpuid: ブート時に CPU の機能を確認する tpm: Measured Boot / Trusted Platform Modules をサポートする\n- \"高度な\" モジュール。以下が含まれます: cryptodisk: plain モードで暗号化されたディスクからブートする gcry_アルゴリズム: 特定のハッシュアルゴリズムと暗号化アルゴリズムをサポートする luks: LUKS で暗号化されたディスクからブートする lvm: LVM 論理ボリュームディスクからブートする mdraid09、mdraid1x、raid5rec、raid6rec: RAID 仮想ディスクからブートする\n\n- play: ブート中に音を鳴らす\n- cpuid: ブート時に CPU の機能を確認する\n- tpm: Measured Boot / Trusted Platform Modules をサポートする\n\n- cryptodisk: plain モードで暗号化されたディスクからブートする\n- gcry_アルゴリズム: 特定のハッシュアルゴリズムと暗号化アルゴリズムをサポートする\n- luks: LUKS で暗号化されたディスクからブートする\n- lvm: LVM 論理ボリュームディスクからブートする\n- mdraid09、mdraid1x、raid5rec、raid6rec: RAID 仮想ディスクからブートする\n\nGRUB モジュールのリストはシェル変数の形にしなければなりません (ここでは GRUB_MODULES と表記しています)。最新の Ubuntu スクリプトをベースとして使い、あなたのシステムでは不要なモジュールを取り除くという方法を取ることもできます。モジュールを減らすと、ブートプロセスが比較的速くなり、ESP のスペースをいくらか節約できます。\n\nまた、セキュリティを高めるために、EFI バイナリにSecure Boot Advanced Targeting (SBAT) ファイル/セクションを含める必要があります (GRUB が UEFI shim ローダから起動される場合)。SBAT ファイル/セクションには、GRUB バイナリに関するメタデータ (バージョン、メンテナ、開発者、上流の URL) が含まれており、特定の GRUB バージョンに脆弱性がある場合、shim がそのバージョンの GRUB のロードをブロックすることが容易になります [1][2] (shim の UEFI shim bootloader secure boot life-cycle improvements というドキュメントで説明されています)。\n\nSBAT セクションが grubx64.efi に無いと、shim は grubx64.efi の起動に失敗します。\n\nGRUB がインストールされている場合、シンプルな SBAT .csv ファイルが /usr/share/grub/sbat.csv で提供されています。\n\nその /usr/share/grub/sbat.csv ファイルと必要な GRUB_MODULES を使って GRUB を再インストールし、GRUB バイナリを署名してください:\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --modules=${GRUB_MODULES} --sbat /usr/share/grub/sbat.csv\n# sbsign --key MOK.key --cert MOK.crt --output esp/EFI/GRUB/grubx64.efi esp/EFI/GRUB/grubx64.efi\n# cp esp/EFI/GRUB/grubx64.efi esp/EFI/BOOT/grubx64.efi\n```\n\n再起動し、MokManager で鍵を選択すれば、セキュアブートが機能するはずです。\n\n"
    },
    {
      "title": "セキュアブートを使用する",
      "level": 4,
      "content": "インストール後は、セキュアブート#セキュアブートを実現する を見て、セキュアブートを有効化する手順を確認してください。\n\nCA 鍵の方法を取っている場合、鍵の管理や登録、ファイルの署名は sbctl で自動化できます。詳細は セキュアブート#sbctl でより簡単に行う を見てください。\n\n"
    },
    {
      "title": "GUID Partition Table (GPT) 特有の手順",
      "level": 3,
      "content": "BIOS/GPT の構成では、BIOS ブートパーティションが必要です。GRUB は core.img をこのパーティションに埋め込みます。\n\n- この方法を試す前に、すべてのシステムでこのパーティショニング方式がサポートされているわけではないということを心に留めておいてください。詳細は パーティショニング#GUID Partition Table を見てください。\n- BIOS ブートパーティションは BIOS/GPT のセットアップでのみ GRUB が必要とします。BIOS/MBR セットアップでは、GRUB は MBR の後にある隙間を core.img のために使用します。しかし、GPT では最初のパーティションの前に未使用の領域があることは保証されていません。\n- UEFI システムでは、ブートセクタが組み込まれないので、BIOS ブートパーティションは必要ありません。しかし、UEFI システムでは依然として EFI システムパーティションが必要です。\n\nディスク上にパーティションタイプ GUID 21686148-6449-6E6F-744E-656564454649 の、ファイルシステムの無い 1 メビバイト (fdisk や gdisk で +1M) のパーティションを作成してください。\n\n- fdisk では、パーティションタイプ BIOS boot を選択してください。\n- gdisk では、パーティションタイプコード ef02 を選択してください。\n- parted では、そのパーティションで bios_grub フラグをセット/アクティブ化してください。\n\nこのパーティションはどのような順番で配置しても良いですが、ディスクの先頭 2 TiB 以内になければなりません。このパーティションは GRUB のインストール前に作成する必要があります。パーティションの準備が完了したら、以下の指示に従ってブートローダーをインストールします。\n\nGPT のアライメント仕様から外れますが、最初のパーティションの前にあるスペースは BIOS ブートパーティションとしても使用できます。このパーティションは定期的にアクセスされるものではないのでパフォーマンスの問題は無視できますが、一部のディスクユーティリティは警告を発します。fdisk や gdisk では、セクター 34 から 2047 までの区間の新しいパーティションを作成して、先のパーティションタイプを設定してください。見える状態のパーティションが先頭から始まるようにするには、このパーティションを最後に追加することを検討してください。\n\n"
    },
    {
      "title": "Master Boot Record (MBR) 特有の手順",
      "level": 3,
      "content": "通常、MBR でパーティションされた環境において MBR の後の隙間 (512 バイトの MBR 領域の後ろで最初のパーティションの前) は 31 KiB になっていて、このパーティションテーブルでは DOS 互換のシリンダーアライメントは問題になりません。しかしながら GRUB の core.img 用に十分な領域を確保するために 1 から 2 MiB ほど MBR の後の領域をとることを推奨します (FS#24103)。この領域を獲得したり他の 512 バイトでないセクターの問題を起こさないために (core.img の埋め込みとは関係ありません) 1 MiB パーティションアライメントをサポートしているパーティションツールを使うのが得策です。\n\n"
    },
    {
      "title": "インストール",
      "level": 3,
      "content": "grub パッケージをインストールしてください (grub-legacyAUR がインストールされている場合は置き換えられます。) 次に以下を実行してください:\n\n```\n# grub-install --target=i386-pc /dev/sdX\n```\n\ni386-pc は実際のアーキテクチャに関わらず使用されます。/dev/sdX は GRUB がインストールされる ディスク (パーティションではありません) です。例えば、/dev/sda、/dev/nvme0n1、/dev/mmcblk0 です。ブロックデバイスの命名方法については デバイスファイル#ブロックデバイスの名前 を参照してください。\n\n次に、メイン設定ファイルを生成する必要があります。\n\n/boot に LVM を使用している場合、GRUB を複数の物理ディスク上にインストールすることができます。\n\ngrub-install コマンドの詳細については、grub-install(8) および GRUB Manual を参照してください。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "インストールされたシステムでは、GRUB は起動の度に設定ファイル /boot/grub/grub.cfg をロードします。ツールを使う場合は、#grub.cfg の生成 を、手動で作成する場合は #grub.cfg のカスタマイズ を参照してください。\n\n"
    },
    {
      "title": "grub.cfg の生成",
      "level": 3,
      "content": "このセクションでは /etc/default/grub 設定ファイルの編集についてだけ扱っています。他のオプションは GRUB/ヒントとテクニック を見て下さい。\n\n"
    },
    {
      "title": "メイン設定ファイルの生成",
      "level": 4,
      "content": "インストールした後は、メインの設定ファイル /boot/grub/grub.cfg を生成する必要があります。生成プロセスは、/etc/default/grub 内の様々なオプションや /etc/grub.d/ 下のスクリプトによって制御されます。/etc/default/grub におけるオプションのリストと、それぞれのオプションの簡潔な説明は、GNU のドキュメントを参照してください。\n\n追加の設定をしていない場合、設定ファイル自動生成スクリプトは、ブートさせるシステムのルートファイルシステムを判定し、その情報を設定ファイルに保存します。これを成功させるには、システムを起動させているか、またはシステムに chroot していることが重要です。\n\n- デフォルトのファイルパスは /boot/grub/grub.cfg です、/boot/grub/i386-pc/grub.cfg ではありません。\n- chroot や systemd-nspawn コンテナで grub-mkconfig を実行しようとした場合、次のようなエラーによりうまく行かないことがあります: grub-probe: error: failed to get canonical path of /dev/sdaX。この場合、このフォーラムの投稿で記述されているように arch-chroot を使ってみて下さい。\n\ngrub-mkconfig ツールを使って /boot/grub/grub.cfg を生成してください:\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\nデフォルトで、生成スクリプトは Arch Linux のカーネルのメニューエントリを自動的に設定に追加します。\n\n- カーネルをインストール/アンインストールした後は、上記の grub-mkconfig コマンドを再度実行する必要があります。\n- 複数の GRUB エントリを管理するためのヒントとして、例えば linux と linux-lts の両方を使用している場合、GRUB/ヒントとテクニック#複数のエントリ を見てください。\n\n他のオペレーティングシステムのエントリを自動的に追加する方法は #他の OS の検出 を見てください。\n\n/etc/grub.d/40_custom を編集して /boot/grub/grub.cfg を再生成することで、追加のカスタムメニューエントリを追加することができます。または、/boot/grub/custom.cfg を作成して、そこにカスタムのメニューエントリを追加することもできます。/boot/grub/custom.cfg を編集した後に grub-mkconfig を再度実行する必要はありません。/etc/grub.d/41_custom は必要な source 文を設定ファイルに追加するからです。\n\nカスタムのメニューエントリの例は #ブートメニューエントリの例 を見てください。\n\n"
    },
    {
      "title": "他の OS の検出",
      "level": 4,
      "content": "grub-mkconfig で、インストールされている他のシステムを検索して自動的にメニューに追加するには、 os-prober パッケージを インストール して、他のシステムが起動するパーティションをマウントしてください。その後、grub-mkconfig を再実行します。もし、Warning: os-prober will not be executed to detect other bootable partitions と出力されたら、/etc/default/grub を編集して次の行を追加/アンコメントしてください:\n\n```\nGRUB_DISABLE_OS_PROBER=false\n```\n\nその後、もう一度試してください。\n\n- 正確なマウントポイントは重要ではありません。os-prober は mtab を読み込んで、起動可能なエントリを検索すべき場所を特定します。\n- 他のオペレーティングシステムをエントリに含めるために、grub-mkconfig を実行するたびに対象のパーティションをマウントすることを忘れないでください。\n- os-prober は、chroot 内で実行すると正しく動作しないかもしれません。そのような場合は、再起動してシステムに入り、再び試してください。\n\nUEFI モードでインストールされた Windows の場合、Windows Boot Manager (bootmgfw.efi) を含んでいる EFI システムパーティションがマウントされていることを確認してください。root として os-prober を実行すると、Windows のエントリを検出・生成します。\n\nBIOS モードでインストールされた Windows の場合、Windows システムパーティション をマウントしてください (そのパーティションのファイルシステムラベルは System Reserved (システムで予約済み) か SYSTEM であるはずです)。root として os-prober を実行すると、Windows のエントリを検出・生成します。\n\n- NTFS パーティションはデフォルトの Linux ドライバでマウントすると、必ずしも検出されないかもしれません。GRUB が検出しない場合、NTFS-3G をインストールして再マウントしてみてください。\n\nTable content:\nこの記事またはセクションは情報が古くなっています。 理由: Windows 7 以降、bootmgr はシステムパーティション内にあり、このパーティションは暗号化されていません。 (Discuss)\n\n- 暗号化された Windows パーティションは、マウントする前に暗号化を解除する必要があるかもしれません。BitLocker では、cryptsetup や dislockerAUR で実行できます。これで os-prober が正しいエントリを追加できるはずです。\n\n"
    },
    {
      "title": "追加引数",
      "level": 4,
      "content": "カスタムの追加引数を Linux イメージに渡すために、/etc/default/grub で GRUB_CMDLINE_LINUX と GRUB_CMDLINE_LINUX_DEFAULT 変数を設定することができます。これら2つは互いに追加され、標準のブートエントリを作成する際にカーネルに渡されます。recovery ブートエントリについては、GRUB_CMDLINE_LINUX だけが生成時に使われます。\n\n両方を使う必要はありませんが、上手く使えば便利です。例えば、GRUB_CMDLINE_LINUX_DEFAULT=\"resume=UUID=uuid-of-swap-partition quiet\" (uuid-of-swap-partition は ハイバネート後に復帰できるようにするためのスワップパーティションの UUID)。この例の設定では、(ハイバネートからの) 復帰をせず、メニューエントリからの起動中にカーネルメッセージを非表示にする quiet も無いリカバリブートエントリを生成します。しかし、他の (標準の) メニューエントリはこれらのオプションを持ちます。\n\nデフォルトでは、grub-mkconfig はルートファイルシステムの UUID を検出して、設定にそれを反映します。これを無効化するには、GRUB_DISABLE_LINUX_UUID=true をアンコメントしてください。\n\nGRUB リカバリエントリを生成するには、/etc/default/grub 内の GRUB_DISABLE_RECOVERY が true に設定されていない必要があります。\n\n詳細は カーネルパラメータ を参照してください。\n\n"
    },
    {
      "title": "トップレベルのメニューエントリを設定する",
      "level": 4,
      "content": "デフォルトでは、grub-mkconfig は、含まれているカーネルを sort -V を使ってソートし、それらの中の最初のカーネルをトップレベルのエントリとして使用します。すなわち、例えば /boot/vmlinuz-linux-lts は /boot/vmlinuz-linux より前に来るので、linux-lts と linux の両方がインストールされている場合、LTS カーネルがトップレベルのメニューエントリとなります。これは、望ましくない場合があるでしょう。この挙動は、/etc/default/grub 内の GRUB_TOP_LEVEL=path_to_kernel\" を指定することでオーバーライドすることができます。例えば、標準のカーネルをトップレベルのメニューエントリにするには、GRUB_TOP_LEVEL=\"/boot/vmlinuz-linux\" を使用します。\n\n"
    },
    {
      "title": "LVM",
      "level": 4,
      "content": "/boot や / に LVM を使用している場合、lvm モジュールをプリロードするようにしてください:\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_PRELOAD_MODULES=\"... lvm\"\n```\n\n"
    },
    {
      "title": "RAID",
      "level": 4,
      "content": "GRUB は RAID ボリュームの便利な管理手段を提供します。ボリュームをネイティブに管理できるようにするために、GRUB モジュール mdraid09 か mdraid1x をロードする必要があります:\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_PRELOAD_MODULES=\"... mdraid09 mdraid1x\"\n```\n\n例えば、/dev/md0 は以下のようになります:\n\n```\nset root=(md/0)\n```\n\nパーティショニングされた RAID ボリューム (例: /dev/md0p1) は以下のようになります:\n\n```\nset root=(md/0,1)\n```\n\n/boot パーティションに RAID1 を使用している場合 (あるいは、/boot が RAID1 ルートパーティション上に存在する場合) に GRUB をインストールするには、BIOS システム上では、両方のドライブ上で grub-install を実行してください。例:\n\n```\n# grub-install --target=i386-pc --debug /dev/sda\n# grub-install --target=i386-pc --debug /dev/sdb\n```\n\nここでは、/boot が存在する RAID1 アレイが、/dev/sda と /dev/sdb に存在するとしています。\n\n{{Note|GRUB は Btrfs RAID 0/1/10 からの起動をサポートしていますが、RAID 5/6 はサポートしていません。RAID 5/6 に対しては mdadm を使用することができます (mdadm は GRUB によってサポートされています)。\n\n"
    },
    {
      "title": "暗号化された /boot",
      "level": 4,
      "content": "GRUB には暗号化された /boot を起動するための特別なサポートがあります。これは、LUKS ブロックデバイスをアンロックして、GRUB の設定を読み込み、initramfs と カーネル をそのブロックデバイスからロードすることにより行われます。このオプションは暗号化されていないブートパーティションの問題を解決することを試みます。\n\nこの機能を有効化するには、/boot が存在するパーティションを通常通り LUKS を使って暗号化してください。そして、以下のオプションを /etc/default/grub に追加してください。\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_ENABLE_CRYPTODISK=y\n```\n\nこのオプションは grub-install により使用され、grub の core.img を生成します。\n\nこのオプションを追加した後やパーティションを暗号化した後に GRUB を(再)インストールすることを忘れないでください。\n\nこれだけだと、パスフレーズを2回入力させられることになります。1回目は起動の初期段階で GRUB が /boot マウントポイントをアンロックするためのもので、2回目は iniramfs により実装されている root ファイルシステムそれ自体をアンロックするためのものです。キーファイルを使えば、これを防げます。\n\n- メインの設定ファイルを生成したいときは、/boot がマウントされていることを確認してください。\n- /boot マウントポイントが関与するシステムアップデートを行うために、アップデートする前に、暗号化された /boot がアンロックされていて、かつ、マウントされていることを確認してください。/boot パーティションが別にある場合、crypttab をキーファイルと一緒に使うことでこれを自動化できます。\n\n- 特殊なキーマップを使用している場合、デフォルトの GRUB 環境にはそのようなキーマップが存在しません。このことは、LUKS ブロックデバイスをアンロックするためにどのようにしてパスフレーズを入力するかに関連しています。GRUB/ヒントとテクニック#初期ブートにおけるコアイメージの手動設定 を参照してください。\n- パスワードの入力画面が表示されない問題が発生した場合 (cryptouuid や cryptodisk、\"device not found\" に関係するエラー)、--modules=\"part_gpt part_msdos\" を grub-install コマンドの最後に付け加えて GRUB を再インストールしてみてください。\n\n#インストール 章で説明されているように、grub-install を使用して LUKS サポートありでブータブルな GRUB イメージを作成してください。ただし、いくつかの注意点があります:\n\n- LUKS2 の初期サポートが GRUB 2.06 で追加されましたが、いくつかの制限があります。これらの制限は、GRUB 2.12rc1 で部分的にのみ対処されています。GRUB bug #55093 を参照してください。\n- GRUB 2.12rc1 から、grub-install で LUKS2 のロックを解除するためのコアイメージを作成できるようになりました。しかし、PBKDF2 のみがサポートされており、Argon2 はサポートされていません。\n- Argon2id (cryptsetup デフォルト) と Argon2i PBKDF はサポートされていません (GRUB bug #59409)。PBKDF2 のみのサポートです。\n\n起動中に無効なパスフレーズを入力して GRUB のレスキューシェルに入った場合、cryptomount -a を実行してすべての (できれば1つだけ) 暗号化されたパーティションをマウントしてみてください。または、cryptomount -u $crypto_uuid を使用して特定のパーティションをマウントしてください。その後、通常通り insmod normal と normal で進めてください。\n\n正しいパスフレーズを入力したが Invalid passphrase というエラーにより即座に戻される場合、正しい暗号化モジュールを指定していることを確認してください。cryptsetup luksDump /dev/nvme0n1p2 を使って、ハッシュ関数 (SHA-256, SHA-512) とインストールされているモジュール (gcry_sha256, gcry_sha512) が一致するか、PBKDF アルゴリズムが pbkdf2 であるかを確認してください。cryptsetup luksConvertKey --hash sha256 --pbkdf pbkdf2 /dev/nvme0n1p2 を使えば、ハッシュと PBDKDF アルゴリズムを今あるキーに対して変更することができます。通常の状況では、パスフレーズが処理されるのに数秒掛かるはずです。\n\n"
    },
    {
      "title": "grub.cfg のカスタマイズ",
      "level": 3,
      "content": "このセクションでは grub-mkconfig に頼らずに /boot/grub/grub.cfg 内にある GRUB のブートエントリーを手動で作成する方法について言及します。\n\n基本的な GRUB の設定ファイルでは以下のオプションが使用されます。\n\n- (hdX,Y) はディスク X 上に存在するパーティション Y を表します。パーティション番号は 1 から始まり、ディスク番号は 0 から始まります。\n- set default=N は、ユーザーが操作せずにタイムアウトした後に選択されるデフォルトのブートエントリを表します。\n- set timeout=M は、ユーザーの選択が無かった場合に M 秒の間待ってデフォルトのブートエントリが起動されることを表します。\n- menuentry \"title\" {entry options} は title というタイトルのブートエントリを表します。\n- set root=(hdX,Y) はカーネルと GRUB モジュールが格納されているブートパーティションを表します。(boot は分離されたパーティションである必要はなく、単に \"root\" パーティション (/) 下にあるディレクトリを指定しても構いません)\n\n"
    },
    {
      "title": "LoaderDevicePartUUID",
      "level": 4,
      "content": "systemd-gpt-auto-generator(8) が GPT パーティションの自動マウントをするために必要な LoaderDevicePartUUID UEFI 変数を GRUB で設定するには、grub.cfg で bli モジュールをロードしてください:\n\n```\nif [ \"$grub_platform\" = \"efi\" ]; then\n  insmod bli\nfi\n```\n\n"
    },
    {
      "title": "ブートメニューエントリの例",
      "level": 4,
      "content": "複数の GRUB エントリーを管理するヒントとして、例えば linux と linux-lts カーネルを同時使用している場合は GRUB/ヒントとテクニック#複数のエントリ を見てください。\n\nArchiso と Archboot のブートメニューエントリについては マルチブート USB ドライブ#ブートエントリ を見てください。\n\n```\nmenuentry \"System shutdown\" {\n\techo \"System shutting down...\"\n\thalt\n}\n```\n\n```\nmenuentry \"System restart\" {\n\techo \"System rebooting...\"\n\treboot\n}\n```\n\n```\nif [ ${grub_platform} == \"efi\" ]; then\n\tmenuentry 'UEFI Firmware Settings' --id 'uefi-firmware' {\n\t\tfwsetup\n\t}\nfi\n```\n\nUEFI モードで起動している場合、GRUB は他の EFI バイナリをチェインロードできます。\n\n```\nif [ ${grub_platform} == \"efi\" ]; then\n\tUEFI のときだけ表示するメニューエントリをここへ\nfi\n```\n\nEFI システムパーティション直下に UEFI シェル を置いてメニューエントリに追加すれば、UEFI シェルを起動できます:\n\n```\nmenuentry \"UEFI Shell\" {\n\tinsmod fat\n\tinsmod chain\n\tsearch --no-floppy --set=root --file /shellx64.efi\n\tchainloader /shellx64.efi\n}\n```\n\ngdisk EFI アプリケーションをダウンロードして gdisk_x64.efi を esp/EFI/tools/ にコピーしてください。\n\n```\nmenuentry \"gdisk\" {\n\tinsmod fat\n\tinsmod chain\n\tsearch --no-floppy --set=root --file /EFI/tools/gdisk_x64.efi\n\tchainloader /EFI/tools/gdisk_x64.efi\n}\n```\n\nセキュアブートに従って生成したか他の方法によって生成した Unified カーネルイメージを持っているならば、それをブートメニューに追加できます。例えば:\n\n```\nmenuentry \"Arch Linux\" {\n\tinsmod fat\n\tinsmod chain\n\tsearch --no-floppy --set=root --fs-uuid FILESYSTEM_UUID\n\tchainloader /EFI/Linux/arch-linux.efi\n}\n```\n\nもう一つのディストリビューションが sda2 パーティションにあると仮定します:\n\n```\nmenuentry \"Other Linux\" {\n\tset root=(hd0,2)\n\tlinux /boot/vmlinuz (必要であれば追加のオプションをここへ)\n\tinitrd /boot/initrd.img (カーネルが必要とする/使用するイメージはここへ)\n}\n```\n\n代わりに UUID やファイルシステムのラベルで GRUB に正しいパーティションを探させるには:\n\n```\nmenuentry \"Other Linux\" {\n        # UUID が 763A-9CB6 だとすると\n\tsearch --no-floppy --set=root --fs-uuid 763A-9CB6\n\n        # OTHER_LINUX というラベルで探す (パーティションラベルが曖昧でないことを確認してください)\n        #search --no-floppy --set=root --label OTHER_LINUX\n\n\tlinux /boot/vmlinuz (必要であれば追加のオプションをここへ。例えば、root=UUID=763A-9CB6)\n\tinitrd /boot/initrd.img (カーネルが必要とする/使用するイメージはここへ)\n}\n```\n\nもう一つのディストリビューションが、インストール済みの GRUB と grub.cfg、カーネル、initramfs のある有効な /boot フォルダーをすでに持っているならば、GRUB にその grub.cfg ファイルを起動中にその場で読み込ませることができます。例えば、hd0 と4番目の GPT パーティションの場合:\n\n```\nmenuentry \"configfile hd0,gpt4\"  {\n        insmod part_gpt\n        insmod btrfs\n        insmod ext2\n        set root='hd0,gpt4'\n        configfile /boot/grub/grub.cfg\n}\n```\n\nこのエントリを選ぶと GRUB は他のボリュームからその grub.cfg を読み込み、メニューを表示させます。configfile ファイル内のコマンドによって環境変数が変更されても、configfile から返ると環境変数の変更はすべて破棄されます。始めの GRUB メニューに戻る場合は Esc を押してください。\n\nこのモードではメニューエントリが選択されると Windows ブートローダーの場所を発見し、GRUB のあとにブートローダーをチェインロードします。ここでするべきことは主に Windows の EFI システムパーティションを見つけて、そのパーティションから Windows のブートローダーを実行することです。\n\n```\nif [ \"${grub_platform}\" == \"efi\" ]; then\n\tmenuentry \"Microsoft Windows Vista/7/8/8.1 UEFI/GPT\" {\n\t\tinsmod part_gpt\n\t\tinsmod fat\n\t\tinsmod chain\n\t\tsearch --no-floppy --fs-uuid --set=root $hints_string $fs_uuid\n\t\tchainloader /EFI/Microsoft/Boot/bootmgfw.efi\n\t}\nfi\n```\n\n$hints_string と $fs_uuid は以下の2つのコマンドで得られます。\n\n$fs_uuid コマンドは EFI システムパーティションの UUID を割り出します。\n\n```\n# grub-probe --target=fs_uuid esp/EFI/Microsoft/Boot/bootmgfw.efi\n```\n\n```\n1ce5-7f28\n```\n\n代わりに、lsblk --fs を実行して、EFI システムパーティションの UUID をそこから読み込むこともできます。\n\n$hints_string コマンドは EFI システムパーティションの場所を割り出します。以下の例ではハードドライブ0にあります:\n\n```\n# grub-probe --target=hints_string esp/EFI/Microsoft/Boot/bootmgfw.efi\n```\n\n```\n--hint-bios=hd0,gpt1 --hint-efi=hd0,gpt1 --hint-baremetal=ahci0,gpt1\n```\n\n以上の2つのコマンドでは Windows が使用する ESP が esp にマウントされていると仮定しています。Windows である以上、Windows の EFI ファイルへのパスが異なる場合があるかもしれません。\n\nこのセクションを通して Windows のパーティションは /dev/sda1 にあると仮定します。パーティションが異なる場合は hd0,msdos1 という記述をすべて変更してください。\n\n両方の例で XXXX-XXXX はファイルシステムの UUID を表しています。UUID は lsblk --fs コマンドを使って得られます。実際の UUID に置き換えてください。\n\nWindows Vista/7/8/8.1/10 では:\n\n```\nif [ \"${grub_platform}\" == \"pc\" ]; then\n\tmenuentry \"Microsoft Windows Vista/7/8/8.1/10 BIOS/MBR\" {\n\t\tinsmod part_msdos\n\t\tinsmod ntfs\n\t\tinsmod ntldr\n\t\tsearch --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 XXXX-XXXX\n\t\tntldr /bootmgr\n\t}\nfi\n```\n\nWindows XP では:\n\n```\nif [ \"${grub_platform}\" == \"pc\" ]; then\n\tmenuentry \"Microsoft Windows XP\" {\n\t\tinsmod part_msdos\n\t\tinsmod ntfs\n\t\tinsmod ntldr\n\t\tsearch --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 XXXX-XXXX\n\t\tntldr /ntldr\n\t}\nfi\n```\n\n```\nX:\\> bootrec.exe /fixboot\nX:\\> bootrec.exe /RebuildBcd\n```\n\nbootrec.exe /Fixmbr を実行しないでください。GRUB が吹き飛びます。 あるいは、トラブルシューティングメニューにあるスタートアップ修復機能を使用できます。これは GRUB を吹き飛ばしませんし、ほとんどのエラーを修復します。 また、対象のハードドライブとブート可能ドライブの両方だけを接続しておくほうが良いでしょう。通常、他のデバイスが接続されていると Windows はブート情報の修復に失敗します。\n\nsearch コマンドに対して --label オプションを使えば、ファイルシステムに付けられた人間が読みやすい文字列であるラベルを使うことができます。まずはじめに、ファイルシステムにラベルがあることを確認してください。\n\nそして、ラベルを使ってエントリを追加してください。例えば:\n\n```\nmenuentry \"Arch Linux, session texte\" {\n  search --label --set=root archroot\n  linux /boot/vmlinuz-linux root=/dev/disk/by-label/archroot ro\n  initrd /boot/initramfs-linux.img\n}\n```\n\n"
    },
    {
      "title": "コマンドシェルを使う",
      "level": 2,
      "content": "GRUB のモジュールを全て保存するには MBR は小さすぎるので、メニューと基本的なコマンドだけが MBR に入っています。GRUB の機能のほとんどは /boot/grub 内のモジュールとして存在し、必要に応じて挿入されます。エラー状態になると (例: パーティションレイアウトが変更された場合)、GRUB が起動に失敗する場合があります。このとき、コマンドシェルが表示されます。\n\nGRUB は複数のシェル/プロンプトを提供しています。メニューの読込に問題があってもブートローダがディスクを見つけられるときは、おそらく \"normal\" シェルに落とされるでしょう:\n\n```\ngrub>\n```\n\nさらに深刻な問題 (例: GRUB が必要なファイルを見つけられないなど) があるときは、代わりに \"rescue\" シェルに落とされるでしょう:\n\n```\ngrub rescue>\n```\n\nrescue シェルは通常のシェルの制限されたサブセットで、使える機能が非常に少なくなっています。rescue シェルが出てきた時は、まず \"normal\" モジュールの挿入を試して、\"normal\" シェルを起動してみて下さい:\n\n```\ngrub rescue> set prefix=(hdX,Y)/boot/grub\ngrub rescue> insmod (hdX,Y)/boot/grub/i386-pc/normal.mod\nrescue:grub> normal\n```\n\n"
    },
    {
      "title": "ページャのサポート",
      "level": 3,
      "content": "GRUB はページャをサポートしており長い出力をするコマンド (help コマンドなど) を読むことができます。これは通常のシェルモードでしか動作せずレスキューモードでは使えません。ページャを有効にするには、GRUB コマンドシェルで次を入力して下さい:\n\n```\nsh:grub> set pager=1\n```\n\n"
    },
    {
      "title": "コマンドシェル環境を使ってオペレーティングシステムを起動する",
      "level": 3,
      "content": "```\ngrub>\n```\n\nGRUB のコマンドシェル環境を使ってオペレーティングシステムを起動することが可能です。 通常はチェインロードを使ってドライブやパーティションから Windows / Linux を起動するということが考えられます。\n\nチェインロードは現在のブートローダから別のブートローダをロードすることを意味します。\n\n他のブートローダーは、パーティショニングされたディスク (MBR) の先頭や、パーティションレスディスク (VBR) のパーティションの先頭に組み込んだり、あるいは UEFI の場合は EFI バイナリとして組み込むことができます。\n\n"
    },
    {
      "title": "パーティションの VBR をチェインロード",
      "level": 4,
      "content": "```\nset root=(hdX,Y)\nchainloader +1\nboot\n```\n\nX=0,1,2... Y=1,2,3...\n\n例えば最初のハードディスクの最初のパーティションに保存された Windows をチェインロードするには:\n\n```\nset root=(hd0,1)\nchainloader +1\nboot\n```\n\n同じようにパーティションにインストールされた GRUB をチェインロードすることもできます。\n\n"
    },
    {
      "title": "ディスクの MBR やパーティションレスディスクの VBR をチェインロード",
      "level": 4,
      "content": "```\nset root=hdX\nchainloader +1\nboot\n```\n\n"
    },
    {
      "title": "UEFI モードでインストールされた Windows/Linux のチェインロード",
      "level": 4,
      "content": "```\ninsmod fat\nset root=(hd0,gpt4)\nchainloader (${root})/EFI/Microsoft/Boot/bootmgfw.efi\nboot\n```\n\ninsmod fat は、EFI システムパーティション上の Windows ブートローダーにアクセするために、FAT ファイルシステムモジュールをロードするために使用されます。 (hd0,gpt4) (すなわち /dev/sda4) は、この例における EFI システムパーティションです。 chainloader 行のエントリは、チェインロードすべき .efi ファイルへのパスを指定しています。\n\n"
    },
    {
      "title": "通常のロード",
      "level": 4,
      "content": "#rescue コンソールを使う の例を見て下さい。\n\n"
    },
    {
      "title": "rescue コンソールを使う",
      "level": 3,
      "content": "まず #コマンドシェルを使う を見て下さい。標準シェルを有効にできない場合、ライブ CD や他のレスキューディスクを使って起動し、設定のエラーを直して GRUB を再インストールという方法があります。ただし、そのようなブートディスクはいつも使えるというわけではありません (もしくは必要ありません); レスキューコンソールは驚くほど堅牢です。\n\nGRUB rescue で利用できるコマンドには insmod、ls、set、unset があります。この例では set と insmod を使います。set は変数を変更し insmod は新しいモジュールを挿入して機能を追加します。\n\n始める前に、ユーザーは自分の /boot パーティションの位置を知っていなければなりません (分割パーティションなのか、root 下のサブディレクトリなのか):\n\n```\ngrub rescue> set prefix=(hdX,Y)/boot/grub\n```\n\nX は物理ドライブ番号、Y はパーティション番号に置き換えてください。\n\nコンソールの機能を拡張するために、linux モジュールを挿入します:\n\n```\ngrub rescue> insmod i386-pc/linux.mod\n```\n\nもしくは、単純に:\n\n```\ngrub rescue> insmod linux\n```\n\nこれで、より親しみのあるであろう linux と initrd のコマンドが使えます。\n\n例えば、Arch Linux を起動する場合:\n\n```\nset root=(hd0,5)\nlinux /boot/vmlinuz-linux root=/dev/sda5\ninitrd /boot/initramfs-linux.img\nboot\n```\n\nboot パーティションを分割している (例えば、UEFI を使用している場合など) なら、行を適宜変更する必要があります:\n\n```\nset root=(hd0,5)\nlinux (hdX,Y)/vmlinuz-linux root=/dev/sda6\ninitrd (hdX,Y)/initramfs-linux.img\nboot\n```\n\nArch Linux 環境のブートに成功したら、必要に応じて grub.cfg を修正し GRUB を再インストールすることができます。\n\nGRUB を再インストールして問題を完全に修正するには、必要応じて /dev/sda を変更してください。詳しくは #インストール を見て下さい。\n\n"
    },
    {
      "title": "UEFI システム",
      "level": 3,
      "content": "grub を削除する前に、他のブートローダがインストールされていて、GRUB の後を引き継ぐように設定されていることを確認してください。\n\n```\n$ efibootmgr\n```\n\n```\nBootOrder: 0003,0001,0000,0002\nBoot0000* Windows Boot Manager  HD(2,GPT,4dabbedf-191b-4432-bc09-8bcbd1d7dabf,0x109000,0x32000)/File(\\EFI\\Microsoft\\Boot\\bootmgfw.efi)\nBoot0001* GRUB  HD(2,GPT,4dabbedf-191b-4432-bc09-8bcbd1d7dabf,0x109000,0x32000)/File(\\EFI\\GRUB\\grubx64.efi)\nBoot0002* Linux-Firmware-Updater        HD(2,GPT,5dabbedf-191b-4432-bc09-8bcbd1d7dabf,0x109000,0x32000)/File(\\EFI\\arch\\fwupdx64.efi)\nBoot0003* Linux Boot Manager    HD(2,GPT,4dabbedf-191b-4432-bc09-8bcbd1d7dabf,0x109000,0x32000)/File(\\EFI\\systemd\\systemd-bootx64.efi)\n```\n\nBootOrder で grub が最初のエントリになっている場合、systemd-boot などの他のブートローダをインストールして最初のエントリにしてください。その後、bootnum を使って grub を削除することができます。\n\n```\n# efibootmgr --delete-bootnum -b 1\n```\n\nまた、esp/EFI/grub と /boot/grub ディレクトリも削除してください。\n\n"
    },
    {
      "title": "BIOS システム",
      "level": 3,
      "content": "grub を他の BIOS ブートローダに置き換えるには、単に新しいブートローダをインストールしてください (そうすることで、MBR ブートコードが上書きされます)。\n\ngrub-install は /boot/grub ディレクトリを作成するので、これは手動で削除する必要があります。しかし、grub をまたインストールするかもしれない場合は、このディレクトリを残しておいたほうが良いかもしれません。\n\nUEFI/GPT に移行した後は、dd を使って MBR ブートコードを削除することができます。\n\n"
    },
    {
      "title": "サポートのないファイルシステム",
      "level": 3,
      "content": "GRUB が root のファイルシステムをサポートしていない場合、代替の /boot パーティションをサポートのあるファイルシステムで作成する必要があります。​開発バージョンの GRUB である grub-gitAUR が該当するファイルシステムをネイティブサポートしている場合があります。\n\nサポートされないファイルシステムで GRUB を使用した場合、ドライブの UUID を抽出できないため、GRUB は古典的で非永続的な /dev/sdXx 名を使います。この場合、/boot/grub/grub.cfg を手動で編集し、root=/dev/sdXx を root=UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX のように置き換える必要があるかもしれません。blkid コマンドを使えばデバイスの UUID を得られます。永続的なブロックデバイスの命名 を見てください。\n\nGRUB はバージョン 2.0.4 より F2FS をサポートしていますが、extra_attr フラグを有効にして作成された F2FS パーティションからブートファイルを正しく読み込むことができません。\n\n"
    },
    {
      "title": "デバッグメッセージを有効にする",
      "level": 3,
      "content": "以下を grub.cfg に追加してください:\n\n```\nset pager=1\nset debug=all\n```\n\n"
    },
    {
      "title": "msdos-style エラーメッセージ",
      "level": 3,
      "content": "```\ngrub-setup: warn: This msdos-style partition label has no post-MBR gap; embedding will not be possible!\ngrub-setup: warn: Embedding is not possible. GRUB can only be installed in this setup by using blocklists.\n            However, blocklists are UNRELIABLE and its use is discouraged.\ngrub-setup: error: If you really want blocklists, use --force.\n```\n\nこのエラーは VMware コンテナに GRUB をインストールしようとすると起こることがあります。詳しくは ここ を読んで下さい。最初のパーティションが MBR (ブロック 63) のすぐ後ろから始まっていて、最初のパーティションの前に通常の 1 MiB のスペース (2048 ブロック) がない場合に起こります。#Master Boot Record (MBR) 特有の手順 を読んで下さい。\n\n"
    },
    {
      "title": "よくあるインストール時のエラー",
      "level": 4,
      "content": "- 一部の UEFI デバイスで起こりうるエラーは、Could not prepare Boot variable: Read-only file system です。/sys/firmware/efi/efivars を読み書き可能な状態で再マウントする必要があります。# mount -o remount,rw,nosuid,nodev,noexec --types efivarfs efivarfs /sys/firmware/efi/efivars ブートローダーのインストールに関しては Gentoo Wiki を見てください。\n- sysfs か procfs がある状態で grub-install を実行すると問題が発生し、modprobe efivarfs を実行しなければならないと言われる場合、efivarfs をマウントして上記のコマンドを実行してみてください。\n- --target と --directory オプションのどちらかがないと、grub-install はどこにファームウェアをインストールすればいいのか決められません。そのような場合 grub-install は source_dir does not exist. Please specify --target or --directory というメッセージを表示します。\n- grub-install の実行後に error: esp doesn't look like an EFI partition と表示される場合、おそらくパーティションが FAT32 でフォーマットされていません。\n\n```\n# mount -o remount,rw,nosuid,nodev,noexec --types efivarfs efivarfs /sys/firmware/efi/efivars\n```\n\n"
    },
    {
      "title": "ファームウェアブートマネージャーに GRUB エントリを作成する",
      "level": 4,
      "content": "grub-install は自動的にブートマネージャーにメニューエントリを追加しようと試みます。もし GRUB がそれを行わない場合、UEFI#efibootmgr を見て、efibootmgr を使ってメニューエントリを作成する指示を読んでください。しかし、UEFI#ISO から UEFI ブータブル USB を作成する にあるように、よくある原因は CD/USB を UEFI モードで起動していないというものです。\n\nGRUB エントリをファームウェアブートマネージャに作成する例として、efibootmgr -c を考えてみましょう。これは、/dev/sda1 が EFI システムパーティションであり、/boot/efi にマウントされていると仮定します。これは efibootmgr のデフォルトの挙動です。このツールは、(\"Linux\" という名前の) 新しいブートオプションを作成し、それをブート順序リストの1番目に配置します。オプションを渡すことでデフォルトの挙動を変更できます。デフォルトの OS ローダーは \\EFI\\arch\\grub.efi です。\n\n"
    },
    {
      "title": "レスキューシェルが起動する",
      "level": 4,
      "content": "GRUB はロードされたが、エラーが表示されずにレスキューシェルに落とされる場合、以下の2つの理由のうち1つが原因である可能性があります:\n\n- grub.cfg が存在しないか、場所を間違えている。--boot-directory を使って GRUB UEFI をインストールして、grub.cfg が存在しない場合に起こります。\n- ブートパーティションが変更された (grubx64.efi ファイルにハードコードされています)。\n\n"
    },
    {
      "title": "GRUB UEFI がロードされない",
      "level": 4,
      "content": "有効な UEFI の例:\n\n```\n# efibootmgr -u\n```\n\n```\nBootCurrent: 0000\nTimeout: 3 seconds\nBootOrder: 0000,0001,0002\nBoot0000* GRUB HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\\EFI\\GRUB\\grubx64.efi)\nBoot0001* Shell HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\\shellx64.efi)\nBoot0002* Festplatte BIOS(2,0,00)P0: SAMSUNG HD204UI\n```\n\n画面が数秒間真っ暗になって、その後、次のブートオプションが試行される場合、この投稿によると、GRUB をルートパーティションに移動することで直るかもしれません。ブートオプションは削除して後でまた作成する必要があります。GRUB のエントリは次のようにしてください:\n\n```\nBoot0000* GRUB HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\\grubx64.efi)\n```\n\n"
    },
    {
      "title": "デフォルト/フォールバックのブートパス",
      "level": 4,
      "content": "一部の UEFI ファーウェアではブート可能なファイルが既知の場所に存在している必要があり、それ以外の場所では UEFI NVRAM ブートエントリに表示されません。この場合、grub-install が、GRUB を起動するエントリが efibootmgr によって追加されたと報告するでしょうが、VisualBIOS のブート順序セレクターには表示されません。解決策は GRUB をデフォルト/フォールバックのブートパスにインストールすることです:\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --removable\n```\n\nあるいは、すでにインストールされた GRUB の EFI 実行ファイルをデフォルト/フォールバックのパスに移動することができます:\n\n```\n# mv esp/EFI/grub esp/EFI/BOOT\n# mv esp/EFI/BOOT/grubx64.efi esp/EFI/BOOT/BOOTX64.EFI\n```\n\n"
    },
    {
      "title": "Invalid signature",
      "level": 3,
      "content": "(例えば、パーティションを再設定したり、追加のハードドライブを追加したりしたあとで) Windows を起動しようとして \"invalid signature\" エラーが発生する場合、GRUB のデバイス設定を移動 (削除) し、GRUB に再設定させてください:\n\n```\n# mv /boot/grub/device.map /boot/grub/device.map-old\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\nこれで grub-mkconfig は Windows を含む全てのブートオプションを記述したはずです。これで動作したら、/boot/grub/device.map-old は削除してください。\n\n"
    },
    {
      "title": "起動中にフリーズする",
      "level": 3,
      "content": "GRUB がカーネルと初期 RAM ディスクをロードした後に、エラーメッセージが表示されずにフリーズする場合、add_efi_memmap カーネルパラメータを削除してみてください。\n\n"
    },
    {
      "title": "他の OS から Arch が見つからない",
      "level": 3,
      "content": "他のディストリビューションで os-prober を使って Arch Linux を自動的に検索できないという報告が複数確認されています。この問題が発生する場合、/etc/lsb-release をおくことで検知が改善されると報告されています。このファイルと更新ツールは公式リポジトリにある lsb-release パッケージから利用可能です。\n\n"
    },
    {
      "title": "chroot でインストールした時に警告が表示される",
      "level": 3,
      "content": "(システムのインストール中などに) chroot 環境で LVM システム上に GRUB をインストールする際に、以下のような警告が発生する場合があります:\n\n```\n/run/lvm/lvmetad.socket: connect failed: No such file or directory\n```\n\nまたは\n\n```\nWARNING: failed to connect to lvmetad: No such file or directory. Falling back to internal scanning.\n```\n\nこれは、/run が chroot 内で利用可能でないから起こります。すべてが正しく行われていれば、これらの警告のせいでシステムが起動できなくなることはありません。インストールを継続することができます。\n\n"
    },
    {
      "title": "GRUB のロードが遅い",
      "level": 3,
      "content": "ディスク容量が残りわずかの場合 GRUB がロードされるのにかなり時間がかかることがあります。起動が遅い場合 /boot や / に十分な空き容量があるか確認してください。\n\n"
    },
    {
      "title": "error: unknown filesystem",
      "level": 3,
      "content": "GRUB が error: unknown filesystem と出力して起動しない理由はいくつか考えられます。UUID が正しいこと、全てのファイルシステムが問題なく、GRUB によってサポートされていることが確認できる場合、BIOS Boot Partition がドライブの最初の 2TB の中にない可能性があります [4]。適当なパーティショニングツールを使ってパーティションが最初の 2TB 以内にあるようにして、GRUB を再インストール・再設定してください。\n\nまた、このエラーは ext4 ファイルシステムがいくつかの機能をサポートしていないことが原因かもしれません:\n\n- large_dir - サポートされません。\n- metadata_csum_seed - GRUB 2.11 でサポートされます (コミット).\n\n"
    },
    {
      "title": "grub-reboot で再設定されない",
      "level": 3,
      "content": "GRUB は Btrfs のルートパーティションに書き込むを行うことができません [5]。grub-reboot を使って他のエントリを起動した場合、ディスク上の環境を更新することができなくなります。(ディストリビューションを切り替えるなどの場合に) 他のエントリから grub-reboot を実行するか他のファイルシステムを使ってください。grub-editenv create を実行して /etc/default/grub に GRUB_DEFAULT=0 を設定することでエントリをリセットできます (設定後は grub-mkconfig -o /boot/grub/grub.cfg を行ってください)。\n\n"
    },
    {
      "title": "古い Btrfs のせいでインストールができない",
      "level": 3,
      "content": "パーティションテーブルを作成しないで Btrfs を使ってドライブをフォーマットしている場合 (例: /dev/sdx)、後からパーティションテーブルを書き込むと、Btrfs のフォーマットが一部残留します。ほとんどのユーティリティや OS は残留した Btrfs を認識できないため、GRUB は (たとえ --force が付けられていても) インストールを拒否します:\n\n```\n# grub-install: warning: Attempting to install GRUB to a disk with multiple partition labels. This is not supported yet..\n# grub-install: error: filesystem `btrfs' does not support blocklists.\n```\n\nドライブを完全に消去してもいいですが、wipefs -o 0x10040 /dev/sdx を使えばデータを残して Btrfs のスーパーブロックだけを消去することができます。\n\n"
    },
    {
      "title": "Windows 8/10 が認識されない",
      "level": 3,
      "content": "Windows 8/10 の \"高速スタートアップ\"、\"ハイブリッドブート\"、\"Hiberboot\" と呼ばれる設定を有効にしていると Windows のパーティションをマウントすることができなくなる可能性があります。そのため grub-mkconfig が Windows を認識することができなくなります。Windows で高速スタートアップを無効化することで GRUB のメニューに追加することができるようになるはずです。\n\n"
    },
    {
      "title": "grub-rescue プロンプトと暗号化済み /boot",
      "level": 3,
      "content": "暗号化済みの /boot を使用している場合に間違ったパスワードを入力してしまうと grub-rescue プロンプトに入ります。\n\nこの grub-rescue プロンプトではできることが限られています。以下のコマンドを使ってブートを完了させます:\n\n```\ngrub rescue> cryptomount <partition>\ngrub rescue> insmod normal\ngrub rescue> normal\n```\n\nより良い説明はこのブログ投稿[リンク切れ 2023-04-23]をご覧ください。\n\n"
    },
    {
      "title": "GRUB をインストールしたが起動時にメニューが表示されない",
      "level": 3,
      "content": "/etc/default/grub を見て GRUB_TIMEOUT が 0 に設定されていないかチェックしてください。0 に設定されていた場合、正の数に設定し直してください。この値はデフォルトの GRUB エントリが起動されるまでの秒数を表しています。GRUB_TIMEOUT_STYLE が hidden に設定されていないかもチェックしてください。hidden に設定されていた場合、menu に設定し直してください。これでメニューがデフォルトで表示されるようになります。以上が終わったら、メインの設定ファイルを再生成して、再起動してメニューが表示されるか確かめてください。\n\nこれでうまく行かない場合、グラフィカルターミナルとの互換性の問題があるのかもしれません。/etc/default/grub で GRUB_TERMINAL_OUTPUT を console に設定し、GRUB のグラフィカルターミナルを無効化してください。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Wikipedia:ja:GNU GRUB\n- 公式 GRUB マニュアル\n- Ubuntu wiki の GRUB ページ\n- UEFI システム用にコンパイルする手順を説明している GRUB wiki ページ\n- Wikipedia:BIOS Boot partition\n- How to configure GRUB\n\n"
    }
  ]
}