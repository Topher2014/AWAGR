{
  "title": "Nginx (日本語)",
  "url": "https://wiki.archlinux.org/title/Nginx_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "nginx (\"エンジンエックス\"と発音します)は 2005 年から Igor Sysoev（ロシア）によって開発されている、フリーでオープンソースかつハイパフォーマンスな HTTP サーバーかつリバースプロクシで、IMAP/POP3 プロクシサーバーとしても機能します。Nginx は主に、その安定性・多機能・単純な設定・低リソース消費によって知られています。\n\nこの記事では nginx の設定方法と、#FastCGI を使って PHP と統合する方法を説明します。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 サービスの開始\n- 3 設定 3.1 設定例 3.2 一般設定 3.2.1 プロセス数とコネクション数 3.2.2 別のユーザーで実行する 3.2.3 サーバーブロック 3.2.3.1 サーバーエントリの管理 3.2.4 TLS 3.2.5 ユーザーごとのディレクトリ 3.3 FastCGI 3.3.1 PHP を動かす 3.3.1.1 手順1: PHP の設定 3.3.1.1.1 MariaDB 3.3.1.2 手順2: php-fpm 3.3.1.3 手順3: Nginx の設定 3.3.2 CGI を動かす 3.3.2.1 手順1: fcgiwrap 3.3.2.1.1 マルチワーカースレッド 3.3.2.2 nginx の設定\n- 4 chroot でインストール 4.1 必要なデバイスを作成 4.2 必要なフォルダを作成 4.3 chroot に移住 4.4 nginx.service を変更して chroot を起動\n- 5 ヒントとテクニック 5.1 systemd を使用したユーザーサービスの実行 5.2 systemd を使って非特権で動作させる 5.2.1 ポート 5.2.2 PID ファイル 5.2.3 /var/lib/nginx 5.2.4 /var/log/nginx 5.3 systemd の別のスクリプト 5.4 Nginx Beautifier 5.5 より良いヘッダー管理 5.6 基本認証 5.7 php-legacy の使用\n- 6 トラブルシューティング 6.1 設定の確認 6.2 Error: The page you are looking for is temporarily unavailable. Please try again later. (502 Bad Gateway) 6.3 Error: No input file specified 6.4 Warning: Could not build optimal types_hash 6.5 要求されたアドレスを割り当てることができない\n- 7 参照\n\n- 3.1 設定例\n- 3.2 一般設定 3.2.1 プロセス数とコネクション数 3.2.2 別のユーザーで実行する 3.2.3 サーバーブロック 3.2.3.1 サーバーエントリの管理 3.2.4 TLS 3.2.5 ユーザーごとのディレクトリ\n- 3.3 FastCGI 3.3.1 PHP を動かす 3.3.1.1 手順1: PHP の設定 3.3.1.1.1 MariaDB 3.3.1.2 手順2: php-fpm 3.3.1.3 手順3: Nginx の設定 3.3.2 CGI を動かす 3.3.2.1 手順1: fcgiwrap 3.3.2.1.1 マルチワーカースレッド 3.3.2.2 nginx の設定\n\n- 3.2.1 プロセス数とコネクション数\n- 3.2.2 別のユーザーで実行する\n- 3.2.3 サーバーブロック 3.2.3.1 サーバーエントリの管理\n- 3.2.4 TLS\n- 3.2.5 ユーザーごとのディレクトリ\n\n- 3.2.3.1 サーバーエントリの管理\n\n- 3.3.1 PHP を動かす 3.3.1.1 手順1: PHP の設定 3.3.1.1.1 MariaDB 3.3.1.2 手順2: php-fpm 3.3.1.3 手順3: Nginx の設定\n- 3.3.2 CGI を動かす 3.3.2.1 手順1: fcgiwrap 3.3.2.1.1 マルチワーカースレッド 3.3.2.2 nginx の設定\n\n- 3.3.1.1 手順1: PHP の設定 3.3.1.1.1 MariaDB\n- 3.3.1.2 手順2: php-fpm\n- 3.3.1.3 手順3: Nginx の設定\n\n- 3.3.1.1.1 MariaDB\n\n- 3.3.2.1 手順1: fcgiwrap 3.3.2.1.1 マルチワーカースレッド\n- 3.3.2.2 nginx の設定\n\n- 3.3.2.1.1 マルチワーカースレッド\n\n- 4.1 必要なデバイスを作成\n- 4.2 必要なフォルダを作成\n- 4.3 chroot に移住\n- 4.4 nginx.service を変更して chroot を起動\n\n- 5.1 systemd を使用したユーザーサービスの実行\n- 5.2 systemd を使って非特権で動作させる 5.2.1 ポート 5.2.2 PID ファイル 5.2.3 /var/lib/nginx 5.2.4 /var/log/nginx\n- 5.3 systemd の別のスクリプト\n- 5.4 Nginx Beautifier\n- 5.5 より良いヘッダー管理\n- 5.6 基本認証\n- 5.7 php-legacy の使用\n\n- 5.2.1 ポート\n- 5.2.2 PID ファイル\n- 5.2.3 /var/lib/nginx\n- 5.2.4 /var/log/nginx\n\n- 6.1 設定の確認\n- 6.2 Error: The page you are looking for is temporarily unavailable. Please try again later. (502 Bad Gateway)\n- 6.3 Error: No input file specified\n- 6.4 Warning: Could not build optimal types_hash\n- 6.5 要求されたアドレスを割り当てることができない\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "公式リポジトリ から nginx-mainline (メインラインブランチ: 最新の機能・アップデート・修正) か nginx (安定ブランチ: 重要な修正のみを適応) のどちらかを インストール できます。\n\nメインラインブランチを使用することをお勧めします。安定版ブランチを使う主な理由は、サードパーティ製モジュールとの非互換性や、新機能 の不注意によるバグ導入など、新機能の起こりうる影響を懸念するためです。\n\nセキュリティを向上させるために chroot によるインストールをするには、chroot でインストール を参照してください。\n\n"
    },
    {
      "title": "サービスの開始",
      "level": 2,
      "content": "nginx.service を起動/有効化します。\n\nhttp://127.0.0.1 で提供されるデフォルトのページは、/usr/share/nginx/html/index.html です。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "nginx における最初の手順は 公式のビギナーズガイド で説明されています。/etc/nginx/ にあるファイルを編集することで Nginx の設定ができます。メインの設定ファイルは /etc/nginx/nginx.conf です。\n\nより詳しい解説は、公式の ドキュメント にある Nginx Configuration Examples にあります。\n\n以下の例は、最も一般的な使用例をカバーしています。ここでは、ドキュメントのデフォルトの場所 (/usr/share/nginx/html) を使用することを想定しています。そうでない場合は、代わりにあなたのパスを指定してください。\n\n"
    },
    {
      "title": "設定例",
      "level": 3,
      "content": "```\n/etc/nginx/nginx.conf\n```\n\n```\nuser http;\nworker_processes auto;\nworker_cpu_affinity auto;\n\nevents {\n    multi_accept on;\n    worker_connections 1024;\n}\n\nhttp {\n    charset utf-8;\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    server_tokens off;\n    log_not_found off;\n    types_hash_max_size 4096;\n    client_max_body_size 16M;\n\n    # MIME\n    include mime.types;\n    default_type application/octet-stream;\n\n    # logging\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log warn;\n\n    # load configs\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n}\n```\n\n"
    },
    {
      "title": "プロセス数とコネクション数",
      "level": 4,
      "content": "worker_processes の適当な値を探って下さい。この設定は最終的に nginx が受け入れる接続の数と利用できるプロセスの数を定義します。通常、システムのハードウェアのスレッド数にすると良いでしょう。また、バージョン 1.3.8 と 1.2.5 から worker_processes には auto と設定することができ、最適な値を自動的に検出します (ソース)。\n\nnginx が受け入れる最大接続数は max_clients = worker_processes * worker_connections で計算できます。\n\n"
    },
    {
      "title": "別のユーザーで実行する",
      "level": 4,
      "content": "デフォルトでは、nginx はマスタープロセスを root で、ワーカープロセスを http ユーザで実行します。ワーカープロセスを別のユーザで実行するには、nginx.conf の user ディレクティブを変更します。\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nuser user [group];\n```\n\ngroup が省略された場合は、user と同じ名前のグループが使用されます。\n\n"
    },
    {
      "title": "サーバーブロック",
      "level": 4,
      "content": "server ブロックを使うことで複数のドメインを利用することができます。\"バーチャルホスト\"とも呼ばれますが、これは Apache の用語です。server ブロックの利用方法は Apache とは異なっています。upstream examples も参照してください。\n\n以下の例では2つのドメインの接続をサーバーが待機します: domainname1.dom と domainname2.dom:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\n...\nserver {\n        listen 80;\n        server_name domainname1.dom;\n        root /usr/share/nginx/domainname1.dom/html;\n        location / {\n           index index.php index.html index.htm;\n        }\n}\n\nserver {\n        listen 80;\n        server_name domainname2.dom;\n        root /usr/share/nginx/domainname2.dom/html;\n        ...\n}\n...\n}\n```\n\nnginx.service を再起動して変更を適用します。\n\nクライアントからの接続時にこれらのドメイン名を解決するには、BIND や dnsmasq などのDNSサーバーを設定する必要があります。\n\nローカルマシンでバーチャルホストをテストするには、/etc/hosts ファイルにバーチャルネームを追加してください:\n\n```\n127.0.0.1 domainname1.dom \n127.0.0.1 domainname2.dom\n```\n\n異なる server ブロックを異なるファイルに配置することができます。これにより、特定のサイトを簡単に有効または無効にできます。\n\n次のディレクトリを作成します。\n\n```\n# mkdir /etc/nginx/sites-available\n# mkdir /etc/nginx/sites-enabled\n```\n\nsites-available ディレクトリに、一つ以上のサーバーブロックを含むファイルを作成します。\n\n```\n/etc/nginx/sites-available/example.conf\n```\n\n```\nserver {\n    listen 443 ssl http2;\n    listen [::]:443 ssl http2;\n\n    ...\n}\n```\n\nhttp ブロックの最後に、include sites-enabled/*; を追加します。\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nhttp {\n    ...\n    include sites-enabled/*;\n}\n```\n\nサイトを有効にするには、シンボリックリンクを作成するだけです。\n\n```\n# ln -s /etc/nginx/sites-available/example.conf /etc/nginx/sites-enabled/example.conf\n```\n\nサイトを無効にするには、アクティブなシンボリックリンクのリンクを解除します。\n\n```\n# unlink /etc/nginx/sites-enabled/example.conf\n```\n\nnginx.service を リロード/再起動 して、サイト設定の変更を有効にします。\n\n"
    },
    {
      "title": "TLS",
      "level": 4,
      "content": "OpenSSL は TLS をサポートし、Arch のインストール時にデフォルトでインストールされます。\n\n- SSL を設定する前に ngx_http_ssl_module のドキュメントを読むことを推奨します。\n- Let’s Encrypt は無料の、自動化されたオープンな証明局です。コマンドラインおよび自動設定から直接有効な SSL 証明書を要求するプラグインを利用可能です。\n- Mozilla には、便利な TLS 記事 と 自動化ツール があります。より安全な設定を作成するのに役立ちます。\n\n秘密キーと自己署名証明書を作成します。CSR を必要としないほとんどのインストールにはこれで十分です。\n\n```\n# mkdir /etc/nginx/ssl\n# cd /etc/nginx/ssl\n# openssl req -new -x509 -nodes -newkey rsa:4096 -keyout server.key -out server.crt -days 1095\n# chmod 400 server.key\n# chmod 444 server.crt\n```\n\nCSR を作成する必要がある場合は、上記の代わりに次の手順に従ってください。\n\n```\n# mkdir /etc/nginx/ssl\n# cd /etc/nginx/ssl\n# openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -out server.key\n# chmod 400 server.key\n# openssl req -new -sha256 -key server.key -out server.csr\n# openssl x509 -req -days 1095 -in server.csr -signkey server.key -out server.crt\n```\n\nTLS を使用した /etc/nginx/nginx.conf の開始点は、Mozilla の SSL 設定ジェネレーター です。\n\nnginx.service を再起動 して変更内容を反映させます。\n\n"
    },
    {
      "title": "ユーザーごとのディレクトリ",
      "level": 4,
      "content": "Apache スタイルの ~user URL をユーザーの ~/public_html ディレクトリに複製するには、次の手順を試してください。(注: 両方のルールを使用する場合、以下では、より具体的な PHP ルールを最初に置く必要があります。)\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\n...\nserver {\n    ...\n    # PHP in user directories, e.g. http://example.com/~user/test.php\n    location ~ ^/~(.+?)(/.+\\.php)$ {\n        alias          /home/$1/public_html$2;\n        fastcgi_pass   unix:/run/php-fpm/php-fpm.sock;\n        fastcgi_index  index.php;\n        include        fastcgi.conf;\n    }\n\n    # User directories, e.g. http://example.com/~user/\n    location ~ ^/~(.+?)(/.*)?$ {\n        alias     /home/$1/public_html$2;\n        index     index.html index.htm;\n        autoindex on;\n    }\n    ...\n}\n...\n```\n\nnginx を使用した PHP 設定の詳細については、PHP を動かす を参照してください。\n\nnginx.service を 再起動 して新しい設定を有効にします。\n\n"
    },
    {
      "title": "FastCGI",
      "level": 3,
      "content": "FastCGI、または FCGI はウェブサーバーでインタラクティブなプログラムを動作させるためのプロトコルです。FastCGI は Common Gateway Interface (CGI) の変種で、ウェブサーバーと CGI プログラムのオーバーヘッドを減らすよう設計されていて、サーバーはより多くのウェブページのリクエストを一度に捌くことができます。\n\nNginx には FastCGI が組み込まれており多くの外部ツールが動きます、例えば Perl、PHP、Python など。これらを使うためにはまず FastCGI サーバーを動かす必要があります。\n\n"
    },
    {
      "title": "PHP を動かす",
      "level": 4,
      "content": "PHP のために FastCGI サーバーを動かす方法は複数あります。ここでは推奨方法として php-fpm を使う方法を記載しています。\n\nphp をインストールしてください。/etc/php/php.ini の中にある open_basedir に PHP ファイルが含まれているベースディレクトリを （/srv/http/ や /usr/share/webapps/ のような感じで）指定しなくてはなりません:\n\n```\nopen_basedir = /usr/share/webapps/:/srv/http/:/home/:/tmp/:/usr/share/pear/\n```\n\nそうしたら必要なモジュールを設定しましょう。例えば sqlite3 を使うなら php-sqlite をインストールして、/etc/php/php.ini の次の行をアンコメントして有効にします:\n\n```\nextension=sqlite3.so\n```\n\nMariaDB で説明されているようにして MySQL/MariaDB を設定してください。\n\n/etc/php/php.ini の以下の行の 少なくともどれか一つ をアンコメント:\n\n```\nextension=pdo_mysql.so\nextension=mysqli.so\n```\n\nウェブスクリプトのために最小権限の MySQL ユーザーを追加することができます。また、/etc/mysql/my.cnf を編集して skip-networking 行をアンコメントすると MySQL サーバーはローカルホストからしかアクセスできなくなります。変更を適用するには MySQL を再起動する必要があります。\n\n- http://php-fpm.org\n\nphp-fpm をインストールします:\n\n```\n# pacman -S php-fpm\n```\n\n設定ファイルは /etc/php/php-fpm.conf です。\n\nサービスを動かします:\n\n```\n# systemctl start php-fpm\n```\n\nphp-fpm をスタートアップ時に有効にします:\n\n```\n# systemctl enable php-fpm.service\n```\n\nそれぞれの server ブロックの中の location ブロックに PHP アプリケーションを次のように記述します:\n\n```\nlocation ~ \\.php$ {\n     fastcgi_pass   unix:/run/php-fpm/php-fpm.sock;\n     fastcgi_index  index.php;\n     include        fastcgi.conf;\n}\n```\n\n/etc/nginx/php.conf を作って設定をそこに書く場合、このファイルを server ブロックに入れて下さい。\n\n```\nserver = {\n    ...\n    include  php.conf;\n    ...\n}\n```\n\n.html や .htm ファイルを PHP として処理したい場合は、以下のようにしてください:\n\n```\nlocation ~ \\.(php|html|htm)$ {\n     fastcgi_pass  unix:/run/php-fpm/php-fpm.sock;\n     fastcgi_index  index.php;\n     include        fastcgi.conf;\n}\n```\n\n拡張子が .php でないファイルを php-fpm で動かすことを /etc/php/php-fpm.conf で有効にする必要があります:\n\n```\nsecurity.limit_extensions = .php .html .htm\n```\n\n設定を変えた後は php-fpm デーモンを再起動してください。\n\n```\n# systemctl restart php-fpm\n```\n\n```\nfastcgi_pass unix:/run/php-fpm/php-fpm.sock;\n```\n\nデフォルトの代わりに、通常の TCP ソケットを使うこともできます\n\n```\nfastcgi_pass 127.0.0.1:9000;\n```\n\nNginx のための FastCGI 設定がある fastcgi.conf か fastcgi_params が含まれていますが、後者は使われなくなりました。これらのファイルは Nginx をインストールしたときに作られます。\n\n最後に、Nginx が動作している場合は再起動してください:\n\n```\n# systemctl restart nginx\n```\n\nFastCGI をテストしたい場合は、/usr/share/nginx/html/index.php を次の内容で作成して\n\n```\n<?php\n  phpinfo();\n?>\n```\n\nブラウザで http://127.0.0.1/index.php を開いて下さい。\n\n以下は実際の設定例です。例の中では root パスは server の下に直接指定されており (デフォルト設定のように) location の中には置いていません。\n\n```\nserver {\n    listen 80;\n    server_name localhost;\n    root /usr/share/nginx/html;\n    location / {\n        index index.html index.htm index.php;\n    }\n\n    location ~ \\.php$ {\n        #fastcgi_pass 127.0.0.1:9000; (depending on your php-fpm socket configuration)\n        fastcgi_pass unix:/run/php-fpm/php-fpm.sock;\n        fastcgi_index index.php;\n        include fastcgi.conf;\n    }\n}\n```\n\n"
    },
    {
      "title": "CGI を動かす",
      "level": 4,
      "content": "この実装は CGI アプリケーションに必要です。\n\nfcgiwrap をインストールしてください。 設定ファイルは /usr/lib/systemd/system/fcgiwrap.socket です。 systemd の fcgiwrap.socket を有効化・起動します。\n\nこの systemd ユニットファイルは現在 ArchLinux のタスクページで議論されています。思い通りに動くか確認するためにユニットファイルを自分で検査すると良いでしょう。\n\n複数のワーカースレッドを生成したい場合は、multiwatchAUR を使用するのが推奨されています。これはクラッシュした子スレッドの再起動の面倒をみてくれます。multiwatch は systemd が作成したソケットを管理できないため、unix ソケットを作成するには spawn-fcgi を使う必要がありますが、ユニットファイルから直接実行した場合は fcgiwrap には問題が生じません。\n\n/usr/lib/systemd/system/fcgiwrap.service から /etc/systemd/system/fcgiwrap.service にユニットファイルをコピーして (存在する場合は fcgiwrap.socket ユニットも)、ExecStart 行を必要に応じて修正してください。以下は multiwatchAUR を使用するユニットファイルです。fcgiwrap.socket が実行中だったり有効になっていないことを確認してください、このユニットと衝突してしまうからです:\n\n```\n/etc/systemd/system/fcgiwrap.service\n```\n\n```\n[Unit]\nDescription=Simple CGI Server\nAfter=nss-user-lookup.target\n\n[Service]\nExecStartPre=/bin/rm -f /run/fcgiwrap.socket\nExecStart=/usr/bin/spawn-fcgi -u http -g http -s /run/fcgiwrap.sock -n -- /usr/bin/multiwatch -f 10 -- /usr/sbin/fcgiwrap\nExecStartPost=/usr/bin/chmod 660 /run/fcgiwrap.sock\nPrivateTmp=true\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target\n```\n\n-f 10 は生成する子スレッドの数に変更してください。\n\n/etc/nginx で、ファイル fastcgi_params を fcgiwrap_params にコピーします。fcgiwrap_params で、SCRIPT_NAME と DOCUMENT_ROOT を設定する行をコメント化するか削除します。\n\nCGI Web アプリケーションを提供する各 server ブロック内には、次のような location ブロックが表示されます。\n\n```\nlocation ~ \\.cgi$ {\n     include       fcgiwrap_params;\n     fastcgi_param DOCUMENT_ROOT /srv/www/cgi-bin/;\n     fastcgi_param SCRIPT_NAME   myscript.cgi;\n     fastcgi_pass  unix:/run/fcgiwrap.sock;\n}\n```\n\nfcgiwrap のデフォルトのソケットファイルは /run/fcgiwrap.sock です。\n\nfastcgi_param SCRIPT_FILENAME /srv/www/cgi-bin/myscript.cgi を使用することは、DOCUMENT_ROOT と SCRIPT_NAME を設定する代わりのショートカットです。 SCRIPT_FILENAME を使用する場合は、fastcgi_params を fcgiwrap_params にコピーして、DOCUMENT_ROOT と SCRIPT_NAME 行をコメントアウトする必要もありません。\n\n502 - bad Gateway エラーが繰り返し発生する場合は、CGI アプリケーションが最初に次のコンテンツの MIME タイプをアナウンスするかどうかを確認する必要があります。HTML の場合、これは Content-type: text/html である必要があります。\n\n403 エラーが発生した場合は、CGI 実行可能ファイルが http ユーザーによって読み取りおよび実行可能であること、およびすべての親フォルダーが http ユーザーによって読み取り可能であることを確認してください。\n\n"
    },
    {
      "title": "chroot でインストール",
      "level": 2,
      "content": "chroot に Nginx をインストールすることでセキュリティレイヤーを追加することができます。セキュリティを最大限に高めるために、Nginx サーバーを動かすのに必要なファイルだけを入れて、全てのファイルはできる限り最小限の権限にします。例えば、なるべく root が所有するようにして、/usr/bin などのディレクトリは読み書きできないようにするなど。\n\nArch はデフォルトでサーバーを実行するための http ユーザーとグループが設定されています。chroot は /srv/http で動作させます。\n\nこの牢獄を作るための perl スクリプトが jail.pl gist にあります。このスクリプトを使用するか、またはこの記事の指示に従って作成するか選ぶことができます。スクリプトは root で実行してください。変更を適用する前に行をアンコメントする必要があります。\n\n"
    },
    {
      "title": "必要なデバイスを作成",
      "level": 3,
      "content": "Nginx には /dev/null, /dev/random, /dev/urandom が必要です。これらを chroot にインストールするために /dev/ フォルダを作成してデバイスを mknod で追加します。chroot が危険になったときでも、攻撃者が /dev/sda1 などの重要なデバイスにアクセスするには chroot から脱出しなくてはならないようにするために、/dev/ を全てマウントはしません。\n\n```\n# export JAIL=/srv/http\n# mkdir $JAIL/dev\n# mknod -m 0666 $JAIL/dev/null c 1 3\n# mknod -m 0666 $JAIL/dev/random c 1 8\n# mknod -m 0444 $JAIL/dev/urandom c 1 9\n```\n\n"
    },
    {
      "title": "必要なフォルダを作成",
      "level": 3,
      "content": "Nginx を適切に実行するためにはたくさんのファイルが必要になります。それらをコピーする前に、ファイルを保存するためのフォルダを作成してください。ここでは Nginx のドキュメントルートが /srv/http/www であると仮定します。\n\n```\n# mkdir -p $JAIL/etc/nginx/logs\n# mkdir -p $JAIL/usr/{lib,bin}\n# mkdir -p $JAIL/usr/share/nginx\n# mkdir -p $JAIL/var/{log,lib}/nginx\n# mkdir -p $JAIL/www/cgi-bin\n# mkdir -p $JAIL/{run,tmp}\n# cd $JAIL; ln -s usr/lib lib\n```\n\nそして $JAIL/tmp と $JAIL/run を tmpfs でマウントします。攻撃者が RAM を全て喰いつくせないようにサイズを制限すると良いでしょう。\n\n```\n# mount -t tmpfs none $JAIL/run -o 'noexec,size=1M'\n# mount -t tmpfs none $JAIL/tmp -o 'noexec,size=100M'\n```\n\n再起動してもマウントが維持されるように、以下のエントリを /etc/fstab に追加します:\n\n```\n/etc/fstab\n```\n\n```\ntmpfs   /srv/http/run   tmpfs   rw,noexec,relatime,size=1024k   0       0\n tmpfs   /srv/http/tmp   tmpfs   rw,noexec,relatime,size=102400k 0       0\n```\n\n"
    },
    {
      "title": "chroot に移住",
      "level": 3,
      "content": "まず平易なファイルをコピーします。\n\n```\n# cp -r /usr/share/nginx/* $JAIL/usr/share/nginx\n# cp -r /usr/share/nginx/html/* $JAIL/www\n# cp /usr/bin/nginx $JAIL/usr/bin/\n# cp -r /var/lib/nginx $JAIL/var/lib/nginx\n```\n\nそして必要なライブラリをコピーします。ldd を使ってライブラリを確認して適当な場所にコピーして下さい。ハードリンクよりはコピーが推奨されます。攻撃者が書き込み権限を得たときに本当のシステムファイルが破壊されたり改変される可能性があるためです。\n\n```\n$ ldd /usr/bin/nginx\n```\n\n```\nlinux-vdso.so.1 (0x00007fffc41fe000)\n   libpthread.so.0 => /usr/lib/libpthread.so.0 (0x00007f57ec3e8000)\n   libcrypt.so.1 => /usr/lib/libcrypt.so.1 (0x00007f57ec1b1000)\n   libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x00007f57ebead000)\n   libm.so.6 => /usr/lib/libm.so.6 (0x00007f57ebbaf000)\n   libpcre.so.1 => /usr/lib/libpcre.so.1 (0x00007f57eb94c000)\n   libssl.so.1.0.0 => /usr/lib/libssl.so.1.0.0 (0x00007f57eb6e0000)\n   libcrypto.so.1.0.0 => /usr/lib/libcrypto.so.1.0.0 (0x00007f57eb2d6000)\n   libdl.so.2 => /usr/lib/libdl.so.2 (0x00007f57eb0d2000)\n   libz.so.1 => /usr/lib/libz.so.1 (0x00007f57eaebc000)\n   libGeoIP.so.1 => /usr/lib/libGeoIP.so.1 (0x00007f57eac8d000)\n   libgcc_s.so.1 => /usr/lib/libgcc_s.so.1 (0x00007f57eaa77000)\n   libc.so.6 => /usr/lib/libc.so.6 (0x00007f57ea6ca000)\n   /lib64/ld-linux-x86-64.so.2 (0x00007f57ec604000)\n```\n\n```\n# cp /lib64/ld-linux-x86-64.so.2 $JAIL/lib\n```\n\n/usr/lib の中にあるファイルについては次のワンライナーが使えます:\n\n```\n# cp $(ldd /usr/bin/nginx | grep /usr/lib | sed -sre 's/(.+)(\\/usr\\/lib\\/\\S+).+/\\2/g') $JAIL/usr/lib\n```\n\n必要なライブラリとシステムファイル以外のファイルをコピーします。\n\n```\n# cp /usr/lib/libnss_* $JAIL/usr/lib\n# cp -rfvL /etc/{services,localtime,nsswitch.conf,nscd.conf,protocols,hosts,ld.so.cache,ld.so.conf,resolv.conf,host.conf,nginx} $JAIL/etc\n```\n\nchroot のために制限を付けたユーザー・グループファイルを作成します。これにより chroot にアクセスするのに必要なシステムユーザー・グループが攻撃者に漏洩しなくなります。\n\n```\n$JAIL/etc/group\n```\n\n```\nhttp:x:33:\nnobody:x:99:\n```\n\n```\n$JAIL/etc/passwd\n```\n\n```\nhttp:x:33:33:http:/:/bin/false\nnobody:x:99:99:nobody:/:/bin/false\n```\n\n```\n$JAIL/etc/shadow\n```\n\n```\nhttp:x:14871::::::\nnobody:x:14871::::::\n```\n\n```\n$JAIL/etc/gshadow\n```\n\n```\nhttp:::\nnobody:::\n```\n\n```\n# touch $JAIL/etc/shells\n# touch $JAIL/run/nginx.pid\n```\n\n最後にパーミッションをできるだけ制限的に設定してください。できるかぎり所有者を root にして書き込み不可にします。\n\n```\n# chown -R root:root $JAIL/\n \n# chown -R http:http $JAIL/www\n# chown -R http:http $JAIL/etc/nginx\n# chown -R http:http $JAIL/var/{log,lib}/nginx\n# chown http:http $JAIL/run/nginx.pid\n \n# find $JAIL/ -gid 0 -uid 0 -type d -print | xargs sudo chmod -rw\n# find $JAIL/ -gid 0 -uid 0 -type d -print | xargs sudo chmod +x\n# find $JAIL/etc -gid 0 -uid 0 -type f -print | xargs sudo chmod -x\n# find $JAIL/usr/bin -type f -print | xargs sudo chmod ug+rx\n# find $JAIL/ -group http -user http -print | xargs sudo chmod o-rwx\n# chmod +rw $JAIL/tmp\n# chmod +rw $JAIL/run\n```\n\nサーバーがポート 80 (あるいは 0-1024 のどれかのポート) で待機する場合、chroot した実行ファイルに root 権限がなくてもポートを使えるように権限を与えてください:\n\n```\n# setcap 'cap_net_bind_service=+ep' $JAIL/usr/bin/nginx\n```\n\n"
    },
    {
      "title": "nginx.service を変更して chroot を起動",
      "level": 3,
      "content": "nginx.service ユニットファイルを編集する前に、ユニットファイルを /etc/systemd/system/ にコピーして /usr/lib/systemd/system/ のファイルよりも優先されるようにすると良いでしょう。nginx をアップグレードしたときにカスタムした .service ファイルが変更されなくなります。\n\n```\n# cp /usr/lib/systemd/system/nginx.service /etc/systemd/system/nginx.service\n```\n\nchroot で nginx を起動するために systemd ユニットを変更して、pid ファイルを chroot に保存します。\n\n```\n/etc/systemd/system/nginx.service\n```\n\n```\n[Unit]\n Description=A high performance web server and a reverse proxy server\n After=syslog.target network.target\n \n [Service]\n Type=forking\n PIDFile=/srv/http/run/nginx.pid\n ExecStartPre=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -t -q -g 'pid /run/nginx.pid; daemon on; master_process on;'\n ExecStart=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -g 'pid /run/nginx.pid; daemon on; master_process on;'\n ExecReload=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -g 'pid /run/nginx.pid; daemon on; master_process on;' -s reload\n ExecStop=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -g 'pid /run/nginx.pid;' -s quit\n \n [Install]\n WantedBy=multi-user.target\n```\n\nchroot されていない nginx 環境は取り除いてもかまいません:\n\n```\n# pacman -Rsc nginx\n```\n\nchroot されていない nginx 環境を削除しない場合、実行中の nginx プロセスが chroot されているプロセスかどうか確認したくなるときがあるかもしれません。/proc/PID/root シンボリックリンクを確認することでチェックできます。\n\n```\n# ps -C nginx | awk '{print $1}' | sed 1d | while read -r PID; do ls -l /proc/$PID/root; done\n```\n\n"
    },
    {
      "title": "systemd を使用したユーザーサービスの実行",
      "level": 3,
      "content": "権限のないユーザーが完全に制御して構成できるサーバーインスタンスを実行したい場合は、nginx-user-serviceAUR の使用を検討してください。\n\n"
    },
    {
      "title": "systemd を使って非特権で動作させる",
      "level": 3,
      "content": "nginx.service のドロップインファイルを使用して、[Service] の下の User と任意で Group を設定します。\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\nUser=user\nGroup=group\n```\n\n権限昇格に対してサービスを防御することができます:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nNoNewPrivileges=yes\n```\n\nそれから user が必要なファイルやポートにアクセスできるようにしてください。以下の項目に従って、nginx を起動します。\n\n"
    },
    {
      "title": "ポート",
      "level": 4,
      "content": "Linux はデフォルトでは root 以外が 1024 以下のポートを使うことができないようになっています。1024 よりも上のポートは使うことができます:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nserver {\n        listen 8080;\n}\n```\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nCapabilityBoundingSet=\nCapabilityBoundingSet=CAP_NET_BIND_SERVICE\nAmbientCapabilities=\nAmbientCapabilities=CAP_NET_BIND_SERVICE\n```\n\n"
    },
    {
      "title": "PID ファイル",
      "level": 4,
      "content": "nginx はデフォルトでは /run/nginx.pid を使います。user が書き込み可能なディレクトリを作成して PID ファイルをそこに配置します。systemd-tmpfiles を使用する例:\n\n```\n/etc/tmpfiles.d/nginx.conf\n```\n\n```\nd /run/nginx 0775 root group - -\n```\n\n設定を実行:\n\n```\n# systemd-tmpfiles --create\n```\n\n元の nginx.service に合わせて PID の値を編集:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nPIDFile=/run/nginx/nginx.pid\nExecStart=\nExecStart=/usr/bin/nginx -g 'pid /run/nginx/nginx.pid; error_log stderr;' \nExecReload=\nExecReload=/usr/bin/nginx -s reload -g 'pid /run/nginx/nginx.pid;'\n```\n\n"
    },
    {
      "title": "/var/lib/nginx",
      "level": 4,
      "content": "nginx は、デフォルトで一時ファイルを /var/lib/nginx に保存するようにコンパイルされます。\n\nたとえば、StateDirectory (systemd.exec(5)) を使用して、ユーザー にこのディレクトリへの書き込みアクセス権を与えることができます。\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nStateDirectory=nginx\n```\n\n"
    },
    {
      "title": "/var/log/nginx",
      "level": 4,
      "content": "nginx は、デフォルトでアクセスログを /var/log/nginx に保存するようにコンパイルされます。\n\nたとえば、LogsDirectory (systemd.exec(5)) を使用して、ユーザー にこのディレクトリへの書き込みアクセス権を与えることができます。\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nLogsDirectory=nginx\n```\n\n"
    },
    {
      "title": "systemd の別のスクリプト",
      "level": 3,
      "content": "純粋な systemd では、chroot + systemd の利点を得ることができます。[1] セット ユーザーグループ と pid に基づいて次のようにします。\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nuser http;\npid /run/nginx.pid;\n```\n\nファイルの絶対パスは /srv/http/etc/nginx/nginx.conf です。\n\n```\n/etc/systemd/system/nginx.service\n```\n\n```\n[Unit]\nDescription=nginx (Chroot)\nAfter=syslog.target network.target\n\n[Service]\nType=forking\nPIDFile=/srv/http/run/nginx.pid\nRootDirectory=/srv/http\nExecStartPre=/usr/bin/nginx -t -c /etc/nginx/nginx.conf\nExecStart=/usr/bin/nginx -c /etc/nginx/nginx.conf\nExecReload=/usr/bin/nginx -c /etc/nginx/nginx.conf -s reload\nExecStop=/usr/bin/nginx -c /etc/nginx/nginx.conf -s stop\n\n[Install]\nWantedBy=multi-user.target\n```\n\nデフォルトの場所を設定する必要はありません。nginx はデフォルトでロードされます。 -c /etc/nginx/nginx.conf ですが、これは良い考えです。\n\nあるいは、パラメータ RootDirectoryStartOnly を yes に設定して chroot として only ExecStart を実行することもできます。(systemd.service(5) を参照) またはマウントポイントが有効になる前、または systemd パス (systemd.path(5) を参照) が利用可能になる前に起動します。\n\n```\n/etc/systemd/system/nginx.path\n```\n\n```\n[Unit]\nDescription=nginx (Chroot) path\n[Path]\nPathExists=/srv/http/site/Public_html\n[Install]\nWantedBy=default.target\n```\n\n作成された nginx.path を 有効化 し、WantedBy=default.target を WantedBy=nginx.path に変更します|/etc/systemd/system/nginx.service}}\n\nユニットファイル内の PIDFile により、systemd がプロセスを監視できるようになります (絶対パスが必要です) 望ましくない場合は、デフォルトのワンショットタイプに変更し、ユニットファイルから参照を削除できます。\n\n"
    },
    {
      "title": "Nginx Beautifier",
      "level": 3,
      "content": "nginxbeautifierAUR は nginx の設定ファイルを整形することができるコマンドラインツールです。\n\n"
    },
    {
      "title": "より良いヘッダー管理",
      "level": 3,
      "content": "Nginx のヘッダー管理システムはあまり直感的とは言えません。ヘッダーは特定のコンテキストでしか定義できず、他のヘッダーは無視されます。headers-more-nginx モジュールをインストールすることでこの挙動を変更できます。\n\nnginx-mod-headers-more パッケージをインストールしてください。モジュールは /usr/lib/nginx/modules ディレクトリにインストールされます。\n\nモジュールをロードするには以下をメインの nginx の設定ファイルに追加してください:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nload_module \"/usr/lib/nginx/modules/ngx_http_headers_more_filter_module.so\";\n...\n```\n\n"
    },
    {
      "title": "基本認証",
      "level": 3,
      "content": "基本認証ではパスワードファイルの作成が必要です。パスワードファイルは、apache パッケージで提供される htpasswd プログラムを使用するか、nginx-passwd を提供する nginx_passwdAUR を使用して管理できます。詳細は、次のサイトで確認できます。 github ソース\n\n"
    },
    {
      "title": "php-legacy の使用",
      "level": 3,
      "content": "php-fpm の代わりに php-legacy-fpm を インストール し、PHP が正しくインストールされ、設定されていることを確認してください。\n\nPHP-LEGACY-FPM の主な設定ファイルは /etc/php-legacy/php-fpm.conf です。基本的な使い方はデフォルトの設定で十分でしょう。\n\nfastcgi_pass 引数の Unix ソケットも調整する必要があります。通常は次のようになります:\n\n```\nfastcgi_pass unix:/run/php-fpm-legacy/php-fpm.sock;\n```\n\n次に、php-legacy-fpm.service を 起動/有効化 して下さい。\n\n"
    },
    {
      "title": "設定の確認",
      "level": 3,
      "content": "```\n# nginx -t\n```\n\n```\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n```\n\n"
    },
    {
      "title": "Error: The page you are looking for is temporarily unavailable. Please try again later. (502 Bad Gateway)",
      "level": 3,
      "content": "これは、FastCGI サーバーが起動していないか、使用されているソケットの権限が間違っているためです。\n\n502 エラーを修正するには、out thisanswer を試してください。\n\nArch Linux では、上記のリンクに記載されている設定ファイルは /etc/php/php-fpm.conf です。\n\n"
    },
    {
      "title": "Error: No input file specified",
      "level": 3,
      "content": "1. /etc/php/php.ini の変数 open_basedir が nginx.conf の {{ic|root} 引数に指定した正しいパスを含むことを確認します。(通常は /usr/share/nginx/) です。PHP の FastCGI サーバとして PHP-FPM を使用する場合、 fastcgi_param PHP_ADMIN_VALUE \"open_basedir=$document_root/:/tmp/:/proc/\"; を location ブロックに追加し、nginx.conf の php ファイル処理用に指定することができます。\n\n2. もう 1 つは、nginx.conf の location ~ \\.php$ セクションの root 引数が間違っていることです。root が同じサーバー内の location / と同じディレクトリを指していることを確認してください。または、root をグローバルとして設定し、location セクションで定義しないこともできます。\n\n3. パーミッションの確認:例えば、ユーザー/グループは http 、ディレクトリは 755 、ファイルは 644 です。html ディレクトリへのパス全体が正しいパーミッションを持っている必要があることを忘れないでください。ディレクトリツリーを一括で変更するには、ファイルのパーミッションと属性#まとめて chmod を参照してください。\n\n4. おそらくスクリプトのフルパスを含んだ SCRIPT_FILENAME がありません。 nginx の設定 (fastcgi_param SCRIPT_FILENAME) が完全でも、このエラーは php が requestd スクリプトをロードできないことを意味しています。これは単純にパーミッションの問題であることが普通で、root で php-cgi を実行するか\n\n```\n# spawn-fcgi -a 127.0.0.1 -p 9000 -f /usr/bin/php-cgi\n```\n\nphp-cgi を起動するグループとユーザーを作成する必要があります。例えば:\n\n```\n# groupadd www\n# useradd -g www www\n# chmod +w /srv/www/nginx/html\n# chown -R www:www /srv/www/nginx/html\n# spawn-fcgi -a 127.0.0.1 -p 9000 -u www -g www -f /usr/bin/php-cgi\n```\n\n5. chrooted nginx で php-fpm を実行している場合は、chroot が /etc/php-fpm/php-fpm.d/www.conf (または /etc/php-fpm/php-fpm.conf 古いバージョンで動作している場合)\n\n"
    },
    {
      "title": "Warning: Could not build optimal types_hash",
      "level": 3,
      "content": "nginx.service を開始すると、プロセスによって次のメッセージが記録される場合があります。\n\n```\n[warn] 18872#18872: could not build optimal types_hash, you should increase either types_hash_max_size: 1024 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size\n```\n\nこの警告を修正するには、http ブロック内のこれらのキーの値を増やします [2] [3]:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nhttp {\n    types_hash_max_size 4096;\n    server_names_hash_bucket_size 128;\n    ...\n}\n```\n\n"
    },
    {
      "title": "要求されたアドレスを割り当てることができない",
      "level": 3,
      "content": "nginx.service ユニットステータス からの完全なエラーは次のとおりです。\n\n```\n[emerg] 460#460: bind() to A.B.C.D:443 failed (99: Cannot assign requested address)\n```\n\nnginx ユニットファイルが systemd を使用して network.target の後に実行するように設定されている場合でも、nginx は、構成されているがどのインターフェイスにもまだ追加されていないアドレスでリッスンしようとする場合があります。 nginx の 開始 を手動で実行して、これが当てはまることを確認します (これにより、IP アドレスが適切に設定されていることが示されます) 任意のアドレスをリッスンするように nginx を設定すると、この問題が解決します。ユースケースで特定のアドレスをリッスンする必要がある場合、考えられる解決策の 1 つは、systemd を再構成することです。\n\n設定されたすべてのネットワークデバイスが起動し、IP アドレスが割り当てられた後に nginx を起動するには、nginx.service 内の After= に network-online.target を追加し、systemd-networkd-wait-online.service を 起動/有効化 にします。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- WebDAV with nginx\n- nginx configuration pitfalls\n- Very good in-depth 2014 look at nginx security and Reverse Proxying\n- Installing LEMP (nginx, PHP, MySQL with MariaDB engine and PhpMyAdmin) in Arch Linux\n- Using SSL certificates generated with Let's Encrypt\n\n"
    }
  ]
}