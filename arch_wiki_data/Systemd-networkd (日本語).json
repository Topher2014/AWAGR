{
  "title": "Systemd-networkd (日本語)",
  "url": "https://wiki.archlinux.org/title/Systemd-networkd_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- systemd\n- systemd-resolved\n- systemd-nspawn\n- ネットワークブリッジ\n- ネットワーク設定\n- ワイヤレスネットワーク設定\n- Category:ネットワーク設定\n\nsystemd-networkd はネットワーク設定を管理するシステムデーモンです。ネットワークデバイスが立ち上がるとそれを検出して設定を行います。また、仮想ネットワークデバイスを作成することもできます。このサービスは systemd-nspawn で管理されるコンテナまたは仮想マシンの複雑なネットワークを設定する場合にとても役に立ちます。また、単純な接続でも正常に動作します。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 基本的な使い方 1.1 必要なサービスと設定 1.2 system-networkd-wait-online 1.2.1 常時接続されていない複数のインターフェース 1.2.2 ネットワークインターフェースがルーティング可能なアドレスを取得するまで待機する 1.3 設定ファイルの例 1.3.1 有線アダプタで DHCP を使用 1.3.2 有線アダプタで固定 IP を使用 1.3.3 無線アダプタ 1.3.4 同一マシンで有線アダプタと無線アダプタ両方を使用\n- 2 設定ファイル 2.1 network ファイル 2.1.1 [Match] 2.1.2 [Link] 2.1.3 [Network] 2.1.4 [Address] 2.1.5 [Route] 2.1.6 [RoutingPolicyRule] 2.1.7 [DHCPv4] 2.1.8 [DHCPServer] 2.2 netdev ファイル 2.2.1 [Match] セクション 2.2.2 [NetDev] セクション\n- 3 コンテナでの使用方法 3.1 DHCP を用いたネットワークブリッジ 3.1.1 ブリッジインターフェイス 3.1.2 イーサネットをブリッジに関連付ける 3.1.3 ブリッジネットワーク 3.1.4 MAC アドレスを継承する(オプション) 3.1.5 コンテナの設定 3.1.6 結果 3.1.7 注意 3.2 静的 IP アドレスを持つネットワークブリッジ 3.3 MACVLAN bridge\n- 4 ヒントとテクニック 4.1 管理やデスクトップの統合 4.2 SSID (場所) に基づいた静的 IP または DHCP の設定 4.3 ワイヤード (有線) インターフェイスとワイヤレスインターフェイスのボンディング 4.4 TCP スロースタートの速度を上げる 4.5 既存のインターフェースに独自の MAC アドレスを持つ2番目の静的 IP を設定する\n- 5 参照\n\n- 1.1 必要なサービスと設定\n- 1.2 system-networkd-wait-online 1.2.1 常時接続されていない複数のインターフェース 1.2.2 ネットワークインターフェースがルーティング可能なアドレスを取得するまで待機する\n- 1.3 設定ファイルの例 1.3.1 有線アダプタで DHCP を使用 1.3.2 有線アダプタで固定 IP を使用 1.3.3 無線アダプタ 1.3.4 同一マシンで有線アダプタと無線アダプタ両方を使用\n\n- 1.2.1 常時接続されていない複数のインターフェース\n- 1.2.2 ネットワークインターフェースがルーティング可能なアドレスを取得するまで待機する\n\n- 1.3.1 有線アダプタで DHCP を使用\n- 1.3.2 有線アダプタで固定 IP を使用\n- 1.3.3 無線アダプタ\n- 1.3.4 同一マシンで有線アダプタと無線アダプタ両方を使用\n\n- 2.1 network ファイル 2.1.1 [Match] 2.1.2 [Link] 2.1.3 [Network] 2.1.4 [Address] 2.1.5 [Route] 2.1.6 [RoutingPolicyRule] 2.1.7 [DHCPv4] 2.1.8 [DHCPServer]\n- 2.2 netdev ファイル 2.2.1 [Match] セクション 2.2.2 [NetDev] セクション\n\n- 2.1.1 [Match]\n- 2.1.2 [Link]\n- 2.1.3 [Network]\n- 2.1.4 [Address]\n- 2.1.5 [Route]\n- 2.1.6 [RoutingPolicyRule]\n- 2.1.7 [DHCPv4]\n- 2.1.8 [DHCPServer]\n\n- 2.2.1 [Match] セクション\n- 2.2.2 [NetDev] セクション\n\n- 3.1 DHCP を用いたネットワークブリッジ 3.1.1 ブリッジインターフェイス 3.1.2 イーサネットをブリッジに関連付ける 3.1.3 ブリッジネットワーク 3.1.4 MAC アドレスを継承する(オプション) 3.1.5 コンテナの設定 3.1.6 結果 3.1.7 注意\n- 3.2 静的 IP アドレスを持つネットワークブリッジ\n- 3.3 MACVLAN bridge\n\n- 3.1.1 ブリッジインターフェイス\n- 3.1.2 イーサネットをブリッジに関連付ける\n- 3.1.3 ブリッジネットワーク\n- 3.1.4 MAC アドレスを継承する(オプション)\n- 3.1.5 コンテナの設定\n- 3.1.6 結果\n- 3.1.7 注意\n\n- 4.1 管理やデスクトップの統合\n- 4.2 SSID (場所) に基づいた静的 IP または DHCP の設定\n- 4.3 ワイヤード (有線) インターフェイスとワイヤレスインターフェイスのボンディング\n- 4.4 TCP スロースタートの速度を上げる\n- 4.5 既存のインターフェースに独自の MAC アドレスを持つ2番目の静的 IP を設定する\n\n"
    },
    {
      "title": "基本的な使い方",
      "level": 2,
      "content": "systemd パッケージは Arch ではデフォルトでインストールされており、有線ネットワークに接続するために必要なファイルは全て揃っています。後で述べているように、wpa_supplicant や iwd など他のサービスを使うことで無線アダプタを設定することもできます。\n\n"
    },
    {
      "title": "必要なサービスと設定",
      "level": 3,
      "content": "systemd-networkd を使用するには、systemd-networkd.service 起動/有効化します。\n\nまた、ネットワーク名前解決サービスである systemd-resolved は，以下の点を考慮して任意に設定して下さい。\n\n- 使用する DNS を適切に設定するためには、resolv.conf と systemd-resolved の相互作用を理解することが重要です。 systemd-resolved にいくつかの解説があります。\n- DNS エントリーが .network ファイルで指定されている場合は systemd-resolved が必要です。\n- systemd-resolved は、DHCP サーバーまたは IPv6 ルーターから DNS アドレスを取得する場合にも必要です。\n\n(DHCP= および IPv6AcceptRA= セクションの [Network] および UseDNS=yes (デフォルト) 、[DHCPv4]、[DHCPv6]、[IPv6AcceptRA]、systemd.network(5) を参照してください。) を設定します。\n\n- systemd-networkd 無しでも systemd-resolved を使うことができることに注意してください。\n\n"
    },
    {
      "title": "system-networkd-wait-online",
      "level": 3,
      "content": "systemd-networkd.service を有効にすると、 systemd-networkd-wait-online.service も有効になります。これは、ネットワークが構成されるのを待つワンショット・システム・サービスです。後者は WantedBy=network-online.target を持っているので、 network-online.target 自身が有効になっているか、他のユニットに引き寄せられた時にのみ起動します。 Systemd#ネットワークが稼働した後にサービスを実行するも参照してください。\n\nデフォルトでは、 systemd-networkd-wait-online.service は、認識され systemd-networkd によって管理されているすべてのリンクが完全に設定されるか、または失敗しても、少なくとも1つのリンクがオンラインになるまで待機します。\n\n詳細については、systemd-networkd-wait-online(8) を参照してください。\n\n"
    },
    {
      "title": "常時接続されていない複数のインターフェース",
      "level": 4,
      "content": "システムに複数のネットワークインタフェースがあるが、常時接続されているとは想定されていないものもある場合 (例えば、 dual-port Ethernet を使用しているが、ケーブルが1本しか接続されていない場合)、 system-networkd-wait-online.service の起動は、デフォルトのタイムアウトである2分後に失敗します。これにより、起動プロセスに不要な遅延が発生する可能性があります。すべての インターフェイスではなく 任意の インターフェイスがオンラインになるまで待機する動作に変更するには、サービスを 編集 し、--any パラメータを ExecStart 行に追加します。\n\n```\n/etc/systemd/system/systemd-networkd-wait-online.service.d/wait-for-only-one-interface.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=/usr/lib/systemd/systemd-networkd-wait-online --any\n```\n\nまたは、特定のインターフェースを待機するために systemd-networkd-wait-online@.service を使用します。たとえば、enp1s0 を待機する場合、systemd-networkd-wait-online.service を無効化し、systemd-networkd-wait-online@enp1s0.service を有効化します。\n\n"
    },
    {
      "title": "ネットワークインターフェースがルーティング可能なアドレスを取得するまで待機する",
      "level": 4,
      "content": "systemd-networkd-wait-online.service(8) によると、\"オンラインとは、リンクの動作状態が \"degraded\" 以上であることを意味します\" とされています (\"degraded\" やその他の動作状態の定義については networkctl(1) を参照してください。)\n\nsystemd-networkd-wait-online.service がネットワークインターフェースにルーティング可能な IP アドレスを取得する前に終了しないようにするため(その結果、ネットワーク接続が必要な他のサービスが早すぎて起動するのを防ぐため).network ファイルの [Link] セクションに RequiredForOnline=routable を追加してください。\n\n```\n[Link]\nRequiredForOnline=routable\n```\n\n"
    },
    {
      "title": "設定ファイルの例",
      "level": 3,
      "content": "このセクションにおける設定はすべて /etc/systemd/network の中に foo.network として保存します。利用できるオプションや処理の順番については、#設定ファイル や systemd.network(5) を見て下さい。\n\nsystemd/udev は、予測可能で安定したネットワークインターフェイス名をすべてのローカルイーサネット、WLAN、WWAN インターフェイスに自動で割り当てます。システム上にあるデバイスのリストを得るには networkctl list を使用してください。\n\n設定ファイルに変更を加えたら、systemd-networkd.service を再起動してください。\n\n- 設定ファイル内で指定するオプションは大文字と小文字が区別されます。\n- 以下の例では、enp1s0 が有線アダプタ、wlp2s0 が無線アダプタです。環境によって名前は変わります。ネットワーク設定#ネットワークインターフェイス を見てください。\n- Name=en* や Name=wl* のようにワイルドカードを使うこともできます。\n- デバイスはタイプによってもマッチさせることが可能です。例: イーサネットは Type=ether、Wi-Fi は Type=wlan、WWAN は Type=wwan。注意点として、Type=ether は仮想イーサネットインターフェイス(veth*)にもマッチします(この動作は望ましくない場合があるでしょう)。\n- IPv6 を無効化したい場合、IPv6#systemd-networkd_3 を見てください。\n\n"
    },
    {
      "title": "有線アダプタで DHCP を使用",
      "level": 4,
      "content": "```\n/etc/systemd/network/20-wired.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Network]\nDHCP=yes\n```\n\n"
    },
    {
      "title": "有線アダプタで固定 IP を使用",
      "level": 4,
      "content": "```\n/etc/systemd/network/20-wired.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Network]\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.1\n```\n\nAddress= は1回以上使用することができ、複数の IPv4 や IPv6 アドレスを指定することができます。さらなるオプションについては #network ファイル や systemd.network(5) を見てください。\n\n"
    },
    {
      "title": "無線アダプタ",
      "level": 4,
      "content": "systemd-networkd で無線ネットワークに接続するには、wpa_supplicant や iwd などの別のアプリケーションで設定された無線アダプタが必要です。\n\n```\n/etc/systemd/network/25-wireless.network\n```\n\n```\n[Match]\nName=wlp2s0\n\n[Network]\nDHCP=yes\nIgnoreCarrierLoss=3s\n```\n\n無線アダプタで固定 IP アドレスを使っている場合、設定は (インターフェイス名を除いて) 有線アダプタと同じになります。\n\n無線スネットワークへの認証には、wpa_supplicant や iwd などを使用します。\n\n"
    },
    {
      "title": "同一マシンで有線アダプタと無線アダプタ両方を使用",
      "level": 4,
      "content": "以下の設定では、metric ディレクティブを使用して、有線と無線両方の接続で DHCP IP を有効にしており、カーネルがその場でどちらを使うか決定します。有線接続が切断されると、即座に無線に切り替わります。接続が途切れることはありません。\n\nシステム上の無線・有線どちらのデバイスも有効な接続がある場合、カーネルのルーティングのメトリック(ip で設定するのと同一) が、パケットを送るのにどちらのルートを使用するか決定します。システム上の有線デバイスと無線デバイスの両方がアクティブな接続を行っている場合がそうです。均衡状態を破るために、カーネルはメトリックを使います。もし一方の接続が終了しても、何も設定せずとも、もう一方が自動的にギャップを埋めます(進行中の転送はまだうまく対処されないでしょうが、これは他の OSI レイヤーでの問題です)。\n\nsystemd-networkd はインターフェイスごとのデフォルトルートメトリクスを設定しないので、手動で設定する必要があります:\n\n```\n/etc/systemd/network/20-wired.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Network]\nDHCP=yes\n\n[DHCPv4]\nRouteMetric=100\n\n[IPv6AcceptRA]\nRouteMetric=100\n```\n\n```\n/etc/systemd/network/25-wireless.network\n```\n\n```\n[Match]\nName=wlp2s0\n\n[Network]\nDHCP=yes\n\n[DHCPv4]\nRouteMetric=600\n\n[IPv6AcceptRA]\nRouteMetric=600\n```\n\n"
    },
    {
      "title": "設定ファイル",
      "level": 2,
      "content": "設定ファイルは /usr/lib/systemd/network/ から、そして一時的な実行時のネットワークディレクトリ /run/systemd/network/ とローカルのネットワーク管理ディレクトリ /etc/systemd/network/ から読み込まれます。/etc/systemd/network/ 内のファイルが一番優先されます。\n\n3つのタイプの設定ファイルが存在します。ファイルのフォーマットは systemd のユニットファイルと似ています。\n\n- .network ファイル。マッチするデバイスにネットワーク設定を適用します。\n- .netdev ファイル。マッチする環境に仮想ネットワークデバイスを作成します。\n- .link ファイル。ネットワークデバイスが作られた時、udev は最初にマッチする .link ファイルを探します。\n\nこれらの設定ファイルは同じルールに従っています:\n\n- [Match] セクションの全ての条件がマッチすれば、プロファイルが有効になります。\n- 空の [Match] セクションはどんな場合でもそのセクションを適用することを示します (いわば * ワイルドカードのようなものです)。\n- 全ての設定ファイルは辞書順でまとめてソートされ処理されます。ファイルがどのディレクトリにあるかは関係ありません。\n- 同じ名前のファイルは互いを置き換えます。\n\n- /etc/systemd/network/ 内のファイルは /usr/lib/systemd/network/ 内の対応する、システムによって提供されたファイルを上書きします。また、/dev/null へのシンボリックリンクを作成することで、システムファイルを\"マスク\"できます。\n- systemd は true 真偽値として値 1、true、yes、on を受け付け、false 真偽値として値 0、false、no、off を受け付けます。systemd.syntax(7) を見てください。For example, see WireGuard#Connection lost after sleep using systemd-networkd.\n\n"
    },
    {
      "title": "network ファイル",
      "level": 3,
      "content": "Table content:\nこのセクションは削除するべきか検討が行われています。 Reason: Duplicates the systemd.network(5) man page. (議論: トーク:Systemd-networkd#)\n\nこのファイルはネットワーク設定の変数の設定、特にサーバーとコンテナの設定のために存在します。\n\n.network ファイルには次のセクションを記述できます: [Match]、[Link]、[Network]、[Address]、[Route]、[DHCPv4]。以下ではそれぞれのセクションでよく使われる設定キーを説明します。詳細や例は systemd.network(5) を見てください。\n\n"
    },
    {
      "title": "[Match]",
      "level": 4,
      "content": "Table content:\nパラメータ | 説明 | 受け入れる値 | デフォルト値\nName= | デバイス名のリストにマッチ(例: en*)。プレフィックス ! を付けると、リストを反転できます。 | 空白で区切られた、グロブ付きデバイス名リスト。論理否定 (!) | \nMACAddress= | MAC アドレスのリストにマッチ(例: MACAddress=01:23:45:67:89:ab 00-11-22-33-44-55 AABB.CCDD.EEFF) | コロン、ハイフン、またはドットで区切られた完全な 16 進数による、空白で区切られた MAC アドレスリスト | \nHost= | ホスト名、またはホストのマシン IDにマッチ。 | グロブ付きのホスト名文字列、machine-id(5) | \nVirtualization= | システムが仮想化環境で起動されているかどうかをチェックします。Virtualization=false キーはホストマシンにのみマッチし、逆に Virtualization=true はコンテナや VM にマッチします。特定の仮想化タイプや実装をチェックしたり、(private-users を使って)ユーザ名前空間をチェックしたりできます。 | 真偽値、論理否定(!)、タイプ(vm, container)、実装(systemd-detect-virt(1) を参照)、private-users | \n\n"
    },
    {
      "title": "[Link]",
      "level": 4,
      "content": "Table content:\nパラメータ | 説明 | 受け入れる値 | デフォルト値\nMACAddress= | ハードウェアアドレスをデバイスに割り当てる。MAC アドレスの偽装に便利。 | コロン、ハイフン、ドットで区切られた、完全な 16 進数 MAC アドレス。 | \nMTUBytes= | デバイスに対して最大転送単位をバイト単位で指定。IPv6 がインターフェイスで有効化されていて、MTU が 1280 (IPv6 における最低 MTU) 未満に指定されている場合、自動的に 1280 まで増やされます。より大きな MTU 値を設定することで(例: ジャンボフレーム 使用時)、ネットワーク転送速度を飛躍的に速くできます。 | 整数 (通常の接尾辞 K、M、G がサポートされており、1024 の倍数として認識されます) | \nMulticast= | マルチキャスト の使用を許可。 | 真偽値 | ? ドキュメント化されておらず ?\n\n"
    },
    {
      "title": "[Network]",
      "level": 4,
      "content": "Table content:\nパラメータ | 説明 | 受け入れる値 | デフォルト値\nDHCP= | DHCPv4 と DHCPv6 の一方/両方のサポートを制御。 | 真偽値、ipv4、ipv6 | false\nDHCPServer= | 有効化されている場合、DHCPv4 サーバが起動されます。 | 真偽値 | false\nMulticastDNS= | マルチキャスト DNS のサポートを有効化。resolve に設定すると、名前解決のみが有効化され、ホストやサービスの登録と広告は行われません。 | 真偽値、resolve | false\nDNSSEC= | リンク上での DNSSEC DNS validation のサポートを制御。allow-downgrade に設定すると、DNSSEC 非対応のネットワークとの互換性が向上します。この場合、DNSSEC は自動でオフになります。 | 真偽値、allow-downgrade | false\nDNS= | 固定 DNS アドレスを設定。1回以上指定できます。 | inet_pton(3) | \nDomains= | リンク上の DNS サーバを利用して解決すべきドメインのリスト。詳細 | ドメイン名、オプションでチルダ(~)のプレフィックス。 | \nIPForward= | 有効化すると、ネットワークインターフェイス上で受信したパケットを、ルーティングテーブルに従って他のインターフェイスに転送します。詳細は インターネット共有#パケット転送の有効化。 | 真偽値、ipv4、ipv6 | false\nIPMasquerade= | 有効化すると、ネットワークインターフェイスからのパケット転送がローカルホストから来るように見えます。値によっては、IPForward=ipv4、IPForward=ipv6、または IPForward=yes の意味になります。 | ipv4、ipv6、both、no | no\nIPv6PrivacyExtensions= | 時間と共に変化するステートレステンポラリアドレスの使用を設定します(RFC 4941 を参照)。prefer-public を指定すると、プライバシー拡張が有効に名ありますが、テンポラリアドレスよりもパブリックアドレスを優先します。kernel を指定すると、カーネルのデフォルトの設定のままになります。 | 真偽値、prefer-public、kernel | false\n\n"
    },
    {
      "title": "[Address]",
      "level": 4,
      "content": "Table content:\nパラメータ | 説明 | 受け入れる値 | デフォルト値\nAddress= | 複数のアドレスを設定するには、このキーを複数回指定してください。DHCP を使用しない限り必須です。指定されたアドレスが(IPv4の 場合) 0.0.0.0 または (IPv6 の場合) :: である場合、要求されたサイズの新しいアドレス範囲が、システム全体の未使用範囲のプールから自動的に割り当てられます。 | 固定 IPv4 または IPv6 アドレスとプレフィックス長(inet_pton(3) を参照) | \n\n"
    },
    {
      "title": "[Route]",
      "level": 4,
      "content": "- Gateway= DHCP を使用しない場合、このオプションは必須です。\n- Destination= ルートの宛先プリフィックスです。スラッシュとプリフィックス長を後ろに付けることができます。\n- Metrics= このルートの優先順位\n- Type= ルートの種類\n- Table= ルートのテーブル識別子\n- GatewayOnLink= yes に設定すると、カーネルは現在のマシンがゲートウェイに直接到達可能か (つまりローカルネットワークに接続されているか) を確認する必要がなくなります。一部のルーティング問題の解決に使用できます。\n\n[Route] セクションに Destination が存在しない場合、デフォルトルートとして扱われます。\n\n"
    },
    {
      "title": "[RoutingPolicyRule]",
      "level": 4,
      "content": "通常のルーティングアルゴリズムは、パケットをどのゲートウェイに送信するかを選択する際に通常、宛先アドレスのみを考慮します。しかし、より複雑なネットワークではそれだけでは不十分です。\n\n[RoutingPolicyRule] セクションでは、指定された条件に一致するパケットにのみ適用される追加ルールを定義できます。\n\n以下はこれらの条件の非網羅的な一覧です:\n\n- TypeOfService= パケットのサービス種別 (0から255の範囲の整数);\n- From= ソースアドレスのプレフィックス;\n- To= 宛先アドレスのプレフィックス;\n- FirewallMark= iptables ファイアウォールのマーク値;\n- IncomingInterface= 受信デバイス;\n- OutgoingInterface= 送信デバイス;\n\nその他のオプション:\n\n- Type= ルーティングポリシーデータベースルールの種類;\n- Table= パケットがルールに一致した場合に使用するルーティングテーブル;\n- Priority= ルールの優先順位。ルールは優先順位の昇順で評価されるため、低い優先順位のルールが先に適用されます;\n- InvertRule= true に設定するとルールが反転し、条件を1つも満たさないパケットに適用されます;\n- SuppressPrefixLength= プレフィックス長が指定された値以下の場合、そのルールは抑制されます;\n\n"
    },
    {
      "title": "[DHCPv4]",
      "level": 4,
      "content": "Table content:\nパラメータ | 説明 | 受け入れる値 | デフォルト値\nUseDNS= | DHCP サーバにより広告された DNS サーバを使用するかどうかを制御。 | 真偽値 | true\nAnonymize= | true を指定すると、DHCP サーバに送られるオプションが RFC:7844 (Anonymity Profiles for DHCP Clients) に従って、識別情報の開示を最小限にするようになります。 | 真偽値 | false\nUseDomains= | DHCP サーバから受け取るドメイン名を DNS 検索ドメインとして使用するかどうかを制御。route に設定すると、DHCP サーバから受け取るドメイン名が DNS クエリにのみ使用され、検索には使用されなくなります。このオプションは、systemd-resolved を使用している際にはローカルな名前解決を修正する可能性があります。 | 真偽値、route | false\nIPv6OnlyMode= | true に設定すると、DHCP クライアントは DHCP サーバーに対し、IPv6 のみの動作をサポートしていることを通知します(RFC:8925、DHCPv4 の IPv6-Only Preferred オプション)。DHCPv4 サーバーがそのオプションを DHCP 応答で返した場合、クライアントは DHCP 要求を中止し、IPv4 アドレスを取得せず、IPv6 のみのネットワークを設定します。」 | 真偽値 | true IPv6が有効になっている場合\n\n"
    },
    {
      "title": "[DHCPServer]",
      "level": 4,
      "content": "これは、無線ホットスポットを作成するために hostapd とうまく連動する DHCP サーバーの設定例です。IPMasquerade は NATを有効にする ためのファイアウォールルールを追加し、IPForward=ipv4 パケット転送 を有効にしています。\n\nTable content:\nこの記事またはセクションの正確性には問題があります。 理由: IPMasquerade=trueはfilter テーブルのルールを追加しません、それらは手動で追加する必要があります。systemd-nspawn#仮想イーサネットリンクを使用する を参照してください (議論: トーク:Systemd-networkd#)\n\n​\n\n```\n/etc/systemd/network/wlan0.network\n```\n\n```\n[Match]\nName=wlan0\n\n[Network]\nAddress=10.1.1.1/24\nDHCPServer=true\nIPMasquerade=ipv4\n\n[DHCPServer]\nPoolOffset=100\nPoolSize=20\nEmitDNS=yes\nDNS=9.9.9.9\n```\n\n"
    },
    {
      "title": "netdev ファイル",
      "level": 3,
      "content": "Table content:\nこのセクションは削除するべきか検討が行われています。 Reason: Duplicates the systemd.netdev(5) man page. (議論: トーク:Systemd-networkd#)\n\nnetdev ファイル群は仮想ネットワークデバイスを作成します。これらのファイルには次のセクションを記述できます: [Match] と [NetDev]。以下ではそれぞれのセクションでよく使われる設定キーを説明します。詳細や例は systemd.netdev(5) を見てください。\n\n"
    },
    {
      "title": "[Match] セクション",
      "level": 4,
      "content": "- Host= ホストネーム\n- Virtualization= VM の中で実行されているかどうか確認する。\n\n"
    },
    {
      "title": "[NetDev] セクション",
      "level": 4,
      "content": "- Name= インターフェイス名。必須\n- Kind= 例: bridge, bond, vlan, veth, sit。必須\n\n"
    },
    {
      "title": "コンテナでの使用方法",
      "level": 2,
      "content": "systemd-networkd は、コンテナ内とホストシステムの両方で使用されている場合、systemd-nspawn コンテナに対するネットワークの完全自動設定を提供できます。総合的な外観は systemd-nspawn#ネットワーキング を見てください。\n\n下で説明している設定について、\n\n- $ ip a コマンドの出力を、関連するインターフェイスにだけ絞っています。\n- ホストは起動しているメインの OS であり、コンテナは仮想マシンのゲストのことです。\n- インターフェイスの名前や IP アドレスは全てあくまでただの例です。\n\n"
    },
    {
      "title": "ブリッジインターフェイス",
      "level": 4,
      "content": "まず、仮想ブリッジインターフェイスを作成してください。systemd に、イーサネットブリッジとして機能する、br0 という名前のデバイスを作成するように指示します。\n\n```\n/etc/systemd/network/mybridge.netdev\n```\n\n```\n[NetDev]\nName=br0\nKind=bridge\n```\n\nオプションとして、ブリッジがブリッジ接続されたインターフェースのいずれかから MAC アドレスを継承するようにするため、NetDev セクションに MACAddress=none を追加します。これには 25-br0.link ファイルの作成も必要です。\n\nsystemd-networkd.service を再起動すると systemd はブリッジを作成します。\n\n新しく追加したブリッジを見るには、ホストとコンテナ上で以下を実行してください:\n\n```\n$ ip a\n```\n\n```\n3: br0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default\n    link/ether ae:bd:35:ea:0c:c9 brd ff:ff:ff:ff:ff:ff\n```\n\nインターフェイス br0 が表示されていますが、この段階ではまだ DOWN になっていることに注意してください。\n\n"
    },
    {
      "title": "イーサネットをブリッジに関連付ける",
      "level": 4,
      "content": "次のステップでは、新しく作成したブリッジにネットワークインターフェイスを追加します。以下の例では、en* という名前にマッチする任意のインターフェイスをブリッジ br0 に追加します。\n\n```\n/etc/systemd/network/bind.network\n```\n\n```\n[Match]\nName=en*\n\n[Network]\nBridge=br0\n```\n\nEthernet インターフェースには DHCP や IP アドレスを割り当ててはいけません。ブリッジは IP アドレスがないインターフェースにバインドする必要があるためです。\n\n"
    },
    {
      "title": "ブリッジネットワーク",
      "level": 4,
      "content": "ブリッジが作成され、既存のネットワークインターフェイスに関連付けられました。ブリッジインターフェイスの IP 設定を指定する必要があります。これは3番目の .network で定義されます。以下の例では DHCP を使用します。\n\n```\n/etc/systemd/network/mybridge.network\n```\n\n```\n[Match]\nName=br0\n\n[Network]\nDHCP=ipv4\n```\n\n"
    },
    {
      "title": "MAC アドレスを継承する(オプション)",
      "level": 4,
      "content": "ブリッジ型インターフェイスの1つから MAC アドレスを吸入するブリッジの場合、macAddress=none および macaddresspolicy=none を設定します。\n\n```\n/etc/systemd/network/25-br0.netdev\n```\n\n```\n[NetDev]\nName=br0\nKind=bridge\nMACAddress=none\n```\n\n```\n/etc/systemd/network/25-br0.link\n```\n\n```\n[Match]\nOriginalName=br0\n\n[Link]\nMACAddressPolicy=none\n```\n\n"
    },
    {
      "title": "コンテナの設定",
      "level": 4,
      "content": "コンテナを起動する際は --network-bridge=br0 オプションを使用してください。詳細は systemd-nspawn#ネットワークブリッジを使用する を見てください。\n\n"
    },
    {
      "title": "結果",
      "level": 4,
      "content": "- ホスト側\n\n```\n$ ip a\n```\n\n```\n3: br0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default\n    link/ether 14:da:e9:b5:7a:88 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.87/24 brd 192.168.1.255 scope global br0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::16da:e9ff:feb5:7a88/64 scope link\n       valid_lft forever preferred_lft forever\n6: vb-MyContainer: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master br0 state UP group default qlen 1000\n    link/ether d2:7c:97:97:37:25 brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::d07c:97ff:fe97:3725/64 scope link\n       valid_lft forever preferred_lft forever\n```\n\n- コンテナ側\n\n```\n$ ip a\n```\n\n```\n2: host0: <BROADCAST,MULTICAST,ALLMULTI,AUTOMEDIA,NOTRAILERS,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 5e:96:85:83:a8:5d brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.73/24 brd 192.168.1.255 scope global host0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::5c96:85ff:fe83:a85d/64 scope link\n       valid_lft forever preferred_lft forever\n```\n\n"
    },
    {
      "title": "注意",
      "level": 4,
      "content": "- ホストの br0 と、コンテナの host0 にそれぞれ IP アドレスが割り当てられました。\n- 2つの新しいインターフェイスが作成されます: ホストの vb-MyContainer とコンテナの host0 です。これは --network-bridge=br0 オプションによるものです。詳細は systemd-nspawn#ネットワークブリッジを使用する を参照してください。\n- host0 の DHCP アドレスはシステムの /usr/lib/systemd/network/80-container-host0.network ファイルから由来します。\n- ホスト側\n\nTable content:\nこの記事またはセクションは情報が古くなっています。 理由: brctl は非推奨です。bridge link を使用してください。ネットワークブリッジ#iproute2 を使う を参照。 (Discuss)\n\n```\n$ brctl show\n```\n\n```\nbridge name\tbridge id\t\tSTP enabled\tinterfaces\nbr0\t\t8000.14dae9b57a88\tno\t\tenp7s0\n\t\t\t\t\t\t\tvb-MyContainer\n```\n\n上記のコマンドの出力で2つのインターフェイスがバインドされたブリッジが確認できます。\n\n- ホスト側\n\n```\n$ ip route\n```\n\n```\ndefault via 192.168.1.254 dev br0\n192.168.1.0/24 dev br0  proto kernel  scope link  src 192.168.1.87\n```\n\n- コンテナ側\n\n```\n$ ip route\n```\n\n```\ndefault via 192.168.1.254 dev host0\n192.168.1.0/24 dev host0  proto kernel  scope link  src 192.168.1.73\n```\n\n上記のコマンドの出力で IP アドレスとゲートウェイが 192.168.1.254 の br0 と host0 インターフェイスが有効になったのが確認できます。ゲートウェイのアドレスは systemd-networkd によって自動的に取得されます。\n\n```\n$ cat /run/systemd/resolve/resolv.conf\n```\n\n```\nnameserver 192.168.1.254\n```\n\n"
    },
    {
      "title": "静的 IP アドレスを持つネットワークブリッジ",
      "level": 3,
      "content": "各デバイスに静的 IP アドレスを設定すると、Web サービス (例:FTP、http、SSH) を展開する場合に便利です。システム /usr/lib/systemd/network/99-default.link ファイルに MACAddressPolicy=persistent オプションが指定されている場合(デフォルトで指定されています)、各デバイスは再起動後も同じMACアドレスを保持します。したがって、ゲートウェイ上の任意のサービスを目的のデバイスに簡単にルーティングできます。\n\nこのセットアップでは、次の設定を行う必要があります。\n\n- ホスト側\n\nこの設定は、#DHCP を用いたネットワークブリッジ セクションと非常によく似ています。まず、仮想ブリッジインターフェイスを作成し、メインの物理インターフェイスをそのインターフェイスにバインドする必要があります。この作業は、次の2つのファイルを使用して実行できます。これらのファイルの内容は、 DHCP セクションで使用できるものと同じです。\n\n```\n/etc/systemd/network/MyBridge.netdev\n/etc/systemd/network/MyEth.network\n```\n\n次に、新しく作成した仮想ブリッジインターフェイスの IP および DNS を設定する必要があります。例:\n\n```\n/etc/systemd/network/MyBridge.network\n```\n\n```\n[Match]\nName=br0\n\n[Network]\nDNS=192.168.1.254\nAddress=192.168.1.87/24\nGateway=192.168.1.254\n```\n\n- コンテナ側\n\nコンテナに静的 IP アドレスを設定するには、システム /usr/lib/systemd/network/80-container-host0.network ファイルを上書きする必要があります。このファイルは、コンテナの host0 ネットワークインタフェースに DHCP 構成を提供します。これを行うには、設定を /etc/systemd/network/80-container-host0.network に置きます。例:\n\n```\n/etc/systemd/network/80-container-host0.network\n```\n\n```\n[Match]\nName=host0\n\n[Network]\nDNS=192.168.1.254\nAddress=192.168.1.94/24\nGateway=192.168.1.254\n```\n\nコンテナで systemd-networkd.service が有効化されていることを確認してください。\n\n"
    },
    {
      "title": "MACVLAN bridge",
      "level": 3,
      "content": "ホストが MacVlan を介して接続されたコンテナに到達できるためには、ホスト自体が MacVLan を介して接続する必要があり、基礎となるイーサネットネットワークインターフェイスに直接接続する必要があります。\n\nホスト上で、基盤となる Ethernet ネットワークインターフェースを MACVLAN に接続し、IP アドレスが割り当てられないようにします。例えば、MACVLAN インターフェース名として mv-0 を使用し、ホストの Ethernet インターフェースとして enp1s0 を使用する場合:\n\n```\n/etc/systemd/network/30-enp1s0.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Link]\nRequiredForOnline=carrier\n\n[Network]\nMACVLAN=mv-0\nDHCP=no\nIPv6AcceptRA=false\nLinkLocalAddressing=no\nMulticastDNS=false\nLLMNR=false\n```\n\n- RequiredForOnline=carrier は、接続が IP アドレスを取得するのを待つ(最終的に失敗する)ことを防ぎますが、このプロセスは絶対に起こりません。\n- 基盤となるネットワークインターフェースは必ずしも物理的な Ethernet インターフェースである必要はありません。例えば、MACVLAN ブリッジはボンドに接続することができます。\n\nMacvlan Bridge を作成 MV-0:\n\n```\n/etc/systemd/network/25-mv-0.netdev\n```\n\n```\n[NetDev]\nName=mv-0\nKind=macvlan\n\n[MACVLAN]\nMode=bridge\n```\n\nMacVlan ブリッジでホストのネットワーク接続を設定します(mv-0)次の例では、DHCP を使用して、必要に応じてオプションを置き換えます。\n\n```\n/etc/systemd/network/35-mv-0.network\n```\n\n```\n[Match]\nName=mv-0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nBindCarrier=enp1s0\nDHCP=yes\n```\n\nコンテナには、基盤となる Ethernet ネットワークインターフェース (上記の例では enp1s0) に MACVLAN を接続します。例えば、/etc/systemd/nspawn/container_name.nspawn で次のように指定します:\n\n```\n[Network]\nMACVLAN=enp1s0\n```\n\nコマンドラインから開始されたコンテナの場合、-network-macvlan = enp1s0 オプションを渡します。\n\nコンテナ内では、MACVLAN インターフェースの名前は mv-underlying_interface_name になります(例:mv-enp1s0)インターフェース名に一致させて、ネットワーク接続を必要に応じて設定します(ホストと同様に)例えば、DHCP を使用する場合:\n\n```\n/etc/systemd/network/30-mv-enp1s0.network\n```\n\n```\n[Match]\nName=mv-enp1s0\n\n[Link]\nRequiredForOnline=routable\n\n[Network]\nDHCP=yes\n```\n\n"
    },
    {
      "title": "管理やデスクトップの統合",
      "level": 3,
      "content": "systemd-networkd にはコマンドラインシェルや GUI による適切なインタラクティブ管理インターフェイスがありません。\n\nただし、ネットワークの現在の状態を表示したり、通知を受信したり、ワイヤレス構成を操作したりするためのツールはあります:\n\n- networkctl は(CLI を通して)ネットワークインターフェイスの状態の簡単な表示を行います。\n- networkd で wpa_supplicant を使うように設定した場合、wpa_cli や wpa_gui を使うことで動的に WLAN インターフェイスを関連付けしたり再設定できます。\n- networkd-notify-gitAUR はネットワークインターフェイスの状態の変化にあわせてシンプルな通知を生成します (接続・切断や再関連付けなど)。\n- networkd-dispatcherAUR デーモンを使うことで NetworkManager-dispatcher と同じようにネットワークインターフェイスの状態が変わったときにスクリプトを実行することができます。\n- DNS リゾルバの systemd-resolved は resolvectl status で現在の DNS サーバーの情報を視覚化できます。\n\n"
    },
    {
      "title": "SSID (場所) に基づいた静的 IP または DHCP の設定",
      "level": 3,
      "content": "ホームワイヤレスネットワークが DHCP を使用し、オフィスワイヤレスネットワークが静的 IP を使用する状況がよくあります。この混在したセットアップは、次のように構成できます:\n\n```\n/etc/systemd/network/24-wireless-office.network\n```\n\n```\n# special configuration for office WiFi network\n[Match]\nName=wlp2s0\nSSID=office_ap_name\n#BSSID=aa:bb:cc:dd:ee:ff\n\n[Network]\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.1\n#DNS=8.8.8.8\n```\n\n```\n/etc/systemd/network/25-wireless-dhcp.network\n```\n\n```\n# use DHCP for any other WiFi network\n[Match]\nName=wlp2s0\n\n[Network]\nDHCP=ipv4\n```\n\n"
    },
    {
      "title": "ワイヤード (有線) インターフェイスとワイヤレスインターフェイスのボンディング",
      "level": 3,
      "content": "ワイヤレスボンディング も参照してください。\n\nボンディングを使用すると、複数のインターフェイスを介して接続を共有できるため、有線インターフェイスを取り外しても、ワイヤレス接続は維持され、ネットワーク接続はシームレスに維持されます。\n\n結合インタフェースを作成します。この場合、モードは active-backup です。つまり、プライマリインターフェイスがダウンした場合、パケットはセカンダリインターフェイスを介してルーティングされます。\n\n```\n/etc/systemd/network/30-bond0.netdev\n```\n\n```\n[NetDev]\nName=bond0\nKind=bond\n\n[Bond]\nMode=active-backup\nPrimaryReselectPolicy=always\nMIIMonitorSec=1s\n```\n\n有線インターフェイスをプライマリとして設定します。\n\n```\n/etc/systemd/network/30-ethernet-bond0.network\n```\n\n```\n[Match]\nName=enp0s25\n\n[Network]\nBond=bond0\nPrimarySlave=true\n```\n\nワイヤレスをセカンダリとして設定します。\n\n```\n/etc/systemd/network/30-wifi-bond0.network\n```\n\n```\n[Match]\nName=wlan0\n\n[Network]\nBond=bond0\n```\n\n通常のインターフェイスと同様に、bond インターフェイスを設定します。\n\n```\n/etc/systemd/network/30-bond0.network\n```\n\n```\n[Match]\nName=bond0\n\n[Network]\nDHCP=ipv4\n```\n\n有線ネットワークが接続されていない場合は、ワイヤレス接続が維持されます。\n\n```\n$ networkctl\n```\n\n```\nIDX LINK    TYPE     OPERATIONAL      SETUP\n  1 lo      loopback carrier          unmanaged\n  2 enp0s25 ether    no-carrier       configured\n  3 bond0   bond     degraded-carrier configured\n  5 wlan0   wlan     enslaved         configured\n\n4 links listed.\n```\n\n"
    },
    {
      "title": "TCP スロースタートの速度を上げる",
      "level": 3,
      "content": "遅延が中程度の広帯域リンク (通常、10 Mbit/s を超えるホームインターネット接続) では、TCP スロースタートアルゴリズムのデフォルト設定はやや保守的です。この問題は、ダウンロードがゆっくりと開始され、接続の全帯域幅に到達するまでに加速するのに数秒かかる場合に発生します。特に pacman アップグレードなどで、ダウンロードされた各パッケージがゆっくりと開始し、接続の最大速度に達する前に終了することがよくあります。\n\nこれらの設定を調整して、 TCP 接続が既定よりも大きなウィンドウサイズで開始されるようにすることができます。これにより 新しい TCP 接続ごとに自動的に増加する時間を避けることができます [1] これは通常、損失した多数のパケットを再送信する必要があるため、低速な接続ではパフォーマンスを低下させますが (または値が大きくなりすぎた場合) 、十分な帯域幅を持つ接続ではパフォーマンスを大幅に向上させることができます。\n\nこれらの値を変更する前と変更した後にベンチマークを実行して、ネットワーク速度を向上させ、低下させないようにすることが重要です。ダウンロードの開始が遅く、速度が徐々に上がっていない場合は、これらの値を変更する必要はありません。これらの値はすでに接続速度に最適です。ベンチマークを行う際には、低速なサーバへのアクセスをさらに低速にすることを犠牲にして高速なマシンへのアクセスを高速化しないように、高速なリモートサーバと低速なリモートサーバの両方に対してテストするようにしてください。\n\nこれらの値を調整するには、接続の .network ファイルを編集します。\n\n```\n/etc/systemd/network/eth0.network\n```\n\n```\n[Match]\nName=eth0\n\n#[Network]\n#Gateway=...  <-- Remove this if you have it, and put it in the Gateway= line below\n\n[Route]\n# This will apply to the gateway supplied via DHCP.  If you manually specify\n# your gateway, put it here instead.\nGateway=_dhcp4\n\n# The defaults for these values is 10.  They are a multiple of the MSS (1460 bytes).\nInitialCongestionWindow=10\nInitialAdvertisedReceiveWindow=10\n```\n\nデフォルトの 10 は、 10Mbit/s より遅い接続に適しています。100 Mbit/s 接続の場合、値 30 位が適切に機能します。マニュアル・ページ systemd.network(5) § [ROUTE] SECTION OPTIONS には、100 の値は過剰と見なされると記載されています。\n\nsysctl 設定 net.ipv4.tcp_slow_start_after_idle が有効になっている場合、しばらくアイドル状態が続くと (多くの場合、ごく短時間) 、接続はこれらの初期設定に戻ります。この設定を無効にすると、パケット転送中に大きいウィンドウがネゴシエートされた場合、接続は大きいウィンドウを維持します。設定に関係なく、新しい各 TCP 接続は上記の Initial* 設定で始まります。\n\nsysctl 設定 net.ipv4.tcp_congestion_control は、 TCP リンクがアクティブなとき、特に2つのホスト間のパスが輻輳してスループットを低下させる必要があるときに、輻輳ウィンドウと受信ウィンドウを調整する方法を制御するため、これらの値とは直接関係しません。上記の Initial* 値は、輻輳アルゴリズムに引き継がれて必要に応じて調整される前に、新しい接続ごとに選択されたデフォルトのウィンドウ値を設定するだけです。高い初期値を設定すると、輻輳アルゴリズムが最適な値 (または、逆に、間違った初期値を設定するとネゴシエーション時間が長くなりますが、輻輳アルゴリズムはそれらを修正するように動作し、新しく確立された各 TCP 接続の速度が数秒間遅くなります。) を見つけようとしている間に、単純にネゴシエーションが短縮されます。\n\n"
    },
    {
      "title": "既存のインターフェースに独自の MAC アドレスを持つ2番目の静的 IP を設定する",
      "level": 3,
      "content": "ルーターに対してコンピュータを完全に異なる2台のデバイスとして認識させるには、異なる IP アドレスだけでなく、異なる MAC アドレスを持つ仮想インターフェースを作成する必要があります。\n\nこれを実現するために、物理インターフェースの上に一意の MAC アドレスを持つ仮想インターフェース(macvlan)を作成します。例えば、次のように作成します:\n\n```\n/etc/systemd/network/25-eth210.netdev\n```\n\n```\n[NetDev]\nName=eth210\nKind=macvlan\nMACAddress=00:11:22:33:44:55\n\n[MACVLAN]\nMode=bridge\nSourceDevice=enp1s0\n```\n\n次に、同じサブネットとゲートウェイを使用して、通常通りネットワークファイルを追加し、静的 IP を設定する場合は DHCP に使用される IP 番号の範囲を回避します。例えば:\n\n```\n/etc/systemd/network/25-eth210.network\n```\n\n```\n[Match]\nName=eth210\n\n[Network]\nAddress=192.168.132.210/24\nGateway=192.168.132.1\n\n[Route]\nDestination=192.168.132.0/24\nMetric=2\n```\n\nmacvlan インターフェースのルートにはメトリック2が設定されています。これにより、トラフィックはメインインターフェースを優先して通過するようになります。なぜなら、メインインターフェースにはデフォルトルートがメトリック1で(暗黙的に)設定されているからです。ただし、特に macvlan インターフェースを使用するよう指示した場合は別です。\n\n最後に、MACVLAN=eth210 をメインインターフェースの .network ファイルの [Network] セクションに追加します!\n\nこの時点で、新しい MAC アドレスをルーターに認識させ、その MAC アドレスを受け入れるように設定するための簡単な方法として、例えば sudo arping -I eth210 192.168.132.1 を実行できます。ルーターで \"新しいデバイス\" の設定をした後、例えば curl --interface 192.168.132.210 ifconfig.me を実行して、新しいインターフェースがインターネットに接続できるかどうかをテストできます。このコマンドは、あなたの公開 IP アドレスを表示するはずです。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- systemd-networkd(8)\n- Tom Gundersen posts on Core OS blog\n- How to set up systemd-networkd with wpa_supplicant (WonderWoofy's walkthrough on Arch forums)\n\n"
    }
  ]
}