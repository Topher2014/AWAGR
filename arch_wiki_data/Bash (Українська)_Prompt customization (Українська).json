{
  "title": "Bash (Українська)/Prompt customization (Українська)",
  "url": "https://wiki.archlinux.org/title/Bash_(%D0%A3%D0%BA%D1%80%D0%B0%D1%97%D0%BD%D1%81%D1%8C%D0%BA%D0%B0)/Prompt_customization_(%D0%A3%D0%BA%D1%80%D0%B0%D1%97%D0%BD%D1%81%D1%8C%D0%BA%D0%B0)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Повʼязані статті\n\n- Bash (Українська)\n- Змінні середовища\n- Git#Git prompt\n\nУ Bash існує кілька запрошень командного рядка, кожне з яких можна налаштувати на основі особистих уявлень про зручність та естетичність.\n\n"
    },
    {
      "title": "Запрошення",
      "level": 2,
      "content": "Bash має чотири рядки запрошення, кожен з яких може бути налаштований.\n\n- PS1 - головне запрошення, яке з'являється перед кожною командою; з цієї причини вона змінюється найчастіше.\n- PS2 - Друге запрошення відображається, якщо команда вимагає введення додаткових даних (наприклад, у випадку багаторядкових команд).\n- PS3 використовується рідко. З'являється, коли виконується вбудована команда Bash select, і відображається інтерактивне меню. На відміну від інших запрошень, не розкриває. Зазвичай всі зміни застосовуються безпосередньо до скрипту, що містить select, а не до файлу . bashrc.\n- PS4 - також рідко використовується. При налагодженні скриптів відображаються рівні вкладеності - перший символ запрошення повторюється стільки разів, скільки в даний час є активних рівнів.\n\nВстановлення конкретного запрошення передбачає призначення (зазвичай у файлі ~/.bashrc) потрібного рядка змінній, наприклад:\n\n```\nPS2='> '\n```\n\n"
    },
    {
      "title": "Техніки",
      "level": 2,
      "content": "Завжди можна зробити запрошення явним, але є ряд прийомів, які роблять його більш динамічним і корисним.\n\n"
    },
    {
      "title": "Escape-послідовносі Bash",
      "level": 3,
      "content": "Коли рядок запрошення виводиться, Bash шукає символи втечі (послідовності втечі) і перетворює їх у спеціальні рядки. Наприклад, \\u перетвориться в ім'я користувача, а \\A - в поточний час.Таким чином, якщо змінній PS1 призначити '\\A \\u $ ', то запрошення буде виглядати так : 17:35 користувач $\n\nВесь список escape-послідовностей можна знайти в керівництві bash(1) § PROMPTING та довіднику Bash.\n\n"
    },
    {
      "title": "Escape-послідовності terminfo",
      "level": 3,
      "content": "Крім escape-послідовностей, які розуміє Bash, більшість терміналів також розпізнають спеціальні послідовності, які впливають на термінал сам собою, а не на друковані символи. Наприклад, можна змінити колір рядка символів, зрушити курсор у довільну позицію або очистити екран. Ці послідовності можуть бути досить незручними та варіюються від терміналу до терміналу, тому вони задокументовані у базі даних terminfo. Щоб побачити, які властивості підтримує термінал, виконайте:\n\n```\n$ infocmp\n```\n\nЗначення властивостей можна знайти в terminfo(5) за назвами (частина перед =). Наприклад, властивість setaf налаштовує колір шрифту для тексту, який буде надрукований після нього. Дізнатися про escape-код властивості можна командою tput. Наприклад,\n\n```\n$ tput setaf 2\n```\n\nвиведе escape-послідовність для налаштування зеленого кольору шрифту.\n\nНа практиці, щоб використовувати ці можливості у запрошенні командного рядка, можна використовувати підстановку команд Bash та інтерполяцію рядків. Наприклад:\n\n```\nGREEN=\"\\[$(tput setaf 2)\\]\"\nRESET=\"\\[$(tput sgr0)\\]\"\n\nPS1=\"${GREEN}my prompt${RESET}> \"\n```\n\n"
    },
    {
      "title": "Escape-послідовності ANSI",
      "level": 3,
      "content": "На жаль, ANSI-послідовності можуть бути відсутні в базі terminfo вашого терміналу. Найчастіше це стосується послідовностей для нових можливостей на кшталт підтримки 256 кольорів. У цьому випадку використовувати tput не вийде і доведеться вводити escape-послідовність вручну.\n\nПриклади escape-послідовностей можна знайти у статті Керувальні послідовності ANSI.Кожна послідовність починається з літералу escape-послідовності, яку можна ввести за допомогою escape-послідовності Bash \\e. Наприклад, \\e[48;5;209m задасть персиковий колір фону (якщо є підтримка 256 кольорів), а \\e[2;2H зрушить курсор у лівий верхній кут екрана.\n\nЯкщо escape-послідовності Bash не підтримуються (як у запрошенні PS3), їх можна додати командою printf:\n\n```\nESC = $ (printf \"e\")\nPEACH=\"$ESC[48;5;209m\"\n```\n\n"
    },
    {
      "title": "Вбудовані команди",
      "level": 3,
      "content": "Якщо ви хочете додати висновок якоїсь команди на запрошення, то використовуйте підстановку команд (command substitution). Наприклад, щоб додати величину вільної пам'яті до запрошення, спробуйте щось на зразок:\n\n```\nPS1=\"$(awk '/MemFree/{print $2}' /proc/meminfo) prompt > \"\n```\n\n```\n53718 prompt >\n53718 prompt >\n53718 prompt >\n```\n\nЯк бачимо, це працює не зовсім коректно - значення пам'яті завжди одне й те саме! Причина — команда виконується лише один раз при першому налаштуванні PS1. Необхідно запобігти підстановці або екрануванням символу $, або визначенням рядка в одиночних лапках — в обох випадках підстановка буде проводитися щоразу при відображенні запрошення:\n\n```\nPS1=\"\\$(awk '/MemFree/{print \\$2}' /proc/meminfo) prompt > \"\n# или\nPS1='$(awk \"/MemFree/{print \\$2}\" /proc/meminfo) prompt > '\n```\n\nЯкщо команди зробили запрошення надто довгим, для кращої читабельності можна винести їх у функцію:\n\n```\nfree_mem()\n{\n    awk '/MemFree/{print $2}' /proc/meminfo\n}\n\nPS1='$(free_mem) prompt > '\n```\n\nNote: **не** \n\n"
    },
    {
      "title": "PROMPT_COMMAND",
      "level": 3,
      "content": "Змінною PROMPT_COMMAND можна надати довільну команду, яка буде виконуватися безпосередньо перед виведенням PS1. Це дозволяє створювати досить сильні ефекти. Наприклад, можна перепризначити PS1 на основі деяких умов або виконати якісь дії з історією Bash під час виконання будь-якої команди.\n\n"
    },
    {
      "title": "Escape-послідовності між введенням та виведенням",
      "level": 3,
      "content": "Властивості тексту можна змінити, \"забувши\" відключити властивості в кінці PS1. Наприклад, якщо вставити tput blink в кінець PS1, то команди, що вводяться, мерехтіть. Проте цей ефект також перейде і на виведення команди, оскільки властивості не відключаються при натисканні Enter.\n\nЩоб вставити escape-послідовність після введення, але перед початком виведення можна перехопити (trap) Bash-сигнал DEBUG, який посилається перед виконанням кожної команди:\n\n```\n$ trap 'tput sgr0' DEBUG\n```\n\n"
    },
    {
      "title": "Налаштування запрошення root",
      "level": 3,
      "content": "Для зручності можна зробити запрошення командного рядка root-користувача візуально відмінним від звичайного (можливо мерехтливий червоний колір?). Налаштування запрошення здійснюється як завжди, але в домашньому каталозі суперкористувача /root. Почніть з копіювання шаблонів /etc/skel/.bash_profile та /etc/skel/.bashrc до каталогу /root, після чого внесіть у файл /root/.bashrc необхідні зміни.\n\n"
    },
    {
      "title": "Кольори",
      "level": 3,
      "content": "Побачити всі кольори вашого терміналу можна за допомогою простого циклу (замініть setab на setaf, якщо потрібен колір тексту, а не тла):\n\n```\nfor C in {0..255}; do\n    tput setab $C\n    echo -n \"$C \"\ndone\ntput sgr0\necho\n```\n\nЯкщо це не працює (причому встановлено правильне значення TERM), протестуйте вручну різні послідовності:\n\n```\n# стандартні кольори\nfor C in {40..47}; do\n    echo -en \"\\e[${C}m$C \"\ndone\n# кольори високої інтенсивності\nfor C in {100..107}; do\n    echo -en \"\\e[${C}m$C \"\ndone\n# 256 кольорів\nfor C in {16..255}; do\n    echo -en \"\\e[48;5;${C}m$C \"\ndone\necho -e \"\\e(B\\e[m\"\n```\n\nАналогічні значення для тексту (не фону): стандартні - 30..37, висока інтенсивність - 90..97, а для 256 кольорів замініть 48 на 38.\n\n"
    },
    {
      "title": "Основні властивості",
      "level": 3,
      "content": "Наступні властивості terminfo будуть корисні при налаштуванні запрошення та підтримуються у багатьох терміналах. #1 і #2 необхідно замінити на числові аргументи.\n\nTable content:\nВластивість | Escape-послідовність | Опис\nВластивості тексту\nblink | \\E[5m | мерехтливий тект вкл\nbold | \\E[1m | напівжирний текст вкл\ndim | \\E[2m | тьмяний текст вкл\nrev | \\E[7m | зворотне відображення вкл (текст/фон змінюються кольорами)\nsitm | \\E[3m | курсив вкл\nritm | \\E[23m | курсив викл\nsmso | \\E[7m | виділення тексту вкл\nrmso | \\E[27m | виділення тексту викл\nsmul | \\E[4m | підкреслення вкл\nrmul | \\E[24m | підкреслення викл\nsetab #1 | \\E[4#1m | встановити колір фону #1 (0-7)\nsetaf #1 | \\E[3#1m | задати колір тексту #1 (0-7)\nsgr0 | \\E(B\\E[m | відключити всі атрибути тексту\nПереміщення курсору\nsc | \\E7 | зберегти позицію курсору\nrc | \\E8 | повернути курсор у збережену позицію\nclear | \\E[H\\E[2J | очистити екран і перемістити курсор у лівий верхній кут\ncuu #1 | \\E[#1A | перемістити курсор вгору на #1 рядків\ncud #1 | \\E[#1B | перемістити курсор вниз #1 рядків\ncuf #1 | \\E[#1C | перемістити курсор вправо #1 стовпців\ncub #1 | \\E[#1D | перемістити курсор вліво #1 стовпців\nhome | \\E[H | перемістити курсор у лівий верхній кут вікна\nhpa #1 | \\E[#1G | перемістити курсор у стовпець #1\nvpa #1 | \\E[#1d | перемістити курсор у рядок #1, перший стовпець\ncup #1 #2 | \\E[#1;#2H | перемістити курсор у рядок #1, стовпець #2\nВидалення символів\ndch #1 | \\E#1P | видалити #1 символів (аналогічно натисканню клавіші backspace)\ndl #1 | \\E#1M | видалити #1 рядків\nech #1 | \\E#1X | стерти #1 символів (без переміщення курсору)\ned | \\E[J | очистити до нижнього краю екрану\nel | \\E[K | очистити до кінця рядка\nel1 | \\E[1K | очистити до початку рядка\n\n"
    },
    {
      "title": "Відображення коду виходу",
      "level": 3,
      "content": "Тим же прийомом, як у вбудованих команд, можна відкласти інтерполяцію спеціальної змінної Bash на кшталт $?. Наступні запрошення матимуть код виходу попередньої команди:\n\n```\nPS1=\"\\$? > \"\n# или\nPS1='$? > '\n```\n\nЦе можна зробити за допомогою умовних виразів та функцій:\n\n```\nexitstatus()\n{\n    if [[ $? == 0 ]]; then\n        echo ':)'\n    else\n        echo 'D:'\n    fi\n}\nPS1='$(exitstatus) > '\n```\n\n"
    },
    {
      "title": "Позиціонування курсору",
      "level": 3,
      "content": "Курсор можна переміщати по екрану під час знаходження \"всередині\" запрошення PS1, щоб різні частини запрошення з'являлися у різних місцях. Важливий момент – після всіх переміщень та виведення символів у будь-яких місцях екрана курсор необхідно повернути у вихідну позицію. Це можна зробити за допомогою властивостей sc та rc, які зберігають та відновлюють позицію курсору відповідно. Загальна схема запрошення, що містить переміщення курсору:\n\n```\nPS1=\"\\[$(tput sc; переміщення курсора) робота з курсором $(tput rc)\\] робота з курсором після повернення\"\n```\n\nВесь блок з переміщеннями курсору обернутий в \\[ \\], щоб Bash не враховував символи, що не друкуються, як частина запрошення.\n\n"
    },
    {
      "title": "Вирівнювання по правому краю",
      "level": 4,
      "content": "Найпростіший спосіб надрукувати текст у правого краю екрана – використовувати printf:\n\n```\nrightprompt()\n{\n printf \"%*s\" $COLUMNS \"right prompt\"\n}\n\nPS1='\\[$(tput sc; rightprompt; tput rc)\\]left prompt > '\n```\n\nТут встановлено поле %*s змінної довжини з вирівнюванням по правому краю. Розмір поля дорівнює поточній кількості стовпців у терміналі ($COLUMNS).\n\n"
    },
    {
      "title": "Довільне позиціонування",
      "level": 4,
      "content": "Властивість cup переміщує курсор у конкретну позицію екрану, наприклад tput cup 20 5 перемістить курсор на рядок 20, стовпець 5 (координати 0 0 позначають верхній лівий кут). cuu, cud, cuf і cub (вгору, вниз, вперед, назад) переміщують курсор щодо поточної позиції. Наприклад, tput cuf 10 перемістить курсор на 10 символів праворуч. В аргументах можна використовувати змінні LINES та COLUMNS, якщо потрібно перемістити курсор щодо нижнього та правого країв вікна. Наприклад, переміщення на 10 рядків та 5 стовпців від правого нижнього кута:\n\n```\n$ tput cup $((LINES - 11)) $((COLUMNS - 6))\n```\n\n"
    },
    {
      "title": "Налаштування назви вікна терміналу",
      "level": 3,
      "content": "Назву вікна терміналу можна налаштувати так само, як і запрошення: виведенням escape-послідовностей в оболонці. Часто користувачі вбудовують налаштування назви вікна у своє запрошення. Технічно це можливість xterm, а й інші сучасні термінали її підтримують. У цьому випадку використовують послідовності ESC]2;нова назва'BEL, де ESC і 'BEL - символи escape (вихід) і bell (сигнал). З послідовностями Bash запрошення з вбудованою назвою вікна буде мати вигляд:\n\n```\nPS1='\\[\\e]2;нова назва\\a\\]prompt > '\n```\n\nЗрозуміло, що рядок назви вікна може включати висновок вбудованих команд або змінні на кшталт $PWD, так що вона може переналаштовуватися після кожної команди.\n\n"
    },
    {
      "title": "Дивіться також",
      "level": 2,
      "content": "- Приклади та скріншоти на темі форуму: What's your PS1?\n- Файл /etc/bash/bashrc для Gentoo; див. також gentoo-bashrcAUR\n- tput(1) Кольори та переміщення курсору з tput\n- Запрошення Bash HOWTO\n- Колекція прикладів запрошень від Giles Orr\n- Поради Bash: кольори та форматування\n- Liquid Prompt – корисне адаптивне запрошення для Bash & zsh\n- Bash POWER PROMPT\n- Wikipedia - Керувальна послідовність\n- Керівництво GNU Bash: керування запрошенням\n\n- Кольори та переміщення курсору з tput\n\n"
    }
  ]
}