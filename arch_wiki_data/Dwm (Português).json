{
  "title": "Dwm (Português)",
  "url": "https://wiki.archlinux.org/title/Dwm_(Portugu%C3%AAs)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- dmenu\n- Gerenciador de janelas\n\nO dwm é um gerenciador de janelas dinâmico para o Xorg. Ele gerencia janelas em layouts (formato de ordenação) lado a lado, empilhado e em tela cheia, além de muitos outros com a ajuda de patches opcionais. Os layouts podem ser aplicados dinamicamente, otimizando o ambiente para o aplicativo em uso e a tarefa que está sendo executada. O dwm é extremamente leve e rápido, escrito em C e com um objetivo de projeto declarado de permanecer com menos de 2000 linhas de código-fonte. Fornece suporte a múltiplos monitores para xrandr e Xinerama.\n\n"
    },
    {
      "title": "Instalação",
      "level": 2,
      "content": "O dwm pode ser instalado com o pacote dwmAUR ou dwm-gitAUR. Faça a #Configuração antes de compilar e instalar, veja makepkg.\n\n"
    },
    {
      "title": "Configuração",
      "level": 3,
      "content": "O dwm é configurado em tempo de compilação ao editar alguns de seus arquivos fonte, especificamente config.h. Para obter informações detalhadas sobre essas configurações, consulte as instruções bem comentadas e incluídas, config.def.h assim como a seção de personalização no site do dwm.\n\nO site oficial possui vários patches que podem adicionar funcionalidades extras ao dwm. Esses patches fazem principalmente alterações no arquivo dwm.c, mas também fazem alterações no arquivo config.h quando necessário. Para obter informações sobre a aplicação de patches, consulte o artigo Aplicação de patch em pacotes.\n\n"
    },
    {
      "title": "Iniciando",
      "level": 2,
      "content": "Selecione Dwm no gerenciador de exibição de sua escolha. Como alternativa, para iniciar o dwm com startx adicione exec dwm ao ~/.xinitrc e o preceda com outros programas, para executá-los também, por exemplo:\n\n```\nredshift -O3500; xset r rate 300 50; exec dwm\n```\n\n"
    },
    {
      "title": "Uso",
      "level": 2,
      "content": "Veja o tutorial do dwm (inglês) para obter informações sobre o uso básico do dwm.\n\n"
    },
    {
      "title": "Configuração da barra de status",
      "level": 3,
      "content": "Para mais exemplos de barras de status, veja [1].\n\nO dwm lê o nome da janela raiz e o redireciona para a barra de status. A janela raiz é a janela na qual todas as outras janelas são desenhadas e organizadas pelo gerenciador de janelas. Como qualquer outra janela, a janela raiz tem um título/nome, mas geralmente é indefinida porque a janela raiz sempre é executada em segundo plano.\n\nAs informações que você deseja que o dwm mostre na barra de status devem ser definidas com o comando xsetroot -name \"\" no ~/.xinitrc ou ~/.xprofile (se você estiver usando um gerenciador de exibição). Por exemplo:\n\n```\nxsetroot -name \"Obrigado por todo o peixe!\"\n```\n\nAs informações atualizadas dinamicamente devem ser colocadas em um loop que é executado em segundo plano - veja o exemplo abaixo:\n\n```\n# Statusbar loop\nwhile true; do\n   xsetroot -name \"$( date +\"%F %R\" )\"\n   sleep 1m    # Atualiza a cada minuto\ndone &\n\n# Autostart section\npcmanfm &\n\nexec dwm\n```\n\nNesse caso, a data é mostrada no formato ISO 8601 e o PCManFM é iniciado na inicialização.\n\n"
    },
    {
      "title": "Conky na barra de status",
      "level": 4,
      "content": "O Conky pode ser impresso na barra de status com xsetroot -name:\n\n```\n(conky | while read LINE; do xsetroot -name \"$LINE\"; done) &\nexec dwm\n```\n\nSe você não quiser gerar muitos PIDs pelo comando 'xsetroot', pode compilar este programa em C:\n\n```\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <X11/Xlib.h>\n\nint main(int argc, char * argv[])\n{\n        Display * dpy = NULL;\n        Display * dpy = NULL;\n        size_t length = 0;\n        ssize_t bytes_read = 0;\n        char * input = NULL;\n\n        dpy = XOpenDisplay(getenv(\"DISPLAY\"));\n        if (dpy == NULL)\n        {\n                fprintf(stderr, \"Can't open display, exiting.\\n\");\n                exit(1);\n        }\n        win = DefaultRootWindow(dpy);\n\n        while ((bytes_read = getline(&input, &length, stdin)) != EOF)\n        {\n                input[strlen(input) - 1] = '\\0';\n                XStoreName(dpy, win, input);\n                XFlush(dpy);\n                fprintf(stderr, \"Input: %s\", input);\n                fprintf(stderr, \"\\nbytes read: %ld\\n\", bytes_read);\n        }\n        free(input);\n        return 0;\n}\n```\n\nSalve este código no arquivo dwm-setstatus.c e compile:\n\n```\n$ gcc dwm-setstatus.c -lX11 -o dwm-setstatus\n```\n\nmova 'dwm-setstatus' dentro do seu $PATH (/usr/local/bin, por exemplo)\n\n```\n# mv dwm-setstatus /usr/local/bin\n```\n\ne executa:\n\n```\n$ conky | dwm-setstatus\n```\n\nPara fazer isso, o conky precisa ser instruído a enviar texto apenas para o console. A seguir, é apresentado um exemplo da conkyrc para um processador com dois núcleos, exibindo várias estatísticas de uso:\n\n```\nconky.config = {\nout_to_console = true,\nout_to_x = false,\nbackground = false,\nupdate_interval = 2,\ntotal_run_times = 0,\nuse_spacer = 'none',\n};\nconky.text = [[\n$mpd_smart :: ${cpu cpu1}% / ${cpu cpu2}%  ${loadavg 1} ${loadavg 2 3} :: ${acpitemp}c :: $memperc% ($mem) :: ${downspeed eth0}K/s ${upspeed eth0}K/s :: ${time %a %b %d %I:%M%P}\n]];\n```\n\nPara ícones e opções de cores, veja dzen.\n\n"
    },
    {
      "title": "Reinicie o dwm",
      "level": 3,
      "content": "Para reiniciar o dwm sem sair ou fechar aplicativos, altere ou adicione um script de inicialização para carregar o dwm em um loop while, por exemplo:\n\n```\nwhile true; do\n    # Log do stderror para um arquivo\n    dwm 2> ~/.dwm.log\n    # sem log de erro\n    #dwm >/dev/null 2>&1\ndone\n```\n\nO dwm agora pode ser reinicializado sem destruir outras janelas X pressionando a combinação habitual Mod-Shift-Q.\n\nÉ uma boa ideia colocar o script de inicialização acima em um arquivo separado por exemplo ~/bin/startdwm, e executá-lo pelo ~/.xinitrc. A partir deste momento, quando você desejar finalizar a sessão X, basta executar killall xinit, ou vincule-o a um atalho conveniente. Como alternativa, você pode configurar seu script de sessão do dwm para que ele reinicie o dwm apenas se o binário mudar. Isso pode ser útil no caso em que você modificar uma configuração ou atualizar a base de código do dwm.\n\n```\n# execute o DWM se o binário mudar, senão saia\ncsum=$(sha1sum $(which dwm))\nnova_csum=\"\"\nwhile true\ndo\n    if [ \"$csum\" != \"$nova_csum\" ]\n    then\n        csum=$nova_csum\n        dwm\n    else\n        exit 0\n    fi\n    nova_csum=$(sha1sum $(which dwm))\n    sleep 0.5\ndone\n```\n\n"
    },
    {
      "title": "Conecte a tecla Alt direita com Mod4",
      "level": 3,
      "content": "Ao usar o Mod4 (a tecla Super/Windows) como o MODKEY, pode ser igualmente conveniente ter a tecla Alt direita (Alt_R) agindo como Mod4. Isso permitirá que você pressione teclas, de outra maneira incômodas com uma mão, como zooming com Alt_R+Enter.\n\nPrimeiro, descubra qual keycode (código da tecla) está atribuído à Alt_R:\n\n```\nxmodmap -pke | grep Alt_R\n```\n\nEm seguida, basta adicionar o seguinte ao script de inicialização (por exemplo, ~/.xinitrc), alterando o keycode 113 se necessário, para o resultado obtido pelo o comando xmodmap anterior:\n\n```\nxmodmap -e \"keycode 113 = Super_L\"  # reatribui Alt_R para Super_L\nxmodmap -e \"remove mod1 = Super_L\"  # garanta que o X mantém a tecla fora do grupo mod1\n```\n\nDepois disso, todas as funções que são acionadas pela tecla Super_L também serão acionadas por Alt_R.\n\n"
    },
    {
      "title": "Espaço ao redor da fonte na barra do dwm",
      "level": 3,
      "content": "Por padrão, a barra do dwm adiciona 2px ao redor do tamanho da fonte. Para mudar isto, modifique a seguinte linha em dwm.c:\n\n```\nbh = dc.h = dc.font.height + 2;\n```\n\n"
    },
    {
      "title": "Desativar o foco seguindo o mouse",
      "level": 3,
      "content": "Para desativar o foco que segue o comportamento do mouse, comente a seguinte linha na definição do manipulador de estruturas em dwm.c\n\n```\n[EnterNotify] = enternotify,\n```\n\nObserve que essa alteração pode causar algumas dificuldades; o primeiro clique em uma janela inativa trará apenas o foco para ela. Para interagir com o conteúdo da janela (botões, campos etc.), você precisa clicar novamente. Além disso, se você tiver alguns monitores, poderá observar que o foco do teclado não muda para outro monitor focado ao clicar.\n\n"
    },
    {
      "title": "Layout flutuante para algumas janelas",
      "level": 3,
      "content": "Para algumas janelas, como as caixas de diálogo de preferências, não faz sentido que essas janelas sejam lado a lado - elas devem flutuar livremente. Por exemplo, para fazer a caixa de diálogo de preferências do Firefox flutuar, adicione o seguinte à sua matriz de regras em config.h:\n\n```\n{ \"Firefox\",     NULL,       \"Firefox Preferences\",        1 << 8,         True,     -1 },\n```\n\n"
    },
    {
      "title": "Usando Tilda com dwm",
      "level": 3,
      "content": "dwm pode gerenciar a localização das janelas automaticamente, então é necessário configurar para que o Tilda funcione adequadamente.\n\nVocê tem que editar o config.h do dwm:\n\n```\nstatic const Rule rules[] = {\n\t/* class      instance    title       tags mask     isfloating   monitor */\n\t{ \"Gimp\",     NULL,       NULL,       0,            True,        -1 },\n\t{ \"Firefox\",  NULL,       NULL,       1 << 8,       False,       -1 },\n//add the line below\n\t{ \"Tilda\",  NULL,       NULL,       0,       True,       -1 },\n\t{ \"Volumeicon\",  NULL,       NULL,       0,       True,       -1 },\n};\n```\n\nIsto acima faz com que todas as janelas com a WM_CLASS \"Tilda\" estejam no modo flutuante.\n\nExecute o tilda com a opção -C:\n\n```\n$ tilda -C\n```\n\nAgora você pode configurar o Tilda, as opções a seguir são recomendadas:\n\n```\nFont: Clean 9\nFont: Clean 9\nAppearance: Height: 50%, Width: 70%, Centered Horizontally\nExtras: Enable Transparency Level 15\nAnimated Pulldown: 1500 usec, Orientation: Top\nColors: Built-in Scheme \"Green on Black\"\nScrolling: Scrollbar is on the left, 2000 lines scrollback\nKey Binding: F9\n```\n\nAbaixo é como a configuração vai ficar parecida depois dessas configurações na ~/.config/tilda/config_0:\n\n```\ntilda_config_version = \"0.9.6\"\n# image = \"\"\n# command = \"\"\nfont = \"Clean 9\"\nkey = \"F9\"\ntitle = \"Tilda\"\nbackground_color = \"white\"\n# working_dir = \"\"\nweb_browser = \"firefox\"\nlines = 2000\nmax_width = 956\nmax_height = 384\nmin_width = 1\nmin_height = 1\ntransparency = 15\nx_pos = 205\ny_pos = 1\ntab_pos = 0\nbackspace_key = 0\ndelete_key = 1\nd_set_title = 3\ncommand_exit = 2\nscheme = 1\nslide_sleep_usec = 1500\nanimation_orientation = 0\nscrollbar_pos = 0\nback_red = 0\nback_green = 0\nback_blue = 0\ntext_red = 0\ntext_green = 65535\ntext_blue = 0\nscroll_background = true\nscroll_on_output = false\nnotebook_border = false\nantialias = true\nscrollbar = false\nuse_image = false\ngrab_focus = true\nabove = true\nnotaskbar = true\nbold = true\nblinks = true\nscroll_on_key = true\nbell = false\nrun_command = false\npinned = true\nanimation = true\nhidden = true\ncentered_horizontally = true\ncentered_vertically = false\nenable_transparency = true\ndouble_buffer = false\n```\n\nÉ importante que você habilite pulldown-animation, de outro modo Tilda vai continuamente pular toda vez que for exibida, provavelmente um problema do dwm.\n\n"
    },
    {
      "title": "Corrigindo aplicativos Java com comportamento inadequado",
      "level": 3,
      "content": "Tente definir export _JAVA_AWT_WM_NONREPARENTING=1. Veja também a página do Java.\n\n"
    },
    {
      "title": "Corrigindo lacunas nas janelas dos terminais",
      "level": 3,
      "content": "Se houver gaps vazios no espaço da área de trabalho fora das janelas dos terminais, provavelmente isso se deve ao tamanho da fonte dos terminais. Ajuste o tamanho até encontrar a escala ideal que fecha os gaps ou alterne resizehints para 0 em config.h.\n\nIsso fará com que o dwm ignore as solicitações de redimensionamento de todas as janelas cliente, não apenas dos terminais. A desvantagem dessa solução alternativa é que alguns terminais podem sofrer anomalias de redesenho, como linhas fantasmas e quebra de linha prematura, entre outros.\n\nComo alternativa, se você usar o emulador de terminal st, poderá aplicar o patch anysize e recompilar o st.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- Site oficial do dwm\n- Introdução ao dwm\n- dmenu - Iniciador de aplicativos simples dos desenvolvedores do dwm\n- A discussão do dwm nos fóruns\n- Hacking dwm thread\n- Confira as discussões de wallpaper nos fóruns para uma seleção de papéis de parede dwm\n- Mostre sua configuração do dwm na discussão do fórum\n\n"
    }
  ]
}