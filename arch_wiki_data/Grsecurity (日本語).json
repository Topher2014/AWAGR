{
  "title": "Grsecurity (日本語)",
  "url": "https://wiki.archlinux.org/title/Grsecurity_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- PAM\n- ケイパビリティ\n- アプリケーション一覧/セキュリティ\n- カテゴリ:セキュリティ\n\nこの記事には、Arch Linux システムをハードニングするための推奨事項とベストプラクティスを並べています。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 概念\n- 2 パスワード 2.1 安全なパスワードの選び方 2.2 パスワードの管理 2.3 パスワードのハッシュ 2.4 pam_cracklib を用いた強力なパスワードの強制\n- 3 CPU 3.1 マイクロコード 3.2 ハードウェアの脆弱性 3.2.1 同時マルチスレッディング (ハイパースレッディング)\n- 4 メモリ 4.1 ハード化された malloc\n- 5 ストレージ 5.1 ディスク暗号化 5.2 ファイルシステム 5.2.1 マウントオプション 5.2.2 スナップショット 5.3 ファイルシステムのパーミッション 5.4 SUID ファイルと SGID ファイル\n- 6 ユーザー設定 6.1 root アカウントを日常的に使用しない 6.2 ログイン失敗後の遅延時間の設定 6.3 3回ログインを失敗したユーザーをロックアウトする 6.4 プロセスの数を制限する 6.5 Wayland を使用する\n- 7 root の制限 7.1 su の代わりに sudo を使う 7.1.1 sudo を使ってファイルを編集する 7.2 root ログインの制限 7.2.1 特定のユーザーだけに許可を与える 7.2.2 ssh ログインを拒否する 7.2.3 access.conf で許容されるログインの組み合わせを指定する\n- 8 強制アクセス制御 8.1 パス名 MAC 8.2 ラベル MAC 8.3 アクセス制御リスト\n- 9 カーネルの堅牢化 9.1 カーネルの自己防衛機能/脆弱性攻撃対策 9.1.1 ユーザー空間 ASLR の比較 9.1.1.1 64 ビットプロセス 9.1.1.2 32 ビットプロセス (x86_64 カーネル上) 9.2 proc ファイルシステム内のカーネルポインタへのアクセスを制限する 9.3 BPF の堅牢化 9.4 ptrace スコープ 9.5 hidepid 9.6 モジュールのロードを制限する 9.7 kexec を無効にする 9.8 カーネルロックダウンモード 9.9 Linux Kernel Runtime Guard (LKRG)\n- 10 アプリケーションのサンドボックス化 10.1 Firejail 10.2 bubblewrap 10.3 chroot 10.4 Linux Containers 10.5 完全な仮想化オプション\n- 11 ネットワークとファイアウォール 11.1 ファイアウォール 11.1.1 ポートを開く 11.2 カーネルパラメータ 11.3 SSH 11.4 DNS 11.5 プロキシ 11.6 SSL 証明書の管理\n- 12 物理セキュリティ 12.1 BIOS をロックダウンする 12.2 ブートローダー 12.2.1 Syslinux 12.2.2 GRUB 12.2.3 systemd-boot 12.3 セキュアブート 12.4 トラステッドプラットフォームモジュール(TPM) 12.5 リムーバブル フラッシュ ドライブ上のブートパーティション 12.6 自動ログアウト 12.7 不正なUSBデバイスから保護する 12.8 揮発性データの収集\n- 13 パッケージ 13.1 パッケージの認証 13.2 アップグレード 13.3 脆弱性アラートの確認 13.4 パッケージの再ビルド\n- 14 参照\n\n- 2.1 安全なパスワードの選び方\n- 2.2 パスワードの管理\n- 2.3 パスワードのハッシュ\n- 2.4 pam_cracklib を用いた強力なパスワードの強制\n\n- 3.1 マイクロコード\n- 3.2 ハードウェアの脆弱性 3.2.1 同時マルチスレッディング (ハイパースレッディング)\n\n- 3.2.1 同時マルチスレッディング (ハイパースレッディング)\n\n- 4.1 ハード化された malloc\n\n- 5.1 ディスク暗号化\n- 5.2 ファイルシステム 5.2.1 マウントオプション 5.2.2 スナップショット\n- 5.3 ファイルシステムのパーミッション\n- 5.4 SUID ファイルと SGID ファイル\n\n- 5.2.1 マウントオプション\n- 5.2.2 スナップショット\n\n- 6.1 root アカウントを日常的に使用しない\n- 6.2 ログイン失敗後の遅延時間の設定\n- 6.3 3回ログインを失敗したユーザーをロックアウトする\n- 6.4 プロセスの数を制限する\n- 6.5 Wayland を使用する\n\n- 7.1 su の代わりに sudo を使う 7.1.1 sudo を使ってファイルを編集する\n- 7.2 root ログインの制限 7.2.1 特定のユーザーだけに許可を与える 7.2.2 ssh ログインを拒否する 7.2.3 access.conf で許容されるログインの組み合わせを指定する\n\n- 7.1.1 sudo を使ってファイルを編集する\n\n- 7.2.1 特定のユーザーだけに許可を与える\n- 7.2.2 ssh ログインを拒否する\n- 7.2.3 access.conf で許容されるログインの組み合わせを指定する\n\n- 8.1 パス名 MAC\n- 8.2 ラベル MAC\n- 8.3 アクセス制御リスト\n\n- 9.1 カーネルの自己防衛機能/脆弱性攻撃対策 9.1.1 ユーザー空間 ASLR の比較 9.1.1.1 64 ビットプロセス 9.1.1.2 32 ビットプロセス (x86_64 カーネル上)\n- 9.2 proc ファイルシステム内のカーネルポインタへのアクセスを制限する\n- 9.3 BPF の堅牢化\n- 9.4 ptrace スコープ\n- 9.5 hidepid\n- 9.6 モジュールのロードを制限する\n- 9.7 kexec を無効にする\n- 9.8 カーネルロックダウンモード\n- 9.9 Linux Kernel Runtime Guard (LKRG)\n\n- 9.1.1 ユーザー空間 ASLR の比較 9.1.1.1 64 ビットプロセス 9.1.1.2 32 ビットプロセス (x86_64 カーネル上)\n\n- 9.1.1.1 64 ビットプロセス\n- 9.1.1.2 32 ビットプロセス (x86_64 カーネル上)\n\n- 10.1 Firejail\n- 10.2 bubblewrap\n- 10.3 chroot\n- 10.4 Linux Containers\n- 10.5 完全な仮想化オプション\n\n- 11.1 ファイアウォール 11.1.1 ポートを開く\n- 11.2 カーネルパラメータ\n- 11.3 SSH\n- 11.4 DNS\n- 11.5 プロキシ\n- 11.6 SSL 証明書の管理\n\n- 11.1.1 ポートを開く\n\n- 12.1 BIOS をロックダウンする\n- 12.2 ブートローダー 12.2.1 Syslinux 12.2.2 GRUB 12.2.3 systemd-boot\n- 12.3 セキュアブート\n- 12.4 トラステッドプラットフォームモジュール(TPM)\n- 12.5 リムーバブル フラッシュ ドライブ上のブートパーティション\n- 12.6 自動ログアウト\n- 12.7 不正なUSBデバイスから保護する\n- 12.8 揮発性データの収集\n\n- 12.2.1 Syslinux\n- 12.2.2 GRUB\n- 12.2.3 systemd-boot\n\n- 13.1 パッケージの認証\n- 13.2 アップグレード\n- 13.3 脆弱性アラートの確認\n- 13.4 パッケージの再ビルド\n\n"
    },
    {
      "title": "概念",
      "level": 2,
      "content": "- システムのセキュリティを厳重にしすぎると、使い物にならなくなることもある。セキュリティと利便性のバランスを取ることが重要だ。重要なのは、安全で かつ 使いやすいシステムを作ること。\n- 最大の脅威は常にユーザー自身である。\n- 最小権限の原則: システムの各部分は、必要最小限の権限のみを持つべきであり、それ以上のアクセスは許可されるべきではない。\n- 多層防御 (Defense in Depth): セキュリティは独立した複数の層で成り立つべきである。一つの層が突破されても、次の層が攻撃を食い止める仕組みが必要です。\n- 少しだけ疑い深くなること。常に警戒すること。うますぎる話には注意すべきだ。それが本当である可能性は低いと思うこと。\n- システムを100%安全にする方法はただ一つ。それはネットワークから切り離し、電源を切り、金庫に入れ、コンクリートで固め、二度と使用しないこと。\n- 失敗を想定せよ。セキュリティが破られたときに備え、あらかじめ対応策を準備しておくこと。\n\n"
    },
    {
      "title": "パスワード",
      "level": 2,
      "content": "パスワードは安全な linux システムのかぎです。パスワードはユーザーアカウント, 暗号化されたファイルシステム, SSH/GPG 鍵などを守ります。コンピュータを使用する人を信頼するのに使う主要な手段なので、安全なパスワードを選んでそれを保護するというのがセキュリティの大部分と言っても過言ではありません。\n\n"
    },
    {
      "title": "安全なパスワードの選び方",
      "level": 3,
      "content": "パスワードは、個人情報などから簡単に推測されないよう十分に複雑であり、また、ソーシャルエンジニアリングやブルートフォース攻撃などの手法でクラックされないようにする必要があります。強力なパスワードの基本原則は、長さとランダム性に基づいています。暗号学では、パスワードの品質はそのエントロピーによって測られます。\n\n安全でないパスワードには、以下のようなものが含まれます。また、以下のようなものを元に変更や置き換えを行った場合も同様に危険です。\n\n- 個人を特定できる情報(例:ペットの名前、生年月日、市外局番、好きなビデオゲームなど)\n- 単純な文字の置き換えを行った単語(例:k1araj0hns0n)最新の辞書攻撃ではこれらも簡単に解析可能\n- 既存の \"単語\" や一般的な文字列の前後に数字・記号・文字を追加したもの(例:DG091101%)\n- 一般的なフレーズや辞書にある単語を短く組み合わせたもの(例:photocopyhauntbranchexpose)文字の置き換えを行っても(例:Ph0toc0pyh4uN7br@nch3xp*se)、安全とは限らない(ただし、後述の \"Diceware\" を利用した場合は例外あり)\n- 最も一般的なパスワードのいずれか\n\n最も安全なパスワードは、十分に長く(長いほど良い)ランダムなソースから生成されたものです。長いパスワードを使用することが重要です。弱いハッシュアルゴリズムを使用すると、8文字のパスワードハッシュはわずか数時間で解読可能 です。\n\npwgen や apgAUR のようなツールを使用すると、ランダムなパスワードを生成できます。しかし、これらのパスワードは覚えにくいことがあります。覚えやすくするための1つの方法は、長いパスワードを生成し、最初は最低限の安全な文字数だけを暗記し、完全な文字列を一時的に書き留めることです。時間をかけて入力する文字数を増やしていけば、最終的にはパスワードが筋肉の記憶として定着し、完全に覚える必要がなくなります。この方法は難易度が高いものの、辞書攻撃や \"知的\" ブルートフォース攻撃(単語の組み合わせや文字の置き換えを考慮する攻撃)に対して非常に強力です。\n\nパスワード管理とは別に、keepassxc はパスワード/パスフレーズの生成機能を提供します。GUI でカスタマイズ可能なパスワード生成機能があり、辞書ベースのパスフレーズもサポートされています。\n\nパスワードを覚えるための1つの方法として、**記憶術(ニーモニック)**を利用することが挙げられます。 例えば、\"the girl is walking down the rainy street\" というフレーズは、以下のようなパスワードに変換できます。簡単な例:t6!WdtR5 より複雑な例:t&6!RrlW@dtR,57 この方法は、パスワードを覚えやすくすることができますが、英単語の最初の文字には偏りがあることに注意が必要です(Wikipedia:Letter frequency を参照)\n\nまた、ランダムに生成したパスワードを紙に書いて安全な場所に保管するという方法も有効です。例えば、財布、カバン、金庫などに保管するのがよいでしょう。ほとんどの人は、デジタルセキュリティよりも物理的な貴重品の保護に関しては理解しやすいため、この方法は現実的です。\n\nさらに、記憶術とランダム生成を組み合わせる方法も効果的です。例えば、長くランダムに生成したパスワードをパスワードマネージャに保存し、それをマスターパスワードで管理する方法です。マスターパスワードは記憶し、絶対に保存しないようにします。この方法では、パスワードマネージャーがインストールされているシステムでのみパスワードにアクセスできるようになり、状況によっては不便にもなりますが、セキュリティ強化の側面もあります。一部のパスワードマネージャーにはスマートフォンアプリもあり、手入力が必要な場合にパスワードを表示することができます(この場合、完全にランダムなものではなく、タイピングしやすいが安全なパスワードを使うことも検討できます)ただし、マスターパスワードを忘れるとすべてのパスワードにアクセスできなくなるため、単一障害点になり得ることに注意が必要です。 また、一部のパスワードマネージャーは、保存するパスワードを暗号化するのではなく、マスターパスワードとサービス名から計算する方式を採用しており、新しいシステムでもデータ同期なしで使用できます。\n\n覚えやすく、それでいて強力なパスワードの作成方法として、無関係な単語を複数組み合わせたパスフレーズを使うという方法もあります。この方法では、十分に長いフレーズを使用することで、辞書単語を使うことによるエントロピーの損失を補うことができます。この手法のエントロピーのトレードオフについては、xkcdのコミック に示されています。この方法の安全性は、選択可能な単語の集合が大きい(数千語以上)ことと、5〜7語以上のランダムな単語を選択することによって保証されます。攻撃者が選択可能な単語の集合と、使用する単語数を知っていたとしても、(選択可能な単語数) の (選択する単語数) 乗の通りのパスフレーズが生成可能であり、安全性が確保されます。詳細については Diceware を参照してください。\n\nさらに詳しい情報については、The passphrase FAQ や Wikipedia:Password strength も参考になります。\n\n"
    },
    {
      "title": "パスワードの管理",
      "level": 3,
      "content": "強力なパスワードを選んだら、それを安全に保管することが重要です。キーロガー (ソフトウェアおよびハードウェア)、スクリーンロガー、ソーシャルエンジニアリング、ショルダースーフィングに注意し、パスワードの使い回しを避けて、セキュリティの低いサーバーから不要な情報が漏れないようにしましょう。パスワードマネージャを使用すると、大量の複雑なパスワードを管理できます。パスワードマネージャーからアプリケーションに保存されたパスワードをコピー&ペーストして使用する場合は、毎回コピーした内容をクリアし、ログに保存されないようにしてください(例:プレーンテキストのターミナルコマンドにペーストしないようにし、.bash_history などのファイルに保存されないようにします)ブラウザ拡張として実装されたパスワードマネージャは、サイドチャネル攻撃に脆弱である可能性があります。これを回避するためには、別のアプリケーションとして実行されるパスワードマネージャーを使用することが推奨されます。\n\n原則として、強力なパスワードを覚えにくいからといって、セキュリティが低いパスワードを選んではいけません。パスワードはバランスを取る必要があります。強力なマスターパスワードと鍵で守られた暗号化された安全なパスワードデータベースを持つ方が、多くの似たような弱いパスワードを使うよりも優れています。パスワードを紙に書いて保管することも、[1] で示されているように、ソフトウェアの脆弱性を避けつつ物理的なセキュリティを確保できるため、非常に効果的です。\n\nパスフレーズの強度のもう一つの側面は、それが他の場所から簡単に回復できないことです。\n\nディスク暗号化のパスフレーズをログインパスワードと同じに使用する場合(例えば、ログイン時に暗号化されたパーティションやフォルダを自動マウントする場合)、/etc/shadow が暗号化されたパーティションに保存されるか、または強力な鍵導出関数 (i.e. yescrypt/argon2 や sha512 を PBKDF2 で使用、md5 や低回数の PBKDF2 は避ける) を使用して保存されたパスワードハッシュを使うようにしてください (詳細については SHA パスワードハッシュ を参照してください)\n\nパスワードデータベースをバックアップする場合、そのコピーが他のパスフレーズで保護されていないことを確認してください。例えば、暗号化されたドライブや認証されたリモートストレージサービスなどです。もしそのような保護が施されている場合、必要なときにアクセスできなくなります。役立つ方法としては、データベースがバックアップされているドライブやアカウントをマスターパスワードの簡単な暗号学的ハッシュで保護することです。バックアップ場所のリストを保持してください。もしもマスターパスワードが漏洩したと疑われる場合、その場所すべてでパスワードを即座に変更し、マスターパスワードから導出された鍵で保護されたすべてのバックアップと場所も変更する必要があります。\n\nデータベースをセキュアにバージョン管理するのは非常に複雑な場合があります。もしその方法を選択するなら、すべてのデータベースバージョンでマスターパスワードを更新する手段を持っている必要があります。マスターパスワードが漏洩したときにそれを即座に知るのは難しいことがあります。他の人がパスワードを発見するリスクを減らすために、定期的にパスワードを変更することを選ぶかもしれません。もしデータベースのコピーの管理が失われたと感じた場合、そのコピーがブルートフォース攻撃によってマスターパスワードを解読される前に、そのデータベース内のすべてのパスワードを変更する必要があります。\n\n"
    },
    {
      "title": "パスワードのハッシュ",
      "level": 3,
      "content": "ハッシュは一方向の関数です。つまり、入力を計算せずにそのハッシュを解読することは不可能になるように設計されています (例:MD5、SHA)\n\nパスワードハッシュ関数は、ユーザー入力 (パスワード) を計算せずに解読することが不可能になるように設計されています(例:bcrypt)鍵導出関数 (KDF; 例:yescrypt、scrypt、PBKDF2) は、入力 (マスターキーやパスワード) から秘密鍵 (例:AESキー、パスワードハッシュ) を導出するために設計された暗号アルゴリズムです。したがって、KDF はパスワードハッシュ関数としても使用できる複数の用途に対応します。\n\nデフォルトでは、Arch Linux はユーザーパスワードをルート専用の読み取り可能な /etc/shadow ファイルにハッシュ化して保存します。これは、他のユーザーのパラメータが保存される世界に読み取り可能な /etc/passwd ファイルから分離されています。詳細は ユーザーとグループ#ユーザーデータベース を参照してください。また、#root の制限 も参照してください。\n\nパスワードは passwd コマンドを使用して設定され、このコマンドはシステムの暗号化関数でパスワードをストレッチし、その後 /etc/shadow に保存されます。パスワードはソルトも施され、レインボーテーブル攻撃に対して防御されます。詳細はLinux でパスワードがどのように保存されているか(Shadow ユーティリティを使ったハッシュの理解)を参照してください。\n\nパスワードハッシュは定義されたフォーマットに従って保存されるため、新たな passwd コマンドの実行に対してメソッドとパラメータを設定することができます。したがって、/etc/shadow ファイルに保存された個々のハッシュは、システムでサポートされているハッシュ関数の異種混合になる可能性があります。\n\nフォーマット、ハッシュメソッド、およびパラメータに関する詳細は、crypt(5) を参照してください。\n\n/etc/login.defs ファイルでは、デフォルトのパスワードハッシュメソッドENCRYPT_METHOD YESCRYPT とそのパラメータ YESCRYPT_COST_FACTOR が設定されます。\n\n例えば、デフォルトの YESCRYPT_COST_FACTOR パラメータを増加させると、パスワードからハッシュを導き出すために必要な計算時間が対数的に増加します。これは、システムがユーザーのログインを認証する際や、第三者がパスワードの秘密を取得しようとする場合にも適用されます。\n\nこれに対して、SHA-512 ハッシュ関数の計算時間は、パラメータにより線形的に影響されます。以前の Arch のデフォルトについては SHA パスワードハッシュ を参照してください。yescrypt アルゴリズムは内部で SHA-256、HMAC、およびPBKDF2 を使用してパスワードハッシュを計算することに注意してください。主な理由は、これらの広く使用され、テストされた関数の良い特性を組み合わせ、攻撃への耐性を強化することです。例えば、SHA の多用途性が原因で、この関数のハードウェアサポートが提供され、SHA ハッシュの計算性能が著しく向上したため、パスワードハッシュ関数としての使用が次第に時代遅れになりつつあります。\n\n"
    },
    {
      "title": "pam_cracklib を用いた強力なパスワードの強制",
      "level": 3,
      "content": "pam_pwquality は、辞書攻撃に対する保護を提供し、システム全体で強制できるパスワードポリシーを設定するのに役立ちます。これは pam_cracklib をベースにしており、そのオプションとの後方互換性があります。\n\nlibpwquality パッケージをインストールしてください。\n\n- root アカウントを使用すると、設定したパスワードポリシーをバイパスするユーザーパスワードを設定できます。これは一時的なパスワードを設定する際に便利です。\n- 現在のパスワードに関するセキュリティガイドライン(例:NISTなど)では、特別な文字を強制することは推奨されていません。なぜなら、それらはしばしば予測可能な変更を引き起こすだけだからです。\n\n例えば、以下のポリシーを強制したい場合:\n\n- エラーが発生した場合にパスワードを2回入力する (retry オプション)\n- 最小長10文字 (minlen オプション)\n- 新しいパスワードを入力する際、古いパスワードとは少なくとも6文字異なること (difok オプション)\n- 最低1桁の数字 (dcredit オプション)\n- 最低1つの大文字 (ucredit オプション)\n- 最低1つの小文字 (lcredit オプション)\n- 最低1つのその他の文字 (ocredit オプション)\n- \"myservice\" および \"mydomain\" という単語を含めない\n- root にもこのポリシーを強制する\n\n/etc/pam.d/passwdファイルを以下のように編集します:\n\n```\n#%PAM-1.0\npassword required pam_pwquality.so retry=2 minlen=10 difok=6 dcredit=-1 ucredit=-1 ocredit=-1 lcredit=-1 [badwords=myservice mydomain] enforce_for_root\npassword required pam_unix.so use_authtok sha512 shadow\n```\n\npassword required pam_unix.so use_authtok は、pam_unix モジュールに対してパスワードの入力を促さず、代わりに pam_pwquality で提供されたものを使用するように指示します。\n\n詳細については、pam_pwquality(8) および pam_unix(8) のマニュアルページを参照してください。\n\n"
    },
    {
      "title": "マイクロコード",
      "level": 3,
      "content": "CPU のマイクロコードに対する重要なセキュリティ更新プログラムをインストールする方法については、マイクロコード を参照してください。\n\n"
    },
    {
      "title": "ハードウェアの脆弱性",
      "level": 3,
      "content": "CPU の中には、ハードウェアの脆弱性を含んでいるものがあります。これらの脆弱性の一覧と、特定の使用シナリオに合わせてこれらの脆弱性を緩和するためにカーネルをカスタマイズするのに役立つ緩和策の選択ガイドについては、kernel documentation on hardware vulnerabilities を参照してください。\n\n既知の脆弱性の影響を受けているかどうかを確認するには、以下を実行してください。\n\n```\n$ grep -r . /sys/devices/system/cpu/vulnerabilities/\n```\n\nほとんどの場合、カーネルとマイクロコードを更新することで、脆弱性を軽減することができます。\n\n"
    },
    {
      "title": "同時マルチスレッディング (ハイパースレッディング)",
      "level": 4,
      "content": "同時マルチスレッディング] (SMT) は、インテル CPU のハイパースレッディングとも呼ばれ、L1 Terminal Fault および Microarchitectural Data Sampling 脆弱性の原因となる可能性のあるハードウェア機能です。Linux カーネルとマイクロコードのアップデートには、既知の脆弱性に対する緩和策が含まれていますが、信頼できない仮想化ゲストが存在する場合、特定の CPU で SMT を無効にしたほうが良い場合があります。\n\nSMT は、システムのファームウェアで無効にできることがよくあります。詳細については、マザーボードまたはシステムのドキュメントを参照してください。また、以下の カーネルパラメータ を追加することで、カーネルで SMT を無効にすることができます。\n\n```\nl1tf=full,force mds=full,nosmt mitigations=auto,nosmt nosmt=force\n```\n\n"
    },
    {
      "title": "ハード化された malloc",
      "level": 3,
      "content": "hardened_malloc (hardened_mallocAUR, hardened-malloc-gitAUR) は glibc の malloc() をハード化した代替品です。元々は Android の Bionic と musl に組み込むために開発されましたが、 x86_64 アーキテクチャの標準 Linux ディストリビューションのサポートにも組み込みました。\n\nhardened_malloc はまだ glibc に統合されていませんが(支援とプルリクエストは歓迎します)、LD_PRELOAD と一緒に簡単に使用することができます。これまでのテストでは、 /etc/ld.so.preload でグローバルに有効にすると、 一握りのアプリケーションにしか問題を起こしません。例えば、getrandom が標準のホワイトリストにないため、seccomp 環境フラグが無効でないと man は正常に動作しませんが、これはシステムコールを追加して再構築すれば簡単に修正可能です。hardened_malloc は性能上のコストがあるので、どの実装を使うかは攻撃対象領域と性能上の必要性に基づいてケースバイケースで決めるとよいでしょう。\n\nスタンドアロンで試すには、hardened-malloc-preload ラッパー スクリプトを使用するか、適切なプリロード値でアプリケーションを手動で開始します。\n\n```\nLD_PRELOAD=\"/usr/lib/libhardened_malloc.so\" /usr/bin/firefox\n```\n\nFirejail の正しい使い方は、その wiki ページにあります。また、hardened_malloc の設定可能なビルドオプションは、githubレポで見つけることができます。\n\n"
    },
    {
      "title": "ディスク暗号化",
      "level": 3,
      "content": "ディスク暗号化、特に 強力なパスフレーズ を使用したフルディスク暗号化は、物理的な回復からデータを守る唯一の方法です。これにより、コンピュータの電源がオフになっている場合や、対象のディスクがアンマウントされている場合にデータの機密性が保たれます。\n\nただし、コンピュータの電源が入っており、ドライブがマウントされている場合、そのデータは暗号化されていないドライブと同様に脆弱です。そのため、データパーティションがもう必要なくなったら、できるだけ早くアンマウントすることが最良の実践です。\n\nまた、TPMにキーを保存してドライブを暗号化 することもできますが、過去に 脆弱性 があり、キーは TPMバススニッフィング攻撃 によって抽出される可能性があります。\n\ndm-crypt のような特定のプログラムは、ユーザーが仮想ボリュームとしてループファイルを暗号化できるようにします。これは、システムの特定の部分だけを安全に保護する必要がある場合、フルディスク暗号化の合理的な代替手段です。\n\nディスク暗号化 の記事で比較されているブロックデバイスやファイルシステムベースの暗号化方法は、物理メディア上のデータ保護には有効ですが、リモートシステム(例えば クラウドストレージ)に保存されたデータを保護するためには使用できません。そのため、個々のファイル暗号化が役立つ場合もあります。\n\nファイルを暗号化するためのいくつかの方法は次の通りです:\n\n- 一部の アーカイブおよび圧縮 ツールは基本的な暗号化も提供します。例としては、7-Zip (-p フラグ)、zip (-eフラグ) があります。これらのツールはクロスプラットフォームの互換性のためにカスタムアルゴリズムを使用している場合があるため、特別な注意を払って使用するべきです。[2]\n- GnuPG を使用してファイルを 暗号化 できます。\n- age は、シンプルで使いやすいファイル暗号化ツールです。複数の受信者をサポートしており、SSH キーを使用した暗号化もサポートしているため、安全なファイル共有に役立ちます。\n\n"
    },
    {
      "title": "ファイルシステム",
      "level": 3,
      "content": "現在カーネルは fs.protected_hardlinks や fs.protected_symlinks sysctl スイッチが有効になっていればハードリンクやシンボリックリンクに関するセキュリティの問題を解決するので、world-writable なディレクトリを分離させるセキュリティ的な利点はもはや存在しません。\n\nそれでもディスク容量が消耗したときのダメージを低減させる荒っぽい方法として world-writable なディレクトリを含むパーティションが分割されることがあります。しかしながら、サービスを落とすには /var や /tmp などのパーティションを一杯にするだけで十分です。この問題の対処についてはもっと柔軟性のある方法が存在します (クォータなど)、またファイルシステムによっては関連する機能を持っていることがあります (btrfs はサブボリュームにクォータを設定できます)。\n\n"
    },
    {
      "title": "マウントオプション",
      "level": 4,
      "content": "最小特権の原則に従い、ファイルシステムは可能な限り制限の厳しいマウントオプションを使用してマウントするべきです(機能を失わない範囲で)\n\n関連するマウントオプションは以下の通りです:\n\n- nodev: ファイルシステム上のキャラクタデバイスやブロックデバイスを解釈しない。\n- nosuid: set-user-identifier や set-group-identifier ビットを無効にする。\n- noexec: マウントされたファイルシステム上のバイナリを直接実行できないようにする。 /home に noexec を設定すると、実行可能なスクリプトが禁止され、Wine、Steam、PyCharm、.NET などが動作しなくなります。 Wine は Windows バイナリの実行に exec フラグを必要としません。ただし、Wine 自体を /home にインストールする場合は必要です。 Steam を動作させるには、/home/user/.local/share/Steam を fstab で exec としてマウントできます。以下の設定を追加してください: /home/user/.local/share/Steam /home/user/.local/share/Steam none defaults,bind,user,exec,nofail 0 0 一部のパッケージ(例:nvidia-dkms のビルド)では、/var に exec が必要な場合があります。\n\n- /home に noexec を設定すると、実行可能なスクリプトが禁止され、Wine、Steam、PyCharm、.NET などが動作しなくなります。 Wine は Windows バイナリの実行に exec フラグを必要としません。ただし、Wine 自体を /home にインストールする場合は必要です。 Steam を動作させるには、/home/user/.local/share/Steam を fstab で exec としてマウントできます。以下の設定を追加してください: /home/user/.local/share/Steam /home/user/.local/share/Steam none defaults,bind,user,exec,nofail 0 0\n- 一部のパッケージ(例:nvidia-dkms のビルド)では、/var に exec が必要な場合があります。\n\n- Wine は Windows バイナリの実行に exec フラグを必要としません。ただし、Wine 自体を /home にインストールする場合は必要です。\n- Steam を動作させるには、/home/user/.local/share/Steam を fstab で exec としてマウントできます。以下の設定を追加してください: /home/user/.local/share/Steam /home/user/.local/share/Steam none defaults,bind,user,exec,nofail 0 0\n\n```\n/home/user/.local/share/Steam /home/user/.local/share/Steam none defaults,bind,user,exec,nofail 0 0\n```\n\nデータ用のファイルシステムは、常に nodev、nosuid、noexec を指定してマウントするべきです。\n\nマウントを検討すべきファイルシステム:\n\n- /var\n- /home\n- /dev/shm\n- /tmp\n- /boot\n\n"
    },
    {
      "title": "スナップショット",
      "level": 4,
      "content": "ファイルシステムのスナップショットを利用する場合(例えば Btrfs、LVM、ZFS など)、スナップショットがユーザーが削除したと期待している機密情報を保持する可能性があることを理解することが重要です。特に、Snapper のような自動スナップショットツールを設定している場合、定期的またはシステムイベントに応じてスナップショットが作成されるため、この問題が発生しやすくなります。\n\n以下は、/home/ 内の機密情報がスナップショットに残存する例です:\n\n- 削除されたファイルやディレクトリ: ファイルシステム上から削除されたとしても、古いスナップショット内には残存している可能性があります。これは通常想定される動作ですが、.local/share/Trash/、.history などのファイルやディレクトリを保持する必要があるかどうかを検討すべきです。\n- 一時ファイルやキャッシュ: アプリケーションによって生成された一時ファイルやキャッシュデータもスナップショットに含まれる可能性があります。例えば、暗号化されたディレクトリ内のファイルを開くと、サムネイル(.cache/thumbnails)や作業用のコピーが作成され、それらがスナップショットに含まれる可能性があります。同様に、ブラウザの履歴(.mozilla/、.config/chromium/ など)も、削除される前にスナップショットに記録されている場合があります。\n\n対応可能であれば、これらのディレクトリをスナップショットの対象から完全に除外することを検討してください。例えば、Btrfs を使用している場合、.cache/、.config/、.local/、.var/ など、用途に応じたディレクトリをサブボリュームとして作成することで、スナップショットの影響を受けにくくできます。\n\n"
    },
    {
      "title": "ファイルシステムのパーミッション",
      "level": 3,
      "content": "デフォルトの パーミッション では、ほとんどのファイルが読み取り可能になっていますが、これを変更することで、http ユーザーや nobody ユーザーなどの非 root アカウントに侵入した攻撃者から貴重な情報を隠すことができます。chmod を使用して、グループやその他のユーザーからすべてのアクセス権を削除できます。\n\n```\n# chmod go-r path_to_hide\n```\n\n考慮すべきパスの例:\n\n- /boot: ブートディレクトリ、vmlinuz や initramfs image、または ユニファイドカーネルイメージ が含まれる場合があります。なお、systemd# GPT パーティションの自動マウント を使用する場合、デフォルトで安全なパーミッションが適用されます。\n- /etc/nftables.conf: nftables の設定ファイル(nftables および iptables-nft に適用)\n- /etc/iptables: レガシーな iptables の設定ファイル(iptables に適用)\n\nまた、新しく作成されるファイルのセキュリティを向上させるために、デフォルトの umask 値 0022 を変更することも可能です。NSA RHEL5 Security Guide では最大限のセキュリティを確保するために、0077 を推奨しており、これにより所有者以外のユーザーが新しいファイルを読み取れなくなります。変更方法については Umask#マスクの値を設定 を参照してください。\n\nさらに、sudo を使用する場合、デフォルトの root umask を適用するよう設定することを検討してください。\n\n"
    },
    {
      "title": "SUID ファイルと SGID ファイル",
      "level": 3,
      "content": "Setuid ビットや Setgid ビットが設定されたファイルには注意しましょう。このようなファイルの例としては、以下があります。\n\n- unix_chkpwd\n- chage expiry gpasswd groupmems passwd sg (shadow パッケージ)\n- fusermount3\n- pkexec polkit-agent-helper-1[3] (polkit パッケージ)\n- ssh-keysign\n- chfn chsh mount newgrp umount wall write (util-linux パッケージ)\n- sudo doas su ksu\n- firejail\n- dbus-daemon-launch-helper\n- chromium-sandbox\n\nこのような実行ファイルの主なリスクとして、特権昇格の脆弱性があります。例えば Wikipedia:Setuid#Security impact を参照してください。[4][5][6]\n\nSUID ビットが設定されているが root によって所有されていないファイル、または SGID ビットが設定されているファイルは、典型的には潜在的なリスクがより小さいですが、理論上、そのようなファイルに脆弱性が存在している場合は、依然として損害を与える可能性があります。通常、代わりにケイパビリティを割り当てることによって、Setuid や Setgid の使用を回避することが可能です。\n\nSUID ビットか SGID ビットを持つファイルを /usr/bin から探すには:\n\n```\n$ find /usr/bin -perm \"/u=s,g=s\"\n```\n\n"
    },
    {
      "title": "root アカウントを日常的に使用しない",
      "level": 3,
      "content": "最小特権の原則に従い、root ユーザーを日常的に使用しないようにしてください。システムを使用する各人に非特権ユーザーアカウントを作成するか。一時的な特権アクセスには、必要に応じて sudo を使用する。\n\n"
    },
    {
      "title": "ログイン失敗後の遅延時間の設定",
      "level": 3,
      "content": "以下の行を /etc/pam.d/system-login に追加し、ログインに失敗した際に最低4秒の遅延を追加します。\n\n```\n/etc/pam.d/system-login\n```\n\n```\nauth optional pam_faildelay.so delay=4000000\n```\n\n4000000 は遅延させる時間をマイクロ秒単位で指定します。\n\n"
    },
    {
      "title": "3回ログインを失敗したユーザーをロックアウトする",
      "level": 3,
      "content": "pambase 20200721.1-2 の時点では 、デフォルトで pam_faillock.so が有効になっており、15分間に3回ログインに失敗すると10分間ユーザをロックアウトします (FS#67644 を参照してください) このロックアウトはパスワード認証 (例:ログインと sudo) にのみ適用され、SSH 経由の公開鍵認証はそのまま利用可能です。 完全なサービス拒否を防ぐために、このロックアウトは root では無効になっています。\n\nユーザーをロック解除するには、次のようにします。\n\n```\n$ faillock --reset --user username\n```\n\nデフォルトでは、ロック機構は /run/faillock/ にあるユーザーごとのファイルです。ディレクトリの所有者は root ですが、ファイルの所有者はユーザーなので、 faillock コマンドはファイルを空にするだけで、root は必要ありません。\n\nモジュール pam_faillock.so は、ファイル /etc/security/faillock.conf で設定することが可能です。ロックアウトのパラメータです。\n\n- unlock_time - ロックアウト時間 (秒単位、デフォルトは10分)\n- fail_interval - ロックアウトに失敗するとロックアウトされる時間 (秒単位、デフォルトは15分)\n- deny - ロックアウトするまでに何回ログインに失敗するか (デフォルトは 3)\n\nデフォルトでは、すべてのユーザーロックは再起動後に失われます。攻撃者がマシンをリブートできるのであれば、ロックは持続させた方が安全です。ロックを持続させるには、/etc/security/faillock.conf の dir パラメータを /var/lib/faillock に変更する必要があります。\n\n変更を反映させるために再起動する必要はありません。root アカウントのロックアウトを有効にする、集中ログイン (LDAP など) を無効にするなど、さらなる設定オプションについては faillock.conf(5) を参照してください。\n\n"
    },
    {
      "title": "プロセスの数を制限する",
      "level": 3,
      "content": "信頼できないユーザーが大量に存在するシステムでは、一度に実行できるプロセスの数を制限して、フォーク爆弾などのサービス拒否攻撃を予防することが重要です。ユーザーやグループごとに実行できるプロセスの数は /etc/security/limits.conf で定義することができ、デフォルトでは空になっています。以下の値をファイルに追加すると、実行できるプロセスが100個までに制限されます。prlimit コマンドを使って一時的に上げられる最大数も200個までに制限します。ユーザーが普段実行するプロセスの数や、管理するハードウェアにあわせて適切な値に変更してください。\n\n```\n* soft nproc 100\n* hard nproc 200\n```\n\n"
    },
    {
      "title": "Wayland を使用する",
      "level": 3,
      "content": "Xorg よりも Wayland を使用することをお勧めします。Xorg の設計は現代のセキュリティ慣行より古く、多くの人が は安全でないと考えています 例えば、Xorg のアプリケーションは非アクティブな状態でもキーストロークを記録することがあります。\n\nもし Xorg を実行しなければならないなら、root での実行を避けることが推奨されます。Wayland 内では、XWayland 互換レイヤーは自動的に root レス Xorg を使用します。\n\n"
    },
    {
      "title": "root の制限",
      "level": 2,
      "content": "root ユーザーは、定義上、システムで最も強力なユーザーです。このため、root ユーザーの権限を維持しながら害を及ぼす力を制限する、もしくは root ユーザーの行動をもっと追跡できるようにする方法が多数存在します。\n\n"
    },
    {
      "title": "su の代わりに sudo を使う",
      "level": 3,
      "content": "色々な理由から特権アクセスには su よりも sudo を使うほうが好ましいとされます。\n\n- 通常の権限しか持たないユーザーが実行した特権コマンドのログを保持します。\n- root アクセスを必要とする各ユーザーに root ユーザーのパスワードを与える必要がありません。\n- 完全な root ターミナルは作成されないため、sudo は root アクセスが必要ないコマンドを偶発的に root で実行してしまうことを防止します。これは最小権限の原則と合っています。\n- 一つのコマンドを実行するためだけに完全な root アクセスを与える代わりに、ユーザーごとに個々のプログラムを有効にすることができます。例えば、ユーザー alice に特定のプログラムへのアクセス権限を与えるには:\n\n```\n# visudo\n```\n\n```\n/etc/sudoers\n```\n\n```\nalice ALL = NOPASSWD: /path/to/program\n```\n\nまた、全てのユーザーに個別のコマンドを許可することも可能です。通常ユーザーでサーバーから Samba 共有をマウントするには:\n\n```\n%users ALL=/sbin/mount.cifs,/sbin/umount.cifs\n```\n\nこれによって users グループのメンバーである全てのユーザーが全てのマシン (ALL) から /sbin/mount.cifs や /sbin/umount.cifs コマンドを実行できるようになります。\n\n```\n/etc/sudoers\n```\n\n```\nDefaults editor=/usr/bin/rnano\n```\n\n# EDITOR=nano visudo のエクスポートは何にでも EDITOR として使うことができるためにセキュリティリスクとされています。\n\n"
    },
    {
      "title": "sudo を使ってファイルを編集する",
      "level": 4,
      "content": "root で vim などのテキストエディタを使用するのはセキュリティ上の脆弱性になりえます。ユーザーは任意のシェルコマンドを実行でき、コマンドを実行したユーザーのログが残らないからです。これを解決するには、以下をシェルの設定ファイルに追加してください:\n\n```\nexport SUDO_EDITOR=rvim\n```\n\nファイルの編集には sudoedit filename または sudo -e filename を使って下さい。自動的に rvim によって filename が編集されるようになり、テキストエディタからのシェルコマンドが無効になります。\n\n"
    },
    {
      "title": "root ログインの制限",
      "level": 3,
      "content": "sudo を適切に設定することで、ユーザビリティをあまり下げることなく完全な root アクセスを大分制限することが可能です。sudo を使える状態のまま root を無効化したい場合、passwd -l root を使用します。\n\n"
    },
    {
      "title": "特定のユーザーだけに許可を与える",
      "level": 4,
      "content": "PAM の pam_wheel.so は wheel グループに入っているユーザーだけに su を使用したログインを許可します。/etc/pam.d/su と /etc/pam.d/su-l の両方を編集して次の行をアンコメントしてください:\n\n```\n# Uncomment the following line to require a user to be in the \"wheel\" group.\nauth\t\trequired\tpam_wheel.so use_uid\n```\n\n特権コマンドを実行できる既存のユーザーだけが root でログインできるようになります。\n\n"
    },
    {
      "title": "ssh ログインを拒否する",
      "level": 4,
      "content": "ローカルユーザーの root ログインを拒否したくない場合でも、SSH による root ログインを拒否するのがグッドプラクティスです。この目的は、ユーザーがリモートでシステムを完全に手にかける前にセキュリティ層を追加することにあります。\n\n"
    },
    {
      "title": "access.conf で許容されるログインの組み合わせを指定する",
      "level": 4,
      "content": "誰かが PAM でログインしようとすると、 /etc/security/access.conf がそのログインプロパティに一致する最初の組み合わせをチェックします。そして、その組み合わせのルールに基づいて、試行が失敗するか成功するかが決まります。\n\n```\n+:root:LOCAL\n-:root:ALL\n```\n\n特定のグループやユーザーに対してルールを設定することができます。この例では、ユーザー archie は、wheel および adm グループに属するすべてのユーザーと同様に、ローカルでのログインを許可されています。それ以外のログインは拒否されます。\n\n```\n+:archie:LOCAL\n+:(wheel):LOCAL\n+:(adm):LOCAL\n-:ALL:ALL\n```\n\n詳しくは access.conf(5) で確認してください。\n\n"
    },
    {
      "title": "強制アクセス制御",
      "level": 2,
      "content": "強制アクセス制御 (Mandatory Access Control, MAC) は Arch やほとんどの Linux ディストリビューションで使われている任意アクセス制御 (Discretionary Access Control, DAC) とは大きく異なるタイプのセキュリティポリシーです。原則的に MAC ではシステムに影響を与えるプログラムの行動は全てセキュリティルールセットによってチェックを受けます。このルールセットは、DAC とは対照的に、ユーザーが変更することは不可能です。実装方法は色々と異なるタイプが存在しますが、強制アクセス制御を使うことで実質的にコンピュータのセキュリティを著しく向上させることになります。\n\n"
    },
    {
      "title": "パス名 MAC",
      "level": 3,
      "content": "パス名ベースのアクセス制御は指定されたファイルのパスに基づいてパーミッションを与えるというシンプルな形式のアクセス制御です。この形式のアクセス制御の欠点としてはファイルが移動されてもパーミッションはファイルと一緒に付いていかないということが挙げられます。プラス面となるのは、パス名ベースの MAC はラベルベースの MAC と異なり、幅広いファイルシステムに実装できることです。\n\n- AppArmor は Canonical によって開発されている MAC 実装で SELinux に比べて\"簡単\"になっています。\n- Tomoyo はもうひとつのシンプルで、使いやすい強制アクセス制御を提供するシステムです。利用と実装の両面でシンプルになるように設計されており、依存するライブラリがとても少なくなっています。\n\n"
    },
    {
      "title": "ラベル MAC",
      "level": 3,
      "content": "ラベルベースのアクセス制御ではファイルの拡張属性を使ってセキュリティパーミッションを管理します。このシステムはセキュリティの機能においてパス名ベースの MAC よりも間違いなく柔軟性が高い一方、拡張属性をサポートしているファイルシステムでしか動作しません。\n\n- SELinux は、Linux セキュリティを向上させる NSA プロジェクトに基づいており、システムユーザーやロールとは完全に独立して MAC を実装しています。成長してオリジナルの設定が変わっていくシステムのコントロールを簡単に維持できる、極めて強固なマルチレベル MAC ポリシー実装を提供します。\n\n"
    },
    {
      "title": "アクセス制御リスト",
      "level": 3,
      "content": "アクセス制御リスト (Access Control List, ACL) は何らかの方法で直接ファイルシステムにルールを付加する代わりとなる手段です。ACL はプログラムの行動を許可された挙動のリストでチェックすることによりアクセス制御を実装しています。\n\n"
    },
    {
      "title": "カーネルの自己防衛機能/脆弱性攻撃対策",
      "level": 3,
      "content": "linux-hardened パッケージは、基本的なカーネル堅牢化パッチセットと、linux パッケージよりもセキュリティに重点を置いたコンパイル時設定オプションを使用します。カスタムビルドでは、セキュリティ寄りのデフォルトとは異なる、セキュリティと性能の妥協点を選択することができます。\n\nしかし、このカーネルを使うといくつかのパッケージが動かなくなることに注意する必要があります。例えば\n\n- skypeforlinux-preview-binAUR\n- skypeforlinux-stable-binAUR\n- throttled\n\nNVIDIA などのアウトオブツリードライバを使用している場合、その DKMS パッケージに切り替える必要があるかもしれません。\n\n"
    },
    {
      "title": "ユーザー空間 ASLR の比較",
      "level": 4,
      "content": "linux-hardened パッケージは、アドレス空間配置ランダム化の改善された実装をユーザ空間のプロセスに対して提供します。paxtest コマンドを使うことで、提供されるエントロピーの推定値を得ることができます:\n\n```\nlinux-hardened 5.4.21.a-1-hardened\n```\n\n```\nAnonymous mapping randomization test     : 32 quality bits (guessed)\nHeap randomization test (ET_EXEC)        : 40 quality bits (guessed)\nHeap randomization test (PIE)            : 40 quality bits (guessed)\nMain executable randomization (ET_EXEC)  : 32 quality bits (guessed)\nMain executable randomization (PIE)      : 32 quality bits (guessed)\nShared library randomization test        : 32 quality bits (guessed)\nVDSO randomization test                  : 32 quality bits (guessed)\nStack randomization test (SEGMEXEC)      : 40 quality bits (guessed)\nStack randomization test (PAGEEXEC)      : 40 quality bits (guessed)\nArg/env randomization test (SEGMEXEC)    : 44 quality bits (guessed)\nArg/env randomization test (PAGEEXEC)    : 44 quality bits (guessed)\nOffset to library randomisation (ET_EXEC): 34 quality bits (guessed)\nOffset to library randomisation (ET_DYN) : 34 quality bits (guessed)\nRandomization under memory exhaustion @~0: 32 bits (guessed)\nRandomization under memory exhaustion @0 : 32 bits (guessed)\n```\n\n```\nlinux 5.5.5-arch1-1\n```\n\n```\nAnonymous mapping randomization test     : 28 quality bits (guessed)\nHeap randomization test (ET_EXEC)        : 28 quality bits (guessed)\nHeap randomization test (PIE)            : 28 quality bits (guessed)\nMain executable randomization (ET_EXEC)  : 28 quality bits (guessed)\nMain executable randomization (PIE)      : 28 quality bits (guessed)\nShared library randomization test        : 28 quality bits (guessed)\nVDSO randomization test                  : 20 quality bits (guessed)\nStack randomization test (SEGMEXEC)      : 30 quality bits (guessed)\nStack randomization test (PAGEEXEC)      : 30 quality bits (guessed)\nArg/env randomization test (SEGMEXEC)    : 22 quality bits (guessed)\nArg/env randomization test (PAGEEXEC)    : 22 quality bits (guessed)\nOffset to library randomisation (ET_EXEC): 28 quality bits (guessed)\nOffset to library randomisation (ET_DYN) : 28 quality bits (guessed)\nRandomization under memory exhaustion @~0: 29 bits (guessed)\nRandomization under memory exhaustion @0 : 29 bits (guessed)\n```\n\n```\nlinux-lts 4.19.101-1-lts\n```\n\n```\nAnonymous mapping randomization test     : 28 quality bits (guessed)\nHeap randomization test (ET_EXEC)        : 28 quality bits (guessed)\nHeap randomization test (PIE)            : 28 quality bits (guessed)\nMain executable randomization (ET_EXEC)  : 28 quality bits (guessed)\nMain executable randomization (PIE)      : 28 quality bits (guessed)\nShared library randomization test        : 28 quality bits (guessed)\nVDSO randomization test                  : 19 quality bits (guessed)\nStack randomization test (SEGMEXEC)      : 30 quality bits (guessed)\nStack randomization test (PAGEEXEC)      : 30 quality bits (guessed)\nArg/env randomization test (SEGMEXEC)    : 22 quality bits (guessed)\nArg/env randomization test (PAGEEXEC)    : 22 quality bits (guessed)\nOffset to library randomisation (ET_EXEC): 28 quality bits (guessed)\nOffset to library randomisation (ET_DYN) : 28 quality bits (guessed)\nRandomization under memory exhaustion @~0: 28 bits (guessed)\nRandomization under memory exhaustion @0 : 28 bits (guessed)\n```\n\n```\nlinux-hardened\n```\n\n```\nAnonymous mapping randomization test     : 16 quality bits (guessed)\nHeap randomization test (ET_EXEC)        : 22 quality bits (guessed)\nHeap randomization test (PIE)            : 27 quality bits (guessed)\nMain executable randomization (ET_EXEC)  : No randomization\nMain executable randomization (PIE)      : 18 quality bits (guessed)\nShared library randomization test        : 16 quality bits (guessed)\nVDSO randomization test                  : 16 quality bits (guessed)\nStack randomization test (SEGMEXEC)      : 24 quality bits (guessed)\nStack randomization test (PAGEEXEC)      : 24 quality bits (guessed)\nArg/env randomization test (SEGMEXEC)    : 28 quality bits (guessed)\nArg/env randomization test (PAGEEXEC)    : 28 quality bits (guessed)\nOffset to library randomisation (ET_EXEC): 18 quality bits (guessed)\nOffset to library randomisation (ET_DYN) : 16 quality bits (guessed)\nRandomization under memory exhaustion @~0: 18 bits (guessed)\nRandomization under memory exhaustion @0 : 18 bits (guessed)\n```\n\n```\nlinux\n```\n\n```\nAnonymous mapping randomization test     : 8 quality bits (guessed)\nHeap randomization test (ET_EXEC)        : 13 quality bits (guessed)\nHeap randomization test (PIE)            : 13 quality bits (guessed)\nMain executable randomization (ET_EXEC)  : No randomization\nMain executable randomization (PIE)      : 8 quality bits (guessed)\nShared library randomization test        : 8 quality bits (guessed)\nVDSO randomization test                  : 8 quality bits (guessed)\nStack randomization test (SEGMEXEC)      : 19 quality bits (guessed)\nStack randomization test (PAGEEXEC)      : 19 quality bits (guessed)\nArg/env randomization test (SEGMEXEC)    : 11 quality bits (guessed)\nArg/env randomization test (PAGEEXEC)    : 11 quality bits (guessed)\nOffset to library randomisation (ET_EXEC): 8 quality bits (guessed)\nOffset to library randomisation (ET_DYN) : 13 quality bits (guessed)\nRandomization under memory exhaustion @~0: No randomization\nRandomization under memory exhaustion @0 : No randomization\n```\n\n"
    },
    {
      "title": "proc ファイルシステム内のカーネルポインタへのアクセスを制限する",
      "level": 3,
      "content": "kernel.kptr_restrict を 1 に設定すると、CAP_SYSLOG を持たない通常ユーザから /proc/kallsyms 内のカーネルシンボルのアドレスが秘匿され、カーネルのエクスプロイトで動的にアドレス/シンボルを解決することが困難になります。これは、事前にコンパイルされた Arch Linux カーネルではあまり意味がありません。周到な攻撃者はカーネルパッケージをダウンロードして、そこから手動でシンボルを取得することができるからです。しかしながら、自分でカーネルをコンパイルする場合は、ローカルの root 攻撃を減らす効果があります。ただし、一部の perf コマンドの機能が、root 以外のユーザによって使用されば場合に破壊されます (しかし、いずれにせよ多くの perf コマンドは root アクセスを必要とします)。詳細は FS#34323 を参照してください。\n\nkernel.kptr_restrict を 2 に設定すると、/proc/kallsyms 内のカーネルシンボルのアドレスが権限に依らず隠されます。\n\n```\n/etc/sysctl.d/51-kptr-restrict.conf\n```\n\n```\nkernel.kptr_restrict = 1\n```\n\n"
    },
    {
      "title": "BPF の堅牢化",
      "level": 3,
      "content": "BPF は、実行時にカーネル内のバイトコードを動的にロードして実行するために使用されるシステムです。ネットワーク (XDP, tc など)、トレース (kprobes, uprobes, tracepoints など)、セキュリティ (seccomp など) など、多くの Linux カーネルサブシステムで使用されています。また、高度なネットワークセキュリティ、パフォーマンスプロファイリング、ダイナミックトレースにも有効です。\n\nBPF はもともと Berkeley Packet Filter の頭文字をとったもので、オリジナルの古典的な BPF は BSD 用のパケットキャプチャツールに使われていたためです。これは最終的に拡張 BPF (eBPF) に発展し、その後まもなくただの BPF (頭字語ではありません) に改名されました。BPFはパケットフィルタリングツールの実装に使われることがありますが、 iptables や netfilter のようなパケットフィルタリングツールと混同しないでください。\n\nBPF のコードは解釈されるか、Just-In-Time (JIT) コンパイラを使ってコンパイルされるかのどちらかです。Arch のカーネルは CONFIG_BPF_JIT_ALWAYS_ON でビルドされており、BPF インタープリタを無効にして全ての BPF を JIT コンパイラでコンパイルするよう強制しています。これにより、攻撃者が BPF を使って SPECTRE 型の脆弱性を悪用した特権昇格攻撃をすることが難しくなります。詳しくは、CONFIG_BPF_JIT_ALWAYS_ON を導入したカーネルパッチを参照してください。\n\nカーネルは JIT コンパイルされた BPF に対して、パフォーマンスと多くの BPF プログラムをトレース・デバッグする能力を犠牲にして、ある種の JIT スプレー攻撃を軽減するための堅牢化機能を備えています。この機能は、net.core.bpf_jit_harden を 1 (非特権コードの堅牢化を有効化する) か 2 (全てのコードの堅牢化を有効化する) に設定することで有効化できます。\n\n詳しくは、カーネルドキュメント の net.core.bpf_* 設定を参照してください。\n\n- linux-hardened では、デフォルトで net.core.bpf_jit_harden=2 が設定されており、0 ではありません。\n- デフォルトでは、BPF プログラムは非特権ユーザでも実行可能です。この挙動を変更するには kernel.unprivileged_bpf_disabled=1 を設定してください [7]。\n\n"
    },
    {
      "title": "ptrace スコープ",
      "level": 3,
      "content": "ptrace(2) システムコールは、あるプロセス (\"tracer\") が他のプロセス (\"tracee\") の実行を監視、制御し、tracee のメモリとレジスタを検査、変更するための手段を提供します。通常、ptrace は gdb や strace、perf、reptyr などのデバッグツールによって使用されます。しかし、他のプロセスからデータを読んだり、他のプロセスの制御を奪ったりする手段を悪意のあるプロセスにも提供してしまいます。\n\nArch では、kernel.yama.ptrace_scope カーネルパラメータを提供する Yama LSM がデフォルトで有効化されています。このパラメータはデフォルトで 1 (制限) に設定されており、CAP_SYS_PTRACE ケイパビリティも特権も持たない tracer が制限されたスコープ外で ptrace コールを実行できないようにしています。これは、古典的なパーミッションと比べてセキュリティ上大きな改善です。このモジュールが無いと、同じユーザとして実行されているプロセスを隔てるものがなくなってしまいます (pid_namespaces(7) などの他のセキュリティレイヤーがない場合)。\n\nデバッグツールを使う必要がない場合は、システムを堅牢化するために kernel.yama.ptrace_scope を 2 (管理者限定) や 3 (ptrace を禁止) に設定することを検討してください。\n\n"
    },
    {
      "title": "hidepid",
      "level": 3,
      "content": "- これは、サンドボックスと Xorg 内で実行するアプリケーションなど、特定のアプリケーションで問題を発生させる場合があります (回避策を見てください)。\n- systemd > 237.64-1 を使用している場合、これは D-Bus、Polkit、PulseAudio、そして bluetooth で問題を発生させます。\n\nカーネルには、proc ファイルシステムを hidepid= オプションと gid= オプションを使ってマウントすることで、他のユーザのプロセス (通常、/proc でアクセス可能) を非特権ユーザから秘匿する機能があります。これらのマウントオプションは https://docs.kernel.org/filesystems/proc.html でドキュメント化されています。\n\nこれにより、侵入者が動作中のプロセスの情報 (特権で動作しているデーモンがあるか、他のユーザが機密情報を扱うプログラムを実行しているか、他のユーザがプログラムを実行しているか) を得る作業を複雑化し、ユーザが特定のプログラムを実行しているかどうかを知るのを不可能にし (ただし、そのプログラムがそれ自体の挙動で存在を他者に知られることがないとする)、さらに、貧弱に書かれたプログラムが機密情報をプログラム引数を介して渡したとしてもローカルの盗聴者から守られます。\n\nproc ユーザーとグループ#システムグループ#グループ (filesystem パッケージによって提供されています) は、他のユーザのプロセス情報を得ることのできるユーザのホワイトリストとして機能します。ユーザやサービスが自身以外の /proc/<pid> ディレクトリにアクセスする必要がある場合、そのユーザまたはサービスをproc グループに追加してください。\n\n例えば、プロセスの情報を proc グループに属さない他のユーザから隠すには:\n\n```\n/etc/fstab\n```\n\n```\nproc\t/proc\tproc\tnosuid,nodev,noexec,hidepid=2,gid=proc\t0\t0\n```\n\nユーザのセッションを正しく動作させるために、systemd-logind を例外として追加する必要があります:\n\n```\n/etc/systemd/system/systemd-logind.service.d/hidepid.conf\n```\n\n```\n[Service]\nSupplementaryGroups=proc\n```\n\n"
    },
    {
      "title": "モジュールのロードを制限する",
      "level": 3,
      "content": "デフォルトの Arch カーネルは CONFIG_MODULE_SIG_ALL が有効で、linux パッケージの一部としてビルドされた全てのカーネルモジュールに署名します。これにより、カーネルは有効なキーで署名されたモジュールだけをロードするように制限できます。実際、これはローカルでコンパイルされた、もしくは virtualbox-host-modules-arch などのパッケージによって提供された、ツリー外のモジュールは全てロードできないことを意味します。\n\nカーネルモジュールの読み込みは module.sig_enforce=1 カーネルパラメータを設定することで制限することができます。詳細はカーネルドキュメントで見られます。\n\n"
    },
    {
      "title": "kexec を無効にする",
      "level": 3,
      "content": "Kexec は、現在実行中のカーネルを置き換えることを可能にします。\n\n```\n/etc/sysctl.d/51-kexec-restrict.conf\n```\n\n```\nkernel.kexec_load_disabled = 1\n```\n\n"
    },
    {
      "title": "カーネルロックダウンモード",
      "level": 3,
      "content": "Linux 5.4 から、オプションのロックダウン機能がカーネルに追加されました。これは、UID 0 (root) とカーネルの間の境界を強化することを目的としています。この機能を有効にすると、ハードウェアやカーネルへの低レベルなアクセスに依存している一部のアプリケーションは動作しなくなる可能性があります。\n\nロックダウンを使用するには、LSM が初期化され、ロックダウンモードが設定されている必要があります。\n\n公式にサポートされているカーネルは全て LSM を初期化しますが、ロックダウンモードを強制しません。\n\nロックダウンには2つの動作モードがあります:\n\n- integrity: ユーザーランドが実行中のカーネルを変更できるカーネル機能 (kexec、bpf) は無効化されます。\n- confidentiality: ユーザーランドがカーネルから機密情報を抽出するためのカーネルの機能も無効化されます。\n\n特定の脅威モデルで指示がない限り、integrity を使用することが推奨されます。\n\n実行時にカーネルのロックダウンを有効にするには、以下を実行してください:\n\n```\n# echo mode > /sys/kernel/security/lockdown\n```\n\n起動時にカーネルのロックダウンを有効にするには、lockdown=mode カーネルパラメータを使用してください:\n\n- カーネルロックダウンを実行時に無効化することはできません。\n- カーネルロックダウンは、ハイバネートを無効化します。\n\nkernel_lockdown(7) も参照してください。\n\n"
    },
    {
      "title": "Linux Kernel Runtime Guard (LKRG)",
      "level": 3,
      "content": "LKRG (lkrg-dkmsAUR) は、カーネルの整合性チェックとエクスプロイト行為の検出を行うカーネルモジュールです。\n\n"
    },
    {
      "title": "アプリケーションのサンドボックス化",
      "level": 2,
      "content": "こちらも参照 Wikipedia:ja:サンドボックス (セキュリティ)\n\nこれを軽減するためには、次のいずれかを行ってください:\n\n- 安全なデフォルトを持つ linux-hardened カーネルを使用する、または\n- kernel.unprivileged_userns_clone sysctl を 0 に設定する。\n\nこれにより、Zoom や nsjail などのアプリケーションが動作しなくなる場合があることに注意してください。また、システムに bubblewrap がインストールされている場合は、bubblewrap-suid に置き換える必要があります。詳細は Bubblewrap#インストール を参照してください。\n\n"
    },
    {
      "title": "Firejail",
      "level": 3,
      "content": "Firejail は、アプリケーションやサーバーをサンドボックス化するための使いやすいツールです。元々はブラウザやインターネット向けアプリケーションのために作成されましたが、現在では多くのアプリケーションに対応しています。さまざまな機能を備えたサンドボックス環境を構築するために、suid バイナリとしてインストールされ、ブラックリストとホワイトリストに基づいてターゲットアプリケーションのサンドボックス化された実行環境を構築します。\n\n"
    },
    {
      "title": "bubblewrap",
      "level": 3,
      "content": "bubblewrap は、Flatpak などの非特権コンテナツール向けに開発されたサンドボックスアプリケーションで、Firejail よりもリソース消費と複雑さが大幅に小さいです。ファイルパスのホワイトリスト機能は欠けていますが、bubblewrap はバインドマウントのほか、ユーザー/IPC/PID/ ネットワーク /cgroup 名前空間の作成をサポートしており、シンプルなものから複雑なサンドボックスまで対応可能です。\n\nBubblejail サンドボックスは bubblewrap を基にしており、リソース指向の権限モデルと、権限を調整するためのグラフィカルインターフェースを提供します。\n\n"
    },
    {
      "title": "chroot",
      "level": 3,
      "content": "手動で chroot してサンドボックス化されたプロセス環境を作成できます。しかし、これは他のサンドボックス技術に比べて非常に制限されています。そのサンドボックス化の範囲はファイルパスの隔離に限られています。\n\n"
    },
    {
      "title": "Linux Containers",
      "level": 3,
      "content": "Linux Containers は、他のオプション(完全な仮想化オプション を除く) よりも多くの隔離が必要な場合に適した選択肢です。LXC は、既存のカーネルの上で擬似 chroot 内で実行され、独自の仮想ハードウェアを持っています。\n\n"
    },
    {
      "title": "完全な仮想化オプション",
      "level": 3,
      "content": "VirtualBox、KVM、Xen、または Qubes OS(Xen ベース)などの完全仮想化オプションを使用することで、リスクの高いアプリケーションを実行したり、危険なウェブサイトを閲覧したりする場合に、隔離とセキュリティを強化することができます。\n\n"
    },
    {
      "title": "ファイアウォール",
      "level": 3,
      "content": "標準の Arch カーネルは Netfilter の iptables および nftables を使用できますが、これらのサービスはデフォルトで 有効化 されていません。システム上で実行されているサービスを保護するために、何らかの形のファイアウォールを設定することを強く推奨します。多くのリソース(ArchWiki など)では、どのサービスを保護するべきかが明示的に記載されていないため、ファイアウォールを有効にすることは良い予防措置となります。\n\n- 一般的な情報については iptables および nftables を参照してください。\n- iptables ファイアウォールの設定方法については シンプルなステートフルファイアウォール を参照してください。\n- netfilter の設定方法については ファイアウォール を参照してください。\n- Bluetack などの IP アドレスリストをブロックするには Ipset を参照してください。\n- opensnitch は、アプリケーション、ポート、ホストなどによる設定可能なルールをサポートする、構成可能なインバウンドおよびアウトバウンドファイアウォールです。\n\n"
    },
    {
      "title": "ポートを開く",
      "level": 4,
      "content": "一部のサービスは、開かれたネットワークポートでインバウンドトラフィックを待ち受けます。これらのサービスは、必要最低限のアドレスとインターフェースにのみバインドすることが重要です。リモート攻撃者が ネットワークプロトコルの欠陥を悪用して公開されたサービスにアクセスする 可能性があります。これは、localhost にバインドされたプロセス にも発生することがあります。\n\n一般的に、サービスがローカルシステムのみでアクセス可能であれば、非ループバックアドレス(例えば 0.0.0.0/0)ではなく、Unix ドメインソケット(unix(7))や localhost のようなループバックアドレスにバインドするべきです。\n\nサービスがネットワーク越しに他のシステムからアクセス可能である必要がある場合、厳格な ファイアウォール ルールでアクセスを制御し、可能な限り認証、認可、暗号化を構成することが重要です。\n\n現在のすべてのオープンポートをリストするには、ss -l を使用できます。すべてのリスニング中のプロセスとその数値的な TCP および UDP ポート番号を表示するには:\n\n```\n# ss -lpntu\n```\n\nその他のオプションについては、ss(8)を参照してください。\n\n"
    },
    {
      "title": "カーネルパラメータ",
      "level": 3,
      "content": "ネットワークに影響を与えるカーネルパラメータは sysctl を使って設定できます。設定方法は sysctl#TCP/IP スタックの防御 を見て下さい。\n\n"
    },
    {
      "title": "SSH",
      "level": 3,
      "content": "SSH 鍵を必要としない Secure Shell を使うのは避けましょう。これは総当たり攻撃を防ぎます。また、Fail2ban や Sshguard はログを監視して iptables ルールを書き込む方式の保護を提供しますが、攻撃者がアドレスを識別して管理者からのパケットのように偽装することができるため、サービスの妨害が行われる危険性があります。\n\n二段階認証によって認証を強化することができます。Google Authenticator はワンタイムパスコード (OTP) を使用する二段階認証方式を提供します。\n\nroot ログインを拒否するのは、侵入追跡と root アクセス前のセキュリティレイヤを追加するという両方の面でグッドプラクティスです。\n\n"
    },
    {
      "title": "DNS",
      "level": 3,
      "content": "DNSSEC や DNSCrypt を見て下さい。\n\n"
    },
    {
      "title": "プロキシ",
      "level": 3,
      "content": "プロキシはアプリケーションとネットワークの間に挟まる追加レイヤーとして使われ、信頼できないソースからのデータをサニタイズします。少ない権限でプロキシを動作させることで、エンドユーザー権限で複雑なアプリケーションを実行するよりも攻撃対象を小さくすることができます。\n\n例えば glibc の中に実装されている DNS リゾルバを考えてみてください。(root で実行することもある) アプリケーションにリンクされている DNS リゾルバにバグが存在した場合、リモートコード実行につながる危険があります。dnsmasq などの DNS キャッシュサーバーをインストールしてプロキシとして使うことで問題を防ぐことが可能です [8]。\n\n"
    },
    {
      "title": "SSL 証明書の管理",
      "level": 3,
      "content": "サーバーサイドの SSL 証明書の管理については OpenSSL や Network Security Services (NSS) を参照してください。また、関連する Let’s Encrypt プロジェクトも見てください。\n\nデフォルトのインターネット SSL 証明書のトラストチェーンは ca-certificates パッケージによって提供されています。Arch はデフォルトで信頼しても問題ないとされる証明書を提供しているソース (例: ca-certificates-cacertAUR, ca-certificates-mozilla) に依存しています。\n\nデフォルトの証明書を変えたいと思うことがあるかもしれません。例えば、ニュース を読んで証明書を信頼しないようにしたい場合 (ソースのプロバイダーによって無効になるのを待てない場合)、Arch のインフラを使うことで簡単に設定できます:\n\n1. .crt 形式の証明書を入手してください (例: view, download; 既存のルート認証局の場合、システム内にあるはずです)。\n1. /etc/ca-certificates/trust-source/blacklist/ にコピーしてください。\n1. root で update-ca-trust を実行してください。\n\nお好きなブラウザを開いて信頼できないサイトとして表示されれば、ブラックリストが上手く機能しています。\n\n"
    },
    {
      "title": "物理セキュリティ",
      "level": 2,
      "content": "十分な時間とリソースさえあればコンピュータへの物理的なアクセスは root アクセスになります。しかしながら、十分な防御策を張ることで実用的で高いレベルのセキュリティを得ることができます。\n\n攻撃者は悪意のある IEEE 1394 (FireWire), Thunderbolt, PCI Express デバイスを取り付けることでメモリーへの完全なアクセスを手に入れることができ、次に起動した時には簡単にコンピュータの完全なコントロールを手中に収めることができます [9]。これを防ぐためにできることは限られており、悪意のあるファームウェアをドライブに書き込むなどハードウェア自体の改変に対処することは不可能です。ただし、攻撃者の大部分にはこうした知識がなく実行されることはほとんどありません。\n\nディスク暗号化はコンピュータが盗まれた場合にデータへのアクセスを防止しますが、あなたが次にログインしたときにデータを取得するために悪意のあるファームウェアが能力のある攻撃者によってインストールされる可能性があります。\n\n"
    },
    {
      "title": "BIOS をロックダウンする",
      "level": 3,
      "content": "BIOS にパスワードを追加することによってリムーバブルメディアから誰かが起動する (これはコンピュータへの root アクセスと基本的に同義です) のを予防します。使用しているドライブがブートの順番で一番最初に来ることを確認して、可能であれば他のドライブのブートを無効にしてください。\n\n"
    },
    {
      "title": "ブートローダー",
      "level": 3,
      "content": "ブートローダー を保護することは非常に重要です。保護されていないブートローダは、例えば init=/bin/sh を設定することでログインの制限を回避することができます。カーネルパラメータ でシェルに直接ブートするようにします。\n\n"
    },
    {
      "title": "Syslinux",
      "level": 4,
      "content": "Syslinux はブートローダーのパスワード保護をサポートしています。メニューのアイテムごとにパスワードを設定したり、ブートローダー全体にパスワードの保護を設定することが可能です。\n\n"
    },
    {
      "title": "GRUB",
      "level": 4,
      "content": "GRUB はブートローダのパスワードもサポートしています。詳しくは GRUB メニューのパスワード保護 を参照してください。暗号化 /boot もサポートしていますが、これはブートローダコードの一部だけを暗号化しないままにしています。GRUB の設定、カーネル、initramfs は暗号化されています。\n\n"
    },
    {
      "title": "systemd-boot",
      "level": 4,
      "content": "systemd-boot は #セキュアブート が有効な場合、カーネルパラメータの編集を無効にします。代わりの方法として、systemd-boot#パスワードで保護されたカーネルパラメータエディタ を参照して下さい、より伝統的なパスワードベースのオプションを使用できます。\n\n"
    },
    {
      "title": "セキュアブート",
      "level": 3,
      "content": "セキュアブート は UEFI の機能で、コンピュータが起動するファイルの認証を可能にするものです。これは、起動パーティション内のファイルを置き換えるような、いくつかの 悪意あるメイド攻撃 を防止するのに役立つ。通常、コンピュータにはベンダー (OEM) によって登録されたキーが付属しています。しかし、これを取り外して、コンピュータを「セットアップモード」にし、ユーザーが自分のキーを登録・管理できるようにすることができます。\n\nセキュアブートのページでは、using your own keys によってセキュアブートを設定する方法を案内しています。\n\n"
    },
    {
      "title": "トラステッドプラットフォームモジュール(TPM)",
      "level": 3,
      "content": "TPM は、暗号鍵が埋め込まれたハードウェア・マイクロプロセッサです。これは、最近のほとんどのコンピュータの基本的な信頼性の根源を形成し、ブートチェーンのエンドツーエンドの検証を可能にします。内部スマートカードとして使用したり、コンピュータ上で動作するファームウェアを証明したり、改ざん防止とブルートフォース耐性のあるストアにユーザーがシークレットに挿入することができます。\n\n"
    },
    {
      "title": "リムーバブル フラッシュ ドライブ上のブートパーティション",
      "level": 3,
      "content": "ブートパーティションをフラッシュドライブに置き、それがないとシステムが起動しないようにする、というのはよくあるアイデアです。このアイデアの支持者はしばしば ディスク暗号化 を併用し、ブートパーティションに置かれた encryption headers を使っている人もいます。\n\nこの方法は encrypting /boot と統合することも可能です。\n\n"
    },
    {
      "title": "自動ログアウト",
      "level": 3,
      "content": "Bash または Zsh を使っている場合、TMOUT によってタイムアウトによるシェルからの自動ログアウトを設定できます。\n\n例えば、以下は仮想コンソールから自動でログアウトします (X11 のターミナルエミュレータからはログアウトしません):\n\n```\n/etc/profile.d/shell-timeout.sh\n```\n\n```\nTMOUT=\"$(( 60*10 ))\";\n[ -z \"$DISPLAY\" ] && export TMOUT;\ncase $( /usr/bin/tty ) in\n\t/dev/tty[0-9]*) export TMOUT;;\nesac\n```\n\n(X のコンソールも含めて) 全ての Bash/Zsh プロンプトでタイムアウトさせたい場合は、次を使って下さい:\n\n```\n$ export TMOUT=\"$(( 60*10 ))\";\n```\n\nシェルで何かコマンドが動作している間はこのタイムアウトは動作しないので注意してください (例: SSH セッションや TMOUT をサポートしていない他のシェル)。しかしながら固まった GDM/Xorg を root で再起動するのに VC を使っているような場合は、とても有用です。\n\n"
    },
    {
      "title": "不正なUSBデバイスから保護する",
      "level": 3,
      "content": "Usbguard は、デバイスの属性に基づく基本的なホワイトリストおよびブラックリスト機能を実装することで、不正な USB デバイス (別名 BadUSB, PoisonTap または LanTurtle) からコンピューターを保護できるソフトウェアフレームワークです。\n\n"
    },
    {
      "title": "揮発性データの収集",
      "level": 3,
      "content": "電源が入っているコンピュータは、volatile data collection に対して脆弱である可能性があります。コンピュータの電源を入れる必要がない時や、コンピュータの物理的な安全性が一時的に損なわれる場合(例:セキュリティチェックポイントを通過する時)には、コンピュータの電源を完全に切ることがベストプラクティスです。\n\n"
    },
    {
      "title": "パッケージの認証",
      "level": 3,
      "content": "パッケージの署名が適正に使われていないと パッケージマネージャへの攻撃 が考えられ、さらに 適切な署名システム を使っているパッケージマネージャにも影響を与える可能性があります。Arch はデフォルトでパッケージの署名を使用しており5つの信頼されたマスターキーによる web of trust を使っています。詳しくは Pacman-key を見て下さい。\n\n"
    },
    {
      "title": "アップグレード",
      "level": 3,
      "content": "定期的に システムのアップグレード を行うことが重要です。\n\n"
    },
    {
      "title": "脆弱性アラートの確認",
      "level": 3,
      "content": "National Vulnerability Database が提供する Common Vulnerabilities and Exposure (CVE) Security Alert の更新を購読し、NVD Download webpage で見つけてください。Arch Linux Security Tracker は Arch Linux Security Advisory (ASA), Arch Linux Vulnerability Group (AVG), CVE データセットを表形式でまとめた、特に有用なリソースです。ツール arch-audit は実行中のシステムに影響を与える脆弱性をチェックするために使われます。グラフィカルなシステムトレイである arch-audit-gtk も使うことができます。Arch Security Teamも参照してください。\n\n特にメインレポジトリや AUR 以外の手段でソフトウェアをインストールしている場合は、あなたが使っているソフトウェアのリリース通知を購読することも検討すべきです。いくつかのソフトウェアには、セキュリティに関する通知を受け取るために購読できるメーリングリストがあります。ソースコードホスティングサイトはしばしば新しいリリースの RSS フィードを提供しています。\n\n"
    },
    {
      "title": "パッケージの再ビルド",
      "level": 3,
      "content": "攻撃対象領域を減らす手段として、パッケージをリビルドし、不要な関数や機能を削除することができます。例えば、bzip2 は CVE-2016-3189 を回避するために bzip2recover を使わずにリビルドすることが可能です。カスタムハードニングフラグは、手動またはラッパーを介して適用することもできます。\n\nTable content:\nフラグ | 目的\n-D_FORTIFY_SOURCE=2 | ランタイムバッファオーバーフローの検出\n-D_GLIBCXX_ASSERTIONS | C++ の文字列とコンテナのランタイム境界チェック\n-fasynchronous-unwind-tables | バックトレースの信頼性向上\n-fexceptions | テーブルベースのスレッドキャンセルを有効にする\n-fpie -Wl,-pie | 実行可能ファイルに対する完全な ASLR\n-fpic -shared | 共有ライブラリのテキスト再配置を行わない\n-fplugin=annobin | ハードニング品質管理用データの作成\n-fstack-clash-protection | スタックオーバーフロー検出の信頼性向上\n-fstack-protector or -fstack-protector-all | スタックスマッシュプロテクター\n-fstack-protector-strong | 同様に\n-g | デバッグ情報を生成する\n-grecord-gcc-switches | デバッグ情報にコンパイラのフラグを格納する\n-mcet -fcf-protection | 制御フローの完全性保護\n-O2 | 推奨される最適化\n-pipe | 一時ファイルを回避し、ビルドを高速化します。\n-Wall | 推奨されるコンパイラの警告\n-Werror=format-security | 安全でない可能性のあるフォーマット文字列の引数を拒否する\n-Werror=implicit-function-declaration | 関数プロトタイプの欠落を却下する\n-Wl,-z,defs | アンダーリンクの検出と拒否\n-Wl,-z,now | 遅延バインディングを無効にする\n-Wl,-z,relro | 移設後の読み出し専用セグメント\n\n- Flags and info ソース\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Arch Linux セキュリティトラッカー\n- ArchWiki のセキュリティアプリケーションのリスト: アプリケーション一覧/セキュリティ\n- CentOS Wiki: OS Protection\n- Hardening the Linux desktop\n- Hardening the Linux server\n- Linux Foundation: Linux ワークステーションのセキュリティチェックリスト\n- privacytools.io Privacy Resources\n- Red Hat Enterprise Linux 7 セキュリティガイド\n- Debian 安全化マニュアル (PDF)\n- The paranoid #! Security Guide\n- UNIX and Linux Security Checklist v3.0\n\n"
    }
  ]
}