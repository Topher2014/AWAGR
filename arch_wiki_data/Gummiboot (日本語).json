{
  "title": "Gummiboot (日本語)",
  "url": "https://wiki.archlinux.org/title/Gummiboot_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Arch ブートプロセス\n- ブートローダー\n- セキュアブート\n- Unified Extensible Firmware Interface\n\nsystemd-boot (旧名 gummiboot。ドイツ語で「ゴムボート」)は、 設定された EFI イメージを実行するシンプルな UEFI ブートマネージャーです。デフォルトのエントリは設定されたパターン (glob) または矢印キーで操作する画面上のメニューによって選択されます。systemd に含まれており、Arch システムにデフォルトでインストールされます。\n\nsystemd-boot は EFI 実行可能ファイル (EFISTUB、UEFI シェル、GRUB、Windows ブートマネージャ) のみを起動できることに注意してください。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 サポートされているファイルシステム\n- 2 インストール\n- 3 EFI ブートマネージャのインストール 3.1 XBOOTLDR を使用したインストール 3.2 UEFI ブートマネージャの更新 3.2.1 手動で更新 3.2.2 自動で更新 3.2.2.1 systemd サービス 3.2.2.2 Pacman フック 3.3 セキュアブートのための署名\n- 4 設定 4.1 ローダー設定 4.2 ローダーの追加 4.2.1 EFI シェルや他の EFI アプリ 4.2.1.1 Memtest86+ 4.2.1.2 Netboot 4.2.1.3 GRUB 4.2.2 別のディスクから起動 4.3 UEFI ファームウェアセットアップの起動 4.4 ハイバネーション 4.5 パスワードで保護されたカーネルパラメータエディタ\n- 5 ヒントとテクニック 5.1 ブートメニューで使用できるキー 5.2 再起動後の起動対象を選択する 5.3 ユニファイドカーネルイメージ を使う 5.4 ESP 上の Grml 5.5 ESP 上の Archiso 5.6 BIOS システムでの systemd-boot\n- 6 トラブルシューティング 6.1 systemd-boot がブートエントリを表示しない 6.2 BIOS モードで起動後にインストール 6.3 efibootmgr を使って手動エントリを追加する 6.4 Windows の bcdedit を使用した手動入力 6.5 Windows をアップグレードした後にメニューが表示されない 6.6 Windows BitLocker TPM ロック解除のサポートを追加\n- 7 参照\n\n- 3.1 XBOOTLDR を使用したインストール\n- 3.2 UEFI ブートマネージャの更新 3.2.1 手動で更新 3.2.2 自動で更新 3.2.2.1 systemd サービス 3.2.2.2 Pacman フック\n- 3.3 セキュアブートのための署名\n\n- 3.2.1 手動で更新\n- 3.2.2 自動で更新 3.2.2.1 systemd サービス 3.2.2.2 Pacman フック\n\n- 3.2.2.1 systemd サービス\n- 3.2.2.2 Pacman フック\n\n- 4.1 ローダー設定\n- 4.2 ローダーの追加 4.2.1 EFI シェルや他の EFI アプリ 4.2.1.1 Memtest86+ 4.2.1.2 Netboot 4.2.1.3 GRUB 4.2.2 別のディスクから起動\n- 4.3 UEFI ファームウェアセットアップの起動\n- 4.4 ハイバネーション\n- 4.5 パスワードで保護されたカーネルパラメータエディタ\n\n- 4.2.1 EFI シェルや他の EFI アプリ 4.2.1.1 Memtest86+ 4.2.1.2 Netboot 4.2.1.3 GRUB\n- 4.2.2 別のディスクから起動\n\n- 4.2.1.1 Memtest86+\n- 4.2.1.2 Netboot\n- 4.2.1.3 GRUB\n\n- 5.1 ブートメニューで使用できるキー\n- 5.2 再起動後の起動対象を選択する\n- 5.3 ユニファイドカーネルイメージ を使う\n- 5.4 ESP 上の Grml\n- 5.5 ESP 上の Archiso\n- 5.6 BIOS システムでの systemd-boot\n\n- 6.1 systemd-boot がブートエントリを表示しない\n- 6.2 BIOS モードで起動後にインストール\n- 6.3 efibootmgr を使って手動エントリを追加する\n- 6.4 Windows の bcdedit を使用した手動入力\n- 6.5 Windows をアップグレードした後にメニューが表示されない\n- 6.6 Windows BitLocker TPM ロック解除のサポートを追加\n\n"
    },
    {
      "title": "サポートされているファイルシステム",
      "level": 2,
      "content": "systemd-boot はファイルシステムのサポートを ファームウェア から引き継ぎます (少なくとも FAT12、FAT16、FAT32) さらに、esp/EFI/systemd/drivers/ にある UEFI ドライバ を全てロードします。\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "systemd-boot は、base メタパッケージの依存関係である systemd パッケージとともに出荷されるため、追加のパッケージを手動でインストールする必要はありません。\n\n"
    },
    {
      "title": "EFI ブートマネージャのインストール",
      "level": 2,
      "content": "systemd-boot の EFI ブートマネージャをインストールする場合、まず UEFI モードでシステムが起動しているかどうか、UEFI 変数 が利用できるかどうか確かめてください。efivar --list コマンドを実行することでチェックできます。または、efivar がインストールされていない場合は、ls /sys/firmware/efi/efivars を実行してください (ディレクトリが存在する場合、システムは UEFI モードにブートされます)\n\nこのページでは ESP のマウントポイントを esp として表します (大抵の場合は /efi か /boot です) これは、システムのマウントポイントに chroot していることを前提としています。\n\nbootctl(1) を使用して EFI システムパーティションに systemd-boot をインストールします:\n\n```\n# bootctl install\n```\n\nこれにより、systemd-boot UEFI ブートマネージャーが ESP にコピーされ、その UEFI ブートエントリが作成され、UEFI ブート順序の最初に設定されます。\n\n- x64 UEFI では、/usr/lib/systemd/boot/efi/systemd-bootx64.efi は esp/EFI/systemd/systemd-bootx64.efi と esp/EFI/BOOT/BOOTX64.EFI にコピーされます。\n- IA32 UEFI では、/usr/lib/systemd/boot/efi/systemd-bootia32.efi は esp/EFI/systemd/systemd-bootia32.efi と esp/EFI/BOOT/BOOTIA32.EFI にコピーされます。\n\nUEFI ブートエントリは \"Linux Boot Manager\" と呼ばれ、UEFI のビット数によって、ESP 上の EFI}systemd-bootx64.efi か EFI}systemd-bootia32.efi を指します。\n\n- bootctl install を実行すると、systemd-boot は ESP を /efi,/boot,/boot/efi に配置しようとします。esp を別の場所に設定するには、--esp-path=esp オプションを渡す必要があります。(詳細は bootctl(1) § OPTIONS を参照)\n- systemd-boot をインストールすると既存の esp/EFI/BOOT/BOOTX64.EFI は上書きされます。(または、esp/EFI/BOOT/BOOTIA32.EFI の IA32 UEFI)、例えば Microsoft 版のファイルなどです。\n\nインストールを完了するには、systemd-boot を設定します。\n\n"
    },
    {
      "title": "XBOOTLDR を使用したインストール",
      "level": 3,
      "content": "カーネルと initramfs を ESP から分離するために、\"Linux extended boot\" タイプ (XBOOTLDR) の別の /boot パーティションを作成することができます。これは、既存の ESP が小さすぎる Windows と Arch のデュアルブート 時に特に役立ちます。\n\n通常どおり ESP を作成し、同じ物理ドライブに XBOOTLDR 用の別のパーティションを作成します。XBOOTLDR のパーティションタイプ GUID は \"bc13c2ff-59e6-4262-a352-b275fd6f7172 である必要があります。XBOOTLDR パーティションのサイズは、インストールする全てのカーネルを収納できる 十分な大きさが必要です。\n\n- systemd-boot は、 ESP の場合のようにファイルシステムチェックを行いません。 したがって、他のファイルシステムを使用することは可能ですが、 UEFI 実装が起動中にそれを読み取ることができる場合に限ります。\n- \"fast boot\" モードが有効の場合、UEFI ファームウェアは ESP 以外のパーティションのロードをスキップすることがあります。これにより、システム起動 が XBOOTLDR パーティション上のエントリを見つけられなくなる可能性があります。XBOOTLDRを使用するには、\"fast boot\" を無効にする必要があります。\n- XBOOTLDR パーティションは、system-boot が認識できるように ESP と同じ物理ディスク上になければならない場合があります。\n\nインストール中に、ESP を /mnt/efi にマウントし、 boot を /mnt/boot にマウントします。\n\nchroot になったら、次のコマンドを使用します:\n\n```\n# bootctl --esp-path=/efi --boot-path=/boot install\n```\n\nインストールを完了するには systemd-boot を設定します。\n\n"
    },
    {
      "title": "UEFI ブートマネージャの更新",
      "level": 3,
      "content": "新しいバージョンの systemd-boot がリリースされるたびに、UEFI ブートマネージャはオプションでユーザーによって再インストールできます。これは手動または自動で行うことができ、以下にその2つの方法を説明します。\n\n"
    },
    {
      "title": "手動で更新",
      "level": 4,
      "content": "bootctl を使用して systemd-boot を更新:\n\n```\n# bootctl update\n```\n\n"
    },
    {
      "title": "自動で更新",
      "level": 4,
      "content": "systemd-boot を自動的に更新するには、systemd サービス または pacman フック を使用してください。これらの2つの方法については、以下に説明します。\n\nバージョン 250 以降、systemd には systemd-boot-update.service が同梱されています。このサービスを 有効化 すると、次回の起動時にブートローダーが更新されます。\n\nsystemd-boot-pacman-hookAUR パッケージは systemd がアップグレードされる度に実行される pacman フックを追加します。\n\nsystemd-boot-pacman-hook をインストールするのではなく、次のファイルを /etc/pacman.d/hooks/ に手動で配置することをお勧めします:\n\n```\n/etc/pacman.d/hooks/95-systemd-boot.hook\n```\n\n```\n[Trigger]\nType = Package\nOperation = Upgrade\nTarget = systemd\n\n[Action]\nDescription = Gracefully upgrading systemd-boot...\nWhen = PostTransaction\nExec = /usr/bin/systemctl restart systemd-boot-update.service\n```\n\n"
    },
    {
      "title": "セキュアブートのための署名",
      "level": 3,
      "content": "セキュアブート が有効な場合、パッケージのアップグレード時にブートマネージャを自動的に署名するために、pacmanフックを追加したい場合:\n\n```\n/etc/pacman.d/hooks/80-secureboot.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nType = Path\nTarget = usr/lib/systemd/boot/efi/systemd-boot*.efi\n\n[Action]\nDescription = Signing systemd-boot EFI binary for Secure Boot\nWhen = PostTransaction\nExec = /bin/sh -c 'while read -r i; do sbsign --key /path/to/keyfile.key --cert /path/to/certificate.crt \"$i\"; done;'\nDepends = sh\nDepends = sbsigntools\nNeedsTargets\n```\n\n/path/to/keyfile.key と /path/to/certificate.crt をそれぞれ署名鍵と証明書に置き換えてください。このフックの詳細な理解には、sbsign(1) を参照してください。\n\n作成された /usr/lib/systemd/boot/efi/systemd-boot*.efi.signed は、bootctl install または bootctl update によって自動的に認識されます。詳細は bootctl(1) § SIGNED .EFI FILES を参照してください。\n\n別の方法としてこちらも参照、sbctl\n\n"
    },
    {
      "title": "ローダー設定",
      "level": 3,
      "content": "ローダーの設定は esp/loader/loader.conf ファイルに保存されます。詳細は、loader.conf(5) § OPTIONS を参照してください。\n\nローダーの設定例を以下に示します:\n\n```\nesp/loader/loader.conf\n```\n\n```\ndefault  arch.conf\ntimeout  4\nconsole-mode max\neditor   no\n```\n\n- systemd-boot はインデント用のタブを受け入れません。代わりにスペースを使用してください。\n- default と timeout はブートメニューで変更することができ、変更した場合は EFI 変数として保存されます。上記のオプションよりも優先して設定されます。\n- ​bootctl set-default \"\" を使用すると、 default オプションに優先して EFI 変数をクリアできます。\n- 基本的なローダーの設定ファイルは /usr/share/systemd/bootctl/loader.conf に存在します。\n- timeout 0 を設定している場合、Space を押すことでブートメニューにアクセスできます。\n- 基本的なローダー設定ファイルは、/usr/share/systemd/bootctl/loader.conf にあります。\n- ブートローダー(エントリ選択中)が歪んで表示される場合や、誤った解像度が使用されている場合は、console-mode を auto(最適な解像度を選択するためのヒューリスティックスを使用)、keep(ファームウェアが提供する解像度を維持)、または 2(最初の非 UEFI 標準解像度を選択しようと試みる)に設定してみることができます。\n\n"
    },
    {
      "title": "ローダーの追加",
      "level": 3,
      "content": "bootctl は esp/loader/entries/*.conf からブートメニューのアイテムを検索します – 各ファイルにそれぞれひとつだけローダーを記述してください。利用可能なオプション:\n\n- title – オペレーティングシステムの名前。必須。\n- version – カーネルバージョン、同じ title のエントリが複数存在する場合にのみ表示されます。任意。\n- machine-id – /etc/machine-id のマシン識別子、title と version が同じエントリが複数存在する場合にのみ表示されます。任意。\n- efi – 起動する EFI プログラム、ESP (/boot) からの相対パス。例: /vmlinuz-linux。このオプションか linux (下を参照) のどちらか一方が必須です。\n- options – EFI プログラムに渡すコマンドラインオプションまたはカーネルパラメータ。任意ですが、Linux を起動する場合 initrd=efipath と root=dev が最低限必要になります。\n\nLinux を起動する場合、efi と options を使う代わりに以下のオプションが使用できます:\n\n- linux と initrd で ESP の適切なファイルの相対パスを指定します。例: /vmlinuz-linux。この値は自動で efi path と options initrd=path に翻訳されます – この文法は利便性のためにサポートされており機能に違いはありません。\n\narch_os というラベルが付いたパーティションから Arch を起動して Intel CPU のマイクロコードをロードするローダーファイルの例:\n\n```\nesp/loader/entries/arch.conf\n```\n\n```\ntitle   Arch Linux\nlinux   /vmlinuz-linux\ninitrd  /initramfs-linux.img\noptions root=UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx rw\n```\n\n```\nesp/loader/entries/arch-fallback.conf\n```\n\n```\ntitle   Arch Linux (fallback initramfs)\nlinux   /vmlinuz-linux\ninitrd  /initramfs-linux-fallback.img\noptions root=UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx rw\n```\n\nbootctl は自動的に \"Windows Boot Manager\" (/EFI/Microsoft/Boot/Bootmgfw.efi), \"EFI Shell\" (/shellx64.efi), \"EFI Default Loader\" (/EFI/BOOT/bootx64.efi) をチェックします。また、/EFI/Linux にカーネルファイルが存在しないかもチェックされます。これらが検出された場合、自動的に適切なエントリが生成されます (auto-windows, auto-efi-shell, auto-efi-default)。これらのエントリを手動でローダー設定する必要はありません。ただし、(rEFInd など) 他の EFI アプリケーションは自動検出されないため、Linux カーネルを起動するには、手動で設定してエントリを作成する必要があります。\n\n- Windows とデュアルブートする場合、Windows のデフォルトオプションである高速スタートアップを無効にすることを強く推奨します。\n- 必要な場合は initrd で Intel のマイクロコードをロードしてください。例はマイクロコード#systemd-boot を参照。\n- blkid -s PARTUUID -o value /dev/sdxY コマンドを使うことで root パーティションの PARTUUID を確認できます。x はデバイス文字、Y はパーティション番号に置き換えて下さい。確認するのは root パーティションだけで大丈夫です。esp は確認する必要がありません。\n\n- 設定済みのブートエントリは bootctl list コマンドで確認できます。\n- サンプルエントリファイルが /usr/share/systemd/bootctl/arch.conf に存在します。\n- LVM, LUKS, dm-crypt などで必要なカーネルパラメータについてはそれぞれのページを確認してください。\n\n"
    },
    {
      "title": "EFI シェルや他の EFI アプリ",
      "level": 4,
      "content": "UEFI シェル を edk2-shell パッケージとともにインストールした場合、\"systemd-boot\" は EFI ファイルが esp/shellx64.efi に配置されると自動的に検出して新しいエントリを作成します。 これを実行するには、パッケージをインストールした後に以下のようなコマンドを使用します:\n\n```\n# cp /usr/share/edk2-shell/x64/Shell.efi /boot/shellx64.efi\n```\n\nそれ以外の場合は、その他の EFI アプリケーション を ESP にインストールした場合、次のスニペットを使用できます。\n\n```\nesp/loader/entries/fwupd.conf\n```\n\n```\ntitle  Firmware updater\nefi     /EFI/tools/fwupdx64.efi\n```\n\n```\nesp/loader/entries/gdisk.conf\n```\n\n```\ntitle  GPT fdisk (gdisk)\nefi     /EFI/tools/gdisk_x64.efi\n```\n\nこれを機能させるには、memtest86+-efi をインストールする必要があります。また、セキュアブートを使用するときに EFI バイナリに署名する必要があります。\n\n```\nesp/loader/entries/memtest.conf\n```\n\n```\ntitle Memtest86+\nefi /memtest86+/memtest.efi\n```\n\n\"systemd-boot\" は Netboot をチェーンロードできます。ipxe-arch.efi EFI バイナリとその署名をダウンロードし、それを検証した後、提案された場所に esp/EFI/arch_netboot/arch_netboot.efi として配置します。\n\n```\nesp/loader/entries/arch_netboot.conf\n```\n\n```\ntitle Arch Linux Netboot\nefi /EFI/arch_netboot/arch_netboot.efi\n```\n\nsystemd-boot は GRUB をチェーンロードできます。grubx64.efi バイナリの場所は、GRUB が ESP にインストールされた際に使用された --bootloader-id= と一致します。\n\n```\nesp/loader/entries/grub.conf\n```\n\n```\ntitle GRUB\nefi /EFI/GRUB/grubx64.efi\n```\n\n"
    },
    {
      "title": "別のディスクから起動",
      "level": 4,
      "content": "\"systemd-boot\" は起動元の ESP や同一ディスク上のXBOOTLDRパーティション以外のパーティションからEFIバイナリを起動 できませんが、 UEFI シェル を使ってそれを行うことができます。\n\nまず、上記の #EFI シェルや他の EFI アプリ のセクションに従って、edk2-shell パッケージをインストールします。UEFI シェルで \"map\" コマンドを使用して、対応する PARTUUID を持つパーティションの FS エイリアス (例:HD0a66666a2、HD0b、FS1、BLK7) を確認します。\n\n次に、exit コマンドを使用して Linux に戻り、UEFI シェルを通じてターゲット EFI プログラムを実行するための新しいローダーエントリを作成します:\n\n```\nesp/loader/entries/windows.conf\n```\n\n```\ntitle   Windows\nefi     /shellx64.efi\noptions -nointerrupt -nomap -noversion HD0b:EFI\\Microsoft\\Boot\\Bootmgfw.efi\n```\n\nefi パスは、 shellx64.efi がコピーされた \"esp\" パーティション内の場所と一致していることを確認してください。また、shellx64.efi EFI ファイルは、\"systemd-boot\" による自動エントリ作成を避けるために他の場所に移動することもできます。\n\nHD0b は、前述の \"FS エイリアス\" に置き換えてください。\n\n- -nointerrupt オプションは、Ctrl+c でターゲット EFI プログラムを中断しないようにします。\n- -nomap -noversion オプションは、デフォルトの UEFI シェルの挨拶を非表示にします。\n- ターゲットEFIプログラムが終了した場合(例えばエラーで)にUEFIシェルが自動的にブートローダーに戻るようにするには、-exit オプションを追加します。\n- もし UEFI シェル内にまだ不要な出力がある場合、-noconsoleout オプションを追加できます。\n\n"
    },
    {
      "title": "UEFI ファームウェアセットアップの起動",
      "level": 3,
      "content": "systemd-boot は、デバイスのファームウェアが OS からセットアップに再起動することをサポートしている場合、UEFI ファームウェアセットアップに起動するエントリを自動的に追加します。\n\n"
    },
    {
      "title": "ハイバネーション",
      "level": 3,
      "content": "サスペンドとハイバネートの記事を参照してください。\n\n"
    },
    {
      "title": "パスワードで保護されたカーネルパラメータエディタ",
      "level": 3,
      "content": "password 設定オプションをサポートしている systemd-boot-passwordAUR をインストールすることもできます。sbpctl generate を使ってオプションで指定する値を生成できます。\n\nsystemd-boot-password は以下のコマンドでインストールしてください:\n\n```\n# sbpctl install esp\n```\n\nカーネルパラメータを編集する前にパスワードの入力が求められるようになります。\n\n"
    },
    {
      "title": "ブートメニューで使用できるキー",
      "level": 3,
      "content": "ブートメニューで使用できるキー割り当てについては、systemd-boot(7) § KEY BINDINGS を参照してください。\n\n"
    },
    {
      "title": "再起動後の起動対象を選択する",
      "level": 3,
      "content": "ブートマネージャーは systemctl コマンドに統合されており、再起動後に起動させるオプションを選択できます。例えば、カスタムカーネルのエントリファイルが esp/loader/entries/arch-custom.conf にあるとき、次のようにするとデフォルト設定はそのままにカスタムカーネルが起動します:\n\n```\n$ systemctl reboot --boot-loader-entry=arch-custom\n```\n\nマザーボードのファームウェアを起動させるときは次のようにします:\n\n```\n$ systemctl reboot --firmware-setup\n```\n\n"
    },
    {
      "title": "ユニファイドカーネルイメージ を使う",
      "level": 3,
      "content": "esp/EFI/Linux/ にある Unified kernel image (UKI)は、systemd-boot によって自動的に読み込まれ、esp/loader/entries にエントリを追加する必要はありません。(Unified kernel image は、systemd-boot によって識別されるためには、.efi 拡張子を持っている必要があります。)\n\n"
    },
    {
      "title": "ESP 上の Grml",
      "level": 3,
      "content": "Grml ​は、システム管理とレスキュー用のソフトウェアを集めた小さなライブシステムです。\n\n​Grml を ESP にインストールするには、カーネル vmlinuz、 initramfs initrd.img、 圧縮イメージ grml64-small.squashfs を iso ファイルから ESP にコピーするだけです。そのためには、まず grml64-small.iso ファイルをダウンロードして(マウントポイントは以降 mnt と表記される) ファイルをマウントします。​カーネルと initramfs は mnt/boot/grml6 small/ にあり、圧縮されたイメージは mnt/live/grml64-small/ にあります。\n\n​次に、Grml 用のディレクトリを ESP に作成します:\n\n```\n# mkdir -p esp/grml\n```\n\n​上記のファイルをコピーします:\n\n```\n# cp mnt/boot/grml64small/vmlinuz esp/grml\n# cp mnt/boot/grml64small/initrd.img esp/grml\n# cp mnt/live/grml64-small/grml64-small.squashfs esp/grml\n```\n\n​最後のステップで、システムブートローダー用のエントリを作成します。 esp/loader/entries 次の内容の grml.conf ファイルを作成します:\n\n```\nesp/loader/entries/grml.conf\n```\n\n```\ntitle   Grml Live Linux\nlinux   /grml/vmlinuz\ninitrd  /grml/initrd.img\noptions apm=power-off boot=live live-media-path=/grml/ nomce net.ifnames=0\n```\n\n​使用可能なブートオプションの概要については、 cheatcode for Grml\n\n"
    },
    {
      "title": "ESP 上の Archiso",
      "level": 3,
      "content": "Grml と同様に、Arch Linux の ISO を使用することができます。そのためには、ISO ファイルからカーネル vmlinuz-linux、initramfs initramfs-linux.img、および squashfs イメージ airootfs.sfs を EFI システムパーティションにコピーする必要があります。\n\n最初に archlinux-yyy.mm.dd-x86_64.iso をダウンロードします。\n\n次に、ESP に Archiso のディレクトリを作成します:\n\n```\n# mkdir -p esp/EFI/archiso\n```\n\nそこに arch ディレクトリの内容を抽出します:\n\n```\n# bsdtar -v -x --no-same-permissions --strip-components 1 -f archlinux-YYYY.MM.DD-x86_64.iso -C esp/EFI/archiso arch\n```\n\n最後のステップでは、systemd-boot Loader のブートエントリを作成します:esp/roader/entries:\n\n```\nesp/loader/entries/arch-rescue.conf\n```\n\n```\ntitle   Arch Linux (rescue system)\nlinux   /EFI/archiso/boot/x86_64/vmlinuz-linux\ninitrd  /EFI/archiso/boot/x86_64/initramfs-linux.img\noptions archisobasedir=/EFI/archiso archisosearchfilename=/EFI/archiso/boot/x86_64/vmlinuz-linux\n```\n\n利用可能なブートオプションの概要については、README.bootparams for mkinitcpio-archiso を参照してください。\n\n"
    },
    {
      "title": "BIOS システムでの systemd-boot",
      "level": 3,
      "content": "ブートローダーの仕様 に従う BIOS システム用のブートローダーが必要な場合は、 BIOS システムで systemd-boot を押してサービスを開始できます。 Clover ブートローダーは BIOS システムからの起動をサポートし、シミュレートされた EFI 環境を提供します。\n\n"
    },
    {
      "title": "systemd-boot がブートエントリを表示しない",
      "level": 3,
      "content": "これは、カーネルへのパスが間違って指定されているなど、設定ファイルに関するさまざまな問題が原因である可能性があります。確認するには、次のコマンドを実行してください:\n\n```\n# bootctl\n```\n\n"
    },
    {
      "title": "BIOS モードで起動後にインストール",
      "level": 3,
      "content": "BIOS モードで OS を起動したいときも systemd-boot をインストールすることは可能です。ただし、起動時に systemd-boot の EFI ファイルを実行するようにファームウェアを設定する必要があります:\n\n- 他の場所に機能する UEFI Shell がある場合。\n- ファームウェアのインターフェイスから起動時にロードされる EFI ファイルを設定する。\n- 一部のファームウェアは、UEFI に他のエントリが設定されていない場合、デフォルトで esp/EFI/BOOT/BOOTX64.EFI を使用することがあります。\n\n設定できる場合、インストールは簡単です: EFI シェルやファームウェアの設定インターフェイスを開いて、マシンのデフォルトの EFI ファイルを esp/EFI/systemd/systemd-bootx64.efi (32ビット環境の場合 systemd-bootia32.efi) に変更してください。\n\n"
    },
    {
      "title": "efibootmgr を使って手動エントリを追加する",
      "level": 3,
      "content": "bootctl install コマンドが失敗した場合、efibootmgr ユーティリティを使って EFI ブートエントリを手動で作成することができます:\n\n```\n# efibootmgr --create --disk /dev/sdX --part Y --loader '\\EFI\\systemd\\systemd-bootx64.efi' --label \"Linux Boot Manager\" --unicode\n```\n\n/dev/sdXY は EFI システムパーティションに置き換えてください。\n\n"
    },
    {
      "title": "Windows の bcdedit を使用した手動入力",
      "level": 3,
      "content": "何らかの理由で Windows から EFI ブートエントリを作成する必要がある場合は、管理者プロンプトから次のコマンドを使用してください。\n\n```\n> bcdedit /copy {bootmgr} /d \"Linux Boot Manager\"\n> bcdedit /set {guid} path \\EFI\\systemd\\systemd-bootx64.efi\n```\n\nguid を最初のコマンドによってリターンされた ID に置き換えます。これをデフォルトのエントリとして設定するには:\n\n```\n> bcdedit /default {guid}\n```\n\n"
    },
    {
      "title": "Windows をアップグレードした後にメニューが表示されない",
      "level": 3,
      "content": "Unified Extensible Firmware Interface#Windows によってブート順序が変わってしまうを見てください。\n\n"
    },
    {
      "title": "Windows BitLocker TPM ロック解除のサポートを追加",
      "level": 3,
      "content": "BitLocker による回復キーの要求を停止するには、次の行を loader.conf に追加します。\n\n```\nesp/loader/loader.conf\n```\n\n```\nreboot-for-bitlocker yes\n```\n\nこれにより、BootNext UEFI 変数が設定され、BitLocker が回復キーを必要とせずに Windows ブートマネージャー がロードされます。これは 1 回限りの変更であり、systemd-boot がデフォルトのブートローダーのままです。Windows が自動検出された場合は、エントリとして指定する必要はありません。\n\nこれは実験的な機能なので、必ず loader.conf(5) を参照してください。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- https://systemd.io/BOOT/\n- https://bbs.archlinux.org/viewtopic.php?id=254374\n- https://uapi-group.org/specifications/specs/boot_loader_specification/\n\n"
    }
  ]
}