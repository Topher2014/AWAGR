{
  "title": "Nommage persistant des périphériques de type bloc",
  "url": "https://wiki.archlinux.org/title/Nommage_persistant_des_p%C3%A9riph%C3%A9riques_de_type_bloc",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- fstab (Français)\n- udev (Français)\n- LVM (Français)\n\nCet article décrit comment utiliser des noms persistants pour vos périphériques de type bloc. Ceci a été rendu possible grâce à l'introduction d'udev et présente quelques avantages par rapport à l'attribution de noms par bus. Si votre machine dispose de plus d'un contrôleur de disque SATA, SCSI ou IDE, l'ordre dans lequel les nœuds de périphériques correspondants sont ajoutés est arbitraire. Cela peut avoir pour conséquence que les noms de périphériques comme /dev/sda et /dev/sdb changent à chaque démarrage, ce qui peut aboutir à un système non amorçable, kernel panic (la panique du noyau) ou la disparition d'un périphérique de type bloc. Un nommage persistant résout ces problèmes.\n\n- Les noms persistants ont des limites qui sont hors du champ de cet article. Par exemple, alors que Mkinitcpio peut prendre en charge une méthode, systemd peut imposer ses propres limites (par exemple FS#42884) sur le nommage qu'il peut prendre en charge au démarrage.\n- Cet article n'est pas pertinent pour les volumes logiques de LVM, puisque les chemins /dev/NomDuGroupeDeVolume/NomDeVolumeLogique vers les périphériques sont permanents.\n\n"
    },
    {
      "title": "Méthodes de nommage persistantes",
      "level": 2,
      "content": "Il existe quatre schémas différents pour l'appellation persistante: by-label, by-uuid, by-id et by-path. Pour ceux qui utilisent des disques avec une table de partitions GUID (GPT), deux schémas supplémentaires peuvent être utilisés by-partlabel et by-partuuid. Vous pouvez également utiliser des noms de périphériques statiques avec Udev.\n\nLes répertoires de /dev/disk/ sont créés et détruits dynamiquement, selon qu'ils contiennent ou non des périphériques.\n\nLes sections suivantes décrivent les différentes méthodes de nommage persistant et leur utilisation.\n\nLa commande lsblk peut être utilisée pour visualiser graphiquement les premiers schémas persistants:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE LABEL  UUID                                 MOUNTPOINT\nsda\n├─sda1 vfat          CBB6-24F2                            /boot\n├─sda2 ext4   SYSTEM 0a3407de-014b-458b-b5c1-848e92a327a3 /\n├─sda3 ext4   DATA   b411dc99-f0a0-4c87-9e05-184977be8539 /home\n└─sda4 swap          f9fe0b69-a280-415d-a03a-a32752370dee [SWAP]\n```\n\nPour ceux qui utilisent GPT, utilisez la commande blkid à la place. Ce dernier est plus pratique pour les scripts, mais plus difficile à lire.\n\n```\n# blkid\n```\n\n```\n/dev/sda1: UUID=\"CBB6-24F2\" TYPE=\"vfat\" PARTLABEL=\"EFI SYSTEM PARTITION\" PARTUUID=\"d0d0d110-0a71-4ed6-936a-304969ea36af\"\n/dev/sda2: LABEL=\"SYSTEM\" UUID=\"0a3407de-014b-458b-b5c1-848e92a327a3\" TYPE=\"ext4\" PARTLABEL=\"GNU/LINUX\" PARTUUID=\"98a81274-10f7-40db-872a-03df048df366\"\n/dev/sda3: LABEL=\"DATA\" UUID=\"b411dc99-f0a0-4c87-9e05-184977be8539\" TYPE=\"ext4\" PARTLABEL=\"HOME\" PARTUUID=\"7280201c-fc5d-40f2-a9b2-466611d3d49e\"\n/dev/sda4: UUID=\"f9fe0b69-a280-415d-a03a-a32752370dee\" TYPE=\"swap\" PARTLABEL=\"SWAP\" PARTUUID=\"039b6c1c-7553-4455-9537-1befbc9fbc5b\"\n```\n\n"
    },
    {
      "title": "by-label",
      "level": 3,
      "content": "Presque tous les types de systèmes de fichiers peuvent avoir une étiquette (label). Toutes vos partitions qui en ont une sont listées dans le répertoire /dev/disk/by-label.\n\n```\n$ ls -l /dev/disk/by-label\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 DATA -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 SYSTEM -> ../../sda2\n```\n\nLa plupart des systèmes de fichiers permettent de définir l'étiquette à la création du système de fichiers, consultez la page de manuel de l'utilitaire mkfs.* correspondant. Pour certains systèmes de fichiers, il est également possible de modifier les étiquettes. Voici quelques méthodes pour modifier les étiquettes des systèmes de fichiers courants :\n\nL'étiquette d'un périphérique peut être obtenu avec lsblk :\n\n```\n$ lsblk -dno LABEL /dev/sda2\n```\n\n```\nArch Linux\n```\n\nOu avec blkid :\n\n```\n# blkid -s LABEL -o value /dev/sda2\n```\n\n```\nArch Linux\n```\n\n- Le système de fichiers ne doit pas être monté pour changer son étiquette. Pour le système de fichiers racine, cela peut être réalisé en démarrant à partir d'un autre volume.\n- Les étiquettes doivent être sans ambiguïté pour éviter tout conflit éventuel.\n- Les étiquettes peuvent comporter jusqu'à 16 caractères.\n- Comme l'étiquette est une propriété du système de fichiers, elle ne convient pas pour adresser un seul périphérique RAID de manière persistante.\n- Lorsque vous utilisez des conteneurs chiffrés avec dm-crypt, les étiquettes des systèmes de fichiers à l'intérieur des conteneurs ne sont pas disponibles tant que le conteneur est verrouillé/chiffré.\n\n"
    },
    {
      "title": "by-uuid",
      "level": 3,
      "content": "UUID est un mécanisme pour donner à chaque système de fichiers un identifiant unique.\n\nCes identificateurs sont générés par les utilitaires du système de fichiers (par ex: mkfs.*) quand les partitions sont formatées et sont définies de manière à ce que les collisions soient improbables. Tous les systèmes de fichiers GNU/Linux (y compris les en-têtes de swap et LUKS des périphériques chiffrés bruts) prennent en charge les UUID. Les systèmes de fichiers FAT et NTFS (label fat et windows ci-dessus) ne prennent pas en charge les UUID, mais sont toujours listés dans /dev/disk/by-uuid avec un UID plus court (identifiant unique).\n\n```\n$ ls -l /dev/disk/by-uuid/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 0a3407de-014b-458b-b5c1-848e92a327a3 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 b411dc99-f0a0-4c87-9e05-184977be8539 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 CBB6-24F2 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 f9fe0b69-a280-415d-a03a-a32752370dee -> ../../sda4\n```\n\nL'UUID d'un périphérique peut être obtenu avec lsblk :\n\n```\n$ lsblk -dno UUID /dev/sda1\n```\n\n```\nCBB6-24F2\n```\n\nOu avec blkid :\n\n```\n# blkid -s UUID -o value /dev/sda1\n```\n\n```\nCBB6-24F2\n```\n\nL'avantage de la méthode UUID est qu'il est beaucoup moins probable que des collisions de noms se produisent qu'avec les étiquettes. De plus, il est généré automatiquement lors de la création du système de fichiers. Il restera, par exemple, unique même si l'appareil est branché à un autre système (qui peut avoir un appareil avec la même étiquette).\n\nL'inconvénient est que les UUIDs rendent les longues lignes de code difficiles à lire et rompent le formatage dans de nombreux fichiers de configuration (par ex: fstab ou crypttab). Aussi chaque fois qu'une partition est redimensionnée ou reformatée, un nouvel UUID est généré et les configurations doivent être ajustées manuellement.\n\n"
    },
    {
      "title": "by-id et by-path",
      "level": 3,
      "content": "by-id crée un nom unique en fonction du numéro de série du matériel, by-path en fonction du chemin physique le plus court (selon sysfs). Les deux contiennent des chaînes de caractères pour indiquer à quel sous-système elles appartiennent (c'est-à-dire pci- pour by-path, et ata- pour by-id), donc ils sont reliés au matériel qui contrôle l'appareil.\n\nCeci implique différents niveaux de persistance: le by-path changera lorsque l'appareil est branché sur un port différent du contrôleur, le by-path changera lorsque l'appareil est branché sur un port d'un contrôleur matériel soumis à un autre sous-système [1]. Par conséquent, les deux ne conviennent pas pour obtenir un nommage persistant tolérant aux changements de matériel.\n\nCependant, les deux fournissent des informations importantes pour trouver un périphérique particulier dans une grande infrastructure matérielle. Par exemple, si vous n'attribuez pas manuellement des étiquettes persistantes (by-label ou by-partlabel) et que vous conservez un répertoire avec l'utilisation du port matériel, by-id et by-path peuvent être utilisés pour trouver un périphérique particulier. [2] [3]\n\nby-id crée également des liens World Wide Name de périphériques de stockage qui le prennent en charge. Contrairement aux autres liens by-id, les WWN sont entièrement persistants et ne changent pas en fonction du sous-système utilisé.\n\n```\n$ ls -l /dev/disk/by-id/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470 -> ../../sda\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part1 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part2 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part3 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part4 -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 mmc-SD32G_0x0040006d -> ../../mmcblk0\nlrwxrwxrwx 1 root root 10 May 27 23:31 mmc-SD32G_0x0040006d-part1 -> ../../mmcblk0p1\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f -> ../../sda\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part1 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part2 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part3 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part4 -> ../../sda4\n```\n\n```\n$ ls -l /dev/disk/by-path/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1 -> ../../sda\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part1 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part2 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part3 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part4 -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:07:00.0-platform-rtsx_pci_sdmmc.0 -> ../../mmcblk0\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:07:00.0-platform-rtsx_pci_sdmmc.0-part1 -> ../../mmcblk0p1\n```\n\n"
    },
    {
      "title": "NVMe",
      "level": 4,
      "content": "Les identifiants de périphériques NVMe persistants sont préfixés par nvme- [4], par opposition à wwn-. Le World Wide Name utilisé est un format plus moderne du Extended Unique Identifier (EUI) par rapport à la plupart des périphériques ATA ou SCSI.\n\n```\n$ ls -l /dev/disk/by-id/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 13 Feb 12 16:28 nvme-eui.002538570142d716 -> ../../nvme1n1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 nvme-eui.002538570142d716-part1 -> ../../nvme1n1p1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 nvme-eui.002538570142d716-part2 -> ../../nvme1n1p2\nlrwxrwxrwx 1 root root 13 Feb 12 16:28 nvme-eui.e8238fa6bf530001001b448b4566aa1a -> ../../nvme0n1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 nvme-eui.e8238fa6bf530001001b448b4566aa1a-part1 -> ../../nvme0n1p1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 nvme-eui.e8238fa6bf530001001b448b4566aa1a-part2 -> ../../nvme0n1p2\nlrwxrwxrwx 1 root root 13 Feb 12 16:28 nvme-Samsung_SSD_970_EVO_Plus_2TB_S4J4NJ0N704064T -> ../../nvme1n1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 nvme-Samsung_SSD_970_EVO_Plus_2TB_S4J4NJ0N704064T-part1 -> ../../nvme1n1p1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 nvme-Samsung_SSD_970_EVO_Plus_2TB_S4J4NJ0N704064T-part2 -> ../../nvme1n1p2\nlrwxrwxrwx 1 root root 13 Feb 12 16:28 nvme-WDS100T1X0E-00AFY0_21455A801268 -> ../../nvme0n1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 nvme-WDS100T1X0E-00AFY0_21455A801268-part1 -> ../../nvme0n1p1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 nvme-WDS100T1X0E-00AFY0_21455A801268-part2 -> ../../nvme0n1p2\n```\n\n```\n$ ls -l /dev/disk/by-path/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 13 Feb 12 16:28 pci-0000:01:00.0-nvme-1 -> ../../nvme0n1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 pci-0000:01:00.0-nvme-1-part1 -> ../../nvme0n1p1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 pci-0000:01:00.0-nvme-1-part2 -> ../../nvme0n1p2\nlrwxrwxrwx 1 root root 13 Feb 12 16:28 pci-0000:04:00.0-nvme-1 -> ../../nvme1n1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 pci-0000:04:00.0-nvme-1-part1 -> ../../nvme1n1p1\nlrwxrwxrwx 1 root root 15 Feb 12 16:28 pci-0000:04:00.0-nvme-1-part2 -> ../../nvme1n1p2\n```\n\n"
    },
    {
      "title": "by-partlabel",
      "level": 3,
      "content": "Les étiquettes de partition peuvent être définis dans l'en-tête de l'entrée de partition sur les disques GPT.\n\nCette méthode est très similaire aux étiquettes du système de fichiers, sauf que le répertoire dynamique est /dev/disk/by-partlabel.\n\n```\nls -l /dev/disk/by-partlabel/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 EFI\\x20SYSTEM\\x20PARTITION -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 GNU\\x2fLINUX -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 HOME -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 SWAP -> ../../sda4\n```\n\nL'étiquette de partition d'un périphérique peut être obtenue avec lsblk :\n\n```\n$ lsblk -dno PARTLABEL /dev/sda1\n```\n\n```\nPartition Système EFI\n```\n\nOu avec blkid :\n\n```\n# blkid -s PARTLABEL -o value /dev/sda1\n```\n\n```\nPartition Système EFI\n```\n\n- Les étiquettes de partition GPT doivent également être différentes pour éviter les conflits. Pour changer l'étiquette de votre partition, vous pouvez utiliser gdisk ou la version basée sur ncurses cgdisk. Les deux sont disponibles à partir du paquet gptfdisk. Consultez les outils de partitionnement (en).\n- Selon la spécification, les étiquettes de partition GPT peuvent contenir jusqu' à 72 caractères.\n\n"
    },
    {
      "title": "by-partuuid",
      "level": 3,
      "content": "Comme les étiquettes de partition GPT, les UUID de partition GPT sont définis dans l'entrée de partition sur les disques GPT.\n\nLe répertoire dynamique est similaire à d'autres méthodes et, comme les systèmes de fichiers UUID, l'utilisation des UUID est préférable aux étiquettes.\n\n```\nls -l /dev/disk/by-partuuid/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 039b6c1c-7553-4455-9537-1befbc9fbc5b -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 7280201c-fc5d-40f2-a9b2-466611d3d49e -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 98a81274-10f7-40db-872a-03df048df366 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 d0d0d110-0a71-4ed6-936a-304969ea36af -> ../../sda1\n```\n\nL'UUID de la partition d'un périphérique peut être obtenu avec lsblk :\n\n```\n$ lsblk -dno PARTUUID /dev/sda1\n```\n\n```\nd0d0d110-0a71-4ed6-936a-304969ea36af\n```\n\nOu avec blkid :\n\n```\n# blkid -s PARTUUID -o value /dev/sda1\n```\n\n```\nd0d0d110-0a71-4ed6-936a-304969ea36af\n```\n\n"
    },
    {
      "title": "Noms de périphériques statiques avec Udev",
      "level": 3,
      "content": "Voir udev (Français)#Définition de noms de périphériques statiques\n\n"
    },
    {
      "title": "Utilisation des noms persistants",
      "level": 2,
      "content": "Il existe plusieurs applications qui peuvent être configurées à l'aide de noms persistants. Ci-dessous quelques exemples et la façon de les configurer.\n\n"
    },
    {
      "title": "fstab",
      "level": 3,
      "content": "Voir l'article Fstab (Français)#Identification des systèmes de fichiers\n\n"
    },
    {
      "title": "Paramètres du noyau",
      "level": 3,
      "content": "Pour utiliser des noms persistants dans les paramètres du noyau, les conditions préalables suivantes doivent être remplies. Lors d'une installation standard qui a suivi le guide d'installation ces deux prérequis sont remplis :\n\n- Vous utilisez une initramfs avec udev inclus.\n- Pour Mkinitcpio, vous avez activé le hook udev ou systemd dans /etc/mkinitcpio.conf\n\nL'emplacement du système de fichiers racine est donné par le paramètre root sur la ligne de commande du noyau. La ligne de commande du noyau est configurée à partir du chargeur d'amorçage, consultez Kernel parameters#Boot loader configuration. Pour changer le nom d'un périphérique persistant, ne modifiez que les paramètres qui spécifient les périphériques de type bloc, par exemple : root et resume, tout en laissant les autres paramètres tels quels. Différents schémas de nommage sont pris en charge:\n\nNommage des périphériques persistants utilisant l'étiquette et le format LABEL=, dans cet exemple Arch Linux est l'étiquette du système de fichiers racine.\n\n```\nroot=\"LABEL=Arch Linux\"\n```\n\nNommage persistant des périphériques utilisant l'UUID et le format UUID=, dans cet exemple 0a3407de-014b-458b-b5c1-848e92a327a3 est l'UUID du système de fichiers racine.\n\n```\nroot=UUID=0a3407de-014b-458b-b5c1-848e92a327a3\n```\n\nNommage de périphérique persistant utilisant l'id du disque et le format de chemin /dev, dans cet exemple wwn-0x60015ee0000b237f-part2 est l'id de la partition racine.\n\n```\nroot=/dev/disk/by-id/wwn-0x60015ee0000b237f-part2\n```\n\nNommage du périphérique persistant utilisant l'UUID de la partition GPT et le format PARTUUID=, dans cet exemple 98a81274-10f7-40db-872a-03df048df366 est le PARTUUID de la partition racine.\n\n```\nroot=PARTUUID=98a81274-10f7-40db-872a-03df048df366\n```\n\nNommage de périphérique persistant utilisant l'étiquette de partition GPT et le format PARTLABEL=, dans cet exemple GNU/Linux est le PARTLABEL de la partition racine.\n\n```\nroot=\"PARTLABEL=GNU/Linux\"\n```\n\n"
    }
  ]
}