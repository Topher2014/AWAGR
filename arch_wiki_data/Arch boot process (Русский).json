{
  "title": "Arch boot process (Русский)",
  "url": "https://wiki.archlinux.org/title/Arch_boot_process_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Главная загрузочная запись\n- Таблица разделов GUID\n- Unified Extensible Firmware Interface (Русский)\n- mkinitcpio (Русский)\n- init\n- systemd (Русский)\n- fstab (Русский)\n- Автозапуск\n\nДля загрузки Arch Linux необходим совместимый с Linux загрузчик. Загрузчик должен загрузить ядро и initial ramdisk в память перед запуском системы. Процесс несколько отличается для BIOS и UEFI; подробное описание дано ниже и на связанных страницах.\n\n"
    },
    {
      "title": "Типы прошивок",
      "level": 2,
      "content": "Прошивка (микропрограмма, firmware) — это самая первая программа, которая выполняется при включении системы.\n\n"
    },
    {
      "title": "BIOS",
      "level": 3,
      "content": "BIOS, или Basic Input-Output System, чаще всего всего хранится во flash-памяти, распаянной непосредственно на материнской плате, и не зависит от системного устройства хранения данных. Изначально создавалась для IBM PC для инициализации устройств и процесса загрузки. С 2010 года постепенно заменена на UEFI, которая не имеет технических ограничений, которые были у BIOS.\n\n"
    },
    {
      "title": "UEFI",
      "level": 3,
      "content": "Unified Extensible Firmware Interface может считывать как таблицу разделов, так и файловые системы. UEFI не выполняет загрузочный код в MBR, вне зависимости от того, существует он или нет. Вместо этого загрузка происходит в соответствии с записями в NVRAM.\n\nСпецификация UEFI объявляет обязательными поддержку файловых систем FAT12, FAT16 и FAT32 (UEFI specification version 2.9, section 13.3.1.1), но производители могут добавлять и другие файловые системы; например, HFS+ или APFS в некоторых прошивках Apple. Также реализации UEFI поддерживают формат оптических дисков ISO-9660.\n\nUEFI запускает так называемые EFI-приложения, например, загрузчики, менеджеры загрузки, UEFI Shell и т.д. Эти приложения обычно хранятся в виде файлов в системном разделе EFI. Каждый производитель может хранить свои файлы в EFI-разделе в каталоге /EFI/производитель. Приложения можно запустить с помощью загрузочной записи в NVRAM или из UEFI-оболочки.\n\nВ спецификации UEFI также предусмотрена legacy-загрузка через BIOS посредством Compatibility Support Module (CSM). UEFI с включённым CSM сгенерирует загрузочные CSM-записи для всех дисков. Если для загрузки выбрана именно такая запись, то CSM попытается выполнить код из MBR на диске.\n\n"
    },
    {
      "title": "Система с BIOS",
      "level": 3,
      "content": "1. Компьютер включается, выполняется power-on self-test (POST).\n1. После POST BIOS инициализирует аппаратуру, необходимую для загрузки (диск, контроллеры клавиатуры и т.д.).\n1. BIOS запускает на выполнение первые 440 байт (MBR bootstrap code area) первого (в очерёдности загрузки) диска.\n1. Код первого этапа загрузчика в MBR загружает и запускает код второго этапа загрузчика (если таковой имеется), который может храниться в следующих местах: следующие сектора диска после MBR, например, т.н. \"post-MBR gap\" (только в случае таблицы разделов MBR). volume boot record (VBR) раздела или partitionless-диска. загрузочный раздел BIOS (только GRUB с BIOS/GPT).\n1. Запускается непосредственно загрузчик.\n1. Загрузчик загружает в память операционную систему либо напрямую, либо посредством цепной загрузки (chain-loading).\n\n- следующие сектора диска после MBR, например, т.н. \"post-MBR gap\" (только в случае таблицы разделов MBR).\n- volume boot record (VBR) раздела или partitionless-диска.\n- загрузочный раздел BIOS (только GRUB с BIOS/GPT).\n\n"
    },
    {
      "title": "Система с UEFI",
      "level": 3,
      "content": "1. Компьютер включается, выполняется power-on self-test (POST).\n1. После POST UEFI инициализирует аппаратуру, необходимую для загрузки (диск, контроллеры клавиатуры и т.д.).\n1. Прошивка считывает загрузочные записи из NVRAM, чтобы определить, какое EFI-приложение необходимо запустить и откуда (т.е. с какого диска и раздела). Загрузочной записью может быть просто диск. В этом случае прошивка ищет системный раздел EFI на этом диске и EFI-приложение на резервном пути загрузки \\EFI\\BOOT\\BOOTx64.EFI (в системах с 32-битным UEFI — BOOTIA32.EFI). Именно так UEFI работает со съёмными загрузочными устройствами.\n1. Прошивка запускает EFI-приложение. Это может быть загрузчик или, при использовании EFISTUB, непосредственно ядро Arch Linux. Это также может быть и какое-то другое приложение, например, командная оболочка UEFI или менеджер загрузки вроде systemd-boot или rEFInd.\n\n- Загрузочной записью может быть просто диск. В этом случае прошивка ищет системный раздел EFI на этом диске и EFI-приложение на резервном пути загрузки \\EFI\\BOOT\\BOOTx64.EFI (в системах с 32-битным UEFI — BOOTIA32.EFI). Именно так UEFI работает со съёмными загрузочными устройствами.\n\n- Это может быть загрузчик или, при использовании EFISTUB, непосредственно ядро Arch Linux.\n- Это также может быть и какое-то другое приложение, например, командная оболочка UEFI или менеджер загрузки вроде systemd-boot или rEFInd.\n\nЕсли включён режим Secure Boot, аутентичность двоичного EFI-файла будет проверена по его подписи.\n\n"
    },
    {
      "title": "Мультизагрузка в UEFI",
      "level": 4,
      "content": "Поскольку файлы различных операционных систем и производителей хранятся в системном разделе EFI в разных каталогах, мультизагрузка с UEFI сводится к запуску EFI-приложения загрузчика конкретной операционной системы. Это позволяет отказаться от использования chain loading при загрузке различных ОС.\n\nСмотрите также Двойная загрузка: Windows и Arch.\n\n"
    },
    {
      "title": "Загрузчик",
      "level": 2,
      "content": "Загрузчик — программа, которая запускается прошивкой (BIOS или UEFI). Эта программа в соответствии с файлами настроек загружает ядро с заданными параметрами, а также начальный загрузочный диск. В случае UEFI ядро может быть загружено напрямую, без загрузчика, посредством EFISTUB; в этом случае загрузчик или менеджер загрузки можно использовать для редактирования параметров ядра перед загрузкой.\n\n"
    },
    {
      "title": "Сравнение возможностей",
      "level": 3,
      "content": "- Поскольку GPT является частью спецификации UEFI, все UEFI-загрузчики поддерживают GPT-диски. GPT на BIOS-системах также возможен, либо посредством \"гибридной загрузки\" с Hybrid MBR, либо с новым протоколом загрузки GPT-only. Этот протокол, однако, может стать причиной проблем в некоторых реализациях BIOS (подробнее см. rodsbooks).\n- Под шифрованием, которое упоминается применительно к файловым системам, подразумевается шифрование на уровне ФС, а не шифрование на уровне блоков.\n\nTable content:\nНазвание | Прошивка | Таблица разделов | Мультизагрузка | Файловые системы | Примечания\nBIOS | UEFI | MBR | GPT | Btrfs | ext4 | ReiserFS | VFAT | XFS\nEFISTUB | – | Да | Да | Да | – | – | – | – | Наследуется от прошивки1 | – | Ядро является EFI-приложением и загружается напрямую из UEFI или другим загрузчиком.\nUnified kernel image | – | Да | Да | Да | – | – | – | – | Наследуется от прошивки1 | – | systemd-stub(7), ядро, initramfs и командная строка ядра упакованы в исполняемый файл EFI для загрузки непосредственно из прошивки UEFI или другого загрузчика.\nGRUB | Да | Да | Да | Да | Да | Да | Да | Да | Да | Да | В конфигурации BIOS/GPT требует загрузочный раздел BIOS. Поддерживает RAID, LUKS1 и LVM (но не thin provisioned тома).\nLimine | Да | Да | Да | Да | Да | Нет | Без шифрования | Нет | Да | Нет | \nrEFInd | Нет | Да | Да | Да | Да2 | Без шифрования | Без шифрования | Без tail-packing | Наследуется от прошивки1 | Нет | Поддерживает автообнаружение ядер и параметров без явной конфигурации, а также fastboot [3].\nSyslinux | Да | Частично | Да | Да | Частично | Без: multi-device тома, сжатие, шифрование | Без шифрования | Нет | Да | Только MBR; без sparse inodes | Не поддерживает некоторые особенности файловых систем [4]. Не имеет драйверов файловых систем [5], может работать только с той ФС, на которую установлен.\nsystemd-boot | Нет | Да | Только ручная установка | Да | Да2 | Sideload3 | Sideload3 | Sideload3 | Наследуется от прошивки1 | Sideload3 | Запускает двоичные файлы только из разделов ESP и Extended Boot Loader Partition (XBOOTLDR). Автоматически определяет unified kernel image в каталоге esp/EFI/Linux.\nGRUB Legacy | Да | Нет | Да | Нет | Да | Нет | Нет | Да | Да | Только XFSv4 | Разработка прекращена в пользу GRUB.\nLILO | Да | Нет | Да | Нет | Да | Нет | Без шифрования | Да | Да | Да | Разработа прекращена из-за ограничений (например, с Btrfs, GPT, RAID).\n\n1. Поддержка файловой системы \"унаследована\" от прошивки. Спецификация UEFI объявляет обязательной поддержку файловых систем FAT12, FAT16 и FAT32 [6], но производители могут добавлять собственные ФС; например, компьютеры Apple Mac поддерживают файловую систему HFS+. Если прошивка имеет интерфейс для загрузки драйверов UEFI при запуске системы, то можно подключить дополнительные файловые системы, загрузив их (сторонние) драйвера.\n1. Менеджер загрузки. Может только запускать другие EFI-приложения, например, ядро Linux (собранное с флагом CONFIG_EFI_STUB=y) или Windows bootmgfw.efi.\n1. systemd-boot поддерживает загрузку UEFI-драйверов файловых систем. Они предоставляются пакетом efifs и должны быть помещены в каталог esp/EFI/systemd/drivers/.\n\nСм. также Wikipedia:Comparison of boot loaders.\n\n"
    },
    {
      "title": "Ядро",
      "level": 2,
      "content": "Ядро — сердце операционной системы. Оно функционирует на низком уровне (т.н. kernelspace, пространство ядра), являясь посредником между аппаратным обеспечением компьютера и прикладными программами. Ядро периодически приостанавливает выполнение одних программ, чтобы предоставить процессорное время другим (т.н. вытесняющая многозадачность). Это создаёт видимость того, что множество задач выполняются параллельно, даже на одноядерном процессоре. Ядро использует планировщик времени процессора для определения процесса, имеющего наибольший приоритет в данный момент.\n\n"
    },
    {
      "title": "initramfs",
      "level": 2,
      "content": "Загрузчик перемещает ядро и имеющиеся файлы initramfs в память и запускает ядро. В начале работы ядро распаковывает архивы с initramfs (initial RAM filesystem, начальная файловая система) в пока что пустующую rootfs (первоначальная корневая файловая система, чаще всего ramfs или tmpfs). Сначала извлекается initramfs, которая была встроена в двоичный файл ядра в процессе сборки, а затем — внешние initramfs-файлы, если таковые имеются. Файлы внешней initramfs перезаписывают одноименные файлы встроенной. После этого ядро запускает в rootfs /init как первый процесс. Начинается раннее пространство пользователя (early userspace).\n\nОфициальные ядра Arch Linux используют в качестве встроенной initramfs пустой архив (используется по умолчанию при сборке Linux). Внешние образы initramfs можно сгенерировать с помощью mkinitcpio, dracut и booster.\n\nНазначение initramfs — загрузить систему до состояния, в котором она может работать с корневой файловой системой (подробнее см. FHS). Это означает, что любые модули, которые необходимы устройствам IDE, SCSI, SATA, USB/FW (при загрузке с внешнего носителя) и не были встроены в ядро, должны загружаться из initramfs; после подключения необходимых модулей (программой/сценарием или неявно udev), процесс загрузки продолжается. В initramfs должны быть только модули, необходимые для доступа к корневой файловой системе; нет необходимости хранить в ней все модули, которые однажды теоретически могут понадобиться. Большинство таких модулей будут позже загружены менеджером устройств udev во время работы процесса init.\n\n"
    },
    {
      "title": "Процесс init",
      "level": 2,
      "content": "В завершающей фазе early userspace монтируется настоящий корневой каталог, замещающий начальную корневую ФС. Выполняется /sbin/init, который заменяет процесс /init. В Arch Linux в качестве init по умолчанию используется systemd.\n\n"
    },
    {
      "title": "getty",
      "level": 2,
      "content": "init запускает для каждого виртуального терминала (обычно их шесть) программу getty, которая инициализирует терминалы и запрашивает имя пользователя и пароль. Предоставленные входные данные getty проверяет по файлам /etc/passwd и /etc/shadow, после чего вызывает login или запускает менеджер экрана, если таковой имеется.\n\n"
    },
    {
      "title": "Менеджер экрана",
      "level": 2,
      "content": "Вместо приглашения входа getty можно использовать экранный менеджер.\n\nЧтобы менеджер экрана запускался автоматически сразу после загрузки, необходимо вручную включить соответствующую службу systemd. Подробнее о включении и запуске служб см. systemd#Использование юнитов.\n\n"
    },
    {
      "title": "Вход",
      "level": 2,
      "content": "Программа login создаёт сеанс для пользователя. Она устанавливает переменные окружения и запускает командую оболочку в соответствии с файлом /etc/passwd.\n\nПосле успешного входа (и перед запуском оболочки) login выводит содержимое файла /etc/motd (message of the day, сообщение дня). Используйте его, чтобы напомнить пользователям о правилах работы, политиках и т.п.\n\n"
    },
    {
      "title": "Оболочка",
      "level": 2,
      "content": "Прежде чем вывести строку приглашения, сразу после запуска командная оболочка исполняет файл настроек времени выполнения, вроде bashrc. Если для учётной записи настроен запуск X при входе, то в файле настроек должен вызываться либо startx, либо xinit.\n\n"
    },
    {
      "title": "GUI, xinit или wayland",
      "level": 2,
      "content": "xinit выполняет файл настроек xinitrc, в котором обычно запускается оконный менеджер. При выходе пользователя из оконного менеджера он возвращается в getty, по очереди завершая xinit, startx, командную оболочку и login.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Early Userspace in Arch Linux\n- Inside the Linux boot process\n- Википедия:Процесс загрузки Linux\n- Википедия:initrd\n- Boot Linux Grub Into Single User Mode\n- NeoSmart: The BIOS/MBR Boot Process\n- Kernel Newbie Corner: initrd and initramfs\n- Rod Smith - Managing EFI Boot Loaders for Linux\n\n"
    }
  ]
}