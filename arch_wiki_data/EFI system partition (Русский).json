{
  "title": "EFI system partition (Русский)",
  "url": "https://wiki.archlinux.org/title/EFI_system_partition_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Unified Extensible Firmware Interface (Русский)\n- Загрузчик\n\nСистемный раздел EFI (EFI system partition, также называемый ESP или EFISYS) — это независимый от ОС раздел, который служит местом хранения загрузчиков UEFI и приложений, которые будут запускаться прошивкой UEFI. Он необходим для загрузки системы в режиме UEFI.\n\n"
    },
    {
      "title": "Проверка существования раздела",
      "level": 2,
      "content": "Если вы устанавливаете Arch Linux на компьютер с поддержкой UEFI и предустановленной ОС, например, Windows 10, то вполне вероятно, что у вас уже есть системный раздел EFI.\n\nЧтобы посмотреть схему разделов диска и системный раздел, запустите fdisk от имени root, указав диск, с которого вы хотите загрузиться:\n\n```\n# fdisk -l /dev/sdx\n```\n\nЭта команда выведет:\n\n- Таблицу разделов диска: GPT будет обозначен как Тип метки диска: gpt, а MBR — как Тип метки диска: dos.\n- Список разделов на диске: поищите в списке системный раздел EFI, он обычно имеет размер не менее 100 МиБ и тип EFI System или EFI (FAT-12/16/32). Чтобы убедиться, что это ESP, смонтируйте его и проверьте, содержит ли он каталог с именем EFI; если да, то это точно ESP.\n\nЕсли вы нашли существующий системный раздел EFI, просто переходите к разделу #Монтирование раздела. Если раздел не нашёлся, его нужно создать: #Создание раздела.\n\n"
    },
    {
      "title": "Создание раздела",
      "level": 2,
      "content": "В следующих двух разделах показано, как создать системный раздел EFI (ESP).\n\nРаздел должен иметь достаточно большой размер для хранения загрузчиков и других файлов, необходимых для загрузки.\n\nРекомендуется сделать раздел размером 1 ГиБ, чтобы в нём было достаточно места для размещения нескольких ядер или unified kernel images, загрузчика, файлов обновлений прошивки и любых других файлов операционной системы или OEM. Если всё равно есть сомнения, то 4 ГиБ должно хватить всем.\n\n- Для ранних и/или несовершенных реализаций UEFI может потребоваться размер не менее 512 МиБ.[1]\n- Если вы планируете монтировать системный раздел EFI как /boot и при этом использовать только одно ядро, то 400 МиБ должно хватить.\n- При двойной загрузке с Windows размер должен составлять не менее 300 МиБ для дисков с размером логического сектора 4096 байт (диски Advanced Format 4Kn)[2] или не менее 100 МиБ в других случаях.[3]\n- Для форматирования в FAT32 размер раздела должен быть не менее 36 МиБ при размере сектора 512 байт и не менее 260 МиБ при размере сектора 4096 байт.[4]\n- Если ни одна из этих проблем не актуальна, размер раздела может составлять всего 2 МиБ, хотя тогда в него не поместится ничего кроме загрузчика.\n\n"
    },
    {
      "title": "Разметка дисков GPT",
      "level": 3,
      "content": "Системный раздел EFI в таблице разделов GUID идентифицируется с помощью GUID типа раздела C12A7328-F81F-11D2-BA4B-00A0C93EC93B.\n\nВыберите один из следующих способов создания ESP для диска GPT с разделами:\n\n- fdisk: Создайте раздел и измените тип раздела на EFI System.\n- gdisk: Создайте раздел с типом раздела EF00.\n- GNU Parted: Создайте раздел fat32 и в Parted активируйте флаг esp.\n\nПосле создания раздел нужно отформатировать; переходите к разделу #Форматирование раздела.\n\n"
    },
    {
      "title": "Разметка дисков MBR",
      "level": 3,
      "content": "Note: Подробнее об ограничениях MBR и преимуществах GPT смотрите в разделе Разметка дисков#Выбор между GPT и MBR.\n\n- Некоторые прошивки могут не поддерживать загрузку UEFI/MBR из-за того, что она не поддерживается установкой Windows.\n- bootctl не поддерживает установку systemd-boot на MBR-диск; смотрите systemd issue 1125.\n\nПодробнее об ограничениях MBR и преимуществах GPT смотрите в разделе Разметка дисков#Выбор между GPT и MBR.\n\nСистемный раздел EFI в главной загрузочной записи идентифицируется с помощью partition ID EF.\n\nВыберите один из следующих способов создания ESP для диска MBR с разделами:\n\n- fdisk: Создайте первичный раздел и измените тип раздела на (EFI (FAT-12/16/32).\n- GNU Parted: Создайте первичный раздел fat32 и в Parted активируйте флаг esp.\n\nПосле создания раздел нужно отформатировать; переходите к разделу #Форматирование раздела.\n\n"
    },
    {
      "title": "Форматирование раздела",
      "level": 2,
      "content": "Спецификация UEFI предусматривает поддержку файловых систем FAT12, FAT16 и FAT32 (UEFI specification version 2.10, section 13.3.1.1), но производители могут по желанию добавить поддержку дополнительных файловых систем; например, прошивки компьютеров Apple Mac поддерживают файловую систему HFS+.\n\nДля предотвращения возможных проблем с другими операционными системами и поскольку в спецификации UEFI говорится, что UEFI «включает использование FAT32 для системного раздела и FAT12 или FAT16 для съёмных носителей»[5], рекомендуется использовать FAT32. Используйте утилиту mkfs.fat(8) из пакета dosfstools:\n\n```\n# mkfs.fat -F 32 /dev/sdxY\n```\n\nЕсли вы получили сообщение WARNING: Not enough clusters for a 32 bit FAT! и у вас нет возможности увеличить размер раздела, уменьшите размер кластера с помощью команды mkfs.fat -s2 -F32 ... или -s1; иначе раздел может оказаться нечитаемым для UEFI. Поддерживаемые размеры кластера можно посмотреть в mkfs.fat(8).\n\nДля разделов размером менее 32 МиБ использовать FAT32 не получится. В этом случае отформатируйте его в FAT16 или даже FAT12. Например, ESP размером 2 МиБ будет поддерживать только FAT12:\n\n```\n# mkfs.fat -F 12 /dev/sdxY\n```\n\n"
    },
    {
      "title": "Монтирование раздела",
      "level": 2,
      "content": "Ядра, файлы initramfs и, в большинстве случаев, микрокод процессора должны быть доступны загрузчику или самому UEFI для успешной загрузки системы. Таким образом, если вы хотите сохранить простоту установки, выбор загрузчика ограничивает варианты выбора точки монтирования для системного раздела EFI.\n\nNote: В качестве альтернативы можно заранее загрузить необходимые модули ядра, например:\n\nВ качестве альтернативы можно заранее загрузить необходимые модули ядра, например:\n\n```\n/etc/modules-load.d/vfat.conf\n```\n\n```\nvfat\nnls_cp437\nnls_ascii\n```\n\n"
    },
    {
      "title": "Типичные точки монтирования",
      "level": 3,
      "content": "Есть три основных варианта монтирования системного раздела EFI.\n\n- Монтирование ESP в /boot: Это облегчает обслуживание и администрирование системы, поскольку /boot является путём по умолчанию, в который пакеты микрокода размещают файлы initramfs микрокода процессора, и в который mkinitcpio помещает ядра и образы initramfs. Это обеспечивает доступ к вышеупомянутым файлам для большинства загрузчиков, поскольку не все из них могут обращаться к файлам на других томах. Это предотвращает установку прав доступа и/или расширенных атрибутов отдельным файлам, поскольку FAT устанавливает глобальные права доступа во время монтирования. Это увеличивает необходимый размер раздела, поскольку к файлам, обычно находящимся в /boot, добавляются файлы, связанные с EFI. В случае двойной загрузки это приводит к тому, что специфичные для ОС загрузочные файлы могут подвергаться потенциально опасным манипуляциям со стороны других ОС. Это делает шифрование /boot невозможным, так как файлы, связанные с EFI, должны быть доступны прошивке.\n- Монтирование ESP в /efi: Это отделяет файлы, специфичные для ОС, от файлов, связанных с EFI. Это позволяет избежать увеличения размера ESP за счёт отказа от размещения в нём файлов, устанавливаемых в /boot: на ESP будут храниться только исполняемые файлы EFI (загрузчик (и, опционально, драйверы) и/или unified kernel image), что экономит место на разделе. Позволяет использовать специфические для Linux права доступа на уровне файловой системы для файлов, находящихся в /boot, без специфичных для FAT ограничений. Это позволяет монтировать ESP отдельно по необходимости, например, только во время обновления загрузчика. При шифровании системы с соответствующей настройкой это позволяет оставить незашифрованными лишь несколько минимально необходимых файлов, а /boot будет защищён: это может быть полезно для unified kernel image или загрузчиков, имеющих драйверы файловой системы, способные прочитать ядро и прочие файлы из другого места.\n- Монтирование ESP в /efi и дополнительно монтирование «Extended Boot Loader Partition» (XBOOTLDR) в /boot. Это может быть полезно, когда ранее созданный ESP слишком мал для размещения нескольких загрузчиков и/или ядер, но увеличить размер ESP проблематично (например, при установке Linux после Windows для двойной загрузки). Этот метод поддерживает как минимум systemd-boot.\n\n- Это облегчает обслуживание и администрирование системы, поскольку /boot является путём по умолчанию, в который пакеты микрокода размещают файлы initramfs микрокода процессора, и в который mkinitcpio помещает ядра и образы initramfs.\n- Это обеспечивает доступ к вышеупомянутым файлам для большинства загрузчиков, поскольку не все из них могут обращаться к файлам на других томах.\n- Это предотвращает установку прав доступа и/или расширенных атрибутов отдельным файлам, поскольку FAT устанавливает глобальные права доступа во время монтирования.\n- Это увеличивает необходимый размер раздела, поскольку к файлам, обычно находящимся в /boot, добавляются файлы, связанные с EFI.\n- В случае двойной загрузки это приводит к тому, что специфичные для ОС загрузочные файлы могут подвергаться потенциально опасным манипуляциям со стороны других ОС.\n- Это делает шифрование /boot невозможным, так как файлы, связанные с EFI, должны быть доступны прошивке.\n\n- Это отделяет файлы, специфичные для ОС, от файлов, связанных с EFI.\n- Это позволяет избежать увеличения размера ESP за счёт отказа от размещения в нём файлов, устанавливаемых в /boot: на ESP будут храниться только исполняемые файлы EFI (загрузчик (и, опционально, драйверы) и/или unified kernel image), что экономит место на разделе.\n- Позволяет использовать специфические для Linux права доступа на уровне файловой системы для файлов, находящихся в /boot, без специфичных для FAT ограничений.\n- Это позволяет монтировать ESP отдельно по необходимости, например, только во время обновления загрузчика.\n- При шифровании системы с соответствующей настройкой это позволяет оставить незашифрованными лишь несколько минимально необходимых файлов, а /boot будет защищён: это может быть полезно для unified kernel image или загрузчиков, имеющих драйверы файловой системы, способные прочитать ядро и прочие файлы из другого места.\n\n- Монтирование в /efi является заменой[6] для ранее распространённой и ныне не рекомендуемой точки монтирования /boot/efi.\n- Каталог /efi изначально отсутствует; его нужно предварительно создать.\n\n"
    },
    {
      "title": "Альтернативные точки монтирования",
      "level": 3,
      "content": "Если вы не используете #Типичные точки монтирования, вам будет нужно самостоятельно скопировать файлы, необходимые для загрузки, в ESP (далее обозначается как esp).\n\n```\n# mkdir -p esp/EFI/arch\n# cp -a /boot/vmlinuz-linux esp/EFI/arch/\n# cp -a /boot/initramfs-linux.img esp/EFI/arch/\n# cp -a /boot/initramfs-linux-fallback.img esp/EFI/arch/\n```\n\nКроме того, вам нужно будет поддерживать файлы на ESP в актуальном состоянии при последующих обновлениях ядра. Несоблюдение этого требования может привести к незагружаемой системе. В следующих разделах обсуждаются несколько механизмов для автоматизации этого процесса.\n\n"
    },
    {
      "title": "Использование bind-монтирования",
      "level": 4,
      "content": "Вместо того, чтобы монтировать целиком ESP в /boot, вы можете подключить отдельный каталог ESP к /boot с помощью bind-монтирования (смотрите mount(8)). Это позволяет pacman обновлять ядро напрямую, а вам — организовать файлы в ESP по своему вкусу.\n\nКак описано в начале раздела, скопируйте все загрузочные файлы в каталог вашего ESP, но смонтируйте ESP вне /boot. Затем выполните bind-монтирование каталога:\n\n```\n# mount --bind esp/EFI/arch/ /boot\n```\n\nЕсли всё хорошо, отредактируйте свой Fstab, чтобы сделать изменение постоянным:\n\n```\n/etc/fstab\n```\n\n```\nesp/EFI/arch /boot none defaults,bind 0 0\n```\n\n"
    },
    {
      "title": "Использование systemd",
      "level": 4,
      "content": "Systemd поддерживает задачи, запускаемые по событию. В данном конкретном случае возможность обнаружения изменения пути используется для синхронизации файлов ядра EFISTUB и initramfs, когда они обновляются в /boot/. Файл, который проверяется на изменения, это initramfs-linux-fallback.img, так как это последний файл, который собирает mkinitcpio, что позволяет убедиться, что все нужные файлы были собраны перед началом копирования. Файлы path и service, которые должны быть созданы, следующие:\n\n```\n/etc/systemd/system/efistub-update.path\n```\n\n```\n[Unit]\nDescription=Copy EFISTUB Kernel to EFI system partition\n\n[Path]\nPathChanged=/boot/initramfs-linux-fallback.img\n\n[Install]\nWantedBy=multi-user.target\nWantedBy=system-update.target\n```\n\n```\n/etc/systemd/system/efistub-update.service\n```\n\n```\n[Unit]\nDescription=Copy EFISTUB Kernel to EFI system partition\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/cp -af /boot/vmlinuz-linux esp/EFI/arch/\nExecStart=/usr/bin/cp -af /boot/initramfs-linux.img esp/EFI/arch/\nExecStart=/usr/bin/cp -af /boot/initramfs-linux-fallback.img esp/EFI/arch/\n```\n\nЗатем запустите и включите efistub-update.path.\n\n```\nExecStart=/usr/bin/sbsign --key /путь/к/db.key --cert /путь/к/db.crt --output esp/EFI/arch/vmlinuz-linux /boot/vmlinuz-linux\n```\n\n"
    },
    {
      "title": "Использование событий файловой системы",
      "level": 4,
      "content": "События файловой системы можно использовать для запуска скрипта, синхронизирующего ядро EFISTUB после обновления ядра. Ниже приведён пример с использованием incron.\n\n```\n/usr/local/bin/efistub-update\n```\n\n```\n#!/bin/sh\ncp -af /boot/vmlinuz-linux esp/EFI/arch/\ncp -af /boot/initramfs-linux.img esp/EFI/arch/\ncp -af /boot/initramfs-linux-fallback.img esp/EFI/arch/\n```\n\n```\n/etc/incron.d/efistub-update.conf\n```\n\n```\n/boot/initramfs-linux-fallback.img IN_CLOSE_WRITE /usr/local/bin/efistub-update\n```\n\nВключите службу incrond.service.\n\n"
    },
    {
      "title": "Использование хука mkinitcpio",
      "level": 4,
      "content": "Mkinitcpio может генерировать хук, для работы которого не нужен демон системного уровня. Он порождает фоновый процесс, который ожидает генерации vmlinuz, initramfs-linux.img и initramfs-linux-fallback.img перед копированием файлов.\n\nДобавьте efistub-update в список хуков в /etc/mkinitcpio.conf.\n\n```\n/etc/initcpio/install/efistub-update\n```\n\n```\n#!/usr/bin/env bash\nbuild() {\n\t/usr/local/bin/efistub-copy $$ &\n}\n\nhelp() {\n\tcat <<HELPEOF\nThis hook waits for mkinitcpio to finish and copies the finished ramdisk and kernel to the ESP\nHELPEOF\n}\n```\n\n```\n/usr/local/bin/efistub-copy\n```\n\n```\n#!/bin/sh\n\nif [ \"$1\" -gt 0 ]\nthen\n\twhile [ -e /proc/\"$1\" ]\n\tdo\n\t\tsleep .5\n\tdone\nfi\n\nrsync -a /boot/ esp/\n\necho \"Synced /boot with ESP\"\n```\n\n"
    },
    {
      "title": "Использование предустановки mkinitcpio",
      "level": 4,
      "content": "Поскольку предустановки в /etc/mkinitcpio.d/ поддерживают shell-скрипты, ядро и initramfs могут быть скопированы простым редактированием предустановок.\n\nИзмените файл /etc/mkinitcpio.d/linux.preset:\n\n```\n/etc/mkinitcpio.d/linux.preset\n```\n\n```\n# mkinitcpio preset file for the 'linux' package\n\n# Directory to install the kernel, the initramfs...\nESP_DIR=\"esp/EFI/arch\"\n\n#ALL_config=\"/etc/mkinitcpio.conf\"\nALL_kver=\"${ESP_DIR}/vmlinuz-linux\"\n[[ -e /boot/intel-ucode.img ]] && cp -af /boot/intel-ucode.img \"${ESP_DIR}/\"\n[[ -e /boot/amd-ucode.img ]] && cp -af /boot/amd-ucode.img \"${ESP_DIR}/\"\n\nPRESETS=('default' 'fallback')\n\n#default_config=\"/etc/mkinitcpio.conf\"\ndefault_image=\"${ESP_DIR}/initramfs-linux.img\"\ndefault_options=\"\"\n\n#fallback_config=\"/etc/mkinitcpio.conf\"\nfallback_image=\"${ESP_DIR}/initramfs-linux-fallback.img\"\nfallback_options=\"-S autodetect\"\n```\n\nДля тестирования выполните:\n\n```\n# rm /boot/initramfs-linux-fallback.img /boot/initramfs-linux.img\n# mv /boot/vmlinuz-linux esp/EFI/arch/\n# mkinitcpio -p linux\n```\n\n```\n/etc/mkinitcpio.d/linux.preset\n```\n\n```\nESP_DIR=\"esp/EFI/arch\"\n#ALL_config=\"/etc/mkinitcpio.conf\"\nALL_kver=\"$ESP_DIR/vmlinuz-linux$suffix\"\nPRESETS=('default')\ndefault_config=\"/etc/mkinitcpio.conf\"\ndefault_image=\"$ESP_DIR/initramfs-linux$suffix.img\"\n```\n\n```\n/etc/mkinitcpio.d/linux-zen.preset\n```\n\n```\nsuffix='-zen'\nsource /etc/mkinitcpio.d/linux.preset\n```\n\n"
    },
    {
      "title": "Использование хука pacman",
      "level": 4,
      "content": "Последний вариант полагается на хуки pacman, которые запускаются в конце транзакции.\n\nПервый файл — это хук, который отслеживает соответствующие файлы и запускается, если они были изменены в прошедшей транзакции.\n\n```\n/etc/pacman.d/hooks/999-kernel-efi-copy.hook\n```\n\n```\n[Trigger]\nType = Path\nOperation = Install\nOperation = Upgrade\nTarget = usr/lib/modules/*/vmlinuz\nTarget = usr/lib/initcpio/*\nTarget = boot/*-ucode.img\n\n[Action]\nDescription = Copying linux and initramfs to EFI directory...\nWhen = PostTransaction\nExec = /usr/local/bin/kernel-efi-copy.sh\n```\n\nВторой файл — собственно копирующий скрипт. Создайте его и сделайте исполняемым:\n\n```\n/usr/local/bin/kernel-efi-copy.sh\n```\n\n```\n#!/bin/sh\n#\n# Copy kernel and initramfs images to EFI directory\n#\n\nESP_DIR=\"esp/EFI/arch\"\n\nfor file in /boot/vmlinuz*\ndo\n        cp -af \"$file\" \"$ESP_DIR/$(basename \"$file\").efi\"\n        [ $? -ne 0 ] && exit 1\ndone\n\nfor file in /boot/initramfs*\ndo\n        cp -af \"$file\" \"$ESP_DIR/\"\n        [ $? -ne 0 ] && exit 1\ndone\n\n[ -e /boot/intel-ucode.img ] && cp -af /boot/intel-ucode.img \"$ESP_DIR/\"\n[ -e /boot/amd-ucode.img ] && cp -af /boot/amd-ucode.img \"$ESP_DIR/\"\n\nexit 0\n```\n\n"
    },
    {
      "title": "ESP в программном RAID1",
      "level": 3,
      "content": "Можно сделать ESP частью массива RAID1, но при этом возникает риск повреждения данных, и при создании ESP необходимо принять дополнительные меры. Смотрите [8], [9] и UEFI booting and RAID1 для подробностей.\n\nКлючевым моментом является использование параметра --metadata 1.0, чтобы сохранить метаданные RAID в конце раздела, иначе прошивка не сможет получить к ним доступ:\n\n```\n# mdadm --create --verbose --level=1 --metadata=1.0 --raid-devices=2 /dev/md/ESP /dev/sdaX /dev/sdbY\n```\n\n"
    },
    {
      "title": "Прошивка не видит каталог EFI",
      "level": 3,
      "content": "Если вы задаёте файловой системе FAT имя тома (то есть метку файловой системы), убедитесь, что оно не совпадает с именем EFI. Это может вызвать ошибку в некоторых прошивках (из-за совпадения имени тома с именем каталога EFI), которая заставит прошивку вести себя так, как будто каталог EFI не существует.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Системный раздел EFI и поведение загрузки по умолчанию\n- Multi Boot Linux With One Boot Partition | John Ramsden\n\n"
    }
  ]
}