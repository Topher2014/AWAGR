{
  "title": "NginX (Русский)",
  "url": "https://wiki.archlinux.org/title/NginX_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "nginx (произносится \"э́нжин-э́кс\" или \"э́нжин-и́кс\") — это свободный высокопроизводительный HTTP-сервер с открытым исходным кодом, а также обратный прокси и IMAP/POP3 прокси-сервер, написанный Игорем Сысоевым в 2005 году. nginx получил широкое распространение благодаря своей стабильности, богатой функциональности, простой настройке и низкому потреблению ресурсов.\n\nДанная статья описывает установку nginx и интеграцию с PHP через #FastCGI.\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Установите один из пакетов:\n\n- nginx-mainline - основная ветка: новые возможности, обновления и исправления ошибок.\n- nginx - стабильная ветка; только исправления серьёзных ошибок.\n- angieAUR - форк, предполагает подмену nginx на месте без переработки конфигурации с расширением возможностей.\n\nРекомендуется использовать основную (mainline) ветку. Основная причина для использования стабильной ветки — возможная несовместимость со сторонними модулями или непреднамеренное появление ошибок при реализации новых функций.\n\nЕсли для обеспечения дополнительной безопасности вы хотите установить nginx в chroot-окружении, смотрите раздел #Установка в chroot.\n\n"
    },
    {
      "title": "Запуск",
      "level": 2,
      "content": "Запустите/включите службу nginx.service или angie.service, если вы используете Angie.\n\nСтраница по умолчанию, доступная по адресу http://127.0.0.1 располагается в /usr/share/nginx/html/index.html.\n\n"
    },
    {
      "title": "Настройка",
      "level": 2,
      "content": "Первые шаги по настройке и использованию nginx описаны в официальном руководстве для начинающих. Вы можете настроить сервер, редактируя файлы в /etc/nginx/; главный файл настроек расположен в /etc/nginx/nginx.conf.\n\nБолее подробную информацию можно прочитать на странице Nginx Configuration Examples[устаревшая ссылка 2024-07-30 ⓘ] и в официальной документации.\n\nПриведенные далее примеры покрывают большинство типичных потребностей. Предполагается, что вы используете стандартное место расположения веб-документов (/usr/share/nginx/html). Если это не так, замените путь на свой.\n\n"
    },
    {
      "title": "Пример настройки",
      "level": 3,
      "content": "```\n/etc/nginx/nginx.conf\n```\n\n```\nuser http;\nworker_processes auto;\nworker_cpu_affinity auto;\n\nevents {\n    multi_accept on;\n    worker_connections 1024;\n}\n\nhttp {\n    charset utf-8;\n    sendfile on;\n    tcp_nopush on;\n    tcp_nodelay on;\n    server_tokens off;\n    log_not_found off;\n    types_hash_max_size 4096;\n    client_max_body_size 16M;\n\n    # MIME\n    include mime.types;\n    default_type application/octet-stream;\n\n    # журналы\n    access_log /var/log/nginx/access.log;\n    error_log /var/log/nginx/error.log warn;\n\n    # загрузка дополнительных файлов конфигурации\n    include /etc/nginx/conf.d/*.conf;\n    include /etc/nginx/sites-enabled/*;\n}\n```\n\n"
    },
    {
      "title": "Процессы и соединения",
      "level": 4,
      "content": "Вы должны выбрать подходящее значение для worker_processes. Этот параметр определяет сколько одновременных соединений сможет принимать nginx и сколько процессоров он сможет при этом использовать. Как правило, это значение устанавливают равным количеству аппаратных потоков в системе. Однако, начиная с версий 1.3.8 и 1.2.5, в качестве значения worker_processes вы также можете задать auto, при этом nginx попытается автоматически подобрать оптимальное значение (источник).\n\nМаксимальное количество одновременных соединений, которое nginx сможет принимать, вычисляется как max_clients = worker_processes * worker_connections.\n\n"
    },
    {
      "title": "Запуск под другим пользователем",
      "level": 4,
      "content": "По умолчанию запускается мастер-процесс nginx от имени root, а он в свою очередь запускает рабочие процессы от имени пользователя http. Для запуска рабочих процессов от имени другого пользователя измените значение директивы user в файле nginx.conf:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nuser пользователь [группа];\n```\n\nЕсли группа не указана, будет использоваться группа, совпадающая с указанным именем пользователя.\n\n"
    },
    {
      "title": "Блоки server",
      "level": 4,
      "content": "Посредством добавления блоков server в файл настроек возможно обслуживать сразу несколько доменов одновременно. Эти блоки работают аналогично \"VirtualHosts\" в Apache. Смотрите также примеры в официальной документации.\n\nВ этом примере сервер принимает запросы для двух доменов: domainname1.dom и domainname2.dom:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\n...\nserver {\n    listen 80;\n    listen [::]:80;\n    server_name domainname1.dom;\n    root /usr/share/nginx/domainname1.dom/html;\n    location / {\n        index index.php index.html index.htm;\n    }\n}\n\nserver {\n    listen 80;\n    listen [::]:80;\n    server_name domainname2.dom;\n    root /usr/share/nginx/domainname2.dom/html;\n    ...\n}\n```\n\nПерезапустите службу nginx.service, чтобы изменения вступили в силу.\n\nДля удобства можно поместить разные блоки server в разные файлы. Это также позволит включать и отключать отдельные сайты.\n\nСоздайте следующие каталоги:\n\n```\n# mkdir /etc/nginx/sites-available\n# mkdir /etc/nginx/sites-enabled\n```\n\nВнутри каталога sites-available создайте файл, содержащий один или несколько блоков server:\n\n```\n/etc/nginx/sites-available/example.conf\n```\n\n```\nserver {\n    listen 443 ssl http2;\n    listen [::]:443 ssl http2;\n\n    ...\n}\n```\n\nВ файле nginx.conf конце блока http добавьте строку include sites-enabled/*;:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nhttp {\n    ...\n    include sites-enabled/*;\n}\n```\n\nЧтобы включить сайт, в каталоге sites-enabled создайте символическую ссылку на связанный с ним файл:\n\n```\n# ln -s /etc/nginx/sites-available/example.conf /etc/nginx/sites-enabled/example.conf\n```\n\nА чтобы отключить сайт, удалите её:\n\n```\n# unlink /etc/nginx/sites-enabled/example.conf\n```\n\nПерезапустите службу nginx.service или перезагрузите конфигурацию (reload), чтобы изменения вступили в силу.\n\n"
    },
    {
      "title": "TLS",
      "level": 4,
      "content": "openssl предоставляет поддержку TLS/SSL и установлен по умолчанию на установленных Arch.\n\n- Перед тем как настраивать SSL, вы можете почитать документацию ngx_http_ssl_module\n- Let's Encrypt — это бесплатный, автоматизированный и открытый центр сертификации. Есть плагин для получения доверенных SSL-сертификатов прямо из командной строки и автоматической настройки.\n- На сайте Mozilla есть полезная статья про TLS, а также инструмент, помогающий составить безопасную конфигурацию.\n\nСоздайте секретный ключ и самоподписанный сертификат. Это подходит для большинства случаев, в которых не требуется CSR:\n\n```\n# cd /etc/nginx/\n# openssl req -new -x509 -nodes -newkey rsa:4096 -keyout nginx.key -out nginx.crt -days 1095\n# chmod 400 nginx.key\n# chmod 444 nginx.crt\n```\n\nЕсли же вам нужно создать CSR, то следуйте данным инструкциям по созданию ключа, вместо приведённых выше:\n\n```\n# openssl genpkey -algorithm RSA -pkeyopt rsa_keygen_bits:4096 -out nginx.key\n# chmod 400 nginx.key\n# openssl req -new -sha256 -key nginx.key -out nginx.csr\n# openssl x509 -req -days 1095 -in nginx.csr -signkey nginx.key -out nginx.crt\n```\n\nВ качестве отправкой точки для создания конфигурации TLS в /etc/nginx/nginx.conf можно использовать генератор настроек SSL от Mozilla.\n\nПерезапустите службу nginx, чтобы изменения вступили в силу.\n\n"
    },
    {
      "title": "Пользовательские каталоги",
      "level": 4,
      "content": "Чтобы сделать Apache-подобные адреса вида ~пользователь, указывающие на пользовательские каталоги ~/public_html, используйте подобную конфигурацию. (Примечание: если вы планируете использовать PHP, то связанный с ним location должен стоять первым.)\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\n...\nserver {\n    ...\n    # Обработка файлов PHP в пользовательских каталогах, например http://example.com/~user/test.php\n    location ~ ^/~(.+?)(/.+\\.php)$ {\n        alias          /home/$1/public_html$2;\n        fastcgi_pass   unix:/run/php-fpm/php-fpm.sock;\n        fastcgi_index  index.php;\n        include        fastcgi.conf;\n    }\n\n    # Пользовательские каталоги, например http://example.com/~user/\n    location ~ ^/~(.+?)(/.*)?$ {\n        alias     /home/$1/public_html$2;\n        index     index.html index.htm;\n        autoindex on;\n    }\n    ...\n}\n...\n```\n\nПодробнее о настройке PHP в nginx смотрите в разделе #Реализация PHP.\n\nПерезапустите службу nginx.service, чтобы изменения вступили в силу.\n\n"
    },
    {
      "title": "FastCGI",
      "level": 3,
      "content": "FastCGI или просто FCGI — это протокол, являющийся интерфейсом между веб-сервером и интерактивными программами. Это модифицированный CGI (Common Gateway Interface), главная цель которого — снизить накладные расходы, связанные со взаимодействием веб сервера и CGI программ, тем самым позволяя серверу обрабатывать большее количество запросов одновременно.\n\nТехнология FastCGI встроена в nginx для работы со многими внешними инструментами, например, Perl, PHP и Python.\n\n"
    },
    {
      "title": "Реализация PHP",
      "level": 4,
      "content": "В качестве FastCGI-сервера для PHP рекомендуется использовать PHP-FPM.\n\nУстановите пакет php-fpm и проверьте корректность настроек PHP. Основным конфигурационным файлом PHP-FPM является /etc/php/php-fpm.conf. Включите и запустите systemd службу php-fpm.\n\n- Если вы запускаете nginx под другим пользователем, убедитесь, что Unix-сокет PHP-FPM доступен этому пользователю, или используйте TCP-сокет.\n- Если вы запускаете nginx в изолированном окружении (к примеру, chroot находится в /srv/nginx-jail, веб-документы расположены в /srv/nginx-jail/www), то вы должны в /etc/php/php-fpm.conf добавить опции chroot /srv/nginx-jail и listen = /srv/nginx-jail/run/php-fpm/php-fpm.sock внутри секции пула (по умолчанию это [www]). Создайте каталог для файла сокета, если его нет. Более того, для модулей, которые динамически связаны с зависимостями, вам нужно будет скопировать эти зависимости в chroot (например, для php-imagick вам нужно будет скопировать в chroot библиотеки ImageMagick, но не сам imagick.so).\n\nВнутри каждого блока server, который обслуживает веб-приложение PHP, должен находиться блок location [1], например:\n\n```\n/etc/nginx/sites-available/example.conf\n```\n\n```\nserver {\n    root /usr/share/nginx/html;\n\n    location / {\n        index index.html index.htm index.php;\n    }\n\n    location ~ \\.php$ {\n        # 404\n        try_files $fastcgi_script_name =404;\n\n        # default fastcgi_params\n        include fastcgi_params;\n\n        # fastcgi settings\n        fastcgi_pass\t\t\tunix:/run/php-fpm/php-fpm.sock;\n        fastcgi_index\t\t\tindex.php;\n        fastcgi_buffers\t\t\t8 16k;\n        fastcgi_buffer_size\t\t32k;\n\n        # fastcgi params\n        fastcgi_param DOCUMENT_ROOT\t$realpath_root;\n        fastcgi_param SCRIPT_FILENAME\t$realpath_root$fastcgi_script_name;\n        #fastcgi_param PHP_ADMIN_VALUE\t\"open_basedir=$base/:/usr/lib/php/:/tmp/\";\n    }\n}\n```\n\nЕсли требуется обрабатывать другие расширения наряду с PHP (например .html и .htm):\n\n```\nlocation ~ [^/]\\.(php|html|htm)(/|$) {\n    ...\n}\n```\n\nВсе расширения, обрабатываемые в php-fpm должны быть также явно добавлены в /etc/php/php-fpm.d/www.conf:\n\n```\nsecurity.limit_extensions = .php .html .htm\n```\n\nNote: **По умолчанию** Вы можете использовать также общий TCP-сокет:\n\n```\nfastcgi_pass unix:/run/php-fpm/php-fpm.sock;\n```\n\nВы можете использовать также общий TCP-сокет:\n\n```\nfastcgi_pass 127.0.0.1:9000;\n```\n\nNote: И затем подключать этот файл в тех блоках server, в которых нужна обработка PHP:\n\n```\n/etc/nginx/php_fastcgi.conf\n```\n\n```\nlocation ~ \\.php$ {\n    # 404\n    try_files $fastcgi_script_name =404;\n\n    # default fastcgi_params\n    include fastcgi_params;\n\n    # fastcgi settings\n    ...\n}\n```\n\nИ затем подключать этот файл в тех блоках server, в которых нужна обработка PHP:\n\n```\n/etc/nginx/sites-available/example.conf\n```\n\n```\nserver {\n    server_name example.com;\n    ...\n\n    include /etc/nginx/php_fastcgi.conf;\n}\n```\n\nПерезапустите службы php-fpm и nginx после изменения настроек, чтобы изменения вступили в силу.\n\nЧтобы проверить работу FastCGI, создайте новый файл .php внутри каталога веб-документов, содержащий:\n\n```\n<?php\n  phpinfo();\n?>\n```\n\nПри открытии файла в браузере должна отобразиться информационная страница с текущими настройками PHP.\n\n"
    },
    {
      "title": "Реализация CGI",
      "level": 4,
      "content": "Эта реализация нужна для CGI-приложений.\n\nУстановите fcgiwrap. Настроить его можно путём редактирования юнита fcgiwrap.socket. Включите и запустите fcgiwrap.socket.\n\nЕсли вы хотите породить несколько рабочих потоков, вам рекомендуется использовать multiwatchAUR, который умеет отслеживать упавшие подпроцессы и перезапускать их. Вам нужно использовать spawn-fcgi, чтобы создать доменный сокет Unix, так как multiwatch не может обрабатывать сокеты, созданные systemd, однако, fcgiwrap сама по себе не вызывает никаких проблем, если вызывается непосредственно из юнит-файла.\n\nСделайте замещение файла юнита fcgiwrap.service (и юнита fcgiwrap.socket, если он есть), и отредактируйте строку ExecStart в соответствии с вашими нуждами. В примере показан юнит файл, который использует multiwatchAUR. Убедитесь, что fcgiwrap.socket не включен и не запущен, потому что он будет конфликтовать с этим юнитом:\n\n```\n/etc/systemd/system/fcgiwrap.service\n```\n\n```\n[Unit]\nDescription=Simple CGI Server\nAfter=nss-user-lookup.target\n\n[Service]\nExecStartPre=/bin/rm -f /run/fcgiwrap.socket\nExecStart=/usr/bin/spawn-fcgi -u http -g http -s /run/fcgiwrap.sock -n -- /usr/bin/multiwatch -f 10 -- /usr/sbin/fcgiwrap\nExecStartPost=/usr/bin/chmod 660 /run/fcgiwrap.sock\nPrivateTmp=true\nRestart=on-failure\n\n[Install]\nWantedBy=multi-user.target\n```\n\nВыберите подходящий -f 10, чтобы изменить количество порождаемых подпроцессов.\n\nВ каталоге /etc/nginx скопируйте файл fastcgi_params в fcgiwrap_params. В файле fcgiwrap_params удалите строки, которые устанавливают SCRIPT_NAME и DOCUMENT_ROOT.\n\nВнутри каждого блока server CGI-приложения должен находиться вложенный блок location:\n\n```\nlocation ~ \\.cgi$ {\n     include       fcgiwrap_params;\n     fastcgi_param DOCUMENT_ROOT /srv/www/cgi-bin/;\n     fastcgi_param SCRIPT_NAME   myscript.cgi;\n     fastcgi_pass  unix:/run/fcgiwrap.sock;\n}\n```\n\nСокетом по умолчанию для fcgiwrap является /run/fcgiwrap.sock.\n\nВместо параметров DOCUMENT_ROOT и SCRIPT_NAME можно использовать более короткую альтернативу fastcgi_param SCRIPT_FILENAME /srv/www/cgi-bin/myscript.cgi. При её использовании не понадобится копировать fastcgi_params в fcgiwrap_params и удалять строки DOCUMENT_ROOT and SCRIPT_NAME.\n\nЕсли вы продолжаете получать ошибку 502 - bad Gateway, проверьте, передаёт ли ли ваше CGI-приложение mime-тип содержимого. Для html это должно быть Content-type: text/html.\n\nЕсли вы получаете ошибки 403, убедитесь, что CGI-файл доступен для чтения и выполнения пользователю http и что каждая родительская папка доступна ему для чтения.\n\n"
    },
    {
      "title": "Установка в chroot",
      "level": 2,
      "content": "Установка nginx в chroot добавляет дополнительный уровень безопасности. Для максимальной безопасности chroot должен включать только файлы, необходимые для запуска сервера nginx, при этом все файлы должны иметь по возможности максимально ограниченные права доступа. Например, как можно больше файлов должно принадлежать пользователю root, а таким каталогам, как /usr/bin должен быть установлен запрет на чтение и запись.\n\nArch поставляется с пользователем http и группой по умолчанию, от имени которых запускается сервер. Измененный корневой каталог будет находиться в /srv/http.\n\nСуществует perl-скрипт для создания chroot-окружения, который доступен в jail.pl gist. Вы можете либо использовать его, либо следовать дальнейшим инструкциям из этой статьи. Скрипт требует прав суперпользователя для работы. Вам нужно будет раскомментировать строку, перед тем, как он сможет выполнять какие-либо изменения.\n\n"
    },
    {
      "title": "Создание необходимых устройств",
      "level": 3,
      "content": "Для nginx нужны /dev/null, /dev/random и /dev/urandom. Чтобы установить их в chroot мы создадим каталог /dev и добавим устройства с помощью mknod. Избегайте монтирования всех устройств в /dev: тогда, даже если chroot будет скомпрометирован, атакующий должен будет выбраться из chroot-окружения чтобы добраться до важных устройств, например /dev/sda1.\n\n```\n# export JAIL=/srv/http\n# mkdir $JAIL/dev\n# mknod -m 0666 $JAIL/dev/null c 1 3\n# mknod -m 0666 $JAIL/dev/random c 1 8\n# mknod -m 0444 $JAIL/dev/urandom c 1 9\n```\n\n"
    },
    {
      "title": "Создание необходимых каталогов",
      "level": 3,
      "content": "Для работы nginx требует определенный набор файлов. Перед тем, как их копировать, создайте для них соответствующие каталоги. Предполагается, что ваш корневой каталог веб-документов nginx находится в /srv/http/www.\n\n```\n# mkdir -p $JAIL/etc/nginx/logs\n# mkdir -p $JAIL/usr/{lib,bin}\n# mkdir -p $JAIL/usr/share/nginx\n# mkdir -p $JAIL/var/{log,lib}/nginx\n# mkdir -p $JAIL/www/cgi-bin\n# mkdir -p $JAIL/{run,tmp}\n# cd $JAIL; ln -s usr/lib lib\n# cd $JAIL; ln -s usr/lib lib64\n# cd $JAIL/usr; ln -s lib lib64\n```\n\nЗатем смонтируйте $JAIL/tmp и $JAIL/run как tmpfs-ы. Размер должен быть ограничен, чтобы быть уверенным, что атакующий не сможет занять всю доступную RAM.\n\n```\n# mount -t tmpfs none $JAIL/run -o 'noexec,size=1M'\n# mount -t tmpfs none $JAIL/tmp -o 'noexec,size=100M'\n```\n\nДля того, чтобы монтирование выполнялось автоматически при загрузке системы, добавьте следующие записи в /etc/fstab:\n\n```\n/etc/fstab\n```\n\n```\ntmpfs   /srv/http/run   tmpfs   rw,noexec,relatime,size=1024k   0       0\n tmpfs   /srv/http/tmp   tmpfs   rw,noexec,relatime,size=102400k 0       0\n```\n\n"
    },
    {
      "title": "Заполнение chroot",
      "level": 3,
      "content": "Сначала скопируйте простые файлы.\n\n```\n# cp -r /usr/share/nginx/* $JAIL/usr/share/nginx\n# cp -r /usr/share/nginx/html/* $JAIL/www\n# cp /usr/bin/nginx $JAIL/usr/bin/\n# cp -r /var/lib/nginx $JAIL/var/lib/nginx\n```\n\nТеперь скопируйте нужные библиотеки. Используйте ldd, чтобы отобразить их и скопируйте все файлы в правильное место. Копирование предпочтительнее, чем создание жестких ссылок, потому, что даже если атакующий получит права записи в файлы, они не смогут уничтожить или изменить системные файлы вне chroot-окружения.\n\n```\n$ ldd /usr/bin/nginx\n```\n\n```\nlinux-vdso.so.1 (0x00007fffc41fe000)\nlibpthread.so.0 => /usr/lib/libpthread.so.0 (0x00007f57ec3e8000)\nlibcrypt.so.1 => /usr/lib/libcrypt.so.1 (0x00007f57ec1b1000)\nlibstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x00007f57ebead000)\nlibm.so.6 => /usr/lib/libm.so.6 (0x00007f57ebbaf000)\nlibpcre.so.1 => /usr/lib/libpcre.so.1 (0x00007f57eb94c000)\nlibssl.so.1.0.0 => /usr/lib/libssl.so.1.0.0 (0x00007f57eb6e0000)\nlibcrypto.so.1.0.0 => /usr/lib/libcrypto.so.1.0.0 (0x00007f57eb2d6000)\nlibdl.so.2 => /usr/lib/libdl.so.2 (0x00007f57eb0d2000)\nlibz.so.1 => /usr/lib/libz.so.1 (0x00007f57eaebc000)\nlibGeoIP.so.1 => /usr/lib/libGeoIP.so.1 (0x00007f57eac8d000)\nlibgcc_s.so.1 => /usr/lib/libgcc_s.so.1 (0x00007f57eaa77000)\nlibc.so.6 => /usr/lib/libc.so.6 (0x00007f57ea6ca000)\n/lib64/ld-linux-x86-64.so.2 (0x00007f57ec604000)\n```\n\nДля файлов, находящихся в /usr/lib, вы можете воспользоваться следующей командой:\n\n```\n# cp $(ldd /usr/bin/nginx | grep /usr/lib | sed -sre 's/(.+)(\\/usr\\/lib\\/\\S+).+/\\2/g') $JAIL/usr/lib\n```\n\nА для ld-linux-x86-64.so — следующей командой:\n\n```\n# cp /lib64/ld-linux-x86-64.so.2 $JAIL/lib\n```\n\nКопируйте другие необходимые библиотеки и системные файлы.\n\n```\n# cp /usr/lib/libnss_* $JAIL/usr/lib\n# cp -rfvL /etc/{services,localtime,nsswitch.conf,nscd.conf,protocols,hosts,ld.so.cache,ld.so.conf,resolv.conf,host.conf,nginx} $JAIL/etc\n```\n\nСоздайте файлы пользователей и групп в chroot-окружении. Таким образом, в chroot-окружении будут доступны только указанные пользователи, и никакая информация о пользователях из основной системы не будет доступна атакующему, получившему доступ в chroot-окружение.\n\n```\n$JAIL/etc/group\n```\n\n```\nhttp:x:33:\nnobody:x:99:\n```\n\n```\n$JAIL/etc/passwd\n```\n\n```\nhttp:x:33:33:http:/:/bin/false\nnobody:x:99:99:nobody:/:/bin/false\n```\n\n```\n$JAIL/etc/shadow\n```\n\n```\nhttp:x:14871::::::\nnobody:x:14871::::::\n```\n\n```\n$JAIL/etc/gshadow\n```\n\n```\nhttp:::\nnobody:::\n```\n\n```\n# touch $JAIL/etc/shells\n# touch $JAIL/run/nginx.pid\n```\n\nНаконец, сделайте права доступа максимально ограниченными. Как можно больше должно принадлежать суперпользователю и быть закрытым для записи.\n\n```\n# chown -R root:root $JAIL/\n\n# chown -R http:http $JAIL/www\n# chown -R http:http $JAIL/etc/nginx\n# chown -R http:http $JAIL/var/{log,lib}/nginx\n# chown http:http $JAIL/run/nginx.pid\n\n# find $JAIL/ -gid 0 -uid 0 -type d -print | xargs chmod -rw\n# find $JAIL/ -gid 0 -uid 0 -type d -print | xargs chmod +x\n# find $JAIL/etc -gid 0 -uid 0 -type f -print | xargs chmod -x\n# find $JAIL/usr/bin -type f -print | xargs chmod ug+rx\n# find $JAIL/ -group http -user http -print | xargs chmod o-rwx\n# chmod +rw $JAIL/tmp\n# chmod +rw $JAIL/run\n```\n\nЕсли ваш сервер будет принимать входящие соединения на 80 порту (или любому другому порту в диапазоне [1-1023]), дайте исполняемому файлу внутри chroot права на использование этих портов без прав суперпользователя.\n\n```\n# setcap 'cap_net_bind_service=+ep' $JAIL/usr/bin/nginx\n```\n\n"
    },
    {
      "title": "Отредактируйте nginx.service для запуска chroot",
      "level": 3,
      "content": "Сделайте замещение файла юнита nginx.service — тогда обновление nginx не изменит ваш файл .service.\n\nЮнит systemd должен быть настроен так, чтобы запускать nginx в chroot от имени пользователя http и хранить pid-файл в chroot.\n\n```\n/etc/systemd/system/nginx.service\n```\n\n```\n[Unit]\nDescription=A high performance web server and a reverse proxy server\nAfter=network.target\n\n[Service]\nType=forking\nPIDFile=/srv/http/run/nginx.pid\nExecStartPre=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -t -q -g 'pid /run/nginx.pid; daemon on; master_process on;'\nExecStart=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -g 'pid /run/nginx.pid; daemon on; master_process on;'\nExecReload=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -g 'pid /run/nginx.pid; daemon on; master_process on;' -s reload\nExecStop=/usr/bin/chroot --userspec=http:http /srv/http /usr/bin/nginx -g 'pid /run/nginx.pid;' -s quit\n\n[Install]\nWantedBy=multi-user.target\n```\n\nТеперь вы можете спокойно удалить nginx, установленный вне chroot.\n\n```\n# pacman -Rsc nginx\n```\n\nЕсли вы не удалили nginx, установленный вне chroot, проверьте, что работающий процесс nginx — это действительно именно тот, что в находится chroot. Для этого посмотрите, куда указывает символическая ссылка /proc/PID/root: она должна указывать на /srv/http, а не на /.\n\n```\n# ps -C nginx | awk '{print $1}' | sed 1d | while read -r PID; do ls -l /proc/$PID/root; done\n```\n\n"
    },
    {
      "title": "Запуск без привилегий через systemd",
      "level": 3,
      "content": "Создайте drop-in файл для службы nginx.service и пропишите в нём секцию [Service] с опцими User и (опционально) Group, чтобы запустить службу от имени указанного вами непривилегированного пользователя:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\nUser=пользователь\nGroup=группа\n```\n\nТакже можно запретить повышение привилегий:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nNoNewPrivileges=yes\n```\n\nПосле этого нужно убедиться, что пользователь имеет доступ ко всем необходимым ресурсам. Следуйте инструкциям, описанным в следующих разделах, и затем запустите nginx.\n\n"
    },
    {
      "title": "Порт",
      "level": 4,
      "content": "По умолчанию Linux запрещает не-root процессам слушать порты ниже 1024. Можно использовать порт выше 1024:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nserver {\n        listen 8080;\n}\n```\n\nИли можно выдать процессу nginx привилегию CAP_NET_BIND_SERVICE, которая позволит ему использовать порты ниже 1024:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nCapabilityBoundingSet=\nCapabilityBoundingSet=CAP_NET_BIND_SERVICE\nAmbientCapabilities=\nAmbientCapabilities=CAP_NET_BIND_SERVICE\n```\n\nИли можно использовать активацию сокетов systemd. В этом случае systemd будет прослушивать порты и, когда будет установлено соединение, запустит nginx, передав сокет в качестве дескриптора файла. Это означает, что процессу nginx не нужны особые привилегии, так как сокет уже существует на момент запуска. Этот подход опирается на использование внутренней переменной окружения, которую nginx использует для передачи сокетов [2], и поэтому официально не поддерживается. Вместо установки CapabilityBoundingSet и AmbientCapabilities переопределите переменную окружения NGINX, чтобы сообщить процессу nginx, какие файловые дескрипторы будут передаваться сокетам:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nEnvironment=NGINX=3:4;\n```\n\nНа каждый прослушиваемый порт будет приходиться один сокет, начиная с файлового дескриптора 3, поэтому в данном примере мы говорим nginx ожидать два сокета. Теперь создайте юнит nginx.socket, указав, какие порты прослушивать:\n\n```\n/etc/systemd/system/nginx.socket\n```\n\n```\n[Socket]\nListenStream=0.0.0.0:80\nListenStream=0.0.0.0:443\nAfter=network.target\nRequires=network.target\n\n[Install]\nWantedBy=sockets.target\n```\n\nСокеты будут передаваться в порядке, определённом в этом юните, поэтому порт 80 будет файловым дескриптором 3, а порт 443 — файловым дескриптором 4. Если вы ранее включали или запускали службу nginx.service, вам нужно остановить её и включить вместо неё nginx.socket. При запуске системы nginx не будет запущен, но запустится, когда вы зайдете на сайт в браузере. Благодаря этому можно дополнительно защитить службу; например, во многих случаях вы можете установить PrivateNetwork=True в файле службы, блокируя nginx от внешней сети, поскольку сокета, созданного systemd, достаточно для обслуживания веб-сайта. Обратите внимание, что при этом в журналы службы nginx будет выведено предупреждение: 2020/08/29 19:33:20 [notice] 254#254: using inherited sockets from \"3:4;\"\n\n"
    },
    {
      "title": "PID-файл",
      "level": 4,
      "content": "По умолчанию nginx использует /run/nginx.pid. Нужно будет создать каталог, в котором пользователь будет иметь право записи, и перенастроить запись PID-файла туда. Например, можно использовать systemd-tmpfiles:\n\n```\n/etc/tmpfiles.d/nginx.conf\n```\n\n```\nd /run/nginx 0775 root группа - -\n```\n\nПримените изменения:\n\n```\n# systemd-tmpfiles --create\n```\n\nОтредактируйте параметры службы, связанные с PID-файлом:\n\n```\n/etc/systemd/system/nginx.service.d/user.conf\n```\n\n```\n[Service]\n...\nPIDFile=/run/nginx/nginx.pid\nExecStart=\nExecStart=/usr/bin/nginx -g 'pid /run/nginx/nginx.pid; error_log stderr;'\nExecReload=\nExecReload=/usr/bin/nginx -s reload -g 'pid /run/nginx/nginx.pid;'\n```\n\n"
    },
    {
      "title": "/var/lib/nginx/*",
      "level": 4,
      "content": "Некоторые каталоги в каталоге /var/lib/nginx должны быть инициализированы путём запуска nginx от имени root. Для этого не обязательно запускать весь сервер, nginx сделает это при проверке конфигурации. Так что просто запустите её — и готово.\n\n"
    },
    {
      "title": "Права каталогов и файлов журналов",
      "level": 4,
      "content": "После запуска проверки конфигурации будет создан журнал, принадлежащий root. Удалите журналы в /var/log/nginx.\n\nПользователю, от имени которого будет работать служба, nginx нужно выдать разрешение на запись в /var/log/nginx. Для этого может понадобиться изменить права и/или владельца каталога.\n\n"
    },
    {
      "title": "Альтернативный скрипт для systemd",
      "level": 3,
      "content": "В systemd есть встроенная возможность запуска через chroot. [3]. Для примера используем такие настройки пользователя, группы и pid:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nuser http;\npid /run/nginx.pid;\n```\n\nАбсолютный путь к файлу настроек будет /srv/http/etc/nginx/nginx.conf.\n\n```\n/etc/systemd/system/nginx.service\n```\n\n```\n[Unit]\nDescription=nginx (Chroot)\nAfter=network.target\n\n[Service]\nType=forking\nPIDFile=/srv/http/run/nginx.pid\nRootDirectory=/srv/http\nExecStartPre=/usr/bin/nginx -t -c /etc/nginx/nginx.conf\nExecStart=/usr/bin/nginx -c /etc/nginx/nginx.conf\nExecReload=/usr/bin/nginx -c /etc/nginx/nginx.conf -s reload\nExecStop=/usr/bin/nginx -c /etc/nginx/nginx.conf -s stop\n\n[Install]\nWantedBy=multi-user.target\n```\n\nУказывать стандартный путь к файлу настроек необязательно, nginx по умолчанию использует -c /etc/nginx/nginx.conf, но, возможно, явное прописывание является хорошей идеей.\n\nТакже можно запускать только ExecStart внутри chroot с параметром RootDirectoryStartOnly заданным как yes (смотрите systemd.service(5)) или запустить его до того, как точка монтирования станет эффективной или будет доступен путь systemd (смотрите systemd.path(5)).\n\n```\n/etc/systemd/system/nginx.path\n```\n\n```\n[Unit]\nDescription=nginx (Chroot) path\n[Path]\nPathExists=/srv/http/site/Public_html\n[Install]\nWantedBy=default.target\n```\n\nВключите созданный юнит nginx.path и в юните nginx.service измените строку WantedBy=default.target на WantedBy=nginx.path.\n\nПараметр PIDFile в файле юнита позволяет systemd следить за процессом (требуется абсолютный путь). Если это нежелательно, вы можете изменить тип на oneshot и удалить упоминание pid-файла из файла юнита.\n\n"
    },
    {
      "title": "Nginx beautifier",
      "level": 3,
      "content": "nginxbeautifierAUR — это инструмент командной строки, используемый для улучшения и форматирования конфигурационных файлов nginx.\n\n"
    },
    {
      "title": "Более удобное управление заголовками",
      "level": 3,
      "content": "Nginx имеет довольно неинтуитивную систему управления HTTP-заголовками: они могут быть определены только в одном контексте, любые другие заголовки игнорируются. Чтобы исправить это, можно установить модуль headers-more-nginx.\n\nУстановите пакет nginx-mod-headers-more. Модуль будет установлен в каталог /usr/lib/nginx/modules.\n\nЧтобы загрузить модуль, добавьте следующее в начало основного конфигурационного файла nginx.\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nload_module \"/usr/lib/nginx/modules/ngx_http_headers_more_filter_module.so\";\n...\n```\n\n"
    },
    {
      "title": "Валидация конфигурации",
      "level": 3,
      "content": "```\n# nginx -t\n```\n\n```\nnginx: the configuration file /etc/nginx/nginx.conf syntax is ok\nnginx: configuration file /etc/nginx/nginx.conf test is successful\n```\n\n"
    },
    {
      "title": "Ошибка: Страница, которую вы ищете, временно недоступна. Пожалуйста, попробуйте позже. (502 Bad Gateway)",
      "level": 3,
      "content": "Это из-за того, что сервер FastCGI не запущен или используемый сокет имеет неправильные права доступа.\n\nПопробуйте этот ответ, чтобы исправить 502 ошибку.\n\nВ Arch Linux, файлом настройки, упомянутом по ссылке выше, является /etc/php/php-fpm.conf.\n\n"
    },
    {
      "title": "Ошибка: No input file specified",
      "level": 3,
      "content": "1. Убедитесь, что переменная open_basedir в /etc/php/php.ini содержит путь, который соответствует аргументу root в nginx.conf (обычно /usr/share/nginx/). Если в качестве FastCGI-сервера используется PHP-FPM, можно попробовать добавить fastcgi_param PHP_ADMIN_VALUE \"open_basedir=$document_root/:/tmp/:/proc/\"; в тот блок location, который используется для обработки php-файлов.\n\n2. Другой причиной может быть то, что задан неправильный аргумент root в секции location ~ \\.php$ в nginx.conf. Убедитесь, что root указывает на ту же директорию, что и в location / на том же сервере. Либо вы можете просто задать параметр root глобально, не переопределяя его в каких-либо location секциях.\n\n3. Проверьте права доступа: например, пользователь/группа http, биты разрешений 755 для каталогов и 644 для файлов. Имейте в виду, что все родительские каталоги тоже должны иметь корректные права доступа. Как массово изменить права всего дерева каталогов, описано в разделе Разрешения и атрибуты файлов#Массовое изменение разрешений.\n\n4. Возможно, у вас не установлена переменная SCRIPT_FILENAME, содержащая полный путь до ваших скриптов. Если конфигурация nginx (fastcgi_param SCRIPT_FILENAME) правильная, то эта ошибка означает, что php не смог загрузить запрашиваемый скрипт. Часто это просто оказывается ошибкой прав доступа, и вы можете запустить php-cgi с правами root:\n\n```\n# spawn-fcgi -a 127.0.0.1 -p 9000 -f /usr/bin/php-cgi\n```\n\nили вам следует создать группу и пользователя для запуска php-cgi:\n\n```\n# groupadd www\n# useradd -g www www\n# chmod +w /srv/www/nginx/html\n# chown -R www:www /srv/www/nginx/html\n# spawn-fcgi -a 127.0.0.1 -p 9000 -u www -g www -f /usr/bin/php-cgi\n```\n\n5. Если вы используете chroot, убедитесь, что опция chroot в файле /etc/php-fpm/php-fpm.d/www.conf имеет корректное значение.\n\n"
    },
    {
      "title": "Warning: Could not build optimal types_hash",
      "level": 3,
      "content": "Если при запуске nginx.service в журнале появляется такое сообщение:\n\n```\n[warn] 18872#18872: could not build optimal types_hash, you should increase either types_hash_max_size: 1024 or types_hash_bucket_size: 64; ignoring types_hash_bucket_size\n```\n\nто попробуйте увеличить значения этих параметров в блоке http [4] [5]:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nhttp {\n    types_hash_max_size 4096;\n    server_names_hash_bucket_size 128;\n    ...\n}\n```\n\n"
    },
    {
      "title": "Cannot assign requested address",
      "level": 3,
      "content": "Полный текст ошибки в статусе юнита nginx.service:\n\n```\n[emerg] 460#460: bind() to A.B.C.D:443 failed (99: Cannot assign requested address)\n```\n\nДаже если файл юнита nginx настроен на запуск после network.target с помощью systemd, nginx может попытаться прослушивать адрес, который настроен, но ещё не добавлен ни к одному интерфейсу. Убедиться, что проблема именно в этом, можно, попытавшись запустить nginx вручную (тем самым показав, что IP-адрес настроен правильно). Настройка nginx на прослушивание всех адресов решит эту проблему. Если же в вашем случае обязательно требуется прослушивание конкретного адреса, одним из возможных решений является перенастройка systemd.\n\nЧтобы запустить nginx только после того, как все настроенные сетевые устройства будут запущены и получат IP-адреса, добавьте network-online.target к строке After= в файле nginx.service и запустите/включите systemd-networkd-wait-online.service.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Использование WebDAV с nginx\n- nginx configuration pitfalls\n- Very good in-depth 2014 look at nginx security and Reverse Proxying\n- Installing LEMP (nginx, PHP, MySQL with MariaDB engine and PhpMyAdmin) in Arch Linux\n- Certbot (Русский)#Nginx\n\n"
    }
  ]
}