{
  "title": "GnuPG (Polski)",
  "url": "https://wiki.archlinux.org/title/GnuPG_(Polski)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section needs to be translated.** This article or section needs to be translated.\n\nThis article or section needs to be translated.\n\nWedług official website:\n\n"
    },
    {
      "title": "Instalacja",
      "level": 2,
      "content": "Zainstaluj paczkę gnupg.\n\nTo również zainstaluje pinentry, kolekcję prostych okienek do wpisywania PINów oraz haseł które GnuPG używa do wprowadzania. Które z okienek dialogowych od pinentry zostanie użyte, jest determinowane przez symboliczny link /usr/bin/pinentry, który domyślnie wskazuje /usr/bin/pinentry-gtk-2.\n\nJeśli chcesz używać graficznego interfejsu, lub programu który integruje się z GnuPG, zobacz List of applications/Security#Encryption, signing, steganography.\n\n"
    },
    {
      "title": "Lokalizacja katalogu",
      "level": 3,
      "content": "$GNUPGHOME jest używany przez GnuPG do wskazywania katalogu, w którym przechowywane są jego pliki konfiguracyjne. Domyślnie $GNUPGHOMEnie jest ustawione i twoje $HOME jest używany zamiast; w ten sposób znajdziesz ~/.gnupg katalog zaraz po instalacji.\n\nAby zmienić domyślną lokalizację, uruchom gpg w ten sposób $ gpg --homedir path/to/file lub ustaw GNUPGHOME environment variable.\n\n"
    },
    {
      "title": "Pliki konfiguracyjne",
      "level": 3,
      "content": "Domyślne pliki konfiguracyjne to ~/.gnupg/gpg.conf i ~/.gnupg/dirmngr.conf.\n\nDomyślnie katalog gnupg ma ustawione uprawnienia do 700 , a pliki, które zawiera, mają ustawione uprawnienia do 600. Tylko właściciel katalogu ma uprawnienia do odczytu, zapisu i uzyskiwania dostępu do plików. Jest to ze względów bezpieczeństwa i nie należy go zmieniać. W przypadku, gdy ten katalog lub jakikolwiek inny plik wewnątrz niego nie jest zgodny z tą miarą bezpieczeństwa, otrzymasz ostrzeżenia o niebezpiecznych uprawnieniach do plików i katalogu domowego.\n\nDołącz do tych plików dowolne długie opcje, które chcesz. Nie zapisuj dwóch kresek, ale po prostu nazwę opcji i wymagane argumenty. Znajdziesz pliki szkieletów w /usr/share/gnupg. Pliki te są kopiowane do ~/.gnupg przy pierwszym uruchomieniu gpg, jeśli tam nie istnieją. Inne przykłady można znaleźć w #Zobacz też.\n\nDodatkowo pacman używa innego zestawu plików konfiguracyjnych do weryfikacji podpisów paczek. Zobacz Pacman/Package signing dla szczegółów.\n\n"
    },
    {
      "title": "Domyślne opcje dla nowych użytkowników",
      "level": 3,
      "content": "Jeśli chcesz ustawić domyślne opcje dla nowych użytkowników, umieść pliki konfiguracyjne w /etc/skel/.gnupg/. Po dodaniu nowego użytkownika w systemie pliki z tego katalogu zostaną skopiowane do katalogu domowego GnuPG. Istnieje również prosty skrypt o nazwie \"addgnupghome\", który można wykorzystać do stworzenia nowych katalogów domowych GnuPG dla istniejących użytkowników:\n\n```\n# addgnupghome user1 user2\n```\n\nTo doda odpowiednie /home/user1/.gnupg i /home/user2/.gnupg i skopiuj do niego pliki z katalogu szkieletu. Użytkownicy z istniejącym katalogiem macierzystym GnuPG są po prostu pomijani.\n\n"
    },
    {
      "title": "Utwórz parę kluczy",
      "level": 3,
      "content": "Wygeneruj parę kluczy, wpisując w terminalu:\n\n```\n$ gpg --full-gen-key\n```\n\nPolecenie spowoduje wyświetlenie odpowiedzi na kilka pytań. Do ogólnego użytku większość ludzi będzie chciała:\n\n- klucz RSA (tylko podpis) i klucz RSA (tylko szyfrowanie).\n- klucz do domyślnej wartości (2048). Większy klucz 4096 \"daje nam prawie nic, a kosztuje nas sporo\"[1].\n- data wygaśnięcia. Okres roku jest wystarczająco dobry dla przeciętnego użytkownika. W ten sposób, nawet jeśli dojdzie do utraty dostępu do kluczy, pozwoli to innym dowiedzieć się, że nie jest już ważny. Później, jeśli to konieczne, data wygaśnięcia może zostać przedłużona bez konieczności ponownego wydania nowego klucza.\n- twoje imię i adres e-mail. Możesz dodać wiele tożsamości do tego samego klucza później (\" ', jeśli masz wiele adresów e-mail, które chcesz powiązać z tym kluczem).\n- 'komentarz \"nie\". Ponieważ semantyka pola komentarza to not well-defined, ma ograniczoną wartość do identyfikacji.\n- a secure passphrase.\n\n"
    },
    {
      "title": "Lista kluczy",
      "level": 3,
      "content": "Aby wyświetlić listę kluczy w swoim publicznym key ring:\n\n```\n$ gpg --list-keys\n```\n\nAby wyświetlić sekretną listę kluczy key ring:\n\n```\n$ gpg --list-secret-keys\n```\n\n"
    },
    {
      "title": "Wyeksportuj swój klucz publiczny",
      "level": 3,
      "content": "Głównym zastosowaniem gpg jest zapewnienie poufności wymienianych wiadomości za pośrednictwem kryptografii z kluczem publicznym. Dzięki niemu każdy użytkownik dystrybuuje klucz publiczny swojego klucza, który może być używany przez innych do szyfrowania wiadomości do użytkownika. Klucz prywatny musi być zawsze \"prywatny\", w przeciwnym razie dochodzi do złamania poufności. Zobacz w w:Public-key cryptography przykłady wymiany wiadomości.\n\nTak więc, aby inni mogli wysyłać zaszyfrowane wiadomości, potrzebują Twojego publicznego klucza.\n\nBy wygenerować wersję ASCII klucza publicznego do pliku public.key (np. do dystrybucji poprzez e-mail):\n\n```\n$ gpg --output public.key --armor --export user-id\n```\n\nAlternatywnie lub dodatkowo możesz zobaczyć sekcję #Użyj serwera kluczy by podzielić się swoim kluczem.\n\n"
    },
    {
      "title": "Zaimportuj klucz publiczny",
      "level": 3,
      "content": "Aby szyfrować wiadomości innym osobom, a także weryfikować ich podpisy, potrzebujesz ich klucza publicznego. Aby zaimportować klucz publiczny z nazwą pliku public.key do twojego publicznego breloczka\n\n```\n$ gpg --import public.key\n```\n\nAlternatywnie, #Użyj serwera kluczy aby znaleźć klucz publiczny.\n\n"
    },
    {
      "title": "Użyj serwera kluczy",
      "level": 3,
      "content": "Możesz zarejestrować swój klucz za pomocą publicznego serwera kluczy PGP, aby inni mogli odzyskać klucz bez konieczności bezpośredniego kontaktu z Tobą:\n\n```\n$ gpg --send-keys user-id\n```\n\nAby poznać szczegóły klucza na serwerze kluczy, bez importowania go, wykonaj następujące czynności:\n\n```\n$ gpg --search-keys user-id\n```\n\nAby zaimportować klucz z serwera kluczy:\n\n```\n$ gpg --recv-keys key-id\n```\n\n- Powinieneś zweryfikować autentyczność pobranego klucza publicznego, porównując jego odcisk palca z tym, który właściciel opublikował w niezależnym źródle (np. Kontaktując się bezpośrednio z osobą). Zobacz Wikipedia:Public key fingerprint po więcej informacji.\n- Używanie krótkiego ID może napotkać na kolizje. Wszystkie klucze zostaną zaimportowane z krótkim identyfikatorem. Aby tego uniknąć, należy użyć pełnego identyfikatora odcisku palca lub długiego identyfikatora klucza podczas odbierania klucza. [3]\n\n- Dodanie keyserver-options auto-key-retrieve do gpg.conf automatycznie pobierze klucze z serwera kluczy w razie potrzeby.\n- Alternatywny serwer kluczy to pool.sks-keyservers.net i można go określić za pomocą keyserver w dirmngr.conf; Zobacz też wikipedia:Key server (cryptographic)#Keyserver examples.\n- Jeśli twoja sieć blokuje porty używane dla hkp / hkps, być może musisz podać port 80, tzn. pool.sks-keyservers.net:80\n- Możesz połączyć się z serwerem kluczy przez Tor używając --use-tor. Zobacz GnuPG blog post po więcej informacji.\n- Możesz połączyć się z serwerem kluczy za pomocą serwera proxy, ustawiając opcję http_proxy Zmienna i ustawienie środowiska honor-http-proxy w dirmngr.conf. Ewentualnie ustaw http-proxy host[:port] w dirmngr.conf, przesłonięte http_proxyZmienna środowiskowa.\n- Jeśli chcesz zaimportować identyfikator klucza, aby zainstalować konkretny pakiet Arch Linux, Zobacz pacman/Package signing#Managing the keyring i Makepkg#Signature checking.\n\n"
    },
    {
      "title": "Asymetryczne",
      "level": 4,
      "content": "Musisz zaimportować klucz publiczny użytkownika przed szyfrowaniem (opcje --encrypt or -e) pliku lub wiadomości do danego odbiorcy (opcje --recipient or -r). Dodatkowo musisz Utworzyć parę kluczy jeśli jeszcze tego nie zrobiłeś.\n\nAby zaszyfrować plik o nazwie \"doc\", użyj:\n\n```\n$ gpg --recipient user-id --encrypt doc\n```\n\nAby odszyfrować (opcja --decrypt lub -d) zaszyfrowany kluczem publicznym plik o nazwie doc .gpg za pomocą klucza prywatnego, użyj:\n\n```\n$ gpg --output doc --decrypt doc.gpg\n```\n\ngpg poprosi cię o podanie hasła, a następnie odszyfruje i zapisze dane z doc . gpg do doc . Jeśli pominiesz -o (--output) opcje, gpg zapisze odszyfrowane dane na standardowe wyjście.\n\n- Dodaj --armor zaszyfrować plik przy użyciu zbroi ASCII (nadaje się do kopiowania i wklejania wiadomości w formacie tekstowym)\n- Używająć -R user-id lub --hidden-recipient user-id zamiast -r nie umieszczać identyfikatorów kluczy odbiorców w zaszyfrowanej wiadomości. Pomaga to ukryć odbiorców wiadomości i stanowi ograniczony środek zaradczy przeciwko analizie ruchu.\n- Dodaj --no-emit-version aby uniknąć drukowania numeru wersji lub dodać odpowiednie ustawienie do pliku konfiguracyjnego.\n- Możesz użyć gnupg do zaszyfrowania poufnych dokumentów za pomocą własnego identyfikatora użytkownika jako odbiorcy lub używając --default-recipient-self zamiast tego flaga; można jednak wykonać tylko ten jeden plik naraz, chociaż zawsze można zarchiwizować różne pliki, a następnie zaszyfrować plik tar. Zobacz też Disk encryption#Available methods jeśli chcesz zaszyfrować katalogi lub cały system plików.\n\n"
    },
    {
      "title": "Symetryczne",
      "level": 4,
      "content": "Szyfrowanie symetryczne nie wymaga generowania pary kluczy i może być używane do prostego szyfrowania danych za pomocą hasła. Po prostu użyj --symmetric lub -c aby wykonać szyfrowanie symetryczne:\n\n```\n$ gpg -c doc\n```\n\nPoniższy przykład:\n\n- Szyfruje doc z symetrycznym szyfrem za pomocą hasła\n- Używa algorytmu szyfrowania AES-256 do szyfrowania hasła\n- Korzysta z algorytmu skrótu SHA-512, aby pomieszać hasło\n- Miesza hasło 65536 razy\n\n```\n$ gpg -c --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-count 65536 doc\n```\n\nAby odszyfrować symetrycznie zaszyfrowany doc.gpg za pomocą hasła i wypakować odszyfrowane treści do tego samego katalogu, co doc:\n\n```\n$ gpg --output doc --decrypt doc.gpg\n```\n\n"
    },
    {
      "title": "Zrób kopię swojego klucza prywatnego",
      "level": 3,
      "content": "Aby wykonać kopię zapasową klucza prywatnego, wykonaj następujące czynności:\n\n```\n$ gpg --export-secret-keys --armor <user-id> > privkey.asc\n```\n\nZwróć uwagę, że \"gpg\" wersja 2.1 zmieniła domyślne zachowanie, więc powyższe polecenie wymusza ochronę hasłem, nawet jeśli świadomie zdecydowałeś się nie używać go przy tworzeniu klucza. Jest tak, ponieważ w przeciwnym razie każdy, kto uzyska dostęp do powyższego wyeksportowanego pliku, będzie mógł szyfrować i podpisywać dokumenty tak, jakby były \"bez\", które wymagają znajomości hasła.\n\nAby zaimportować kopię zapasową klucza prywatnego:\n\n```\n$ gpg --import privkey.asc\n```\n\n"
    },
    {
      "title": "Zrób kopię certyfikatu unieważniającego",
      "level": 3,
      "content": "Certyfikaty unieważniające są generowane automatycznie dla nowo wygenerowanych kluczy. One domyślnie są usytuowane w ~/.gnupg/openpgp-revocs.d/. Nazwa pliku tego certyfikatu jest odciskiem palca klucza, którego unieważnia. Certyfikat unieważniający może zostać również ręcznie wygenerowany przez użytkownika użwywając:\n\n```\n$ gpg --gen-revoke --armor --output revcert.asc user-id\n```\n\nTen certyfikat może zostać wykorzystany do Unieważnienia klucza[broken link: invalid section], jeśli ten zostanie kiedyś zgubiony lub skompromitowany. Kopia zapasowa jest dlatego właśnie ważna, ponieważ gdy stracimy dostęp do prywatnego klucza, nie będziemy w stanie już później wygenerować takiego certyfikatu, jak za pomocą wyżej wymienionej komendy. Jest on na tyle krótki, aby został wydrukowany i wpisany ręcznie, gdy zajdzie taka potrzeba.\n\n"
    },
    {
      "title": "Edytuj swój klucz",
      "level": 3,
      "content": "Uruchomienie polecenia gpg --edit-key <user-id> wyświetli menu, które pozwoli ci wykonać większość kluczowych zadań związanych z zarządzaniem.\n\nKilka przydatnych poleceń w podmenu edycji kluczy:\n\n```\n> passwd       # change the passphrase\n> clean        # compact any user ID that is no longer usable (e.g revoked or expired)\n> revkey       # revoke a key\n> addkey       # add a subkey to this key\n> expire       # change the key expiration time\n```\n\nTyp help w podmenu edycji kluczy, aby uzyskać więcej poleceń.\n\n"
    },
    {
      "title": "Eksportowanie podklucza",
      "level": 3,
      "content": "Jeśli zamierzasz używać tego samego klucza na wielu urządzeniach, możesz usunąć klucz główny i przechowywać tylko minimalny podklucz szyfrowany na mniej bezpiecznych systemach.\n\nNajpierw sprawdź, który podklucz chcesz wyeksportować.\n\n```\n$ gpg -K\n```\n\nWybierz tylko ten podklucz do eksportu.\n\n```\n$ gpg -a --export-secret-subkeys [subkey id]! > /tmp/subkey.gpg\n```\n\nW tym momencie możesz przestać, ale najprawdopodobniej dobrze jest również zmienić hasło. Zaimportuj klucz do folderu tymczasowego.\n\n```\n$ gpg --homedir /tmp/gpg --import /tmp/subkey.gpg\n$ gpg --homedir /tmp/gpg --edit-key <user-id>\n> passwd\n> save\n$ gpg --homedir /tmp/gpg -a --export-secret-subkeys [subkey id]! > /tmp/subkey.altpass.gpg\n```\n\nW tym momencie możesz teraz użyć /tmp/subkey.altpass.gpg na innych urządzeniach.\n\n"
    },
    {
      "title": "Rotacja podkluczy",
      "level": 3,
      "content": "Note: **Nigdy** \n\nJeśli ustawiłeś podklucze, aby wygasły po określonym czasie, możesz utworzyć nowe. Zrób to z kilkutygodniowym wyprzedzeniem, aby inni mogli zaktualizować swoją bazę kluczy.\n\nUtwórz nowy podklucz (powtórz dla podpisu i klucza szyfrowania)\n\n```\n$ gpg --edit-key <user-id>\n> addkey\n```\n\nI odpowiedz na następujące pytania, które prosi (patrz#Utwórz parę kluczy dla sugerowanych ustawień).\n\nZapisz zmiany\n\n```\n> save\n```\n\nZaktualizuj go do serwera kluczy.\n\n```\n$ gpg --keyserver pgp.mit.edu --send-keys <user-id>\n```\n\n"
    },
    {
      "title": "Unieważnij klucz",
      "level": 3,
      "content": "Unieważnienie klucza powinno się wykonać gdy klucz zostanie skompromitowany, zastąpiony, jest już nieużywany lub gdy zapomnisz do niego swojego hasła. Wykonuje się to scalając klucz z certyfikatem unieważnienia.\n\nJeśli już nie masz dostępu do swojej pary kluczy, wpierw #Zaimportuj klucz publiczny by zaimportować własny klucz. Wtedy, by unieważnić swój klucz, zaimportuj plik zapisany w #Zrób kopię certyfikatu unieważniającego:\n\n```\n$ gpg --import revcert.asc\n```\n\nTeraz uniważnienie musi zostać upublicznione. #Użyj serwera kluczy by wysłać swój unieważniony klucz do serwera PGP jeśli takiego wcześniej użyłeś, w przeciwnym razie, eksportuj unieważniony klucz do pliku i roześlij do osób z którymi się komunikujesz.\n\n"
    },
    {
      "title": "Podpisy",
      "level": 2,
      "content": "Podpisy potwierdzają i znakują czasowo dokumenty. Jeśli dokument zostanie zmodyfikowany, weryfikacja podpisu nie powiedzie się. W przeciwieństwie do szyfrowania, które wykorzystuje klucze publiczne do szyfrowania dokumentu, podpisy tworzone są za pomocą klucza prywatnego. Odbiorca podpisanego dokumentu sprawdza następnie podpis za pomocą klucza publicznego nadawcy.\n\n"
    },
    {
      "title": "Zarejestruj plik",
      "level": 4,
      "content": "Aby podpisać plik, użyj --sign lub -s flaga:\n\n```\n$ gpg --output doc.sig --sign doc\n```\n\ndoc.sig zawiera zarówno skompresowaną zawartość oryginalnego pliku doc, jak i podpis w formacie binarnym, ale plik nie jest zaszyfrowany. możesz łączyć podpisywanie z szyfrowaniem\n\n"
    },
    {
      "title": "Clearsign a file or message",
      "level": 4,
      "content": "Aby podpisać plik bez kompresowania go do formatu binarnego użyj:\n\n```\n$ gpg --output doc.sig --clearsign doc\n```\n\nTutaj zarówno zawartość oryginalnej dokumentacji doc, jak i podpis są przechowywane w formie czytelnej dla człowieka w pliku doc.sig.\n\n"
    },
    {
      "title": "Utwórz oddzielny podpis",
      "level": 4,
      "content": "Aby utworzyć oddzielny plik podpisu, który ma być dystrybuowany oddzielnie od samego dokumentu lub pliku, użyj flagi --detach-sig\n\n```\n$ gpg --output doc.sig --detach-sig doc\n```\n\nTutaj podpis jest przechowywany w doc.sig, ale zawartość doc nie jest w nim zapisana. Ta metoda jest często używana w dystrybucji oprogramowania, aby umożliwić użytkownikom sprawdzenie, czy program nie został zmodyfikowany przez stronę trzecią.\n\n"
    },
    {
      "title": "Zweryfikuj podpis",
      "level": 3,
      "content": "Aby zweryfikować podpis, użyj flagi --verify\n\n```\n$ gpg --verify doc.sig\n```\n\ngdzie doc.sig to podpisany plik zawierający podpis, który chcesz zweryfikować.\n\nJeśli sprawdzasz odłączony podpis, zarówno podpisany plik danych, jak i plik podpisu muszą być obecne podczas weryfikacji. Na przykład, aby sprawdzić najnowszą wersję iso Arch Linux, wykonaj:\n\n```\n$ gpg --verify archlinux-version.iso.sig\n```\n\ngdzie archlinux-version.iso musi znajdować się w tym samym katalogu.\n\nMożna również określić podpisany plik danych z drugim argumentem:\n\n```\n$ gpg --verify archlinux-version.iso.sig /path/to/archlinux-version.iso\n```\n\nJeśli plik został zaszyfrowany, oprócz podpisu, po prostu odszyfruje plik i jego podpis również zostaną zweryfikowane.\n\n"
    },
    {
      "title": "gpg-agent",
      "level": 2,
      "content": "gpg-agent jest najczęściej używany jako demon do żądania i buforowania hasła dla pęku kluczy. Jest to przydatne, jeśli GnuPG jest używany z zewnętrznego programu, takiego jak klient poczty gnupg przychodzi z systemd user gniazda, które są domyślnie włączone. Te gniazda są gpg-agent.socket, gpg-agent-extra.socket, gpg-agent-browser.socket, gpg-agent-ssh.socket, i dirmngr.socket.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n- Główny gpg-agent.socket jest używany przez gpg do łączenia się z demonem gpg-agent.\n- Celem użycia gpg-agent-extra.socket w systemie lokalnym jest skonfigurowanie przekazywania domeny unixowej z systemu zdalnego. Umożliwia to używanie gpg w systemie zdalnym bez narażania kluczy prywatnych w systemie zdalnym. Aby uzyskać szczegółowe informacje, patrz gpg-agent(1).\n- gpg-agent-ssh.socket może być używany przez SSH do buforowania kluczy SSH dodanych przez program ssh-add. Zobacz #SSH agent dla potrzebnej konfiguracji.\n- dirmngr.socket uruchamia demona GnuPG obsługującego połączenia z serwerami kluczy.\n\n.\n\n"
    },
    {
      "title": "Konfiguracja",
      "level": 3,
      "content": "gpg-agent można skonfigurować za pomocą pliku ~/.gnupg/gpg-agent.conf. Opcje konfiguracji są wymienione w gpg-agent(1). Na przykład możesz zmienić podręczne cache dla nieużywanych kluczy:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\ndefault-cache-ttl 3600\n```\n\nNote: gdzie XXXX jest kluczem. Możesz uzyskać jego wartość podczas uruchamiania gpg --with-keygrip -K. Hasło zostanie zapisane, dopóki gpg-agent nie zostanie zrestartowany. Jeśli ustawisz wartość default-cache-ttl, będzie ona miała pierwszeństwo.\n\n```\n$ /usr/lib/gnupg/gpg-preset-passphrase --preset XXXXXX\n```\n\ngdzie XXXX jest kluczem. Możesz uzyskać jego wartość podczas uruchamiania gpg --with-keygrip -K. Hasło zostanie zapisane, dopóki gpg-agent nie zostanie zrestartowany. Jeśli ustawisz wartość default-cache-ttl, będzie ona miała pierwszeństwo.\n\n"
    },
    {
      "title": "Załaduj ponownie agenta",
      "level": 3,
      "content": "Po zmianie konfiguracji, ponownie załaduj agenta za pomocą gpg-connect-agent:\n\n```\n$ gpg-connect-agent reloadagent /bye\n```\n\nPolecenie powinno wyświetlić OK.\n\nJednak w niektórych przypadkach tylko ponowne uruchomienie może nie być wystarczające, np. Gdy keep-screen został dodany do konfiguracji agenta. W takim przypadku najpierw musisz zabić trwający proces gpg-agent, a następnie możesz go ponownie uruchomić, jak wyjaśniono powyżej.\n\n"
    },
    {
      "title": "pinentry",
      "level": 3,
      "content": "Wreszcie, agent musi wiedzieć, jak poprosić użytkownika o hasło. Można to ustawić w pliku konfiguracyjnym gpg-agent.\n\nDomyślne używa okna dialogowego gtk. Dostępne są inne opcje - patrz informacja o pinentry. Aby zmienić konfigurację okna dialogowego, ustaw konfigurację programu pinentry-program:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\n# PIN entry program\n# pinentry-program /usr/bin/pinentry-curses\n# pinentry-program /usr/bin/pinentry-qt\n# pinentry-program /usr/bin/pinentry-kwallet\n\npinentry-program /usr/bin/pinentry-gtk-2\n```\n\nPo wprowadzeniu tej zmiany, ponownie załaduj gpg-agent.\n\n"
    },
    {
      "title": "Bezobsługowe hasło",
      "level": 3,
      "content": "Począwszy od GnuPG 2.1.0, wymagane jest użycie gpg-agent i pinentry, co może przełamać kompatybilność wsteczną dla haseł wprowadzanych przez STDIN za pomocą opcji --passphrase-fd 0. Aby mieć ten sam typ funkcjonalności co starsze wersje, należy zrobić dwie rzeczy:\n\nNajpierw edytuj konfigurację gpg-agent, aby umożliwić tryb pracy z loopback\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\nallow-loopback-pinentry\n```\n\nZrestartuj proces gpg-agent, jeśli jest uruchomiony, aby zmiana zaczęła obowiązywać.\n\nPo drugie, albo aplikacja musi zostać zaktualizowana, aby zawierała parametr wiersza poleceń, aby użyć trybu pętli zwrotnej, jak na przykład:\n\n```\n$ gpg --pinentry-mode loopback ...\n```\n\n...lub jeśli nie jest to możliwe, dodaj opcję do konfiguracji:\n\n```\n~/.gnupg/gpg.conf\n```\n\n```\npinentry-mode loopback\n```\n\n"
    },
    {
      "title": "SSH agent",
      "level": 3,
      "content": "gpg-agent ma emulację agenta OpenSSH. Jeśli już korzystasz z pakietu GnuPG, możesz rozważyć użycie jego agenta do buforowania SSH keys Ponadto niektórzy użytkownicy mogą preferować okno dialogowe wprowadzania kodu PIN, które zapewnia agent GnuPG w ramach zarządzania hasłami.\n\n"
    },
    {
      "title": "Set SSH_AUTH_SOCK",
      "level": 4,
      "content": "Musisz ustawić SSH_AUTH_SOCK, aby SSH używał gpg-agent zamiast ssh-agent. Aby upewnić się, że każdy proces może znaleźć Twoją instancję gpg-agent niezależnie od np. typ powłoki jest dzieckiem użytkowania pam_env.\n\n```\n~/.config/environment.d/50-ssh_auth_sock.conf\n```\n\n```\nSSH_AGENT_PID\tDEFAULT=\nSSH_AUTH_SOCK\tDEFAULT=\"${XDG_RUNTIME_DIR}/gnupg/S.gpg-agent.ssh\"\n```\n\nEwentualnie zależą od Bash. Działa to również w przypadku niestandardowych lokalizacji gniazd:\n\n```\n~/.bashrc\n```\n\n```\nunset SSH_AGENT_PID\nif [ \"${gnupg_SSH_AUTH_SOCK_by:-0}\" -ne $$ ]; then\n  export SSH_AUTH_SOCK=\"$(gpgconf --list-dirs agent-ssh-socket)\"\nfi\n```\n\n"
    },
    {
      "title": "Skonfiguruj pinentry, aby użyć prawidłowego TTY",
      "level": 4,
      "content": "Ustaw również GPG_TTY i odśwież TTY, jeśli użytkownik przełączył się w sesję X, jak podano w gpg-agent(1). Na przykład:\n\n```\n~/.bashrc\n```\n\n```\n# Set GPG TTY\nexport GPG_TTY=$(tty)\n\n# Refresh gpg-agent tty in case user switches into an X session\ngpg-connect-agent updatestartuptty /bye >/dev/null\n```\n\n"
    },
    {
      "title": "Dodaj klucze SSH",
      "level": 4,
      "content": "Po uruchomieniu gpg-agent możesz użyć ssh-add do zatwierdzenia kluczy, wykonując te same kroki, co dla ssh-agent. Lista zatwierdzonych kluczy przechowywana jest w pliku ~/.gnupg/sshcontrol.\n\nPo zatwierdzeniu klucza, za każdym razem, gdy potrzebne jest hasło, otrzymasz okno dialogowe z danymi. Możesz kontrolować buforowanie hasła w pliku ~/.gnupg/gpg-agent.conf. W poniższym przykładzie gpg-agent będzie przechowywać klucze w pamięci podręcznej przez 3 godziny:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\ndefault-cache-ttl-ssh 10800\nmax-cache-ttl-ssh 10800\n```\n\n"
    },
    {
      "title": "Użyj klucza GPG jako klucza SSH",
      "level": 4,
      "content": "Jeśli używasz gpg-agent jako agent SSH, możesz użyć swojego klucza GnuPG jako klucza SSH. Zmniejsza to kluczową konserwację i możesz przechowywać klucz SSH na karcie dostępu. Musisz utworzyć klucz z funkcją uwierzytelniania (patrz #Niestandardowe funkcje). GnuPG automatycznie użyje tego klucza, jeśli będzie to konieczne. Aby sprawdzić, czy klucz został dodany, uruchom:\n\n```\n$ ssh-add -l\n```\n\nKomentarz do klucza powinien wyglądać tak: openpgp:key-id cardno:card-id.\n\n"
    },
    {
      "title": "Smartcards",
      "level": 2,
      "content": "GnuPG używa scdaemona jako interfejsu do czytnika kart inteligentnych. Szczegółowe informacje znajdują się w man page\n\n"
    },
    {
      "title": "GnuPG only setups",
      "level": 3,
      "content": "Jeśli nie planujesz używać innych kart oprócz tych opartych na GnuPG, powinieneś sprawdzić parametr port-czytnika w ~/.gnupg/scdaemon.conf. Wartość \"0\" odnosi się do pierwszego dostępnego czytnika portów szeregowych, a wartość \"32768\" (domyślnie) odnosi się do pierwszego czytnika USB.\n\n"
    },
    {
      "title": "GnuPG z pcscd (PCSC Lite)",
      "level": 3,
      "content": "pcscd to demon, który obsługuje dostęp do karty inteligentnej (SCard API). Jeśli scduemon GnuPG nie połączy bezpośrednio karty inteligentnej (np. Za pomocą zintegrowanej obsługi CCID), będzie się starał znaleźć kartę elektroniczną za pomocą sterownika PCSC Lite.\n\n"
    },
    {
      "title": "Zawsze używaj pcscd",
      "level": 4,
      "content": "Jeśli używasz jakiejkolwiek karty inteligentnej ze sterownikiem opensc (np .: karty identyfikacyjne z niektórych krajów) powinieneś zwrócić uwagę na konfigurację GnuPG. Po wyjęciu z pudełka możesz otrzymać wiadomość podobną do tej, gdy używasz gpg --card-status\n\n```\ngpg: selecting openpgp failed: ec=6.108\n```\n\nDomyślnie scdaemon będzie próbował łączyć się bezpośrednio z urządzeniem. To połączenie zakończy się niepowodzeniem, jeśli czytnik będzie używany przez inny proces. Na przykład: demon pcscd używany przez OpenSC. Aby poradzić sobie z tą sytuacją, powinniśmy użyć tego samego sterownika, co opensc, aby mogli dobrze współpracować. W celu wskazania scdaemona do użycia pcscd powinieneś usunąć reader-port z ~/.gnupg/scdaemon.conf, określić lokalizację biblioteki libpcsclite.so i wyłączyć ccid, abyśmy upewnili się, że używamy pcscd:\n\n```\n~/.gnupg/scdaemon.conf\n```\n\n```\npcsc-driver /usr/lib/libpcsclite.so\ncard-timeout 5\ndisable-ccid\n```\n\nSprawdź scdaemon(1), jeśli nie korzystasz z OpenSC.\n\n"
    },
    {
      "title": "Inny algorytm",
      "level": 3,
      "content": "Możesz użyć silniejszych algorytmów:\n\n```\n~/.gnupg/gpg.conf\n```\n\n```\n...\n\npersonal-digest-preferences SHA512\ncert-digest-algo SHA512\ndefault-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed\npersonal-cipher-preferences TWOFISH CAMELLIA256 AES 3DES\n```\n\nW najnowszej wersji GnuPG domyślnymi algorytmami są SHA256 i AES, które są wystarczająco bezpieczne dla większości ludzi. Jeśli jednak używasz wersji GnuPG starszej niż 2.1 lub chcesz uzyskać jeszcze wyższy poziom bezpieczeństwa, wykonaj powyższy krok.\n\n"
    },
    {
      "title": "Zaszyfruj hasło",
      "level": 3,
      "content": "Przydaje się szyfrowanie hasła, więc nie będzie ono zapisane w pliku konfiguracyjnym. Dobrym przykładem jest twoje hasło e-mail.\n\nNajpierw utwórz plik z hasłem. Po podaniu hasła musisz zostawić jedną pustą linię, w przeciwnym razie gpg zwróci komunikat o błędzie podczas oceniania pliku.\n\nNastępnie uruchom:\n\n```\n$ gpg -e -a -r <user-id> your_password_file\n```\n\n-e is for encrypt, -a for armor (ASCII output), -r for recipient user ID.\n\nZostaniesz z nowym plikiem your_password_file.asc\n\n"
    },
    {
      "title": "Odwoływanie klucza",
      "level": 3,
      "content": "- Każdy, kto ma dostęp do Twojego certyfikatu unieważnienia, może odwołać klucz, czyniąc go bezużytecznym.\n- Odwołanie klucza powinno być wykonywane tylko w przypadku złamania lub zgubienia klucza, lub zapomnienia hasła.\n\nCertyfikaty unieważnienia są generowane automatycznie dla nowo wygenerowanych kluczy, chociaż jeden z nich może zostać wygenerowany ręcznie przez użytkownika później. Są one zlokalizowane w ~/.gnupg/openpgp-revocs.d/. Nazwa pliku certyfikatu to odcisk palca klucza, który zostanie odwołany.\n\nAby unieważnić klucz, wystarczy zaimportować certyfikat unieważnienia:\n\n```\n$ gpg --import <fingerprint>.rev\n```\n\nTeraz zaktualizuj serwer kluczy:\n\n```\n$ gpg --keyserver subkeys.pgp.net --send-keys <userid>\n```\n\n"
    },
    {
      "title": "Change trust model",
      "level": 3,
      "content": "By default GnuPG uses the Web of Trust as the trust model. You can change this to Trust on first use by adding --trust-model=tofu when adding a key or adding this option to your GnuPG configuration file. More details are in this email to the GnuPG list.\n\n"
    },
    {
      "title": "Ukryj wszystkie identyfikatory odbiorców",
      "level": 3,
      "content": "Domyślnie identyfikator klucza odbiorcy znajduje się w zaszyfrowanej wiadomości. Można go usunąć w czasie szyfrowania dla odbiorcy za pomocą ukrytego odbiorcy hidden-recipient <user-id>. Aby usunąć go dla wszystkich odbiorców, dodaj throw-keyids do pliku konfiguracyjnego. Pomaga to ukryć odbiorców wiadomości i stanowi ograniczony środek zaradczy przeciwko analizie ruchu. (Korzystając z małej inżynierii społecznej, każdy, kto potrafi odszyfrować wiadomość, może sprawdzić, czy jeden z pozostałych odbiorców jest tym, kogo podejrzewa.) Po stronie odbierającej może spowolnić proces deszyfrowania, ponieważ wszystkie dostępne klucze tajne muszą zostać wypróbowane ( np. z --try-secret-key <user-id>).\n\n"
    },
    {
      "title": "Używanie caff do wysyłania kluczy partiami",
      "level": 3,
      "content": "Aby umożliwić użytkownikom sprawdzanie poprawności kluczy w serwerach kluczy iw ich plikach kluczy (to znaczy upewnić się, że pochodzą od kogo się podają), PGP/GPG korzysta z Web of Trust. Strony z kluczami pozwalają użytkownikom zebrać się w fizycznej lokalizacji, aby sprawdzić klucze. Protokół podpisywania kluczy Zimmermann-Sassaman jest sposobem na uczynienie ich bardzo skutecznymi. Tutaj znajdziesz artykuł z instrukcjami.\n\nAby ułatwić proces podpisywania kluczy i wysyłania podpisów do właścicieli po keysigning party możesz użyć narzędzia caff. Można go zainstalować z AUR z pakietem caff-gitAUR.\n\nAby wysłać podpisy do ich właścicieli, potrzebujesz działającego MTA. Jeśli jeszcze go nie masz, zainstaluj msmtp.\n\n"
    },
    {
      "title": "Zawsze pokazuj długie identyfikatory i odciski palca",
      "level": 3,
      "content": "Aby zawsze wyświetlać długie identyfikatory klucza, dodaj plik keyid-format 0xlong do pliku konfiguracyjnego. Aby zawsze wyświetlać pełne with-fingerprint do pliku konfiguracyjnego.\n\n"
    },
    {
      "title": "Niestandardowe funkcje",
      "level": 3,
      "content": "W celu dalszego dostosowania można również ustawić niestandardowe możliwości do kluczy. Dostępne są następujące możliwości:\n\n- Certify (tylko dla kluczy głównych) - pozwala kluczowi tworzyć podklucze, obowiązkowe dla kluczy głównych.\n- Sign - pozwala kluczowi tworzyć podpisy kryptograficzne, które inni mogą zweryfikować za pomocą klucza publicznego.\n- Encrypt - umożliwia każdemu szyfrowanie danych za pomocą klucza publicznego, który tylko klucz prywatny może odszyfrować.\n- Authenticate - umożliwia uwierzytelnianie klucza za pomocą różnych programów innych niż GnuPG. Klucz może być użyty jako np. klucz SSH.\n\nMożliwe jest określenie możliwości klucza głównego, uruchamiając:\n\n```\n$ gpg --full-generate-key --expert\n```\n\nWybierz opcję, która pozwala ustawić własne możliwości.\n\nComparably, to specify custom capabilities for subkeys, add the --expert flag to gpg --edit-key, see #Edytuj swój klucz for more information.\n\nPorównywalnie, aby określić niestandardowe możliwości dla podkluczy, dodaj --expert flag to gpg --edit-key zobacz #Edytuj swój klucz, aby uzyskać więcej informacji.\n\n"
    },
    {
      "title": "Cache passwords",
      "level": 3,
      "content": "Aby otrzymać hasło do GnuPG tylko raz na sesję, ustaw max-cache-ttl i default-cache-ttl na coś bardzo wysokiego, na przykład:\n\n```\ngpg-agent.conf\n```\n\n```\nmax-cache-ttl 60480000\ndefault-cache-ttl 60480000\n```\n\nZobacz #gpg-agent.\n\n"
    },
    {
      "title": "Nie ma wystarczającej liczby losowych bajtów",
      "level": 3,
      "content": "Podczas generowania klucza, gpg można napotkać ten błąd:\n\n```\nNot enough random bytes available. Please do some other work to give the OS a chance to collect more entropy!\n```\n\nAby sprawdzić dostępną entropię, sprawdź parametry jądra:\n\n```\ncat /proc/sys/kernel/random/entropy_avail\n```\n\nZdrowy system linuksowy z dużą dostępną entropią powróci do pełnej liczby 4096 bitów entropii. Jeśli wartość zwracana jest mniejsza niż 200, systemu zaczyna brakować entropii.\n\nAby go rozwiązać, pamiętaj, że często nie trzeba tworzyć kluczy, a najlepiej robić to, co sugeruje komunikat (np. Tworzyć aktywność na dysku, poruszać myszą, edytować wiki - wszystko stworzy entropię). Jeśli to nie pomoże, sprawdź, która usługa wykorzystuje entropię i zastanów się, czy nie zatrzymać jej na czas. Jeśli to nie jest alternatywa, zobacz Random number generation#Alternatives.\n\n"
    },
    {
      "title": "su",
      "level": 3,
      "content": "Podczas używania pinentry musisz mieć odpowiednie uprawnienia urządzenia końcowego (np. /dev/tty1) w użyciu. Jednak w przypadku su (lub sudo) własność pozostaje z oryginalnym użytkownikiem, a nie nowym. Oznacza to, że pinentry zawiedzie, nawet jako root. Poprawka polega na zmianie uprawnień urządzenia w pewnym momencie przed użyciem pinentry (tj. Za pomocą gpg z agentem). Jeśli robisz gpg jako root, po prostu zmień właściciela na root przed użyciem gpg:\n\n```\n# chown root /dev/ttyN  # where N is the current tty\n```\n\na następnie zmienić go po użyciu gpg po raz pierwszy. Odpowiednik ten prawdopodobnie będzie true w /dev/pts/.\n\nNote: **nie** \n\n```\n# script -q -c \"gpg --gen-key\" /dev/null\n```\n\n"
    },
    {
      "title": "Agent complains end of file",
      "level": 3,
      "content": "Domyślnym programem pinentry jest pinentry-gtk-2, który do prawidłowego działania potrzebuje magistrali sesji DBus. Zobacz General troubleshooting#Session permissions szczegółowe informacje.\n\nAlternatywnie możesz użyć pinentry-qt. Zobacz #pinentry.\n\n"
    },
    {
      "title": "KGpg configuration permissions",
      "level": 3,
      "content": "Pojawiły się problemy z kgpg możliwością uzyskania dostępu do pliku ~/.gnupg/ options. Jeden problem może być wynikiem przestarzałego pliku opcji, zobacz raport o błędzie bug report.\n\n"
    },
    {
      "title": "GNOME na Wayland zastępuje gniazdo agenta SSH",
      "level": 3,
      "content": "W przypadku sesji Wayland, gnome-session ustawia SSH_AUTH_SOCK na standardowe gniazdo gnome-keyring, $ $XDG_RUNTIME_DIR/keyring/ssh. To przesłoni wszelkie wartości ustawione w ~/.pam_environmment lub systemd jednostek jednostkowych.\n\nAby wyłączyć to zachowanie, ustaw zmienną GSM_SKIP_AGENT_WORKAROUND:\n\n```\n~/.pam_environment\n```\n\n```\nSSH_AGENT_PID\tDEFAULT=\nSSH_AUTH_SOCK\tDEFAULT=\"${XDG_RUNTIME_DIR}/gnupg/S.gpg-agent.ssh\"\nGSM_SKIP_SSH_AGENT_WORKAROUND\tDEFAULT=\"true\"\n```\n\n"
    },
    {
      "title": "mutt",
      "level": 3,
      "content": "Mutt może nie używać poprawnie gpg-agent, musisz ustawić zmienną środowiskową GPG_AGENT_INFO (treść nie ma znaczenia) podczas uruchamiania mutt. Upewnij się także, czy poprawnie buforujesz hasła, patrz #Cache passwords.\n\nZobacz this forum thread\n\n"
    },
    {
      "title": "\"Utracone\" klucze, aktualizacja do wersji 2.1 Gnupg",
      "level": 3,
      "content": "Kiedy gpg gpg --list-keys nie pokazuje kluczy, które były tam wcześniej, a aplikacje narzekają na brakujące lub nieprawidłowe klucze, niektóre klucze mogły nie zostać zmigrowane do nowego formatu.\n\nPrzeczytaj GnuPG invalid packet workaround Zasadniczo jest napisane, że istnieje błąd związany z kluczami w starych plikach pubring.gpg i secring.gpg, które zostały zastąpione nowym plikiem pubring.kbx oraz podkatalogiem private-keys-v1.d/ i plikami. Twoje brakujące klucze można odzyskać za pomocą następujących komend:\n\n```\n$ cd\n$ cp -r .gnupg gnupgOLD\n$ gpg --export-ownertrust > otrust.txt\n$ gpg --import .gnupg/pubring.gpg\n$ gpg --import-ownertrust otrust.txt\n$ gpg --list-keys\n```\n\n"
    },
    {
      "title": "gpg zawiesza się dla wszystkich serwerów kluczy (podczas próby odebrania kluczy)",
      "level": 3,
      "content": "Jeśli gpg zawieszi się z określonym serwerem kluczy podczas próby odebrania kluczy, być może trzeba zabić dirmngr, aby uzyskać dostęp do innych serwerów kluczy, które faktycznie działają, w przeciwnym razie może zachowywać zawieszenie dla nich wszystkich.\n\n"
    },
    {
      "title": "Nie wykryto SmartCard",
      "level": 3,
      "content": "Twój użytkownik może nie mieć uprawnień dostępu do karty elektronicznej, co powoduje card error , mimo że karta jest poprawnie skonfigurowana i włożona.\n\nJednym z możliwych rozwiązań jest dodanie nowego scard grupy, w tym użytkowników, którzy potrzebują dostępu do smartcard.\n\nNastępnie użyj reguły udev , podobnej do następującej:\n\n```\n/etc/udev/rules.d/71-gnupg-ccid.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"usb\", ENV{ID_VENDOR_ID}==\"1050\", ENV{ID_MODEL_ID}==\"0116|0111\", MODE=\"660\", GROUP=\"scard\"\n```\n\nTrzeba dostosować VENDOR i MODEL zgodnie z wyjściem lsusb, powyższy przykład dotyczy YubikeyNEO.\n\n"
    },
    {
      "title": "gpg: WARNING: server 'gpg-agent' is older than us (x < y)",
      "level": 3,
      "content": "To ostrzeżenie pojawia się, gdy gnupgjest uaktualniony, a stary gpg-agent nadal działa. Zrestartuj gpg-agent.socket użytkownika (tj. Użyj flagi --user podczas ponownego uruchamiania).\n\n"
    },
    {
      "title": "gpg: ..., IPC connect call failed",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nUpewnij się, że gpg-agent i dirmngr nie działają z killall gpg-agent dirmngr, a folder $GNUPGHOME/crls.d/ ma uprawnienia ustawione na 700.\n\nJeśli twoj keyring jest przechowywana na systemie plików vFat (np. Dysku USB), gpg-agent nie będzie w stanie utworzyć wymaganych gniazd (vFat nie obsługuje gniazd), możesz utworzyć przekierowania do lokalizacji, która obsługuje gniazda, np. /dev/shm:\n\n```\n# export GNUPGHOME=/custom/gpg/home\n# printf '%%Assuan%%\\nsocket=/dev/shm/S.gpg-agent\\n' > $GNUPGHOME/S.gpg-agent\n# printf '%%Assuan%%\\nsocket=/dev/shm/S.gpg-agent.browser\\n' > $GNUPGHOME/S.gpg-agent.browser\n# printf '%%Assuan%%\\nsocket=/dev/shm/S.gpg-agent.extra\\n' > $GNUPGHOME/S.gpg-agent.extra\n# printf '%%Assuan%%\\nsocket=/dev/shm/S.gpg-agent.ssh\\n' > $GNUPGHOME/S.gpg-agent.ssh\n```\n\nSprawdź, czy gpg-agent uruchamia się pomyślnie z gpg-agent --daemon.\n\n"
    },
    {
      "title": "Zobacz też",
      "level": 2,
      "content": "- GNU Privacy Guard Homepage\n- RFC4880 \"OpenPGP Message Format\"\n- Creating GPG Keys (Fedora)\n- OpenPGP subkeys in Debian\n- A more comprehensive gpg Tutorial\n- gpg.conf recommendations and best practices\n- Torbirdy gpg.conf\n- /r/GPGpractice - a subreddit to practice using GnuPG.\n- Protecting code integrity with PGP\n\n"
    }
  ]
}