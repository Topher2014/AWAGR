{
  "title": "Simple stateful firewall (Español)",
  "url": "https://wiki.archlinux.org/title/Simple_stateful_firewall_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2018-09-05** \n\nArtículos relacionados\n\n- Firewalls\n- Internet sharing\n- Nftables#Simple stateful firewall\n- Router\n- Uncomplicated Firewall\n\nEsta página explica cómo configurar un cortafuegos stateful usando iptables. También explica lo que significan las reglas y por qué son necesarias. Para simplificar, se divide en dos secciones principales. La primera sección trata sobre la configuración de un cortafuegos para una sola máquina, la segunda establece la configuración de una puerta de enlace NAT además de la del cortafuegos de la primera sección.\n\n"
    },
    {
      "title": "Requisitos previos",
      "level": 2,
      "content": "En primer lugar, instale las herramientas iptables en el espacio de usuario o verifique que ya están instaladas.\n\nEste artículo supone que no hay reglas iptables establecidas en su sistema. Para comprobar el conjunto de reglas vigentes y cerciorarse que no existen actualmente reglas, ejecute lo siguiente:\n\n```\n# iptables-save\n```\n\n```\n# Generated by iptables-save v1.4.19.1 on Thu Aug  1 19:28:53 2013\n*filter\n:INPUT ACCEPT [50:3763]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [30:3472]\nCOMMIT\n# Completed on Thu Aug  1 19:28:53 2013\n```\n\no\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 156 packets, 12541 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 82 packets, 8672 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nSi hay reglas, podrá ser capaz de restablecerlas, cargando el conjunto de reglas por defecto:\n\n```\n# iptables-restore < /etc/iptables/empty.rules\n```\n\nDe lo contrario, vea Iptables (Español)#Restablecer las reglas.\n\n"
    },
    {
      "title": "Crear las cadenas necesarias",
      "level": 3,
      "content": "Para esta configuración básica, vamos a crear dos cadenas, definidas por el usuario, que utilizaremos para abrir puertos en el cortafuegos.\n\n```\n# iptables -N TCP\n# iptables -N UDP\n```\n\nLas cadenas pueden tener, por supuesto, nombres arbitrarios. Elegimos estos nombres solo para que coincidan con los protocolos que queremos manejar con ellos en las reglas posteriores, que se especifican con las opciones del protocolo, por ejemplo, -p tcp, siempre.\n\n"
    },
    {
      "title": "La cadena FORWARD",
      "level": 3,
      "content": "Si desea configurar el equipo como una puerta de enlace NAT, vaya a #Configurar una puerta de enlace NAT. Para una sola máquina, sin embargo, simplemente establecemos la política de la cadena FORWARD en DROP y continuamos con la configuración:\n\n```\n# iptables -P FORWARD DROP\n```\n\n"
    },
    {
      "title": "La cadena OUTPUT",
      "level": 3,
      "content": "No tenemos ninguna intención de filtrar todo el tráfico saliente, ya que esto haría la configuración mucho más complicada y requeriría alguna reflexión adicional. Para el caso simple que nos ocupa, ponemos la política OUTPUT en ACCEPT.\n\n```\n# iptables -P OUTPUT ACCEPT\n```\n\n"
    },
    {
      "title": "La cadena INPUT",
      "level": 3,
      "content": "De manera similar a las cadenas anteriores, fijamos la política predeterminada para la cadena INPUT en DROP como medida preventiva para evitar que se nos deslice algún error en nuestras reglas. Cerrar todo el tráfico y especificar luego qué tráfico entrante está permitido es la mejor manera de hacer un cortafuegos seguro.\n\n```\n# iptables -P INPUT DROP\n```\n\nCada paquete que se recibe por cualquier interfaz de red pasará primero por la cadena INPUT, si está destinado a nuestra máquina. Con esta cadena, nos aseguraremos de que solo los paquetes que queremos sean aceptados.\n\nLa primera regla añadida a la cadena INPUT permitirá el tráfico perteneciente a las conexiones ya establecidas, o para el nuevo tráfico válido relacionado con estas conexiones, como los errores ICMP, o las respuestas de Echo (los paquetes que retornan al equipo cuando se hace ping —«(...) es un servicio de red que repite aquel comando que se le envía (como el eco). Es útil para hacer comprobaciones sobre el estado de la conectividad de una red» (fuente)—). ICMP (siglas en inglés de Internet Control Message Protocol) significa Protocolo de Mensajes de Control de Internet. Algunos mensajes ICMP son muy importantes y ayudan a gestionar la congestión y MTU, y son aceptados por esta regla.\n\nEl estado de conexión ESTABLISHED implica que, o bien otra regla anteriormente permitió la conexión inicial intentada (--ctstate NEW), o bien la conexión ya estaba activa (por ejemplo, una conexión SSH remota activa) al tiempo de establecer esta regla:\n\n```\n# iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n```\n\nLa segunda regla aceptará todo el tráfico de la interfaz (lo) «loopback», que es necesario para muchas aplicaciones y servicios.\n\n```\n# iptables -A INPUT -i lo -j ACCEPT\n```\n\nLa tercera regla descartará todo el tráfico que coincida con el estado «INVALID». El tráfico puede agruparse en una de las cuatro categorías de «estado»: NEW, ESTABLISHED, RELATED o INVALID, y esto es lo que hace de este sea un cortafuegos «stateful» (podríamos definirlo como un cortafuegos de filtrado dinámico de paquetes), en lugar de un cortafuegos «stateless» (filtrado de paquetes sin estado) que es menos seguro. Los estados hacen un seguimiento usando los módulos del kernel «nf_conntrack_*» que se cargan automáticamente por el kernel a medida que se añaden las reglas.\n\n- Esta regla descartará todos los paquetes con cabeceras o sumas de comprobación no válidas, indicadores TCP no válidos, mensajes ICMP no válidos (como un puerto inaccesible cuando no enviamos nada para el equipo), y descarta los paquetes secuenciados que pueden ser causados por la predicción de secuencia u otros ataques similares. El objetivo de «DROP» es descartar un paquete sin dar ninguna respuesta, contrariamente a REJECT que rechaza el paquete. Utilizamos DROP porque no hay una respuesta adecuada a los paquetes que no son válidos, y no queremos reconocer que hemos recibido esos paquetes.\n- Los paquetes Neighbor Discovery de ICMPv6 permanecen sin seguimiento, y siempre se clasifican «INVALID» aunque no estén dañados o similares. Tenga esto presente, y acepte dicha situación antes de esta regla: iptables -A INPUT -p 41 -j ACCEPT\n\n```\n# iptables -A INPUT -m conntrack --ctstate INVALID -j DROP\n```\n\nLa siguiente regla aceptará todos las nuevas peticiones de ICMP echo requests, también conocidas como pings. Solo el primer paquete contará como NUEVO, el resto estará a cargo de la regla RELATED,ESTABLISHED. Dado que el equipo no es un router, ningún otro tráfico ICMP con el estado NEW necesita ser permitido.\n\n```\n# iptables -A INPUT -p icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT\n```\n\nAhora asociamos las cadenas TCP y UDP a la cadena INPUT para manejar todas las nuevas conexiones entrantes. Una vez que una conexión es aceptada por la cadena TCP o UDP, la misma es manejada por la regla de tráfico RELATED/ESTABLISHED. Las cadenas TCP y UDP bien aceptan las nuevas conexiones entrantes, o bien las rechazan. Las nuevas conexiones TCP deben comenzar con paquetes SYN.\n\n```\n# iptables -A INPUT -p udp -m conntrack --ctstate NEW -j UDP\n# iptables -A INPUT -p tcp --syn -m conntrack --ctstate NEW -j TCP\n```\n\nRechazamos las conexiones TCP con paquetes RESET de TCP y flujos de UDP con mensaje de puerto ICMP inalcanzable, si no se abren los puertos. Esto imita el comportamiento predeterminado de Linux (RFC), y que permite al remitente cerrar rápidamente la conexión y limpiarla.\n\n```\n# iptables -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable\n# iptables -A INPUT -p tcp -j REJECT --reject-with tcp-reset\n```\n\nPara otros protocolos, añadimos una regla final para la cadena INPUT para rechazar todo el tráfico entrante restante con protocolo ICMP de mensajes inaccesibles. Esto imita el comportamiento por defecto de Linux.\n\n```\n# iptables -A INPUT -j REJECT --reject-with icmp-proto-unreachable\n```\n\n"
    },
    {
      "title": "Archivo resultante de iptables.rules",
      "level": 3,
      "content": "He aquí un ejemplo de archivo iptables.rules que se obtendría después de ejecutar todas las órdenes anteriores:\n\n```\n/etc/iptables/iptables.rules\n```\n\n```\n# Generated by iptables-save v1.4.18 on Sun Mar 17 14:21:12 2013\n*filter\n:INPUT DROP [0:0]\n:FORWARD DROP [0:0]\n:OUTPUT ACCEPT [0:0]\n:TCP - [0:0]\n:UDP - [0:0]\n-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -m conntrack --ctstate INVALID -j DROP\n-A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT\n-A INPUT -p udp -m conntrack --ctstate NEW -j UDP\n-A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP\n-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable\n-A INPUT -p tcp -j REJECT --reject-with tcp-reset\n-A INPUT -j REJECT --reject-with icmp-proto-unreachable\nCOMMIT\n# Completed on Sun Mar 17 14:21:12 2013\n```\n\nEste archivo se puede generar con:\n\n```\n# iptables-save > /etc/iptables/iptables.rules\n```\n\ny se puede utilizar como base para continuar con las siguientes secciones. Si va a configurar un cortafuegos de forma remota a través de SSH, añada la siguiente regla para permitir nuevas conexiones SSH antes de continuar (ajustar el puerto si es necesario):\n\n```\n-A TCP -p tcp --dport 22 -j ACCEPT\n```\n\n"
    },
    {
      "title": "Las cadenas TCP y UDP",
      "level": 3,
      "content": "Las cadenas TCP y UDP contienen reglas para la aceptación de nuevas conexiones TCP y flujos UDP entrantes para puertos específicos.\n\n"
    },
    {
      "title": "Apertura de puertos para conexiones entrantes",
      "level": 4,
      "content": "Para aceptar conexiones TCP entrantes en el puerto 80 para un servidor web:\n\n```\n# iptables -A TCP -p tcp --dport 80 -j ACCEPT\n```\n\nPara aceptar conexiones TCP entrantes en el puerto 443 para un servidor web (HTTPS):\n\n```\n# iptables -A TCP -p tcp --dport 443 -j ACCEPT\n```\n\nPara permitir conexiones remotas a través de SSH (en el puerto 22):\n\n```\n# iptables -A TCP -p tcp --dport 22 -j ACCEPT\n```\n\nPara aceptar transmisiones TCP/UDP entrantes en el puerto 53 para un servidor DNS:\n\n```\n# iptables -A TCP -p tcp --dport 53 -j ACCEPT\n# iptables -A UDP -p udp --dport 53 -j ACCEPT\n```\n\nVea iptables(8) para conocer reglas más avanzadas, como equipar múltiples puertos.\n\n"
    },
    {
      "title": "Golpear puertos",
      "level": 4,
      "content": "El golpeo de puertos es un método para abrir puertos externamente que, por defecto, el cortafuegos mantiene cerrado. Funciona al demandar intentos de conexión a una serie de puertos cerrados de forma predefinida. Cuando la secuencia correcta del puerto al que se «golpea» (intentos de conexión) es recibida, el cortafuegos abre determinado puerto(s) para permitir una conexión. Vea Port knocking (Español) para más información.\n\n"
    },
    {
      "title": "Protección contra ataques de suplantación",
      "level": 3,
      "content": "El bloqueo de las direcciones locales reservadas entrantes desde Internet o red local se realiza normalmente a través de la configuración de rp_filter (Reverse Path Filter) en sysctl ajustándola a 1. Para ello, añada la siguiente línea al archivo /etc/sysctl.d/90-firewall.conf (ver sysctl para más detalles) para permitir la verificación de la dirección IP de origen que está integrado en el mismo kernel de Linux. La verificación por parte del kernel se encargará de la suplantación de identidad o spoofing mejor que las reglas de iptables individuales para cada caso.\n\n```\nnet.ipv4.conf.all.rp_filter=1\n```\n\nEsto se puede hacer con netfilter en su lugar, si se desean estadíaticas (y mejorar el registro):\n\n```\n# iptables -t raw -I PREROUTING -m rpfilter --invert -j DROP\n```\n\nSolo cuando el enrutamiento es asíncrono, se debe utilizar la opción de sysctl rp_filter=0. Pasando el modificador --loose al módulo rpfilter se logrará lo mismo con netfilter.\n\n"
    },
    {
      "title": "«Ocultar» el ordenador",
      "level": 3,
      "content": "Si está ejecutando una máquina de escritorio, esto podría ser una buena idea para bloquear algunas peticiones entrantes.\n\n"
    },
    {
      "title": "Bloquear solicitudes de ping",
      "level": 4,
      "content": "Una petición 'Ping' es un paquete ICMP enviado a la dirección IP de destino para garantizar la conectividad entre los dispositivos. Si la red funciona bien, puede bloquear de forma segura todas las solicitudes de ping. Es importante señalar que esto en realidad «no» oculta su ordenador —cualquier paquete que se le envíe será rechazado, por lo que aún se mostrará en un nmap simple de «escaneo de ping» de un conjunto de IP—.\n\nEsta es una «protección» rudimentaria y hace más difícil la depuración de problemas en el futuro. Solo debe hacer esto para propósitos educativos.\n\nPara bloquear las peticiones de Echo, añada la siguiente línea a su archivo /etc/sysctl.d/90-firewall.conf (ver sysctl para más detalles):\n\n```\nnet.ipv4.icmp_echo_ignore_all = 1\n```\n\nPuede encontrar más información en la página del manual de iptables, o leyendo la documentación y ejemplos en la página web https://web.archive.org/web/20200217165135/http://snowman.net/projects/ipt_recent/\n\n"
    },
    {
      "title": "Engañar a los analizadores de puertos",
      "level": 4,
      "content": "- Esto le abre a una forma de DoS (siglas en inglés de Denial of Service —ataque de denegación de servicios—). Un ataque puede enviar paquetes con direcciones IP falsas, y hacer que los recursos o servicios sean bloqueados para conectarse a los mismos por los usuarios legítimos.\n- Este truco puede bloquear una dirección IP legítima si algunos paquetes de red provenientes de esta dirección al puerto de destino se consideran NO VÁLIDOS por el módulo «conntrack». Para evitar su inclusión en listas negras, un cambio de tendencia es permitir que todos los paquetes se dirijan a ese puerto de destino particular.\n\nLos escaneadores de puertos son utilizados por los atacantes para identificar los puertos abiertos en su equipo. Esto les permite identificar y analizar las huellas de sus servicios en ejecución y, posiblemente, lanzar exploits contra ellos.\n\nLa regla de estado INVALID se hará cargo de todos los tipos de escaneo de puertos, excepto para los escaneo de UDP, ACK y SYN (-sU, -sA y -sS en nmap, respectivamente).\n\nLos escaneos ACK no se utilizan para identificar los puertos abiertos, pero si para identificar los puertos filtrados por un cortafuegos. Debido a la comprobación de SYN para todas las conexiones TCP con el estado NEW, cada paquete individual enviado por una exploración ACK será rechazado correctamente por un paquete TCP RST. Algunos cortafuegos bloquean estos paquetes en su lugar, y esto permite que un atacante pueda trazar las reglas del cortafuegos.\n\nEl módulo recent puede ser utilizado para engañar a los otros dos tipos de escaneos de puertos restantes. El módulo recent puede agregar equipos a una lista «recent» que se puede utilizar para los analizadores de huellas y detener ciertos tipos de ataques. Las listas recent actuales se pueden ver en /proc/net/xt_recent/.\n\nEn un escaneo SYN, el analizador de puertos envía paquetes SYN a cada puerto. Los puertos cerrados devuelven un paquete TCP RST, o son bloqueados por un cortafuegos estricto. Los puertos abiertos devuelven un paquete SYN ACK independientemente de la presencia o no de un cortafuegos.\n\nEl módulo recent se puede utilizar para realizar un seguimiento de los equipos con intentos rechazados y devolverles un TCP RST para cualquier paquete SYN que envían a puertos abiertos como si el puerto estuviera cerrado. Si un puerto abierto es el primero en ser escaneado, será devuelto un paquete SYN ACK pese a ello, por lo que las aplicaciones en ejecución, requieren que funcionen en puertos no esperados para que esto sea coherente, como ssh que debe ejecutarse en puertos no estándar.\n\nEn primer lugar, insertar una regla en la parte superior de la cadena TCP. Esta regla responde con un RST TCP a cualquier equipo añadido a la lista TCP PortScan en los últimos sesenta segundos. El parámetro --update hace que la lista recent se actualice, lo que hace que el contador de 60 segundo se restablezca.\n\n```\n# iptables -I TCP -p tcp -m recent --update --rsource --seconds 60 --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset\n```\n\nA continuación, la regla para rechazar los paquetes TCP necesita ser modificada para incluir los equipos con paquetes rechazados en la lista TCP-PORTSCAN.\n\n```\n# iptables -D INPUT -p tcp -j REJECT --reject-with tcp-reset\n# iptables -A INPUT -p tcp -m recent --set --rsource --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset\n```\n\nLos escaneos de puertos UDP son similares a las exploraciones TCP SYN, excepto que UDP es un protocolo «sin conexión (previamente establecida)». No hay contacto ni reconocimiento. En cambio, el escáner envía paquetes UDP a cada puerto UDP. Los puertos cerrados devuelven mensajes ICMP de puertos inaccesibles, y los puertos abiertos no devuelven respuesta. Dado que UDP no es un protocolo «confiable», el escáner no tiene manera de saber si los paquetes se perdieron, y tiene que hacer varias comprobaciones para cada puerto que no devuelve una respuesta.\n\nEl kernel de Linux envía mensajes ICMP de puerto inaccesible muy lentamente, por lo que un escaneo UDP completo contra una máquina Linux podría durar más de 10 horas. Sin embargo, los puertos comunes todavía pudieron ser identificados, por lo que la aplicación de las mismas medidas contra escaneos de SYN para UDP es una buena idea.\n\nEn primer lugar, añada una regla para rechazar los paquetes de los equipos incluidos en la lista UDP-PortScan al inicio de la cadena de UDP.\n\n```\n# iptables -I UDP -p udp -m recent --update --rsource --seconds 60 --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable\n```\n\nA continuación, modifique la regla de rechazo de paquetes para UDP:\n\n```\n# iptables -D INPUT -p udp -j REJECT --reject-with icmp-port-unreachable\n# iptables -A INPUT -p udp -m recent --set --rsource --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable\n```\n\nSi se utilizaron uno o ambas de los reglas de escaneo de puertos descritos, estas se colocarán por encima de la última regla por defecto, con lo cual esta última ya no será la regla final en la cadena INPUT. La regla por defecto tiene que ser la última regla, de lo contrario interferirá en las reglas del escaneo de puertos que acaba de agregar y nunca se utilizarán. Solo tiene que eliminar la regla (D) y, a continuación, añadirla (-A) de nuevo, lo que hará que la regla por defecto se coloque al final de la cadena.\n\n```\n# iptables -D INPUT -j REJECT --reject-with icmp-proto-unreachable\n# iptables -A INPUT -j REJECT --reject-with icmp-proto-unreachable\n```\n\n"
    },
    {
      "title": "Protección contra otros ataques",
      "level": 3,
      "content": "Consulte sysctl#TCP/IP stack hardening para conocer los parámetros del kernel más relevantes.\n\n"
    },
    {
      "title": "Ataques de fuerza bruta",
      "level": 4,
      "content": "Desafortunadamente, los ataques de fuerza bruta sobre los servicios accesibles a través de una dirección IP expuesta públicamente son comunes. Una razón para esto es que los ataques son fáciles de hacer con las muchas herramientas disponibles. Afortunadamente, hay varias formas de proteger los servicios contra ellos. Una de ellas es el uso de reglas apropiadas iptables que activen e incluyan en una lista negra las direcciones IP después de que estas hayan intentado iniciar una conexión de forma infructuosa con un número determinado de paquetes. Otro es el uso de demonios especializados que controlen los archivos del registro de intentos fallidos y la lista negra en consecuencia.\n\nDos aplicaciones que prohíben direcciones IP después de demasiados fracasos con la contraseña son Fail2ban (Español) o, para sshd en particular, Sshguard (Español). Estas dos aplicaciones actualizan las reglas de iptables para rechazar futuras conexiones desde direcciones IP incluidas en la lista negra.\n\nLas siguientes reglas se dan como un ejemplo de configuración para mitigar los ataques de fuerza bruta contra SSH utilizando iptables.\n\n```\n# iptables -N IN_SSH\n# iptables -A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -j IN_SSH\n# iptables -A IN_SSH -m recent --name sshbf --rttl --rcheck --hitcount 3 --seconds 10 -j DROP\n# iptables -A IN_SSH -m recent --name sshbf --rttl --rcheck --hitcount 4 --seconds 1800 -j DROP \n# iptables -A IN_SSH -m recent --name sshbf --set -j ACCEPT\n```\n\nLa mayoría de las opciones pueden explicarse por sí mismas, así las reglas precedentes permiten tres paquetes de conexión cada diez segundos. El resto de intentos en ese lapso de tiempo incluyen la IP en la lista negra. La siguiente regla añade una peculiaridad, al permitir un total de cuatro intentos en 30 minutos. Esto se hace porque algunos ataques de fuerza bruta que se realizan son realmente lentos y no en un estallido de intentos. Las reglas emplean una serie de opciones adicionales. Para leer más acerca de ellas, revise la referencia original para este ejemplo: compilefailure.blogspot.com\n\nLas reglas anteriores se pueden usar para proteger cualquier servicio, aunque el demonio SSH es probablemente uno de los más solicitado.\n\nEn términos de orden, uno debe asegurarse de que -A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -j IN_SSH esté en la posición correcta en la secuencia de iptables: debe aparecer antes que el de La cadena TCP que está conectada a INPUT para detectar nuevas conexiones SSH primero. Si se han completado todos los pasos anteriores de esta wiki, funcionaría con el siguiente posicionamiento:\n\n```\n...\n-A INPUT -m conntrack --ctstate INVALID -j DROP\n-A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT\n-A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j IN_SSH\n-A INPUT -p udp -m conntrack --ctstate NEW -j UDP\n-A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP\n...\n```\n\n"
    },
    {
      "title": "IPv6",
      "level": 3,
      "content": "Si no utiliza IPv6, considere desactivarlo, de lo contrario, siga estos pasos para activar las reglas de IPv6 para el cortafuegos.\n\nCopie las reglas IPv4 utilizadas en este ejemplo como base, y cambie cualquier IP del formato IPv4 al formato IPv6:\n\n```\n# cp /etc/iptables/iptables.rules /etc/iptables/ip6tables.rules\n```\n\nA few of the rules in this example have to be adapted for use with IPv6. The ICMP protocol has been updated in IPv6, replacing the ICMP protocol for use with IPv4. Hence, the reject error return codes --reject-with icmp-port-unreachable and --reject-with icmp-proto-unreachable have to be converted to ICMPv6 codes.\n\nAlgunas de las reglas de este ejemplo deben adaptarse para su uso con IPv6. El protocolo ICMP se ha actualizado en IPv6, reemplazando el protocolo ICMP para su uso con IPv4. Por lo tanto, los códigos de retorno de error de rechazo --reject-with icmp-port-unreachable y {{ic | --reject-with icmp-proto-unreachable}. Por lo tanto, los códigos de retorno de error de rechazo --reject-with icmp-port-unreachable y --reject-with icmp-proto-unreachable tienen que ser convertidos en códigos ICMPv6.\n\nLos códigos de error de ICMPv6 disponibles se enumeran en RFC 4443, que especifica que una regla de cortafuegos para bloquear los intentos de conexión debe utilizar --reject-with icmp6-adm-prohibited. Si lo bloquea, básicamente informa al sistema remoto que la conexión fue rechazada por el cortafuegos, en lugar de informar que un servicio fue escuchado.\n\nSi se prefiere no informar explícitamente acerca de la existencia de un filtro en el cortafuegos, el paquete también puede ser rechazado sin el mensaje:\n\n```\n-A INPUT -j REJECT\n```\n\nLo anterior va a rechazar con la devolución de error por defecto --reject-with-icmp6-port-unreachable. Debe tener en cuenta, sin embargo, que la identificación de un cortafuegos es una característica básica de las aplicaciones de escaneo de puertos y la mayoría va a identificarlo a pesar de todo.\n\nEl siguiente paso es asegurarse de que el protocolo y la extensión se cambian al apropiado para IPv6 en la regla de todas las nuevas peticiones de echo ICMP entrantes (pings):\n\n```\n# ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 128 -m conntrack --ctstate NEW -j ACCEPT\n```\n\nconntrack de netfilter no parece hacer el seguimiento del Protocolo Neighbor Discovery de ICMPv6 (el IPv6 equivalente de ARP), así que tenemos que permitir el tráfico ICMPv6 sin importar el estado para todas las subredes conectadas directamente. Lo siguiente debe insertarse después de descartar --ctstate INVALID, pero antes de cualquier otro objetivo DROP o REJECT, junto con la línea correspondiente de cada subred conectada directamente:\n\n```\n# ip6tables -A INPUT -s fe80::/10 -p ipv6-icmp -j ACCEPT\n```\n\nComo no existe un filtro de ruta inversa del kernel para IPv6, es posible que desee habilitar uno en ip6tables con lo siguiente:\n\n```\n# ip6tables -t raw -A PREROUTING -m rpfilter -j ACCEPT\n# ip6tables -t raw -A PREROUTING -j DROP\n```\n\n"
    },
    {
      "title": "Guardar las reglas",
      "level": 3,
      "content": "El conjunto de reglas ya está terminado y se debe guardar en el disco duro para que pueda ser cargado en cada arranque.\n\nGuarde las reglas de IPv4 y IPv6 con estas órdenes\n\n```\n# iptables-save > /etc/iptables/iptables.rules\n# ip6tables-save > /etc/iptables/ip6tables.rules\n```\n\nDespués active e inicie iptables.service y ip6tables.service. Compruebe el estado de los servicios para asegurarse de que las reglas estén cargadas correctamente.\n\n"
    },
    {
      "title": "Configurar una puerta de enlace NAT",
      "level": 2,
      "content": "Esta sección de la guía trata sobre la configuración de una puerta de enlace NAT (siglas en inglés de Network Address Translation —conversión de direcciones de red—). Se supone que ya ha leído la primera parte de la guía y configurado las cadenas INPUT, OUTPUT, TCP y UDP como se ha descrito anteriormente. Todas las reglas hasta ahora se han creado en la tabla filter. En esta sección, también vamos a tener que utilizar la tabla nat.\n\n"
    },
    {
      "title": "Crear las cadenas necesarias",
      "level": 4,
      "content": "En nuestra configuración, utilizaremos otras dos cadenas en la tabla de filtros, las cadenas fw-interfaces y fw-open que crearemos con las siguientes órdenes:\n\n```\n# iptables -N fw-interfaces\n# iptables -N fw-open\n```\n\n"
    },
    {
      "title": "Configurar la cadena FORWARD",
      "level": 4,
      "content": "La creación de la cadena FORWARD es similar a la cadena INPUT de la primera parte de esta guía.\n\nAhora establecemos una regla con conntrack, idéntica a la de la cadena INPUT:\n\n```\n# iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n```\n\nEl siguiente paso es activar el reenvío para las interfaces de confianza y hacer que todos los paquetes pasen por la cadena fw-open.\n\n```\n# iptables -A FORWARD -j fw-interfaces \n# iptables -A FORWARD -j fw-open\n```\n\nA los paquetes restantes se les niega con un mensaje ICMP:\n\n```\n# iptables -A FORWARD -j REJECT --reject-with icmp-host-unreach\n# iptables -P FORWARD DROP\n```\n\n"
    },
    {
      "title": "Configurar las cadenas fw-interfaces y fw-open",
      "level": 4,
      "content": "El significado de las cadenas fw-interfaces y fw-open se explica más adelante, cuando nos ocupemos de las cadenas POSTROUTING y PREROUTING en la tabla nat, respectivamente.\n\n"
    },
    {
      "title": "Configurar la tabla nat",
      "level": 3,
      "content": "En toda esta sección, se supone que la interfaz de salida (la que tiene la IP expuesta públicamente a internet) es ppp0. Tenga en cuenta que tiene que cambiar el nombre en todas las reglas siguientes si su interfaz de salida tiene otro nombre.\n\n"
    },
    {
      "title": "Configurar la cadena POSTROUTING",
      "level": 4,
      "content": "Ahora, tenemos que definir quién tiene permisos para conectarse a Internet. Supongamos que tenemos la subred 192.168.0.0/24 (que significa que todas las direcciones tienen el formato 192.168.0.*) en eth0. Primero tenemos que aceptar las máquinas en esta interfaz en la tabla FORWARD, es por eso que hemos creado la cadena fw-interfaces anterior:\n\n```\n# iptables -A fw-interfaces -i eth0 -j ACCEPT\n```\n\nAhora, tenemos que modificar todos los paquetes salientes de manera que tengan nuestra dirección IP pública como la dirección IP de origen, en lugar de la dirección LAN local. Para ello, utilizamos el objetivo MASQUERADE:\n\n```\n# iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o ppp0 -j MASQUERADE\n```\n\nNo se olvide el parámetro -o ppp0 anterior. Si lo omite, su red no funcionará.\n\nSupongamos que tenemos otra subred, 10.3.0.0/16 (que comprende todas las direcciones 10.3.*.*), en la interfaz eth1. Añadimos las mismas reglas que antes, además de:\n\n```\n# iptables -A fw-interfaces -i eth1 -j ACCEPT\n# iptables -t nat -A POSTROUTING -s 10.3.0.0/16 -o ppp0 -j MASQUERADE\n```\n\nEl último paso es activar activar el reenvío de paquetes de red (si no está ya activado):\n\nLas máquinas de estas subredes pueden ahora utilizar su nueva máquina NAT como su puerta de enlace. Tenga en cuenta que es posible que desee configurar un servidor DNS y DHCP como dnsmasq o una combinación de BIND y dhcpd para simplificar la configuración de red en la resolución de DNS en los equipos clientes. Este no es el tema de esta guía.\n\n"
    },
    {
      "title": "Configurar la cadena PREROUTING",
      "level": 4,
      "content": "A veces, queremos cambiar la dirección de un paquete entrante de la puerta de entrada a una máquina de la LAN. Para ello, utilizamos la cadena fw-open definida antes, así como la cadena PREROUTING de la tabla nat.\n\nDaremos dos ejemplos sencillos: en primer lugar, queremos cambiar todos los paquetes entrantes SSH (puerto 22) al servidor ssh en la máquina 192.168.0.5:\n\n```\n# iptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 22 -j DNAT --to 192.168.0.5\n# iptables -A fw-open -d 192.168.0.5 -p tcp --dport 22 -j ACCEPT\n```\n\nEl segundo ejemplo le mostrará cómo cambiar los paquetes a un puerto diferente del puerto de entrada. Queremos cambiar cualquier conexión entrante en el puerto 8000 en nuestro servidor web 192.168.0.6, al puerto 80:\n\n```\n# iptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 8000 -j DNAT --to 192.168.0.6:80\n# iptables -A fw-open -d 192.168.0.6 -p tcp --dport 80 -j ACCEPT\n```\n\nLa misma configuración también funciona con los paquetes UDP.\n\n"
    },
    {
      "title": "Guardar las reglas",
      "level": 3,
      "content": "Guarde las reglas con:\n\n```\n# iptables-save > /etc/iptables/iptables.rules\n```\n\nEsto supone que ha seguido los pasos anteriores para activar el servicio de systemd iptables.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- Methods to block SSH attacks\n- Using iptables to block brute force attacks\n- 20 Iptables Examples For New SysAdmins\n- 25 Most Frequently Used Linux IPTables Rules Examples\n\n"
    }
  ]
}