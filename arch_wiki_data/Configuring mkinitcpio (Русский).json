{
  "title": "Configuring mkinitcpio (Русский)",
  "url": "https://wiki.archlinux.org/title/Configuring_mkinitcpio_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Booster\n- Отладка загрузки\n- dracut\n- Модули ядра\n- mkinitcpio/Minimal initramfs\n- systemd (Русский)\n\nmkinitcpio — это bash-скрипт, используемый для создания начального загрузочного диска системы. Из mkinitcpio(8) man page:\n\nТрадиционно ядро отвечает за обнаружение всего оборудования и выполняет задачи на ранних этапах процесса загрузки до монтирования корневой файловой системы. Однако по мере развития технологий эти задачи становятся всё более сложными.\n\nВ настоящее время корневая файловая система может быть на широком диапазоне аппаратных средств от SCSI до SATA и USB дисков, управляемых различными контроллерами от разных производителей. Кроме того корневая файловая система может быть зашифрована или сжата, находиться в RAID массиве или группе логических томов. Простой способ справиться с этой сложностью является передача управления в пользовательском пространстве: начальный загрузочный диск. Смотрите также: /dev/brain0 » Blog Archive » Early Userspace in Arch Linux.\n\nmkinitcpio создан разработчиками Arch Linux и вкладами сообщества. Смотрите public Git repository.\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Установите пакет mkinitcpio, который является зависимостью пакета linux, поэтому большинство пользователей уже установили его.\n\nПродвинутые пользователи могут захотеть установить последнюю версию mkinitcpio из Git с пакетом mkinitcpio-gitAUR.\n\nNote: **Настоятельно** \n\n"
    },
    {
      "title": "Автоматическая генерация",
      "level": 3,
      "content": "Каждый раз, когда ядро устанавливается или обновляется, pacman-хук генерирует файл предустановки (.preset) и сохраняет его в /etc/mkinitcpio.d/. Например, для официального пакета linux создаётся файл linux.preset. Предустановка — это просто список информации, необходимой для создания начальных образов RAM-диска, вместо того, чтобы вручную указывать различные параметры и расположение выходных файлов. По умолчанию mkinitcpio генерирует два образа после установки или обновления ядра:\n\n1. default, создаваемый в соответствии с директивами, указанными в настройках, и\n1. fallback, который создается с точно таким же конфигурационным файлом за исключением хука autodetect, что позволяет включить в него все модули.\n\n"
    },
    {
      "title": "Ручная генерация",
      "level": 3,
      "content": "Чтобы запустить скрипт вручную, обратитесь к mkinitcpio(8) для чтения инструкций. В частности, чтобы (повторно) сгенерировать предустановку, предоставленную пакетом ядра, используйте параметр -p/--preset с именем нужной предустановки. Для стандартного ядра Arch Linux, linux:\n\n```\n# mkinitcpio -p linux\n```\n\nЧтобы (повторно) сгенерировать все существующие предустановки, используйте параметр -P/--allpresets. Обычно это используется для регенерации всех образов initramfs после изменения глобальных настроек:\n\n```\n# mkinitcpio -P\n```\n\nПараметр -p (сокращение от preset) указывает на использование preset файла из /etc/mkinitcpio.d (т.е. /etc/mkinitcpio.d/linux.preset для linux). preset файл определяет параметры сборки initramfs образа вместо указания файла конфигурации и выходной файл каждый раз.\n\nМожно создать любое количество initramfs с различными конфигурациями. Необходимый initramfs должен быть прописан в конфигурационном файле загрузчика.\n\n"
    },
    {
      "title": "Варианты создания initcpio",
      "level": 3,
      "content": "Пользователи могут вручную создать образ с помощью альтернативного конфигурационного файла. Например, следующее будет генерировать initramfs образ в соответствии с /etc/mkinitcpio-custom.conf и сохранит его в /boot/linux-custom.img.\n\n```\n# mkinitcpio --config /etc/mkinitcpio-custom.conf --generate /boot/initramfs-custom.img\n```\n\nЕсли необходимо создать образ с ядром отличным от загруженного, добавьте параметр с версией ядра. Доступные версии ядер можно посмотреть в /usr/lib/modules, синтаксис соответствует выводу uname -r для каждого ядра.\n\n```\n# mkinitcpio --generate /boot/initramfs-custom2.img --kernel 5.7.12-arch1-1\n```\n\n"
    },
    {
      "title": "Unified kernel images",
      "level": 3,
      "content": "С версии 31 mkinitcpio также может генерировать unified kernel image.\n\n"
    },
    {
      "title": "Настройка",
      "level": 2,
      "content": "/etc/mkinitcpio.conf - основной конфигурационный файл mkinitcpio. Кроме того, в каталоге /etc/mkinitcpio.d располагаются preset файлы (e.g. /etc/mkinitcpio.d/linux.preset).\n\nМожно изменять шесть переменных в конфигурационном файле:\n\nNote: **lvm2** \n\n- Некоторые хуки, которые могут быть нужны для вашей системы, вроде lvm2, mdadm, и encrypt, НЕ включены по умолчанию. Смотрите раздел #HOOKS, чтобы узнать, как их включить и настроить.\n- Если у вас более одного контроллера дисков, использующих одно пространство имён устройств (например, 2 SCSI/SATA или IDE контроллера), и они требуют разных модулей, используйте постоянные имена для блочных устройств, чтобы быть уверенным, что вы смонтировали действительно то, что хотели. Без этого устройства могут поменяться местами и вы получите kernel panic при загрузке.\n\n"
    },
    {
      "title": "MODULES",
      "level": 3,
      "content": "Указывает какие модули ядра должны быть загружены прежде чем что-либо будет сделано.\n\nДля модулей с суффиксом ? не будет выводиться ошибка, если они не будут найдены. Это может быть полезно для пользовательских ядер.\n\nNote: **reiser4** \n\n- При использовании reiser4 обязательно добавьте его в массив MODULES.\n- При использовании хука encrypt или sd-encrypt модули клавиатуры и/или файловых систем, необходимые для разблокировки устройства LUKS во время загрузки системы, нужно добавить в массив MODULES, когда целевая система отличается от той, которая использовалась для запуска mkinitcpio. Например, если вы используете keyfile в файловой системе ext2, но во время запуска mkinitcpio файловая система ext2 не смонтирована, добавьте ext2. Подробнее смотрите dm-crypt/System configuration#cryptkey.\n- Если клавиатура подключена через USB3-хаб и вы хотите использовать её для разблокировки LUKS устройства, добавьте usbhid xhci_hcd.\n- При использовании дисплеев, подключенных к док-станции, вам может потребоваться добавить модуль для вашей видеокарты, чтобы сделать вывод initrd видимым (например i915 для большинства карт Intel).\n\n"
    },
    {
      "title": "BINARIES и FILES",
      "level": 3,
      "content": "Указывают какие файлы необходимо добавить в initramfs. BINARIES и FILES будут добавлены до запуска хуков и использоваться для переопределения файлов использаемых хуками. BINARIES - бинарные файлы из PATH, необходимые для работы библиотеки будут автоматически добавлены. FILES добавляет файлы как есть. Например:\n\n```\nFILES=(/etc/modprobe.d/modprobe.conf)\n```\n\n```\nBINARIES=(kexec)\n```\n\nИ BINARIES, и FILES являются bash-массивами, в них можно добавить несколько файлов с пробелом в качестве разделителя.\n\n"
    },
    {
      "title": "HOOKS",
      "level": 3,
      "content": "Параметр HOOKS наиболее важный в файле настроек. Хуки - это небольшие скрипты, которые описывают что будет добавлено к образу, а также дополнительные действия, выполняемые при загрузке системы. Хуки указываются по имени и выполняются по порядку.\n\nЗначение по умолчанию для HOOKS должно быть достаточным для большинства простых установок с одним диском. Для корневых устройств, которые являются многоуровневыми или многоблочными устройствами, такими как LVM, mdadm или dm-crypt, см. cоответствующие страницы вики для дальнейшей необходимой конфигурации.\n\n"
    },
    {
      "title": "Build hooks",
      "level": 4,
      "content": "Build hooks - хуки сборки. Располагаются в /usr/lib/initcpio/install/; пользовательские хуки можно добавить в /etc/initcpio/install/. Эти файлы используются mkinitcpio во время сборки initramfs. Должны содержать две функции: build и help. Функция build перечисляет модули, файлы, исполняемые файлы, которые добавляются в образ. Функция help содержит описание действий хука.\n\nДля получения списка всех доступных хуков:\n\n```\n$ mkinitcpio -L\n```\n\nИспользуйте опцию -H/--hookhelp для вывода информации о конкретном хуке:\n\n```\n$ mkinitcpio -H udev\n```\n\n"
    },
    {
      "title": "Runtime hooks",
      "level": 4,
      "content": "Runtime hooks - хуки времени выполнения. Располагаются в /usr/lib/initcpio/hooks/, пользовательские хуки могут быть помещены в /etc/initcpio/hooks/. Для любого runtime-хука всегда должен быть build-хук с тем же именем, в котором имеется вызов add_runscript, указывающий на добавление runtime-хука в образ. Эти файлы обрабатываются командным интерпретатором ash из busybox во время early userspace. Они запускаются по порядку записи в HOOKS за исключением хуков очистки. Runtime хуки могут содержать несколько функций:\n\nrun_earlyhook: Функции с таким именем будут запускаться один раз после установки API файловых систем и обработки командной строки ядра. Как правило, здесь запускаются дополнительные демоны, такие как udev, необходимые для раннего процесса загрузки.\n\nrun_hook: Функции с таким именем запускаются вскоре после ранних хуков. Это наиболее распространенная точка хуков, и здесь должны выполняться операции, такие как сборка многоуровневых блочных устройств.\n\nrun_latehook: Функции c этим именем запускаются после того, как была примонтирована корневая файловая система. Это следует использовать, умеренно, для дальнейшей настройки корневой ФС или для монтирования других файловых систем, таких как /usr.\n\nrun_cleanuphook: Функции с этим именем запускаются как можно позже, и в порядке обратном, порядку их перечисления в HOOKS файла конфигурации. Эти хуки должны использоваться для любой очистки в последнюю минуту, например, для закрытия всех демонов, запущенных ранними хуками.\n\nNote: **systemd** \n\n"
    },
    {
      "title": "Доступные хуки",
      "level": 4,
      "content": "Таблица стандартных хуков и как они влияют на создание и выполнение образа. Обратите внимание, что эта таблица не является полной, так как пакеты могут предоставлять свои хуки.\n\nTable content:\nbusybox init | systemd init | Build hook | Runtime hook\nbase | Устанавливает все начальные каталоги, базовые утилиты и библиотеки. Всегда ставьте этот хук первым, за исключением случаев, когда вы действительно знаете, что делаете, если не используется хук systemd. Предоставляет busybox recovery shell при использовании совместно с хуком systemd. Примечание: Командная оболочка восстановления недоступна, так как аккаунт root в initramfs заблокирован. Смотрите FS#70408. | –\nudev | systemd | Добавляет udev, udevadm и небольшое подмножество правил udev в образ. | Udev автоматически создает файл устройства для корня и загружает необходимые модули для его работы. Рекомендуется использовать.\nusr | Добавляет поддержку отделного /usr раздела. Подробнее: #/usr на отдельном разделе | Монтирует раздел /usr после монтирования корневой файловой системы.\nresume | – | Необходим для работы спящего режима (suspend to disk). Смотрите Ждущий и спящий режимы.\nbtrfs | -- | Sets the required modules to enable Btrfs for using multiple devices with Btrfs. This hook is not required for using Btrfs on a single device. | Runs btrfs device scan to assemble a multi-device Btrfs root file system when udev hook or systemd hook is not present. The btrfs-progs package is required for this hook.\nautodetect | Уменьшает размер initramfs, пытаясь определить, какие модули вам нужны, сканируя sysfs. Проверьте список модулей, которые он добавил. Он должен запускаться раньше других подсистем. Все обработчики, выполняемые до него, будут включать все модули. | –\nmodconf | Добавляет конфигурационные файлы modprobe из /etc/modprobe.d/ и /usr/lib/modprobe.d/ | –\nblock | Добавляет все модули блочных устройств, ранее предоставляемые другими хуками (fw, mmc, pata, sata, scsi, usb, virtio). | –\nnet | не реализован | Добавляет поддержку сети. Установите mkinitcpio-nfs-utils для использования этого хука. Подробнее: #При использовании net | Требуется для корневой файловой системы через NFS.\ndmraid | ? | Поддержка корневой файловой системы на fakeRAID массивах. Необходимо установить пакет dmraid. Обратите внимание, что необходимо использовать mdadm с хуком mdadm_udev с fakeRAID если ваш контроллер поддерживает это. Подробнее: #При использовании RAID | Находит и монтирует fakeRAID блочные устройства, используя dmraid.\nmdadm_udev | Обеспечивает поддержку для сборки RAID массивов с помощью udev. Необходимо установить пакет mdadm. Если вы используете этот хук с массивом FakeRAID, рекомендуется включить mdmon в секции BINARIES. Подробнее: #При использовании RAID | –\nkeyboard | Добавляет модули, необходимые для работы клавиатур. Используйте этот хук, если необходимо использовать USB-клавиатуру на ранней стадии загрузки (для ввода пароля от заширфованных данных или для работы в командной оболочке). В качестве побочного эффекта также могут быть добавлены модули для некоторых устройств ввода без клавиатуры, но на это не следует полагаться. Заменяет старый хук usbinput. Примечание: Для систем, которые загружаются с различными конфигурациями оборудования (например, ноутбуки с внешней клавиатурой или внутренней клавиатурой или headless-системы), этот хук необходимо поместить перед autodetect, чтобы иметь возможность использовать клавиатуру во время загрузки, например, чтобы разблокировать зашифрованное устройство при использовании хука encrypt. | –\nkeymap | sd-vconsole | Добавляет в initramfs раскладки, указанные в /etc/vconsole.conf. При использовании шифрования системы добавляйте его перед хуком encrypt. | Загружает раскладки, указанные в /etc/vconsole.conf.\nconsolefont | Добавляет в initramfs консольный шрифт, указанный в /etc/vconsole.conf. | Загружает шрифт, указанный в /etc/vconsole.conf.\nencrypt | sd-encrypt | Добавлет модуль ядра dm_crypt и cryptsetup. Требуется пакет cryptsetup. Примечание: Обратите внимание на замечания для хука keyboard выше для разблокировки зашифрованного устройства во время загрузки, а также примечания о файловых системах в #MODULES, если вы используете файл для разблокировки. | Определяет и подключает зашифрованый корневой раздел. Смотрите #Настройка во время выполнения для дальнейшей настройки. Для sd-encrypt смотрите dm-crypt/System configuration#Using systemd-cryptsetup-generator.\nlvm2 | Добавляет поддержку lvm. Требует установленного пакета lvm2. Необходим, если корневая файловая система на LVM. | –\nfsck | Добавляет исполняемый файл fsck и необходимые обработчики файловых систем для проверки корневой файловой системы (и /usr, если он на отдельном разделе) перед монтированием. Если стоит после хука autodetect, то будут добавлены только обработчики для вашей корневой файловой системы. Использование этого хука настоятельно рекомендуется и обязательно с отдельным /usr разделом. При включении этого хука крайне рекомендуется также включить все необходимые модули для обеспечения работы вашей клавиатуры в early userspace. Использование этого хука требует, чтобы rw передавался в командной строке ядра (обсуждение). Смотрите fsck (Русский)#Проверка при загрузке для подробностей. | –\nfilesystems | Включает в образ модули необходимых файловых систем. Этот хук обязателен, если Вы не указываете модули файловых систем в MODULES. | –\n\nПредоставляет busybox recovery shell при использовании совместно с хуком systemd.\n\nNote: **autodetect** \n\nДля sd-encrypt смотрите dm-crypt/System configuration#Using systemd-cryptsetup-generator.\n\n"
    },
    {
      "title": "COMPRESSION",
      "level": 3,
      "content": "Ядро поддерживает несколько форматов для сжатия initramfs - gzip, bzip2, lzma, xz, lzo, lz4 и zstd. По умолчанию mkinitcpio использует zstd; имейте в виду, что сжатие zstd работает в многопоточном режиме (с опцией -T0, которая запускает столько же потоков, сколько ядер в процессоре).\n\nСтандартный mkinitcpio.conf имеет различные закомментированные варианты COMPRESSION. Раскомментируйте один, чтобы выбрать необходимый формат сжатия. Чтобы создать несжатый образ, укажите COMPRESSION=cat в конфигурации или используйте -z cat в командной строке.\n\nУбедитесь, что для метода, который вы хотите использовать, установлена ​​правильная утилита сжатия файлов.\n\n"
    },
    {
      "title": "COMPRESSION_OPTIONS",
      "level": 3,
      "content": "Это дополнительные флаги, переданные программе, указанной COMPRESSION, например:\n\n```\nCOMPRESSION_OPTIONS=(-9)\n```\n\nNote: **незагружаемой системе** \n\n"
    },
    {
      "title": "Настройка во время выполнения",
      "level": 2,
      "content": "Настройки среды выполнения могут быть переданы в init и некоторые хуки через параметры ядра, которые обычно задаются в загрузчике. Приведённые ниже параметры могут быть добавлены в командную строку ядра для изменения поведения по умолчанию. Подробности смотрите в статьях Параметры ядра и Процесс загрузки Arch.\n\n"
    },
    {
      "title": "init from base hook",
      "level": 3,
      "content": "```\nroot=/dev/sda1                                                # /dev node\nroot=LABEL=CorsairF80                                         # метка\nroot=UUID=ea1c4959-406c-45d0-a144-912f4e86b207                # UUID\nroot=PARTUUID=14420948-2cea-4de7-b042-40f67c618660            # GPT UUID раздела\n```\n\n```\ndisablehooks=resume\n```\n\nСмотрите Устранение часто встречающихся неполадок#Проблемы загрузки и mkinitcpio(8) для более подробной информации.\n\n"
    },
    {
      "title": "При использовании RAID",
      "level": 3,
      "content": "Смотрите RAID#Configure mkinitcpio.\n\n"
    },
    {
      "title": "При использовании net",
      "level": 3,
      "content": "Требуемые пакеты\n\nХук net требует пакет mkinitcpio-nfs-utils.\n\nПараметры ядра\n\nПолную и актуальную информацию можно найти в официальной документации ядра.\n\nip=\n\nЭтот параметр сообщает ядру, как настраивать IP-адреса устройств и таблицу маршрутизации. Может принимать до девяти аргументов, разделённых двоеточиями:\n\nip=<client-ip>:<server-ip>:<gw-ip>:<netmask>:<hostname>:<device>:<autoconf>:<dns0-ip>:<dns1-ip>:<ntp0-ip>.\n\nЕсли этот параметр не указан, все поля считаются пустыми и используются значения по умолчанию, описанные в документации ядра. В целом это подразумевает, что ядро пытается настроить всё с помощью автоконфигурации.\n\nМожно указать <autoconf> в одиночку как значение параметра ip (без всех двоеточий перед ним). Значение ip=off или ip=none отключает автоконфигурацию. Чаще всего используется ip=dhcp.\n\nРазъяснение параметров:\n\n```\n<client-ip>   IP адрес клиента. Если пустой, то автоматически назначается\n               протоколом RARP/BOOTP/DHCP. Какой протокол используется\n               зависит от параметра <autoconf>. Если его значение не пустое,\n               то autocnf работает корректно.\n \n <server-ip>   IP адрес NFS сервера. Если используется RARP для определения\n               адреса клиента и этот параметр не пуст, то принимаются ответы\n               только от указанного сервера.\n               Для использования разных RARP и NFS серверов,\n               укажите ваш RARP сервер здесь (или оставьте пустым), и\n               укажите ваш NFS сервер в параметре `nfsroot'\n               (см. выше). Если тут пусто, будет использован сервер, ответивший\n               на RARP/BOOTP/DHCP запрос.\n \n <gw-ip>       IP адрес шлюза если сервер в другой подсети. Если тут пусто,\n               предполагается, что сервер находится в одной подсети, если значение\n               не получено по BOOTP/DHCP.\n \n <netmask>     Маска подсети для локального интерфейса. Если тут пусто,\n               используется маска по умолчанию в зависимости от класса IP,\n               если конечно не переопределена значением из BOOTP/DHCP ответа.\n \n <hostname>    Имя машины клиента. Если пусто, используется IP адрес в виде ASCII\n               строки, или значение полученное по BOOTP/DHCP.\n \n <device>      Имя сетевого устройства. Если тут пусто, все устройства будут использованы\n               для RARP/BOOTP/DHCP запросов, и все настройки будут получены из первого\n               пришедшего ответа. Если вы имеете только одно сетевое устройство, можно спокойно\n               оставить поле пустым.\n \n <autoconf>\tКакой метод использовать для автонастройки: 'rarp', 'bootp', или 'dhcp'.\n               Если значение 'both', 'all' или пусто, все протоколы будут использованы.\n               'off', 'static' или 'none' означают запрет автонастройки.\n \n <dns0-ip>     IP-адрес основного DNS-сервера. Определяется автоматически при включенном autoconf.\n               Значение доступно в /proc/net/pnp с префиксом \"nameserver \".\n \n <dns1-ip>     IP-адрес запасного DNS-сервера, аналогично <dns0-ip>.\n \n <ntp0-ip>     IP-адрес NTP-сервера. Определяется автоматически при включенном autoconf.\n               Значение доступно в /proc/net/ipconfig/ntp_servers, ядром не используется.\n```\n\nПолное объяснение параметров можно почитать в документации ядра (на английском).\n\nПримеры:\n\n```\nip=127.0.0.1:::::lo:none  --> Разрешить lo интерфейс.\n ip=192.168.1.1:::::eth2:none --> Статический eth2 интерфейс.\n ip=:::::eth0:dhcp --> Разрешить dhcp протокол для настройки интерфейса eth0.\n```\n\nBOOTIF=\n\nЕсли у вас несколько сетевых карт, в этом параметре можно указать MAC-адрес интерфейса, с которого вы загружаетесь. Это часто бывает полезно, так как нумерация интерфейсов может измениться, или в сочетании с опцией pxelinux IPAPPEND 2 или IPAPPEND 3. Если не указан, будет использоваться eth0.\n\nПример\n\n```\nBOOTIF=01-A1-B2-C3-D4-E5-F6  # Обратите внимание на ведущий \"01-\" и верхний регистр.\n```\n\nnfsroot=\n\nЕсли параметр 'nfsroot' НЕ передан, будет использовано значение по умолчанию \"/tftpboot/%s\".\n\n```\nnfsroot=[<server-ip>:]<root-dir>[,<nfs-options>]\n```\n\nОписание параметров:\n\n```\n<server-ip>   IP адрес NFS сервера. Если параметр отсутствует\n               адрес по умолчанию определяется по переменной\n               `ip' (см. ниже). Одно из применений этого параметра -\n               использование разных серверов для \n               RARP и NFS. Обычно можете оставить этот параметр пустым.\n \n <root-dir>    Путь к директории, которая будет корневой на клиенте. Если тут\n               написано \"%s\", то оно будет заменено на ASCII представление IP\n               клиента.\n \n <nfs-options> Стандартные опции NFS. Все опции разделены запятыми.\n               Если опция отсутствует будут использованы следующие значения по умолчанию:\n                       port            = как скажет portmap демон на сервере\n                       rsize           = 1024\n                       wsize           = 1024\n                       timeo           = 7\n                       retrans         = 3\n                       acregmin        = 3\n                       acregmax        = 60\n                       acdirmin        = 30\n                       acdirmax        = 60\n                       flags           = hard, nointr, noposix, cto, ac\n```\n\nПолное описание параметров можно почитать в mkinitcpio -H net (на английском).\n\n"
    },
    {
      "title": "При использовании lvm",
      "level": 3,
      "content": "Если ваш корень находится на LVM, смотрите Install Arch Linux on LVM#Adding mkinitcpio hooks.\n\n"
    },
    {
      "title": "При зашифрованном корневом разделе",
      "level": 3,
      "content": "Если у вас зашифрованный корень, смотрите dm-crypt/System configuration#mkinitcpio для информации о том, какие хуки нужно добавлять.\n\n"
    },
    {
      "title": "/usr на отдельном разделе",
      "level": 3,
      "content": "Если у вас /usr на отдельном разделе, вы должны соблюдать следующие требования:\n\n- Добавьте хук fsck, а в файле /etc/fstab укажите для passno значение 2, чтобы запускалась проверка этого раздела при загрузке системы. Без этого хука /usr проверяться не будет.\n- Если не используется хук systemd, добавьте хук usr, который будет монтировать раздел /usr после монтирования корневой ФС.\n\n"
    },
    {
      "title": "Распаковка образа",
      "level": 3,
      "content": "Если вам интересно посмотреть, что находится внутри образа initramfs, вы можете распаковать его.\n\nОбраз initramfs является архивом SVR4 CPIO, созданным с помощью команд find и bsdcpio и опционально сжатым с форматом сжатия, понятным ядру. Подробнее о сжатии смотрите в разделе #COMPRESSION.\n\nmkinitcpio включает в себя инструмент lsinitcpio(1), позволяющий посмотреть и/или извлечь содержимое образов initramfs.\n\nПросмотр списка файлов в образе:\n\n```\n# lsinitcpio /boot/initramfs-linux.img\n```\n\nИзвлечение всех файлов в текущий каталог:\n\n```\n# lsinitcpio -x /boot/initramfs-linux.img\n```\n\nБолее удобный обзор самых важных частей образа:\n\n```\n# lsinitcpio -a /boot/initramfs-linux.img\n```\n\n"
    },
    {
      "title": "Изменение и упаковка образа",
      "level": 3,
      "content": "После распаковки архива описанным выше способом вы можете изменить файлы и упаковать всё обратно. Вызовите функцию build_image из скрипта /usr/bin/mkinitcpio с параметрами\n\n```\nbuild_image выходной-файл сжатие\n```\n\nЭто можно сделать путём создания нового скрипта с содержимым функции build_image и его вызова с описанными выше параметрами. Он упакует содержимое текущего каталога в выходной-файл.\n\n"
    },
    {
      "title": "\"/dev must be mounted\", хотя он и так примонтирован",
      "level": 3,
      "content": "mkinitcpio считает /dev примонтированным при наличии /dev/fd/. Если всё выглядит хорошо, его можно «создать» вручную:\n\n```\n# ln -s /proc/self/fd /dev/\n```\n\n(Очевидно, /proc тоже должен быть примонтирован. mkinitcpio всё равно это требует и тоже это проверяет.)\n\n"
    },
    {
      "title": "Possibly missing firmware for module XXXX",
      "level": 3,
      "content": "В процессе сборки initramfs после обновления ядра вы можете заметить подобные предупреждения:\n\n```\n==> WARNING: Possibly missing firmware for module: wd719x\n==> WARNING: Possibly missing firmware for module: aic94xx\n==> WARNING: Possibly missing firmware for module: xhci_pci\n```\n\nОни появляются у большинства пользователей Arch Linux, так как соответствующие прошивки не поставляются пакетом linux-firmware. Если вы не используете устройства, которым нужны эти прошивки, вы можете игнорировать эти сообщения. На данный момент единственным решением для скрытия предупреждений модулей wd719x и aic94xx является установка пакетов с этими самыми прошивками. Для aic94xx установите aic94xx-firmwareAUR. Для wd719x установите wd719x-firmwareAUR. Для xhci_pci установите upd72020x-fwAUR. Смотрите связанное обсуждение здесь.\n\nСамые распространённые файлы прошивок поставляются пакетом linux-firmware. Другие файлы прошивок можно поискать в официальных репозиториях или AUR.\n\n"
    },
    {
      "title": "No PS/2 controller found",
      "level": 3,
      "content": "На некоторых материнских платах (в основном старых, но также и некоторых новых) контроллер i8042 не определяется автоматически. Это бывает редко, но некоторые люди всё же могут оказаться с неработающей клавиатурой. Вы можете заранее обнаружить эту ситуацию. Если у вас есть порт PS/2 и вы получаете сообщение i8042: PNP: No PS/2 controller found. Probing ports directly, добавьте atkbd в массив MODULES.\n\n"
    },
    {
      "title": "Стандартная процедура восстановления",
      "level": 3,
      "content": "При неправильно сформированном начальном RAM-диске систему скорее всего не получится загрузить. В таком случае выполните описанную ниже процедуру восстановления системы:\n\n"
    },
    {
      "title": "Загрузка выполняется на одной машине и терпит неудачу на другой",
      "level": 4,
      "content": "autodetect hook скрипта mkinitcpio фильтрует ненужные модули ядра в первичном initramfs путем сканирования /sys и модулей, загруженных во время запуска. Если вы переносите /boot каталог на другую машину и последовательность загрузки терпит неудачу на стадии early userspace, то это может проиходить, потому что новое аппаратное обеспечение не определено отсутствующими модулями ядра. Обратите внимание, что для USB 2.0 и 3.0 нужны разные модули ядра.\n\nЧтобы исправить, сначала попробуйте выбрать fallback образ в вашем загрузчике, поскольку он не фильтруется с помощью autodetect. После загрузки выполните mkinitcpio на новой машине, чтобы пересобрать первичный образ с корректными модулями. Если fallback образ не решил проблему, пропробуйте загрузиться в Arch Linux live CD/USB, выполнить chroot в установленную систему и выполнить mkinitcpio на новой машине. В крайнем случае, попробуйте вручную добавить модули в initramfs.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Документация ядра Linux: initramfs, \"What is rootfs?\"\n- Документация ядра Linux: initrd\n- Статья на Википедии: initrd\n\n"
    }
  ]
}