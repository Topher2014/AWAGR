{
  "title": "Управление питанием",
  "url": "https://wiki.archlinux.org/title/%D0%A3%D0%BF%D1%80%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BF%D0%B8%D1%82%D0%B0%D0%BD%D0%B8%D0%B5%D0%BC",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Ждущий и спящий режимы\n- Power management/Wakeup triggers\n- Display Power Management Signaling (Русский)\n- Управление частотой процессора\n- Гибридная графика\n- Модули ядра\n- sysctl (Русский)\n- udev (Русский)\n\nУправление питанием — это функция, которая отключает питание или переводит компоненты системы в состояние низкого энергопотребления, когда они неактивны.\n\nВ Arch Linux управление питанием состоит из двух основных частей:\n\n1. Конфигурация ядра Linux, которое взаимодействует с аппаратным обеспечением. Параметры ядра Модули ядра Правила udev\n1. Конфигурация пользовательских инструментов, которые взаимодействуют с ядром и реагируют на его события. Многие инструменты также предоставляют удобные способы изменения конфигурация ядра. Смотрите раздел #Пользовательские инструменты.\n\n- Параметры ядра\n- Модули ядра\n- Правила udev\n\n"
    },
    {
      "title": "Пользовательские инструменты",
      "level": 2,
      "content": "Эти инструменты являются удобной альтернативой ручной установке многих параметров. Запускайте только один из этих инструментов, чтобы избежать возможных конфликтов, так как все они работают примерно одинаково. Просмотрите Category:Power management (Русский), чтобы получить представление о том, какие возможности управления питанием существуют в Arch Linux.\n\nПопулярные скрипты и инструменты, управляющие энергосбережением:\n\n"
    },
    {
      "title": "Консольные",
      "level": 3,
      "content": "- acpid — Демон для доставки событий управления питанием ACPI с поддержкой netlink.\n\n- Laptop Mode Tools — Инструмент для настройки параметров энергосбережения ноутбука, которую многие считают де-факто утилитой для энергосбережения, хотя она может потребовать некоторой настройки.\n\n- libsmbios — Библиотека и инструменты для взаимодействия с таблицами Dell SMBIOS.\n\n- powertop — Инструмент для диагностики проблем с энергопотреблением и управлением питанием, помогающий установить параметры энергосбережения.\n\n- systemd — Менеджер системы и служб.\n\n- TLP — Расширенное управление питанием для Linux.\n\n"
    },
    {
      "title": "Графические",
      "level": 3,
      "content": "- batsignal — Лёгкий монитор батареи, использующий libnotify для предупреждения о низком уровне заряда.\n\n- cbatticon — Лёгкий и быстрый значок батареи в системном трее.\n\n- GNOME Power Statistics — Информация о питании системы и статистика для среды GNOME.\n\n- KDE Power Devil — Модуль управления питанием для Plasma.\n\n- LXQt Power Management — Модуль управления питанием для LXQt.\n\n- MATE Power Management — Инструмент управления питанием для MATE.\n\n- MATE Power Statistics — Информация о питании системы и статистика для среды MATE.\n\n- poweralertd — Демон для доставки уведомлений UPower.\n\n- powerkit — Менеджер питания, независимый от сред рабочего стола.\n\n- Xfce Power Manager — Менеджер питания для Xfce.\n\n- vattery — Приложение, написанное на Vala, которое отображает состояние батареи ноутбука в системном трее.\n\n"
    },
    {
      "title": "События ACPI",
      "level": 3,
      "content": "systemd обрабатывает некоторые события ACPI, связанные с питанием. Выполняемые при этом действия можно настроить в /etc/systemd/logind.conf или /etc/systemd/logind.conf.d/*.conf — смотрите logind.conf(5). В системах без специального менеджера питания он может заменить демон acpid, который обычно использовался для реагирования на эти события ACPI.\n\nВозможные действия — ignore, poweroff, reboot, halt, suspend, hibernate, hybrid-sleep, suspend-then-hibernate, lock или kexec. Для использования ждущего (suspend) и спящего (hibernate) режимов требуется предварительная настройка. При отсутствии настроек systemd будет выполнять действие по умолчанию.\n\nTable content:\nОбработчик | Описание | Действие по умолчанию\nHandlePowerKey | Срабатывает, когда нажата кнопка питания. | poweroff\nHandleSuspendKey | Срабатывает, когда нажата кнопка ждущего режима. | suspend\nHandleHibernateKey | Срабатывает, когда нажата кнопка спящего режима. | hibernate\nHandleLidSwitch | Срабатывает, когда закрывается крышка (ноутбука), за исключением описанных ниже случаев. | suspend\nHandleLidSwitchDocked | Срабатывает, когда закрывается крышка, но система подключена к док-станции или подключено более одного монитора. | ignore\nHandleLidSwitchExternalPower | Срабатывает, когда закрывается крышка, но система подключена к внешнему питанию. | действие, установленное для HandleLidSwitch\n\nДля применения изменений отправьте процессу systemd-logind сигнал HUP:\n\n```\n# systemctl kill -s HUP systemd-logind\n```\n\n"
    },
    {
      "title": "Менеджеры питания",
      "level": 4,
      "content": "Некоторые среды рабочего стола предоставляют менеджеры питания, которые блокируют (inhibit, временно отключают) некоторые или все настройки systemd ACPI. Если такой менеджер питания запущен, то действия для событий ACPI могут быть настроены только в этом менеджере. Изменения в /etc/systemd/logind.conf или /etc/systemd/logind.conf.d/*.conf нужны только в том случае, если вы хотите настроить поведение для события, которое не блокируется используемым вами менеджером питания.\n\nОбратите внимание, что если менеджер питания не блокирует соответствующие события в systemd, вы можете оказаться в ситуации, когда systemd уводит систему в сон, а затем, когда система пробуждается, другой менеджер питания снова уводит её в сон. Менеджеры питания KDE, GNOME, Xfce и MATE выдают необходимые команды inhibited. Если они не выдаются, например, при использовании acpid или других инструментов для обработки событий ACPI, установите в опциях Handle значение ignore. Смотрите также systemd-inhibit(1).\n\n"
    },
    {
      "title": "xss-lock",
      "level": 4,
      "content": "xss-lock подписывается на systemd-события suspend, hibernate, lock-session и unlock-session с соответствующими действиями (запустить блокировщик и ждать, пока пользователь разблокирует или убьёт блокировщик). xss-lock также реагирует на события DPMS и в ответ запускает или завершает блокировщик.\n\nДобавьте xss-lock в автозапуск, например:\n\n```\nxss-lock -- i3lock -n -i фоновая_картинка.png &\n```\n\n"
    },
    {
      "title": "Ждущий и спящий режимы",
      "level": 3,
      "content": "systemd предоставляет команды для перехода в ждущий (suspend) или спящий (hibernate) режим, использующие встроенную в ядро функциональность. Также есть механизм хуков для настройки действий до и после сна.\n\nКоманда systemctl suspend должна работать из коробки, а для systemctl hibernate требуется предварительная настройка, описанная в статье Ждущий и спящий режимы#Гибернация.\n\nТакже есть ещё два режима, комбинирующих ждущий и спящий режимы:\n\n- systemctl hybrid-sleep сохраняет состояние системы одновременно и в оперативной памяти, и на диске, благодаря чему отключение питания не приводит к потере данных. Этот режим также называют suspend to both.\n- systemctl suspend-then-hibernate изначально уходит в ждущий режим на максимально возможное время, затем по сигналу от аппаратных часов (или по сигналу о низком заряде батареи, если это реализовано в системе) просыпается и уходит в спящий режим. Время срабатывания аппаратных часов указывается в настройке HibernateDelaySec в файле systemd-sleep.conf(5). Значение по умолчанию вычисляется на основе скорости разряда батареи так, чтобы к моменту пробуждения оставалось 5% заряда; если батареи нет, то значение по умолчанию 2 часа. Вычисление производится на основе измерения уровня заряда батареи после времени, заданного в настройке SuspendEstimationSec в systemd-sleep.conf(5): после истечения указанного времени система ненадолго проснётся для выполнения измерения (измерение также производится при пробуждении пользователем).\n\n"
    },
    {
      "title": "Отключение сна",
      "level": 4,
      "content": "При использовании устройства в качестве, например, сервера уход в сон может быть не нужен или даже нежелателен. Можно настроить любое состояние сна:\n\n```\n/etc/systemd/sleep.conf.d/disable-suspend.conf\n```\n\n```\n[Sleep]\nAllowSuspend=no\nAllowHibernation=no\nAllowSuspendThenHibernate=no\nAllowHybridSleep=no\n```\n\n"
    },
    {
      "title": "Файлы служб",
      "level": 4,
      "content": "Можно запускать службы до или после сна, если связать их с юнитами suspend.target, hibernate.target, sleep.target, hybrid-sleep.target и suspend-then-hibernate.target. Для общесистемных и пользовательских действий нужно создавать отдельные файлы. Ниже приведены примеры таких файлов; включите службы suspend@пользователь и resume@пользователь.\n\n```\n/etc/systemd/system/suspend@.service\n```\n\n```\n[Unit]\nDescription=User suspend actions\nBefore=sleep.target\n\n[Service]\nUser=%I\nType=forking\nEnvironment=DISPLAY=:0\nExecStartPre= -/usr/bin/pkill -u %u unison ; /usr/local/bin/music.sh stop\nExecStart=/usr/bin/sflock\nExecStartPost=/usr/bin/sleep 1\n\n[Install]\nWantedBy=sleep.target\n```\n\n```\n/etc/systemd/system/resume@.service\n```\n\n```\n[Unit]\nDescription=User resume actions\nAfter=suspend.target\n\n[Service]\nUser=%I\nType=simple\nExecStart=/usr/local/bin/ssh-connect.sh\n\n[Install]\nWantedBy=suspend.target\n```\n\nПример для общесистемных действий (включите службы root-resume и root-suspend):\n\n```\n/etc/systemd/system/root-suspend.service\n```\n\n```\n[Unit]\nDescription=Local system suspend actions\nBefore=sleep.target\n\n[Service]\nType=simple\nExecStart=-/usr/bin/pkill sshfs\n\n[Install]\nWantedBy=sleep.target\n```\n\n```\n/etc/systemd/system/root-resume.service\n```\n\n```\n[Unit]\nDescription=Local system resume actions\nAfter=suspend.target\n\n[Service]\nType=simple\nExecStart=/usr/bin/systemctl restart mnt-media.automount\n\n[Install]\nWantedBy=suspend.target\n```\n\n- Если указать Type=oneshot, то вы сможете использовать несколько строк ExecStart=. В противном случае допускается только одна строка ExecStart. Вы можете добавлять дополнительные команды либо с помощью ExecStartPre, либо разделяя команды точкой с запятой (смотрите первый пример выше; обратите внимание на пробелы до и после точки с запятой, так как они обязательны).\n- Если к команде добавить префикс -, то ненулевой статус выхода будет игнорироваться и любое завершение работы команды будет считаться успешным выполнением команды.\n- Лучшее место для поиска ошибок при решении проблем, связанных с этими файлами, — это, конечно, journalctl.\n\n"
    },
    {
      "title": "Комбинированный файл службы",
      "level": 4,
      "content": "При использовании комбинированного файла службы один и тот же хук выполняет всю работу для разных фаз (сон и пробуждение) и для разных целей (ждущий/спящий/гибридный режимы).\n\nПример и объяснение:\n\n```\n/etc/systemd/system/wicd-sleep.service\n```\n\n```\n[Unit]\nDescription=Wicd sleep hook\nBefore=sleep.target\nStopWhenUnneeded=yes\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=-/usr/share/wicd/daemon/suspend.py\nExecStop=-/usr/share/wicd/daemon/autoconnect.py\n\n[Install]\nWantedBy=sleep.target\n```\n\n- RemainAfterExit=yes: После запуска служба считается активной до тех пор, пока её явно не остановят.\n- StopWhenUnneeded=yes: Если служба активна, она будет остановлена, если ни одна другая активная служба не нуждается в ней. В данном конкретном примере она будет остановлена после остановки sleep.target.\n- Поскольку sleep.target связан с suspend.target, hibernate.target и hybrid-sleep.target и поскольку sleep.target сам является StopWhenUnneeded службой, хук гарантированно запустится/остановится правильно для различных режимов.\n\nВ следующем примере показана служба-шаблон, которая может быть использована для подключения любой существующей службы systemd к событиям питания:[1]\n\n```\n/etc/systemd/system/sleep@.service\n```\n\n```\n[Unit]\nDescription=%I sleep hook\nBefore=sleep.target\nStopWhenUnneeded=yes\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=-/usr/bin/systemctl stop %i\nExecStop=-/usr/bin/systemctl start %i\n\n[Install]\nWantedBy=sleep.target\n```\n\nВключите экземпляр этого шаблона, после символа @ указав название существующей службы systemd, то есть sleep@название-файла-службы.service. Смотрите systemd.unit(5) § DESCRIPTION для более подробной информации о юнитах-шаблонах.\n\n"
    },
    {
      "title": "Хуки в /usr/lib/systemd/system-sleep",
      "level": 4,
      "content": "systemd запускает все исполняемые файлы из каталога /usr/lib/systemd/system-sleep/, передавая им два аргумента:\n\n- Аргумент 1: pre или post в зависимости от того, уходит ли система в сон или пробуждается\n- Аргумент 2: suspend, hibernate или hybrid-sleep в зависимости от конкретного режима сна\n\nsystemd запускает все файлы одновременно, а не последовательно друг за другом.\n\nВывод будет записан в журнал службы systemd-suspend.service, systemd-hibernate.service или systemd-hybrid-sleep.service, который можно посмотреть с помощью journalctl:\n\n```\n# journalctl -b -u systemd-suspend.service\n```\n\nПример скрипта:\n\n```\n/usr/lib/systemd/system-sleep/example.sh\n```\n\n```\n#!/bin/sh\ncase $1/$2 in\n  pre/*)\n    echo \"Going to $2...\"\n    ;;\n  post/*)\n    echo \"Waking up from $2...\"\n    ;;\nesac\n```\n\nНе забудьте сделать скрипт исполняемым.\n\nСмотрите systemd.special(7) и systemd-sleep(8) для более подробной информации.\n\n"
    },
    {
      "title": "Отложенное выполнение действия при закрытии крышки ноутбука",
      "level": 4,
      "content": "Если ноутбук закрывается и открывается несколько раз подряд, logind задержит переход в ждущий режим до 90 секунд, чтобы дать ядру время для обнаружения подключенной док-станции. [3] С версии systemd v220 время задержки можно настроить:[4]\n\n```\n/etc/systemd/logind.conf\n```\n\n```\n...\nHoldoffTimeoutSec=30s\n...\n```\n\n"
    },
    {
      "title": "Fn-кнопка сна на ноутбуке не работает",
      "level": 4,
      "content": "Если независимо от настроек в logind.conf кнопка сна не работает (её нажатие даже не приводит к появлению сообщения в syslog), то logind, вероятно, не отслеживает клавиатуру. [5] Выполните:\n\n```\n# journalctl --grep=\"Watching system buttons\"\n```\n\nВы увидите что-то подобное:\n\n```\nMay 25 21:28:19 vmarch.lan systemd-logind[210]: Watching system buttons on /dev/input/event2 (Power Button)\nMay 25 21:28:19 vmarch.lan systemd-logind[210]: Watching system buttons on /dev/input/event3 (Sleep Button)\nMay 25 21:28:19 vmarch.lan systemd-logind[210]: Watching system buttons on /dev/input/event4 (Video Bus)\n```\n\nЕсли здесь нет клавиатуры, то найдите её ATTRS{name} [6] :\n\n```\n# udevadm info -a /dev/input/by-path/*-kbd\n```\n\n```\n...\nKERNEL==\"event0\"\n...\nATTRS{name}==\"AT Translated Set 2 keyboard\"\n```\n\nИ напишите правило udev для добавления тега \"power-switch\":\n\n```\n/etc/udev/rules.d/70-power-switch-my.rules\n```\n\n```\nACTION==\"remove\", GOTO=\"power_switch_my_end\"\nSUBSYSTEM==\"input\", KERNEL==\"event*\", ATTRS{name}==\"AT Translated Set 2 keyboard\", TAG+=\"power-switch\"\nLABEL=\"power_switch_my_end\"\n```\n\nПерезапустите службу systemd-udevd.service, перезагрузите правила выполнением команды udevadm trigger от имени root и перезапустите службу systemd-logind.service.\n\nТеперь в журнале должна появиться строка, связанная с клавиатурой: Watching system buttons on /dev/input/event0.\n\n"
    },
    {
      "title": "Компьютер с чипсетом A520I или B550I не пробуждается",
      "level": 4,
      "content": "На некоторых материнских платах с чипсетами A520i и B550i система не полностью входит в состояние сна или выходит из него. Симптомы: система переходит в сон, монитор выключается, а внутренние светодиоды на материнской плате или светодиод питания остаются включенными. Впоследствии система не возвращается из этого состояния и требует полного выключения питания. Если у вас возникли подобные проблемы с AMD, сначала убедитесь, что ваша система полностью обновлена, и проверьте, установлен ли пакет с микрокодом для AMD.\n\nУбедитесь, что строка, начинающаяся с GPP0, имеет статус enabled:\n\n```\n$ cat /proc/acpi/wakeup\n```\n\n```\nDevice\tS-state\t  Status   Sysfs node\nGP12\t  S4\t*enabled   pci:0000:00:07.1\nGP13\t  S4\t*enabled   pci:0000:00:08.1\nXHC0\t  S4\t*enabled   pci:0000:0b:00.3\nGP30\t  S4\t*disabled\nGP31\t  S4\t*disabled\nPS2K\t  S3\t*disabled\nGPP0\t  S4\t*enabled   pci:0000:00:01.1\nGPP8\t  S4\t*enabled   pci:0000:00:03.1\nPTXH\t  S4\t*enabled   pci:0000:05:00.0\nPT20\t  S4\t*disabled\nPT24\t  S4\t*disabled\nPT26\t  S4\t*disabled\nPT27\t  S4\t*disabled\nPT28\t  S4\t*enabled   pci:0000:06:08.0\nPT29\t  S4\t*enabled   pci:0000:06:09.0\n```\n\nЕсли enabled, вы можете выполнить следующую команду:\n\n```\n# echo GPP0 > /proc/acpi/wakeup\n```\n\nТеперь проверьте, запустив systemctl suspend и позволив системе перейти в ждущий режим. Затем попробуйте разбудить систему через несколько секунд. Если это сработает, вы можете сделать этот обходной путь постоянным. Создайте файл юнита systemd:\n\n```\n/etc/systemd/system/toggle-gpp0-to-fix-wakeup.service\n```\n\n```\n[Unit]\nDescription=\"Disable GPP0 to fix suspend issue\"\n\n[Service]\nExecStart=/bin/sh -c \"/bin/echo GPP0 > /proc/acpi/wakeup\"\n\n[Install]\nWantedBy=multi-user.target\n```\n\nВыполните daemon-reload и запустите/включите этот юнит.\n\n"
    },
    {
      "title": "Подкачка только для спящего режима",
      "level": 4,
      "content": "Иногда может потребоваться, чтобы подкачка включалась только для спящего режима и выключалась после пробуждения.\n\nХотя это можно реализовать с помощью описанных выше хуков, можно также напрямую настроить юнит подкачки (смотрите systemd.swap(5)):\n\n```\n/etc/systemd/system/путь-к-подкачке.swap\n```\n\n```\n[Unit]\nBefore=systemd-hibernate.service\nStopWhenUnneeded=true\n\n[Swap]\nWhat=/путь/к/подкачке\nOptions=noauto\n\n[Install]\nRequiredBy=systemd-hibernate.service\n```\n\nОбратите внимание, что имя файла юнита должно соответствовать пути подкачки и что юнит должен быть включен, чтобы параметр RequiredBy= вступил в силу.\n\nМожно также прописать в зависимости hibernate.target вместо systemd-hibernate.service, но тогда прямой запуск systemctl start systemd-hibernate.service не будет работать.\n\nОбратите внимание, что среды рабочего стола теперь могут не показывать опцию перехода в спящий режим и systemctl hibernate не будет работать, потому что они запрашивают у systemd-logind доступные режимы энергосбережения, а он не будет сообщать о возможности перехода в спящий режим, если нет активной подкачки.\n\nЭто можно обойти, запустив systemd-logind с переменной окружения SYSTEMD_BYPASS_HIBERNATION_MEMORY_CHECK=1, например, создав drop-in файл:\n\n```\n/etc/systemd/system/systemd-logind.service.d/disable-hibernation-swap-check.conf\n```\n\n```\n[Service]\nEnvironment=\"SYSTEMD_BYPASS_HIBERNATION_MEMORY_CHECK=1\"\n```\n\n"
    },
    {
      "title": "Энергосбережение",
      "level": 2,
      "content": "Данный раздел является справочником по созданию скриптов и настроек энергосбережения, например, с помощью правил udev. Убедитесь, что настройки не управляются каким-либо другим пользовательским инструментом, чтобы не было конфликтов.\n\nПочти все перечисленные здесь функции стоит использовать независимо от того, работает ли компьютер от сети или от батареи. Большинство из них имеют незначительное влияние на производительность и просто не включены по умолчанию из-за распространённых неисправностей оборудования/драйверов. Снижение энергопотребления означает снижение тепловыделения, что может даже привести к повышению производительности современного процессора Intel или AMD благодаря динамическому изменению тактовой частоты.\n\n"
    },
    {
      "title": "Процессоры с поддержкой Intel HWP (Intel Hardware P-state)",
      "level": 3,
      "content": "Доступные энергетические предпочтения (energy preferences) процессора, поддерживающего HWP: default, performance, balance_performance, balance_power, power.\n\nЭто можно проверить командой\n\n```\n$ cat /sys/devices/system/cpu/cpufreq/policy?/energy_performance_available_preferences\n```\n\nЧтобы сэкономить больше энергии, можно создать следующий файл:\n\n```\n/etc/tmpfiles.d/energy_performance_preference.conf\n```\n\n```\nw /sys/devices/system/cpu/cpufreq/policy?/energy_performance_preference - - - - balance_power\n```\n\nСмотрите systemd-tmpfiles(8) и tmpfiles.d(5) для более подробной информации.\n\n"
    },
    {
      "title": "Ядро",
      "level": 4,
      "content": "По умолчанию энергосбережение звуковых устройств отключено в большинстве драйверов. Его можно включить, задав параметр power_save — время (в секундах) до перехода в режим ожидания. Чтобы отключить звуковую карту через одну секунду, создайте следующий файл для звуковых карт Intel.\n\n```\n/etc/modprobe.d/audio_powersave.conf\n```\n\n```\noptions snd_hda_intel power_save=1\n```\n\nДля ac97 используйте следующее:\n\n```\noptions snd_ac97_codec power_save=1\n```\n\n- Чтобы узнать производителя звуковой карты и соответствующий драйвер ядра, выполните lspci -k.\n- Переключение состояния питания аудиокарты может вызвать щёлкающий звук или заметную задержку на некотором оборудовании.\n\nТакже можно ещё больше снизить требования к питанию звука, отключив аудиовыход HDMI, что можно сделать, заблокировав соответствующие модули ядра (например, snd_hda_codec_hdmi для Intel).\n\n"
    },
    {
      "title": "PulseAudio",
      "level": 4,
      "content": "По умолчанию PulseAudio приостанавливает работу всех источников звука, которые слишком долго простаивают. При использовании внешнего USB-микрофона запись может начинаться с щелчком. В качестве обходного пути закомментируйте следующую строку в файле /etc/pulse/default.pa:\n\n```\nload-module module-suspend-on-idle\n```\n\nПосле этого перезапустите PulseAudio: systemctl restart --user pulseaudio.\n\n"
    },
    {
      "title": "Подсветка экрана",
      "level": 3,
      "content": "Смотрите Backlight (Русский).\n\n"
    },
    {
      "title": "Bluetooth",
      "level": 3,
      "content": "Чтобы полностью отключить Bluetooth, заблокируйте модули btusb и bluetooth.\n\nДля временного отключения используйте rfkill:\n\n```\n# rfkill block bluetooth\n```\n\nИли с помощью правила udev:\n\n```\n/etc/udev/rules.d/50-bluetooth.rules\n```\n\n```\n# disable bluetooth\nSUBSYSTEM==\"rfkill\", ATTR{type}==\"bluetooth\", ATTR{state}=\"0\"\n```\n\n"
    },
    {
      "title": "Веб-камера",
      "level": 3,
      "content": "Если вы не используете встроенную веб-камеру, заблокируйте модуль uvcvideo.\n\n"
    },
    {
      "title": "Параметры ядра",
      "level": 3,
      "content": "Этот раздел использует конфигурацию /etc/sysctl.d/ — drop-in каталог для sysctl-параметров ядра. Смотрите The New Configuration Files и sysctl.d(5) для более подробной информации.\n\n"
    },
    {
      "title": "Отключение сторожевого таймера с NMI",
      "level": 4,
      "content": "Сторожевой таймер, использующий немаскируемое прерывание (Non-maskable interrupt), — это отладочная функция, позволяющая отлавливать аппаратные зависания, которые вызывают панику ядра. В некоторых системах он может генерировать большое количество прерываний, вызывая заметное увеличение энергопотребления:\n\n```\n/etc/sysctl.d/disable_watchdog.conf\n```\n\n```\nkernel.nmi_watchdog = 0\n```\n\nИли добавьте nmi_watchdog=0 в параметры ядра для полного отключения с начала загрузки.\n\n"
    },
    {
      "title": "Время Writeback",
      "level": 4,
      "content": "Увеличение времени перед записью изменённых данных из памяти на диск помогает сгруппировать операции ввода-вывода, тем самым уменьшая нагрузку на диск и потребление энергии. Чтобы установить значение 60 секунд (по умолчанию 5 секунд):\n\n```\n/etc/sysctl.d/dirty.conf\n```\n\n```\nvm.dirty_writeback_centisecs = 6000\n```\n\nЧтобы сделать то же самое для записи журналов на поддерживаемых файловых системах (например, ext4, btrfs...), используйте commit=60 в качестве опции в fstab.\n\nОбратите внимание, что это значение изменяется как побочный эффект настройки Laptop Mode, приведённой ниже. Другие параметры, влияющие на производительность ввода-вывода и энергосбережение, описаны в разделе sysctl (Русский)#Виртуальная память.\n\n"
    },
    {
      "title": "Laptop Mode",
      "level": 4,
      "content": "Смотрите документацию ядра. \"A sensible value for the knob is 5 seconds.\"\n\n```\n/etc/sysctl.d/laptop.conf\n```\n\n```\nvm.laptop_mode = 5\n```\n\n"
    },
    {
      "title": "Сетевые интерфейсы",
      "level": 3,
      "content": "Wake-on-LAN может быть полезной функцией, но если вы не используете её, то она впустую потребляет дополнительную энергию в режиме сна. Вы можете адаптировать правило Wake-on-LAN#udev, чтобы отключить эту функцию для всех Ethernet-интерфейсов. Чтобы включить энергосбережение с помощью iw на всех беспроводных интерфейсах:\n\n```\n/etc/udev/rules.d/81-wifi-powersave.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"net\", KERNEL==\"wl*\", RUN+=\"/usr/bin/iw dev $name set power_save on\"\n```\n\nИмя этого файла имеет важное значение. При использовании постоянных имён устройств в systemd это правило, которое в лексикографической сортировке находится после 80-net-setup-link.rules, применяется после переименования устройства в его постоянное имя, например wlan0 переименовывается в wlp3s0. Помните, что команда RUN выполняется после обработки всех правил и в любом случае должна использовать постоянное имя, доступное в $name для сопоставленного устройства.\n\n"
    },
    {
      "title": "Беспроводные карты Intel (iwlwifi)",
      "level": 4,
      "content": "Дополнительные функции энергосбережения беспроводных карт Intel с драйвером iwlwifi можно включить путём передачи правильных параметров в модуль ядра. Сделать их постоянными можно, добавив следующие строки в файл /etc/modprobe.d/iwlwifi.conf:\n\n```\noptions iwlwifi power_save=1\n```\n\nЭта опция, вероятно, увеличит медианную задержку:\n\n```\noptions iwlwifi uapsd_disable=0\n```\n\nНа ядрах < 5.4 вы можете использовать эту опцию, но это, вероятно, снизит максимальную пропускную способность:\n\n```\noptions iwlwifi d0i3_disable=0\n```\n\nВ зависимости от вашей беспроводной карты будет применяться один из этих двух вариантов.\n\n```\noptions iwlmvm power_scheme=3\n```\n\n```\noptions iwldvm force_cam=0\n```\n\nВы можете проверить, какой из них является актуальным, проверив, какой из этих модулей запущен, используя\n\n```\n# lsmod | grep '^iwl.vm'\n```\n\nПомните, что эти варианты энергосбережения являются экспериментальными и могут привести к нестабильной работе системы.\n\n"
    },
    {
      "title": "Active State Power Management",
      "level": 4,
      "content": "Если система считает, что компьютер не поддерживает ASPM, он будет отключен при загрузке:\n\n```\n# lspci -vv | grep 'ASPM.*abled;'\n```\n\nASPM управляется через BIOS. Если ASPM отключен, это происходит потому, что [7][устаревшая ссылка 2024-10-12 ⓘ]:\n\n1. BIOS отключил его по какой-то причине (из-за конфликтов?).\n1. PCIE требует ASPM, но L0s необязательны (поэтому L0s могут быть отключены, а включен только L1).\n1. BIOS мог быть не запрограммирован для этого.\n1. BIOS глючит.\n\nЕсли компьютер точно поддерживает ASPM, его можно принудительно включить с помощью параметра ядра pcie_aspm=force.\n\n- Принудительное включение ASPM может вызвать зависание/панику, поэтому убедитесь, что у вас есть возможность удалить этот параметр, если он не сработает.\n- На системах, которые не поддерживают эту функцию, принудительное включение ASPM может даже увеличить энергопотребление.\n- Это принудительно включает ASPM в ядре, в то время как в аппаратной части он может оставаться отключенным и не работать. Чтобы проверить, так ли это, выполните dmesg | grep ASPM от имени root. Если да, обратитесь к вики-статье, относящейся к вашему оборудованию.\n\nЧтобы переключиться на powersave, выполните (следующая команда не будет работать, если ASPM не включен):\n\n```\n# echo powersave > /sys/module/pcie_aspm/parameters/policy\n```\n\nПо умолчанию этот файл выглядит примерно так:\n\n```\n$ cat /sys/module/pcie_aspm/parameters/policy\n```\n\n```\n[default] performance powersave powersupersave\n```\n\n"
    },
    {
      "title": "PCI Runtime Power Management",
      "level": 4,
      "content": "```\n/etc/udev/rules.d/pci_pm.rules\n```\n\n```\nSUBSYSTEM==\"pci\", ATTR{power/control}=\"auto\"\n```\n\nЭто правило выключает все неиспользуемые устройства, но некоторые из них не проснутся обратно. Чтобы разрешить Runtime Power Management только для устройств, о которых известно, что они работают нормально, используйте простое сопоставление с идентификаторами производителя и устройства (используйте lspci -nn для получения этих значений):\n\n```\n/etc/udev/rules.d/pci_pm.rules\n```\n\n```\n# whitelist for pci autosuspend\nSUBSYSTEM==\"pci\", ATTR{vendor}==\"0x1234\", ATTR{device}==\"0x1234\", ATTR{power/control}=\"auto\"\n```\n\nАльтернативный вариант — заблокировать устройства, не работающие с PCI Runtime Power Management, и включить его для всех остальных устройств:\n\n```\n/etc/udev/rules.d/pci_pm.rules\n```\n\n```\n# blacklist for pci runtime power management\nSUBSYSTEM==\"pci\", ATTR{vendor}==\"0x1234\", ATTR{device}==\"0x1234\", ATTR{power/control}=\"on\", GOTO=\"pci_pm_end\"\n\nSUBSYSTEM==\"pci\", ATTR{power/control}=\"auto\"\nLABEL=\"pci_pm_end\"\n```\n\n"
    },
    {
      "title": "Автоматическая приостановка устройств USB",
      "level": 4,
      "content": "Ядро Linux может автоматически приостанавливать работу USB-устройств, когда они не используются (USB autosuspend). Иногда это позволяет сэкономить довольно много энергии, однако некоторые USB-устройства не совместимы с функцией энергосбережения и начинают вести себя неадекватно (частое явление среди USB-мышей/клавиатур). Правила udev, основанные на фильтрации по белым или чёрным спискам, могут помочь смягчить проблему.\n\nСамый простой и, скорее всего, бесполезный пример — включение автоматической приостановки для всех USB-устройств:\n\n```\n/etc/udev/rules.d/50-usb_power_save.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"usb\", TEST==\"power/control\", ATTR{power/control}=\"auto\"\n```\n\nЧтобы разрешить автоотключение только для устройств, о которых известно, что они работают нормально, используйте простое сопоставление с идентификаторами производителя и продукта (используйте lsusb для получения этих значений):\n\n```\n/etc/udev/rules.d/50-usb_power_save.rules\n```\n\n```\n# whitelist for usb autosuspend\nACTION==\"add\", SUBSYSTEM==\"usb\", TEST==\"power/control\", ATTR{idVendor}==\"05c6\", ATTR{idProduct}==\"9205\", ATTR{power/control}=\"auto\"\n```\n\nАльтернативный вариант — заблокировать устройства, не работающие с USB autosuspend, и включить его для всех остальных устройств:\n\n```\n/etc/udev/rules.d/50-usb_power_save.rules\n```\n\n```\n# blacklist for usb autosuspend\nACTION==\"add\", SUBSYSTEM==\"usb\", ATTR{idVendor}==\"05c6\", ATTR{idProduct}==\"9205\", GOTO=\"power_usb_rules_end\"\n\nACTION==\"add\", SUBSYSTEM==\"usb\", TEST==\"power/control\", ATTR{power/control}=\"auto\"\nLABEL=\"power_usb_rules_end\"\n```\n\nВремя задержки по умолчанию контролируется параметром autosuspend встроенного модуля ядра usbcore. Чтобы установить задержку на 5 секунд вместо стандартных 2 секунд, добавьте следующий параметр ядра в настройках вашего загрузчика:\n\n```\nusbcore.autosuspend=5\n```\n\nПо аналогии с power/control, время задержки можно изменить для отдельного устройства с помощью атрибута power/autosuspend. Установка значения -1 полностью отключит автоматическую приостановку:\n\n```\n/etc/udev/rules.d/50-usb_power_save.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"usb\", ATTR{idVendor}==\"05c6\", ATTR{idProduct}==\"9205\", ATTR{power/autosuspend}=\"-1\"\n```\n\nДополнительная информации об управлении питанием USB доступна в документации ядра.\n\n"
    },
    {
      "title": "SATA Active Link Power Management",
      "level": 4,
      "content": "В Linux 4.15 появилась новая настройка med_power_with_dipm, которая соответствует поведению настроек драйвера Windows IRST и не должна приводить к потере данных на последних SSD или HDD. Экономия энергии может быть значительной — от 1,0 до 1,5 Вт (в режиме ожидания). Это станет настройкой по умолчанию для ноутбуков на базе Intel в Linux 4.16 [8].\n\nТекущую настройку можно прочитать из /sys/class/scsi_host/host*/link_power_management_policy с помощью команды:\n\n```\n$ cat /sys/class/scsi_host/host*/link_power_management_policy\n```\n\nTable content:\nНастройка | Описание | Энергосбережение\nmax_performance | текущее значение по умолчанию | нет\nmedium_power | - | ~1,0 Вт\nmed_power_with_dipm | рекомендуемое значение | ~1,5 Вт\nmin_power | ВНИМАНИЕ: возможна потеря данных | ~1,5 Вт\n\n```\n/etc/udev/rules.d/hd_power_save.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"scsi_host\", KERNEL==\"host*\", ATTR{link_power_management_policy}=\"med_power_with_dipm\"\n```\n\n"
    },
    {
      "title": "Жёсткие диски",
      "level": 3,
      "content": "Возможные параметры для управления питанием диска описаны в разделе hdparm (Русский)#Настройка управления питанием.\n\nСберечь энергию не получится, если много программ часто записывают данные на диск. Отслеживание всех программ, а также того, как и когда они записывают данные на диск, является способом ограничения использования диска. Используйте iotop, чтобы увидеть, какие программы часто используют диск. Другие советы есть в разделе Увеличение производительности#Устройства хранения.\n\nТакже могут помочь такие мелочи, как установка опции noatime. Если доступно достаточно оперативной памяти, подумайте об отключении или ограничении swappiness, так как это может заметно уменьшить запись на диск.\n\nДля дисков Seagate с технологией PowerChoice трюки с настройкой APM через hdparm не работают. Вместо этого установите пакет seagate-seachestAUR. Например, для полного отключения EPC на диске можно использовать следующее:\n\n```\n# SeaChest_PowerControl --scan\n# SeaChest_PowerControl -d /dev/sdX -i\n# SeaChest_PowerControl -d /dev/sdX --showEPCSettings\n# SeaChest_PowerControl -d /dev/sdX --EPCfeature disable\n# SeaChest_PowerControl -d /dev/sdX --showEPCSettings\n```\n\nПоследняя команда выведет информацию:\n\n```\n==========================================================================================\n SeaChest_PowerControl - Seagate drive utilities - NVMe Enabled\n Copyright (c) 2014-2022 Seagate Technology LLC and/or its Affiliates, All Rights Reserved\n SeaChest_PowerControl Version: 3.1.10-3_2_1 X86_64\n Build Date: Jul 26 2022\n Today: Sat May 20 15:49:25 2023        User: root\n==========================================================================================\n\n/dev/sdc - ST1000NM0008-2F2100 - ZFA19JG2 - SN02 - ATA\n.\n\n===EPC Settings===\n        * = timer is enabled\n        C column = Changeable\n        S column = Savable\n        All times are in 100 milliseconds\n\nName       Current Timer Default Timer Saved Timer   Recovery Time C S\nIdle A      0            *10           *10           1             Y Y\nIdle B      0            *1200         *1200         3             Y Y\nIdle C      0             6000          6000         16            Y Y\nStandby Z   0             9000          9000         46            Y Y\n```\n\nНули в первом столбце означают, что парковка и остановка вращения были отключены.\n\n"
    },
    {
      "title": "Использование скрипта с правилом udev",
      "level": 3,
      "content": "Поскольку пользователи systemd могут переводить систему в ждущий или спящий режим через systemctl suspend или systemctl hibernate и обрабатывать события acpi с помощью /etc/systemd/logind.conf, может быть интересно удалить pm-utils и acpid. Есть только одна вещь, которую systemd не может сделать (по состоянию на systemd-204): управление питанием в зависимости от того, работает ли система от сети или от батареи. Чтобы заполнить этот пробел, вы можете создать правило udev, которое запускает скрипт при подключении и отключении внешнего питания:\n\n```\n/etc/udev/rules.d/powersave.rules\n```\n\n```\nSUBSYSTEM==\"power_supply\", ATTR{online}==\"0\", RUN+=\"/путь/к/вашему/скрипту true\"\nSUBSYSTEM==\"power_supply\", ATTR{online}==\"1\", RUN+=\"/путь/к/вашему/скрипту false\"\n```\n\nПримеры powersave скриптов:\n\n- ftw, пакет: ftw-gitAUR\n- powersave\n- throttlectl, из throttlectlAUR\n\nПриведённое выше правило udev должно работать как задумано, но если ваши настройки питания не обновляются после пробуждения системы, добавьте такой скрипт в /usr/lib/systemd/system-sleep/:\n\n```\n/usr/lib/systemd/system-sleep/00powersave\n```\n\n```\n#!/bin/sh\n\ncase $1 in\n    pre) /путь/к/вашему/скрипту false ;;\n    post)\n\tif cat /sys/class/power_supply/AC0/online | grep 0 > /dev/null 2>&1\n\tthen\n    \t\t/путь/к/вашему/скрипту true\n\telse\n    \t\t/путь/к/вашему/скрипту false\n\tfi\n    ;;\nesac\nexit 0\n```\n\nНе забудьте сделать его исполняемым.\n\n"
    },
    {
      "title": "Вывод параметров питания",
      "level": 3,
      "content": "Этот скрипт выводит параметры питания и ряд других свойств для USB и PCI устройств. Обратите внимание, что для просмотра всех настроек необходимы права root.\n\n```\n#!/bin/bash\n\nfor i in $(find /sys/devices -name \"bMaxPower\")\ndo\n\tbusdir=${i%/*}\n\tbusnum=$(<$busdir/busnum)\n\tdevnum=$(<$busdir/devnum)\n\ttitle=$(lsusb -s $busnum:$devnum)\n\n\tprintf \"\\n\\n+++ %s\\n  -%s\\n\" \"$title\" \"$busdir\"\n\n\tfor ff in $(find $busdir/power -type f ! -empty 2>/dev/null)\n\tdo\n\t\tv=$(cat $ff 2>/dev/null|tr -d \"\\n\")\n\t\t[[ ${#v} -gt 0 ]] && echo -e \" ${ff##*/}=$v\";\n\t\tv=;\n\tdone | sort -g;\ndone;\n\nprintf \"\\n\\n\\n+++ %s\\n\" \"Kernel Modules\"\nfor mod in $(lspci -k | sed -n '/in use:/s,^.*: ,,p' | sort -u)\ndo\n\techo \"+ $mod\";\n\tsystool -v -m $mod 2> /dev/null | sed -n \"/Parameters:/,/^$/p\";\ndone\n```\n\n"
    },
    {
      "title": "События нажатия кнопки питания и закрытия крышки ноутбука",
      "level": 3,
      "content": "События нажатия кнопок ждущего режима, выключения и режима гибернации, а также закрытия крышки ноутбука обрабатываются logind, как описано в разделе #События ACPI.\n\n"
    },
    {
      "title": "Используя systemd-logind",
      "level": 3,
      "content": "Если вы используете polkit, пользователи через локальный сеанс могут вызывать команды управления режимами электропитания, пока сеанс не будет нарушен.\n\nЧтобы убедиться, что ваш сеанс активен, наберите:\n\n```\n$ loginctl show-session $XDG_SESSION_ID --property=Active\n```\n\nПользователь может использовать команды systemctl в командной строке, или добавить их в меню среды рабочего стола:\n\n```\n$ systemctl poweroff\n$ systemctl reboot\n```\n\nДругие команды, такие как systemctl suspend и systemctl hibernate также могут быть использованы. Смотрите раздел System Commands в справочном руководстве systemctl(1).\n\n"
    },
    {
      "title": "Используя sudo",
      "level": 3,
      "content": "Установите sudo и добавьте текущего пользователя в список sudoers. После этого, текущий пользователь сможет вызывать команды sudo systemctl (например, sudo systemctl poweroff, sudo systemctl reboot, sudo systemctl suspend и sudo systemctl hibernate) через sudo из командной строки. Смотрите раздел System Commands в справочном руководстве systemctl(1).\n\n"
    },
    {
      "title": "Ограничение привилегий sudo",
      "level": 4,
      "content": "Если пользователю следует разрешить только, например, использовать команду выключения, добавьте следующее в конец файла /etc/sudoers, используя команду visudo:\n\n```\nимя_пользователя имя_хоста=NOPASSWD: /usr/bin/systemctl poweroff,/usr/bin/systemctl halt,/usr/bin/systemctl reboot\n```\n\nИмя хоста вы можете не указывать (или указать localhost). Теперь пользователь сможет выключить компьютер используя sudo systemctl poweroff или sudo systemctl halt, и перезагрузить его с помощью sudo systemctl reboot без ввода пароля. Удалите NOPASSWD:, если вы хотите, чтобы у пользователя запрашивался его пароль перед продолжением.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- ThinkWiki:How to reduce power consumption\n- How to get longer battery life on Linux\n\n"
    }
  ]
}