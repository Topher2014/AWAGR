{
  "title": "グループ",
  "url": "https://wiki.archlinux.org/title/%E3%82%B0%E3%83%AB%E3%83%BC%E3%83%97",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- DeveloperWiki:UID / GID Database\n- Sudo\n- Polkit\n- ファイルのパーミッションと属性\n- systemd-homed\n- パスワードリカバリ\n- アイデンティティ管理\n\nGNU/Linux のユーザーとグループは、アクセス制御のために使われています — つまり、システムのファイル、ディレクトリ、周辺機器へのアクセスのコントロールに使われます。Linux は比較的シンプルかつ粗っぽいアクセス制御メカニズムをデフォルトで提供します。高度な制御については、ACL や ケイパビリティ、PAM#設定方法を見て下さい。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 概要\n- 2 パーミッションと所有権\n- 3 Shadow\n- 4 ファイル一覧\n- 5 ユーザー管理 5.1 ユーザーを追加する例 5.1.1 ユーザーのデフォルト設定を変更する 5.2 システムユーザーを追加する例 5.3 ユーザーのログイン名やホームディレクトリを変更する 5.4 ユーザー管理の他の例\n- 6 ユーザーデータベース\n- 7 自動整合性チェック\n- 8 グループ管理\n- 9 グループ一覧 9.1 ユーザーグループ 9.2 システムグループ 9.3 systemd 以前のグループ 9.4 使われなくなったグループ\n- 10 これらのデータベースに関連した他のツール\n\n- 5.1 ユーザーを追加する例 5.1.1 ユーザーのデフォルト設定を変更する\n- 5.2 システムユーザーを追加する例\n- 5.3 ユーザーのログイン名やホームディレクトリを変更する\n- 5.4 ユーザー管理の他の例\n\n- 5.1.1 ユーザーのデフォルト設定を変更する\n\n- 9.1 ユーザーグループ\n- 9.2 システムグループ\n- 9.3 systemd 以前のグループ\n- 9.4 使われなくなったグループ\n\n"
    },
    {
      "title": "概要",
      "level": 2,
      "content": "ユーザーとはコンピュータを使う全ての人のことです。ここで、名前がユーザーを表すことを説明しましょう。名前は Mary や Bill という風につけられ、実名のかわりに Dragonlady や Pirate といった名前を使うことができます。重要なのはコンピュータはそれぞれのアカウントに名前をつけていて、人々がコンピュータを使うためのアクセスを得るために名前を使うということです。システムサービスによっては制限・特権ユーザーアカウントを使って動作させることもあります。\n\n特定の方法でアクセスを制限することでセキュリティのためにユーザーの管理が行われます。スーパーユーザー (root) はオペレーティングシステムと設定全てにアクセスすることができます。そのため管理用途だけに使われることが想定されています。特権がないユーザーはいくつかのプログラムによって制御された特権昇格を行うことが可能です。\n\n作成するアカウントにそれぞれ異なる名前を使えば、人々は複数のアカウントを持つことが可能です。さらに、\"root\" など、使うことができない予約済みの名前も存在します。\n\nユーザーは\"グループ\"にまとめることができ、グループに入ることでユーザーはグループで認められた特権的アクセスを利用することができます。\n\n"
    },
    {
      "title": "パーミッションと所有権",
      "level": 2,
      "content": "In UNIX Everything is a File より:\n\nExtending UNIX File Abstraction for General-Purpose Networking より:\n\nGNU/Linux において全てのファイルは1つのユーザーと1つのグループによって所有されます。加えて、アクセス許可の3つのタイプが存在します: 読み込み、書き込み、実行です。ファイルの所有ユーザー、所有グループ、（所有権をもっていない）第三者に対してそれぞれ異なるアクセス許可を適用することが可能です。ls コマンドによってファイルの所有者とパーミッションを確認できます:\n\n```\n$ ls -l /boot/\n```\n\n```\ntotal 13740\ndrwxr-xr-x 2 root root    4096 Jan 12 00:33 grub\n-rw-r--r-- 1 root root 8570335 Jan 12 00:33 initramfs-linux-fallback.img\n-rw-r--r-- 1 root root 1821573 Jan 12 00:31 initramfs-linux.img\n-rw-r--r-- 1 root root 1457315 Jan  8 08:19 System.map26\n-rw-r--r-- 1 root root 2209920 Jan  8 08:19 vmlinuz-linux\n```\n\n最初の列にファイルのパーミッションが表示されます (例えば、ファイル initramfs-linux.img のパーミッションは -rw-r--r--)。3、4列目にはファイルの所有ユーザーとグループがそれぞれ示されます。この例では、全てのファイルは root ユーザーと root グループによって所有されています。\n\n```\n$ ls -l /media/\n```\n\n```\ntotal 16\ndrwxrwx--- 1 root vboxsf 16384 Jan 29 11:02 sf_Shared\n```\n\nこの例では、sf_Shared ディレクトリは root ユーザーと vboxsf グループによって所有されています。stat コマンドを使うことでもファイルの所有者とパーミッションを確認することができます:\n\n所有ユーザー:\n\n```\n$ stat -c %U /media/sf_Shared/\n```\n\n```\nroot\n```\n\n所有グループ:\n\n```\n$ stat -c %G /media/sf_Shared/\n```\n\n```\nvboxsf\n```\n\nアクセス権限:\n\n```\n$ stat -c %A /media/sf_Shared/\n```\n\n```\ndrwxrwx---\n```\n\nアクセス許可は3つのグループの文字で表示され、それぞれ所有ユーザー、所有グループ、第三者のパーミッションを表しています。例えば、-rw-r--r-- はファイルの所有者は読み込みと書き込みが可能で、実行はできない (rw-) ことを示していて、さらに所有グループに属しているユーザーとその他のユーザーは読み込みしかできない (r-- と r--) ことを示しています。一方、drwxrwx--- はファイルの所有者と所有グループに属すユーザーが読み込み・書き込み・実行の全てができ (rwx と rwx)、他のユーザーはアクセスを拒否される (---) ことを示しています。一番最初の文字はファイルのタイプです。\n\nあるユーザーやグループによって所有されているファイルを一覧するには find コマンドを使います:\n\n```\n# find / -group groupname\n```\n\n```\n# find / -group groupnumber\n```\n\n```\n# find / -user user\n```\n\nファイルの所有ユーザーやグループは chown コマンドで変更できます。ファイルのアクセス許可を変更するコマンドは chmod です。\n\n詳しくは chown(1)、chmod(1)、Linux file permissions を見て下さい。\n\n"
    },
    {
      "title": "Shadow",
      "level": 2,
      "content": "Arch Linux のユーザー、グループおよびパスワードの管理ツールは、base メタパッケージ の依存関係である shadow パッケージから取得されます。\n\n"
    },
    {
      "title": "ファイル一覧",
      "level": 2,
      "content": "Table content:\nファイル | 目的\n/etc/shadow | セキュアなユーザーアカウント情報\n/etc/passwd | ユーザーアカウント情報\n/etc/gshadow | グループアカウントの暗号化された情報\n/etc/group | ユーザーが属するグループの定義\n\n"
    },
    {
      "title": "ユーザー管理",
      "level": 2,
      "content": "現在システムにログインしているユーザーを一覧するには who コマンドを使います。全てのユーザーアカウントとユーザーデータベースに保存されているプロパティを確認するには、root で passwd -Sa を実行してください。出力されるフォーマットについては passwd(1) の説明を読んでください。\n\n新しいユーザーを追加するときは useradd コマンドを使って下さい:\n\n```\n# useradd -m -G additional_groups -s login_shell username\n```\n\n初期のログイングループを名前か番号で指定する場合、すでに存在しているグループを参照しなければなりません。指定しない場合、useradd の挙動は /etc/login.defs 内の USERGROUPS_ENAB 変数に依存します。デフォルトの挙動 (USERGROUPS_ENAB yes) では、ユーザ名と同じ名前のグループを作成します。\n\n特定のサービスのためにユーザアカウントを作成する場合など、ログインシェルが機能してほしくない場合、/usr/bin/nologin をログインシェルとして指定することで、ログインを丁重に拒否することができます (nologin(8) を見てください)。\n\nサポートされている他のオプションについては useradd(8) を見てください。\n\n"
    },
    {
      "title": "ユーザーを追加する例",
      "level": 3,
      "content": "以下のコマンドは、archie という名前の新しいユーザを追加し、ホームディレクトリを作成し、グループ、ディレクトリ名、使用されるシェル、それ他のパラメータに関してはすべてデフォルト値を使用します:\n\n```\n# useradd -m archie\n```\n\n新しく作成したユーザ archie をパスワードで保護する必要はありませんが、パスワードで保護することが強く推奨されます:\n\n```\n# passwd archie\n```\n\n上記の useradd コマンドは、同時に archie という名前のグループも自動的に作成し、そのグループを archie のデフォルトのグループとします。ユーザを作成する際に各ユーザに (そのユーザと同じ名前の) 独自のグループを持たせることが推奨されています。\n\n-g オプションを使うことで別のグループをデフォルトグループにすることもできますが、マルチユーザシステムにおいてすべてのユーザが単一のデフォルトグループ (users など) を使用することは推奨されていません。その理由は、特定のグループのユーザで書き込みアクセス権を共有する方法は、ユーザの umask 値を 002 に設定するというものですが、これは、あなたが作成したすべてのファイルはデフォルトで常にデフォルトグループによってアクセス可能であることを意味するからです。User Private Groups も参照してください。ユーザが特定のグループのメンバーになる必要がある場合、そのユーザを作成する際にそのグループを補助グループとして指定してください。\n\n推奨されるシナリオ (デフォルトグループの名前がユーザ名と同じ場合) では、デフォルトですべてのファイルはそれらのファイルを作成したユーザのみが書き込み可能です。特定のグループに書き込みアクセスを許可したい場合、そのグループに属している全員に対して共有ファイル/ディレクトリを書き込み可能にすることで可能です。ディレクトリにグループの setgid ビットを設定することで、親ディレクトリを所有するグループに所有グループを自動的に固定することができます:\n\n```\n# chmod g+s our_shared_directory\n```\n\nそうしない場合、ファイル作成者のデフォルトグループ (通常、ユーザ名と同じ名前) が使用されます。\n\n一時的に GID を変更する必要がある場合、newgrp コマンドを使用することで実行時にユーザのフォルトの GID を他の GID に変更できます。例えば、newgrp groupname を実行したあと、そのユーザによって作成されたファイルは (再ログインの必要とせずに) groupname の GID と関連付けられます。デフォルトの GID に戻すには、グループ名無しで newgrp を実行してください。\n\n"
    },
    {
      "title": "ユーザーのデフォルト設定を変更する",
      "level": 4,
      "content": "新しいアカウントを作成する際に用いられるデフォルト値は /etc/default/useradd で設定されており、useradd --defaults コマンドで確認できます。例えば、SHELL=/usr/bin/shell を設定すると、デフォルトのシェルをグローバルに変更できます。また、-s/--shell オプションを使えば、アカウント毎にシェルを設定できます。chsh -l を使えば、有効なログインシェルを一覧表示できます。\n\n/etc/skel ディレクトリでは、新しく作成したユーザーのホームディレクトリへ追加するファイルを指定することもできます。これは、デスクトップ環境のような動作を実現するために設定ファイルを手動で編集する必要のあるミニマリズムなウィンドウマネージャにおいて便利です。例えば、新しく作成する全ユーザーに対してデフォルトのショートカットをセットアップするには:\n\n```\n# mkdir /etc/skel/.config\n# cp ~archie/.config/sxhkd /etc/skel/.config\n```\n\nまた、ディスプレイマネージャ#セッションとして ~/.xinitrc を実行 では、全ユーザーに対してディスプレイマネージャで xinitrc をオプションとして追加する方法について説明されています。\n\n"
    },
    {
      "title": "システムユーザーを追加する例",
      "level": 3,
      "content": "システムユーザーは、異なるユーザのもとでプロセス/デーモンを実行するために使用できます。(chown を使うなどして) ファイルやディレクトリを保護するなど、コンピュータの堅牢化において様々な使用例があります。\n\n以下のコマンドで、シェルへのアクセス権が無く、home ディレクトリも持たないシステムユーザが作成されます (オプションで、-U パラメータを追加するとユーザと同じ名前のグループも作成し、ユーザをそのグループに追加します):\n\n```\n# useradd --system -s /usr/bin/nologin username\n```\n\nシステムユーザが特定のユーザ ID およびグループ ID を必要とする場合、ユーザの作成時に -u/--uid オプションと -g/--gid オプションで ID を指定してください:\n\n```\n# useradd --system -u 850 -g 850 -s /usr/bin/nologin username\n```\n\n"
    },
    {
      "title": "ユーザーのログイン名やホームディレクトリを変更する",
      "level": 3,
      "content": "ユーザーのホームディレクトリを変更するには:\n\n```\n# usermod -d /my/new/home -m username\n```\n\nこのコマンドの -m オプションは、自動的に新しいホームディレクトリを作成し、旧ホームディエレクトリ内の内容をそこへ移動します。\n\n```\n# ln -s /my/new/home/ /my/old/home\n```\n\n/my/old/home の末尾に / が存在しないことを確認してください。\n\nユーザのログイン名を変更するには:\n\n```\n# usermod -l newname oldname\n```\n\nユーザー名の変更は usermod コマンドを使って正しく行えば安全かつ簡単です。ユーザーが同じ名前のグループに属している場合、groupmod コマンドで変更できます。\n\nまたは、/etc/passwd ファイルを直接編集する方法もあります。詳しくは #ユーザーデータベース を見てください。\n\nまた、以下のことにも気をつけてください:\n\n- sudo を使用する場合、/etc/sudoers を更新して新しいユーザー名を反映させてください (root で visudo コマンドを使用)。\n- 個人用の crontab は、/var/spool/cron 内のユーザーファイルを古い名前から新しい名前に変更し、crontab -e を開いて相対パスを変更してファイルのパーミッションも調整する必要があります。\n- ~/.wine/drive_c/users、~/.local/share/applications/wine/Programs などの中にある Wine の個人用フォルダ/ファイルのコンテンツは手動で名前を変更/編集する必要があります。\n- Enigmail など特定の Thunderbird アドオンは再インストールが必要かもしれません。\n- ホームディレクトリの絶対パス (つまり /home/oldname) を使っているファイル (デスクトップショートカット、シェルスクリプトなど) は、ホームディレクトリの名前の変更を反映させる必要があります。シェルスクリプトでこういう問題が起こらないようにするには、ホームディレクトリを指定するときに ~ や $HOME 変数を使いましょう。\n- また /etc/ の設定ファイルで絶対パスを使っている場合は忘れずに編集してください (Samba や CUPS など)。どのファイルを編集すればいいかわからないときは grep コマンドを使います: grep -r old_user *。\n\n"
    },
    {
      "title": "ユーザー管理の他の例",
      "level": 3,
      "content": "GECOS コメントにユーザ情報を入力するには (フルのユーザ名など)、以下を実行してください:\n\n```\n# chfn username\n```\n\n(この方法では chfn はインタラクティブモードで実行します)。\n\nあるいは、以下のように自由に GECOS コメントを設定することもできます:\n\n```\n# usermod -c \"Comment\" username\n```\n\nユーザーのパスワードを期限切れにして、次にログインした時に新しいパスワードを作るよう求めたいときは、次を実行してください:\n\n```\n# chage -d 0 username\n```\n\nuserdel コマンドでユーザアカウントを削除できます:\n\n```\n# userdel -r username\n```\n\nuserdel の -r オプションは、ユーザのホームディレクトリとメールスプールも削除します。\n\nユーザのログインシェルを変更するには:\n\n```\n# usermod -s /usr/bin/bash username\n```\n\n"
    },
    {
      "title": "ユーザーデータベース",
      "level": 2,
      "content": "ローカルユーザの情報はプレーンテキストの /etc/passwd ファイルに保存されます。このファイル内の各行は1つのユーザアカウントを表しており、7つのフィールドがコロンで区切られて記述されています。\n\n```\naccount:password:UID:GID:GECOS:directory:shell\n```\n\nそれぞれのフィールドの意味は以下のとおりです:\n\n- account はユーザ名です。このフィールドを空白にすることはできません。標準的な *NIX の命名規則が適用されます。\n- password はユーザのパスワードです。 警告: passwd ファイルは全ユーザが読むことができます。なので、パスワード (ハッシュ化されているものなど) をこのファイルに保存することは安全ではありません。代わりに、Arch Linux ではシャドウパスワードが使用されます。この場合、password フィールドにはプレースホルダー文字 (x) が代わりに記入され、アクセスが制限されている /etc/shadow ファイルにハッシュ化されたパスワードが保存されていることを示します。そのような理由により、パスワードの変更には必ず passwd コマンドを使用することが推奨されます。\n- UID はユーザ ID の数値です。Arch では、(サービスとは異なる) 一般ユーザの (root の後の) 最初のログイン名の UID はデフォルトで 1000 となります。その後のユーザの UID エントリは 1000 より大きい必要があります。\n- GID はユーザのプライマリグループ ID の数値です。GID の数値は /etc/group にリストアップされています。\n- GECOS はオプションのフィールドで、ユーザの情報を格納するために使用されます。通常、このフィールドには完全なユーザ名が含まれますが、このフィールドは finger などのサービスによって使用されたり、chfn コマンドによって管理されたりする可能性があります。このフィールドは任意で、空白のままにしておくこともできます。\n- directory は、$HOME 環境変数を設定するためにログインコマンドによって使用されます。独自のユーザを持ついくつかのサービスは / を使用しますが、通常ユーザは普通 /home 下のディレクトリを使用します。\n- shell はユーザのデフォルトコマンドシェルへのパスです。このフィールドはオプションで、デフォルトは /usr/bin/bash となります。\n\n例:\n\n```\narchie:x:1001:1003:Archie,some comment here,,:/home/archie:/usr/bin/bash\n```\n\nこの例の意味は次のとおりです: ユーザ は archie で、パスワードは /etc/shadow に保存されており、UID は 1001 で、プライマリグループは 1003。Archie は完全な名前で、このアカウントに関連付けられたコメントが記入されています。このユーザのホームディレクトリは /home/archie で、Bash を使用しています。\n\npwck を使うことで、ユーザデータベースの整合性を検証することができます。また、このコマンドはユーザのリストを GID によってソートします (比較の際に便利でしょう):\n\n```\n# pwck -s\n```\n\n"
    },
    {
      "title": "自動整合性チェック",
      "level": 2,
      "content": "pwck や grpck を自分で実行する代わりに、Systemd タイマー shadow.timer は shadow.service を毎日実行します (shadow.timer は shadow パッケージの一部であり、このパッケージのインストール時に自動で有効化されます)。shadow.service は pwck(8) と grpck(8) を実行してパスワードファイルとグループファイルの両方の整合性を検証します。\n\n不整合が報告された場合、グループは vigr(8) コマンドで、ユーザは vipw(8) コマンドで編集できます。これは、これらのコマンドがデータベースが編集されないようロックするという観点で、追加の保護を提供します。デフォルトのテキストエディタは vi ですが、EDITOR 環境変数を設定することで他のエディタを使用できます。\n\n"
    },
    {
      "title": "グループ管理",
      "level": 2,
      "content": "/etc/group は、システム上のグループを定義するファイルです (詳細は group(5) を見てください)。このファイルの仲間に gshadow というものもありますが、これはめったに使用されません。詳細は gshadow(5) を見てください。\n\ngroups コマンドでグループのメンバーを表示できます:\n\n```\n$ groups user\n```\n\nuser が省略された場合、現在のユーザが属しているグループの名前が表示されます。\n\nid コマンドは追加の詳細情報も出力します (ユーザの UID や関連付けられた GID など):\n\n```\n$ id user\n```\n\nシステム上の全てのグループを一覧するには:\n\n```\n$ cat /etc/group\n```\n\ngroupadd コマンドで新しいグループを作成できます:\n\n```\n# groupadd group\n```\n\nそしてユーザーをグループに追加するには gpasswd コマンドを使います (エラーについては FS#58262 を見てください):\n\n```\n# gpasswd -a user group\n```\n\nあるいは、usermod でユーザをグループに追加できます (additional_groups はコンマで区切られたリストに置き換えてください):\n\n```\n# usermod -aG additional_groups username\n```\n\ngroupmod コマンドで既存のグループを変更できます。例えば、old_group グループの名前を new_group に変更するには:\n\n```\n# groupmod -n new_group old_group\n```\n\n既存のグループを削除するには:\n\n```\n# groupdel group\n```\n\nグループからユーザを削除するには:\n\n```\n# gpasswd -d user group\n```\n\ngrpck コマンドを使用することでシステムのグループファイルの整合性を検証できます。\n\n"
    },
    {
      "title": "グループ一覧",
      "level": 2,
      "content": "このセクションでは filesystem パッケージに含まれている主要なグループの用途を説明します。他にもグループは存在し、パッケージがインストールされたときに適当な GID を使って作成されます。詳しくはグループに関連するソフトウェアのページを見てください。\n\n"
    },
    {
      "title": "ユーザーグループ",
      "level": 3,
      "content": "ワークステーション/デスクトップの非 root ユーザはしばしば、ハードウェア周辺機器にアクセスできるようにしたりシステム管理を楽にしたりするために、以下のグループのどれかに追加する必要があります:\n\nTable content:\nグループ | 影響を受けるファイル | 目的\nadm |  | 管理者グループ。一般的に、保護されたログに読み込みアクセスするために使用されます。このグループは journal ファイルへの完全な読み込みアクセス権を持ちます。\nftp | /srv/ftp/ | FTP サーバにより提供されているファイルへのアクセス。\ngames | /var/games | 一部のゲームソフトウェアへのアクセス。\nhttp | /srv/http/ | HTTP サーバによって提供されているファイルへのアクセス。\nlog |  | syslog-ng によって作成された /var/log/ にあるログファイルへのアクセス。\nrfkill | /dev/rfkill | ワイヤレスデバイスの電源状態の制御権 (rfkill によって使用されます)。\nsys |  | CUPS でのプリンタの管理権。\nsystemd-journal | /var/log/journal/* | systemd のログへの読み取り専用アクセスを提供します。adm や wheel の代わりとして使用されます [1]。このグループに属さない場合、ユーザによって生成されたメッセージのみが表示されます。\nuucp | /dev/ttyS[0-9]+, /dev/tts/[0-9]+, /dev/ttyUSB[0-9]+, /dev/ttyACM[0-9]+, /dev/rfcomm[0-9]+ | RS-232 シリアルポートや、それらに接続されているデバイス。\nwheel |  | 管理者グループ。一般的に、管理者アクションを実行する権限を与えるために使用されます。このグループは journal ファイルへの完全な読み取りアクセス権と、CUPS でプリンタを管理する権限を持ちます。また、sudo や su ユーティリティへのアクセス権を与えるためにも使用されます (どちらのユーティリティもデフォルトではこのグループを使用しません)。\n\n"
    },
    {
      "title": "システムグループ",
      "level": 3,
      "content": "以下のグループはシステムのために使用されます。これらのグループへのユーザの割り当ては、限られた目的においてのみ必要になります:\n\nTable content:\nグループ | 影響を受けるファイル | 目的\ndbus |  | dbus によって内部的に使用されます。\nkmem | /dev/port, /dev/mem, /dev/kmem | \nlocate | /usr/bin/locate, /var/lib/locate, /var/lib/mlocate, /var/lib/slocate | Locate を見てください。\nlp | /dev/lp[0-9]*, /dev/parport[0-9]* | パラレルポートのデバイスへのアクセス (プリンタなど)。\nmail | /usr/bin/mail | \nnobody |  | 非特権グループ。\nproc | /proc/pid/ | proc ファイルシステムの hidepid= マウントオプションによって制限されているプロセス情報の取得を許可されているグループ。このグループは gid= マウントオプションによって明示的に設定されなければなりません。\nroot | /* | 完全なシステムの管理と制御 (root, admin)。\nsmmsp |  | sendmail グループ。\ntty | /dev/tty, /dev/vcc, /dev/vc, /dev/ptmx | \nutmp | /run/utmp, /var/log/btmp, /var/log/wtmp | \n\n"
    },
    {
      "title": "systemd 以前のグループ",
      "level": 3,
      "content": "Arch が systemd に移行する前は、デバイスにアクセスできるようにするためにユーザを以下のグループに手動で追加する必要がありました。この方法は非推奨となっており、現在は udev がデバイスに uaccess タグを付け、現在どのセッションがアクティブであるかに応じて logind が ACL を使って動的にユーザに権限を割り当てています。この仕組みを機能させるにはセッションが破壊されないようにしなければなりません (一般的なトラブルシューティング#セッションのパーミッションを参照)。\n\nグループによってはユーザーを追加しなくてはいけない例外も存在します: 例えば、ログインしていない状態でユーザーからデバイスにアクセスしたい場合など。ただし、グループにユーザーを追加すると機能が破壊されることもあるので注意してください (例えば audio グループを使用するとユーザーの高速切り替えが無効化されソフトウェアミキシングができなくなります)。\n\nTable content:\nグループ | 影響を受けるファイル | 目的\naudio | /dev/audio, /dev/snd/*, /dev/rtc0 | 全てのセッションでのサウンドハードウェアへの直接アクセス。リモートセッションで ALSA と OSS を動作させるために未だに必要になりますが (ALSA#ユーザー権限 を参照)、そうするつもりでない場合にはこのグループを使用することは推奨されません。他の特定のディストリビューションとは異なり、このグループはリアルタイム権限を与えるために使用されていません。\ndisk | /dev/sd[a-zA-Z]*[1-9]* | optical、floppy、storage など他のグループによる影響を受けないブロックデバイスへのアクセス。\nfloppy | /dev/fd[0-9]* | フロッピードライブへのアクセス。\ninput | /dev/input/event[0-9]*, /dev/input/mouse[0-9]* | 入力デバイスへのアクセス。systemd 215 で導入されました [2]。\nkvm | /dev/kvm | KVM を使用する仮想マシンへのアクセス。\noptical | /dev/sr[0-9], /dev/sg[0-9] | CD や DVD ドライブなどの光学デバイスへのアクセス。\nscanner | /var/lock/sane | スキャナーハードウェアへのアクセス。\nstorage | /dev/st[0-9]*[lma]*, /dev/nst[0-9]*[lma]* | USB ハードドライブ、フラッシュ/ジャンプドライブ、MP3 プレイヤーなどのリームーバブルドライブへのアクセス権を得るために使用されます。ユーザがストレージデバイスをマウントできるようにします。[3] 現在では、カスタムの udev ルールが存在しない場合にテープにダイレクトアクセスするためだけに使用されます [4][5][6][7]。 また、udisks/udisksctl を通して一部のデバイスを操作するために必要です。\nvideo | /dev/fb/0, /dev/misc/agpgart | ビデオキャプチャデバイス、2D/3D ハードウェアアクセラレーション、フレームバッファへのアクセス (Xは、このグループに属さなくとも使用可能です)。\n\n現在では、カスタムの udev ルールが存在しない場合にテープにダイレクトアクセスするためだけに使用されます [4][5][6][7]。\n\nまた、udisks/udisksctl を通して一部のデバイスを操作するために必要です。\n\n"
    },
    {
      "title": "使われなくなったグループ",
      "level": 3,
      "content": "以下のグループは現在利用されていません:\n\nTable content:\nグループ | 影響を受けるファイル | 目的\nbin | なし | 歴史的に存在していました。\ndaemon |  | \nlock |  | ロックファイルのアクセスのために使用されました。gnokiiAUR などがこれを必要とします。\nmem |  | \nnetwork |  | デフォルトで使用されません。NetworkManager を使用する権限を与える場合などに使えます (NetworkManager#PolicyKit のパーミッションをセットアップするを参照)。\npower |  | \nuuidd |  | \nusers |  | (/etc/login.defs で USERGROUPS_ENAB no を設定したり、useradd の -N/--no-user-group オプションを使用したりしてユーザを作成する場合など) ユーザープライベートグループを使用しない場合 (通常、推奨されません) のユーザのプライマリグループです。\n\n"
    },
    {
      "title": "これらのデータベースに関連した他のツール",
      "level": 2,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: Arch Linux は本当に vipw -s や vigr -s よりも chage を推奨しているのか? (議論: トーク:ユーザーとグループ#)\n\ngetent(1) を使用することで特定のレコードを読み出すことができます。\n\n```\n$ getent group tty\n```\n\n#ユーザーデータベースで警告されているように、このようなデータベースを変更する際には、passwd や chfn といった特定のユーティリティを使うほうが良いです。それでもやはり、直接編集するほうが良い場合もあります。そのような場合のために vipw や vigr が提供されています。これらのツールはデータベースをロックして同時に編集されるのを防ぐので、一般的なテキストエディタよりもこれらの専用のエディターを使うことが強く推奨されます。また、これらのツールは無効なエントリや構文エラーを防止します。Arch Linux ではシャドウデータベースの変更するために util-linux の vipw -s や vigr -s よりも特定のツール (chage など) の使用を推奨していることに注意してください。FS#31414 も参照してください。\n\n"
    }
  ]
}