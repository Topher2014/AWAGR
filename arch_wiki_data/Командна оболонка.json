{
  "title": "Командна оболонка",
  "url": "https://wiki.archlinux.org/title/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%BD%D0%B0_%D0%BE%D0%B1%D0%BE%D0%BB%D0%BE%D0%BD%D0%BA%D0%B0",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Повʼязані статті\n\n- dotfiles\n- Core utilities\n\nКомандна оболонка Unix (англ. Unix shell, часто просто «шелл» або «sh») — інтерпретатор команд, що використовується в операційних системах сімейства Unix, який дозволяє користувачеві вводити команди поодинці або запускати скрипти, що складаються з набору команд. Під терміном shell зазвичай розуміються оболонки, сумісні з POSIX, що ведуть своє походження від Bourne shell (шелл Борна), який з’явився в Unix Version 7.\n\n"
    },
    {
      "title": "Список оболонок",
      "level": 2,
      "content": "Оболонки, більш-менш сумісні з POSIX, перераховані в розділі #POSIX-сумісні, а оболонки з іншим синтаксисом - у розділі #Альтернативні оболонки.\n\n"
    },
    {
      "title": "POSIX-сумісні",
      "level": 3,
      "content": "На ці оболонки може вести символічне посилання /usr/bin/sh. Коли Bash, mkshAUR} і zsh запускаються через виконуваний файл з іменем sh, вони автоматично стають більш сумісними з POSIX.\n\n- Bash — розширює оболонку Bourne shell, додаючи історію та автодоповнення, індексовані та асоціативні масиви, цілочисельну арифметику, підстановку процесів, here strings, регулярні вирази та розширення дужок.\n\n- Dash — Потомок NetBSD-версії Almquist SHell (ash). Швидка POSIX-сумісна оболонка, яка прагне бути настільки маленькою, наскільки це можливо.\n\n- Korn shell (ksh) — Мова KornShell - це повна, потужна мова програмування високого рівня для написання додатків, найчастіше легша і швидша, ніж на інших мовах високого рівня. Це робить її особливо придатною для прототипування. ksh поєднує в собі найкращі риси оболонки Bourne і C, плюс безліч самостійних можливостей. Таким чином Ksh може зробити багато чого, щоб підвищити продуктивність і якість вашої роботи під час взаємодії з системою і в програмуванні. Програми на ksh легше писати, вони коротші та читабельніші, ніж програми, написані мовою нижчого рівня, такою як C.\n\n- nsh — Командна оболонка, схожа на fish, але POSIX-сумісна.\n\n- Oil Shell (OSH) — Bash-сумісна оболонка командного рядка UNIX. OSH може бути запущена на більшості UNIX-подібних операційних систем, у тому числі GNU/Linux. Вона написана мовою Python (v2.7), але поставляється у вигляді нативного виконуваного файлу. Діалект Bash, розпізнаваний OSH, називається мовою OSH.\n\n- Yash — Yet another shell, POSIX-сумісна оболонка командного рядка, написана мовою C99 (ISO/IEC 9899:1999). Yash прагне стати найбільшою POSIX-сумісною оболонкою у світі, підтримуючи при цьому функції для інтерактивного використання і для написання скриптів.\n\n- Zsh — Оболонка, призначена для інтерактивного використання, хоча це також потужна скриптова мова. Багато з корисних особливостей Bash, ksh і tcsh були включені в Zsh; було додано багато оригінальних рис. У вступі перераховані деякі з унікальних особливостей Zsh.\n\n"
    },
    {
      "title": "Альтернативні оболонки",
      "level": 3,
      "content": "- C shell (tcsh) — Командний інтерпретатор, що використовується як інтерактивна оболонка входу в систему та командний процесор скриптів. Він має редактор командного рядка, програмоване автодоповнення слів, перевірку орфографії, механізм історії, керування завданнями та C-подібний синтаксис.\n\n- Closh — Bash-подібна командна оболонка на Clojure.\n\n- Elvish — Сучасна та виразна оболонка, яка може переносити внутрішні структуровані значення через конвеєри. Ця можливість дозволяє уникнути великої кількості складного коду для обробки тексту. Це виразна мова програмування з такими можливостями, як винятки, простори імен та анонімні функції. Також є потужний readline, який перевіряє синтаксис при наборі тексту, і підсвічування синтаксису за замовчуванням.\n\n- fish — Розумна і зручна командна оболонка. Fish робить повнокольорове підсвічування синтаксису командного рядка, а також підсвічування і автодоповнення команд та їхніх аргументів, наявних файлів та історії. Підтримується функція завершення в міру введення для історії та команд. Fish здатний аналізувати man-сторінки системи для визначення допустимих аргументів команд, що дає йому змогу підсвічувати і доповнювати команди. Легкий перегляд останніх команд може бути зроблений за допомогою Alt+Up. Демон Fish (fishd) полегшує синхронізацію історії всіх екземплярів fish, а також універсальних і постійних змінних оточення. Крім того, fish має простий синтаксис програмування та потік управління (подібно до ruby). Для отримання додаткової інформації читайте документацію.\n\n- ion — Сучасна системна оболонка з простим, але потужним синтаксисом. Вона повністю написана на Rust, що значно підвищує загальну якість і безпеку оболонки, усуваючи можливість появи вразливостей на кшталт ShellShock і спрощуючи розробку. Вона також забезпечує рівень продуктивності, що перевершує Dash, при використанні можливостей Ion. Хоча він розробляється поряд із RedoxOS і насамперед для неї, він цілком придатний і для інших *nix-платформ. Для отримання більш докладної інформації дивіться керівництво.\n\n- Murex — Командна оболонка з розширеними можливостями та поліпшеним користувацьким інтерфейсом.\n\n- nushell — Nu черпає натхнення у функціональних мовах програмування та сучасних інструментах командного рядка. Замість того, щоб розглядати файли і сервіси як необроблені потоки тексту, Nu розглядає кожне введення як щось, що має структуру.\n\n- Oh — Unix-оболонка, написана на Go. Це оболонка в дусі Unix, але відрізняється в деталях. Oh розширює можливості мови програмування оболонки без шкоди для інтерактивних функцій оболонки.\n\n- PowerShell — Об'єктно-орієнтована мова програмування та інтерактивна оболонка командного рядка, спочатку написана для Windows. Пізніше PowerShell був відкритий і портований на macOS і Linux.\n\n- rc — Командний інтерпретатор для Plan 9, що надає можливості, схожі на Bourne shell, з невеликими доповненнями та менш своєрідним синтаксисом.\n\n- xonsh — Оболонка на Python з додатковими примітивами, до яких ви звикли з Bash і IPython.\n\n"
    },
    {
      "title": "Вибір усталеної оболонки",
      "level": 2,
      "content": "Після встановлення будь якої з раніше перерахованих оболонок ви можете запустити обрану оболонку всередині поточної оболонки,запустивши виконуваний файл. Якщо ви хочете використовувати тільки що встановлену оболонку, потрібно замінити стандартну оболону.\n\nОгляньте встановлені оболонки:\n\n```\n$ chsh -l\n```\n\nТа оберіть одну з них, що використовуватиметься для вашого користувача:\n\n```\n$ chsh -s повний-шлях-до-оболонки\n```\n\n```\n$ homectl update --shell=повний-шлях-до-оболонки користувач\n```\n\nДе повний-шлях-до-оболонки — шлях який вивела команда chsh -l.\n\nТепер, якщо ви вийдете і увійдете знову в систему, вас зустрічатиме обрана оболонка.\n\n"
    },
    {
      "title": "Видалення оболонки",
      "level": 2,
      "content": "Змініть усталену оболонку на іншу перед її видаленням. В якості альтернативи змініть базу даних користувачів, зробіть це для кожного користувача у якого обрана оболонка використовується в якості оболонки входу (також варто перевірити root користувача). Після завершення пакет можна видаляти.\n\n"
    },
    {
      "title": "Оболонка входу",
      "level": 2,
      "content": "Оболонка входу (login shell) - це режим запуску оболонки, в якому вона читає файли, призначені для одноразової ініціалізації, такі як загальносистемний /etc/profile або користувацький ~/.profile або інші специфічні для оболонки файли. Ці файли задають початкове оточення, яке успадковується всіма іншими процесами, запущеними з оболонки (зокрема, іншими оболонками, не пов'язаними із входом у систему, або графічними додатками). Отже, вони читаються тільки один раз на початку сеансу, тобто, наприклад, коли користувач входить у консоль або через SSH, змінює користувача за допомогою sudo або su з параметром --login або коли користувач вручну запускає оболонку входу (наприклад, командою bash --login}).\n\nОгляд різних файлів ініціалізації дивіться в розділі #Файли налаштувань і за посиланнями в ньому. Для отримання додаткової інформації про оболонку входу дивіться також Difference between Login Shell and Non-Login Shell? і Why a «login» shell over a «non-login» shell? на Stack Exchange.\n\n"
    },
    {
      "title": "Файли налаштувань",
      "level": 2,
      "content": "Щоб зробити автозапуск програм у консолі або при вході в систему, можна використовувати файли/каталоги, які оболонка виконує під час запуску. Дивіться документацію до вашої оболонки або відповідну статтю в ArchWiki: наприклад, Bash (Українська) #Конфігураційні файли або Zsh #Startup/Shutdown files.\n\n"
    },
    {
      "title": "/etc/profile",
      "level": 3,
      "content": "Під час входу в систему всі Bourne-сумісні оболонки виконують source файлу /etc/profile, який, своєю чергою, виконує source всіх читабельних файлів *.sh в каталозі /etc/profile.d/: у цих скриптах не потрібно вказувати директиву інтерпретатора (шебанг) і їх не потрібно робити виконуваними. Вони використовуються для налаштування оточення і визначення параметрів, специфічних для додатків.\n\n"
    },
    {
      "title": "Стандартизація",
      "level": 3,
      "content": "Можна змусити файли налаштувань (деяких) оболонок слідувати одній і тій самій угоді про іменування, а також підтримувати деякі загальні налаштування між оболонками.\n\nДивіться статтю про це і відповідний репозиторій. Дивіться також xsh.\n\n"
    },
    {
      "title": "Введення та виведення",
      "level": 2,
      "content": "Дивіться також GregsWiki і I/O Redirection.\n\n- При перенаправленні виводу в файл важливо мати на увазі, що файл очищається (truncate) перед виконанням команди. Якщо ви спробуєте зробити щось подібне: $ команда файл > файл то це не спрацює, а вміст файлу буде втрачено. Хоча в деяких командах (наприклад sed) є опція для редагування файлів на місці, багато команд такої опції не мають. У такому разі можна використовувати команду sponge(1) з пакета moreutils.\n- Оскільки cat не є вбудованою в оболонку командою, може бути краще використовувати замість неї переспрямування, наприклад, у скриптах, або якщо вам важлива продуктивність. Фактично, < файл робить те ж саме, що і cat файл.\n- POSIX-сумісні оболонки підтримують Here Documents: $ cat << EOF раз два три EOF\n- Конвеєри (труби, pipelines) за замовчуванням працюють зі стандартним виводом (stdout). Щоб працювати зі стандартним виведенням помилок (stderr(3)), можна переспрямувати stderr у stdout за допомогою конструкції вигляду команда 2>&1 | інша-команда, або, в Bash 4, команда |& інша-команда.\n- Пам'ятайте, що багато основних утиліт GNU приймають файли як аргументи, тож, наприклад, замість grep паттерн < файл можна написати grep паттерн файл .\n\n```\n$ команда файл > файл\n```\n\n```\n$ cat << EOF\nраз\nдва\nтри\nEOF\n```\n\n"
    },
    {
      "title": "Дивіться також",
      "level": 2,
      "content": "- Еволюція оболонок у Linux на IBM developerWorks\n- terminal.sexy - Конструктор колірних схем терміналу\n- Hyperpolyglot - Порівняння синтаксису різних оболонок\n- UNIX Power Tools - Загальне використання інструментів командної лінії\n- commandlinefu.com - Обмін фрагментами командного рядка\n- List of applications/Utilities#Terminal emulators\n\n"
    }
  ]
}