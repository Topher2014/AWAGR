{
  "title": "Systemd (Français)/User (Français)",
  "url": "https://wiki.archlinux.org/title/Systemd_(Fran%C3%A7ais)/User_(Fran%C3%A7ais)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- systemd (Français)\n- Getty (Français)#Connexion automatique à la console\n- Xinit (Français)#Démarrage automatique de X à la connexion\n\nSystemd offre la possibilité de gérer des services sous le contrôle de l'utilisateur en lui permettant de démarrer, arrêter, activer ou désactiver une unité utilisateur. Cette option est pratique pour les daemons et autres services qui ne sont généralement exécutés que pour un seul utilisateur, comme mpd, ou pour effectuer des tâches automatisées comme la récupération du courrier électronique.\n\n"
    },
    {
      "title": "Fonctionnement",
      "level": 2,
      "content": "Selon la configuration par défaut dans /etc/pam.d/system-login, le module pam_systemd lance automatiquement une instance systemd --user lorsque l'utilisateur se connecte pour la première fois. Ce processus survivra tant qu'il y aura une session pour cet utilisateur, et sera tué dès que la dernière session de l'utilisateur sera fermée. Lorsque #Démarrage automatique des instances utilisateur systemd est activé, l'instance est démarrée au démarrage et ne sera pas tuée. L'instance utilisateur systemd est responsable de la gestion des services utilisateurs, qui peuvent être utilisés pour exécuter des daemons ou des tâches automatisées, avec tous les avantages de systemd, tels que l'activation des sockets, les timers, le système de dépendances ou le contrôle strict des processus via les cgroups.\n\nDe la même manière que les unités système, les unités utilisateur sont situées dans les répertoires suivants (classés par ordre de préséance ascendante) :\n\n- /usr/lib/systemd/user/ où appartiennent les unités fournies par les paquets installés.\n- ~/.local/share/systemd/user/ où appartiennent les unités des paquets qui ont été installés dans le répertoire personnel.\n- /etc/systemd/user/ où sont placées les unités des utilisateurs du système par l'administrateur système.\n- ~/.config/systemd/user/ où l'utilisateur place ses propres unités.\n\nLorsqu'une instance utilisateur de systemd démarre, elle active la cible par utilisateur default.target. Les autres unités peuvent être contrôlées manuellement avec systemctl --user. Consultez systemd.special(7) § UNITS MANAGED BY THE USER SERVICE MANAGER.\n\n- Sachez que l'instance systemd --user est un processus par utilisateur, et non par session. La raison en est que la plupart des ressources gérées par les services utilisateur, comme les sockets ou les fichiers d'état, seront par utilisateur (dans le répertoire personnel de l'utilisateur) et non par session. Cela signifie que tous les services utilisateur s'exécutent en dehors d'une session. Par conséquent, les programmes qui doivent être exécutés à l'intérieur d'une session seront probablement interrompus dans les services utilisateur. La façon dont systemd gère les sessions utilisateur est en pleine évolution. Consultez [1] et [2] pour obtenir des indications sur l'avancement.\n- systemd --user s'exécute comme un processus distinct du processus systemd --system. Les unités de l'utilisateur ne peuvent pas référencer ou dépendre des unités du système ou des unités d'autres utilisateurs.\n\n"
    },
    {
      "title": "Configuration de base",
      "level": 2,
      "content": "Toutes les unités de l'utilisateur seront placées dans ~/.config/systemd/user/. Si vous voulez démarrer les unités à la première connexion, exécutez systemctl --user enable unit pour toute unité que vous voulez démarrer automatiquement.\n\n"
    },
    {
      "title": "Variables d'environnement",
      "level": 3,
      "content": "L'instance utilisateur de systemd n'hérite d'aucune des variables d'environnement définies dans des endroits comme .bashrc, etc. Il existe plusieurs façons de définir les variables d'environnement pour l'instance utilisateur de systemd :\n\n- Pour les utilisateurs ayant un répertoire $HOME, créez un fichier .conf dans le répertoire ~/.config/environment.d/ avec des lignes de la forme NAME=VAL. Affecte uniquement l'unité utilisateur de cet utilisateur. Consultez environment.d(5) pour plus d'informations.\n- Utiliser l'option DefaultEnvironment dans le fichier /etc/systemd/user.conf. Affecte toutes les unités utilisateur.\n- Ajouter un fichier de configuration de dépôt dans /etc/systemd/system/user@.service.d/. Affecte toutes les unités utilisateur ; consultez #Exemple de service.\n- A tout moment, utilisez systemctl --user set-environment ou systemctl --user import-environment. Affecte toutes les unités utilisateur démarrées après la définition des variables d'environnement, mais pas les unités qui étaient déjà en cours d'exécution.\n- Utiliser la commande dbus-update-activation-environment --systemd --all fournie par dbus. A le même effet que systemctl --user import-environment, mais affecte également la session D-Bus. Vous pouvez ajouter ceci à la fin de votre fichier d'initialisation du shell.\n- Pour les variables d'environnement \"globales\" pour l'environnement de l'utilisateur, vous pouvez utiliser les répertoires environment.d qui sont analysés par certains générateurs. Consultez environment.d(5) et systemd.generator(7) pour plus d'informations.\n- Vous pouvez également écrire un script systemd.environment-generator(7) qui peut produire des variables d'environnement qui varient d'un utilisateur à l'autre, c'est probablement la meilleure façon si vous avez besoin d'environnements par utilisateur (c'est le cas pour XDG_RUNTIME_DIR, DBUS_SESSION_BUS_ADDRESS, etc).\n\nUne variable que vous pouvez vouloir définir est PATH.\n\nAprès la configuration, la commande systemctl --user show-environment peut être utilisée pour vérifier que les valeurs sont correctes.\n\n"
    },
    {
      "title": "Exemple de service",
      "level": 4,
      "content": "Créez le répertoire «drop-in» /etc/systemd/system/user@.service.d/ et créez à l'intérieur un fichier ayant l'extension .conf (par exemple local.conf) :\n\n```\n/etc/systemd/system/user@.service.d/local.conf\n```\n\n```\n[Service]\nEnvironment=\"PATH=/usr/lib/ccache/bin:/usr/local/bin:/usr/bin:/bin\"\nEnvironment=\"EDITOR=nano -c\"\nEnvironment=\"BROWSER=firefox\"\nEnvironment=\"NO_AT_BRIDGE=1\"\n```\n\n"
    },
    {
      "title": "DISPLAY et XAUTHORITY",
      "level": 4,
      "content": "DISPLAY est utilisé par toute application X pour savoir quel affichage utiliser et XAUTHORITY pour fournir un chemin vers le fichier .Xauthority de l'utilisateur et donc le cookie nécessaire pour accéder au serveur X. Si vous prévoyez de lancer des applications X à partir d'unités systemd, ces variables doivent être définies. Systemd fournit un script dans /etc/X11/xinit/xinitrc.d/50-systemd-user.sh pour importer ces variables dans la session de l'utilisateur systemd au lancement de l'application. [3] Donc, à moins que vous ne démarriez X d'une manière non standard, les services utilisateurs devraient être conscients des variables DISPLAY et XAUTHORITY.\n\n"
    },
    {
      "title": "PATH",
      "level": 4,
      "content": "Si vous personnalisez votre PATH et prévoyez de lancer des applications qui l'utilisent à partir d'unités systemd, vous devez vous assurer que le PATH modifié est défini dans l'environnement systemd. En supposant que vous avez défini votre PATH dans .bash_profile, la meilleure façon de faire connaître à systemd votre PATH modifié est d'ajouter ce qui suit à .bash_profile après la définition de la variable PATH :\n\n```\n~/.bash_profile\n```\n\n```\nsystemctl --user import-environnement PATH\n```\n\n- Cela n'affectera pas les services systemd démarrés avant l'importation du PATH.\n- systemd ne regarde pas le PATH défini lorsqu'il résout lui-même les binaires sans chemin absolus.\n\n"
    },
    {
      "title": "pam_env",
      "level": 4,
      "content": "Les variables d'environnement peuvent être rendues disponibles par l'utilisation du module pam_env.so. Consultez Environment variables#Using pam_env pour les détails de configuration.\n\n"
    },
    {
      "title": "Démarrage automatique des instances utilisateur systemd",
      "level": 3,
      "content": "L'instance utilisateur systemd est démarrée après la première connexion d'un utilisateur et tuée après la fermeture de la dernière session de l'utilisateur. Parfois, il peut être utile de la lancer juste après le démarrage, et de maintenir l'instance utilisateur systemd en cours d'exécution après la fermeture de la dernière session, par exemple pour avoir un processus utilisateur en cours d'exécution sans aucune session ouverte. Lingering est utilisé à cet effet. Utilisez la commande suivante pour activer le lingering pour un utilisateur spécifique :\n\n```\n# loginctl enable-linger username\n```\n\nNote: **pas** \n\n"
    },
    {
      "title": "Écrire des unités utilisateur",
      "level": 2,
      "content": "Consultez Systemd (Français)#Écrire des unités pour des informations générales sur l'écriture des fichiers d'unités de systemd.\n\n"
    },
    {
      "title": "Exemple",
      "level": 3,
      "content": "Voici un exemple d'une version utilisateur du service mpd :\n\n```\n~/.config/systemd/user/mpd.service\n```\n\n```\n[Unit]\nDescription=Music Player Daemon\n\n[Service]\nExecStart=/usr/bin/mpd --no-daemon\n\n[Install]\nWantedBy=default.target\n```\n\n"
    },
    {
      "title": "Exemple avec variables",
      "level": 3,
      "content": "Ci-dessous, le service utilisateur de foldingathomeAUR, qui tient compte par une variable des répertoires personnels où Folding@home peut trouver certains fichiers :\n\n```\n~/.config/systemd/user/foldingathome-user.service\n```\n\n```\n[Unit]\nDescription=Folding@home distributed computing client\nAfter=network.target\n\n[Service]\nType=simple\nWorkingDirectory=%h/.config/fah\nExecStart=/usr/bin/FAHClient\nCPUSchedulingPolicy=idle\nIOSchedulingClass=3\n\n[Install]\nWantedBy=default.target\n```\n\nComme détaillé dans systemd.unit(5) § SPECIFIERS, la variable %h est remplacée par le répertoire personnel de l'utilisateur qui exécute le service. Il existe d'autres variables qui peuvent être prises en compte dans les pages de manuel de systemd.\n\n"
    },
    {
      "title": "Lecture du journal",
      "level": 3,
      "content": "Le journal de l'utilisateur peut être lu en utilisant la commande analogue :\n\n```\n$ journalctl --user\n```\n\nPour spécifier une unité, on peut utiliser\n\n```\n$ journalctl --user-unit monunité.service\n```\n\nOu, de manière équivalente\n\n```\n$ journalctl --user -u monunité.service\n```\n\n"
    },
    {
      "title": "Fichiers temporaires",
      "level": 2,
      "content": "systemd-tmpfiles permet aux utilisateurs de gérer des fichiers et des répertoires volatils et temporaires personnalisés, tout comme pour le système dans son ensemble (consultez Systemd (Français)#systemd-tmpfiles - fichiers temporaires). Les fichiers de configuration spécifiques à l'utilisateur sont lus dans ~/.config/user-tmpfiles.d/ et ~/.local/share/user-tmpfiles.d/, dans cet ordre. Pour que cette fonctionnalité puisse être utilisée, il est nécessaire d'activer les unités utilisateur systemd nécessaires pour votre utilisateur :\n\n```\n$ systemctl --user enable systemd-tmpfiles-setup.service systemd-tmpfiles-clean.timer\n```\n\nLa syntaxe des fichiers de configuration est la même que celle utilisée dans tout le système. Consultez les pages de manuel systemd-tmpfiles(8) et tmpfiles.d(5) pour plus de détails.\n\n"
    },
    {
      "title": "Xorg et systemd",
      "level": 2,
      "content": "Il y a plusieurs façons d'exécuter xorg dans les unités systemd. Ci-dessous, il y a deux options, soit en démarrant une nouvelle session utilisateur avec un processus xorg, soit en lançant xorg depuis un service utilisateur systemd.\n\n"
    },
    {
      "title": "Connexion automatique à Xorg sans gestionnaire d'affichage",
      "level": 3,
      "content": "Cette option lancera une unité système qui démarrera une session utilisateur avec un serveur xorg, puis exécutera les ~/.xinitrc habituels pour lancer le gestionnaire de fenêtres, etc. Vous devez avoir installé xlogin-gitAUR. Configurez votre xinitrc comme indiqué dans la section Xinit (Français)#xinitrc.\n\nLa session utilisera son propre daemon dbus, mais divers utilitaires systemd se connecteront automatiquement à l'instance dbus.service. Enfin, activez le service xlogin@username pour une connexion automatique au démarrage. La session utilisateur vit entièrement à l'intérieur d'un scope systemd et tout ce qui se trouve dans la session utilisateur devrait fonctionner parfaitement.\n\n"
    },
    {
      "title": "Xorg comme service utilisateur systemd",
      "level": 3,
      "content": "Alternativement, xorg peut être exécuté à partir d'un service utilisateur systemd. C'est une bonne chose puisque d'autres unités liées à X peuvent être rendues dépendantes de xorg, etc, mais d'un autre côté, cela a quelques inconvénients expliqués ci-dessous.\n\nxorg-server fournit une intégration avec systemd de deux manières :\n\n- Il peut être exécuté sans privilège, déléguant la gestion des périphériques à logind (consultez les commits de Hans de Goede autour de ce commit).\n- Peut être transformé en un service activé par socket (consultez ce commit).\n\nMalheureusement, pour pouvoir exécuter xorg en mode non privilégié, il doit être exécuté dans une session. Donc, actuellement, le handicap de l'exécution de xorg en tant que service utilisateur est qu'il doit être exécuté avec les privilèges root (comme avant la 1.16), et ne peut pas profiter du mode non privilégié introduit dans la 1.16.\n\nVoici comment lancer xorg à partir d'un service utilisateur :\n\n1. Faites tourner xorg avec les privilèges root pour n'importe quel utilisateur, en éditant /etc/X11/Xwrapper.config. Ceci s'appuie sur Xorg (Français)#Xorg en root en ajoutant la stipulation que cela n'a pas besoin d'être fait depuis une console physique. C'est-à-dire que le défaut de allowed_user de console est remplacé par anybody ; voir Xorg.wrap(1).\n\n```\n/etc/X11/Xwrapper.config\n```\n\n```\nallowed_users=anybody\nneeds_root_rights=yes\n```\n\n2. Ajoutez les unités suivantes à ~/.config/systemd/user\n\n```\n~/.config/systemd/user/xorg@.socket\n```\n\n```\n[Unit]\nDescription=Socket for xorg at display %i\n\n[Socket]\nListenStream=/tmp/.X11-unix/X%i\n```\n\n```\n~/.config/systemd/user/xorg@.service\n```\n\n```\n[Unit]\nDescription=Xorg server at display %i\n\nRequires=xorg@%i.socket\nAfter=xorg@%i.socket\n\n[Service]\nType=simple\nSuccessExitStatus=0 1\n\nExecStart=/usr/bin/Xorg :%i -nolisten tcp -noreset -verbose 2 \"vt${XDG_VTNR}\"\n```\n\noù ${XDG_VTNR} est le terminal virtuel où xorg sera lancé, soit codé en dur dans l'unité de service, soit défini dans l'environnement systemd avec\n\n```\n$ systemctl --user set-environment XDG_VTNR=1\n```\n\n3. Assurez-vous de configurer la variable d'environnement DISPLAY comme expliqué ci-dessus.\n\n4. Ensuite, pour activer l'activation de la socket pour xorg sur l'affichage 0 et le tty 2, il faut faire :\n\n```\n$ systemctl --user set-environment XDG_VTNR=2 # Pour que xorg@.service sache quel vt utiliser\n$ systemctl --user start xorg@0.socket # Commence à écouter sur le socket pour l'affichage 0\n```\n\nMaintenant, l'exécution de toute application X lancera xorg sur le terminal virtuel 2 automatiquement.\n\nLa variable d'environnement XDG_VTNR peut être définie dans l'environnement systemd à partir de .bash_profile, et l'on peut alors démarrer n'importe quelle application X, y compris un gestionnaire de fenêtres, en tant qu'unité systemd qui dépend de xorg@0.socket.\n\n"
    },
    {
      "title": "Gestionnaire de fenêtres",
      "level": 3,
      "content": "Pour exécuter un gestionnaire de fenêtres en tant que service systemd, vous devez d'abord exécuter #Xorg comme service utilisateur systemd. Dans ce qui suit, nous utiliserons awesome comme exemple :\n\n```\n~/.config/systemd/user/awesome.service\n```\n\n```\n[Unit]\nDescription=Awesome window manager\nAfter=xorg.target\nRequires=xorg.target\n\n[Service]\nExecStart=/usr/bin/awesome\nRestart=always\nRestartSec=10\n \n[Install]\nWantedBy=wm.target\n```\n\n"
    },
    {
      "title": "Multiplexeur de terminal persistant",
      "level": 3,
      "content": "Plutôt que de vous connecter par défaut à une session de gestionnaire de fenêtres pour votre session utilisateur, vous pouvez souhaiter exécuter automatiquement un multiplexeur de terminal (tel que screen ou tmux) en arrière-plan.\n\nCréez ce qui suit :\n\n```\n~/.config/systemd/user/multiplexer.target\n```\n\n```\n[Unit]\nDescription=Terminal multiplexer\nDocumentation=info:screen man:screen(1) man:tmux(1)\nAfter=cruft.target\nWants=cruft.target\n\n[Install]\nAlias=default.target\n```\n\nSéparer le login du login X n'est probablement utile que pour ceux qui démarrent sur un TTY au lieu d'un gestionnaire d'affichage (dans ce cas, vous pouvez simplement regrouper tout ce que vous démarrez dans mystuff.target).\n\nLa dépendance cruft.target, comme la mystuff.target ci-dessus, permet de démarrer tout ce qui doit être exécuté avant le démarrage du multiplexeur (ou que vous voulez démarrer au démarrage sans tenir compte du timing), comme une session du daemon GnuPG.\n\nVous devez ensuite créer un service pour votre session multiplexeur. Voici un exemple de service, utilisant tmux comme exemple et utilisant une session gpg-agent qui écrit ses informations dans /tmp/gpg-agent-info. Cette session d'exemple, lorsque vous démarrez X, sera également capable d'exécuter des programmes X, puisque $DISPLAY est défini :\n\n```\n~/.config/systemd/user/tmux.service\n```\n\n```\n[Unit]\nDescription=tmux: A terminal multiplexer \nDocumentation=man:tmux(1)\nAfter=gpg-agent.service\nWants=gpg-agent.service\n\n[Service]\nType=forking\nExecStart=/usr/bin/tmux start\nExecStop=/usr/bin/tmux kill-server\nEnvironment=DISPLAY=:0\nEnvironmentFile=/tmp/gpg-agent-info\n\n[Install]\nWantedBy=multiplexer.target\n```\n\nActivez tmux.service, multiplexer.target et tous les services que vous avez créés pour être exécutés par cruft.target, démarrez user@.service comme d'habitude et vous devriez avoir terminé.\n\n"
    },
    {
      "title": "Tuer les processus utilisateur lors de la déconnexion",
      "level": 2,
      "content": "Arch Linux construit le paquet systemd avec --without-kill-user-processes, définissant KillUserProcesses à no par défaut. Ce paramètre fait que les processus utilisateur ne sont pas tués lorsque l'utilisateur se déconnecte. Pour modifier ce comportement afin que tous les processus utilisateur soient tués lors de la déconnexion de l'utilisateur, définissez KillUserProcesses=yes dans /etc/systemd/logind.conf.\n\nNotez que la modification de ce paramètre casse les multiplexeurs de terminaux tels que tmux et GNU Screen. Si vous modifiez ce paramètre, vous pouvez toujours utiliser un multiplexeur de terminal en utilisant systemd-run comme suit :\n\n```\n$ systemd-run --scope --user command args.\n```\n\nPar exemple, pour exécuter screen vous devez faire :\n\n```\n$ systemd-run --scope --user screen -S foo\n```\n\nL'utilisation de systemd-run ne maintiendra le processus en cours d'exécution après la déconnexion que si l'utilisateur est connecté au moins une fois ailleurs dans le système et que user@.service est toujours en cours d'exécution.\n\nAprès que l'utilisateur se soit déconnecté de toutes les sessions, user@.service sera également arrêté, par défaut, à moins que l'utilisateur n'ait activé la fonction \"lingering\" [7]. Pour permettre aux utilisateurs d'exécuter des tâches à long terme même s'ils sont complètement déconnectés, la fonction \"lingering\" doit être activée pour eux. Consultez #Démarrage automatique des instances utilisateur systemd et loginctl(1) pour plus de détails.\n\n"
    },
    {
      "title": "Runtime directory '/run/user/1000' is not owned by UID 1000, as it should",
      "level": 3,
      "content": "```\nsystemd[1867]: pam_systemd(systemd-user:session): Runtime directory '/run/user/1000' is not owned by UID 1000, as it should.\nsystemd[1867]: Trying to run as user instance, but $XDG_RUNTIME_DIR is not set\n```\n\nSi vous consultez des erreurs de ce type et que votre session de connexion est interrompue, il est possible qu'un autre service système (non utilisateur) sur votre système crée ce répertoire. Cela peut se produire par exemple si vous utilisez un conteneur docker qui a un montage bind sur /run/user/1000. Pour résoudre ce problème, vous pouvez soit réparer le conteneur en supprimant le montage, soit désactiver/retarder le service docker.\n\n"
    },
    {
      "title": "Voir aussi",
      "level": 2,
      "content": "- Le wiki Bitbucket de KaiSforza\n- Les unités de Zoqaeski sur GitHub\n- Fil du forum Arch sur les changements dans les instances utilisateur de systemd 206\n\n"
    }
  ]
}