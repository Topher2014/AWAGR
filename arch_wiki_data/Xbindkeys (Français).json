{
  "title": "Xbindkeys (Français)",
  "url": "https://wiki.archlinux.org/title/Xbindkeys_(Fran%C3%A7ais)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- xmodmap (Français)\n- Sxhkd\n- Xorg#Automation\n\nXbindkeys est un utilitaire capable de faire correspondre n'importe quelle touche ou combinaison de touches à une commande. Cela peut être intéressant par exemple, pour configurer un clavier multimédia ou les touches de fonction d'un ordinateur portable indépendamment du gestionnaire de fenêtres utilisé.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Installez le paquet xbindkeys.\n\n"
    },
    {
      "title": "Configuration",
      "level": 2,
      "content": "Créez un ~/.xbindkeysrc vierge, ou vous pouvez créer un fichier exemple (Notez que cela inclut certains raccourcis telles que Ctrl+f, que vous voudrez peut-être modifier ou supprimer) :\n\n```\n$ xbindkeys -d > ~/.xbindkeysrc\n```\n\nMaintenant, vous pouvez soit éditer ~/.xbindkeysrc pour définir les raccourcis clavier, soit utiliser la méthode #Avec une GUI.\n\n"
    },
    {
      "title": "Contrôle audio",
      "level": 3,
      "content": "Voici un exemple de fichier de configuration qui lie les combinaisons de touches Fn d'un ordinateur portable aux commandes pactl qui règlent l'audio, comme le volume du son et l'état du muet. Notez que les symboles dièse (#) peuvent être utilisés pour créer des commentaires.\n\n```\n~/.xbindkeysrc\n```\n\n```\n# Augmenter le volume\n\"pactl set-sink-volume @DEFAULT_SINK@ +1000\"\n   XF86AudioRaiseVolume\n\n# Diminuer le volume\n\"pactl set-sink-volume @DEFAULT_SINK@ -1000\"\n   XF86AudioLowerVolume\n\n# Coupe le volume\n\"pactl set-sink-mute @DEFAULT_SINK@ toggle\"\n   XF86AudioMute\n\n# Coupe le micro\n\"pactl set-source-mute @DEFAULT_SOURCE@ toggle\"\n   XF86AudioMicMute\n```\n\nPour des commandes alternatives de contrôle du volume, consultez PulseAudio#Keyboard volume control ou ALSA#Keyboard volume control.\n\n"
    },
    {
      "title": "Contrôle du rétroéclairage",
      "level": 3,
      "content": "Les raccourcis pour le contrôle du rétroéclairage peuvent être définies à l'aide des touches XF86MonBrightnessUp et XF86MonBrightnessDown. Consultez Backlight#Backlight utilities pour connaître les utilitaires de contrôle du rétroéclairage disponibles.\n\n"
    },
    {
      "title": "Avec une GUI",
      "level": 3,
      "content": "Pour une configuration graphique, installez le paquet xbindkeys_config-gtk2AUR et exécutez :\n\n```\n$ xbindkeys_config\n```\n\n"
    },
    {
      "title": "Identifier les keycodes",
      "level": 2,
      "content": "Pour trouver les keycodes d'une touche particulière, entrez la commande suivante :\n\n```\n$ xbindkeys --key\n```\n\nou la commande suivante pour saisir plusieurs touches :\n\n```\n$ xbindkeys --multikey\n```\n\nUne fenêtre vide s'ouvre. Appuyez sur la ou les touches auxquelles vous souhaitez assigner une commande et xbindkeys produira un extrait pratique qui peut être entré dans ~/.xbindkeysrc. Par exemple, lorsque la fenêtre vide est ouverte, appuyez sur Alt+o pour obtenir la sortie suivante (les résultats peuvent varier) :\n\n```\n\"(Scheme function)\"\n    m:0x8 + c:32\n    Alt + o\n```\n\n1. La première ligne représente une commande.\n1. La deuxième ligne contient l'état (0x8) et le code de touche (32) tels que rapportés par l'outil xev.\n1. La troisième ligne contient les keysyms associés aux keycodes donnés.\n\nPour utiliser cette sortie, copiez l'une des deux dernières lignes dans ~/.xbindkeysrc et remplacez \"(Scheme function)\" par la commande que vous souhaitez exécuter.\n\nPour identifier les boutons de la souris, xev peut être utilisé, consultez [1].\n\n"
    },
    {
      "title": "Rendre les changements permanents",
      "level": 2,
      "content": "Une fois que vous avez fini de configurer vos touches, éditez votre fichier xprofile ou xinitrc (en fonction de votre gestionnaire de fenêtres) et placez\n\n```\nxbindkeys\n```\n\navant la ligne qui démarre votre gestionnaire de fenêtres ou DE.\n\n"
    },
    {
      "title": "Simuler les touches multimédia",
      "level": 2,
      "content": "Les touches XF86Audio* et autres touches multimédia (consultez LQWiki:Symboles du clavier XF86) sont à peu près reconnues par les principaux DE. Pour les claviers ne possédant pas de telles touches, vous pouvez simuler leur effet avec d'autres touches\n\n```\n# Diminuer le volume en appuyant sur Super-moins\n\"pactl set-sink-volume 0 -1000\"\n   m:0x50 + c:20\n   Mod2+Mod4 + minus\n```\n\nCependant, pour appeler les touches elles-mêmes, vous pouvez utiliser des outils comme xdotool et xmacroAUR. Malheureusement, comme vous tenez déjà une touche modificatrice (Super ou Shift, par exemple), X consultera le résultat sous la forme Super-XF86AudioLowerVolume, ce qui n'apportera rien d'utile. Voici un script basé sur xmacro et xmodmap du paquet xorg-xmodmap pour faire cela [2].\n\n```\n#!/bin/sh\necho 'KeyStrRelease Super_L KeyStrRelease minus' | xmacroplay :0\nxmodmap -e 'remove Mod4 = Super_L'\necho 'KeyStrPress XF86AudioLowerVolume KeyStrRelease XF86AudioLowerVolume' | xmacroplay :0\nxmodmap -e 'add Mod4 = Super_L'\n```\n\nCela fonctionne pour appeler XF86AudioLowerVolume une fois (en supposant que vous utilisez Super+minus), mais l'appeler de manière répétée sans relâcher la touche Super (comme taper sur un bouton de volume) ne fonctionne pas. Si vous souhaitez que cela fonctionne ainsi, ajoutez la ligne suivante au bas du script.\n\n```\necho 'KeyStrPress Super_L' | xmacroplay :0\n```\n\nAvec ce script modifié, si vous appuyez sur la combinaison de touches assez rapidement, votre touche Super_L restera activée jusqu'à la prochaine fois que vous l'appuierez, ce qui peut entraîner des effets secondaires intéressants. Il suffit d'appuyer à nouveau sur la touche pour supprimer cet état, ou d'utiliser le script original si vous voulez que les choses fonctionnent simplement et que cela ne vous dérange pas de ne pas appuyer plusieurs fois sur le volume haut/bas.\n\nCes instructions sont valables pour pratiquement toutes les touches multimédia «XF86» (les plus importantes sont XF86AudioRaiseVolume, XF86AudioLowerVolume, XF86AudioPlay, XF86AudioPrev, XF86AudioNext).\n\n"
    },
    {
      "title": "«Mouse chording»",
      "level": 2,
      "content": "En dédiant un bouton de la souris comme une touche \"d'accord\" (un peu comme la touche Shift sur un clavier), il est possible d'utiliser xbindkeys pour configurer votre souris afin d'effectuer plus d'actions que ce qui serait possible autrement. Cela nécessite l'utilisation de Scheme, plutôt que la syntaxe simplifiée de xbindkeys.\n\n```\n.xbindkeysrc.scm\n```\n\n```\n(define (define-mouse-chords chord-key . definitions)\n  (define (start-mouse-chord)\n    (let ((cmd #f))\n      (for-each\n        (lambda (definition)\n          (let ((key (list-ref definition 0)) (binding (list-ref definition 1)))\n            (xbindkey-function key (lambda () (set! cmd binding)))))\n        definitions)\n      (xbindkey-function `(release ,chord-key)\n        (lambda ()\n          (remove-xbindkey `(release ,chord-key))\n          (for-each\n            (lambda (definition)\n              (let ((key (list-ref definition 0)))\n                (remove-xbindkey key)))\n            definitions)\n          (if cmd\n            (begin\n              (run-command cmd)\n              (set! cmd #f))\n          )))))\n  (xbindkey-function chord-key start-mouse-chord))\n```\n\nAvec cette fonction définie, vous pouvez maintenant configurer quelques commandes «accordées» :\n\n```\n(define-mouse-chords \"b:10\"\n  (list '(release \"b:1\") \"xdotool click 8\")\n  (list '(release \"b:2\") \"xdotool click 9\")\n)\n```\n\nCeci définit le \"bouton 10\" comme une touche d'accord sur votre souris. Lorsque le bouton 10 est enfoncé, la fonction crée des liens pour les boutons définis dans le bloc. Lorsque le bouton 10 est relâché, ces raccourcis seront supprimées. Ainsi, par exemple, si le bouton 10 est maintenu enfoncé, le fait d'appuyer sur le bouton 1 et de le relâcher, puis de relâcher le bouton 10, entraînera la génération d'un événement virtuel \"bouton 8\" (retour).\n\n"
    },
    {
      "title": "Dépannage",
      "level": 2,
      "content": "Si, pour une raison quelconque, un raccourci clavier que vous avez déjà défini dans ~/.xbindkeysrc ne fonctionne pas, ouvrez un terminal et tapez ce qui suit :\n\n```\n$ xbindkeys -n\n```\n\nEn appuyant sur la touche qui ne fonctionne pas, vous pourrez consulter toute erreur rencontrée par xbindkeys (ex : commande/code touche mal saisi,...).\n\nSi la commande pour un keybind fonctionne via le xdotool en ligne de commande, mais pas lorsqu'elle est activée par le hotkey essayez d'ajouter \"+ Release\" au raccourci (particulièrement notable sur GNOME) :\n\n```\n\"xdotool key --clearmodifiers XF86AudioPlay\"\n    Mod2 + F7 + Release\n```\n\nCeci fera en sorte que la touche F7 joue/pause le son. Alors que la commande \"xdotool\" fonctionne en ligne de commande, si le \"+ Release\" est supprimé, elle échouera avec xbindkeys.\n\n"
    }
  ]
}