{
  "title": "Python package guidelines (Русский)",
  "url": "https://wiki.archlinux.org/title/Python_package_guidelines_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Font – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust – Shell – VCS – Web – Wine\n\nЭтот документ охватывает стандарты и рекомендации по написанию файлов PKGBUILD для программ, работающих на Python.\n\n"
    },
    {
      "title": "Именование пакета",
      "level": 2,
      "content": "Для библиотек Python 3 используйте python-имямодуля. Также используйте префикс, если пакет предоставляет программу, тесно связанную с экосистемой Python (например, pip или tox). Для других приложений используйте только имя программы.\n\n"
    },
    {
      "title": "Архитектура",
      "level": 2,
      "content": "Смотрите PKGBUILD (Русский)#arch.\n\nПакет Python, содержащий расширения C, является архитектурно-зависимым. В противном случае он, скорее всего, является архитектурно-независимым.\n\nПакеты, собираемые с помощью setuptools, определяют свои расширения C с помощью ключевого слова ext_modules в setup.py.\n\n"
    },
    {
      "title": "Исходники",
      "level": 2,
      "content": "URL загрузки, связанные с сайтом PyPI, содержат непредсказуемый хэш, который необходимо получать с сайта PyPI каждый раз, когда пакет должен быть обновлён. Это делает их непригодными для использования в PKGBUILD. PyPI предоставляет альтернативную стабильную схему: массив source должен использовать следующие шаблоны URL:\n\nОбратите внимание, что используется переменная _name вместо pkgname, поскольку пакеты Python обычно имеют префикс python-. Эта переменная может быть определена следующим образом:\n\n```\n_name=${pkgname#python-}\n```\n\n"
    },
    {
      "title": "Методы установки",
      "level": 2,
      "content": "Пакеты Python обычно устанавливаются с помощью специального менеджера пакетов, такого как pip, который получает пакеты из онлайн-репозитория (обычно PyPI, Python Package Index) и отслеживает соответствующие файлы.\n\nОднако для управления пакетами Python из PKGBUILD необходимо «установить» пакет Python во временное место $pkgdir/usr/lib/python<версия Python>/site-packages/$pkgname.\n\nДля пакетов Python, использующих стандартные метаданные для указания бэкенда сборки в файле pyproject.toml, это проще всего сделать с помощью python-build и python-installer. Старые пакеты могут не указывать, что они используют setuptools, и предлагать только setup.py, который должен быть вызван вручную.\n\n"
    },
    {
      "title": "Основанный на стандартах (PEP 517)",
      "level": 3,
      "content": "- python-setuptools-scm: SETUPTOOLS_SCM_PRETEND_VERSION\n- python-pbr: PBR_VERSION\n- python-pdm-backend: PDM_BUILD_SCM_VERSION\n\nРабочий процесс, основанный на стандартах, прост: создайте wheel-пакет с помощью python-build и установите его в $pkgdir с помощью python-installer:\n\n```\nmakedepends=(python-build python-installer python-wheel)\n\nbuild() {\n    cd \"$_name-$pkgver\"\n    python -m build --wheel --no-isolation\n}\n\npackage() {\n    cd \"$_name-$pkgver\"\n    python -m installer --destdir=\"$pkgdir\" dist/*.whl\n}\n```\n\nгде\n\n- --wheel указывает создать только wheel-пакет, без архива с исходным кодом.\n- --no-isolation указывает, что пакет должен быть собран с использованием установленных в системе зависимостей (включая пакеты, указанные вами в depends); по умолчанию без этой опции для сборки создаётся изолированное виртуальное окружение.\n- --destdir=\"$pkgdir\" предотвращает попытку прямой установки в хост-систему, а не внутрь файла пакета, что привело бы к ошибке доступа\n- --compile-bytecode=... или --no-compile-bytecode можно передать в installer, но значение по умолчанию выбрано разумно, поэтому в этом нет необходимости.\n\nNote: **только** \n\n"
    },
    {
      "title": "setuptools или distutils",
      "level": 3,
      "content": "Если pyproject.toml отсутствует или не содержит таблицу [build-system], это означает, что проект использует старый формат, использующий файл setup.py, который вызывает setuptools или distutils. Обратите внимание, что хотя distutils включен в стандартную библиотеку Python, наличие установленного setuptools означает, что вы используете пропатченную версию distutils.\n\n```\nmakedepends=('python-setuptools')  # если только он не требует именно distutils\n\nbuild() {\n    cd \"$_name-$pkgver\"\n    python setup.py build\n}\n\npackage() {\n    cd \"$_name-$pkgver\"\n    python setup.py install --root=\"$pkgdir\" --optimize=1\n}\n```\n\nгде:\n\n- --root=\"$pkgdir\" работает как --destdir выше\n- --optimize=1 заранее компилирует оптимизированные файлы байткода (.opt-1.pyc), чтобы их мог отслеживать pacman, вместо ленивого их создания при запуске программы.\n- Добавление --skip-build оптимизирует ненужную попытку повторного выполнения шагов сборки, уже запущенных в функции build(), если это имеет место.\n\nНекоторые пакеты пытаются использовать setuptools и возвращаются к distutils, если setuptools не может быть импортирован. В этом случае setuptools должен быть добавлен как makedepends, чтобы результирующие метаданные Python были лучше.\n\nЕсли пакет требует сборки setuptools из-за включения исполняемых файлов (что не поддерживается distutils), но импортирует только distutils, то при сборке будет выдано предупреждение, а полученный пакет будет повреждён (он не будет содержать исполняемых файлов):\n\n```\n/usr/lib/python3.8/distutils/dist.py:274: UserWarning: Unknown distribution option: 'entry_points'\n  warnings.warn(msg)\n```\n\nНеобходимо сообщить об ошибке в upstream. Для обхода проблемы можно использовать недокументированную функцию setuptools:\n\n```\n# не работает из-за distutils\npython setup.py build\n\n# работает, используя setuptools shim\npython -m setuptools.launch setup.py build\n```\n\nЕсли пакет использует python-setuptools-scm, пакет, скорее всего, не будет собран с ошибкой, такой как:\n\n```\nLookupError: setuptools-scm was unable to detect version for /build/python-jsonschema/src/jsonschema-3.2.0.\n\nMake sure you're either building from a fully intact git repository or PyPI tarballs. Most other sources (such as GitHub's tarballs, a git checkout without the .git folder) don't contain the necessary metadata and will not work.\n```\n\nЧтобы пакет собрался, нужно экспортировать переменную окружения SETUPTOOLS_SCM_PRETEND_VERSION со значением $pkgver:\n\n```\nexport SETUPTOOLS_SCM_PRETEND_VERSION=$pkgver\n```\n\n"
    },
    {
      "title": "Проверка",
      "level": 2,
      "content": "Note: **не** \n\nБольшинство проектов Python, предоставляющих набор тестов, используют nosetests или pytest для запуска тестов с test в имени файла или каталога, содержащего набор тестов. В общем случае для запуска набора тестов достаточно просто запустить nosetests или pytest.\n\n```\ncheck(){\n    cd \"$srcdir/foo-$pkgver\"\n\n    # Для nosetests\n    nosetests\n\n    # Для pytest\n    pytest\n}\n```\n\nЕсли есть скомпилированное расширение C, тесты необходимо запускать, используя $PYTHONPATH, отражающий текущую мажорную и минорную версию Python, чтобы найти и загрузить его.\n\n```\ncheck(){\n  cd \"$pkgname-$pkgver\"\n  local python_version=$(python -c 'import sys; print(\"\".join(map(str, sys.version_info[:2])))')\n  # Для nosetests\n  PYTHONPATH=\"$PWD/build/lib.linux-$CARCH-cpython-${python_version}\" nosetests\n\n  # Для pytest\n  PYTHONPATH=\"$PWD/build/lib.linux-$CARCH-cpython-${python_version}\" pytest\n}\n```\n\nНекоторые проекты предоставляют setup.py точки входа для запуска теста. Это работает как для pytest, так и для nosetests.\n\n```\ncheck(){\n    cd \"$srcdir/foo-$pkgver\"\n\n    # Для nosetests\n    python setup.py nosetests\n\n    # Для pytest - нужен python-pytest-runner\n    python setup.py pytest\n}\n```\n\n"
    },
    {
      "title": "Обнаружение отдельных подписей PGP на PyPI",
      "level": 3,
      "content": "Если для sdist-архива существуют отдельные PGP-подписи — их следует использовать для проверки архива. Однако файлы подписей не отображаются непосредственно в разделе загрузки файлов какого-либо проекта на pypi.org. Чтобы обнаружить sdist и их потенциальные файлы подписей, можно воспользоваться этим сервисом для получения обзора по каждому проекту: https://pypi.debian.net/.\n\nДля python-requests это будет https://pypi.debian.net/requests.\n\n"
    },
    {
      "title": "Использование версии python",
      "level": 3,
      "content": "Иногда во время подготовки, сборки, тестирования или установки требуется указать мажорную и минорную версию Python для системы. Не записывайте это жёстко в коде (например, 3.9 или 3.10), а запустите интерпретатор Python для получения информации и сохранения её в локальной переменной:\n\n```\ncheck(){\n  local python_version=$(python -c 'import sys; print(\".\".join(map(str, sys.version_info[:2])))')\n  ...\n}\n```\n\n"
    },
    {
      "title": "Использование site-packages",
      "level": 3,
      "content": "Иногда во время сборки, тестирования или установки требуется обратиться к системному каталогу site-packages. Не следует записывать путь жёстко в коде, вместо этого запустите интерпретатор Python для получения пути и сохранения его в локальной переменной:\n\n```\ncheck(){\n  local site_packages=$(python -c \"import site; print(site.getsitepackages()[0])\")\n  ...\n}\n```\n\n"
    },
    {
      "title": "Тестовый каталог в site-packages",
      "level": 3,
      "content": "Убедитесь, что вы не установили каталог с именем tests в site-packages. (т.е. /usr/lib/pythonX.Y/site-packages/tests/). Некоторые Python-проекты, использующие setuptools, иногда неправильно настроены и добавляют каталог с тестами в качестве Python-пакета верхнего уровня. Если вы столкнулись с этим, то можете помочь, отправив проекту сообщение об ошибке с просьбой исправить это, например, вот так.\n\n"
    }
  ]
}