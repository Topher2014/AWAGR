{
  "title": "Bash/Functions (Español)",
  "url": "https://wiki.archlinux.org/title/Bash/Functions_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2020-12-08** \n\nBash también admite funciones. Añada las funciones a ~/.bashrc, o a un archivo separado que sea cargado desde ~/.bashrc. Se pueden encontrar más ejemplos de la función Bash en BBS#30155.\n\n"
    },
    {
      "title": "Mostrar códigos de error",
      "level": 2,
      "content": "Para configurar trap para interceptar un código de retorno distinto de cero de la última ejecución del programa:\n\n```\nEC() {\n\techo -e '\\e[1;33m'code $?'\\e[m\\n'\n}\ntrap EC ERR\n```\n\n"
    },
    {
      "title": "Compilar y ejecutar una código fuente en C sobre la marcha",
      "level": 2,
      "content": "La siguiente función compilará (dentro del directorio /tmp/) y ejecutará el código fuente en C del argumento sobre la marcha (y la ejecución será sin argumentos). Y finalmente, después de que el programa termine, eliminará el archivo compilado.\n\n```\n# Compilar y ejecutar un código fuente en C sobre la marcha\ncsource() {\n\t[[ $1 ]]    || { echo \"Falta el operando\" >&2; return 1; }\n\t[[ -r $1 ]] || { printf \"El archivo %s no existe o no se puede leer\\n\" \"$1\" >&2; return 1; }\n\tlocal output_path=${TMPDIR:-/tmp}/${1##*/};\n\tgcc \"$1\" -o \"$output_path\" && \"$output_path\";\n\trm \"$output_path\";\n\treturn 0;\n}\n```\n\n"
    },
    {
      "title": "Extraer",
      "level": 2,
      "content": "La siguiente función extraerá una amplia gama de tipos de archivos comprimidos. Utilícelo con la sintaxis extract <archivo1> <archivo2> ....\n\n```\nextract() {\n    local c e i\n\n    (($#)) || return\n\n    for i; do\n        c=''\n        e=1\n\n        if [[ ! -r $i ]]; then\n            echo \"$0: el archivo es ilegible: \\`$i'\" >&2\n            continue\n        fi\n\n        case $i in\n            *.t@(gz|lz|xz|b@(2|z?(2))|a@(z|r?(.@(Z|bz?(2)|gz|lzma|xz)))))\n                   c=(bsdtar xvf);;\n            *.7z)  c=(7z x);;\n            *.Z)   c=(uncompress);;\n            *.bz2) c=(bunzip2);;\n            *.exe) c=(cabextract);;\n            *.gz)  c=(gunzip);;\n            *.rar) c=(unrar x);;\n            *.xz)  c=(unxz);;\n            *.zip) c=(unzip);;\n            *.zst) c=(unzstd);;\n            *)     echo \"$0: extensión de archivo no reconocida: \\`$i'\" >&2\n                   continue;;\n        esac\n\n        command \"${c[@]}\" \"$i\"\n        ((e = e || $?))\n    done\n    return \"$e\"\n}\n```\n\nOtra forma de hacer esto es instalar un paquete especializado, véase Herramientas convenientes de archivado y compresión.\n\n"
    },
    {
      "title": "cd y ls en uno",
      "level": 2,
      "content": "Muy a menudo, al cambiar a un directorio le sigue la orden ls para listar su contenido. Por lo tanto, es útil tener una segunda función que haga ambas cosas a la vez. En este ejemplo lo llamaremos cl (change list, o listar al cambiar) y mostraremos un mensaje de error si el directorio especificado no existe.\n\n```\ncl() {\n\tlocal dir=\"$1\"\n\tlocal dir=\"${dir:=$HOME}\"\n\tif [[ -d \"$dir\" ]]; then\n\t\tcd \"$dir\" >/dev/null; ls\n\telse\n\t\techo \"bash: cl: $dir: Directorio no encontrado\"\n\tfi\n}\n```\n\nPor supuesto, la orden ls puede modificarse para adaptarse a sus necesidades, por ejemplo, ls -hall --color=auto.\n\n"
    },
    {
      "title": "Tomador de notas simple",
      "level": 2,
      "content": "```\nnote () {\n    # si el archivo no existe, créalo\n    if [[ ! -f $HOME/.notes ]]; then\n        touch \"$HOME/.notes\"\n    fi\n\n    if ! (($#)); then\n        # sin argumentos, imprimir archivo\n        cat \"$HOME/.notes\"\n    elif [[ \"$1\" == \"-c\" ]]; then\n        # limpiar archivo\n        printf \"%s\" > \"$HOME/.notes\"\n    else\n        # añadir todos los argumentos al archivo\n        printf \"%s\\n\" \"$*\" >> \"$HOME/.notes\"\n    fi\n}\n```\n\n"
    },
    {
      "title": "Utilidad de tarea simple",
      "level": 2,
      "content": "Inspirado en #Tomador de notas simple.\n\n```\ntodo() {\n    if [[ ! -f $HOME/.todo ]]; then\n        touch \"$HOME/.todo\"\n    fi\n\n    if ! (($#)); then\n        cat \"$HOME/.todo\"\n    elif [[ \"$1\" == \"-l\" ]]; then\n        nl -b a \"$HOME/.todo\"\n    elif [[ \"$1\" == \"-c\" ]]; then\n        > $HOME/.todo\n    elif [[ \"$1\" == \"-r\" ]]; then\n        nl -b a \"$HOME/.todo\"\n        eval printf %.0s- '{1..'\"${COLUMNS:-$(tput cols)}\"\\}; echo\n        read -p \"Introduzca un número para eliminar: \" number\n        sed -i ${number}d $HOME/.todo \"$HOME/.todo\"\n    else\n        printf \"%s\\n\" \"$*\" >> \"$HOME/.todo\"\n    fi\n}\n```\n\n"
    },
    {
      "title": "Calculadora",
      "level": 2,
      "content": "```\ncalc() {\n    echo \"scale=3;$@\" | bc -l\n}\n```\n\n"
    },
    {
      "title": "Kingbash",
      "level": 2,
      "content": "Kingbash - autocompletado dirigido por menú (véase BBS#101010).\n\nInstale kingbash-gb-gitAUR[enlace roto: package not found] de AUR, luego inserte lo siguiente en su ~/.bashrc:\n\n```\nfunction kingbash.fn() {\n    echo -n \"KingBash> $READLINE_LINE\" #Where \"KingBash> \" se ve mejor si se parece a su PS1, al menos en longitud.\n    OUTPUT=$(/usr/bin/kingbash \"$(compgen -ab -A function)\")\n    READLINE_POINT=$(echo \"$OUTPUT\" | tail -n 1)\n    READLINE_LINE=$(echo \"$OUTPUT\" | head -n -1)\n    echo -ne \"\\r\\e[2K\"\n}\nbind -x '\"\\t\":kingbash.fn'\n```\n\n"
    },
    {
      "title": "Información IP",
      "level": 2,
      "content": "Información detallada sobre una dirección IP o nombre de máquina (hostname) en bash a través de https://ipinfo.io:\n\n```\nipif() { \n    if grep -P \"(([1-9]\\d{0,2})\\.){3}(?2)\" <<< \"$1\"; then\n\t curl ipinfo.io/\"$1\"\n    else\n\tipawk=($(host \"$1\" | awk '/address/ { print $NF }'))\n\tcurl ipinfo.io/${ipawk[1]}\n    fi\n    echo\n}\n```\n\n"
    }
  ]
}