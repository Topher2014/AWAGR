{
  "title": "Dd (Русский)",
  "url": "https://wiki.archlinux.org/title/Dd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Клонирование диска\n- Установочный образ на USB-накопителе#Через dd\n- Benchmarking#dd\n- Securely wipe disk#dd\n\ndd — это основная утилита, основной задачей которой является конвертация и копирование файлов.\n\nКак и cp, по умолчанию dd делает точную копию файла, но позволяет контролировать параметры ввода-вывода на низком уровне.\n\nПодробности можно почитать в dd(1) или полной документации.\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "dd входит в состав GNU coreutils. Другие утилиты из этого пакета описаны в статье Основные утилиты.\n\n"
    },
    {
      "title": "Клонирование диска и восстановление",
      "level": 2,
      "content": "Команда dd — это простой, но универсальный и мощный инструмент. Она может использоваться для копирования, блок за блоком, независимо от типа файловой системы или операционной системы. Нередко dd используется в LiveCD.\n\n"
    },
    {
      "title": "Клонирование раздела",
      "level": 3,
      "content": "Копирование раздела 1 на диске /dev/sda в раздел 1 на диске /dev/sdb:\n\n```\n# dd if=/dev/sda1 of=/dev/sdb1 bs=64K conv=noerror,sync status=progress\n```\n\n"
    },
    {
      "title": "Клонирование всего диска",
      "level": 3,
      "content": "Копирование физического диска /dev/sda в диск /dev/sdb:\n\n```\n# dd if=/dev/sda of=/dev/sdb bs=64K conv=noerror,sync status=progress\n```\n\nЭта команда скопирует диск целиком, в том числе таблицу разделов, загрузчик, разделы, UUID и данные.\n\n- bs= устанавливает размер блока. По умолчанию 512 байт, что является «классическим» размером блока для жёстких дисков с начала 1980-х годов, но не самым удобным. Используйте большее значение, 64K или 128K. Также прочитайте предупреждение ниже, потому что это не просто «размер блока» — это также влияет на обработку ошибок чтения. Смотрите [1] и [2] для получения подробной информации и определения наилучшего значения bs для вашего случая.\n- noerror указывает dd продолжить работу, игнорируя все ошибки чтения. По умолчанию dd прекращает работу при любой ошибке.\n- sync заполняет входные блоки нулями, если были ошибки чтения, чтобы смещения данных оставались правильными.\n- status=progress показывает статистику передачи данных, которая позволяет оценить время завершения.\n\nУтилита dd технически имеет «размер входного блока» (IBS) и «размер выходного блока» (OBS). Когда вы устанавливаете bs, вы фактически устанавливаете и IBS, и OBS. Обычно, если размер блока, скажем, 1 МиБ, dd считывает 1024×1024 байт и записывает столько же байт. Но если произойдет ошибка чтения, всё пойдет не так. Многие думают, что dd «заполнит ошибки чтения нулями», если вы используете опции noerror,sync, но это не так. dd, согласно документации, дополнит размер OBS до размера IBS после завершения чтения, что означает добавление нулей в конце блока. То есть, весь 1 МиБ будет испорчен из-за одной ошибки чтения в 512 байт в начале чтения: 12ERROR89 станет 128900000 вместо 120000089.\n\nЕсли вы уверены, что ваш диск не содержит ошибок, вы можете использовать больший размер блока, что увеличит скорость копирования в несколько раз. Например, изменение bs с 512 до 64K изменило скорость копирования с 35 МБ/с до 120 МБ/с на простой системе Celeron 2,7 ГГц. Но имейте в виду, что ошибки чтения на исходном диске будут в конечном итоге выглядеть как ошибки блоков на целевом диске, то есть одна ошибка чтения 512 байт испортит весь выходной блок размером 64 КиБ.\n\n- Чтобы сделать UUID файловых систем ext2/3/4 снова уникальными после копирования, используйте tune2fs /dev/sdXY -U random для каждого раздела. Для разделов подкачки используйте mkswap /dev/sdXY.\n- Если вы копируете GPT-диск, вы можете использовать sgdisk для рандомизации GUID диска и разделов и восстановления их уникальности.\n- Изменения таблицы разделов, которые внёс dd на целевом диске, не регистрируются ядром. Чтобы попросить ядро перечитать таблицы разделов без перезагрузки, можно использовать утилиту partprobe (часть GNU Parted).\n\n"
    },
    {
      "title": "Резервное копирование таблицы разделов",
      "level": 3,
      "content": "Смотрите fdisk (Русский)#Резервное копирование и восстановление таблицы разделов или GPT fdisk (Русский)#Резервное копирование и восстановление таблицы разделов.\n\n"
    },
    {
      "title": "Создание образа диска",
      "level": 3,
      "content": "Загрузитесь в LiveCD и убедитесь, что разделы исходного диска не примонтированы.\n\nЗатем смонтируйте целевой диск и запишите на него резервную копию:\n\n```\n# dd if=/dev/sda conv=sync,noerror bs=64K | gzip -c  > /путь/к/копии.img.gz\n```\n\nПри необходимости (например, если результирующие файлы будут храниться в файловой системе FAT32) можно разделить образ диска на несколько частей (смотрите также split(1)):\n\n```\n# dd if=/dev/sda conv=sync,noerror bs=64K | gzip -c | split -a3 -b2G - /путь/к/копии.img.gz\n```\n\nЕсли не хватает свободного места на локальном диске, можно отправить образ через ssh:\n\n```\n# dd if=/dev/sda conv=sync,noerror bs=64K | gzip -c | ssh user@local dd of=копия.img.gz\n```\n\nНаконец, сохраните дополнительную информацию о геометрии диска, необходимую для интерпретации таблицы разделов, хранящейся в образе. Наиболее важной из них является размер цилиндра.\n\n```\n# fdisk -l /dev/sda > /путь/к/list_fdisk.info\n```\n\n"
    },
    {
      "title": "Восстановление системы",
      "level": 3,
      "content": "Чтобы восстановиться из такой резервной копии:\n\n```\n# gunzip -c /путь/к/копии.img.gz | dd of=/dev/sda\n```\n\nЕсли образ был разделён на несколько частей командой split, используйте другую команду (обратите внимание на звёздочку):\n\n```\n# cat /путь/к/копии.img.gz* | gunzip -c | dd of=/dev/sda\n```\n\n"
    },
    {
      "title": "Патчинг бинарных файлов",
      "level": 2,
      "content": "Если нужно заменить заменить три байта FF C0 14 по смещению 0x123AB, это можно сделать с помощью такой команды:\n\n```\n# printf '\\xff\\xc0\\x14' | dd seek=$((0x123AB)) conv=notrunc bs=1 of=/путь/к/файлу\n```\n\n"
    },
    {
      "title": "Резервное копирование и восстановление MBR",
      "level": 2,
      "content": "Перед внесением изменений на диск можно создать резервную копию таблицы разделов и схемы разделов диска. Также можно использовать резервную копию для копирования одной и той же схемы разделов на несколько дисков.\n\nMBR хранится в первых 512 байтах диска. Она состоит из 4 частей:\n\n1. Первые 440 байт содержат загрузочный код (загрузчик).\n1. Следующие 6 байт содержат сигнатуру диска.\n1. Следующие 64 байта содержат таблицу разделов (4 записи по 16 байт каждая, по одной записи на каждый основной раздел).\n1. Последние 2 байта содержат сигнатуру загрузки.\n\nСохранение MBR в mbr_file.img:\n\n```\n# dd if=/dev/sdX of=/путь/к/mbr_file.img bs=512 count=1\n```\n\nТакже можно извлечь MBR из полного образа диска dd:\n\n```\n# dd if=/путь/к/образу.img of=/путь/к/mbr_file.img bs=512 count=1\n```\n\nДля восстановления (будьте осторожны, это уничтожит существующую таблицу разделов, а вместе с ней и доступ ко всем данным на диске):\n\n```\n# dd if=/путь/к/mbr_file.img of=/dev/sdX bs=512 count=1\n```\n\nЕсли вы хотите восстановить только загрузчик, но не информацию о разделах, просто восстановите первые 440 байт MBR:\n\n```\n# dd if=/путь/к/mbr_file.img of=/dev/sdX bs=440 count=1\n```\n\nВосстановление только таблицы разделов без затрагивания загрузчика и сигнатуры:\n\n```\n# dd if=/путь/к/mbr_file.img of=/dev/sdX bs=1 skip=446 count=64\n```\n\n"
    },
    {
      "title": "Удаление загрузчика",
      "level": 3,
      "content": "Чтобы стереть загрузочный код MBR (может быть полезно, если вам нужно сделать полную переустановку другой операционной системы), можно обнулить первые 440 байт:\n\n```\n# dd if=/dev/zero of=/dev/sdX bs=440 count=1\n```\n\n"
    },
    {
      "title": "Partial read",
      "level": 3,
      "content": "Файлы, созданные с помощью dd, могут иметь меньший размер, чем запрошено, если полный входной блок недоступен и системный вызов read(2) завершается раньше времени. Это может произойти при чтении из pipe(7) или при чтении с /dev/random и недостаточной энтропии[3], или с /dev/urandom при чтении более 32 МиБ[4].\n\nВозможно, но не гарантировано, что dd предупредит вас об этой проблеме:\n\n```\ndd: warning: partial read (X bytes); suggest iflag=fullblock\n```\n\nРешается это так, как и предлагает предупреждение: добавлением iflag=fullblock к команде dd:\n\n```\n$ dd if=/dev/random of=bigsecret.img bs=1K count=1 iflag=fullblock\n$ dd if=/dev/urandom of=bigsecret.img bs=40M count=1 iflag=fullblock\n```\n\nДля /dev/urandom также можно задать большее число копируемых блоков:\n\n```\n$ dd if=/dev/urandom of=bigsecret.img bs=1M count=40\n```\n\nПри чтении из pipe альтернативой для для iflag=fullblock может быть прописывние для bs значения PIPE_BUF, которое определено в /usr/include/linux/limits.h [5]. Например:\n\n```\n$ cat input.img | dd of=output.img bs=4k count=100\n```\n\n"
    }
  ]
}