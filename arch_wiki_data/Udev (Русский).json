{
  "title": "Udev (Русский)",
  "url": "https://wiki.archlinux.org/title/Udev_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- udisks (Русский)\n\nudev — работающая в пространстве пользователя система, с помощью которой системный администратор может создавать обработчики событий. События, получаемые udev, обычно генерируются ядром Linux в ответ на физические события, происходящие с периферийными устройствами. Например, при обнаружении периферийных устройств или \"горячем\" подключении udev может выполнить определённые действия, в том числе и вернуть управление ядру, если необходима загрузка модулей или прошивок.\n\nПодобно предшественникам, утилитам devfsd и hotplug, udev управляет файлами устройств в каталоге /dev, добавляя их, переименовывая и создавая символические ссылки. udev полностью замещает функционал hotplug и hwdetect.\n\nОбработка событий в udev происходит параллельно, что теоретически улучшает производительность старых систем. С другой стороны, это может усложнить администрирование. Так, при перезапуске системы порядок загрузки модулей ядра может измениться, а при наличии в машине нескольких блочных устройств могут поменяться названия их файлов. Например, для системы с двумя жёсткими дисками файл /dev/sda после перезагрузки может превратиться в /dev/sdb.\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "udev входит в состав systemd и установлен по умолчанию. Подробнее см. systemd-udevd.service(8).\n\nСуществует также отдельный от systemd форк, который можно установить с пакетом eudevAUR или eudev-gitAUR[ссылка недействительна: package not found].\n\n"
    },
    {
      "title": "О правилах udev",
      "level": 2,
      "content": "Создаваемые системным администратором правила udev хранятся в каталоге /etc/udev/rules.d/. Названия файлов правил должны заканчиваться суффиксом .rules. Правила из пакетов программ при установке помещаются в каталог /usr/lib/udev/rules.d/. Если в каталогах /usr/lib и /etc находятся два файла правил с одинаковыми именами, то файл в /etc будет иметь приоритет.\n\nПравила udev подробно описаны в руководстве udev(7). Также стоит изучить статью Создание правил udev (англ.) и приведённые в ней практические примеры: Создание правил udev - Примеры (англ.).\n\n"
    },
    {
      "title": "Пример правила udev",
      "level": 3,
      "content": "Ниже приведён пример правила, которое создаёт символическую ссылку /dev/video-cam, когда к компьютеру подключается веб-камера.\n\nПредположим, мы выяснили, что для подключённой камеры создан файл устройства /dev/video2. Причина, по которой мы создаем это правило, заключается в том, что при следующей загрузке веб-камере может быть присвоено другое имя, например, /dev/video0.\n\n```\n$ udevadm info --attribute-walk --path=$(udevadm info --query=path --name=/dev/video2)\n```\n\n```\nUdevadm info starts with the device specified by the devpath and then walks up the chain of parent devices.\nIt prints for every device found, all possible attributes in the udev rules key format.\nA rule to match, can be composed by the attributes of the device and the attributes from one single parent device.\n\nlooking at device '/devices/pci0000:00/0000:00:04.1/usb3/3-2/3-2:1.0/video4linux/video2':\n  KERNEL==\"video2\"\n  SUBSYSTEM==\"video4linux\"\n   ...\nlooking at parent device '/devices/pci0000:00/0000:00:04.1/usb3/3-2/3-2:1.0':\n  KERNELS==\"3-2:1.0\"\n  SUBSYSTEMS==\"usb\"\n  ...\nlooking at parent device '/devices/pci0000:00/0000:00:04.1/usb3/3-2':\n  KERNELS==\"3-2\"\n  SUBSYSTEMS==\"usb\"\n  ATTRS{idVendor}==\"05a9\"\n  ATTRS{manufacturer}==\"OmniVision Technologies, Inc.\"\n  ATTRS{removable}==\"unknown\"\n  ATTRS{idProduct}==\"4519\"\n  ATTRS{bDeviceClass}==\"00\"\n  ATTRS{product}==\"USB Camera\"\n  ...\n```\n\nМы используем параметры веб-камеры KERNEL==\"video2\" и SUBSYSTEM==\"video4linux\", затем мы возьмем идентификаторы производителя и изделия родительского USB-устройства SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"05a9\" и ATTRS{idProduct}==\"4519\" для сопоставления:\n\n```\n/etc/udev/rules.d/83-webcam.rules\n```\n\n```\nKERNEL==\"video[0-9]*\", SUBSYSTEM==\"video4linux\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"05a9\", ATTRS{idProduct}==\"4519\", SYMLINK+=\"video-cam\"\n```\n\nВ примере мы создали символическую ссылку, используя параметр SYMLINK+=\"video-cam\". Мы можем также легко задать владельца (OWNER=\"john\"), группу (GROUP=\"video\"), или установить права доступа к файлу ссылки (MODE=\"0660\").\n\nЕсли вы намереваетесь создать правило, которое делает что-нибудь при удалении устройства, имейте в виду, что атрибуты устройства могут стать недоступны. В этом случае вам необходимо использовать специальный набор переменных окружения. Чтобы отобразить эти переменные, выполните следующую команду при отсоединении устройства:\n\n```\n$ udevadm monitor --environment --udev\n```\n\nВ выводе команды вы увидите значения параметров устройства, например, ID_VENDOR_ID и ID_MODEL_ID, которые соответствуют использованным ранее идентификаторам производителя и изделия. Правило, которое использует переменные окружения устройства, может выглядеть следующим образом:\n\n```\n/etc/udev/rules.d/83-webcam-removed.rules\n```\n\n```\nACTION==\"remove\", SUBSYSTEM==\"usb\", ENV{ID_VENDOR_ID}==\"05a9\", ENV{ID_MODEL_ID}==\"4519\", RUN+=\"''/path/to/your/script''\"\n```\n\n"
    },
    {
      "title": "Список атрибутов устройства",
      "level": 3,
      "content": "Чтобы вывести все атрибуты устройства, которые вы можете использовать в написании правил udev, выполните:\n\n```\n$ udevadm info --attribute-walk --name=имя_устройства\n```\n\nЗамените имя_устройства текущим именем файла устройства, например, /dev/sda или /dev/ttyUSB0.\n\nЕсли вы не знаете имя файла устройства, вы можете также вывести все атрибуты по конкретному системному пути:\n\n```\n$ udevadm info --attribute-walk --path=/sys/class/backlight/acpi_video0\n```\n\nЧтобы сузить поле поиска, определите класс устройства и выполните:\n\n```\n$ ls /dev/класс/by-id\n```\n\nНайденную символическую ссылку (или файл, на который она указывает) можно использовать в параметре --name:\n\n```\n$ udevadm info --attribute-walk --name=/dev/input/by-id/usb-foostan_Corne-event-kbd\n```\n\n"
    },
    {
      "title": "Проверка правил перед загрузкой",
      "level": 3,
      "content": "Используйте команду:\n\n```\n# udevadm test $(udevadm info -q path -n имя_устройства) 2>&1\n```\n\nВы можете также указать прямой системный путь до устройства:\n\n```\n# udevadm test /sys/class/backlight/acpi_video0/\n```\n\n"
    },
    {
      "title": "Загрузка новых правил",
      "level": 3,
      "content": "udev способен определять наличие изменений в файлах правил автоматически, поэтому изменения сразу вступают в силу без необходимости перезапуска udev. Однако, новые правила не будут применены сразу к уже подключенным устройствам. Устройства с возможностью горячей замены, например, устройства USB, могут быть просто переподключены для применения к ним новых правил. Также вы можете перезагрузить модули ядра ohci-hcd и ehci-hcd, что автоматически приведет к перезагрузке всех драйверов для каждого USB-устройства.\n\nЕсли правила не перезагружаются автоматически, выполните:\n\n```\n# udevadm control --reload-rules\n```\n\nЧтобы вручную заставить udev применить ваши правила, выполните:\n\n```\n# udevadm trigger\n```\n\n"
    },
    {
      "title": "udisks",
      "level": 2,
      "content": "См. udisks.\n\n"
    },
    {
      "title": "Монтирование съёмных устройств",
      "level": 3,
      "content": "Монтировать съёмные устройства с помощью команды mount в правиле udev не стоит по двум причинам: (1) systemd по умолчанию запускает systemd-udevd.service с отдельным \"пространством имён монтирования\" (см. namespaces(7)), что означает, что данное устройство не будет видно из остальной системы. (2) Чтобы этого не происходило, можно закомментировать параметры PrivateMounts и MountFlags в файле службы, но тогда проявится другая проблема: запускаемые udev процессы система будет убивать по истечении нескольких секунд. В случае файловых систем FUSE, вроде NTFS, \"монтирование\" запустит в пространстве пользователя процесс для работы с файловой системой; затем процесс будет уничтожен и при попытке доступа к ФС вы получите ошибку Transport endpoint not connected.\n\nЕсть несколько возможных решений:\n\n- Из правила udev запускается пользовательская служба systemd; служба запустит сценарий, который, в свою очередь, может породить любое количество долгосрочных процессов (вроде FUSE). В качестве примера можно использовать утилиту udev-media-automount, разработанную для быстрого и надёжного автоматического монтирования устройств. Другой вариант той же идеи предложен в этом сообщении.\n- В правилах udev вместо команды mount можно использовать systemd-mount, как рекомендуют разработчики systemd. Пример монтирования USB-дисков в каталоге /media:\n\n```\nACTION==\"add\", SUBSYSTEMS==\"usb\", SUBSYSTEM==\"block\", ENV{ID_FS_USAGE}==\"filesystem\", RUN{program}+=\"/usr/bin/systemd-mount --no-block --automount=yes --collect $devnode /media\"\n```\n\n- Программы вроде udisks или udiskie. Мощные утилиты, хоть и с довольно сложной настройкой. Нужно учитывать, что они работают для одного пользовательского сеанса: доступ к некоторым файловым системам предоставляется только тому пользователю, сеанс которого активен в данный момент.\n\n"
    },
    {
      "title": "Доступ к программаторам и виртуальным COM-портам",
      "level": 3,
      "content": "Следующий набор правил даст возможность пользователям, входящим в группу users, получить доступ к USB-программаторам микроконтроллеров AVR USBtinyISP:\n\n```\n/etc/udev/rules.d/50-usbtinyisp.rules\n```\n\n```\nSUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"1781\", ATTRS{idProduct}==\"0c9f\", GROUP=\"users\", MODE=\"0660\"\nSUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"16c0\", ATTRS{idProduct}==\"0479\", GROUP=\"users\", MODE=\"0660\"\n```\n\nИдентификаторы производителя и изделия для других устройств можно узнать с помощью утилиты lsusb.\n\n"
    },
    {
      "title": "Выполнение команд при подключении VGA-монитора",
      "level": 3,
      "content": "Создайте правило /etc/udev/rules.d/95-monitor-hotplug.rules со следующим содержимым, чтобы запускать arandr при каждом подключении VGA-монитора:\n\n```\nKERNEL==\"card0\", SUBSYSTEM==\"drm\", ENV{DISPLAY}=\":0\", ENV{XAUTHORITY}=\"/home/username/.Xauthority\", RUN+=\"/usr/bin/arandr\"\n```\n\nНекоторые экранные менеджеры размещают файл .Xauthority вне домашнего каталога пользователя. В этом случае параметр ENV{XAUTHORITY} необходимо соответствующим образом изменить. Например, значение переменной XAUTHORITY для GNOME Display Manager:\n\n```\n$ printenv XAUTHORITY\n```\n\n```\n/run/user/1000/gdm/Xauthority\n```\n\n"
    },
    {
      "title": "Определение новых накопителей eSATA",
      "level": 3,
      "content": "Если ваш накопитель eSATA не был определен системой при подключении, вы можете перезагрузить систему, не отключая кабель устройства, либо, если перезагрузка нежелательна, выполнить:\n\n```\n# echo 0 0 0 | tee /sys/class/scsi_host/host*/scan\n```\n\nЕще один вариант заключается в использовании утилиты scsiaddAUR из AUR:\n\n```\n# scsiadd -s\n```\n\nНакопитель должен появиться в /dev. Если это не так, попробуйте выполнить:\n\n```\n# udevadm monitor\n```\n\nдо и после вышеприведенных команд и посмотреть, происходит ли что-нибудь.\n\n"
    },
    {
      "title": "Определение внутренних портов SATA как внешних",
      "level": 3,
      "content": "Если вы подключили eSATA-адаптер, система все еще будет распоздавать его как внутренний SATA-накопитель. GNOME и KDE будут постоянно запрашивать пароль администратора. Следующее правило помечает все указанные SATA-порты как порты eSATA, благодаря чему обычные пользователи смогут подключать свой накопитель eSATA к этому порту как USB-накопитель без запроса пароля администратора:\n\n```\n/etc/udev/rules.d/10-esata.rules\n```\n\n```\nDEVPATH==\"/devices/pci0000:00/0000:00:1f.2/host4/*\", ENV{UDISKS_SYSTEM}=\"0\"\n```\n\n```\n$ udevadm info --query=path /dev/sdb\n```\n\n```\n/devices/pci0000:00/0000:00:1f.2/host4/target4:0:0/4:0:0:0/block/sdb\n```\n\n```\n$ find /sys/devices/ -name sdb\n```\n\n```\n/sys/devices/pci0000:00/0000:00:1f.2/host4/target4:0:0/4:0:0:0/block/sdb\n```\n\n"
    },
    {
      "title": "Установка постоянных имен устройств",
      "level": 3,
      "content": "Из-за асинхронного способа загрузки модулей, они инициализируются в разном порядке от загрузки к загрузке. Это приводит к случайному переименованию устройств при каждом запуске. Чтобы задать постоянные имена вашим устройствам, можно создать специальное правило udev. Смотрите также статьи Постоянные имена для блочных устройств и Настройка сети#Смена имени интерфейса.\n\n"
    },
    {
      "title": "Видеоустройства",
      "level": 4,
      "content": "Процедура установки веб-камеры описана в статье Webcam setup.\n\nПри загрузке веб-камерам присваиваются случайные имена вида /dev/video*. Рекомендуемое решение состоит в создании символических ссылок с использованием правила udev (подобно правилу в разделе #Пример правила udev):\n\n```\n/etc/udev/rules.d/83-webcam.rules\n```\n\n```\nKERNEL==\"video[0-9]*\", SUBSYSTEM==\"video4linux\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"05a9\", ATTRS{idProduct}==\"4519\", SYMLINK+=\"video-cam1\"\nKERNEL==\"video[0-9]*\", SUBSYSTEM==\"video4linux\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"046d\", ATTRS{idProduct}==\"08f6\", SYMLINK+=\"video-cam2\"\n```\n\n"
    },
    {
      "title": "Принтеры",
      "level": 4,
      "content": "Если у вас несколько принтеров, им будут случайным образом присвоены имена вида /dev/lp[0-9], что, например, может помешать серверу CUPS правильно настроить устройства. Вы можете создать следующее правило, которое будет создавать постоянные символические ссылки в каталогах /dev/lp/by-id и /dev/lp/by-path подобно схеме, приведенной в статье Постоянные имена для блочных устройств:\n\n```\n/etc/udev/rules.d/60-persistent-printer.rules\n```\n\n```\nACTION==\"remove\", GOTO=\"persistent_printer_end\"\n# Это не должно понадобиться\n#KERNEL!=\"lp*\", GOTO=\"persistent_printer_end\"\n\nSUBSYSTEMS==\"usb\", IMPORT{builtin}=\"usb_id\"\nENV{ID_TYPE}!=\"printer\", GOTO=\"persistent_printer_end\"\n\nENV{ID_SERIAL}==\"?*\", SYMLINK+=\"lp/by-id/$env{ID_BUS}-$env{ID_SERIAL}\"\n\nIMPORT{builtin}=\"path_id\"\nENV{ID_PATH}==\"?*\", SYMLINK+=\"lp/by-path/$env{ID_PATH}\"\n\nLABEL=\"persistent_printer_end\"\n```\n\n"
    },
    {
      "title": "Определение диска по серийному номеру",
      "level": 3,
      "content": "Действия с дисковыми устройствами /dev/sdX можно выполнять на основании серийного номера ID_SERIAL_SHORT, который можно узнать из вывода команды udevadm info /dev/sdX. Примерное правило udev для этого случая приведено ниже. В параметре RUN сценарию передаётся имя устройства; это сделано исключительно в иллюстративных целях:\n\n```\n/etc/udev/rules.d/69-disk.rules\n```\n\n```\nACTION==\"add\", KERNEL==\"sd[a-z]\", ENV{ID_SERIAL_SHORT}==\"СЕРИЙНЫЙ_НОМЕР\", RUN+=\"/путь/к/файлу/сценария /dev/%k\"\n```\n\n"
    },
    {
      "title": "Пробуждение при активности USB-устройства",
      "level": 3,
      "content": "С помощью правила udev можно настроить систему выходить из режима сна при активности USB-устройств, например, мыши или клавиатуры.\n\nПервым делом определите идентификаторы производителя и изделия для вашего устройства:\n\n```\n$ lsusb | grep Logitech\n```\n\n```\nBus 007 Device 002: ID 046d:c52b Logitech, Inc. Unifying Receiver\n```\n\nЗатем найдите, куда данное устройство подключено:\n\n```\n$ grep c52b /sys/bus/usb/devices/*/idProduct\n```\n\n```\n/sys/bus/usb/devices/1-1.1.1.4/idProduct:c52b\n```\n\nНаконец, создайте правило, которое при подключении будет изменять атрибут power/wakeup как для устройства, так и для USB-контроллера, к которому оно подключено:\n\n```\n/etc/udev/rules.d/50-wake-on-device.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"usb\", DRIVERS==\"usb\", ATTRS{idVendor}==\"046d\", ATTRS{idProduct}==\"c52b\", ATTR{power/wakeup}=\"enabled\", ATTR{driver/1-1.1.1.4/power/wakeup}=\"enabled\"\n```\n\n"
    },
    {
      "title": "Генерирование событий",
      "level": 3,
      "content": "Может быть полезно сгенерировать различные события udev. Например, вы хотите симулировать отключение USB-устройства на удалённой машине. В таких случаях, используйте udevadm trigger:\n\n```\n# udevadm trigger --verbose --type=subsystems --action=remove --subsystem-match=usb --attr-match=\"idVendor=abcd\"\n```\n\nЭта команда симулирует отключение всех USB-устройств с указанным идентификатором поставщика idVendor.\n\n"
    },
    {
      "title": "Уведомления на рабочем столе",
      "level": 3,
      "content": "Заставить правильно работать из правила udev сценарий, содержащий команду notify-send, может оказаться непростой задачей, потому что уведомления не будут выводиться на рабочий стол. Ниже показано, какие файлы, команды и переменные окружения необходимо задйствовать, чтобы notify-send работала как положено.\n\n1) Следующее правило udev запускает сценарий, создающий графическое и звуковое уведомление, когда яркость экрана меняется в зависимости от способа питания ноутбука:\n\n```\n/etc/udev/rules.d/99-backlight_notification.rules\n```\n\n```\n# Правило на случай переключения на работу от батареи\nACTION==\"change\", SUBSYSTEM==\"power_supply\", ATTR{type}==\"Mains\", ATTR{online}==\"0\", ENV{DISPLAY}=\":0\", ENV{XAUTHORITY}=\"/home/USERNAME/.Xauthority\" RUN+=\"/usr/bin/su USERNAME_TO_RUN_SCRIPT_AS -c /usr/local/bin/brightness_notification.sh\"\n# Правило на случай переключения на работу от кабеля\nACTION==\"change\", SUBSYSTEM==\"power_supply\", ATTR{type}==\"Mains\", ATTR{online}==\"1\", ENV{DISPLAY}=\":0\", ENV{XAUTHORITY}=\"/home/USERNAME/.Xauthority\" RUN+=\"/usr/bin/su USERNAME_TO_RUN_SCRIPT_AS -c /usr/local/bin/brightness_notification.sh\"\n```\n\n- USERNAME_TO_RUN_SCRIPT_AS и USERNAME необходимо заменить на имя пользователя, который запустил графический сеанс;\n- сценарий должен запускаться командой /usr/bin/su, чтобы его владельцем считался не root, а пользователь, который запустил графический сеанс и для которого будут выводиться уведомления.\n\n2) Содержимое сценария, который запускается правилом udev:\n\n```\n/usr/local/bin/brightness_notification.sh\n```\n\n```\n#!/usr/bin/env bash\n\nexport XAUTHORITY=/home/USERNAME_TO_RUN_SCRIPT_AS/.Xauthority\nexport DISPLAY=:0\nexport DBUS_SESSION_BUS_ADDRESS=\"unix:path=/run/user/UID_OF_USER_TO_RUN_SCRIPT_AS/bus\"\n\n/usr/bin/sudo -u USERNAME_TO_RUN_SCRIPT_AS /usr/bin/paplay --server=/run/user/UID_OF_USER_TO_RUN_SCRIPT_AS/pulse/native /home/USERNAME/.i3/sounds/Click1.wav > /dev/null 2>&1\n\n/usr/bin/notify-send --icon=/usr/share/icons/gnome/256x256/status/battery-full-charging.png 'Changing Power States' --expire-time=4000\n```\n\n- USERNAME_TO_RUN_SCRIPT_AS, UID_OF_USER_TO_RUN_SCRIPT_AS и USERNAME необходимо заменить на имя и идентификатор пользователя, запустившего графический сеанс;\n- команда /usr/bin/sudo воспроизводит звуковое уведомление с помощью pulseaudio;\n- для пользователя, запустившего графический сеанс, в котором будут отображаться уведомления, необходимо определить и экспортировать три переменные окружения (XAUTHORITY, DISPLAY и DBUS_SESSION_BUS_ADDRESS).\n\n3) Загрузите/перезагрузите новое правило udev и проверьте, как оно работает, выдернув или подключив кабель питания ноутбука.\n\n"
    },
    {
      "title": "Создание долгосрочных процессов",
      "level": 3,
      "content": "Программы, запущенные udev, блокируют последующие события от данного устройства, а любые процессы, порождённые правилом udev, завершаются сразу после обработки события. Если вы хотите запустить долгосрочный процесс с помощью udev, то либо используйте at (например, ваша_команда | at now или batch), либо создайте юнит systemd, который можно запустить из правила udev.\n\n"
    },
    {
      "title": "Добавление модулей в черный список",
      "level": 3,
      "content": "Иногда udev может ошибочно загружать неправильные модули ядра. Чтобы избежать этого, добавьте такие модули в чёрный список. Если модуль находится в чёрном списке, udev будет игнорировать его как при загрузке, так и при более позднем \"горячем\" подключении внешнего устройства (например, USB-носителя).\n\n"
    },
    {
      "title": "Отладочная печать",
      "level": 3,
      "content": "Если задать параметр ядра udev.log-priority=debug, то аппаратное обеспечение будет выдавать отладочную информацию. Другой способ — задать параметр\n\n```\n/etc/udev/udev.conf\n```\n\n```\nudev_log=\"debug\"\n```\n\nЧтобы добавить эту опцию в initramfs, укажите файл настроек udev в строке FILES\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nFILES=\"... /etc/udev/udev.conf\"\n```\n\nпосле чего сгенерируйте initramfs.\n\n"
    },
    {
      "title": "udevd вылетает при загрузке",
      "level": 3,
      "content": "После миграции на LDAP или обновления системы, использующей LDAP, udevd может начать аварийно завершаться в момент загрузки системы с сообщением \"Starting UDev Daemon\". Обычно это происходит потому, что udevd пытается определить имя через LDAP, но не может, так как в этот момент еще не установлено подключение к сети.\n\nНеобходимо, чтобы все используемые в LDAP группы были продублированы локально. Получить имена групп, используемых в правилах udev, и имена групп, присутствующих в системе, можно командами:\n\n```\n# grep -Fr GROUP /etc/udev/rules.d/ /usr/lib/udev/rules.d/ | sed 's:.*GROUP=\"\\([-a-z_]\\{1,\\}\\)\".*:\\1:' | sort -u >udev_groups\n# cut -d: -f1 /etc/gshadow /etc/group | sort -u >present_groups\n```\n\nВывод будет записан в файлы present_groups и udev_groups. Чтобы увидеть различия, выполните построчное сравнение командой diff:\n\n```\n# diff -y present_groups udev_groups\n...\nnetwork\t\t\t\t\t\t\t      <\nnobody\t\t\t\t\t\t\t      <\nntp\t\t\t\t\t\t\t      <\noptical\t\t\t\t\t\t\t\toptical\npower\t\t\t\t\t\t\t      |\tpcscd\nrfkill\t\t\t\t\t\t\t      <\nroot\t\t\t\t\t\t\t\troot\nscanner\t\t\t\t\t\t\t\tscanner\nsmmsp\t\t\t\t\t\t\t      <\nstorage\t\t\t\t\t\t\t\tstorage\n...\n```\n\nВ данном примере группа pcscd по какой-то причине отсутствует в системе. Все такие группы необходимо добавить в систему. Также убедитесь, что имена всех локальных ресурсов разрешены, прежде чем возвращаться к LDAP. Файл /etc/nsswitch.conf должен содержать следующую строку:\n\n```\ngroup: files ldap\n```\n\n"
    },
    {
      "title": "Устройство является съемным, однако не признается таковым",
      "level": 3,
      "content": "Создайте правило udev для конкретного устройства. Чтобы получить подробную информацию об устройстве вы можете либо использовать ID_SERIAL, либо ID_SERIAL_SHORT (не забудьте поменять /dev/sdb если нужно):\n\n```\n$ udevadm info /dev/sdb | grep ID_SERIAL\n```\n\nТеперь установите UDISKS_AUTO=\"1\", чтобы пометить устройство для автоматического монтирования и UDISKS_SYSTEM=\"0\", чтобы пометить устройство как съёмное. Подробнее см. udisks(8)\n\n```\n/etc/udev/rules.d/99-removable.rules\n```\n\n```\nENV{ID_SERIAL_SHORT}==\"серийный_номер\", ENV{UDISKS_AUTO}=\"1\", ENV{UDISKS_SYSTEM}=\"0\"\n```\n\nПерезагрузите правила udev командой udevadm control --reload. Теперь ваше устройство будет распознаваться как съёмное.\n\n"
    },
    {
      "title": "Проблемы с автоматической загрузкой модулей аудиоустройств",
      "level": 3,
      "content": "Некоторые пользователи испытывают проблемы с загрузкой модулей звуковых устройств, для которых остались старые записи в /etc/modprobe.d/sound.conf. Чистка файла от таких записей может помочь.\n\n"
    },
    {
      "title": "Поддержка дисководов IDE",
      "level": 3,
      "content": "Начиная с версии 170, udev не поддерживает устройства CD-ROM/DVD-ROM, загружаемые как обычные IDE дисководы модулем ide_cd_mod и отображаемые в системе как /dev/hd*. Дисковод доступен только программам, которые обращаются к устройству напрямую, таким как cdparanoia, но невидим для более высокоуровневых программ вроде KDE.\n\nПричина, по которой загрузка модуля ide_cd_mod имеет приоритет перед другими модулями, например, sr_mod, может заключаться в том, что по какой-либо причине модуль piix загружается в вашем initramfs. В этом случае вы можете просто заменить его в файле /etc/mkinitcpio.conf на ata_piix.\n\n"
    },
    {
      "title": "Оптические дисководы имеют неверный group ID",
      "level": 3,
      "content": "Если значение group ID вашего дисковода установлено как disk, но вы хотите, чтобы оно было optical, вам следует создать такое правило:\n\n```\n/etc/udev/rules.d\n```\n\n```\n# permissions for IDE CD devices\nSUBSYSTEMS==\"ide\", KERNEL==\"hd[a-z]\", ATTR{removable}==\"1\", ATTRS{media}==\"cdrom*\", GROUP=\"optical\"\n\n# permissions for SCSI CD devices\nSUBSYSTEMS==\"scsi\", KERNEL==\"s[rg][0-9]*\", ATTRS{type}==\"5\", GROUP=\"optical\"\n```\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- udev(7)\n- Введение в udev (англ.)\n- Почтовая рассылка udev (англ.)\n- Сценарии udev (англ.)\n- Правила udev (англ.)\n- Организация устройств и модулей в LFS (англ.)\n- GUI и переменные экрана в правилах udev (англ.)\n\n"
    }
  ]
}