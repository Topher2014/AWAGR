{
  "title": "Cross-compiling tools package guidelines (Русский)",
  "url": "https://wiki.archlinux.org/title/Cross-compiling_tools_package_guidelines_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Font – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust – Shell – VCS – Web – Wine\n\nДанная статья описывает создание пакетов с инструментами для кросс-компиляции. Другим способом кросс-компиляции является использование distcc на смешанных архитектурах. Смотрите distcc#Cross compiling with distcc.\n\n"
    },
    {
      "title": "Важная заметка",
      "level": 2,
      "content": "На этой странице описан новый принцип работы, основанный на следующих пакетах:\n\n- mingw-w64-gcc и другие пакеты из mingw-w64-* серии\n- arm-none-eabi-gcc и другие пакеты из arm-none-eabi-* серии\n- другие пакеты из arm-wince-cegcc-* серии\n\n"
    },
    {
      "title": "Совместимость версий",
      "level": 2,
      "content": "Note: **все** \n\nСледующая стратегия позволяют выбирать совместимые версии gcc, binutils, ядра и библиотеки C:\n\n- Основные правила: существует корреляция между выпусками gcc и binutils, используйте одновременно выпущенные версии; лучше использовать последние заголовки ядра для компиляции libc, но использовать переключатель --enable-kernel (специфично для glibc, другие библиотеки C могут использовать другие соглашения) для обеспечения работы на старых ядрах;\n- Официальные репозитории: вам, возможно, придётся использовать дополнительные исправления и хаки, но версии, используемые в Arch Linux (или специфичные ответвления для архитектуры), скорее всего, можно заставить работать вместе;\n- Документация по программному обеспечению: все программы GNU имеют файлы README и NEWS, документирующие такие вещи, как минимально необходимые зависимости;\n- Другие дистрибутивы: они тоже делают кросс-компиляцию\n- https://trac.clfs.org описывает шаги, необходимые для сборки кросс-компилятора, и упоминает несколько актуальных версий зависимостей.\n\n- существует корреляция между выпусками gcc и binutils, используйте одновременно выпущенные версии;\n- лучше использовать последние заголовки ядра для компиляции libc, но использовать переключатель --enable-kernel (специфично для glibc, другие библиотеки C могут использовать другие соглашения) для обеспечения работы на старых ядрах;\n\n"
    },
    {
      "title": "Сборка кросс-компилятора",
      "level": 2,
      "content": "Общий подход к созданию кросс-компилятора:\n\n1. binutils: Создание cross-binutils, которая связывает и обрабатывает для целевой архитектуры\n1. headers: Установите набор библиотеки C и заголовками ядра для целевой архитектуры используйте linux-api-headers в качестве образца и передайте ARCH=target-architecture для make создайте пакет заголовков libc (для Glibc процесс описан здесь)\n1. gcc-stage-1: Создайте базовый (этап 1) gcc кросс-компилятор. Будет использоваться для компиляции библиотеки C. Он не сможет собирать почти что угодно другое (потому что он не сможет слинковаться с библиотекой C, которой на данном этапе ещё нет).\n1. libc: Соберите библиотеку C (используя кросс-компилятор из этапа 1).\n1. gcc-stage-2: Сборка полного кросс-компилятора C (этап 2)\n\n1. используйте linux-api-headers в качестве образца и передайте ARCH=target-architecture для make\n1. создайте пакет заголовков libc (для Glibc процесс описан здесь)\n\nИсточник заголовков и libc будет отличаться для разных платформ.\n\n"
    },
    {
      "title": "Наименование пакета",
      "level": 2,
      "content": "В имени пакета не должно быть префикса со словом cross- (было предложено ранее, но не было принято в официальных пакетах, возможно, из-за дополнительной длины имен), и должно состоять из имени пакета с префиксом GNU triplet без поля поставщика или со значением \"unknown\" в поле поставщика; пример: arm-linux-gnueabihf-gcc. Если существует более короткое соглашение об именах (например, mips-gcc), его можно использовать, но это не рекомендуется.\n\n"
    },
    {
      "title": "Размещение файлов",
      "level": 2,
      "content": "Последние версии gcc и binutils используют не конфликтующие пути для sysroot и библиотек. Исполняемые файлы должны быть помещены в /usr/bin/, чтобы предотвратить возникновение конфликтов, перед всеми ними необходимо указать префикс имени архитектуры.\n\nКак правило, ./configure будет иметь по крайней мере следующие параметры:\n\n```\n_target=your_target\n_sysroot=/usr/lib/${_target}\n...\n./configure \\\n    --prefix=${_sysroot} \\\n    --sysroot=${_sysroot} \\\n    --bindir=/usr/bin\n```\n\nгде your_target может быть, например, \"i686-pc-mingw32\".\n\n"
    },
    {
      "title": "Пример",
      "level": 2,
      "content": "Это PKGBUILD для binutils для MinGW. Вещи, на которые стоит обратить внимание:\n\n- указание корневого каталога кросс-окружения\n- использование переменных ${_pkgname} , ${_target} и ${_sysroot} , чтобы сделать код более читабельным\n- удаление дублированных / конфликтующих файлов\n\n```\n# Maintainer: Allan McRae <allan@archlinux.org>\n\n# cross toolchain build order: binutils, headers, gcc (pass 1), w32api, mingwrt, gcc (pass 2)\n\n_target=i686-pc-mingw32\n_sysroot=/usr/lib/${_target}\n\npkgname=${_target}-binutils\n_pkgname=binutils\npkgver=2.19.1\npkgrel=1\npkgdesc=\"MinGW Windows binutils\"\narch=('i686' 'x86_64')\nurl=\"http://www.gnu.org/software/binutils/\"\nlicense=('GPL')\ndepends=('glibc>=2.10.1' 'zlib')\noptions=('!libtool' '!distcc' '!ccache')\nsource=(http://ftp.gnu.org/gnu/${_pkgname}/${_pkgname}-${pkgver}.tar.bz2)\nmd5sums=('09a8c5821a2dfdbb20665bc0bd680791')\n\nbuild() {\n  cd ${srcdir}/${_pkgname}-${pkgver}\n  mkdir binutils-build && cd binutils-build\n\n  ../configure --prefix=${_sysroot} --bindir=/usr/bin \\\n    --with-sysroot=${_sysroot} \\\n    --build=$CHOST --host=$CHOST --target=${_target} \\\n    --with-gcc --with-gnu-as --with-gnu-ld \\\n    --enable-shared --without-included-gettext \\\n    --disable-nls --disable-debug --disable-win32-registry\n  make\n  make DESTDIR=${pkgdir}/ install\n  \n  # clean-up cross compiler root\n  rm -r ${pkgdir}/${_sysroot}/{info,man}\n}\n```\n\nNote: **make** \n\n"
    },
    {
      "title": "Почему бы не устанавливать в /opt",
      "level": 3,
      "content": "Две причины:\n\n1. Во-первых, согласно File Hierarchy Standard, эти файлы просто должны быть в /usr. И точка!\n1. Во-вторых, установка в /opt является крайней мерой, когда других вариантов нет.\n\n"
    },
    {
      "title": "Что за \"out-of-path executables\"?",
      "level": 3,
      "content": "Размещение исполняемых файлов за пределами path — эта такая странная штука, которая облегчает кросс-компиляцию. В некоторых проектах Makefile не использует CC и другие подобные переменные, а вместо них напрямую используют gcc. Если вы просто хотите попробовать выполнить кросс-компиляцию такого проекта, то редактирование Makefile может оказаться весьма долгой операцией. Однако изменение $PATH на использование в первую очередь «наших» исполняемых файлов — очень быстрое решение. Вместо простого make можно запустить что-то вроде PATH=/usr/архитектура/bin/:$PATH make, и тогда при сборке будет использоваться инструментарий кросс-компиляции.\n\n"
    },
    {
      "title": "Что делать, если компиляция не удалась без внятного сообщения об ошибке?",
      "level": 3,
      "content": "Если ошибка возникла во время выполнения configure, почитайте $srcdir/pkgname-build/config.log. Для ошибки, произошедшей во время компиляции, прокрутите лог консоли вверх или поищите слово \"error\".\n\n"
    },
    {
      "title": "Что означает эта ошибка [error message]?",
      "level": 3,
      "content": "Скорее всего, вы допустили некоторые неочевидные ошибки:\n\n- Слишком много или слишком мало флагов конфигурации. Попробуйте использовать уже проверенный набор флагов.\n- Зависимости повреждены. Например, отсутствующие или размещённые не там файлы binutils могут привести к загадочной ошибке во время настройки gcc.\n- Вы не добавили export CFLAGS=\"\" в свою функцию build() (см. bug 25672 в GCC Bugzilla).\n- Для некоторых комбинаций --prefix/--with-sysroot может потребоваться, чтобы каталоги были доступны для записи (что не очевидно из руководства clfs).\n- В sysroot нет заголовков ядра или libc.\n- Если вдумчивое гугление не помогает, отмените текущую конфигурацию и попробуйте более стабильную/проверенную.\n\n"
    },
    {
      "title": "Почему файлы устанавливаются в неправильных местах?",
      "level": 3,
      "content": "Различные методы запуска make install приводят к разным результатам. Например, некоторые цели make могут не обеспечивать поддержку DESTDIR, а вместо этого требуют использования install_root. То же самое для tooldir, prefix и других подобных аргументов. Иногда предоставление параметров в качестве аргументов вместо переменных окружения, например\n\n```\n./configure CC=arm-elf-gcc\n```\n\nвместо\n\n```\nCC=arm-elf-gcc ./configure\n```\n\nи наоборот, может привести к различным результатам (часто вызванным рекурсивным самовывозом configure/make).\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- https://wiki.osdev.org/GCC_Cross-Compiler\n\n"
    }
  ]
}