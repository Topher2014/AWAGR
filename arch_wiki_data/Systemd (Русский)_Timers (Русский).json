{
  "title": "Systemd (Русский)/Timers (Русский)",
  "url": "https://wiki.archlinux.org/title/Systemd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)/Timers_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- systemd (Русский)\n- systemd/Пользователь\n- systemd FAQ\n- cron (Русский)\n\nТаймеры — файлы юнитов systemd, имя которых имеет суффикс .timer; они позволяют контролировать файлы .service или события. Таймеры могут использоваться в качестве замены cron (смотрите #В качестве замены cron). Таймеры имеют встроенную поддержку календарных и регулярных событий и могут запускаться в асинхронном режиме.\n\n"
    },
    {
      "title": "Юниты таймера",
      "level": 2,
      "content": "Таймеры systemd — файлы юнитов с суффиксом .timer. Они хранятся в тех же каталогах, что и другие файлы настроек юнитов, но включают в себя раздел [Timer], который определяет, как и когда таймер запускается. Существует два типа таймеров:\n\n- Таймеры реального времени (также известные как настенные часы) запускаются в зависимости от событий календаря (как cronjobs). Для определения таких таймеров используется опция OnCalendar=.\n- Монотонные таймеры активируются после определенного промежутка времени по отношению к той или иной отправной точке. Они не сработают, если компьютер находится в режиме ожидания или выключен. Есть несколько различных монотонных таймеров, но все они имеют вид: OnTypeSec=. Обычно монотонные таймеры включают в себя OnBootSec и OnUnitActiveSec.\n\nПодробнее см. systemd.timer(5). Синтаксис аргументов для календарных событий и временных промежутков можно найти в systemd.time(7).\n\n"
    },
    {
      "title": "Юнит службы",
      "level": 2,
      "content": "Каждому файлу .timer соответствует файл .service (например, foo.timer и foo.service). .timer запускается и контролирует .service. .service не требует раздела [Install], так как последний присутствует в юните timer, который уже включен. Если необходимо, то можно контролировать юниты с разным названием, используя опцию Unit= в таймере в разделе [Timer].\n\n"
    },
    {
      "title": "Управление",
      "level": 2,
      "content": "Для того, чтобы использовать юнит-timer, включите и запустите его, как любой другой юнит (не забудьте добавить суффикс .timer). Для того, чтобы увидеть все запущенные таймеры, выполните:\n\n```\n$ systemctl list-timers\n```\n\n```\nNEXT                          LEFT        LAST                          PASSED     UNIT                         ACTIVATES\nThu 2014-07-10 19:37:03 CEST  11h left    Wed 2014-07-09 19:37:03 CEST  12h ago    systemd-tmpfiles-clean.timer systemd-tmpfiles-clean.service\nFri 2014-07-11 00:00:00 CEST  15h left    Thu 2014-07-10 00:00:13 CEST  8h ago     logrotate.timer              logrotate.service\n```\n\n- Чтобы увидеть все таймеры (в том числе и неактивные), используйте systemctl list-timers --all.\n- Статус службы, запускаемой посредством таймера, вероятно, будет неактивным, если, конечно, она не была запущена непосредственно перед проверкой статуса.\n- Если таймер рассинхронизировался, то может помочь удаление соответствующих файлов stamp-* в /var/lib/systemd/timers (или ~/.local/share/systemd/). Это файлы нулевого размера, которые отмечают последнее время запуска таймера. Если данные файлы отсутствуют, то они будут перестроены при следующем запуске соответствующего таймера.\n\n"
    },
    {
      "title": "Примеры",
      "level": 2,
      "content": "Запуск службы может быть запланирован по таймеру. В последующих примерах назначается запуск foo.service в соответствии с таймером foo.timer.\n\n"
    },
    {
      "title": "Монотонный таймер",
      "level": 3,
      "content": "Таймер, который запустится через 15 минут после загрузки, а затем снова будет запускаться каждую неделю во время работы системы.\n\n```\n/etc/systemd/system/foo.timer\n```\n\n```\n[Unit]\nDescription=Run foo weekly and on boot\n\n[Timer]\nOnBootSec=15min\nOnUnitActiveSec=1w \n\n[Install]\nWantedBy=timers.target\n```\n\n"
    },
    {
      "title": "Таймер реального времени",
      "level": 3,
      "content": "Таймер, который будет запускаться один раз в неделю (в 12:00 в понедельник). При активации он сразу же запустит службу, если отсутствует последнее время запуска (опция Persistent=true), например, в связи с отключением системы:\n\n```\n/etc/systemd/system/foo.timer\n```\n\n```\n[Unit]\nDescription=Run foo weekly\n\n[Timer]\nOnCalendar=weekly\nPersistent=true     \n \n[Install]\nWantedBy=timers.target\n```\n\nЕсли требуется указать более точную дату и время, используйте следующий формат:\n\n```\nДеньНедели Год-Месяц-День Часы:Минуты:Секунды\n```\n\nЗвездочка может быть использована, чтобы указать все значения, а запятые, в свою очередь, для перечисления возможных значений. Используйте .., чтобы выделить какой-то конкретный промежуток. В следующем примере служба запускается в первые четыре дня каждого месяца в полдень, но только если день является понедельником или вторником.\n\n```\nOnCalendar=Mon,Tue *-*-01..04 12:00:00\n```\n\nЗапуск службы в первую субботу каждого месяца:\n\n```\nOnCalendar=Sat *-*-1..7 18:00:00\n```\n\nПо крайней мере один день должен быть указан при использовании ДеньНедели. Таймер, который будет запускаться каждый день в 4 утра:\n\n```\nOnCalendar=*-*-* 4:00:00\n```\n\nЕсли необходимо запускать службу в разное время, то можно указать параметр OnCalendar несколько раз. В примере ниже служба запускается в 22:30 по рабочим дням и в 20:00 по выходным:\n\n```\nOnCalendar=Mon..Fri 22:30\nOnCalendar=Sat,Sun 20:00\n```\n\nПодробнее см. systemd.time(7).\n\n- Указатели времени OnCalendar могут быть протестированы для того, чтобы проверить их правильность и вычислить следующее время срабатывания условия. Например, systemd-analyze calendar weekly или systemd-analyze calendar \"Mon,Tue *-*-01..04 12:00:00\".\n- Команда faketime полезна для тестирования с командой выше. Установите пакет libfaketime.\n- Специальные выражения событий, такие как daily и weekly, относятся к конкретному времени начала и, таким образом, все таймеры, использующие эти выражения, запустятся одновременно. Таймеры, использующие специальные выражения, могут негативно сказаться на производительности системы, если сервисы, запускаемые таймерами, являются ресурсозатратными. Опция RandomizedDelaySec в разделе [Timer] помогает избежать подобных проблем посредством случайного выбора времени запуска каждого из таймеров. Смотрите systemd.timer(5).\n- Добавьте опцию AccuracySec=1us в раздел [Timer], чтобы не использовать значение погрешности 1m, установленное по умолчанию. См. также systemd.timer(5).\n\n"
    },
    {
      "title": "Временные юниты .timer",
      "level": 2,
      "content": "Можно использовать systemd-run для создания временных юнитов .timer. То есть можно назначить запуск определённой команды в нужное время, не имея соответствующего файла службы. Например, следующая команда создаст файл через 30 секунд:\n\n```\n# systemd-run --on-active=30 /bin/touch /tmp/foo\n```\n\nКроме того, можно указать предварительно существующий файл сервиса, при этом не имея файла таймера. Например, запустим юнит, который называется некоторыйюнит.service, через 12.5 часов:\n\n```\n# systemd-run --on-active=\"12h 30m\" --unit некоторыйюнит.service\n```\n\nСмотрите systemd-run(1) для получения дополнительной информации и примеров.\n\n"
    },
    {
      "title": "В качестве замены cron",
      "level": 2,
      "content": "Несмотря на то, что cron, возможно, самый известный планировщик задач, таймеры systemd могут выступать в качестве альтернативы.\n\n"
    },
    {
      "title": "Преимущества",
      "level": 3,
      "content": "Основные преимущества использования таймеров приходят от каждой задачи, которая имеет собственную службу systemd. Вот некоторые из этих преимуществ:\n\n- Задачи могут быть легко запущены независимо от их таймеров. Это упрощает отладку.\n- Каждая задача может быть настроена для работы в определенной среде (смотрите systemd.exec(5)).\n- Задачи могут быть присоединены к cgroups.\n- Задачи могут быть настроены в зависимости от других юнитов systemd.\n- Задачи регистрируются в журнале systemd для легкости отладки.\n\n"
    },
    {
      "title": "Предостережения",
      "level": 3,
      "content": "Некоторые вещи, которые легко сделать посредством cron, трудно сделать только юнитами таймера.\n\n- Создание: чтобы настроить задачу, запускаемую в определенное время, при помощи systemd, вам нужно создать два файла и использовать команды systemctl. Сравните это с добавлением одной строчки в crontab.\n- Электронная почта: отсутствие встроенного эквивалента cron MAILTO для отправки писем при сбое. В следующем разделе приведен пример создания эквивалента с использованием OnFailure=.\n\nТакже обратите внимание, что пользовательские юниты-таймеры будут запускаться только тогда, когда активен сеанс соответствующего пользователя. Тем не менее, долговременные службы могут запускаться при загрузке системы даже если пользователь не выполнил вход.\n\n"
    },
    {
      "title": "MAILTO",
      "level": 3,
      "content": "Вы можете настроить systemd для отправки электронной почты при сбое юнита - так же, как Cron делает с MAILTO. Прежде всего, нужно два файла: исполняемый для посылки почты и .service для запуска первого. В следующем примере, исполняемый файл - скрипт, использующий sendmail, который можно найти в пакетах, предоставляющих smtp-forwarder.:\n\n```\n/usr/local/bin/systemd-email\n```\n\n```\n#!/bin/sh\n\n/usr/bin/sendmail -t <<ERRMAIL\nTo: $1\nFrom: systemd <root@$HOSTNAME>\nSubject: $2\nContent-Transfer-Encoding: 8bit\nContent-Type: text/plain; charset=UTF-8\n\n$(systemctl status --full \"$2\")\nERRMAIL\n```\n\nИсполняемый файл, видимо, должен получать минимум два аргумента, полученных сценарием: адрес для отправки и файл юнита для получения статуса. Файл .service, который мы создадим, будет передавать эти аргументы:\n\n```\n/etc/systemd/system/status_email_user@.service\n```\n\n```\n[Unit]\nDescription=status email for %i to user\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/systemd-email address %i\nUser=nobody\nGroup=systemd-journal\n```\n\nЗдесь user — получатель почты, а address — адрес электронной почты пользователя. Хотя получать \"захардкожен\", файл юнита для отчёта передается как параметр экзепляра, поэтому данная служба может посылать электронные письма множеству юнитов. Запустите status_email_user@dbus.service, чтобы убедиться, что вы можете получать почту.\n\nЗатем просто отредактируйте службу, от которой вы хотите получать почту и добавьте OnFailure=status_email_user@%n.service в раздел [Unit]. %n передает имя юнита в шаблон.\n\n- Если вы настроили sSMTP в соответствии с sSMTP#Security, то пользователь nobody не будет иметь доступа к /etc/ssmtp/ssmtp.conf и команда systemctl start status_email_user@dbus.service не сработает. Одним из решений является использование root-пользователя в юните status_email_user@.service.\n- Если вы попробуете использовать mail -s somelogs address в почтовом скрипте, mail создаст свой форк и systemd убьет процесс посылки почты, когда увидит, что скрипт завершился. Можно сделать так, чтобы почтовый процесс не создавал своих форков путем выполнения mail -Ssendwait -s somelogs address.\n\n"
    },
    {
      "title": "Использование crontab",
      "level": 3,
      "content": "Некоторые из предостережений можно обойти путем установки пакета, который анализирует crontab, а затем настраивает таймеры на его основе. systemd-cron-nextAUR[ссылка недействительна: package not found] и systemd-cronAUR — два таких пакета. Они могут предоставлять недостающую функцию MAILTO.\n\nЕсли вам нравится crontabs только потому, что он предоставляет единый вид для всех запланированных задач, systemctl делает тоже самое. Смотрите #Управление\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- systemd.timer(5)\n- Fedora:Features/SystemdCalendarTimers\n- Gentoo:Systemd#Timer services\n- systemd-cron-next — утилита для создания таймеров/служб из файлов crontab и anacrontab\n\n- systemd-cron — предоставляет юнитам systemd запускать скрипты cron; используя systemd-crontab-generator для конвертации crontab'ов\n\n- Systemd Timers for Scheduling Tasks\n\n"
    }
  ]
}