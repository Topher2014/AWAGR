{
  "title": "Command shell (日本語)",
  "url": "https://wiki.archlinux.org/title/Command_shell_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- ドットファイル\n- Core Utilities\n\nWikipedia より:\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 シェル一覧 1.1 POSIX準拠 1.2 代替シェル\n- 2 デフォルトシェルを変更する\n- 3 シェルのアンインストール\n- 4 ログインシェル\n- 5 設定ファイル 5.1 /etc/profile 5.2 標準化\n- 6 入出力\n- 7 参照\n\n- 1.1 POSIX準拠\n- 1.2 代替シェル\n\n- 5.1 /etc/profile\n- 5.2 標準化\n\n"
    },
    {
      "title": "シェル一覧",
      "level": 2,
      "content": "POSIX に(多かれ少なかれ)準拠しているシェルは #POSIX準拠 に、異なる構文を持つシェルは #代替シェル にリストアップされています。\n\n"
    },
    {
      "title": "POSIX準拠",
      "level": 3,
      "content": "これらのシェルはすべて /usr/bin/sh からリンクできます。Bash、 mkshAUR、 zsh、 を sh という名前で呼び出すと、自動的に POSIX に準拠するようになります。\n\n- Bash — Bash は Bourne シェルを拡張したもので、コマンドライン履歴と補完、インデックス付き連想配列、整数演算、プロセス置換、ヒア文字列、正規表現マッチング、およびブレース展開などの機能を備えています。\n\n- DASH — 可能な限り小さくなるように作られた POSIX 互換の /bin/sh の実装です。なるべく速度を犠牲にしないように作られています。実際に、ほとんどの処理で Bash (GNU Bourne-Again SHell) よりも高速に動きます。\n\n- Korn shell — KornShell 言語は AT&T ベル研究所の David G. Korn によって設計・開発されました。様々なコンピューター・ワークステーションから UNIX などのシステムにアクセスすることができるインタラクティブなコマンド言語です。また、KornShell 言語はアプリケーションを書くのに使える完全でパワフルな高級プログラミング言語でもあり、多くの場合、他の高級言語よりも簡単で高速です。このため特にプロトタイピングに適しています。他に広く使われているシェルとして、AT&T ベル研究所の Steven Bourne によって開発された Bourne シェルと、カリフォルニア大学の Bill Joy によって開発された C シェルという2つのシェルがあります。ksh はその2つのシェルの一番良い所を取り、新しい機能を数多く追加しました。そのため、システムとの対話とプログラミングの両方で ksh はあなたの作業の生産性と質を高めることができます。ksh のプログラムは簡単に書くことができ、C などの低級言語で書かれたプログラムよりも簡潔で読みやすいものになります。\n\n- nsh — Fish のようなコマンドラインシェルですが、POSIX と互換性があります。\n\n- OSH (Oil Shell) — Oil Shell は Bash 互換の UNIX コマンドラインシェルです。OSH は GNU/Linux を含むほとんどの UNIX ライクなオペレーティングシステムで実行できます。Python (v2.7) で記述されていますが、ネイティブの実行可能ファイルが付属しています。OSH によって認識される Bash の方言は OSH 言語と呼ばれます。\n\n- Yash — C99 (ISO/IEC 9899:1999) で書かれた POSIX に準拠したコマンドラインシェルです。Yash は世界で最も POSIX に準拠したシェルであることを意図しており、日常的な対話やスクリプトによる使用のための機能をサポートしています。\n\n- Zsh — インタラクティブな利用のために作られたシェルですが、パワフルなスクリプト言語でもあります。Bash, ksh, tcsh の便利な機能の多くが Zsh に組み入れられており、オリジナルの機能も多数追加されています。入門ドキュメント に Zsh のユニークな機能の説明があります。\n\n"
    },
    {
      "title": "代替シェル",
      "level": 3,
      "content": "- C shell — 対話式のログインシェルとしてもシェル言語コマンドプロセッサとしても使うことができるコマンド言語インタプリタ。コマンドラインエディタ、プログラマブルな単語補完、スペル訂正、履歴機構、ジョブ操作、C ライクな構文を持っています。\n\n- Closh — Clojure に基づく Bash のようなシェル。\n\n- Elvish — 近代的かつ表現豊かなシェルで、内部構造の値をパイプラインで渡すことができます。この機能によって複雑なテキスト処理のコードを書かなくてすみます。表現的なプログラミング言語を備えており、例外・名前空間・匿名関数などが使えます。タイピング中に構文をチェックする強力な readline を装備しており、デフォルトでシンタックスハイライトが効きます。\n\n- fish — スマートでユーザーフレンドリなコマンドラインシェル。OS X や Linux などに対応。Fish にはフルカラーのコマンドライン・シンタックスハイライトがあり、コマンドとその引数、既存のファイルや履歴のハイライトそして補完をすることができます。履歴やコマンドの補完候補の表示もサポート。Fish はシステムの man ページを解析してコマンドの正しい引数を調べることにより、コマンドのハイライトと補完を可能にしています。Alt-Up を使うことで最後に実行したコマンドの変更を簡単に行うことができます。fish デーモン (fishd) は fish の全てのインスタンス間で、履歴や環境変数を同期します。\n\n- ion — Ion は、シンプルかつ強力な構文を特徴とする、最新のシステムシェルです。シェル全体の品質と安全性を大幅に向上させ、ShellShock のような脆弱性の可能性を排除し、開発を容易にするために、すべて Rust で書かれています。また、Ion の機能を活用した場合、Dash を超えるレベルのパフォーマンスを発揮します。主に RedoxOS と並行して開発されていますが、他の *nix プラットフォームでも十分な性能を発揮します。詳しくは マニュアル を参照して下さい。\n\n- Murex — 機能が改善され、UX が強化されたコマンドラインシェル。\n\n- nushell — Nu は、関数型プログラミング言語や最新の CLI ツールからインスピレーションを受けています。ファイルやサービスを生のテキストの流れとして考えるのではなく、Nuはそれぞれの入力を構造化されたものとして見ます。\n\n- Oh — Go で書かれた Unix シェル。他の Unix シェルと同じような精神を持っていますが細かい所は異なっています。Oh はシェルの対話機能を犠牲にすることなくシェルのプログラミング言語機能を拡張しています。\n\n- Powershell — PowerShell は元は Windows 専用に作られた、オブジェクト指向言語でありインタラクティブなコマンドラインシェルです。後になって、オープンソース化されて macOS や Linux に移植されました。\n\n- rc — Plan 9 のコマンドインタプリタで UNIX の Bourne シェルと同じような機能を提供します。細かい追加がなされ構文はもっと一般的になっています。\n\n- xonsh — python インタプリタがベースの後方互換なシェル。\n\n"
    },
    {
      "title": "デフォルトシェルを変更する",
      "level": 2,
      "content": "上記のシェルをインストールした後、実行ファイルを起動すると、今使っているシェルの中でインストールしたシェルが起動します。ログイン時にインストールしたシェルが起動するようにしたい場合、デフォルトシェルを変更する必要があります。\n\nインストールされているシェルを確認するには、次を実行:\n\n```\n$ chsh -l\n```\n\nデフォルトシェルを設定するには次を実行 (chsh -l で確認できる、フルパスを指定するようにしてください):\n\n```\n$ chsh -s full-path-to-shell\n```\n\nsystemd-homed を使用している場合は、次のように実行します:\n\n```\n$ homectl update --shell=full-path-to-shell user\n```\n\nここで、full-path-to-shell は chsh -l で与えられたフルパスです。\n\n上記コマンドを実行してからログアウト・ログインすると、指定したシェルが開くはずです。\n\n"
    },
    {
      "title": "シェルのアンインストール",
      "level": 2,
      "content": "シェルのパッケージを削除する前に、デフォルトのシェルを変更する 必要があります。\n\nまたは、ユーザデータベース を変更します。\n\nログインシェルとして zsh が設定されている全てのユーザー (必要であれば root も含む) にこれを使用します。完了したら、パッケージを削除することができます。\n\n"
    },
    {
      "title": "ログインシェル",
      "level": 2,
      "content": "ログインシェルは呼び出しモードで、シェルはシステム全体の /etc/profile またはユーザー専用の ~/.profile や他のシェル固有のファイルなど、一度だけの初期化を目的としたファイルを読み込みます。これらのファイルは初期環境を設定し、シェル(他の非ログインシェルやグラフィカルプログラムを含む)から起動される他のすべてのプロセスに継承されます。例えば、ユーザがコンソールや SSH 経由でログインしたとき、--login パラメータを使って sudo や su でユーザを変更したとき、ユーザが手動でログインシェルを起動したとき bash --login) などです。\n\nさまざまな初期化ファイルの概要については、#設定ファイル とその中のリンクを参照してください。ログインシェルの詳細については、Stackexchange の Difference between Login Shell and Non-Login Shell? や Why a \"login\" shell over a \"non-login\" shell? を参照してください。\n\n"
    },
    {
      "title": "設定ファイル",
      "level": 2,
      "content": "ログイン時にコンソールでプログラムを自動起動させたい場合、シェルのスタートアップファイル・ディレクトリを使用することができます。シェルのドキュメントや ArchWiki の記事を見てください (例: Bash#設定ファイルや Zsh#設定ファイル)。\n\n様々なシェルの設定ファイルの比較は Wikipedia:Unix shell#Configuration files も参照してください。\n\n"
    },
    {
      "title": "/etc/profile",
      "level": 3,
      "content": "ログイン時に Bourne 互換のシェルは /etc/profile を読み込み、それから /etc/profile.d/ の *.sh ファイルを全て読み込みます。これらのスクリプトはインタプリタのディレクティブを必要とせず、実行可能属性を付与する必要もありません。環境やアプリケーション個別の設定を定義するのに使用します。\n\n"
    },
    {
      "title": "標準化",
      "level": 3,
      "content": "(いくつかの)シェルの設定ファイルを同じ命名規則に従うようにしたり、シェル間で共通の設定をサポートする事ができます。\n\nこれに関する記事 や 関連リポジトリ 、xsh を参照してください。\n\n"
    },
    {
      "title": "入出力",
      "level": 2,
      "content": "GregsWiki と I/O Redirection を参照。\n\n- リダイレクトは、コマンドが実行される前にファイルを切りすてます:$ command file > file したがって、期待通りには動作しません。一部のコマンド(例えばsed)は、ファイルをその場で編集するオプションを提供しますが、多くの場合は提供されません。このような場合は、moreutils パッケージの sponge(1) コマンドを使用します。\n\n```\n$ command file > file\n```\n\n- cat はシェルに組み込まれていないため、多くの場合、スクリプトやパフォーマンスを重視する場合は リダイレクト を使った方が便利です。実際、< file は cat file と同じです。\n\n- POSIX準拠のシェルは ヒアドキュメント をサポートしています:$ cat << EOF one two three EOF\n\n```\n$ cat << EOF\none\ntwo\nthree\nEOF\n```\n\n- シェルパイプラインは、デフォルトでは stdout で動作します。stderr(3) で動作させるには、command 2>&1 |othercommand のように strerr から strout に リダイレクトします。Bash 4 の場合は、command |& othercommand となります。\n\n- 多くの GNU Core Utilities はファイルを引数として受けとる事を思いだしてください。例えば、grep pattern < file は grep pattern file と置きかえられます。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- IBM developerWorks の Linux におけるシェルの進化\n- terminal.sexy — ターミナルカラースキームデザイナ\n- Hyperpolyglot — シェル構文の比較\n- UNIX Power Tools — 一般的なコマンドラインツールの使用方法\n- commandlinefu.com — コマンドラインスニペットの共有\n- アプリケーション一覧/ユーティリティ#ターミナルエミュレータ\n\n"
    }
  ]
}