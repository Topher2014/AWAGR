{
  "title": "Command-line shell (Русский)",
  "url": "https://wiki.archlinux.org/title/Command-line_shell_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- dotfiles\n- Основные утилиты\n\nИз Википедии:\n\n"
    },
    {
      "title": "Список оболочек",
      "level": 2,
      "content": "Оболочки, более или менее совместимые с POSIX, перечислены в разделе #POSIX-совместимые, а оболочки с другим синтаксисом — в разделе #Альтернативные оболочки.\n\n"
    },
    {
      "title": "POSIX-совместимые",
      "level": 3,
      "content": "На эти оболочки может вести символическая ссылка /usr/bin/sh. Когда Bash, mkshAUR и zsh запускаются через исполняемый файл с именем sh, они автоматически становятся более совместимыми с POSIX.\n\n- Bash — Bash расширяет оболочку Bourne shell, добавляя историю и автодополнение, индексированные и ассоциативные массивы, целочисленную арифметику, подстановку процессов, here strings, регулярные выражения и расширение скобок.\n\n- Dash — Потомок NetBSD-версии Almquist SHell (ash). Быстрая POSIX-совместимая оболочка, которая стремится быть настолько маленькой, насколько это возможно.\n\n- Korn shell (ksh) — Язык KornShell представляет собой полный, мощный язык программирования высокого уровня для написания приложений, зачастую легче и быстрее, чем на других языках высокого уровня. Это делает его особенно подходящим для прототипирования. ksh сочетает в себе лучшие черты оболочки Bourne и C, плюс множество самостоятельных возможностей. Таким образом Ksh может сделать многое, чтобы повысить продуктивность и качество вашей работы при взаимодействии с системой и в программировании. Программы на ksh легче писать, они более кратки и читабельны, чем программы, написанные на языке более низкого уровня, таком как C.\n\n- nsh — Командная оболочка, похожая на fish, но POSIX-совместимая.\n\n- Oil Shell (OSH) — Bash-совместимая оболочка командной строки UNIX. OSH может быть запущена на большинстве UNIX-подобных операционных систем, в том числе GNU/Linux. Она написана на языке Python (v2.7), но поставляется в виде нативного исполняемого файла. Диалект Bash, распознаваемый OSH, называется языком OSH.\n\n- Yash — Yet another shell, POSIX-совместимая оболочка командной строки, написанная на языке C99 (ISO/IEC 9899:1999). Yash стремится стать самой POSIX-совместимой оболочкой в мире, поддерживая при этом функции для интерактивного использования и для написания скриптов.\n\n- Zsh — Оболочка, предназначенная для интерактивного использования, хотя это также мощный скриптовый язык. Многие из полезных особенностей Bash, ksh и tcsh были включены в Zsh; были добавлены многие оригинальные черты. Во введении перечислены некоторые из уникальных особенностей Zsh.\n\n"
    },
    {
      "title": "Альтернативные оболочки",
      "level": 3,
      "content": "- C shell (tcsh) — Командный интерпретатор, используемый как интерактивная оболочка входа в систему и командный процессор скриптов. Он имеет редактор командной строки, программируемое автодополнение слов, проверку орфографии, механизм истории, управление заданиями и C-подобный синтаксис.\n\n- Closh — Bash-подобная командная оболочка на Clojure.\n\n- Elvish — Современная и выразительная оболочка, которая может переносить внутренние структурированные значения через конвейеры. Эта возможность позволяет избежать большого количества сложного кода для обработки текста. Это выразительный язык программирования с такими возможностями, как исключения, пространства имён и анонимные функции. Также есть мощный readline, который проверяет синтаксис при наборе текста, и подсветка синтаксиса по умолчанию.\n\n- fish — Умная и удобная командная оболочка. Fish делает полноцветную подсветку синтаксиса командной строки, а также подсветку и автодополнение команд и их аргументов, существующих файлов и истории. Поддерживается функция завершения по мере ввода для истории и команд. Fish способен анализировать man-страницы системы для определения допустимых аргументов команд, что позволяет ему подсвечивать и дополнять команды. Лёгкий просмотр последних команд может быть сделан с помощью Alt+Up. Демон Fish (fishd) облегчает синхронизацию истории всех экземпляров fish, а также универсальных и постоянных переменных окружения. Кроме того, fish имеет простой синтаксис программирования и поток управления (подобно ruby). Для получения дополнительной информации смотрите руководство.\n\n- ion — Современная системная оболочка с простым, но мощным синтаксисом. Она полностью написана на Rust, что значительно повышает общее качество и безопасность оболочки, устраняя возможность появления уязвимостей вроде ShellShock и упрощая разработку. Она также обеспечивает уровень производительности, превосходящий Dash, при использовании возможностей Ion. Хотя он разрабатывается наряду с RedoxOS и в первую очередь для неё, он вполне пригоден и для других *nix-платформ. Для получения более подробной информации смотрите руководство.\n\n- Murex — Командная оболочка с расширенными возможностями и улучшенным пользовательским интерфейсом.\n\n- nushell — Nu черпает вдохновение в функциональных языках программирования и современных инструментах командной строки. Вместо того, чтобы рассматривать файлы и сервисы как необработанные потоки текста, Nu рассматривает каждый ввод как нечто, имеющее структуру.\n\n- Oh — Unix-оболочка, написанная на Go. Это оболочка в духе Unix, но отличается в деталях. Oh расширяет возможности языка программирования оболочки без ущерба интерактивных функций оболочки.\n\n- PowerShell — Объектно-ориентированный язык программирования и интерактивная оболочка командной строки, изначально написанная для Windows. Позже PowerShell был открыт и портирован на macOS и Linux.\n\n- rc — Командный интерпретатор для Plan 9, который предоставляет возможности, похожие на Bourne shell, с небольшими дополнениями и менее своеобразным синтаксисом.\n\n- xonsh — Оболочка на Python с дополнительными примитивами, к которым вы привыкли из Bash и IPython.\n\n"
    },
    {
      "title": "Выбор оболочки по умолчанию",
      "level": 2,
      "content": "После установки какой-либо из перечисленных выше оболочек вы можете запустить эту оболочку внутри вашей текущей оболочки, просто запустив её исполняемый файл. Если вы хотите всегда пользоваться только что поставленной оболочкой, для этого нужно изменить оболочку, используемую по умолчанию.\n\nПосмотрите все установленные оболочки:\n\n```\n$ chsh -l\n```\n\nИ выберите одну из них в качестве оболочки по умолчанию для вашего пользователя:\n\n```\n$ chsh -s полный-путь-до-оболочки\n```\n\nЕсли вы используете systemd-homed, выполните:\n\n```\n$ homectl update --shell=полный-путь-до-оболочки пользователь\n```\n\nГде полный-путь-до-оболочки — это путь, который вывела команда chsh -l.\n\nТеперь, если вы выйдите из системы и войдёте снова, вас встретит установленная оболочка.\n\n"
    },
    {
      "title": "Удаление оболочки",
      "level": 2,
      "content": "Измените оболочку по умолчанию на другую перед её удалением.\n\nВ качестве альтернативы измените базу данных пользователей.\n\nСделайте это для каждого пользователя, у которого удаляемая оболочка используется в качестве оболочки входа (не забудьте проверить пользователя root). После завершения пакет можно удалить.\n\n"
    },
    {
      "title": "Оболочка входа",
      "level": 2,
      "content": "Оболочка входа (login shell) — это режим запуска оболочки, в котором она читает файлы, предназначенные для однократной инициализации, такие как общесистемный /etc/profile или пользовательский ~/.profile или другие специфические для оболочки файлы. Эти файлы задают начальное окружение, которое наследуется всеми другими процессами, запущенными из оболочки (в том числе другими оболочками, не связанными со входом в систему, или графическими приложениями). Следовательно, они читаются только один раз в начале сеанса, то есть, например, когда пользователь входит в консоль или через SSH, меняет пользователя с помощью sudo или su с параметром --login, или когда пользователь вручную запускает оболочку входа (например, командой bash --login).\n\nОбзор различных файлов инициализации смотрите в разделе #Файлы настроек и по ссылкам в нём. Для получения дополнительной информации об оболочке входа смотрите также Difference between Login Shell and Non-Login Shell? и Why a \"login\" shell over a \"non-login\" shell? на Stack Exchange.\n\n"
    },
    {
      "title": "Файлы настроек",
      "level": 2,
      "content": "Чтобы сделать автозапуск программ в консоли или при входе в систему, можно использовать файлы/каталоги, которые оболочка выполняет при запуске. Смотрите документацию к вашей оболочке или соответствующую статью в ArchWiki: например, Bash (Русский)#Файлы настроек или Zsh (Русский)#Файлы запуска/завершения.\n\n"
    },
    {
      "title": "/etc/profile",
      "level": 3,
      "content": "При входе в систему все Bourne-совместимые оболочки выполняют source файла /etc/profile, который, в свою очередь, выполняет source всех читабельных файлов *.sh в каталоге /etc/profile.d/: в этих скриптах не требуется указывать директиву интерпретатора (шебанг) и их не нужно делать исполняемыми. Они используются для настройки окружения и определения параметров, специфичных для приложений.\n\n"
    },
    {
      "title": "Стандартизация",
      "level": 3,
      "content": "Можно заставить файлы настроек (некоторых) оболочек следовать одному и тому же соглашению об именовании, а также поддерживать некоторые общие настройки между оболочками.\n\nСмотрите статью об этом и соответствующий репозиторий. Смотрите также xsh.\n\n"
    },
    {
      "title": "Ввод и вывод",
      "level": 2,
      "content": "Смотрите также GregsWiki и I/O Redirection.\n\n- При перенаправлении вывода в файл важно иметь в виду, что файл очищается (truncate) перед выполнением команды. Если вы попытаетесь сделать что-то подобное: $ команда файл > файл то это не сработает, а содержимое файла будет потеряно. Хотя в некоторых командах (например sed) есть опция для редактирования файлов на месте, многие команды такой опции не имеют. В таком случае можно использовать команду sponge(1) из пакета moreutils.\n- Так как cat не является встроенной в оболочку командой, может быть лучше использовать вместо неё перенаправление, например, в скриптах, или если вам важна производительность. Фактически, < файл делает то же самое, что и cat файл.\n- POSIX-совместимые оболочки поддерживают Here Documents: $ cat << EOF раз два три EOF\n- Конвейеры (трубы, pipelines) по умолчанию работают со стандартным выводом (stdout). Чтобы работать со стандартным выводом ошибок (stderr(3)), можно перенаправить stderr в stdout с помощью конструкции вида команда 2>&1 | другая-команда, или, в Bash 4, команда |& другая-команда.\n- Помните, что многие основные утилиты GNU принимают файлы в качестве аргументов, так что, например, вместо grep паттерн < файл можно написать grep паттерн файл.\n\n```\n$ команда файл > файл\n```\n\n```\n$ cat << EOF\nраз\nдва\nтри\nEOF\n```\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Evolution of shells in Linux on the IBM developerWorks\n- terminal.sexy — Конструктор цветовых схем терминала\n- Hyperpolyglot — Сравнение синтаксиса разных оболочек\n- UNIX Power Tools — General command-line tool usage\n- commandlinefu.com — Command-line snippets sharing\n- List of applications/Utilities#Terminal emulators\n\n"
    }
  ]
}