{
  "title": "Systemd/User (Italiano)",
  "url": "https://wiki.archlinux.org/title/Systemd/User_(Italiano)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section needs to be translated.** This article or section needs to be translated.\n\nThis article or section needs to be translated.\n\nArticoli correlati\n\n- systemd (Italiano)\n- Automatic login to virtual console (Italiano)\n- Start X at Login (Italiano)\n\nsystemd offre agli utenti la possibilità di gestire i servizi sotto il controllo dell'utente tramite una istanza di systemd per singolo utente, che consente agli stessi di avviare, fermare, abilitare e disabilitare le proprie unità. Questa caratteristica è utile per demoni e altre operazioni automatiche come lo scaricamento della posta. È inoltre possibile, con alcune modifiche, avviare Xorg e il window manager in uso direttamente tramite i servizi utente.\n\n"
    },
    {
      "title": "Come funziona",
      "level": 2,
      "content": "Secondo la configurazione di default in /etc/pam.d/system-login, il modulo pam_systemd avvia automaticamente una istanza di systemd --user al primo login dell'utente. Tale processo rimarrà in esecuzione fin tanto che l'utente sarà coneesso, e verrà terminato quando l'utente effettua il logout. Quando l'#Avvio automatico delle istanze utente di systemd è abilitato, l'istanza viene avviata al boot e non più terminata. L'istanza utente di systemd si occupa di gestire i servizi utente, utilizzabili per avviare demoni o compiere operazioni automatiche, disponendo comunque di tutti i benefici di systemd, come l'attivazione socket, timers, dipendenze o controllo processi tramite cgroups. Similmente a quanto accade con in servizi di sistema, i servizi utente risiedono nelle directory seguenti (ordinate per preferenza crescente):\n\n- /usr/lib/systemd/user/ directory per i servizi forniti dai pacchetti.\n- /etc/systemd/user/ directory per i servizi definiti dall'amministratore di sistema.\n- ~/.config/systemd/user/ directory per i servizi utente.\n\nAll'avvio di una istanza utente di systemd, viene caricato il target default.target; è ora possibile controllare manualmente i servizi utente tramite systemctl --user.\n\n- Si noti che, a partire dalla versione 206, l'istanza utente systemd --user è un processo dedicato per utente, e non per sessione. Ne consegue che la maggior parte delle risorse gestite dai servizi utenti, come sockets o file di stato, riguardano un singolo utente (sono difatti situati nella home directory dello stesso) e non una sessione. Ciò significa che tutti i servizi utente vengono eseguiti al di fuori di una sessione; per questo motivo, i programmi che necessitano di essere eseguiti per ogni singola sessione probabilmente non funzioneranno con le istanze utente di systemd. La gestione delle sessioni da parte di systemd varia continuamente. Si legga [1] e [2] per avere un'idea generale sullo sviluppo di questa funzionalità.\n- systemd --user viene eseguito come processo separato rispetto a systemd --system. I servizi utente non possono pertanto riferirsi o dipendere da servizi di sistema.\n\n"
    },
    {
      "title": "Configurazione di base",
      "level": 2,
      "content": "Tutti i servizi utente devono essere inseriti in ~/.config/systemd/user. Se si vuole avviare une servizio automaticamente al login, si esegua systemctl --user enable servizio per ogni servizio.\n\n"
    },
    {
      "title": "D-Bus",
      "level": 3,
      "content": "Alcune applicazioni necessitano di un messagebus D-Bus, tradizionalmente avviato quando si esegue un desktop environment tramite dbus-launch. A partire dalla versione 226, systemd è divenuto il gestore del messagebus utente. [3] Il demone dbus-daemon viene avviato una volta per ogni sessione utente utilizzando le unità utente dbus.socket e dbus.service.\n\n"
    },
    {
      "title": "Variabili d'ambiente",
      "level": 3,
      "content": "L'istanza utente di systemd non eredita le variabili d'ambiente definite in .bashrc e similari. Vi sono quattro modi per definire variabili d'ambiente per istanze utente di systemd:\n\n1. Per gli utenti che abbiano una propria home directory, si specifichi l'opzione DefaultEnvironment in ~/.config/systemd/user.conf. Viene applicata solo alle unità utente di un utente specifico.\n1. Utilizzare l'opzione DefaultEnvironment in /etc/systemd/user.conf. Viene applicata a tutti i servizi utente.\n1. Creare un file di configurazione in /etc/systemd/system/user@.service.d/. Viene applicata a tutti i servizi utente.\n1. In qualsiasi momento, tramite i comandi systemctl --user set-environment o systemctl --user import-environment. Applicata a tutti i servizi avviati dopo l'esecuzione dei comandi di cui sopra, ma non a quelli già avviati.\n\nUna variabile che si potrebbe voler definire è PATH.\n\n"
    },
    {
      "title": "DISPLAY e XAUTHORITY",
      "level": 4,
      "content": "La variabile DISPLAY viene utilizzata da qualsiasi applicazione X per individuare il display da utilizare, mentre XAUTHORITY identifica il percorso al file .Xauthority dell'utente corrente, e di conseguenza il cookie necessario per accedere a X. Se si intende lanciare applicazioni grafiche tramite servizi di systemd, sarà necessario definire tali variabili. A partire dalla versione 219, systemd fornisce uno script situato in /etc/X11/xinit/xinitrc.d/50-systemd-user.sh per importarle nella sessione utente di systemd all'avvio di X. Ne consegue che, a meno che X non venga avviato tramite procedure non standard, i servizi utenti dovrebbero essere già al corrente dei valori delle due variabili.\n\n"
    },
    {
      "title": "PATH",
      "level": 4,
      "content": "Come tutte le variabili d'ambiente definite tramite .bashrc o .bash_profile, anche PATH non è visibile a systemd. Se si modifica il valore di tale variabile e si intende avviare applicazioni che se ne avvalgano come servizi di systemd, sarà necessario notificare systemd della sua modifica. È consigliabile farlo aggiungendo la seguente riga al proprio .bash_profile, dopo aver definito la variabile PATH:\n\n```\n~/.bash_profile\n```\n\n```\nsystemctl --user import-environment PATH\n```\n\n"
    },
    {
      "title": "Avvio automatico delle istanze utente di systemd",
      "level": 3,
      "content": "L'istanza utente di systemd viene avviata dopo il primo login di un utente, e fermata alla chiusura dell'ultima sessione di quell'utente. Potrebbe essere talvolta necesario avviarla subito dopo il boot, e mantenerla attiva alla chiusura dell'ultima sessione utente relativa, ad esempio per avere processi utente attivi senza alcuna sesione utente in corso. Si esegua a tal proposito il seguente comando per abilitare tale comportamento per un singolo utente:\n\n```\n# loginctl enable-linger nomeutente\n```\n\nNote: **non** \n\n"
    },
    {
      "title": "Xorg e systemd",
      "level": 2,
      "content": "Vi sono diversi metodi per avviare Xorg tramite systemd. Di seguito due possibilità: l'avvio di una sessione utente con un processo di Xorg o l'avvio di quest'ultimo come servizio utente.\n\n"
    },
    {
      "title": "Login automatico in Xorg senza display manager",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nQuanto sotto avvierà una sessione utente ed il server Xorg come unità di sistema e provvederà poi a leggere il contenuto di ~/.xinitrc, avviare il window manager, ecc.\n\nSarà necessario configurare #D-Bus nel modo corretto ed installare il pacchetto xlogin-gitAUR.\n\nSi crei il proprio file xinitrc da quello di default, in modo che effettui il source dei files in /etc/X11/xinit/xinitrc.d/. È necessario che l'esecuzione del priorio ~/.xinitrc non ritorni, quindi si inserisca wait come ultimo comando, o si aggiunga exec all'ultimo comando (ad esempio, il proprio window manager).\n\nQuesta sessione utilizzerà il proprio demone D-Bus, ma varie utility di systemd si connetteranno automaticamente all'istanza avviata dal servizio dbus.service\n\nSi abiliti infine (come root) il servizio xlogin per ottenere il login automatico al boot:\n\n```\n# systemctl enable xlogin@username\n```\n\nLa sessione utente viene eseguita interamente in un ambiente systemd, quindi tutto dovrebbe funzionare nel modo corretto.\n\n"
    },
    {
      "title": "Avvio di Xorg come servizio utente",
      "level": 3,
      "content": "In alternativa, è possibile avviare xorg come servizio utente, avendo il vantaggio di poter definire il servizio in questione come dipendenza di altre unità che lo necessitino. Questo approccio, tuttavia, non è esente da difetti, elencati sotto:\n\nA partire dalla versione 1.16, xorg-server si integra in modo migliore con systemd in due modi:\n\n- Può essere avviato senza privilegi di root, delegando la gestione dei dispositivi a logind (si vedano i commit di Hans de Goede this qui).\n- Può essere avviato come servizio attivato tramite socket (si veda questo commit).\n\nSfortunatamente, per avviare Xorg senza privilegi di amministratore, è necessario essere in una sessione, perciò, in questo momento, è necessario avviare Xorg come amministratore per poterlo gestire tramite i servizi utente (come per versioni precedenti la 1.16).\n\nDi seguito le istruzioni per avviare Xorg come servizio utente\n\n1. Assicurarsi che Xorg possa venire avviato con privilegi da amministratore da qualsiasi utente, modificando /etc/X11/Xwrapper.config:\n\n```\n/etc/X11/Xwrapper.config\n```\n\n```\nallowed_users=anybody\nneeds_root_rights=yes\n```\n\n2. Creare le seguenti unità in ~/.config/systemd/user:\n\n```\n~/.config/systemd/user/xorg@.socket\n```\n\n```\n[Unit]\nDescription=Socket for xorg at display %i\n\n[Socket]\nListenStream=/tmp/.X11-unix/X%i\n```\n\n```\n~/.config/systemd/user/xorg@.service\n```\n\n```\n[Unit]\nDescription=Xorg server at display %i\n\nRequires=xorg@%i.socket\nAfter=xorg@%i.socket\n\n[Service]\nType=simple\nSuccessExitStatus=0 1\n\nExecStart=/usr/bin/Xorg :%i -nolisten tcp -noreset -verbose 2 \"vt${XDG_VTNR}\"\n```\n\nDove ${XDG_VTNR} è il terminale virtuale dove Xorg verrà eseguito, definito all'interno del servizio utente, o specificato come variabile d'ambiente in systemd tramite:\n\n```\n$ systemctl --user set-environment XDG_VTNR=1\n```\n\n3. Assicurarsi di definire la variabile d'ambiente DISPLAY come spiegato sopra.\n\n4. Per abilitare l'attivazione socket per Xorg sul display 0 e tty2, si procederebbe come segue:\n\n```\n$ systemctl --user set-environment XDG_VTNR=2     # Per dichiarare a xorg@.service quale terminale utilizzare\n$ systemctl --user start xorg@0.socket            # Resta in ascolto sul socket del display 0\n```\n\nA questo punto, qualsiasi applicazione X11 verrà eseguita automaticamente sul terminale virtuale 2.\n\nLa variabile d'ambiente XDG_VTNR può essere definita nell'ambiente di systemd partendo da .bash_profile, cosa che renderebbe possibile avviare qualsiasi applicazione X11, compreso un window manager, come unità utente systemd, inserendo una dipendenza a xorg@0.socket.\n\n"
    },
    {
      "title": "Esempio",
      "level": 3,
      "content": "Di seguito un esempio per l'avvio di mpd come servizio utente:\n\n```\n~/.config/systemd/user/mpd.service\n```\n\n```\n[Unit]\nDescription=Music Player Daemon\n\n[Service]\nExecStart=/usr/bin/mpd --no-daemon\n\n[Install]\nWantedBy=default.target\n```\n\n"
    },
    {
      "title": "Esempio con variabili",
      "level": 3,
      "content": "Esempio di avvio di sickbeard come servizio utente, con definizione di una variabile utente per la directory home dove Sickbeard reperisce alcuni file di configurazione:\n\n```\n~/.config/systemd/user/sickbeard.service\n```\n\n```\n[Unit]\nDescription=SickBeard Daemon\n\n[Service]\nExecStart=/usr/bin/env python2 /opt/sickbeard/SickBeard.py --config %h/.sickbeard/config.ini --datadir %h/.sickbeard\n\n[Install]\nWantedBy=default.target\n```\n\nCome specificato in systemd.unit(5), la variabile %h viene sostituita con la home directory dell'utente che esegue il servizio. Vi sono altre variabili disponibili, spiegate in dettaglio nelle pagine di manuale di systemd.\n\n"
    },
    {
      "title": "Nota per applicazioni X11",
      "level": 3,
      "content": "La maggior parte delle applicazioni X11, necessitano della variabile DISPLAY per essere eseguite. Vedere a tal proposito la sezione #DISPLAY e XAUTHORITY.\n\n"
    },
    {
      "title": "Multiplexer di terminale persistente",
      "level": 3,
      "content": "Note: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nYou may wish your user session to default to running a terminal multiplexer, such as GNU Screen or Tmux, in the background rather than logging you into a window manager session. Separating login from X login is most likely only useful for those who boot to a TTY instead of to a display manager (in which case you can simply bundle everything you start in with myStuff.target).\n\nTo create this type of user session, procede as above, but instead of creating wm.target, create multiplexer.target:\n\n```\n[Unit]\nDescription=Terminal multiplexer\nDocumentation=info:screen man:screen(1) man:tmux(1)\nAfter=cruft.target\nWants=cruft.target\n\n[Install]\nAlias=default.target\n```\n\ncruft.target, like mystuff.target above, should start anything you think should run before tmux or screen starts (or which you want started at boot regardless of timing), such as a GnuPG daemon session.\n\nYou then need to create a service for your multiplexer session. Here is a sample service, using tmux as an example and sourcing a gpg-agent session which wrote its information to /tmp/gpg-agent-info. This sample session, when you start X, will also be able to run X programs, since DISPLAY is set.\n\n```\n[Unit]\nDescription=tmux: A terminal multiplixer\nDocumentation=man:tmux(1)\nAfter=gpg-agent.service\nWants=gpg-agent.service\n\n[Service]\nType=forking\nExecStart=/usr/bin/tmux start\nExecStop=/usr/bin/tmux kill-server\nEnvironment=DISPLAY=:0\nEnvironmentFile=/tmp/gpg-agent-info\n\n[Install]\nWantedBy=multiplexer.target\n```\n\nOnce this is done, systemctl --user enable tmux.service, multiplexer.target and any services you created to be run by cruft.target and you should be set to go! Activated user-session@.service as described above, but be sure to remove the Conflicts=getty@tty1.service from user-session@.service, since your user session will not be taking over a TTY. Congratulations! You have a running terminal multiplexer and some other useful programs ready to start at boot!\n\n"
    },
    {
      "title": "Window manager",
      "level": 3,
      "content": "Per eseguire un window manager come servizio di systemd, sarà necessario avviare Xorg come servizio utente. Di seguito, un esempio utilizzando awesome:\n\n```\n~/.config/systemd/user/awesome.service\n```\n\n```\n[Unit]\nDescription=Awesome window manager\nAfter=xorg.target\nRequires=xorg.target\n\n[Service]\nExecStart=/usr/bin/awesome\nRestart=always\nRestartSec=10\n \n[Install]\nWantedBy=wm.target\n```\n\n"
    },
    {
      "title": "Riferimenti",
      "level": 2,
      "content": "- Wiki Bitbucket di KaiSforza\n- Servizi di Zoqaeski su GitHub\n- Collezione di servizi utente systemd[link interrotto 2020-08-06]\n- Discussione sul forum di Arch a seguito dei cambiamenti introdotti a partire da systemd 206\n\n"
    }
  ]
}