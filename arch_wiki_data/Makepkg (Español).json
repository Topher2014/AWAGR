{
  "title": "Makepkg (Español)",
  "url": "https://wiki.archlinux.org/title/Makepkg_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2020-05-31** \n\nArtículos relacionados\n\n- Crear paquetes\n- PKGBUILD\n- Arch User Repository\n- Pacman\n- Repositorios oficiales\n- Arch Build System\n\nmakepkg es usado para compilar y construir paquetes capaces de instalar mediante pacman, el manejador de paquetes de Arch Linux. makepkg es un script que automatiza el proceso de construcción de paquetes; este puede descargar y validar archivos fuente, resolver dependencias, configurar los parámetros de tiempo de compilación, compilar las fuentes e instalarlo dentro de un root temporal.\n\nmakepkg lo provee el paquete pacman.\n\n"
    },
    {
      "title": "Configuración",
      "level": 2,
      "content": "El archivo principal de configuración de makepkg es /etc/makepkg.conf . la mayoría de los usuarios querrán configurar estas opciones de makepkg antes de construir cualquier paquete (por ejemplo modificar las variables MAKEFLAGS en sistemas con soporte SMP para reducir tiempos de compilación , o personalizar la variable PACKAGER para personalizar paquetes. Lea la documentación de PACKAGER para más detalles\n\nPara poder instalar paquetes con makepkg sin ser usuario administrador (con makepkg -s, información más delante), instale sudo y agregue los usuarios con estos privilegios en el archivo to /etc/sudoers:\n\n```\nUSER_NAME    ALL=(ALL)    NOPASSWD: /usr/bin/pacman\n```\n\nLa línea de arriba eliminara la necesidad de introducir un password cada vez que utilicemos pacman. Revise la wiki de sudo para mas información\n\nEnseguida, puede configurar donde serán guardados los paquetes terminados. Este paso es meramente opcional; por definición los paquetes serán creados en el directorio donde makepkg se ejecute Cree el directorio:\n\n```\n$ mkdir /home/$USER/packages\n```\n\nLuego modifique la variable PKGDEST en el archivo /etc/makepkg.conf de acuerdo a esta directorio.\n\n"
    },
    {
      "title": "Información del empaquetador",
      "level": 3,
      "content": "Cada paquete es etiquetado con meta información que identifica entre otros el packager. Por defecto, paquetes compilados por el usuario son marcados con Unknown Packager. Si múltiples usuarios van a compilar paquetes en un sistema o si planea distribuir sus paquetes con otros usuarios, es conveniente proveer un contacto real. Esto se puede hacer modificando la variable PACKAGER en el archivo makepkg.conf.\n\nPara revisar esta variable en un paquete instalado ejecute:\n\n```\n$ pacman -Qi paquete\n```\n\n```\n...\nPackager       : John Doe <john@doe.com>\n...\n```\n\nPara firmar sus paquete automaticamente, tambien modifique la variable GPGKEY en el archivo makepkg.conf.\n\n"
    },
    {
      "title": "Resultado del paquete",
      "level": 3,
      "content": "Por defecto, makepkg crea tarballs de los paquetes en el directorio de trabajo y descarga las fuentes en el directorio src/. Rutas personalizadas pueden ser configuradas, por ejemplo para mantener todos los paquetes construidos en ~/build/packages/ y todas las fuentes en ~/build/sources/.\n\nConfigure las siguientes variables en makepkg.conf, si lo considera necesario:\n\n- PKGDEST — directorio para guardar los paquetes resultantes\n- SRCDEST — directorio para guardar datos fuente, (links simbólicos seran puestos en src/ si la ruta es diferente)\n- SRCPKGDEST — directorio para guardar las fuentes resultantes (construido con makepkg -S)\n\n"
    },
    {
      "title": "Verificación de firmas",
      "level": 3,
      "content": "Si una firma de la forma .sig o .asc es parte del PKGBUILD en la sección source, makepkg automáticamente intentara verificarla. En caso de que el llavero del usuario no contenga la clave pública para la verificación makepkg abortara el procedimiento con un mensaje que la clave PGP no pudo ser verificada.\n\nSi una clave pública es necesaria, el PKGBUILD probablemente tendrá una sección validpgpkeys con las IDs requeridas. Se puede importar manualmente, o la puede ubicar en un keyserver e importarla desde allí.\n\n"
    },
    {
      "title": "fakeroot",
      "level": 3,
      "content": "fakeroot permite al usuario usar los permisos necesarios de root para crear paquetes en el ambiente de construcción sin necesidad de alterar todo el sistema. Si el proceso de construcción trata de alterar archivos fuera del ambiente de construcción entonces aparecerán mensajes de error y el empaquetado habrá fallado – esto es muy útil para verificar la calidad, seguridad e integridad de los PKGBUILD para su distribución. Por default fakeroot esta habilitado en el archivo de configuración /etc/makepkg.conf; los usuarios pueden utilizar el prefijo ! en la variable BUILDENV para deshabilitar esto.\n\n"
    },
    {
      "title": "Utilización",
      "level": 2,
      "content": "Antes de continuar, asegúrese de que el grupo de paquetes base-devel este instalado. Los paquetes pertenecientes a este grupo no son requeridos en la lista de dependencias en los PKGBUILD.\n\n- Asegurese de haber configurado sudo correctamente al pasar comandos a pacman.\n- Ejecutar makepkg como root no esta permitido. Debido a que un PKGBUILD puede incluir comandos arbitrarios, construir como root se considera peligroso.\n\nPara crear un paquete primero debe tener un PKGBUILD, como se describe en la guía de in Creating packages, o obtenga uno del ABS tree, Arch User Repository, u obténgalo de alguna otra fuente.\n\nUna vez en posesión de un PKGBUILD, entre al directorio donde esta salvado este archivo y ejecute el siguiente comando para compilar y construir el paquete como lo fue descrito en el archivo un PKGBUILD:\n\n```\n$ makepkg\n```\n\nSi no se satisfacen algunas dependencias, makepkg mostrara una advertencia antes de fallar, para construir el paquete e instalar sus dependencias automáticamente, simplemente se utiliza el comando:\n\n```\n$ makepkg -s\n```\n\n- Estas dependencias deben estar disponibles dentro de los repositorios disponibles para pacman, vea pacman (Español)#Repositorios y servidores de réplicas para mayor información al respecto. También se pueden instalar las dependencias antes de construir el paquete (pacman -S --asdeps dep1 dep2).\n- Solo se utilizarán valores globales cuando se instalen las dependencias, por ejemplo, cualquier anulación hecha en la función de paquete dividido no sera usado.\n\nUna vez que se hayan satisfecho todas las dependencias y el paquete se construyo satisfactoriamente, un archivo con el nombre (pkgname-pkgver.pkg.tar.gz) será creado en el directorio de trabajo. Para instalarlo (al igual que pacman -U pkgname-pkgver.pkg.tar.gz) simplemente se ejecuta:\n\n```\n$ makepkg -i\n```\n\nPara despejar archivos que no son necesarios, como los existentes en $srcdir, agregue la opción -c. Este comando es útil al actualizar la version de los paquetes usando el mismo directorio. Se previene la transferencia de archivos obsoletos en la nueva construcción.\n\n```\n$ makepkg -c\n```\n\nPara mas información, mire makepkg(8).\n\n"
    },
    {
      "title": "Construir binarios optimizados",
      "level": 3,
      "content": "Una mejora de rendimiento del empaquetado de software se puede lograr habilitando optimizaciones en la máquina local. El inconveniente es que los binarios compilados para una arquitectura de procesador específico pueden no ejecutarse correctamente en otros ordenadores. En las máquinas x86_64 es raro ganar un rendimiento significativo que justifique invertir tiempo en reconstruir los paquetes oficiales.\n\nSin embargo es muy fácil disminuir el rendimiento utilizando FLAGS de compilación \"no estandar\". Muchas optimizaciones son útiles solo en determinadas situaciones y no debe de aplicarse para todos los paquetes. A no haya ser que puedas verificar que algo es más rápido, es una muy buena oportunidad ¡como no! Los artículos de Gentoo Guía de optimización de compilación y CFLAGS Seguros (en ingles) proporciona mas información detallada sobre optimizaciones de compilador.\n\nLas opciones pasadas al compilador C/C++ (e.g. gcc o clang) están controladas por CFLAGS, CXXFLAGS y CPPFLAGS variables de entorno. Para usarlos en el sistema de construcción de Arch, makepkg muestra las variables de entorno según las opciones de configuración en makepkg.conf. Los valores por defecto están configurados para producir binarios genéricos que pueden ser instalados en un amplio rango de máquinas.\n\n- Tener en cuenta que no todos los sistemas de construcciones utilizan las variables configuradas en makepkg.conf. Por ejemplo, cmake no tiene en cuenta las opciones de preprocesamiento CPPFLAGS. Consecuentemente, muchos PKGBUILD contienen métodos alternativos con opciones específicas para el sistema constructor usado por el gestor de paquetes.\n- La configuración proporcionada con el código fuente en el Makefile o algún argumento específico en la compilación desde la linea de comandos tiene preferencia y puede potencialmente sobrescribir el de makepkg.conf.\n\nGCC puede detectar automáticamente y habilitar de forma segura las optimizaciones especificas de la arquitectura. Para utilizar esta función, primero elimina cualquier -march y -mtune flags, después añade -march=native. Por ejemplo:\n\n```\n/etc/makepkg.conf\n```\n\n```\nCFLAGS=\"-march=native -O2 -pipe -fstack-protector-strong -fno-plt\"\nCXXFLAGS=\"${CFLAGS}\"\n```\n\nPara ver que flags estan habilitadas en tu ordenador, ejecuta:\n\n```\n$ gcc -march=native -v -Q --help=target\n```\n\nNote: **puede no** \n\n"
    },
    {
      "title": "Compilación paralela",
      "level": 4,
      "content": "El sistema de construcción make usa las MAKEFLAGS como variables de entorno para especificar opciones adicionales. Las variables también pueden ser definidas en el archivo /etc/makepkg.conf.\n\nUsuarios con sistemas que poseen múltiples núcleos o CPU pueden especificar el número de trabajos a ejecutar simultáneamente. Esto se puede realizar usando nproc para determinar el número de procesadores disponibles, v.g. modificando la línea MAKEFLAGS en /etc/makepkg.conf.\n\n```\nMAKEFLAGS=\"-j$(nproc)\"\n```\n\nPara decirle al compilador que use un número especifico de núcleos al momento de compilar, se usa el mismo parámetro -j<numero_de_núcleos>. El número recomendado es n+1, donde n es la cantidad de núcleos de tu procesador.\n\nPor ejemplo un procesador de 2 núcleos (2+1=3):\n\n```\n/etc/makepkg.conf\n```\n\n```\n...\n#-- Make Flags: change this for DistCC/SMP systems\nMAKEFLAGS=\"-j3\"\n...\n```\n\nAlgunos PKGBUILD sobrescriben específicamente con -j1, por las condiciones en algunas versiones o porque simplemente no están soportadas en primer lugar. Paquetes que fallen la construcción por esto debe de ser reportado en el bug tracker (o en su caso de los paquetes del AUR, al mantenedor del paquete) después de estar seguro que ese error lo causa su MAKEFLAGS.\n\nVea make(1) para una lista completa de opciones.\n\n"
    },
    {
      "title": "Construir desde archivos en memoria",
      "level": 4,
      "content": "La compilación requiere muchas operaciones I/O y manejar muchos archivos pequeños, moviendo el directorio de trabajo a tmpfs puede mejorar los tiempos de compilación.\n\nLa variable BUILDDIR se puede exportar temporalmente a makepkg para establecer el directorio de trabajo a un tmpfs existente. Por ejemplo:\n\n$ BUILDDIR=/tmp/makepkg makepkg\n\nLa configuración duradera se puede hacer en makepkg.conf descomentando la opción BUILDDIR, que se encuentra al final de la sección BUILD ENVIRONMENT en el archivo /etc/makepkg.conf por defecto. Estableciendo el valor en, por ejemplo, BUILDDIR=/tmp/makepkg hará que make use el sistema de archivos temporal /tmp por defecto en Arch.\n\n- Evita compilar paquetes grandes en tmpfs para prevenir que se ejecute fuera de memoria.\n- La carpeta tmpfs tiene que estar montada sin la opción noexec, si no evitara ejecutar la construcción de binarios.\n- Mantén en mente que los paquetes compilados en tmpfs no perdurarán en un reinicio. Considera establecer la opción PKGDEST apropiada para mover el paquete construido automáticamente a un directorio persistente.\n\n"
    },
    {
      "title": "Usar caché de compilación",
      "level": 4,
      "content": "El uso de ccache puede mejorar los tiempos de compilación generando caché los resultados de las compilaciones para utilizarlos sucesivamente.\n\n"
    },
    {
      "title": "Generar nueva suma de verificación",
      "level": 3,
      "content": "Instala pacman-contrib y ejecute el siguiente comando en el mismo directorio que el PKGBUILD para generar una nueva suma de verificación:\n\n```\n$ updpkgsums\n```\n\nLas sumas de verificación pueden también obtenerse con, por ejemplo, sha256sum y añadirlo al array sha256sums a mano.\n\n"
    },
    {
      "title": "Usar otros algoritmos de compresión",
      "level": 3,
      "content": "Para acelerar la empaquetación y la instalación, con la desventaja de tener paquetes más grandes, cambia PKGEXT. Por ejemplo, lo siguiente hace que el paquete se descomprima para una sola invocación:\n\n```\n$ PKGEXT='.pkg.tar' makepkg\n```\n\nOtro ejemplo, usar el algoritmo lzop, con el paquete necesario lzop:\n\n```\n$ PKGEXT='.pkg.tar.lzo' makepkg\n```\n\nPara hacer estas configuraciones permanentes, establece PKGEXT en /etc/makepkg.conf.\n\n"
    },
    {
      "title": "Uso de múltiples núcleos en la compresión",
      "level": 3,
      "content": "xz es compatible con Multiprocesamiento_simétrico (SMP) con el párametro --threads para acelerar la compresión. Para permitir que makepkg use tantos núcleos como sea possible al comprimir paquetes, edite la linea COMPRESSXZ en /etc/makepkg.conf:\n\n```\nCOMPRESSXZ=(xz -c -z - --threads=0)\n```\n\npigz es una implementación paralela de gzip en la que por defecto utiliza todos los núcleos de la CPU disponibles. El parámetro -p/--processes se puede utilizar para que utilice menos núcleos:\n\nCOMPRESSGZ=(pigz -c -f -n)\n\npbzip2 en un drop-in, la implementación paralela para bzip2 que también utiliza todos los nucleos CPU disponibles por defecto. El parámetro -p# se puede utilizar para emplear menos núcleos (Nota: no hay ningún espacio entre -p y el número de núcleos).\n\nCOMPRESSBZ2 =(pbzip2 -c -f)\n\nzstd soporta multiprocesamiento simétrico (SMP) a través de la bandera --threads para acelerar la compresión. Por ejemplo, para dejar que makepkg utilice tantos nucleos de CPU como sea posible para comprimir paquetes edite el array COMPRESSZST en /etc/makepkg.conf:\n\nCOMPRESSZST=(zstd -c -z -q - --threads=0)\n\n"
    },
    {
      "title": "Ver paquetes con un empaquetador específico",
      "level": 3,
      "content": "Esto muestra todos los paquetes instalados en el sistema con el empaquetador nombreempaqueetador:\n\n$ expac \"%n %p\" | grep \"nombreempaquetador\" | column -t\n\nEsto muestra todos los paquetes instalados en el sistema con el empaquetador establecido en la variable PACKAGER en el /etc/makepkg. Solo muestra los paquetes que están en el repositorio definido en /etc/pacman.conf.\n\n$ . /etc/makepkg.conf; grep -xvFf <(pacman -Qqm) <(expac \"%n\\t%p\" | grep \"$PACKAGER$\" | cut -f1)\n\n"
    },
    {
      "title": "Construir paquetes de 32-bit en un sistema de 64-bit",
      "level": 3,
      "content": "Primero, habilite el repositorio multilib e instala multilib-devel.\n\nDespués crea un archivo de configuración de 32-bit.\n\n```\n~/.makepkg.i686.conf\n```\n\n```\nCARCH=\"i686\"\nCHOST=\"i686-unknown-linux-gnu\"\nCFLAGS=\"-m32 -march=i686 -mtune=generic -O2 -pipe -fstack-protector-strong\"\nCXXFLAGS=\"${CFLAGS}\"\nLDFLAGS=\"-m32 -Wl,-O1,--sort-common,--as-needed,-z,relro\"\n```\n\ny ejecuta makepkg así\n\n```\n$ linux32 makepkg --config ~/.makepkg.i686.conf\n```\n\n"
    },
    {
      "title": "CFLAGS/CXXFLAGS/LDFLAGS en makepkg.conf no funcionan en los paquetes basados en CMake",
      "level": 3,
      "content": "Con el fin de dejar que CMake use las variables definidas en makepkg.conf, simplemente no especifique la variable -DCMAKE_BUILD_TYPE cuando configure un proyecto cmake.[3]\n\nEsto causa que cmake utilice una construcción tipo None en la que utiliza las variables de entorno como CFLAGS, CPPFLAGS, etc.\n\n"
    },
    {
      "title": "Especificar el directorio de instalación para los paquetes basados en QMAKE",
      "level": 3,
      "content": "El makefile generado por \"qmake\" utiliza la variable de entorno INSTALL_ROOT para determinar dónde se va a instalar el programa. Así que esta funcion del paquete debería funcionar:\n\n```\nPKGBUILD\n```\n\n```\n...\n\npackage() {\n\tcd \"$srcdir/${pkgname%-git}\"\n\tmake INSTALL_ROOT=\"$pkgdir\" install\n}\n\n...\n```\n\nTenga en cuenta que qmake tiene que estar configurado correctamente, por ejemplo ponga esto en su archivo \".pro\":\n\n```\nYourProject.pro\n```\n\n```\n...\n\ntarget.path = /usr/local/bin\nINSTALLS += target\n\n...\n```\n\n"
    },
    {
      "title": "ADVERTENCIA: Paquetes que contienen referencias a $srcdir",
      "level": 3,
      "content": "Por alguna razón, las cadenas $srcdir o $pkgdir literales acaban en uno de los archivos de instalación en su paquete.\n\nPara identificar que archivos son, ejecute lo siguiente desde el directorio de construcción de makepkg:\n\n```\n$ grep -R \"$PWD/src\" pkg/\n```\n\nUna posible causa puede ser por el uso de la macro __FILE__ en el código C/C++ con la ruta absoluta pasada al comilador.\n\n"
    },
    {
      "title": "Makepkg falla al descargar las dependencias a través de un proxy",
      "level": 3,
      "content": "Cuando makepkg llama a las dependencias, llama a pacman para instalar los paquetes, que requieren permisos administrativos via sudo. De todas formas, sudo no pasa ninguna variable de entorno al entorno con privilegios, incluido las variables relacionadas con el proxy ftp_proxy, http_proxy, https_proxy, y no_proxy.\n\nPara tener a makepkg trabajando a través de un proxy tiene que seguir uno de los dos métodos.\n\n"
    },
    {
      "title": "Habilitar proxy estableciendo su URL en XferCommand",
      "level": 4,
      "content": "XferCommand puede establecerse para utilizar la URL del proxy deseado en /etc/pacman.conf. Añade o descomenta la siguiente línea en su pacman.conf[4]:\n\n```\n/etc/pacman.conf\n```\n\n```\n...\nXferCommand = /usr/bin/curl -x http://username:password@proxy.proxyhost.com:80 -L -C - -f -o %o %u\n...\n```\n\n"
    },
    {
      "title": "Habilitar proxy via sudoer's env_keep",
      "level": 4,
      "content": "Alternativamente, puede querer utilizar la opción env_keep, que habilita preservar las variables dadas al entorno privilegiado. Vea Sudo (Español)#Variables de entorno para más información.\n\n"
    },
    {
      "title": "Makepkg falla, pero el make termina bien",
      "level": 3,
      "content": "Si algo se compila manualmente utilizando make, pero falla al utilizar makepkg, casi seguro que es porque el /etc/makepkg.conf establece la variable de compilación a algo que normalmente funciona, pero lo que usted esta compilando sea incompatible. Intente añadir estos parámetros a la linea options del PKGBUILD:\n\n!buildflags, para evitar que utilice CPPFLAGS, CFLAGS, CXXFLAGS, y LDFLAGS dadas por defecto.\n\n!makeflags, para evitar que utilice MAKEFLAGS por defecto, en caso de que se haya editado /etc/makepkg.conf para habilitar la compilación paralela.\n\n!debug, para evitar que utilice DEBUG_CFLAGS y DEBUG_CXXFLAGS dadas por defecto, en caso de que su paquete sea una construcción debug.\n\nSi alguno de estos parámetros soluciona el problema, lo puede indicar reportando un bug, si usted localiza que parámetro exactamente está causando el problema.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- makepkg(8) Manual Page\n- makepkg.conf(5) Manual Page\n- A Brief Tour of the Makepkg Process\n- makepkg source code\n\n"
    }
  ]
}