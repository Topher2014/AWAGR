{
  "title": "Crypttab (Português)",
  "url": "https://wiki.archlinux.org/title/Crypttab_(Portugu%C3%AAs)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n- Se precisa desbloquear remotamente o sistema de arquivos da partição raiz ou de outras partições na inicialização (máquinas sem monitor, servidores distantes...), siga instruções específicas em dm-crypt/Especificidades#Abrir remotamente a partição raiz (ou outra)[link quebrado: seção inválida].\n- Para facilitar a inserção de UUIDs, PARTUUIDs, etc. nos arquivos de configuração, você pode instalar e usar um editor de texto que suporta a inserção de saída de comandos () (e.x. nano com Ctrl+t, Vim ou Neovim com :read ou mcedit com Alt+u) e passar o comando lsblk ou blkid adequado. Alternativamente, você pode instalar um multiplexador de terminal e usar a sua funcionalidade de cópia e cola.\n\n"
    },
    {
      "title": "mkinitcpio",
      "level": 2,
      "content": "Em alguns cenários, um subconjunto dos seguintes hooks do mkinitcpio terão que ser habilitados:\n\nTable content:\nbusybox | systemd | Caso de uso\nencrypt | sd-encrypt | Sempre necessário quando a partição raiz, ou outra partição que precisa ser montada antes dela, é criptografada. Não é necessário em todos os casos, scripts de inicialização de sistema como crypttab cuidam do desbloqueio de outras partições criptografadas. Deve ser colocado depois do hook udev ou systemd.\nkeyboard | Necessário para o funcionamento do teclado no estágio inicial do espaço do usuário.\nkeymap | sd-vconsole | Trás suporte a teclados que não são do padrão US; deve ser colocado antes do hook encrypt. Defina seu padrão do seu teclado em /etc/vconsole.conf, veja Configuração de teclado no console#Configuração persistente.\nconsolefont | Carrega uma fonte alternativa para o console no estágio inicial do espaço do usuário. Defina sua fonte em /etc/vconsole.conf, veja Console do Linux#Configuração persistente.\n\nOutros hooks necessários devem ser claramente especificados durante a instalação do sistema.\n\nGere novamente o initramfs depois de salvar as mudanças.\n\n"
    },
    {
      "title": "Exemplos",
      "level": 3,
      "content": "Uma configuração típica em /etc/mkinitcpio.conf quando se usa o hook encrypt é:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\n...\nHOOKS=(base udev autodetect keyboard keymap consolefont modconf block encrypt lvm2 filesystems fsck)\n...\n```\n\nJá uma configuração com o initramfs baseado no systemd, fazendo uso do hook sd-encrypt, seria semelhante a:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\n...\nHOOKS=(base systemd autodetect keyboard sd-vconsole modconf block sd-encrypt lvm2 filesystems fsck)\n...\n```\n\n"
    },
    {
      "title": "Gerenciador de boot",
      "level": 2,
      "content": "Para habilitar a inicialização em uma partição raiz criptografada, um subconjunto dos seguintes parâmetros do kernel terão que ser configurados. Veja Parâmetros do kernel para instruções específicas para seu Gerenciador de boot.\n\nPor exemplo, se está usando o GRUB, os parâmetros relevantes são adicionados no /etc/default/grub, antes de gerar o arquivo de configuração principal. Veja também GRUB#Aviso ao instalar em chroot como outro ponto a se atentar.\n\nOs parâmetros do kernel irão variar de acordo com qual hook (encrypt ou sd-encrypt) você vai usar.\n\n"
    },
    {
      "title": "Parâmetros do Kernel",
      "level": 3,
      "content": "Parâmetros do kernel como root e resume são especificados da mesma forma para os hooks encrypt e sd-encrypt.\n\n"
    },
    {
      "title": "root",
      "level": 4,
      "content": "O parâmetro root= especifica o dispositivo do sistema de arquivos raiz (descriptografado):\n\n```\nroot=dispositivo\n```\n\n- Se o sistema de arquivos foi colocado diretamente no dispositivo descriptografado, o caminho será /dev/mapper/dmnome.\n- Se LVM vai ser ativado primeiro e contém um volume lógico raiz criptografado, a forma acima também é aplicável.\n- Se o sistema de arquivos raiz está no volume lógico de uma LVM criptografada, o mapeador de dispositivos vai estar em sua forma genérica root=/dev/grupoDoVolume/volumeLógico.\n\n"
    },
    {
      "title": "resume",
      "level": 4,
      "content": "```\nresume=dispositivo\n```\n\n- dispositivo nesse caso é a swap descriptografada, este parâmetro é utilizado com o objetivo de suspender para o disco. Se a swap está em uma partição separada, ela estará na forma de /dev/mapper/partição_swap. Veja também dm-crypt/Swap criptografada.\n\n"
    },
    {
      "title": "Usando o hook encrypt",
      "level": 3,
      "content": "Note: **um** \n\n- Abrir múltiplos discos criptografados[link quebrado: seção inválida] (FS#23182). Somente um dispositivo pode ser aberto no initramfs.\n- Usar um cabeçalho LUKS desanexado[link quebrado: seção inválida] (FS#42851).\n\n"
    },
    {
      "title": "cryptdevice",
      "level": 4,
      "content": "Este parâmetro fará o sistema solicitar a senha para abrir o dispositivo contendo a raiz criptografada na primeira inicialização (cold boot). Ele é utilizado para o hook encrypt identificar o dispositivo que contém o sistema criptografado:\n\n```\ncryptdevice=dispositivo:nomedm\n```\n\n- dispositivo é o caminho para o container criptografado que contém o sistema. É fortemente recomendado o uso de nomeação persistente de dispositivo de bloco.\n- nomedm é o nome do dispositivo mapeado que será dado ao container descriptografado, que estará disponível como /dev/mapper/nomedm.\n- Se possui um volume lógico raiz criptografado, LVM vai ser ativado primeiro, o grupo de volumes e o volume lógico raiz serão o dispositivo. Coloque da seguinte forma cryptdevice=/dev/grupo_de_volumes/volume_lógico_raiz:nomedm.\n\n"
    },
    {
      "title": "cryptkey",
      "level": 4,
      "content": "Este parâmetro especifica a localização de uma keyfile, o hook encrypt é necessário para ler e abrir o cryptdevice (a menos que a chave está em um caminho padrão, veja abaixo). Três parâmetros podem ser definidos, dependendo de como a keyfile existe, pode ser um arquivo no dispositivo, uma bitstream que começa em uma localização específica ou um arquivo incluido no initramfs.\n\nPara um arquivo no dispositivo o formato é:\n\n```\ncryptkey=dispositivo:tipo_do_sistema_de_arquivos:caminho\n```\n\n- dispositivo é o dispositivo de bloco onde a keyfile se encontra. Uso de nomeação persistente de dispositivo de bloco é fortemente recomendado.\n- tipo_do_sistema_de_arquivos é o tipo do sistema de arquivos do dispositivo (ou auto).\n- caminho é o caminho absoluto da keyfile dentro do dispositivo.\n\nExemplo: cryptkey=LABEL=pendrive:vfat:/chave_secreta\n\nPara uma bitstream no dispositivo, a localização é especificada com:\n\n```\ncryptkey=dispositivo:início:tamanho\n```\n\nOnde início e tamanho estão em bytes. Por exemplo, cryptkey=UUID=ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ:0:512 lê uma keyfile de 512 byte no começo do dispositivo.\n\nPara um arquivo incluído no initramfs o formato é[1]:\n\n```\ncryptkey=rootfs:caminho\n```\n\nExemplo: cryptkey=rootfs:/chave_secreta\n\nTambém note que se cryptkey não é especificada, o padrão /crypto_keyfile.bin (arquivo incluído no initramfs) será utilizado.[2]\n\nVeja também dm-crypt/Encriptação de dispositivo#Keyfiles.\n\n"
    },
    {
      "title": "crypto",
      "level": 4,
      "content": "Este parâmetro é especifíco para passar opções do modo plain do dm-crypt para o hook encrypt.\n\nSua forma é:\n\n```\ncrypto=<hash>:<cifra>:<tamanho_da_chave>:<início>:<pule>\n```\n\nOs argumentos são relacionados diretamente a opções do cryptsetup. Veja dm-crypt/Encriptação de dispositivo#Opções de encriptação para o modo plain.\n\nPara um disco criptografado com somente as opções padrão do modo plain, o argumento crypto deve ser especificado, mas cada entrada pode ser vazia:\n\n```\ncrypto=::::\n```\n\nUm exemplo especifíco é:\n\n```\ncrypto=sha512:twofish-xts-plain64:512:0:\n```\n\n"
    },
    {
      "title": "Usando o hook sd-encrypt",
      "level": 3,
      "content": "Todos os seguintes rd.luks podem ser trocados por luks. Os parâmetros rd.luks são somente reconhecidos pelo initrd, enquanto luks são reconhecidos tanto pelo sistema quanto pelo initrd. A menos que você queira controlar os dispositivos com argumentos dados ao kernel enquanto o sistema é inicializado, use rd.luks. Veja systemd-cryptsetup-generator(8) para mais informações e detalhes.\n\n- Se o arquivo /etc/crypttab.initramfs existe, mkinitcpio o adicionará ao initramfs como /etc/crypttab, você pode especificar nele dispositivos que precisam ser desbloqueados durante a inicialização. Sintaxe é documentada em #crypttab e crypttab(5).\n- /etc/crypttab.initramfs não é limitado somente ao uso do UUID como o rd.luks. Você pode usar qualquer um dos métodos de nomeação persistente de dispositivo de bloco.\n- Senhas entradas durante a inicialização são salvas em cache no chaveiro do kernel pelo systemd-cryptsetup(8), então se multiplos dispositivos podem ser abertos com a mesma senha (isto inclui os dispositivos no crypttab que são abertos depois da inicialização), então você precisará entrar cada senha somente uma vez.\n\n- Todos os parâmetros do rd.luks podem ser especificados múltiplas vezes para múltiplos volumes criptografados LUKS.\n- Os parâmetros do rd.luks somente suportam dispositivos LUKS detectáveis. Para abrir um dispositivo dm-crypt plain ou com cabeçalho do LUKS desanexado, você deve especificá-lo em /etc/crypttab.initramfs. Veja #crypttab para a sintaxe.\n\n"
    },
    {
      "title": "rd.luks.uuid",
      "level": 4,
      "content": "```\nrd.luks.uuid=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n```\n\nEspecifique o UUID do dispositivo a ser aberto na inicialização com este parâmetro. Se o UUID está em /etc/crypttab.initramfs, as opções listadas lá serão utilizadas. Para opções do luks.uuid, o /etc/crypttab.initramfs ou /etc/crypttab será usado.\n\nPor padrão o dispositivo mapeado estará localizado en /dev/mapper/luks-XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX onde XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX é o UUID da partição LUKS.\n\n"
    },
    {
      "title": "rd.luks.name",
      "level": 4,
      "content": "```\nrd.luks.name=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=nome\n```\n\nEspecifique o nome do dispositivo mapeado depois que a partição LUKS é aberta, onde XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX é o UUID dela. É equivalente ao segundo parâmetro do encrypt, cryptdevice.\n\nExemplo, especificar rd.luks.name=12345678-9ABC-DEF0-1234-56789ABCDEF0=cryptraiz faz o dispositivo LUKS aberto do UUID 12345678-9ABC-DEF0-1234-56789ABCDEF0 estar localizado em /dev/mapper/cryptroot.\n\n"
    },
    {
      "title": "rd.luks.options",
      "level": 4,
      "content": "```\nrd.luks.options=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=opções\n```\n\nou\n\n```\nrd.luks.options=opções\n```\n\nDefina as opções para um dispositivo especificado com o UUID ou, se não especificado, para todos os UUIDs especificados em outro lugar (e.g., crypttab).\n\nÉ relativamente equivalente ao terceiro parâmetro do encrypt, cryptdevice.\n\nSegue um formato similar às opções usadas no crypttab - opções são separadas por vírgulas, opções com valores são especificados com opção=valor.\n\nExemplo:\n\n```\nrd.luks.options=timeout=10s,swap,cipher=aes-cbc-essiv:sha256,size=256\n```\n\n"
    },
    {
      "title": "rd.luks.key",
      "level": 4,
      "content": "Especifique a localização da keyfile que será utilizada para abrir o dispositivo especificado com o UUID. Não há uma localização padrão para a keyfile, como existe com o parâmetro do hook encrypt, cryptkey.\n\nSe a keyfile está incluída no initramfs:\n\n```\nrd.luks.key=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=/caminho/para/keyfile\n```\n\nou\n\n```\nrd.luks.key=/caminho/para/keyfile\n```\n\nSe a keyfile está em outro dispositivo:\n\n```\nrd.luks.key=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=/caminho/para/keyfile:UUID=ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ\n```\n\nSubstitua UUID=ZZZZZZZZ-ZZZZ-ZZZZ-ZZZZ-ZZZZZZZZZZZZ com o identificador do dispositivo que a keyfile está localizada. Se o sistema de arquivos utilizado não é o mesmo do sistema raiz, você deve incluir o módulo dele no initramfs.\n\n```\nrd.luks.options=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX=keyfile-timeout=10s\n```\n\n"
    },
    {
      "title": "Timeout",
      "level": 4,
      "content": "Existem duas opções que irão afetar o tempo de espera até a senha ser solicitada durante a inicialização:\n\n- rd.luks.options=timeout=tempo_limite especifica o tempo máximo para achar a senha\n- rootflags=x-systemd.device-timeout=tempo_limite especifica o quanto systemd deve esperar pelo dispositivo até desistir (padrão 90 segundos)\n\nSe deseja desabilitar os tempos de espera, então defina ambos para zero:\n\n```\nrd.luks.options=timeout=0 rootflags=x-systemd.device-timeout=0\n```\n\n"
    },
    {
      "title": "crypttab",
      "level": 2,
      "content": "O arquivo /etc/crypttab (tabela de dispositivos criptografados) é similar ao arquivo fstab e contém uma lista de dispositivos criptografados que serão abertos durante a inicialização. Este arquivo pode ser usado para montar automaticamente dispositivos swap ou sistemas de arquivos não raiz.\n\ncrypttab é lido antes do fstab, então os containers do dm-crypt podem ser abertos antes que o sistema de arquivos seja montado. Note que crypttab é lido depois que o sistema inicia, logo não é um substituto para abrir partições criptografadas com os hooks do mkinitcpio e opções do gerenciador de boot como no caso de criptografar a partição raiz. A leitura do crypttab é feita na inicialização pelo systemd-cryptsetup-generator automaticamente.\n\nVeja crypttab(5) para detalhes, veja abaixo alguns exemplos, e a seção #Montando na inicialização para instruções de como usar UUIDs para montar um dispositivo criptografado.\n\nNote: **Não** \n\n- Se a opção nofail é especificada, a tela de entrada da senha pode desaparecer enquanto digita. nofail deve então somente ser usada junto com keyfiles.\n- Existem problemas no systemd quando ele processa entradas do crypttab para o modo plain (--type plain) do dm-crypt: Para dispositivos --type plain com uma keyfile, é necessário adicionar a opção hash=plain para o crypttab devido a uma incompatibilidade do systemd. Não use systemd-cryptsetup manualmente para a criação do dispositivo como medida provisória. Pode ser necessário adicionar a opção plain explicitamente para forçar systemd-cryptsetup a reconhecer o dispositivo (--type plain) na inicialização. Veja issue do systemd 442.\n\n- Para dispositivos --type plain com uma keyfile, é necessário adicionar a opção hash=plain para o crypttab devido a uma incompatibilidade do systemd. Não use systemd-cryptsetup manualmente para a criação do dispositivo como medida provisória.\n- Pode ser necessário adicionar a opção plain explicitamente para forçar systemd-cryptsetup a reconhecer o dispositivo (--type plain) na inicialização. Veja issue do systemd 442.\n\n```\n/etc/crypttab\n```\n\n```\n# Exemplo de um arquivo crypttab. campos são: nome, dispositivo criptografado, senha, opções do cryptsetup.\n\n# Monte /dev/lvm/swap criptografando-a com uma nova chave a cada inicialização.\n swap\t/dev/lvm/swap\t/dev/urandom\tswap,cipher=aes-xts-plain64,size=256\n\n# Monte /dev/lvm/tmp como /dev/mapper/tmp usando o modo plain do dm-crypt com uma senha randômica, fazendo seu conteúdo não recuperável depois de desmontada.\ntmp\t/dev/lvm/tmp\t/dev/urandom\ttmp,cipher=aes-xts-plain64,size=256 \n\n# Monte /dev/lvm/home como /dev/mapper/home usando LUKS, solicite a senha durante a inicialização.\nhome   /dev/lvm/home\n\n# Monte /dev/sdb1 como /dev/mapper/backup usando LUKS, com uma senha guardada em um arquivo.\nbackup /dev/sdb1       /home/alice/backup.key\n```\n\nPara testar seu crypttab imediatamente depois de editá-lo, recarregue o gerenciador de configuração do systemd com:\n\n```\n# systemctl daemon-reload\n```\n\ne inicie o recentemente gerado systemd-cryptsetup@nome.service.\n\n```\n# cryptsetup status name\n```\n\n```\n/dev/mapper/name is active.\n  type:    ...\n  cipher:  ...\n  keysize: ... bits\n  key location: ...\n  device:  /dev/sdxN\n  sector size:  ...\n  offset:  ... sectors\n  size:    ... sectors\n  mode:    ...\n  flags:   ...\n```\n\nPara mais informações sobre systemd-cryptsetup@nome.service, veja #Montando em demanda.\n\n"
    },
    {
      "title": "Montando na inicialização",
      "level": 3,
      "content": "Se você quer montar uma unidade de armazenamento criptografada na inicialização, você pode colocar o UUID do dispositivo em /etc/crypttab. Para descobrir o UUID (da partição) pode usar o comando lsblk -f e adicioná-lo ao crypttab desse jeito:\n\n```\n/etc/crypttab\n```\n\n```\ndisco_externo         UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX        none    luks,timeout=180\n```\n\nO primeiro parâmetro é o nome que o dispositivo criptografado vai receber quando aberto(que fica a sua preferência). A opção none fará a senha ser solicitada durante a inicialização. A opção timeout define um tempo de espera máximo em segundos para entrar com a senha.\n\n"
    },
    {
      "title": "Desbloqueando com uma keyfile",
      "level": 4,
      "content": "Se a keyfile para um sistema de arquivos não raiz está guardada dentro do sistema criptografado, ela está segura quando o sistema está desligado e pode ser automaticamente aberto durante a inicialização via crypttab. Por exemplo, abrir um dispositivo especificado com UUID:\n\n```\n/etc/crypttab\n```\n\n```\nhome    UUID=<identificador UUID>    /etc/cryptsetup-keys.d/home-crypt.key\n```\n\n- Se uma keyfile não é especificada, systemd-cryptsetup(8) irá automaticamente tentar carregá-la de /etc/cryptsetup-keys.d/nome.key e /run/cryptsetup-keys.d/nome.key.[3]\n- Se você prefere usar o modo --plain, as opções de encriptação necessárias para abrir o dispositivo deverão ser especificadas no /etc/crypttab. Tome cuidado ao fazer a medida provisória mencionada no crypttab.\n\nUse o nome do dispositivo mapeado (definido no /etc/crypttab) para fazer a entrada no /etc/fstab:\n\n```\n/etc/fstab\n```\n\n```\n/dev/mapper/home        /home   ext4        defaults        0       2\n```\n\nDesde que /dev/mapper/home já é uma mapeação única, não existe a necessidade de especificar o UUID dele. Em qualquer caso, o sistema de arquivos mapeado vai ter um UUID diferente da partição criptografada.\n\n"
    },
    {
      "title": "Montando um dispositivo de bloco empilhado",
      "level": 4,
      "content": "Os geradores do systemd também processam automaticamente os dispositivos de bloco empilhados na inicialização.\n\nPor exemplo, você pode usar o cryptsetup numa configuração do RAID e criar um volume lógico LVM com o sistema de arquivos dentro de um dispositivo de bloco criptografado. Resultando em:\n\n```\n$ lsblk -f\n```\n\n```\n─sdXX                  linux_raid_member    \n│ └─md0                 crypto_LUKS   \n│   └─cryptedbackup     LVM2_member \n│     └─vgraid-lvraid   ext4              /mnt/backup\n└─sdYY                  linux_raid_member    \n  └─md0                 crypto_LUKS       \n    └─cryptedbackup     LVM2_member \n      └─vgraid-lvraid   ext4              /mnt/backup\n```\n\nA senha será solicitada e ele será montado na inicialização.\n\nAo especificar corretamente as entradas do crypttab (exemplo, UUID para o dispositivo crypto_LUKS) e fstab (/dev/vgraid/lvraid), não há necessidade para configurações/hooks adicionais no mkinitcpio, devido ao processamento do /etc/crypttab aplicado às partições não raiz somente. Existe uma exceção, quando o hook mdadm_udev já é usado (exemplo, o dispositivo raiz). Neste caso é necessário atualizar o /etc/madadm.conf e o initramfs para que a raid raiz correta seja selecionada.\n\n"
    },
    {
      "title": "Montando em demanda",
      "level": 3,
      "content": "Ao invés de:\n\n```\n# cryptsetup luksOpen UUID=... disco_externo\n```\n\nVocê pode iniciar o systemd-cryptsetup@disco_externo.service, quando você tem uma entrada como a seguir em seu /etc/crypttab:\n\n```\n/etc/crypttab\n```\n\n```\ndisco_externo UUID=... none noauto\n```\n\nDesta maneira você não precisa se lembrar exatamente das opções do crypttab. A senha será solicitada se necessário.\n\nO arquivo correspondente unit é gerada automaticamente pelo systemd-cryptsetup-generator(8). Você pode listar todos os arquivos unit gerados usando:\n\n```\n$ systemctl list-unit-files | grep systemd-cryptsetup\n```\n\n"
    },
    {
      "title": "Sistema travado no prompt de inicialização/senha não aparece",
      "level": 3,
      "content": "Se você está usando Plymouth, tenha certeza de usar os módulos corretos (veja Plymouth#O hook do plymouth) ou desabilite isso. De outra forma, Plymouth irá atrapalhar o prompt de senha, impedindo o sistema de inicializar.\n\n"
    }
  ]
}