{
  "title": "Bash (日本語)",
  "url": "https://wiki.archlinux.org/title/Bash_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Bash/関数\n- Bash/プロンプトのカスタマイズ\n- 環境変数\n- Readline\n- Fortune\n- Pkgfile\n- コマンドラインシェル\n\nBash (Bourne-again Shell) は GNU プロジェクトによるコマンドラインシェル/プログラミング言語です。Bash という名前は、長い間非推奨であった Bourne shell という先祖の名前のオマージュから来ています。Bash は GNU/Linux を含むほとんどの UNIX ライクなオペレーティングシステムで動作します。\n\nBash は、Arch Linux のデフォルトのコマンドラインシェルです。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 実行 1.1 設定ファイル 1.2 シェルと環境変数\n- 2 コマンドライン 2.1 タブ補完 2.1.1 シングルタブ 2.1.2 よく使われるプログラムとオプション 2.1.3 コマンド毎にカスタマイズする 2.2 履歴 2.2.1 履歴による補完 2.2.2 履歴のカスタマイズ 2.2.3 履歴を無効にする 2.3 Zsh の run-help 機能を模倣する\n- 3 エイリアス\n- 4 ヒントとテクニック 4.1 プロンプトのカスタマイズ 4.2 シンタックスハイライトとオートサジェスト機能 4.3 Command not found 4.4 ターミナルで Ctrl+z を無効化 4.5 ログアウト後に画面をクリア 4.6 パスを入力したら自動で \"cd\" 4.7 Autojump 4.8 ファイルの上書きを防止する 4.9 ディレクトリスタックを使用して移動する\n- 5 トラブルシューティング 5.1 ウィンドウをリサイズした時の行の折り返し 5.2 ignoreeof が設定されているのにシェルが終了する 5.3 スクリプトを解析してエラーをチェックする\n- 6 参照 6.1 チュートリアル 6.2 コミュニティ 6.3 サンプル\n\n- 1.1 設定ファイル\n- 1.2 シェルと環境変数\n\n- 2.1 タブ補完 2.1.1 シングルタブ 2.1.2 よく使われるプログラムとオプション 2.1.3 コマンド毎にカスタマイズする\n- 2.2 履歴 2.2.1 履歴による補完 2.2.2 履歴のカスタマイズ 2.2.3 履歴を無効にする\n- 2.3 Zsh の run-help 機能を模倣する\n\n- 2.1.1 シングルタブ\n- 2.1.2 よく使われるプログラムとオプション\n- 2.1.3 コマンド毎にカスタマイズする\n\n- 2.2.1 履歴による補完\n- 2.2.2 履歴のカスタマイズ\n- 2.2.3 履歴を無効にする\n\n- 4.1 プロンプトのカスタマイズ\n- 4.2 シンタックスハイライトとオートサジェスト機能\n- 4.3 Command not found\n- 4.4 ターミナルで Ctrl+z を無効化\n- 4.5 ログアウト後に画面をクリア\n- 4.6 パスを入力したら自動で \"cd\"\n- 4.7 Autojump\n- 4.8 ファイルの上書きを防止する\n- 4.9 ディレクトリスタックを使用して移動する\n\n- 5.1 ウィンドウをリサイズした時の行の折り返し\n- 5.2 ignoreeof が設定されているのにシェルが終了する\n- 5.3 スクリプトを解析してエラーをチェックする\n\n- 6.1 チュートリアル\n- 6.2 コミュニティ\n- 6.3 サンプル\n\n"
    },
    {
      "title": "実行",
      "level": 2,
      "content": "Bash は、起動の仕方によって動作が変わります。以下、一部のモードについて説明します。\n\nBash が TTY 内で login コマンドによって呼び出された場合や、SSH デーモンによって呼び出された場合、その他の似たような方法によって呼び出された場合、ログインシェルとみなされます。また、-l/--login コマンドラインオプションを使用した場合も、このモードが有効化されます。\n\nBash の標準入力、標準出力、そして標準エラー出力がターミナルに接続されていて (例えば、ターミナル内で実行された場合)、かつ、-c オプションも非オプション引数 (例えば bash スクリプト) も使用されずに起動された場合、インタラクティブシェルとみなされます。全てのインタラクティブシェルは /etc/bash.bashrc と ~/.bashrc を読み込んで実行します。一方、インタラクティブなログインシェルは、これらに加えて /etc/profile と ~/.bash_profile も読み込んで実行します。\n\n"
    },
    {
      "title": "設定ファイル",
      "level": 3,
      "content": "Bash は一連のスタートアップファイルを実行しようと試みます。読み込まれるファイルは、Bash がどのように実行されたかに依存します。完全な説明は、GNU Bash マニュアルの Bash Startup Files 章を参照してください。\n\nTable content:\nファイル | 説明 | ログインシェル (以下のノートを参照) | インタラクティブ (非ログインシェル)\n/etc/profile | /etc/profile.d/*.sh と /etc/bash.bashrc のアプリケーションの設定を source します。 | Yes | No\n~/.bash_profile | ユーザ毎の設定ファイルです。/etc/profile のあとに読み込まれます。このファイルが存在しない場合、~/.bash_login と ~/.profile がこの順番でチェックされます。スケルトンファイル /etc/skel/.bash_profile は ~/.bashrc も読み込みます。 | Yes | No\n~/.bash_logout | ユーザ毎の設定ファイル。ログインシェルが終了する際に実行されます。 | Yes | No\n/etc/bash.bash_logout | このファイルが読み込まれるかどうかは、-DSYS_BASH_LOGOUT=\"/etc/bash.bash_logout\" コンパイルフラグに依存します。ログインシェルの終了時に実行されます。 | Yes | No\n/etc/bash.bashrc | このファイルが読み込まれるかどうかは、-DSYS_BASHRC=\"/etc/bash.bashrc\" コンパイルフラグに依存します。このファイルは /usr/share/bash-completion/bash_completion を読み込みます。 | No | Yes\n~/.bashrc | ユーザ毎の設定ファイル。/etc/bash.bashrc の後に読み込まれます。 | No | Yes\n\n- ログインシェルは、--login 引数付きで呼び出された場合に非インタラクティブになり得ます。\n- インタラクティブな非ログインシェルは、~/.bash_profile を読み込みません。ですが、依然として親プロセスの環境変数を継承します (親プロセスがログインシェルであっても)。詳細は https://mywiki.wooledge.org/ProcessManagement#On_processes.2C_environments_and_inheritance を参照してください。\n\n"
    },
    {
      "title": "シェルと環境変数",
      "level": 3,
      "content": "Bash、及び Bash によって実行されるプログラムの動作は、様々な環境変数による影響を受ける可能性があります。環境変数は、コマンドが探索されるディレクトリのリストや、どのブラウザを使用するかなど、有用な値を保存するために使用されます。新しいシェルやスクリプトが実行された際、そのプロセスは親プロセスの変数を継承します。つまり、内部のシェル変数を持った状態で起動されるわけです [1]。\n\nBash 内のシェル変数を環境変数とするには、export する必要があります:\n\n```\nVARIABLE=content\nexport VARIABLE\n```\n\nこれは、以下のようにショートカットすることも可能です:\n\n```\nexport VARIABLE=content\n```\n\n伝統的に環境変数は、他の Bourne 互換のシェルも使用できるようにするために、~/.profile や /etc/profile 内で定義されます。\n\nより一般的な情報は 環境変数 を参照してください。\n\n"
    },
    {
      "title": "コマンドライン",
      "level": 2,
      "content": "Bash のコマンドラインは Readline という名前の別のライブラリによって処理されています。Readline は、コマンドラインと対話 (つまり、単語単位で前後に移動したり、単語を削除したりなど) するための emacs や vi スタイルのショートカットを提供しています。また、入力したコマンドの履歴を管理するのも Readline の仕事です。最後に、また重要なことですが、Readline はマクロの作成も可能にします。\n\n"
    },
    {
      "title": "タブ補完",
      "level": 3,
      "content": "タブ補完とは、Tab を押すことによって入力済みのコマンドを自動補完するオプションです (デフォルトで有効)。\n\n"
    },
    {
      "title": "シングルタブ",
      "level": 4,
      "content": "コマンドの補完候補を全て表示するにはタブを最大で3回押す必要があります。タブを押す回数を減らしたい場合は、Readline#高速な補完 を参照してください。\n\n"
    },
    {
      "title": "よく使われるプログラムとオプション",
      "level": 4,
      "content": "デフォルトでは、Bash によってタブ補完されるのはコマンド、ファイル名、そして変数のみです。bash-completion をインストールすると、よく使われるコマンドとオプションに対するタブ補完も追加されます。この補完は、/usr/share/bash-completion/bash_completion を source することで有効化することができます (このファイルは Arch Linux の /etc/bash.bashrc で既に source されています)。bash-completion を使うと、($ ls file.*<tab><tab> などの) 通常の補完も挙動が変化しますが、$ compopt -o bashdefault program によって元に戻すことができます (詳しくは [2] と [3] を参照)。\n\n"
    },
    {
      "title": "コマンド毎にカスタマイズする",
      "level": 4,
      "content": "デフォルトでは、Bash はコマンドの後のファイル名しかタブ補完しません。complete -c を使うことで、コマンド名も補完できるようにできます:\n\n```\n~/.bashrc\n```\n\n```\ncomplete -c man which\n```\n\nまた、-cf でコマンド名とファイル名を補完できます:\n\n```\ncomplete -cf sudo\n```\n\nその他の補完オプションは bash(1) § Programmable Completion を見てください。\n\n"
    },
    {
      "title": "履歴による補完",
      "level": 4,
      "content": "上下キーを Bash 履歴の検索に割り当てることができます (Readline#履歴 と Readline Init File Syntax を参照):\n\n```\n~/.bashrc\n```\n\n```\nbind '\"\\e[A\": history-search-backward'\nbind '\"\\e[B\": history-search-forward'\n```\n\nあるいは、全ての readline プログラムに適用するには:\n\n```\n~/.inputrc\n```\n\n```\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n```\n\n"
    },
    {
      "title": "履歴のカスタマイズ",
      "level": 4,
      "content": "HISTCONTROL 変数により、特定のコマンドを履歴に残さないようにできます。\n\n連続する同じコマンドを記録しない:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=ignoredups\n```\n\n同じコマンドは、一番最後を除いて記録しない:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=erasedups\n```\n\n空白で始まるコマンドは記録しない:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=ignorespace\n```\n\n連続する同じコマンド、及び空白で始まるコマンドは記録しない:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=ignoreboth\n```\n\n同じコマンドは、一番最後を除いて記録せず、さらに空白で始まるコマンドも記録しない:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=\"erasedups:ignorespace\"\n```\n\n詳細は bash(1) § HISTCONTROL を参照してください。\n\n"
    },
    {
      "title": "履歴を無効にする",
      "level": 4,
      "content": "一時的に Bash の履歴を無効化するには:\n\n```\n$ set +o history\n```\n\n以降、入力されたコマンドは $HISTFILE に記録されません。\n\nこれで、機密情報をディスクに残すことなく、printf シークレット | sha256sum でパスワードのハッシュ値を計算したり、gpg -eaF secret-pubkey.asc などの GPG の使用履歴を隠蔽したりできるようになります。\n\n履歴を有効化するには:\n\n```\n$ set -o history\n```\n\n全ての Bash 履歴を無効化するには:\n\n```\n~/.bashrc or /etc/profile\n```\n\n```\nexport HISTSIZE=0\n```\n\n...そして、念のため、古い履歴ファイルを完全に削除してください:\n\n```\n$ wipe -i -l2 -x4 -p4 \"$HISTFILE\"\n$ ln -sv /dev/null \"$HISTFILE\"\n```\n\n"
    },
    {
      "title": "Zsh の run-help 機能を模倣する",
      "level": 3,
      "content": "Zsh では Alt+h を押すことで、入力したコマンドのマニュアルを呼び出すことができます。Readline の bind を使うことで Bash でも同じようにできます:\n\n```\n~/.bashrc\n```\n\n```\nrun-help() { help \"$READLINE_LINE\" 2>/dev/null || man \"$READLINE_LINE\"; }\nbind -m vi-insert -x '\"\\eh\": run-help'\nbind -m emacs -x     '\"\\eh\": run-help'\n```\n\n上記では、(デフォルトの) Emacs 編集モードを使用していることを前提としています。\n\n"
    },
    {
      "title": "エイリアス",
      "level": 2,
      "content": "alias は、ある単語の別名を定義するコマンドです。システムコマンドを短縮したり、日頃使っているコマンドにデフォルトの引数を追加したりするために使用されます。\n\nユーザ毎のエイリアスは、~/.bashrc に定義するか、別のファイルに記述して ~/.bashrc からそのファイルを source することができます。システム全体で使用される (つまり、全てのユーザに適用される) エイリアスは /etc/bash.bashrc に記述します。エイリアスの例は [4] を見てください。\n\n関数については、Bash/関数 を参照してください。\n\n"
    },
    {
      "title": "プロンプトのカスタマイズ",
      "level": 3,
      "content": "Bash/プロンプトのカスタマイズ を見てください。\n\n"
    },
    {
      "title": "シンタックスハイライトとオートサジェスト機能",
      "level": 3,
      "content": "blesh-gitAUR は、純粋な Bash で記述されたコマンドラインエディタであり、Readline の置き換えです。シンタックスハイライト、オートサジェスト、メニュー補完、略語、Vim 編集モード、フック関数など、多くの強化された機能を備えています。\n\nインストール後、対話型セッションで設定ファイルを source してください。設定は ~/.blerc ファイルと wiki で詳しく説明されています。安定版の bleshAUR パッケージも利用可能です。\n\n"
    },
    {
      "title": "Command not found",
      "level": 3,
      "content": "pkgfile には \"command not found\" フックが含まれており、認識できないコマンドが入力されると自動的に公式リポジトリを検索します。\n\nこのフックを有効化するには、source する必要があります。例:\n\n```\n~/.bashrc\n```\n\n```\nsource /usr/share/doc/pkgfile/command-not-found.bash\n```\n\n以降、利用できないコマンドを実行しようとすると、次のような情報が表示されるようになります:\n\n```\n$ abiword\n```\n\n```\nabiword may be found in the following packages:\n  extra/abiword 3.0.1-2\t/usr/bin/abiword\n```\n\n"
    },
    {
      "title": "ターミナルで Ctrl+z を無効化",
      "level": 3,
      "content": "以下のようにコマンドをラップすることで、Ctrl+z 機能 (アプリケーションの停止/終了) を無効化することができます:\n\n```\n#!/bin/bash\ntrap \"\" 20\nadom\n```\n\nこれで、adomAUR で Shift+z ではなく Ctrl+z を間違って押しても、Ctrl+z は無視されるため何も起こりません。\n\n"
    },
    {
      "title": "ログアウト後に画面をクリア",
      "level": 3,
      "content": "仮想コンソールでログアウト後に画面を消去するには:\n\n```\n~/.bash_logout\n```\n\n```\nclear\nreset\n```\n\n"
    },
    {
      "title": "パスを入力したら自動で \"cd\"",
      "level": 3,
      "content": "シェルにパスだけを入力したとき Bash に cd を自動で前につけるようにすることができます。例えば通常は以下のようになりますが:\n\n```\n$ /etc\n```\n\n```\nbash: /etc: ディレクトリです\n```\n\n.bashrc に以下の設定を追加すると:\n\n```\n~/.bashrc\n```\n\n```\n...\nshopt -s autocd\n...\n```\n\n次の通り:\n\n```\n[user@host ~]$ /etc\ncd /etc\n[user@host etc]$\n```\n\n"
    },
    {
      "title": "Autojump",
      "level": 3,
      "content": "autojump-gitAUR は、ユーザがよく訪れるパスが記録されたデータベースを検索することでファイルシステムの移動を速くできる Python スクリプトです。\n\nzoxide はこれの代替品で、オリジナルの autojump に比べてより多くの機能があり、パフォーマンスも優れているので、autojump の完全な代用として使うことができます。\n\n"
    },
    {
      "title": "ファイルの上書きを防止する",
      "level": 3,
      "content": "現在のセッション限定で、シェル出力のリダイレクトによる既存の通常ファイルへの上書きを禁止するには:\n\n```\n$ set -o noclobber\n```\n\nこれは set -C と同じです。\n\nユーザ毎にこの設定を永続化するには:\n\n```\n~/.bashrc\n```\n\n```\n...\nset -o noclobber\n```\n\nnoclobber が設定されている状態でファイルを手動で上書きするには:\n\n```\n$ echo \"output\" >| file.txt\n```\n\n"
    },
    {
      "title": "ディレクトリスタックを使用して移動する",
      "level": 3,
      "content": "pushd と popd を使用すると、ディレクトリに切り替えるときにスタックにディレクトリをプッシュまたはポップできます。これは、ナビゲーション履歴を リプレイ するのに役立ちます。\n\n```\n[user@host ~] pushd /tmp/dir1\n[user@host /tmp/dir1] pushd /var/lib\n[user@host/var/lib] popd\n[user@host/tmp/dir1] popd\n[user@host ~]\n```\n\nbash(1) § DIRSTACK を参照してください。\n\n"
    },
    {
      "title": "ウィンドウをリサイズした時の行の折り返し",
      "level": 3,
      "content": "ターミナルエミュレータのウィンドウサイズを変更した時、Bash はリサイズシグナルを受け取らないことがあります。そうすると入力したテキストが正しく折り返されずにプロンプトをはみ出してしまいます。checkwinsize シェルオプションはコマンドごとにウィンドウサイズの確認を行い、必要ならば、LINES と COLUMNS の値を更新します。\n\n```\n~/.bashrc\n```\n\n```\nshopt -s checkwinsize\n```\n\n"
    },
    {
      "title": "ignoreeof が設定されているのにシェルが終了する",
      "level": 3,
      "content": "ignoreeof オプションが設定されているのに、ctrl-d を繰り返し入力するとシェルが終了してしまうのは、このオプションは ctrl-d を連続10回押すと (厳密には連続する10個の EOF 文字が入力されると) シェルが終了するように設定することが原因です。\n\nこの回数をより多くするには、IGNOREEOF 変数を設定してください。例:\n\n```\nexport IGNOREEOF=100\n```\n\n"
    },
    {
      "title": "スクリプトを解析してエラーをチェックする",
      "level": 3,
      "content": "shellcheck パッケージは bash (及び他のシェル) のスクリプトを解析し、考えられるエラーを表示し、より良いコードを提案します。\n\nまた、このプログラムをベースにした同じ目的のウェブサイト shellcheck.net も存在します。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Wikipedia:ja:Bash\n- Bash Reference Manual (あるいは /usr/share/doc/bash/bashref.html)\n- Readline Init File Syntax\n- The Bourne-Again Shell - The Architecture of Open Source Applications の第3章\n- PS1 generator - ドラッグアンドドロップのインターフェイスで .bashrc/PS1 Bash プロンプトを生成してくれます。\n- その他の便利な .bashrc コマンド\n\n"
    },
    {
      "title": "チュートリアル",
      "level": 3,
      "content": "- Greg's Wiki\n- Greg's Wiki: BashGuide\n- Greg's Wiki: BashFAQ\n- Quote Tutorial\n\n"
    },
    {
      "title": "コミュニティ",
      "level": 3,
      "content": "- Bash のための アクティブでフレンドリーな IRC チャネル\n\n"
    },
    {
      "title": "サンプル",
      "level": 3,
      "content": "- How to change the title of an xterm\n\n"
    }
  ]
}