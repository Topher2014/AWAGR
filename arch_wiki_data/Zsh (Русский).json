{
  "title": "Zsh (Русский)",
  "url": "https://wiki.archlinux.org/title/Zsh_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Zsh является мощной современной оболочкой, которая работает как в интерактивном режиме, так и в качестве интерпретатора языка сценариев. Он совместим с bash (не по умолчанию, только в режиме emulate sh), но имеет преимущества, такие как улучшенное завершение и подстановка.\n\nЕще больше причин, по которым стоит использовать Zsh, перечислено в Zsh FAQ EN.\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Перед установкой вы можете посмотреть, какая оболочка используется в данный момент:\n\n```\n$ echo $SHELL\n```\n\nУстановите пакет zsh. Чтобы значительно расширить возможности автодополнения команд, установите также пакет zsh-completions.\n\n"
    },
    {
      "title": "Первоначальная настройка",
      "level": 3,
      "content": "Убедитесь, что Zsh был установлен правильно, выполнив следующую команду в терминале:\n\n```\n$ zsh\n```\n\nПосле этого вы должны увидеть скрипт zsh-newuser-install, который проведет вас через некоторые основные настройки. Если вы хотите пропустить первичную настройку, нажмите q. Если скрипт не запустился, вы можете вызвать его вручную:\n\n```\n$ autoload -Uz zsh-newuser-install\n$ zsh-newuser-install -f\n```\n\n"
    },
    {
      "title": "Установка Zsh в качестве оболочки по умолчанию",
      "level": 3,
      "content": "Вы можете изменить оболочку по умолчанию на /usr/bin/zsh. Смотрите раздел Командная оболочка#Выбор оболочки по умолчанию.\n\n"
    },
    {
      "title": "Файлы запуска/завершения",
      "level": 2,
      "content": "- Если $ZDOTDIR не определена, используется $HOME по умолчанию.\n- Если опция RCS удаляется в одном из файлов, никакие файлы конфигурации больше не будут прочитаны после этого файла.\n- Если опция GLOBAL_RCS удаляется в одном из файлов, никакие глобальные файлы конфигурации (/etc/zsh/*) не будут прочитаны после этого файла.\n\nПри запуске Zsh по умолчанию он будет загружать следующие файлы в этом порядке:\n\n- /etc/zsh/zshenv — используется для установки переменных окружения для всех пользователей; он не должен содержать команд, которые производят вывод или предполагают, что shell подключен к TTY. Если файл существует, он всегда будет прочитан, это нельзя переопределить.\n- $ZDOTDIR/.zshenv — используется для установки переменных окружения текущего пользователя; он не должен содержать команд, которые производят вывод или предполагают, что shell подключен к TTY. Если файл существует, он всегда будет прочитан.\n- /etc/zsh/zprofile — используется для выполнения команд для всех пользователей, будет прочитан при запуске оболочки входа. Обратите внимание, что в Arch Linux по умолчанию он содержит одну строку, считывающую /etc/profile. /etc/profile — этот файл должен быть прочитан всеми POSIX sh-совместимыми оболочками при входе в систему: он устанавливает $PATH и другие переменные окружения, а также специфичные для приложения (/etc/profile.d/*.sh) настройки при входе в систему.\n- $ZDOTDIR/.zprofile — используется для выполнения команд текущего пользователя, будет прочитан при запуске оболочки входа. Обычно используется для автозапуска графического сеанса или установки переменных окружения для сеанса.\n- /etc/zsh/zshrc — используется для настройки интерактивной конфигурации оболочки и выполнения команд для всех пользователей, будет прочитан при запуске интерактивной оболочки.\n- $ZDOTDIR/.zshrc — используется для настройки интерактивной конфигурации и выполнения команд текущего пользователя, будет прочитан при запуске интерактивной оболочки.\n- /etc/zsh/zlogin — используется для выполнения команд для всех пользователей при завершении прогресса инициализации, будет прочитан при запуске оболочки входа.\n- $ZDOTDIR/.zlogin — используется для выполнения команд текущего пользователя при завершении прогресса инициализации, будет вызван при запуске оболочки входа. Не следует использовать для автозапуска графического сеанса, так как в этот момент сеанс может содержать конфигурацию, предназначенную только для интерактивной оболочки.\n- $ZDOTDIR/.zlogout — используется для выполнения команд текущего пользователя при завершении работы оболочки входа.\n- /etc/zsh/zlogout — используется для выполнения команд для всех пользователей при завершении работы оболочки входа.\n\n- /etc/profile — этот файл должен быть прочитан всеми POSIX sh-совместимыми оболочками при входе в систему: он устанавливает $PATH и другие переменные окружения, а также специфичные для приложения (/etc/profile.d/*.sh) настройки при входе в систему.\n\nСмотрите также графическое представление.\n\nNote: **не используется** \n\n"
    },
    {
      "title": "Настройка Zsh",
      "level": 2,
      "content": "Хотя Zsh может использоваться “из коробки”, он настроен не так, как хотело бы большинство пользователей. Из-за наличия огромных возможностей настройки, доступных в Zsh, этот процесс может оказаться сложным и трудоемким. Для автоматической настройки можно использовать #Сторонние расширения.\n\n"
    },
    {
      "title": "Простой .zshrc",
      "level": 3,
      "content": "Ниже приведён пример файла настроек, который обеспечивает достойный набор опций по умолчанию, а также предоставляет примеры многих вариантов настройки Zsh. Для того, чтобы использовать этот пример, сохраните его в виде файла с именем .zshrc.\n\nВот простой .zshrc:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz compinit promptinit\ncompinit\npromptinit\n\n# Эта настройка установит тему walters для приглашения командной строки\nprompt walters\n```\n\nПодробности о темах приглашений командной строки описаны в разделе #Темы строк приглашений.\n\n"
    },
    {
      "title": "Настройка переменной $PATH",
      "level": 3,
      "content": "Zsh связывает переменную PATH с массивом path. Это позволяет вам менять PATH, просто изменяя массив path. Подробности смотрите в руководстве пользователя Z-Shell.\n\nЧтобы добавить ~/.local/bin/ в PATH:\n\n```\n~/.zshenv\n```\n\n```\ntypeset -U path PATH\npath=(~/.local/bin $path)\nexport PATH\n```\n\n"
    },
    {
      "title": "Автозавершение команд",
      "level": 3,
      "content": "Возможно, наиболее убедительной стороной Zsh является его передовые возможности автозавершения. Включите автозавершение в .zshrc. Добавив следующую строку в ваш ~/.zshrc:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz compinit\ncompinit\n```\n\nНастройки выше включают в себя также автодополнение хостов ssh/scp/sftp, но для того, чтобы эта функция работала, пользователи не должны включать хеширование имён SSH-хостов в ~/.ssh/known_hosts (опция HashKnownHosts).\n\nДля автодополнения с помощью меню, управляемом клавишами-стрелками, добавьте следующую строку:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion:*' menu select\n```\n\nДля активации меню нажмите Tab дважды.\n\nЧтобы автодополнение для привилегированных команд выполнялось в привилегированном окружении (например, если вы вводите команду через sudo, то скрипты автодополнения тоже будут запущены через sudo), добавьте:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion::complete:*' gain-privileges 1\n```\n\n"
    },
    {
      "title": "Назначение клавиш",
      "level": 3,
      "content": "Zsh не использует Readline, вместо этого он использует свой собственный и более мощный ZLE. Т.е. не читает /etc/inputrc или ~/.inputrc. Введение в настройку ZLE: A closer look at the zsh line editor and creating custom widgets.\n\nZLE имеет режимы Emacs и vi. По умолчанию он проверяет переменные окружения VISUAL и EDITOR: если одна из них содержит vi, то будет использоваться режим vi; в противном случае по умолчанию будет Emacs. Переключить режим можно с помощью команд bindkey -e или bindkey -v для режима Emacs или режима vi соответственно. Задержка при нажатии клавиши Esc в режиме vi по умолчанию составляет 0,4 с, но её можно сделать короче (0,05 с) через export KEYTIMEOUT=5.\n\nСочетания клавиш назначаются путём сопоставления escape-последовательности, соответствующей нажатию клавиши, виджету ZLE. Доступные виджеты с описанием их действий и привязок по умолчанию перечислены в zshzle(1) § STANDARD WIDGETS и zshcontrib(1) § ZLE FUNCTIONS.\n\nСмотрите также zshwiki: bindkeys.\n\nРекомендуемый способ установки сочетаний клавиш в Zsh — чтение поддерживаемых escape-последовательностей из terminfo(5). Например[1]:\n\n```\n~/.zshrc\n```\n\n```\n# Создание хэш-таблицы, совместимой с zkbd.\n# Информацию о всех доступных клавишах можно узнать в man 5 terminfo\ntypeset -g -A key\n\nkey[Home]=\"${terminfo[khome]}\"\nkey[End]=\"${terminfo[kend]}\"\nkey[Insert]=\"${terminfo[kich1]}\"\nkey[Backspace]=\"${terminfo[kbs]}\"\nkey[Delete]=\"${terminfo[kdch1]}\"\nkey[Up]=\"${terminfo[kcuu1]}\"\nkey[Down]=\"${terminfo[kcud1]}\"\nkey[Left]=\"${terminfo[kcub1]}\"\nkey[Right]=\"${terminfo[kcuf1]}\"\nkey[PageUp]=\"${terminfo[kpp]}\"\nkey[PageDown]=\"${terminfo[knp]}\"\nkey[Shift-Tab]=\"${terminfo[kcbt]}\"\n\n# Назначение действий поддерживаемым клавишам\n[[ -n \"${key[Home]}\"      ]] && bindkey -- \"${key[Home]}\"       beginning-of-line\n[[ -n \"${key[End]}\"       ]] && bindkey -- \"${key[End]}\"        end-of-line\n[[ -n \"${key[Insert]}\"    ]] && bindkey -- \"${key[Insert]}\"     overwrite-mode\n[[ -n \"${key[Backspace]}\" ]] && bindkey -- \"${key[Backspace]}\"  backward-delete-char\n[[ -n \"${key[Delete]}\"    ]] && bindkey -- \"${key[Delete]}\"     delete-char\n[[ -n \"${key[Up]}\"        ]] && bindkey -- \"${key[Up]}\"         up-line-or-history\n[[ -n \"${key[Down]}\"      ]] && bindkey -- \"${key[Down]}\"       down-line-or-history\n[[ -n \"${key[Left]}\"      ]] && bindkey -- \"${key[Left]}\"       backward-char\n[[ -n \"${key[Right]}\"     ]] && bindkey -- \"${key[Right]}\"      forward-char\n[[ -n \"${key[PageUp]}\"    ]] && bindkey -- \"${key[PageUp]}\"     beginning-of-buffer-or-history\n[[ -n \"${key[PageDown]}\"  ]] && bindkey -- \"${key[PageDown]}\"   end-of-buffer-or-history\n[[ -n \"${key[Shift-Tab]}\" ]] && bindkey -- \"${key[Shift-Tab]}\"  reverse-menu-complete\n\n# Наконец, нужно убедиться, что терминал находится в application mode, когда\n# zle активен. Только в этом случае значения из $terminfo будут действительны.\nif (( ${+terminfo[smkx]} && ${+terminfo[rmkx]} )); then\n\tautoload -Uz add-zle-hook-widget\n\tfunction zle_application_mode_start { echoti smkx }\n\tfunction zle_application_mode_stop { echoti rmkx }\n\tadd-zle-hook-widget -Uz zle-line-init zle_application_mode_start\n\tadd-zle-hook-widget -Uz zle-line-finish zle_application_mode_stop\nfi\n```\n\n"
    },
    {
      "title": "Поиск по истории",
      "level": 4,
      "content": "Сперва создайте хэш-таблицу key и переведите ZLE в application mode, как описано в разделе #Назначение клавиш.\n\nДобавьте эти строки в .zshrc\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz up-line-or-beginning-search down-line-or-beginning-search\nzle -N up-line-or-beginning-search\nzle -N down-line-or-beginning-search\n\n[[ -n \"${key[Up]}\"   ]] && bindkey -- \"${key[Up]}\"   up-line-or-beginning-search\n[[ -n \"${key[Down]}\" ]] && bindkey -- \"${key[Down]}\" down-line-or-beginning-search\n```\n\nПосле этого стрелки вверх и вниз будут выводить только те команды из истории, которые начинаются с символов, находящихся перед текущим положением курсора.\n\n"
    },
    {
      "title": "Модификаторы Shift, Alt, Ctrl и Meta",
      "level": 4,
      "content": "В xterm-совместимых терминалах можно использовать расширенные определения клавиш из user_caps(5). Это комбинации клавиш Shift, Alt, Ctrl и Meta вместе Up, Down, Left, Right, PageUp, PageDown, Home, End или Del. Список рекомендуемых названий клавиш-модификаторов и комбинаций клавиш смотрите в zkbd source.\n\nНапример, чтобы Ctrl+Left выполнял переход к началу предыдущего слова, а Ctrl+Right — к началу следующего слова:\n\n```\n~/.zshrc\n```\n\n```\nkey[Control-Left]=\"${terminfo[kLFT5]}\"\nkey[Control-Right]=\"${terminfo[kRIT5]}\"\n\n[[ -n \"${key[Control-Left]}\"  ]] && bindkey -- \"${key[Control-Left]}\"  backward-word\n[[ -n \"${key[Control-Right]}\" ]] && bindkey -- \"${key[Control-Right]}\" forward-word\n```\n\n"
    },
    {
      "title": "Приглашения",
      "level": 3,
      "content": "Zsh позволяет использовать темы для строк приглашений командной строки или, если не устраивают темы (или хочется расширить их возможности), создать собственную строку приглашения.\n\n"
    },
    {
      "title": "Темы строк приглашений",
      "level": 4,
      "content": "Темы — это быстрый и лёгкий способ создать цветное приглашение в Zsh. Информация о темах и об их создании есть в zshcontrib(1) § PROMPT THEMES.\n\nДля использования темы убедитесь, что prompt установлен в autoload в файле .zshrc. Это может быть сделано путём добавления этих строк:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz promptinit\npromptinit\n```\n\nПосмотреть список доступных цветных тем можно с помощью команды:\n\n```\n$ prompt -l\n```\n\nДля просмотра всех доступных тем (с примерами), используйте команду:\n\n```\n$ prompt -p\n```\n\nНапример, чтобы использовать цветовую схему bigfade, введите:\n\n```\n$ prompt bigfade\n```\n\nЧтобы использовать цветовую схему с заданным цветом (если доступен в теме), введите:\n\n```\n$ prompt elite2 blue\n```\n\nСуществует возможность установки тем вручную, без использования внешних инструментов. Для локальной установки сначала создайте каталог и добавьте его в массив fpath, например:\n\n```\n$ mkdir ~/.zprompts\n$ fpath=(\"$HOME/.zprompts\" \"$fpath[@]\")\n```\n\nЗатем в этом каталоге создайте символическую ссылку на файл темы:\n\n```\n$ ln -s mytheme.zsh ~/.zprompts/prompt_mytheme_setup\n```\n\nИли если вы хотите установить тему глобально:\n\n```\n# ln -s mytheme.zsh /usr/share/zsh/functions/Prompts/prompt_mytheme_setup\n```\n\nПосле этого тему можно будет активировать:\n\n```\n$ prompt mytheme\n```\n\nЕсли сработает, можно записать это в .zshrc.\n\nПомимо создания темы в отдельном файле, можно добавить тему внутри другого файла (например, в вашем .zshrc):\n\n```\n~/.zshrc\n```\n\n```\n# Загрузка promptinit\nautoload -Uz promptinit && promptinit\n\n# Создание темы\nprompt_mytheme_setup() {\n  PS1=\"%~%# \"\n}\n\n# Добавление темы в promptsys\nprompt_themes+=( mytheme )\n\n# Загрузка темы\nprompt mytheme\n```\n\n"
    },
    {
      "title": "Настройка строки приглашения",
      "level": 4,
      "content": "В дополнение к приглашению слева PS1 (PROMPT, prompt), которое используется в большинстве командных оболочек, Zsh также поддерживает приглашение справа RPS1 (RPROMPT). Эти две переменные используются для установки произвольного приглашения командной строки.\n\nДругие приглашения специального назначения, например PS2 (PROMPT2), PS3 (PROMPT3), PS4 (PROMPT4), RPS1 (RPROMPT), RPS2 (RPROMPT2) и SPROMPT, описаны в zshparam(1) § PARAMETERS USED BY THE SHELL.\n\nПриглашения командной строки поддерживают специальные управляющие последовательности (escapes), которые описаны в zshmisc(1) § EXPANSION OF PROMPT SEQUENCES. Некоторые примеры:\n\n%n - Имя пользователя %m - Имя компьютера (до первой точки) %M - Полное имя компьютера %~ - Путь к текущему каталогу относительно домашнего %d - Полный путь к текущей директории ($PWD) %T - Время в формате HH:MM %* - Время в формате HH:MM:SS %D - Дата в формате YY-MM-DD %B, %b - Начало и конец выделения жирным\n\nZsh устанавливает цвета иначе, чем Bash; вам не нужно возиться ANSI-кодами или с terminfo(5). Zsh предоставляет удобные управляющие последовательности для установки основного и фонового цветов и других визуальных эффектов; их список и описание приведены в zshmisc(1) § Visual effects.\n\nЦвет может быть задан десятичным целым числом, названием одного из восьми наиболее широко поддерживаемых цветов или символом #, за которым следует триплет RGB в шестнадцатеричном формате. Подробнее в описании параметра fg=colour в zshzle(1) § CHARACTER HIGHLIGHTING.\n\nБольшинство терминалов поддерживают следующие цвета по названиям:\n\nTable content:\nНазвание | Цвет\nblack | 0\nred | 1\ngreen | 2\nyellow | 3\nblue | 4\nmagenta | 5\ncyan | 6\nwhite | 7\n\nДля терминалов, поддерживающих 256 цветов, можно использовать номера 0–255: смотрите xterm-256color chart.\n\nПри правильно заданной переменной окружения TERM поддерживаемое терминалом максимальное количество цветов можно узнать из базы данных terminfo(5) с помощью команды echoti colors. Для 24-битных цветов также проверьте переменную окружения COLORTERM командой print $COLORTERM. Если она выведет 24bit или truecolor, то ваш терминал поддерживает 16777216 (224) цветов, даже если terminfo показывает меньшее число.\n\n- Цвета 0–15 могут быть разными в зависимости от используемого эмулятора терминала и пользовательских настроек.\n- Многие эмуляторы терминала отображают жирный текст более ярким цветом.\n\n- Протестировать управляющие последовательности можно командой print -P \"строка с escape-последовательностями\", например: $ print -P '%B%F{red}цв%F{green}ет%F{blue}а!%f%b'\n- Если вы используете 24-битные цвета, может быть полезно загрузить модуль zsh/nearcolor для работы в терминалах, которые их не поддерживают. Например: [[ \"$COLORTERM\" == (24bit|truecolor) || \"${terminfo[colors]}\" -eq '16777216' ]] || zmodload zsh/nearcolor Смотрите zshmodules(1) § THE ZSH/NEARCOLOR MODULE для более подробной информации об этом модуле.\n\n```\n$ print -P '%B%F{red}цв%F{green}ет%F{blue}а!%f%b'\n```\n\n```\n[[ \"$COLORTERM\" == (24bit|truecolor) || \"${terminfo[colors]}\" -eq '16777216' ]] || zmodload zsh/nearcolor\n```\n\nПример простого приглашения командной строки без цветов:\n\n```\nPROMPT='%n@%m %~ %# '\n```\n\nОно будет отображаться так:\n\nПример использования двухстороннего приглашения с цветами:\n\n```\nPROMPT='%F{green}%n%f@%F{magenta}%m%f %F{blue}%B%~%b%f %# '\nRPROMPT='[%F{yellow}%?%f]'\n```\n\nА вот как оно будет отображаться:\n\nДля использования цветов из диапазона 16-255 и 24-битного true color можно использовать число от 0 до 255, присвоенное нужному цвету, и его шестнадцатеричный код цвета соответственно:\n\n```\nPROMPT='%F{2}%n%f@%F{5}%m%f %F{4}%B%~%b%f %# '\nRPROMPT='[%F{3}%?%f]'\n```\n\n```\nPROMPT='%F{#c0c0c0}%n%f@%F{#008000}%m%f %F{#800080}%B%~%b%f %# '\nRPROMPT='[%F{#0000ff}%?%f]'\n```\n\n"
    },
    {
      "title": "Примеры файла .zshrc",
      "level": 3,
      "content": "- Пакет grml-zsh-config, доступный в официальном репозитории взятый с https://grml.org/zsh содержит zshrc файл, который включает в себя множество настроек для Zshell. Эта настройка используется по умолчанию для ежемесячного ISO релиза.\n- Базовая настройка с динамической строкой приглашения (Prompt) и заголовком окна / Hardinfo => https://github.com/MrElendig/dotfiles-alice/blob/master/.zshrc;\n- https://github.com/slashbeast/conf-mgmt/blob/master/roles/home_files/files/DOTzshrc - zshrc с несколькими функциями, - смотрите комментарии в файле. Известные особенности: подтверждение выключения, если пользователь запустил poweroff, а также запрос подтверждения на reboot или hibernate, поддержка GIT в Prompt (сделано без vcsinfo), завершение по TAB с меню, вывод текущей выполняемой команды в заголовке окна, и многое другое.\n\nСмотрите также dotfiles#User repositories.\n\n"
    },
    {
      "title": "Автозапуск X при входе в систему",
      "level": 3,
      "content": "Смотрите xinit (Русский)#Автозапуск X при входе в систему.\n\n"
    },
    {
      "title": "Восстановление настроек терминала после аварийного завершения программы",
      "level": 3,
      "content": "Некоторые программы, меняющие состояние терминала, не восстанавливают его изначальные настройки после нештатного завершения (например, при вылете или получении сигнала SIGINT).\n\nЭто обычно решается с помощью reset(1):\n\n```\n$ reset\n```\n\nВ следующих подразделах описаны способы решения, не требующие ручного сброса терминала.\n\n"
    },
    {
      "title": "Команда ttyctl",
      "level": 4,
      "content": "С помощью команды ttyctl можно «заморозить» и «разморозить» терминал. Для заморозки интерактивной оболочки при запуске:\n\n```\n~/.zshrc\n```\n\n```\nttyctl -f\n```\n\n"
    },
    {
      "title": "Сброс терминала с помощью управляющих последовательностей",
      "level": 4,
      "content": "Альтернативный набор символов может испортить работу терминала так, что ttyctl не сможет этого предотвратить.\n\nПростым решением является вывод escape-последовательностей, сбрасывающих терминал, через хук precmd, чтобы они выполнялись каждый раз перед выводом приглашения. Например, с помощью управляющей последовательности \\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[0;0r\\e8:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nfunction reset_broken_terminal () {\n\tprintf '%b' '\\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[0;0r\\e8'\n}\n\nadd-zsh-hook -Uz precmd reset_broken_terminal\n```\n\nДля проверки работоспособности выполните:\n\n```\n$ print '\\e(0\\e)B'\n```\n\n"
    },
    {
      "title": "Dirstack",
      "level": 4,
      "content": "Zsh можно настроить, чтобы он помнил DIRSTACKSIZE (последние посещённые каталоги). Это пригодится для более быстрой работы с cd. Вам нужно добавить несколько строк, в файл настройки:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nDIRSTACKFILE=\"${XDG_CACHE_HOME:-$HOME/.cache}/zsh/dirs\"\nif [[ -f \"$DIRSTACKFILE\" ]] && (( ${#dirstack} == 0 )); then\n\tdirstack=(\"${(@f)\"$(< \"$DIRSTACKFILE\")\"}\")\n\t[[ -d \"${dirstack[1]}\" ]] && cd -- \"${dirstack[1]}\"\nfi\nchpwd_dirstack() {\n\tprint -l -- \"$PWD\" \"${(u)dirstack[@]}\" > \"$DIRSTACKFILE\"\n}\nadd-zsh-hook -Uz chpwd chpwd_dirstack\n\nDIRSTACKSIZE='20'\n\nsetopt AUTO_PUSHD PUSHD_SILENT PUSHD_TO_HOME\n\n## Удалить повторяющиеся записи\nsetopt PUSHD_IGNORE_DUPS\n\n## Это Отменяет +/- операторы.\nsetopt PUSHD_MINUS\n```\n\nТеперь используйте\n\n```\ndirs -v\n```\n\nДля вывода стека директорий. Используйте cd -<NUM> чтобы вернуться к посещённому каталогу. Используйте автозавершение (нажав TAB) после тире.\n\n"
    },
    {
      "title": "cdr",
      "level": 4,
      "content": "cdr позволяет сменить рабочий каталог на предыдущий из списка, ведущегося автоматически. Все записи хранятся в файлах, которые синхронизируются между сеансами и (по умолчанию) между эмуляторами терминалов в текущем сеансе.\n\nСмотрите zshcontrib(1) § REMEMBERING RECENT DIRECTORIES.\n\n"
    },
    {
      "title": "zoxide",
      "level": 4,
      "content": "zoxide — это более интеллектуальный cd, позволяющий перемещаться в любое место всего за несколько нажатий клавиш. Программа подсчитывает часто используемые каталоги, чтобы угадать, куда вы хотите перейти.\n\n"
    },
    {
      "title": "Команда Help",
      "level": 3,
      "content": "В отличие от bash, в Zsh не предусмотрена встроенная команда help, вместо неё используется run-help. По умолчанию run-help является псевдонимом команды man, её можно либо выполнить вручную, добавив к команде, либо вызвать для текущей команды с помощью сочетаний клавиш Alt+h или Esc h.\n\nПоскольку по умолчанию это всего лишь псевдоним на man, она будет работать только с внешними командами. Для улучшения функциональности, чтобы она работала со встроенными командами оболочки и другими её возможностями, нужно использовать функцию run-help. Более подробная информация о run-help и вспомогательных функциях есть в zshcontrib(1).\n\nСначала загрузите функцию run-help, а затем удалите существующий псевдоним run-help. Для удобства можно сделать help псевдонимом run-help. Например, добавьте следующие строки в ваш zshrc:\n\n```\nautoload -Uz run-help\n(( ${+aliases[run-help]} )) && unalias run-help\nalias help=run-help\n```\n\nВспомогательные функции нужно включить отдельно:\n\n```\nautoload -Uz run-help-git run-help-ip run-help-openssl run-help-p4 run-help-sudo run-help-svk run-help-svn\n```\n\nТеперь, например, команда run-help git commit будет открывать man-страницу git-commit(1), а не просто git(1).\n\n"
    },
    {
      "title": "Постоянный rehash",
      "level": 3,
      "content": "Как правило, compinit не будет автоматически находить новые исполняемые файлы в $PATH. Например, после установки нового пакета файлы в каталоге /usr/bin/ не появятся в автодополнении сразу. Для их появления нужно выполнить команду:\n\n```\n$ rehash\n```\n\nЕё можно запускать автоматически.[2] Просто добавьте в ваш zshrc:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion:*' rehash true\n```\n\n"
    },
    {
      "title": "Выполнение rehash по необходимости",
      "level": 4,
      "content": "С помощью хуков можно настроить pacman на запуск rehash после установки или удаления пакетов, что позволит избежать снижения производительности из-за постоянного запуска rehash описанным выше способом. Создайте каталоги /etc/pacman.d/hooks и /var/cache/zsh, а затем создайте хук:\n\n```\n/etc/pacman.d/hooks/zsh.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nOperation = Remove\nType = Path\nTarget = usr/bin/*\n[Action]\nDepends = zsh\nWhen = PostTransaction\nExec = /usr/bin/install -Dm644 /dev/null /var/cache/zsh/pacman\n```\n\nОн будет обновлять дату изменения файла /var/cache/zsh/pacman каждый раз при установке, обновлении или удалении пакетов. Теперь нужно заставить Zsh обновить свой кэш команд, когда он устареет. Добавьте в ~/.zshrc:\n\n```\n~/.zshrc\n```\n\n```\nzshcache_time=\"$(date +%s%N)\"\n\nautoload -Uz add-zsh-hook\n\nrehash_precmd() {\n  if [[ -a /var/cache/zsh/pacman ]]; then\n    local paccache_time=\"$(date -r /var/cache/zsh/pacman +%s%N)\"\n    if (( zshcache_time < paccache_time )); then\n      rehash\n      zshcache_time=\"$paccache_time\"\n    fi\n  fi\n}\n\nadd-zsh-hook -Uz precmd rehash_precmd\n```\n\nЕсли хук precmd срабатывает до того, как дата у файла /var/cache/zsh/pacman обновится, то автодополнение может выдавать устаревшие данные до тех пор, пока не будет запущено новое приглашение. Для этого достаточно выполнить пустую команду, например, нажать enter.\n\n"
    },
    {
      "title": "Выполнение rehash по необходимости с помощью SIGUSR1",
      "level": 4,
      "content": "Аналогично описанному выше, но хук теперь такой:\n\n```\n/etc/pacman.d/hooks/zsh-rehash.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nOperation = Remove\nType = Path\nTarget = usr/bin/*\n\n[Action]\nDepends = zsh\nDepends = procps-ng\nWhen = PostTransaction\nExec = /usr/bin/pkill zsh --signal=USR1\n```\n\n```\n~/.zshrc\n```\n\n```\nTRAPUSR1() { rehash }\n```\n\nВместо функции можно использовать trap 'rehash' USR1. Об отличиях между этими двумя способами можно почитать в zshmisc(1) § Trap Functions.\n\nЭтот метод будет запускать rehash во всех экземплярах zsh сразу, избавляя от необходимости нажимать enter для запуска precmd.\n\n"
    },
    {
      "title": "Назначение клавиши в ncurses",
      "level": 3,
      "content": "Привяжите приложение ncurses к keystoke, но оно не будет принимать взаимодействие. Используйте переменную BUFFER, чтобы заставить его работать. Следующий пример позволяет пользователям открывать ncmpcpp, используя Alt+\\:\n\n```\n~/.zshrc\n```\n\n```\nncmpcppShow() {\n  BUFFER=\"ncmpcpp\"\n  zle accept-line\n}\nzle -N ncmpcppShow\nbindkey '^[\\' ncmpcppShow\n```\n\nЭтот метод будет содержать всё, что вы ввели в строку перед вызовом приложения\n\n```\n~/.zshrc\n```\n\n```\nncmpcppShow() {\n  ncmpcpp <$TTY\n  zle redisplay\n}\nzle -N ncmpcppShow\nbindkey '^[\\' ncmpcppShow\n```\n\n"
    },
    {
      "title": "Горячие клавиши как в файловом менеджере",
      "level": 4,
      "content": "Могут пригодится настройки клавиш использующиеся в графическом файловом менеджере. Первая комбинация показывает историю каталогов (Alt + Left), вторая позволяет пользователю перейти в родительский каталог (Alt + Up). Они также отображают содержимое каталогов.\n\n```\n~/.zshrc\n```\n\n```\ncdUndoKey() {\n  popd\n  zle       reset-prompt\n  print\n  ls\n  zle       reset-prompt\n}\n\ncdParentKey() {\n  pushd ..\n  zle      reset-prompt\n  print\n  ls\n  zle       reset-prompt\n}\n\nzle -N                 cdParentKey\nzle -N                 cdUndoKey\nbindkey '^[[1;3A'      cdParentKey\nbindkey '^[[1;3D'      cdUndoKey\n```\n\n"
    },
    {
      "title": "Заголовок xterm",
      "level": 3,
      "content": "Если эмулятор терминала поддерживает такую возможность, то из Zsh можно задать его заголовок. Это позволяет динамически изменять заголовок для отображения нужной информации о состоянии оболочки, например, показывать имя пользователя и текущий каталог или выполняемую в данный момент команду.\n\nЗаголовок xterm задаётся с помощью escape-последовательности OSC \\e]2;\\a или \\e]2;\\e\\\\. Например:\n\n```\n$ print -n '\\e]2;Заголовок моего xterm\\a'\n```\n\nустановит заголовок\n\n```\nЗаголовок моего xterm\n```\n\nПростой способ сделать динамический заголовок — менять его с помощью хуков precmd и preexec. Информация о существующих хуках есть в zshmisc(1) § Hook Functions.\n\nС помощью print -P можно также использовать управляющие последовательности Zsh.\n\n- Печать заголовка может быть разделена на несколько команд, если они идут последовательно.\n- GNU Screen посылает заголовок xterm в hardstatus (%h). Если вы хотите использовать string escapes из Screen (например, для цветов), то вам следует установить hardstatus с помощью управляющей последовательности \\e_\\e\\\\. В противном случае, если в \\e]2;\\a будут string escapes, эмулятор терминала получит искажённое название, так как не сможет интерпретировать их.\n\n- Не используйте опцию -P команды print при печати переменных, чтобы их содержимое не обрабатывалось как управляющие последовательности.\n- Используйте parameter expansion flag q при выводе переменных, чтобы их содержимое не обрабатывалось как управляющие последовательности.\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nfunction xterm_title_precmd () {\n\tprint -Pn -- '\\e]2;%n@%m %~\\a'\n\t[[ \"$TERM\" == 'screen'* ]] && print -Pn -- '\\e_\\005{g}%n\\005{-}@\\005{m}%m\\005{-} \\005{B}%~\\005{-}\\e\\\\'\n}\n\nfunction xterm_title_preexec () {\n\tprint -Pn -- '\\e]2;%n@%m %~ %# ' && print -n -- \"${(q)1}\\a\"\n\t[[ \"$TERM\" == 'screen'* ]] && { print -Pn -- '\\e_\\005{g}%n\\005{-}@\\005{m}%m\\005{-} \\005{B}%~\\005{-} %# ' && print -n -- \"${(q)1}\\e\\\\\"; }\n}\n\nif [[ \"$TERM\" == (Eterm*|alacritty*|aterm*|foot*|gnome*|konsole*|kterm*|putty*|rxvt*|screen*|wezterm*|tmux*|xterm*) ]]; then\n\tadd-zsh-hook -Uz precmd xterm_title_precmd\n\tadd-zsh-hook -Uz preexec xterm_title_preexec\nfi\n```\n\n"
    },
    {
      "title": "Заголовок вкладки в эмуляторе терминала",
      "level": 4,
      "content": "Некоторые эмуляторы терминалов и мультиплексоры поддерживают установку заголовка вкладки. Используемые escape-последовательности зависят от терминала:\n\nTable content:\nТерминал | Escape-последовательности | Описание\nGNU Screen | \\ek\\e\\\\ | Заголовок окна Screen (%t).\nKonsole | \\e]30;\\a | Заголовок вкладки Konsole.\n\n"
    },
    {
      "title": "Определение окружения",
      "level": 3,
      "content": "Репозиторий с информацией о том, как определить окружение, в котором работает командная оболочка, в частности: оболочка входа, сеанс Xorg, TTY, сеанс SSH.\n\n"
    },
    {
      "title": "Эквивалент /dev/tcp: ztcp",
      "level": 3,
      "content": "Используйте модуль zsh/net/tcp:\n\n```\n$ zmodload zsh/net/tcp\n```\n\nОн позволяет устанавливать TCP-соединения:\n\n```\n$ ztcp example.com 80\n```\n\nПодробнее: zshmodules(1) § THE_ZSH/NET/TCP_MODULE и zshtcpsys(1).\n\n"
    },
    {
      "title": "Сочетание клавиш для выхода из оболочки при введённой команде",
      "level": 3,
      "content": "По умолчанию Ctrl+d не завершает работу оболочки, если в ней что-то введено. Можно исправить это так:\n\n```\n.zshrc\n```\n\n```\nexit_zsh() { exit }\nzle -N exit_zsh\nbindkey '^D' exit_zsh\n```\n\n"
    },
    {
      "title": "Обработка неизвестных команд с использованием pacman -F",
      "level": 3,
      "content": "pacman позволяет найти пакет по имени файла, так что можно создать обработчик неизвестных команд, который ищет пакеты, в которых присутствует введённая команда:\n\n```\n~/.zshrc\n```\n\n```\n...\nfunction command_not_found_handler {\n    local purple='\\e[1;35m' bright='\\e[0;1m' green='\\e[1;32m' reset='\\e[0m'\n    printf 'zsh: command not found: %s\\n' \"$1\"\n    local entries=(\n        ${(f)\"$(/usr/bin/pacman -F --machinereadable -- \"/usr/bin/$1\")\"}\n    )\n    if (( ${#entries[@]} ))\n    then\n        printf \"${bright}$1${reset} may be found in the following packages:\\n\"\n        local pkg\n        for entry in \"${entries[@]}\"\n        do\n            # (repo package version file)\n            local fields=(\n                ${(0)entry}\n            )\n            if [[ \"$pkg\" != \"${fields[2]}\" ]]\n            then\n                printf \"${purple}%s/${bright}%s ${green}%s${reset}\\n\" \"${fields[1]}\" \"${fields[2]}\" \"${fields[3]}\"\n            fi\n            printf '    /%s\\n' \"${fields[4]}\"\n            pkg=\"${fields[2]}\"\n        done\n    fi\n    return 127\n}\n...\n```\n\nВариант, использующий pkgfile: #Обработка неизвестных команд с использованием pkgfile.\n\n"
    },
    {
      "title": "Очистка буфера сочетанием клавиш",
      "level": 3,
      "content": "По умолчанию в большинстве эмуляторов терминала сочетание клавиш, очищающее экран, не очищает backbuffer (ту часть текста, до которой нужно прокрутить вверх, чтобы увидеть её). Решить это можно так:\n\n```\n~/.zshrc\n```\n\n```\n...\nfunction clear-screen-and-scrollback() {\n    echoti civis >\"$TTY\"\n    printf '%b' '\\e[H\\e[2J' >\"$TTY\"\n    zle .reset-prompt\n    zle -R\n    printf '%b' '\\e[3J' >\"$TTY\"\n    echoti cnorm >\"$TTY\"\n}\n\nzle -N clear-screen-and-scrollback\nbindkey '^L' clear-screen-and-scrollback\n...\n```\n\n"
    },
    {
      "title": "Фреймворки настроек",
      "level": 3,
      "content": "- oh-my-posh (пакет oh-my-poshAUR) - Движок приглашений для любой оболочки, позволяющий настроить строку приглашения с помощью функции или переменной.\n- oh-my-zsh управляемый сообществом, популярный фреймворк для настройки вашего Zsh. Он поставляется в комплекте с тонной полезных функций, помощников, плагинов, тем.\n- Prezto - мгновенно прекрасный Zsh (доступен в prezto-gitAUR) настроенный фреймворк Zsh. Он поставляется с модулями, разумно расширяющих среду интерфейса командной строки (по умолчанию), псевдонимами (алиасами), функциями, атодополнением, и темами Prompt.\n- ZIM (пакет zsh-zim-gitAUR) - Фреймворк настроек с молниеносной скоростью и модульными расширениями. Zim очень легко настраивается, имеет богатый набор модулей и возможностей без ущерба для скорости и функциональности.\n\n"
    },
    {
      "title": "Менеджеры плагинов",
      "level": 3,
      "content": "- Antidote (пакет zsh-antidoteAUR) - Полнофункциональная Zsh-реализация старого менеджера плагинов Antibody.\n- zinit (ранее «zplugin», пакет zinit-gitAUR) - Гибкий менеджер плагинов Zsh с чистым fpath, отчётами, управлением автодополнением, турбо-режимом REVIVED.\n- sheldon (пакет sheldon) - Быстрый, настраиваемый менеджер плагинов оболочки, написанный на Rust.\n- Antigen (дступен в antigen-gitAUR) - менеджер плагинов для zsh, вдохновлённый oh-my-zsh и vundle.\n- zgen (пакет zgen-gitAUR) - Лёгкий и простой менеджер плагинов для Zsh. Заброшен.\n- zplug (пакет zplugAUR) - Менеджер плагинов нового поколения для Zsh. Заброшен.\n\n"
    },
    {
      "title": "Подсветка синтаксиса как в Fish",
      "level": 3,
      "content": "Fish обеспечивает очень мощную подсветку синтаксиса. Для использования в zsh, вы можете установить zsh-syntax-highlighting из официального репозитория и обязательно добавьте в ваш ~/.zshrc строку:\n\n```\nsource /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\n```\n\nТакже можно добавить zsh-autosuggestions:\n\n```\n~/.zshrc\n```\n\n```\nsource /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh\n```\n\n"
    },
    {
      "title": "Обработка неизвестных команд с использованием pkgfile",
      "level": 3,
      "content": "В утилиту pkgfile входит Zsh скрипт, содержащий функцию command_not_found_handler. При вводе неизвестной команды функция автоматически осуществляет поиск в официальных репозиториях.\n\nДля её включения добавьте:\n\n```\n~/.zshrc\n```\n\n```\nsource /usr/share/doc/pkgfile/command-not-found.zsh\n```\n\nВариант, использующий pacman: #Обработка неизвестных команд с использованием pacman -F.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "Рекомендуем обязательно обратится к следующим Русскоязычным статьям, для более полного и лучшего понимания.\n\n- Советы по настройке Zsh\n- Cправочная карта Zsh (PDF)\n\nСтатьи на Английском:\n\n- A User's Guide to ZSH\n- The Z Shell Manual (different format available here)\n- Zsh FAQ\n- zsh-lovers(1) (this is also available as zsh-lovers in offical repository)\n- Zsh Wiki\n- Gentoo Wiki: Zsh/HOWTO\n- Bash2Zsh Reference Card\n\n"
    }
  ]
}