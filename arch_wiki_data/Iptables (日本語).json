{
  "title": "Iptables (日本語)",
  "url": "https://wiki.archlinux.org/title/Iptables_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Nftables\n- Fail2ban\n- Sshguard\n- シンプルなステートフルファイアウォール\n- Sysctl#TCP/IP スタックの防御\n- Uncomplicated Firewall\n\nIptables は netfilter プロジェクトの一つとして Linux カーネルに組み込まれている強力なファイアウォールです。直接、または様々なフロントエンドや GUI を使って設定することができます。IPv4 では iptables が、IPv6 では ip6tables が使用されます。iptables と ip6tables はどちらも同じ構文ですが、一部のオプションは IPv4 または IPv6 のいずれかに固有です。 ​\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 基本概念 2.1 テーブル 2.2 チェイン 2.3 ルール 2.4 チェインの通過 2.5 モジュール\n- 3 iptables の設定と実行 3.1 コマンドラインから 3.1.1 現在のルールを表示する 3.1.2 ルールをリセットする 3.1.3 ルールを編集する 3.2 設定ファイル 3.3 マルチキャストのトラフィックを許可する 3.4 ガイド\n- 4 ログ 4.1 ログ出力の上限を設定する 4.2 記録されたパケットを表示する 4.3 syslog-ng 4.4 ulogd\n- 5 参照\n\n- 2.1 テーブル\n- 2.2 チェイン\n- 2.3 ルール\n- 2.4 チェインの通過\n- 2.5 モジュール\n\n- 3.1 コマンドラインから 3.1.1 現在のルールを表示する 3.1.2 ルールをリセットする 3.1.3 ルールを編集する\n- 3.2 設定ファイル\n- 3.3 マルチキャストのトラフィックを許可する\n- 3.4 ガイド\n\n- 3.1.1 現在のルールを表示する\n- 3.1.2 ルールをリセットする\n- 3.1.3 ルールを編集する\n\n- 4.1 ログ出力の上限を設定する\n- 4.2 記録されたパケットを表示する\n- 4.3 syslog-ng\n- 4.4 ulogd\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "標準の Arch Linux カーネルは iptables サポートを有効にしてコンパイルされています。必要なのは、公式リポジトリの iptables に入ってるユーザーランドユーティリティをインストールすることだけです。base メタパッケージの依存関係の iproute2 パッケージに iptables が含まれているため、あなたのシステムにはデフォルトで iptables パッケージがインストールされています。\n\n"
    },
    {
      "title": "基本概念",
      "level": 2,
      "content": "iptables は IPv4 パケットを検査・変更・転送・リダイレクト・拒否するのに使われます。IPv4 パケットをフィルタリングするコードはカーネルに含まれており、特定の目的ごとにテーブルとしてまとめられています。テーブルは定義済みのチェインのセットでできており、チェインを通過するルールが順番に含まれています。各ルールはマッチと対応するアクション (ターゲットと呼ばれます) の条件文からなり、条件が真のときに (つまり条件がマッチしたとき) 実行されます。iptables はそれらのチェインやルールを使うためのユーザーユーティリティです。ほとんどの新規ユーザーは linux の IP ルーティングの複雑性をとても難しく感じますが、一般的なユースケース (NAT や基本的なインターネットファイアウォール) では実はあまり複雑ではありません。\n\niptables の動作を理解するための鍵は このチャート です。上部の小文字の単語がテーブルで下部の大文字の単語がチェインになります。あらゆるネットワークインターフェースから来た IP パケットは全てこのフローチャートの上から下まで通過します。よくある勘違いの元は、内部インターフェースからのパケットがインターネットに接するインターフェースからのパケットと違ったふうに処理されることにあります。全てのインターフェースは同じように処理されます。それを別々に扱うようにルールを定義するのはあなた次第です。もちろんローカルプロセスのためのパケットというものが存在し、チャートの一番上から <Local Process> のところで止まり、一方ローカルプロセスによって生成されたパケットは <Local Process> からスタートしてフローチャートを下っていきます。このフローチャートの働きの詳しい説明は こちら から読めます。\n\nほとんどの使い方では raw, mangle, security テーブルを使うことは全くありません。従って、iptables をネットワークパケットが通る様子を表すと以下のチャートのようになります:\n\n```\nXXXXXXXXXXXXXXXXXX\n                             XXX     Network    XXX\n                               XXXXXXXXXXXXXXXXXX\n                                       +\n                                       |\n                                       v\n +-------------+              +------------------+\n |table: filter| <---+        | table: nat       |\n |chain: INPUT |     |        | chain: PREROUTING|\n +-----+-------+     |        +--------+---------+\n       |             |                 |\n       v             |                 v\n [local process]     |           ****************          +--------------+\n       |             +---------+ Routing decision +------> |table: filter |\n       v                         ****************          |chain: FORWARD|\n****************                                           +------+-------+\nRouting decision                                                  |\n****************                                                  |\n       |                                                          |\n       v                        ****************                  |\n+-------------+       +------>  Routing decision  <---------------+\n|table: nat   |       |         ****************\n|chain: OUTPUT|       |               +\n+-----+-------+       |               |\n      |               |               v\n      v               |      +-------------------+\n+--------------+      |      | table: nat        |\n|table: filter | +----+      | chain: POSTROUTING|\n|chain: OUTPUT |             +--------+----------+\n+--------------+                      |\n                                      v\n                               XXXXXXXXXXXXXXXXXX\n                             XXX    Network     XXX\n                               XXXXXXXXXXXXXXXXXX\n```\n\n"
    },
    {
      "title": "テーブル",
      "level": 3,
      "content": "iptables には5つのテーブルがあります:\n\n1. raw は接続追跡の対象から外れるようパケットを設定するのに使われます。\n1. filter はデフォルトのテーブルで、主としてファイアウォールが備えるべきアクションは全てここで行われます。\n1. nat はネットワークアドレス変換に使われます (例: ポートフォワーディング)。\n1. mangle は特別なパケット変換に使われます (Mangled packet を参照)。\n1. security は強制アクセス制御のネットワークルールに使われます (例: SELinux -- 詳しくは この記事 を参照)。\n\nほとんどの場合、使用するテーブルは2つだけです: filter と nat。他のテーブルは複数のルーターやルーティングの判定が関わる複雑な設定のためにあり、どちらにしろ導入の域を超えています。\n\n"
    },
    {
      "title": "チェイン",
      "level": 3,
      "content": "テーブルはチェインで構成されています。チェインは順番に並べられたルールのリストです。デフォルトのテーブル、filter には3つの組み込みチェインが含まれます: INPUT, OUTPUT, FORWARD。フローチャート で示されているように、パケットのフィルタリングプロセスの別々の場所で使われます。nat テーブルには PREROUTING, POSTROUTING, OUTPUT チェインが含まれます。\n\n他のテーブルの組み込みチェインの説明は man 8 iptables を見て下さい。\n\nデフォルトでは、チェインにはルールが何も入っていません。使用したいチェインにルールを追加するのはあなたの手に委ねられています。チェインにはデフォルトのポリシーが存在し、基本的には ACCEPT に設定されていますが、あなたのルールセットを何も通り抜けられないようにしたい場合は DROP に設定しなおすことができます。デフォルトのポリシーは常にチェインの一番最後に適用されます。故に、パケットはデフォルトポリシーの適用の前にチェインに存在するルール全てを通過する必要があります。\n\nユーザー定義チェインを追加すればルールセットをより効率的に、または簡単に修正できるようにすることができます。ユーザー定義チェインをどうやって使うかの例はシンプルなステートフルファイアウォールを見て下さい。\n\n"
    },
    {
      "title": "ルール",
      "level": 3,
      "content": "パケットフィルタリングは複数のマッチ (ルールが適用されるパケットの条件) と一つのターゲット (パケットが全ての条件に一致したときのアクション) によって記された、ルールに基づきます。ルールがマッチするものはパケットが入ってくるインターフェース (例: eth0 または eth1) や、パケットのタイプ (ICMP, TCP, UDP)、パケットの送信先ポートなどになります。\n\nターゲットは -j または --jump オプションを使って指定します。ターゲットはユーザー定義チェイン (条件に一致した場合、次のユーザー定義チェインにジャンプしてそこから処理が続行される)、特別な組み込みターゲットのどれか、またはターゲットの拡張のいずれかになります。組み込みターゲットは ACCEPT, DROP, QUEUE, RETURN で、ターゲットの拡張は REJECT や LOG などです。ターゲットが組み込みターゲットだった場合、パケットの運命はすぐに決まり、現在のテーブルのパケットの処理は停止します。ターゲットがユーザー定義チェインだった場合で、さらにこの2番目のチェインをパケットが通過した場合、元のチェインの次のルールに移ります。ターゲットの拡張は終了 (組み込みターゲットと同じ) と非終了 (ユーザー定義チェインと同じ) のいずれも可能です。詳しくは man 8 iptables-extensions を見て下さい。\n\n"
    },
    {
      "title": "チェインの通過",
      "level": 3,
      "content": "あらゆるインターフェースで受け取られたネットワークパケットは フローチャート で示されている順番でテーブルのトラフィック制御チェインを通過していきます。最初のルーティングの決定はパケットの最終目的地がローカルマシンなのか (その場合パケットは INPUT チェインを通過します) もしくは他のところなのか (その場合パケットは FORWARD チェインを通過します) 判断するところからです。次のルーティングの決定は送出パケットにどのインターフェースを割り当てるかの決定を伴います。この経路にあるチェインごとに、全てのルールが順番に評価され、ルールが一致すれば、対応するターゲット・ジャンプのアクションが実行されます。最も一般的に使われるターゲットのビッグスリーは ACCEPT と DROP、そしてユーザー定義チェインへのジャンプです。組み込みチェインにはデフォルトポリシーを設定できますが、ユーザー定義チェインではできません。ジャンプした先のチェインのルールがどれも完全一致しないときは、パケットは こちら に描かれているように元のチェインに戻ります。DROP ターゲットのルールで完全一致があった場合は即座にパケットは拒否され、先の処理は行われません。チェインの中でパケットが ACCEPT されると、全ての上位のチェインでパケットが ACCEPT され、上位チェインを通過しなくなります。ただし、他のテーブルのチェインは全て通常通りにパケットが通過するので注意してください。\n\n"
    },
    {
      "title": "モジュール",
      "level": 3,
      "content": "connlimit, conntrack, limit, recent など多数のモジュールを使うことで iptables を拡張することができます。これらのモジュールは新しい機能を追加して複雑なフィルタリングルールを可能にします。\n\n"
    },
    {
      "title": "iptables の設定と実行",
      "level": 2,
      "content": "iptables は systemd のサービスであり次のように起動できます:\n\n```\n# systemctl start iptables\n```\n\nただし、このサービスは /etc/iptables/iptables.rules ファイルがないと起動せず、Arch の iptables パッケージにはデフォルトの iptables.rule ファイルは付いていません。したがって初めてサービスを起動する場合:\n\n```\n# touch /etc/iptables/iptables.rules\n# systemctl start iptables\n```\n\nまたは:\n\n```\n# cp /etc/iptables/empty.rules /etc/iptables/iptables.rules\n# systemctl start iptables\n```\n\n他のサービスと同じように、起動時に iptables が自動的にロードされるようにしたいときは、有効化してください:\n\n```\n# systemctl enable iptables\n```\n\n"
    },
    {
      "title": "現在のルールを表示する",
      "level": 4,
      "content": "次のコマンドを使うことで現在のルールセットとルールごとのヒット数を確認できます:\n\n```\n# iptables -nvL\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n```\n\n上のように出力された場合、ルールは存在しません。何もブロックされません。\n\nルールを表示する際に行番号を表示するには、--line-numbers をコマンドに追加してください。個々のルールを削除したり追加するときに便利です。\n\n"
    },
    {
      "title": "ルールをリセットする",
      "level": 4,
      "content": "以下のコマンドを使えば iptables をデフォルトに戻すことができます:\n\n```\n# iptables -F\n# iptables -X\n# iptables -t nat -F\n# iptables -t nat -X\n# iptables -t mangle -F\n# iptables -t mangle -X\n# iptables -t raw -F\n# iptables -t raw -X\n# iptables -t security -F\n# iptables -t security -X\n# iptables -P INPUT ACCEPT\n# iptables -P FORWARD ACCEPT\n# iptables -P OUTPUT ACCEPT\n```\n\n引数を付けない -F コマンドは現在のテーブルの全てのチェインを削除します。同じく、-X はテーブル内の空の (デフォルトでない) チェインを全て削除します。\n\n[chain] 引数を付けて -F や -X を使うことでチェインを個別に削除することもできます。\n\n"
    },
    {
      "title": "ルールを編集する",
      "level": 4,
      "content": "ルールの追加は、チェインにルールを付け足すか、またはチェインの特定の位置にルールを挿入することで行います。ここでは両方の方法を用います。\n\nまず最初に、わたしたちのコンピュータはルーターではありません (もちろん、ルーターなのであれば話は別ですが)。FORWARD チェインのデフォルトポリシーを ACCEPT から DROP に変更します:\n\n```\n# iptables -P FORWARD DROP\n```\n\nDropbox の LAN 同期機能は認識された全てのコンピュータに30秒毎にパケットを送信します。Dropbox クライアントで LAN を使っていてこの機能を利用しない場合、このパケットは拒否すると良いでしょう:\n\n```\n# iptables -A INPUT -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable\n```\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nそして今度は、Dropbox に関する考えをあらためてコンピュータに Dropbox をインストールすることを決めたとします。LAN 同期も行いますが、ネットワーク上の特定の一つの IP しか使いません。そこで -R を使って古いルールを置き換える必要があります。10.0.0.85 は別の IP です:\n\n```\n# iptables -R INPUT 1 -p tcp --dport 17500 ! -s 10.0.0.85 -j REJECT --reject-with icmp-port-unreachable\n```\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 REJECT     tcp  --  *      *      !10.0.0.85            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nオリジナルのルールをコンピュータのポート 17500 に 10.0.0.85 がアクセスできるようにルールを置き換えました。しかしながらここで、このルールは扱いづらいということに気づきました。フレンドリーな Dropbox ユーザーがデバイスのポート 17500 にアクセスしようとしたときに、すぐにそのユーザーを許可したいわけで、その後のファイアウォールルールで彼をテストしたくないということです。\n\n信頼されているユーザーはすぐ許可するように、新しいルールを書き込みます。-I を使って古いルールの前に新しいルールを挿入:\n\n```\n# iptables -I INPUT -p tcp --dport 17500 -s 10.0.0.85 -j ACCEPT -m comment --comment \"Friendly Dropbox\"\n```\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 ACCEPT     tcp  --  *      *       10.0.0.85            0.0.0.0/0            tcp dpt:17500 /* Friendly Dropbox */\n2        0     0 REJECT     tcp  --  *      *      !10.0.0.85            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nそして2番目のルールを、ポート 17500 で全てを拒否するルールに置き換えます:\n\n```\n# iptables -R INPUT 2 -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable\n```\n\n最終的なルールは以下のようになりました:\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 ACCEPT     tcp  --  *      *       10.0.0.85            0.0.0.0/0            tcp dpt:17500 /* Friendly Dropbox */\n2        0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\n"
    },
    {
      "title": "設定ファイル",
      "level": 3,
      "content": "Arch Linux のデフォルトでは、iptables のルールは /etc/iptables/iptables.rules に保存されます。ただし、ルールは自動でロードされません。代わりに起動時にこのファイルを読み込んでルールをロードする iptables.service を有効にすることができます:\n\n```\n# systemctl enable iptables\n# systemctl start iptables\n```\n\nIPv6 の iptables ルールは、デフォルトで、/etc/iptables/ip6tables.rules に保存され、このファイルは ip6tables.service によって読み込まれます。このサービスを起動する方法は上と同じです。\n\n```\n[Unit]\nWants=network-pre.target\nBefore=network-pre.target\n```\n\nコマンドラインでルールを追加した後、設定ファイルは自動では変更されません — 手動で保存する必要があります:\n\n```\n# iptables-save > /etc/iptables/iptables.rules\n```\n\n設定ファイルを手動で編集したら、リロードしてください:\n\n```\n# systemctl reload iptables\n```\n\nもしくは iptables を使って直接ロードすることもできます:\n\n```\n# iptables-restore < /etc/iptables/iptables.rules\n```\n\n"
    },
    {
      "title": "マルチキャストのトラフィックを許可する",
      "level": 3,
      "content": "Protocols that use multicast identification (e.g. SANE searching for network scanners) will send traffic to the network's broadcast IP and responses will come back from a specific client's IP. Since these IP addresses are different, iptables will not recognize the response as RELATED or ESTABLISHED, and it will block the response. See [1] for how to accept multicast traffic without creating an overly-permissive firewall.\n\nFirst, create an ipset hash container. The timeout is the window of time to accept client responses.\n\n```\n# ipset create upnp hash:ip,port timeout 3\n```\n\nSecond, create a rule to add outgoing multicast traffic to the ipset hash.\n\n```\n# iptables -A OUTPUT -d 239.255.255.250/32 -p udp -m udp -j SET --add-set upnp src,src --exist\n```\n\nThird, create a rule to allow incoming traffic that matches against the ipset hash.\n\n```\n# iptables -A INPUT -p udp -m set --match-set upnp dst,dst -j ACCEPT\n```\n\nFinally, remember to save the new rules (see #Configuration and usage and ipset#Making ipset persistent), and ensure iptables.service and ipset.service are enabled so the rules load upon system start.\n\n"
    },
    {
      "title": "ガイド",
      "level": 3,
      "content": "- シンプルなステートフルファイアウォール\n- ルーター\n\n"
    },
    {
      "title": "ログ",
      "level": 2,
      "content": "LOG ターゲットを使うことでルールにヒットしたパケットを記録することができます。ACCEPT や DROP など他のターゲットとちがって、パケットは LOG ターゲットにヒットした後もチェインを通過します。つまり拒否されたパケットを全て記録するためには、それぞれの DROP ルールの前に同じ LOG ルールを追加する必要があります。これだと事態がややこしくなり効率的でなくなるので、代わりに logdrop チェインを作成します。\n\nチェインを作成:\n\n```\n# iptables -N logdrop\n```\n\n新しく作成したチェインに以下のルールを追加:\n\n```\n# iptables -A logdrop -m limit --limit 5/m --limit-burst 10 -j LOG\n# iptables -A logdrop -j DROP\n```\n\nlimit や limit-burst オプションの説明は下のセクションにあります。\n\nこれで、パケットを拒否してイベントを記録したいときは、毎回 logdrop チェインにジャンプするようにします。例えば:\n\n```\n# iptables -A INPUT -m conntrack --ctstate INVALID -j logdrop\n```\n\n"
    },
    {
      "title": "ログ出力の上限を設定する",
      "level": 3,
      "content": "上記の logdrop チェインは limit モジュールを使うことで iptables のログが大きくなりすぎたり不必要なハードドライブの書き込みが発生するのを防ぐことができます。上限を設定していないと、誤って設定したサービスが接続を試行したり、攻撃者によって、iptables のログへの書き込みでドライブ (少なくとも /var パーティション) が埋まってしまう可能性があります。\n\nlimit モジュールは -m limit で呼び出すことができます。そして --limit を使うことで平均レートを、--limit-burst を使うことで最初のバーストレートを設定することができます。上記の logdrop のサンプルなら:\n\n```\n# iptables -A logdrop -m limit --limit 5/m --limit-burst 10 -j LOG\n```\n\nこれで通過する全てのパケットを記録するルールが追加されます。最初の連続する10のパケットが記録され、それから1分ごとに5のパケットだけ記録されます。\"limit burst\" のカウントは log アクティビティがノーマルに自動的に戻って \"limit rate\" が壊れない度にリセットされます。\n\n"
    },
    {
      "title": "記録されたパケットを表示する",
      "level": 3,
      "content": "記録されたパケットは systemd の journal でカーネルメッセージとして見ることができます。\n\nマシンが最後に起動したときから記録されたパケットを全て表示するには:\n\n```\n# journalctl -k | grep \"IN=.*OUT=.*\" | less\n```\n\n"
    },
    {
      "title": "syslog-ng",
      "level": 3,
      "content": "syslog-ng を使っている場合、iptables のログ出力先をコントロールすることができます:\n\n```\nfilter f_everything { level(debug..emerg) and not facility(auth, authpriv); };\n```\n\nを\n\n```\nfilter f_everything { level(debug..emerg) and not facility(auth, authpriv) and not filter(f_iptables); };\n```\n\nこれで iptables による /var/log/everything.log へのログ出力が停止されます。\n\niptables に /var/log/iptables.log 以外のファイルにログを出力して欲しい場合は、destination d_iptables の file の値を変更するだけで可能です (syslog-ng.conf にあります):\n\n```\ndestination d_iptables { file(\"/var/log/iptables.log\"); };\n```\n\n"
    },
    {
      "title": "ulogd",
      "level": 3,
      "content": "ulogd は netfilter のための特別なユーザースペースパケットログデーモンで、デフォルトの LOG ターゲットを置き換えることができます。ulogd パッケージは [community] リポジトリから入手可能です。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- iptables 公式ウェブサイト\n- iptables Tutorial 1.2.2 by Oskar Andreasson\n- iptables Debian Debian wiki\n\n"
    }
  ]
}