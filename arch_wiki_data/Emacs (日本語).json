{
  "title": "Emacs (日本語)",
  "url": "https://wiki.archlinux.org/title/Emacs_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Emacs は拡張性があり、カスタマイズ可能な、セルフドキュメント方式のリアルタイム表示エディタです。Emacs のコアには、多数の Emacs の内蔵機能や拡張を実装するのに使われている言語である、Emacs Lisp のインタプリタが存在します。GNU Emacs 22 から GTK がデフォルトの X ツールキットとして使われていますが、CLI 環境でも負けず劣らずに機能します。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 Emacs の実行 2.1 色無し 2.2 デーモンとして 2.3 systemd ユニットとして\n- 3 ヘルプを見る 3.1 マニュアル\n- 4 設定\n- 5 クイックスタート 5.1 基本的な用語と慣習 5.2 移動 5.3 ファイルとバッファ 5.4 編集 5.5 kill と yank とリージョン 5.6 検索と置換 5.7 前置引数 5.8 インデント 5.9 ウィンドウとフレーム 5.10 モード 5.11 マニュアル\n- 6 カスタマイズ 6.1 マルチ設定 6.2 ローカル・カスタム変数 6.3 カスタムカラーとテーマ 6.4 SyncTeX サポート 6.5 Systemd ファイルのシンタックスハイライト 6.6 emacs-nox のクリップボードサポート\n- 7 ヒントとテクニック 7.1 TRAMP 7.2 Emacs を git のマージツールとして使う 7.3 Caps Lock キーを Control キーとして使う 7.4 キーボードマクロとレジスタ 7.5 正規表現 7.6 矩形選択 7.7 ブックマーク 7.8 Elisp インタプリタ 7.9 スマートなウィンドウ切り替え 7.10 シェルコマンドの実行 7.11 シェルバッファ 7.12 対応する括弧のハイライト 7.13 スペルチェック 7.14 テーブル 7.15 予定表、スプレッドシート、文章作成 7.16 リファクタリングとスマート補完 7.16.1 機能 7.16.2 設定 7.16.3 文献\n- 8 パッケージ\n- 9 トラブルシューティング 9.1 Emacs が 'Undefined color: \"WINDOW_FOREGROUND\"' というエラーメッセージで起動しない 9.2 Gccemacs を使用すると Emacs systemd サービスが起動しない 9.3 カラー出力の問題 9.4 X ウィンドウでの文字の表示問題 9.5 起動が遅い 9.6 Cannot open load file: ... 9.7 デッドアクセントキーの問題: '<dead-acute> is undefined' 9.8 C-M-% やその他のバインディングが emacs nox で動作しない 9.9 Emacs がフリーズする 9.10 Emacs-nox の出力が汚い 9.11 emacs ターミナルにおかしなエスケープ数字 (utf-8) が表示される 9.12 tmux で emacs を使っているときに Shift + 矢印キーが動作しない 9.13 KDE でウィンドウのリサイズがおかしい\n- 10 派生 10.1 Emacs ディストリビューション\n- 11 参照\n\n- 2.1 色無し\n- 2.2 デーモンとして\n- 2.3 systemd ユニットとして\n\n- 3.1 マニュアル\n\n- 5.1 基本的な用語と慣習\n- 5.2 移動\n- 5.3 ファイルとバッファ\n- 5.4 編集\n- 5.5 kill と yank とリージョン\n- 5.6 検索と置換\n- 5.7 前置引数\n- 5.8 インデント\n- 5.9 ウィンドウとフレーム\n- 5.10 モード\n- 5.11 マニュアル\n\n- 6.1 マルチ設定\n- 6.2 ローカル・カスタム変数\n- 6.3 カスタムカラーとテーマ\n- 6.4 SyncTeX サポート\n- 6.5 Systemd ファイルのシンタックスハイライト\n- 6.6 emacs-nox のクリップボードサポート\n\n- 7.1 TRAMP\n- 7.2 Emacs を git のマージツールとして使う\n- 7.3 Caps Lock キーを Control キーとして使う\n- 7.4 キーボードマクロとレジスタ\n- 7.5 正規表現\n- 7.6 矩形選択\n- 7.7 ブックマーク\n- 7.8 Elisp インタプリタ\n- 7.9 スマートなウィンドウ切り替え\n- 7.10 シェルコマンドの実行\n- 7.11 シェルバッファ\n- 7.12 対応する括弧のハイライト\n- 7.13 スペルチェック\n- 7.14 テーブル\n- 7.15 予定表、スプレッドシート、文章作成\n- 7.16 リファクタリングとスマート補完 7.16.1 機能 7.16.2 設定 7.16.3 文献\n\n- 7.16.1 機能\n- 7.16.2 設定\n- 7.16.3 文献\n\n- 9.1 Emacs が 'Undefined color: \"WINDOW_FOREGROUND\"' というエラーメッセージで起動しない\n- 9.2 Gccemacs を使用すると Emacs systemd サービスが起動しない\n- 9.3 カラー出力の問題\n- 9.4 X ウィンドウでの文字の表示問題\n- 9.5 起動が遅い\n- 9.6 Cannot open load file: ...\n- 9.7 デッドアクセントキーの問題: '<dead-acute> is undefined'\n- 9.8 C-M-% やその他のバインディングが emacs nox で動作しない\n- 9.9 Emacs がフリーズする\n- 9.10 Emacs-nox の出力が汚い\n- 9.11 emacs ターミナルにおかしなエスケープ数字 (utf-8) が表示される\n- 9.12 tmux で emacs を使っているときに Shift + 矢印キーが動作しない\n- 9.13 KDE でウィンドウのリサイズがおかしい\n\n- 10.1 Emacs ディストリビューション\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "次のパッケージのいずれかを インストール して下さい。:\n\n- emacs - 安定したリリース、\n- emacs-nativecomp - ネイティブコンパイル が有効\n- emacs-nox - X11 サポートなし、\n- emacs-wayland - ネイティブコンパイルと PGTK が有効になっています。\n\n他のバリエーションも検索できます。例として、emacs-gitAUR は GNU Emacs の開発ブランチを提供します。\n\n"
    },
    {
      "title": "Emacs の実行",
      "level": 2,
      "content": "emacs を起動する前に、終了の方法を知っておきましょう (特にターミナルで実行する場合): Ctrl+xCtrl+c キーシーケンスを使って下さい。\n\nEmacs を起動するには次を実行:\n\n```\n$ emacs\n```\n\nまた、コンソールから使うには:\n\n```\n$ emacs -nw\n```\n\n(.emacs を使わずに) 高速でロードして CLI で編集するには:\n\n```\n$ emacs -Q -nw\n```\n\nnox バージョンをインストールしている場合、'emacs' と 'emacs -nw' は同じになります。\n\nファイル名を指定することですぐにファイルを開くこともできます:\n\n```\n$ emacs filename.txt\n```\n\n"
    },
    {
      "title": "色無し",
      "level": 3,
      "content": "デフォルトでは、Emacs はハイパーリンクが濃青で表示されるカラーテーマで起動します。Emacs をカラーテーマやスキームを使わずに起動するには:\n\n```\n$ emacs -nw --color=no\n```\n\nこのコマンドでは全てのテキストがターミナルの前景色だけで表示されます。通常は黒背景に白字か、白背景に黒字となります。\n\n"
    },
    {
      "title": "デーモンとして",
      "level": 3,
      "content": "毎回 .emacs ファイルをロードするため Emacs を起動するときには時間が多少かかります。また、別のインスタンスから同じファイルにアクセスしたいと思うときもあるかもしれません。バージョン23から、Emacs はユーザーが接続できるデーモンとして起動することが可能になっています。Emacs をデーモンとして実行するには:\n\n```\n$ emacs --daemon\n```\n\n起動時にデーモンを実行してウィンドウをデーモンに接続すると良いでしょう。さらに、グラフィカル・コンソールクライアント両方を同意時にデーモンに接続して GUI を素早く起動することも可能です。\n\nデーモンに接続したいときは場合は次のコマンドを使って下さい (グラフィカル環境から実行したときはグラフィカルクライアントが、tty などのコンソールから実行したときはコンソールクライアントが起動します):\n\n```\n$ emacsclient\n```\n\nグラフィカル環境にいるときもコンソールクライアントを使いたい場合は次のコマンドを使って下さい:\n\n```\n$ emacsclient -t\n```\n\nさらに、-a \"\" パラメータを追加することもできます。 これで、最初にコマンドを実行したときは、デーモンとして emacs が起動します。バックグラウンドで動き続けるので後で呼び出した時に起動時間が早くなります (バッファも残り続けます)。\n\nターミナルや他のプログラムからクライアントを起動した場合、呼び出すプログラムを使うことで Emacs クライアントを閉じなくてもクライアントを使い続けることができます。そのためには、 -n (--no-wait) パラメータを使ってクライアントを起動します:\n\n```\n$ emacsclient -nc\n```\n\nMutt や Git などのプログラムは (コミットメッセージを読むための) エディタが終了するまで待機するため、-n パラメータを使うことはできません。デフォルトエディタが設定されている場合、他のエディタを指定する必要があるかもしれません (例: emacsclient -a \"\" -t)。\n\n以下のシェル設定が利用できます:\n\n```\nalias emt='emacsclient -nc -a \"\"'\nalias emc='emacsclient -t -a \"\"'\nEDITOR='emacsclient -a \"\"'\n```\n\nただしこれには注意事項があります: コマンドのスペースの関係で多数のプログラムが外部エディタをロードすることはできません。\n\nスクリプトを書くほうがもっと使い勝手が良く信頼性があります:\n\n```\n/usr/local/bin/emc\n```\n\n```\n#!/bin/sh\nif [ -z \"$DISPLAY\" ]; then\n    IS_GRAPHICAL=true\nelse\n    IS_GRAPHICAL=$(emacs --batch -Q --eval='(if (fboundp '\"'\"'tool-bar-mode) (message \"true\") (message \"false\"))' 2>&1)\nfi\n\nif $IS_GRAPHICAL; then\n    emacsclient -a \"\" -nc \"$@\"\nelse\n    emacsclient -a \"\" -t \"$@\"\nfi\n```\n\nスクリプトは実行可能属性を付けて下さい:\n\n```\n# chmod 755 /usr/local/bin/emc\n```\n\nこれで 'emc' が期待通りに動作するようになります。このクライアントをデフォルトのエディタにしたいときは上記のスクリプトで EDITOR 環境変数を設定すれば OK です。\n\n"
    },
    {
      "title": "systemd ユニットとして",
      "level": 3,
      "content": "Emacs 26.1 から systemd ユニットが含まれています。Emacs のインストール後に以下のように有効化してください:\n\n```\n$ systemctl --user enable --now emacs\n```\n\nEmacs サーバーを実行したいユーザーで上記のコマンドを実行してください。サービスの起動後、Emacs の準備ができます。ユニットファイルは /usr/lib/systemd/user/emacs.service に存在します。ユニットファイルの中身は以下のようになっています:\n\n```\n/usr/lib/systemd/user/emacs.service\n```\n\n```\n[Unit]\nDescription=Emacs text editor\nDocumentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/\n\n[Service]\nType=simple\nExecStart=/usr/bin/emacs --fg-daemon\nExecStop=/usr/bin/emacsclient --eval \"(kill-emacs)\"\nEnvironment=SSH_AUTH_SOCK=%t/keyring/ssh\nRestart=on-failure\n\n[Install]\nWantedBy=default.target\n```\n\nsystemd のユーザーユニットはログインシェル (~/.bash_profile など) から環境変数を継承しないため、~/.pam_environment に変数を設定すると良いでしょう。詳しくは Systemd/ユーザーを参照。\n\nemacs をデーモンとして起動する場合、VISUAL と EDITOR 環境変数を emacsclient に設定することでプログラムからエディタを起動するときにエディタの新しいインスタンスを起動するかわりに emacsclient が使われるようになります。外部エディタを使用するプログラムとしてメールプログラム (メッセージを編集するため) や Git (コミットメッセージを編集するため)、less (v コマンドで表示されたファイルを編集するため) などが存在します。emacsclient の -n (--nowait) オプションは使用しないでください。基本的にプログラムはエディタが終了したときに編集が完了したと認識するためです。\n\nGUI の Emacs のスタートメニューエントリなども emacs ではなく emacsclient が使われるように変更することを推奨します。\n\n"
    },
    {
      "title": "ヘルプを見る",
      "level": 2,
      "content": "Emacs にはチュートリアルが組み込まれており、スプラッシュ画面の最初のリンクをクリックし、メニューから Help->Emacs Tutorial を選択するか、C-h t を押してアクセスすることができます。\n\nEmacsは設計上、セルフ・ドキュメンテーションです。そのため、例えば特定のコマンドの名前やキーバインドを決定するために、非常に多くの情報を利用することができます。C-h C-h ですべてのコンテキスト・ヘルプのバインディングを見ることができます。\n\nEmacs にはリファレンスカードも含まれており、初心者にも上級者にも便利です。/usr/share/emacs/<バージョン>/etc/refcards/ (<バージョン> はあなたの emacs のバージョンに置き換えます) をご覧ください。\n\n"
    },
    {
      "title": "マニュアル",
      "level": 3,
      "content": "Emacsを本当に使いこなしたいのであれば、やはり公式のマニュアルが一番おすすめです。\n\n- Emacs: コンプリート Emacs ユーザーマニュアル\n- Emacs FAQ\n- Emacs Lisp: イントロ プログラミング言語を使ったことがない人向け\n- Elisp: 既にプログラミング言語に慣れている人向け\n\nGNU.org から PDF としてアクセスすることもできますし、組み込まれた info リーダーのおかげで Emacs 自体から直接アクセスすることも可能です。C-h i を使ってください。 ブックを選ぶには m を押してください。\n\n一部のユーザーは、便利なショートカット、ウィンドウ幅に合わせた段落、現在の画面解像度に合わせたフォントのために、info を使用してブックを読むことを好みます。目に刺激が少ないと感じる人もいます。最後に、本から任意の Emacs バッファーにコンテンツを簡単にコピーでき、例から直接 Lisp コードスニペットを実行することもできます。\n\n詳しくは Info を読むといいかもしれません。C-h i m info <RET> です。 情報モード中に ? を押すと、ショートカットのクイックリストが表示されます。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "Emacs の大きな特徴の一つは、その拡張性と設定のしやすさです。Emacs にはカスタマイズエンジンが組み込まれています。カスタマイズのオプションのリストを表示するには、M-x customize を実行します。このインタフェースの使い方については Easy Customization 情報ノードを参照してください。(info \"(emacs) Easy Customization\") をご覧下さい。カスタマイズを適用したら 1つの Emacs セッションに対してのみ設定することも、設定ファイル に保存して Emacs セッションにまたがって保存することもできます。\"適用して保存\" を選択した場合、カスタマイズ・インタフェースが適用されることに注意してください。\n\nEmacs を起動するとき、通常は 初期化ファイル 、略して initファイル から Lisp プログラムを読み込もうとします。 このファイルは、もし存在すれば、あなたのために Emacs を初期化する方法を指定します。 Emacs は '~/.emacs', '~/.emacs.el', '~/.emacs.d/init.el', または '~/.config/emacs/init.el' というファイル名であなたの init ファイルを検索します。詳しくは info ノードの 初期化ファイル を見て下さい。参照: (info \"(emacs) Init File\")\n\n"
    },
    {
      "title": "クイックスタート",
      "level": 2,
      "content": "Emacs は複雑ですが、そのカスタマイズと拡張性のレベルによってもたらされる利益を理解し始めるのにそう時間はかからないでしょう。さらに、幅広い拡張を利用することで Emacs はあらゆる種類の文章編集のための強力な環境に姿を変えることができます。\n\nEmacs には素晴らしいチュートリアルが内蔵されており、スプラッシュ画面の最初のリンクをクリックしてアクセスできます。メニューから Help->Emacs Tutorial を選択するか 'F1' の後に 't' を押して下さい。このページは Emacs を始めるのに追加的なリソースになるように書かれています。\n\n初心者にもエキスパートにも役立つ、リファレンスカードのセットも Emacs に含まれています、/usr/share/emacs/<version>/etc/refcards/ を見て下さい (<version> はあなたの emacs のバージョンに置き換えて下さい)。\n\n"
    },
    {
      "title": "基本的な用語と慣習",
      "level": 3,
      "content": "始めは慣れないと思うかもしれませんが Emacs にはいくつか特別な用語法と約束事があり、必要に応じて紹介していきます。ただ、Emacs を使うにあたって当然知ってるべきとされるような、基本的な用語についてはあらかじめ説明しておいたほうが良いでしょう。\n\n真っ先に知るべきはバッファの概念です。バッファは Emacs の中のデータを表します。例えば、Emacs でファイルを開いたとき、ディスクからファイルから読み込まれてバッファに中身が保存され、バッファを編集して後でディスクに上書き保存することができます。バッファはテキストに限られず、画像やウィジェットなども含めます。作業中でもバッファでアプリケーションを表示することすらできます。こういう考え方もできます: ディスク上のデータは'ファイル'であり、一方、Emacs 上のデータは'バッファ'である。\n\nEmacs におけるキーシーケンスの決まり事も見慣れないかもしれません。即ち:\n\nC-x は Control-x を示します\n\nM-x は Meta-x を示します\n\n例えば、Emacs を終了するには次のキーシーケンスを使います: C-x C-c。これは \"Control を押しながら 'x' を押す。手を離す。Control を押しながら 'c' を押す\" と読み替えることができます。Emacs にはメニューバーが存在しますが、キーシーケンスを使いこなせるように練習することを推奨します。以下から、Emacs で使われるキーバインディングと慣習について説明します。\n\n"
    },
    {
      "title": "移動",
      "level": 3,
      "content": "カーソルの移動は他のグラフィカルエディタとよく似ています。マウスや方向キーを使ってカーソルの位置 (Emacs ではポイントと呼ばれます) を変更することができます。一般的な移動コマンドは方向キーでできますが、Emacs には他にも便利なバインディングが存在します。1文字先に移動するには C-f を使用して、1文字前に移動するには C-b を使用します。C-n と C-p でそれぞれ次の行と前の行に移動できます。基本的に、マウスや方向キーを使うよりもこれらのキーシーケンスを使うことが推奨されています。\n\n当然、Emacs には、単語や文単位で移動できる、もっと高度な移動コマンドが用意されています。M-f は1単語先に移動して M-b は1単語前にポイント移動します。同じく、M-e は1文先にポイント移動して M-a は前に戻ります。\n\nここまでは、紹介した全ての移動コマンドはポイントに関連しています。M-< を使うことでバッファの最初にポイントを移動することができ、逆に、M-> はバッファの最後に移動します。特定の行番号にポイントを移動するには、M-g g を使います。M-g g は移動したい行番号を尋ねます。また、現在の行の先頭と末尾に移動するには、C-a あるいは C-e を使って下さい。\n\n"
    },
    {
      "title": "ファイルとバッファ",
      "level": 3,
      "content": "Emacs にはファイルを操作するためのコマンドが用意されています。このセクションでは最もよく使われるコマンドを紹介します。ファイルを開くには C-x C-f を使います (Emacs ではこのコマンドを 'find-file' と呼びます)。指定されたファイルが存在しなかった場合、Emacs は空のバッファを開きます。バッファを保存するとバッファの中身が入ったファイルが作成されます。C-x C-s を使うことでバッファを保存できます。別のファイル名でバッファを保存するには、C-x C-w を使って下さい (this is a mnemonic for the command 'write-file')。新しいファイル名が尋ねられ、ディスクにファイルが書き込まれます。C-x s で全てのバッファを保存することも可能です。最後に保存されていた状態からバッファに変更が加えられている場合、保存を実行するかどうか訊くプロンプトが表示されます。\n\n\"find-file\" や \"write-file\" などのインタラクティブなコマンドでは Emacs ウィンドウの一番下の行に入力が求められます。この行のことはミニバッファと呼びます。ミニバッファでは基本的な編集コマンドを使うことができ、多くの *nix シェルで利用できるのと同じようなタブ補完機能があります。<TAB> を2回連続で押すと補完リストが表示され、マウスを使ってリストから補完候補を選択することも可能です。ミニバッファでの補完はコマンドやファイル名など様々な形で使えます。\n\nミニバッファには履歴機能も存在します。前に入力したコマンドは Up Arrow または M-p を使うことで再呼び出しできます。\n\nミニバッファは C-g を押すことでいつでも終了できます。\n\nファイルを複数開いたら、ファイルを切り替える手段が必要です。Emacs 内に既に存在するバッファにファイルを開くと、Emacs はそのバッファに切り替えます。しかしながらこれは効率的とは言えません。Emacs には表示するバッファを選択する C-x b が存在します (タブ補完が使えます)。存在しないバッファの名前を入力すると、その名前で新しいバッファが作成されます。\n\n全てのバッファのリストを C-x C-b で表示することができます。バッファが必要なくなったときは C-x k で削除することが可能です。\n\n"
    },
    {
      "title": "編集",
      "level": 3,
      "content": "Emacs には多数の編集コマンドが存在します。まだ紹介していない最も重要なコマンドはおそらく 'undo' でしょう。C-_ または C-/ で実行することができます。基本的に移動コマンドには対応する削除コマンドが存在します。例えば M-<backspace> で後方の単語を削除することができ、M-d で前方の単語を削除できます。行末または文章の終わりまで削除するにはそれぞれ C-k または M-k を使います。\n\n1行は80文字を超えていはいけないという経験則が存在します。1行の長さを長くしすぎないことで、特にウィンドウの縁で改行してしまうような場合に、可読性を維持することができます。改行の自動挿入 (または削除) は Emacs では詰め込み (filling) と呼ばれます。M-q を使うことでパラグラフを折り返させることができます。\n\n文字列と単語はそれぞれ C-t と M-t で置き換えることが可能です。例えば Hello World! を World! Hello と置き換えられます。\n\n単語の大文字小文字はすぐに修正できます。M-l は単語を小文字に変換し (HELLO は hello)、M-u は単語を大文字に変換します (hello は HELLO)。そして M-c は単語の最初の文字を大文字にして他の文字は小文字にします (hElLo は Hello)。\n\n"
    },
    {
      "title": "kill と yank とリージョン",
      "level": 3,
      "content": "リージョンとは、2点間にあるテキストです。2点のうちの1つは、マーク と呼ばれ、もう1つはポイントです。 C-<SPC> によってマークの位置がセットされ、その後でポイントが移動することでリージョンが作られます。GNU Emacs 23.1 以降、リージョンはデフォルトで可視化されます。リージョン上で動作する多くのコマンドがあり、もっともよく使われるコマンドに killing コマンドがあります。\n\nEmacs では、カット＆ペーストはそれぞれ、kill と yank と呼ばれます。1文字以上の文字を削除するコマンド（ C-k や M-d といった上で記述したコマンドも含めて）は、実際にテキストをカットし、kill-ring として知られるものに追加します。kill-ring は、単に kill されたテキストのリストです。kill-ring は、デフォルトでは直近60個の kill されたテキストを保存します。kill に成功すると、リストの先頭に接続されて保存されます。\n\nC-w と M-w によって、それぞれリージョンの kill とコピーができます。\n\nkill されたテキストをバッファに挿入する（'yanking' として知られます）ためには、C-y を使います。 C-y は、複数回使用することで、繰り返しテキストを yank できます。前述の通り、以前の kill は、リストに保存されます。しかし、C-y は、そのうち最初のものしか取得しません。それより前の kill は、M-y によってアクセスすることができます。これによって、'yank' で挿入されたテキストをリストの先頭に移動させます。 M-y は C-y に続けて使われなければならず、kill-ring をたどるために何度でも使えます。\n\n"
    },
    {
      "title": "検索と置換",
      "level": 3,
      "content": "文字列を検索することは、テキストの編集において一般的な作業です。検索は、C-s (後方検索) または C-r (前方検索) によって実行されます。これらのコマンドは、検索する文字列を入力するプロンプトを表示します。検索は1文字入力するごとに実行され、タイプごとに次に（あるいは前に）一致した文字列にマッチします。次の検索結果に行くには C-s を、前の検索結果に行くには C-r を押します。 もし探しているものが見つかったのであれば、<RET> を押すことで検索を終了できます。一方、検索を開始した場所に戻りたければ C-g を押します。\n\nいったん検索が完了すると (たとえば C-g 等で中断していない場合)、検索された文字列は、次の検索のデフォルト検索文字となります。検索された文字を使用するには、後方検索なら C-s C-s , 前方検索なら C-r C-r をそれぞれ押します。\n\nI-search には、いくつかの有用なコマンドがあります。 M-e によって、検索文字列の編集が可能です。 M-c によって、大文字小文字を区別するか、しないかを切り替えることができます。\n\n正規表現検索は、検索の開始コマンド以外、上述の検索と同様に動作します。 C-M-s あるいは C-M-r によって、それぞれ正規表現による後方検索、前方検索を開始します。いったん正規表現検索を開始すると、文字列検索と同様に C-s と C-r を後方検索、前方検索に使用することができます。\n\n検索に加え、文字列や正規表現を置換することができます（それぞれ M-% および C-M-% によって実行されます）。元のテキストと変換後のテキスト用にプロンプトが表示され、それからハイライトされた一致箇所に対する動作のために別のプロンプトが表示されます。多くのオプションが使用できますが（使用できるオプションの完全なリストは ? を押してください）、もっとも一般的に使われるのは、変換を実行する y と、スキップする n 、そしてハイライトされている文字列を含め、以降すべての一致に対して変換する ! になります。\n\n"
    },
    {
      "title": "前置引数",
      "level": 3,
      "content": "C-u は、'universal-argument' コマンドに対応づけられています。'universal-argument' を渡すことによって、より多くの情報をコマンドに提供できます（この情報を '前置引数' と呼びます）。たとえば\n\n```\nC-u 80 %\n```\n\nは、%記号の行を挿入します。また、\n\n```\nC-u 4 M-d\n```\n\nは4単語を削除します。この場合、M-d によって実行されるコマンドへ、要求する単語の数を渡しています。\n\nuniversal argument は、M-<数字> によって少し早く入力することができます。\n\n```\nM-80 %\n```\n\n"
    },
    {
      "title": "インデント",
      "level": 3,
      "content": "インデントは、1行をインデントする <TAB> やリージョンをインデントする C-M-\\ によって実行されます。リージョンが有効（たとえばハイライトされている）場合、<TAB> はリージョンもインデントします。\n\nテキストがどのようにインデントされるかは、正確には有効になっている メジャーモード に依ります。メジャーモードは、しばしば特定の種類のテキストをインデントするときに特化したインデントスタイルを定義します。（より詳しくは Modes を見てください。）\n\nいくつかの場合、ファイルタイプに対して適したメジャーモードがありません。その場合、手動でのインデントが必要になります。リージョンを作成（ kill と yank とリージョン 参照）し、C-u <n> C-x <TAB> でインデントを実行してください。（ここで、'<n>' はリージョンに含まれるテキストがインデントされる列の数です。）例えば、\n\nリージョンのインデントを4列追加する:\n\n```\nC-u 4 C-x <TAB>\n```\n\nリージョンのインデントを2列減らす:\n\n```\nC-u -2 C-x <TAB>\n```\n\n"
    },
    {
      "title": "ウィンドウとフレーム",
      "level": 3,
      "content": "Emacs は、多くのファイルを同時に編集するために便利であるよう設計されています。これは、Emacs のインタフェースを3つの階層にわけることで実現されています。つまり、すでに紹介済みのバッファ、ウィンドウ と フレーム です。\n\nウィンドウ とは、Emacsでバッファを表示している場所のことです。1つのウィンドウは、一度に1つのバッファしか表示できません。しかし、1つのバッファは複数のウィンドウに表示できます。それぞれのウィンドウの下には、モードライン があります。モードラインには、そのバッファの情報が表示されています。\n\nフレーム とは、Emacs の\"ウィンドウ\"（一般的な意味。たとえば最近のデスクトップパラダイムの意味での 'ウィンドウ'）です。フレームには、タイトルバー、メニューバー、1つ以上の 'ウィンドウ' (Emacs 的な意味。たとえば上で定義した 'ウィンドウ') が含まれます。\n\n以降では、これらの単語は Emacs に存在するものでの定義として使用します。\n\nウィンドウを水平あるいは垂直に分割するには、それぞれ C-x 2 あるいは C-x 3 を使います。これは、現在のフレームにもう1つのウィンドウを生成する効果があります。複数のウィンドウ間を巡回するには、C-x o を使用します。\n\nウィンドウ分割の反対は、ウィンドウを削除することです。現在のウィンドウを削除するには C-x 0 を使い、現在のウィンドウ以外を削除するには C-x 1 を使います。\n\nウィンドウと同様に、フレームも生成や削除が可能です。 C-x 5 2 によってフレームを生成できます。 C-x 5 0 によって現在のフレームを削除し、C-x 5 1 によってr現在のフレーム以外のすべてのフレームを削除します。\n\n"
    },
    {
      "title": "モード",
      "level": 3,
      "content": "Emacs モードは Emacs Lisp で書かれた拡張であり、接続されているバッファの挙動を制御します。大抵の場合、インデントやシンタックスハイライト、テキストを編集するときのキーバインドを提供します。洗練されたモードは Emacs を完全な IDE (統合開発環境) に変貌させます。Emacs は基本的にファイルの拡張子でモードをロードすべきか判断します。\n\nシェルスクリプトを編集するのに役立つモードとして sh-mode, line-number-mode, column-number-mode が存在します。同時に使用することができ、以下のコマンドで呼び出します:\n\nM-x sh-mode <RET>\n\nM-x column-number-mode <RET>\n\nline-number-mode はデフォルトで有効になっていますが、コマンドを再度実行することでオンとオフを切り替えられます:\n\nM-x line-number-mode <RET>\n\nsh-mode は、メジャーモード の1つです。メジャーモードは Emacs を調整し、時には、特定の種類のテキストの編集用に特別なコマンドを提供します。それぞれのバッファでは、メジャーモードは1つだけが有効です。シンタックスハイライトやインデントサポートに加えて、sh-mode はシェルスクリプトを書く助けになるいくつかのコマンドを定義しています。以下に、それらの内のいくつかを示します。\n\n```\nC-c (\t 関数定義を挿入する\n\nC-c C-f\t 'for' ループを挿入する\n\nC-c TAB\t 'if' 文を挿入する\n\nC-c C-w\t 'while' ループを挿入する\n\nC-c C-l\t 1 から n までの番号付きループを挿入する\n```\n\n'line-number-mode' と 'column-number-mode' はマイナーモードです。マイナーモードはメジャーモードを拡張することができ、同時に任意の数のマイナーモードを有効にできます。\n\n"
    },
    {
      "title": "マニュアル",
      "level": 3,
      "content": "Emacs を本当にマスターしたいのであれば、一番よく読むべき文章はやはり公式マニュアルです:\n\n- Emacs: 完全な Emacs ユーザーマニュアル\n- Emacs FAQ\n- Emacs Lisp Intro: プログラミング言語を使用したことがない場合\n- Elisp: プログラミング言語をよく知っている場合\n\nこれらは、 GNU.org から PDF として入手できます。あるいは Emacs 自身にて組み込みの 'info' リーダー C-h i を用いて直接読むこともできます。本を選択するには m を押してください。\n\nユーザーの幾人かは、'info' で読むことを好みます。便利なショートカットであり、段落はウィンドウ幅に調整され、フォントは現在の画面解像度に調整されるためです。何人かは目に優しいと気づいています。最後に、本の内容を任意の Emacs バッファへ簡単にコピーでき、さらに例示されている Lisp コードを直接実行することさえできます。\n\ninfo 本について、もっとよく知りたいなら、C-h i m info <RET> を実行してください。 info モードで ? を押すと、ショートカットの簡易リストが表示されます。\n\n"
    },
    {
      "title": "カスタマイズ",
      "level": 2,
      "content": "Emacs は ~/.emacs を編集するか M-x customize を使うことで設定をすることができます。このセクションでは手動で ~/.emacs を編集する方に焦点をあて、いくつかのカスタマイズ例を示すことで、一般的な Emacs の設定をデモンストレーションします。customize コマンドは調整を行うためのシンプルなインターフェイスを提供しますが、おそらく Emacs に慣れてくるにつれて制約を感じるようになるでしょう。\n\nここでの例は、すべて Emacs が動作している間に動作します。Emacs 内で式を評価するには、以下を使います。\n\nC-M-x ポイントがある式を評価する\n\nあるいは、\n\nC-x C-e ポイントの直前の ')' を最後のカッコとする式を評価する\n\n何人かのユーザーは、プロンプトで 'yes' や 'no' をタイプすると、すぐに疲れます。その代わりに 'y' や 'n' を使うために:\n\n```\n(defalias 'yes-or-no-p 'y-or-n-p)\n```\n\nカーソルの点滅を止めるには、次を使用:\n\n```\n(blink-cursor-mode -1)\n```\n\n同じく、前のセクションにある column-number-mode を有効にするには:\n\n```\n(column-number-mode 1)\n```\n\n前の2つのコマンドに類似性があるのは偶然ではありません。blink-cursor-mode と column-number-mode は、共にマイナーモードです。ルールとして、マイナーモードは正の数を引数にとると有効になり、負の数で無効になります。引数が省略された時、マイナーモードは on/off を切り替えます。\n\nマイナーモードのその他いくつかの例を示します。以下はそれぞれ、スクロールバー、メニューバー、ツールバーを無効にします。\n\n```\n(scroll-bar-mode -1)\n(menu-bar-mode -1)\n(tool-bar-mode -1)\n```\n\n変数 'auto-mode-alist' によって、特定のファイル名に対してデフォルトで使われるメジャーモードを変更することができます。以下の例では、'.tut' および '.req' ファイルのデフォルトのメジャーモードを 'text-mode' にします。\n\n```\n(setq auto-mode-alist\n  (append\n    '((\"\\\\.tut$\" . text-mode)\n      (\"\\\\.req$\" . text-mode))\n    auto-mode-alist))\n```\n\n設定は、基底となるモードごとに適用することもできます。基本的な方法は、hook に関数を追加することです。例えば、text-mode でだけインデントをタブの代わりに強制的にスペースを使用するためには:\n\n```\n(add-hook 'text-mode-hook (lambda () (setq indent-tabs-mode nil)))\n```\n\n同様に、場所によらずインデントにてスペースを使用するには:\n\n```\n(setq-default indent-tabs-mode nil)\n```\n\nキーバインドは、2つの方法で調整できます。1つ目の方法は 'define-key' です。'define-key' は、コマンドに対するキーバインドを作成できますが、1つのモードに対してだけ作成します。以下の例では、F8 に、'text-mode' バッファでは行末のホワイトスペースを除去するよう割り当てます。\n\n```\n(define-key text-mode-map (kbd \"<f8>\") 'delete-trailing-whitespace)\n```\n\nもう1つの方法は、'global-set-key' です。これによって、場所によらずキーにコマンドを割り当てることができます。'query-replace-regexp' (C-M-%) を '<f7>' に割り当てるには:\n\n```\n(global-set-key (kbd \"<f7>\") 'query-replace-regexp)\n```\n\n他のキーにコマンドを割り当てることは、既存の割当を入れ替えるわけではありません。たとえば、上記例の後、'query-replace-regexp' は、F7 と C-M-% の両方に割り当てられます。\n\nEmacs のほとんどすべてがカスタマイズできます。Emacs Wiki を通して見ることが基礎固めに適しています。\n\n"
    },
    {
      "title": "マルチ設定",
      "level": 3,
      "content": "複数の設定を使い、Emacs にどれか一つをロードさせることができます。\n\n例えば、2つの設定ファイルを定義してみましょう。\n\n```\n.emacs\n```\n\n```\n(load \"~/.emacs.d/main\" nil t)\n(load \"~/.emacs.d/functions\" nil t)\n(load \"~/.emacs.d/modes\" nil t)\n(load \"~/.emacs.d/plugins\" nil t)\n(load \"~/.emacs.d/theme\" nil t)\n```\n\nこれによって、デーモンとしての起動用にフルカスタムをロードします。しかし、plugins ファイルは巨大で、ロードが遅いです。plugins 機能が不要な新しい Emacs インスタンスを生成したい場合、plugins を毎回ロードすることは面倒です。\n\n```\n.emacs-light\n```\n\n```\n(load \"~/.emacs.d/main\" nil t)\n(load \"~/.emacs.d/functions\" nil t)\n(load \"~/.emacs.d/modes\" nil t)\n(load \"~/.emacs.d/theme\" nil t)\n```\n\nEmacs を以下のコマンドで起動します。\n\n```\nemacs -q -l ~/.emacs-light\n```\n\nこれによって、エイリアスを生成して、呼び出しを簡単にすることができます。\n\n"
    },
    {
      "title": "ローカル・カスタム変数",
      "level": 3,
      "content": "設定ファイル内で変数を定義することができます。この変数はファイル内でローカルに変更することができます。\n\n```\n(defcustom my-compiler \"gcc\" \"Some documentation\")\n```\n\nどんなファイルでもローカル変数を定義するには2つの方法があります。完全な詳細のマニュアル を参照してください\n\n- M-x add-file-local-variable-prop-line は、ファイルの先頭に以下のようなコメント行を追加します。\n\n```\n// -*- my-compiler:g++; mode:c++ -*-\n```\n\n- M-x add-file-local-variable は、ファイルの末尾付近に行を追加します。\n\n```\n// Local Variables:\n// my-compiler: g++\n// mode: c++\n// End:\n```\n\n変数の効果を得るためには、M-x revert-buffer を実行する必要あることに注意してください。\n\nカスタム変数は、デフォルトでは安全でないと考えられています。もしカスタム変数によって再定義されたローカル変数を含むファイルを開こうとすると、Emacs は確認するよう通知します。\n\n変数を安全であるとして宣言することもできます。これによって確認のためのプロンプトを除去することができます。新しい変数が安全と考えられるためには検証されなければならない、と述語を指定する必要があります。\n\n```\n(defcustom my-compiler \"gcc\" \"Some documentation\" :safe 'stringp)\n```\n\nこの例では、文字列以外の何かにセットしようとすると、Emacs は安全でないと考えます。\n\n"
    },
    {
      "title": "カスタムカラーとテーマ",
      "level": 3,
      "content": "face を使うことで簡単に色をカスタマイズすることができます:\n\n```\n(set-face-background  'region                 \"color-17\")\n(set-face-foreground  'region                 \"white\")\n(set-face-bold-p      'font-lock-builtin-face t )\n```\n\nポイントがある場所の face の名前を Emacs に表示させることができます。そのためには customize-face を使います。どのように色、太字、下線、等が設定されているかを示すことができます。\n\nコンソール上の Emacs は、256色を扱うことができます。しかし、それには適したターミナルを使わなければなりません。たとえば URxvt は256色をサポートしています。list-colors-display によって、サポートされる色の包括的なリストが表示できます。これは強くターミナルに依存します。\n\n"
    },
    {
      "title": "SyncTeX サポート",
      "level": 3,
      "content": "Emacs は強力な LaTeX エディタです。LaTeX モードを必要に応じて自由に編集・作成することができます。\n\nSyncTeX サポートといった、まだいくつかの挑戦があります。最初に TeX ディストリビューションに SyncTeX があるかを確認する必要があります。もし TeX Live を手動でインストールした場合、synctex パッケージをインストールする必要があるかもしれません。\n\n```\n# umask 022 && tlmgr install synctex\n```\n\nSyncTeX サポートは、ビューア依存です。ここでは例として Zathura を使用します。他の PDF ビューアを使用する場合、コードを変更する必要があります。\n\n```\n(defcustom tex-my-viewer \"zathura --fork -s -x \\\"emacsclient --eval '(progn (switch-to-buffer  (file-name-nondirectory \\\"'\\\"'\\\"%{input}\\\"'\\\"'\\\")) (goto-line %{line}))'\\\"\" \n  \"TeX 文書用 PDF ビューア。\n   同じドキュメントを2回起動したこと検出する、または Emacs を\n   閉じても表示を継続するためにビューアを fork したい場合、\n \nシンプルなコマンド:\n\n  zathura --fork\n\nSyncTex を用いて pdf を逆検索するために以下が使用できる。\n\n  emacsclient --eval '(progn (switch-to-buffer  (file-name-nondirectory \\\"%{input}\\\")) (goto-line %{line}))'\n\n引用符および二重引用符は必須で、適切にエスケープされなければならない点に注意。\"\n:safe 'stringp)\n```\n\nカスタム変数を定義します。もし AucTeX や Emacs 標準の LaTeX-mode を使用しているなら、それに応じてビューアを設定する必要があります。\n\nLaTeX ソースファイルを Emacs で開き、文書をコンパイルし、ビューアを起動します。Zathura が起動します。Ctrl+Left click を押すと、Emacs は対応する位置にポイントを移動させます。\n\n"
    },
    {
      "title": "Systemd ファイルのシンタックスハイライト",
      "level": 3,
      "content": "systemd-mode を使うことができます。\n\nもしくは init ファイルに以下を追加することで、簡単に emacs で systemd のファイル (サービスやタイマーなど) をカラー表示できます:\n\n```\n(add-to-list 'auto-mode-alist '(\"\\\\.service\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.timer\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.target\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.mount\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.automount\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.slice\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.socket\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.path\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.netdev\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.network\\\\'\" . conf-unix-mode))\n (add-to-list 'auto-mode-alist '(\"\\\\.link\\\\'\" . conf-unix-mode))\n```\n\n"
    },
    {
      "title": "emacs-nox のクリップボードサポート",
      "level": 3,
      "content": "emacs-nox で Xorg クリップボードを使うには、xclip をインストールして以下の関数を ~/.emacs に追加してください [1]:\n\n```\n;; use xclip to copy/paste in emacs-nox\n(unless window-system\n  (when (getenv \"DISPLAY\")\n    (defun xclip-cut-function (text &optional push)\n      (with-temp-buffer\n\t(insert text)\n\t(call-process-region (point-min) (point-max) \"xclip\" nil 0 nil \"-i\" \"-selection\" \"clipboard\")))\n    (defun xclip-paste-function()\n      (let ((xclip-output (shell-command-to-string \"xclip -o -selection clipboard\")))\n\t(unless (string= (car kill-ring) xclip-output)\n\t  xclip-output )))\n    (setq interprogram-cut-function 'xclip-cut-function)\n    (setq interprogram-paste-function 'xclip-paste-function)\n    ))\n```\n\n```\n;; xterm mouse support\n(require 'mouse)\n(xterm-mouse-mode t)\n```\n\n"
    },
    {
      "title": "ヒントとテクニック",
      "level": 2,
      "content": "前のセクションでは基本的な編集コマンドを説明していますが、それだけでは Emacs の可能性はわかりません。このセクションではより高度なテクニックや機能を紹介します。\n\nただし全てを説明するとなると長くなりすぎます。そのためこのセクションはあくまで Emacs の雅やかな機能をいくつかデモするだけにとどめます。\n\n全ての機能の詳細な説明はドキュメントを見て下さい。\n\n"
    },
    {
      "title": "TRAMP",
      "level": 3,
      "content": "TRAMP (Transparent Remote Access, Multiple Protocols) は多数のプロトコルで、リモートファイルに透過的にアクセスすることができる拡張です。ファイル名を入力するときに、特定の形式を入力すると TRAMP が呼びだされます。例:\n\n/etc/hosts を root 権限で開く前に root のパスワードを要求するには:\n\n```\nC-x C-f /sudo::/etc/hosts\n```\n\nSSH で 'myhost' に 'myuser' として接続して ~/example.txt ファイルを開くには:\n\n```\nC-x C-f /ssh:myuser@myhost:~/example.txt\n```\n\nTRAMP のパスは '/[protocol]:[[user@]host]:<file>' という形式で指定します。TRAMP がサポートしているのは上記の例に限りません。詳しくは TRAMP の info マニュアルを参照してください。マニュアルは Emacs に付属しています。\n\n"
    },
    {
      "title": "Emacs を git のマージツールとして使う",
      "level": 3,
      "content": "デフォルトでは、git はマージツールとして Emacs の Emerge モードをサポートしています。しかしながら、Ediff モードの方をより好むかもしれません。不幸にも、このモードは技術的な理由により git によってサポートされていません。Ediff モードを使用する方法はまだあります。emacs call 上で以下の elisp コードを評価します。\n\n```\n.gitconfig\n```\n\n```\n[mergetool.ediff]\n    cmd = emacs --eval \\\" (progn (defun ediff-write-merge-buffer () (let ((file ediff-merge-store-file)) (set-buffer ediff-buffer-C) (write-region (point-min) (point-max) file) (message \\\\\\\"Merge buffer saved in: %s\\\\\\\" file) (set-buffer-modified-p nil) (sit-for 1))) (setq ediff-quit-hook 'kill-emacs ediff-quit-merge-hook 'ediff-write-merge-buffer) (ediff-merge-files-with-ancestor \\\\\\\"$LOCAL\\\\\\\" \\\\\\\"$REMOTE\\\\\\\" \\\\\\\"$BASE\\\\\\\" nil \\\\\\\"$MERGED\\\\\\\"))\\\" \n\n[merge]\n\ttool = ediff\n```\n\nコマンドは1行で書かれなければならない点に注意してください。 上の例では、Emacs を新たに起動します。より早く起動するために emacsclient を使いたいかもしれませんが、推奨されていません。なぜなら Ediff 呼び出しは実際にはクリーンではないためで、現在の Emacs セッションを混乱させる可能性があります。\n\n-q オプションを使用して、即席で起動することができます。設定の一部を残したまま Emacs を素早く起動するには、Emacs を以下のように呼び出します。\n\n```\nemacs -q -l ~/.emacs-light\n```\n\nここで、Ediff のために必要なことのみを記した軽量な設定ファイルがロードされます。\n\nこのトリックおよび Ediff の問題点についての詳細は、kerneltrap.org および stackoverflow を参照してください。\n\n"
    },
    {
      "title": "Caps Lock キーを Control キーとして使う",
      "level": 3,
      "content": "いわゆる 'emacs 小指' にならないようにこちらの挙動を好むユーザーもいます。X で試用してみたいときは、次を実行:\n\n```\n$ setxkbmap -option 'ctrl:nocaps'\n```\n\nまた、キーを交換するには、次を実行:\n\n```\n$ setxkbmap -option 'ctrl:swapcaps'\n```\n\n永続的に設定したくなったら、.xinitrc ファイルに上のコマンドを追加してください。\n\nリージョンを小文字から大文字にする必要がある場合は、デフォルトの C-x C-u キーバインディングを使って下さい、upcase-region 関数が呼び出されます。\n\nCaps Lock がない場合は、両方の \"Shift\" にマッピングしてください:\n\n```\n$ setxkbmap -option \"shift:both_capslock\"\n```\n\n一部のデスクトップ環境にはキーボードのマッピングを変更するためのグラフィカルなツールが含まれています。例えば Plasma 5 ならシステム設定を開いて入力デバイスをクリックしてください。キーボードを選択して高度な設定タブから Caps Lock を Ctrl として使用するように設定できます。\n\n"
    },
    {
      "title": "キーボードマクロとレジスタ",
      "level": 3,
      "content": "このセクションでは、2, 3の強力な編集機能に対する実用的なデモンストレーションを示します。つまり、keyboard macros と registers です。\n\n目的は、一連の文字のリストとこのリスト内での対応する位置を作ることです。それらは手動で成形することもできますが、遅く、間違いをおこしやすいです。その代わりに、Emacs のよりパワフルないくつかの編集機能によって、レバレッジを効かせられます。答えの前に、以下で使うテクニックの背景について詳細を示します。\n\n1つ目の機能は レジスタ です。レジスタ は、数字からウィンドウコンフィグまでに及ぶ様々なデータ型を格納し取得するために使われます。それぞれのレジスタには、1文字の名前が与えられます。この文字はレジスタへのアクセスに使われます。\n\nもう1つの機能は、キーボードマクロ です。キーボードマクロは、一連のコマンドを格納します。それによって後で簡単に繰り返すことができます。これらの変化を、ここでステップバイステップで実施してみます。\n\n文字集合を含むバッファから始めます。\n\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n```\n\n'number-to-register' コマンド（C-x r n）を呼び出してレジスタを準備します。それから数字 '0' をレジスタ 'k' に保存します。\n\n```\nC-x r n k\n```\n\nバッファの先頭にポイントを移動させ、キーボードマクロ（C-x (）を実行開始し、文字のフォーマットを始めます。\n\n```\nC-x ( C-f M-4 .\n```\n\nレジスタ 'k' に挿入 (C-x r i) とインクリメント (C-x r +) を行います。前置引数 (C-u) によって、テキストを挿入した後でポイント位置を離します。\n\n```\nC-u C-x r i k C-x r + k\n```\n\n改行を入れることでフォーマットを完了させます。残りの文字に対しては、Emacs はキーボードマクロを定義したポイント位置から始まるこのプロセスを繰り返すことができます。C-x e はキーボードマクロを完了して呼び出します。前置引数 M-0 によって、エラーが起きるまでマクロを繰り返します。この場合、バッファの最後に到着すると中断します。\n\n```\n<RET> M-0 C-x e\n```\n\n結果は以下のようになります:\n\n```\nA....0\n B....1\n C....2\n [...]\n x....49\n y....50\n z....51\n```\n\nもし、後々使うためにマクロを保存したいなら、名前をつけて設定ファイルに保存する必要があります。\n\n```\nname-last-kbd-macro \ninsert-kbd-macro\n```\n\n定義したマクロは、すべてマクロリングに格納されます。マクロを巡回するには、\n\n```\nC-x C-k C-n  次のマクロ\nC-x C-k C-p  前のマクロ\n```\n\n同様に、仮想的に何でも保存するためにレジスタを使えます。\n\n```\nC-x r SPC 現在のポイント（位置）をレジスタにコピーする\nC-x r w   現在のウィンドウ設定をレジスタにコピーする\nC-x r j   レジスタに再保存する。\n```\n\nしばしば異なるプロジェクトごとにウィンドウを行ったり来たりして作業をするなら、別のプロジェクトのために設定を保存し、ある画角から別の画角へ簡単に切り替えることができます。\n\nlist-registers コマンドによって、使用したレジスタをリストにして表示することができます。\n\n"
    },
    {
      "title": "正規表現",
      "level": 3,
      "content": "Emacs Manual より: \"正規表現 (regexp と略す) とは、一致する可能性がある一連の (無限個でもよい) 文字列を表現するパターンである\"。このセクションでは正規表現自体には深くは立ち入りません (単純に説明しきれない)。そのかわり正規表現のパワーを簡単にデモンストレーションします。詳しい説明は Emacs Manual の Regular Expressions セクションを見て下さい。\n\n上と同じシナリオが与えられた場合、つまり複数文字のリストがあり、そのリスト内に複数文字の相対位置を持つリストを考えます。(参照 キーボードマクロとレジスタ) 再度、以下を含むバッファから開始します。\n\n```\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n```\n\nバッファの最初に C-M-% を使用します。（もしキー列が実行するには難しいなら、M-x query-replace-regexp を使う方がより快適かもしれません。）プロンプトには以下を入力します：\n\n```\n\\(.\\)\n```\n\nこれは、単に1文字にマッチします。それから置換先のプロンプトには：\n\n```\n\\1....\\#^J\n```\n\n置換先の表現は、以下のように読みます： \"最初のカッコに囲まれた部分にマッチするテキストを挿入しなさい (今回は1文字)。次にピリオドを4文字挿入し、それから自動的にインクリメントされた数を挿入し、改行が続きます。\"\n\n最後に、! を押すことで、バッファ全体に渡って適用します。前のセクションで実行したすべてのフォーマットが、1つの正規表現置換で実行できます。\n\n"
    },
    {
      "title": "矩形選択",
      "level": 3,
      "content": "先進的なテキストエディタが当然備えているべき強力な機能として、テキストを矩形で選択・編集できるというのがあるでしょう。\n\nEmacs でも矩形選択は可能です。C-SPC で普通にテキストを選択してから、複数の矩形コマンドを使うことができます。\n\n```\nC-x r t  矩形領域にテキストを挿入する\nC-x r k  矩形領域を kill する (kill-ring に保存する)\nC-x r y  矩形領域を Yank する\nC-x r o  矩形領域にスペースを挿入する\n```\n\nたとえ矩形の外のテキストがハイライトされていても、上記のコマンドが影響を与えることはありません。\n\n"
    },
    {
      "title": "ブックマーク",
      "level": 3,
      "content": "Emacs は開いたファイルのリストを保存できます。\n\n```\nC-x r m カレントバッファをブックマークに追加。\nC-x r b ブックマークからバッファを開く。\nC-x r l ブックマークの確認。\n```\n\n"
    },
    {
      "title": "Elisp インタプリタ",
      "level": 3,
      "content": "eval-last-sexp (C-x C-e) を使うことで、elisp 式を評価することができます。Emacs は、開始時に常に *scratch* バッファを生成します。*scratch* バッファはディスクに保存されず、自由にテキストやコードを記述することができます。これは特にelispの評価に有用です。このバッファは、デフォルトで lisp-interaction-mode 有効で開始することに注意してください。\n\nその他に、Emacs は、ielm コマンドでトップレベルの elisp インタプリタを提供します。\n\n"
    },
    {
      "title": "スマートなウィンドウ切り替え",
      "level": 3,
      "content": "長い間使っていると C-x o による伝統的なウィンドウ切り替えは面倒かもしれません。windmove コマンドはもっと便利にウィンドウを切り替えることができます。Shift を押しながら方向キーでウィンドウを指定するだけです。\n\nwindmove キーを有効にするには、設定ファイルに以下を記述してください:\n\n```\n~/.emacs\n```\n\n```\n(when (fboundp 'windmove-default-keybindings)\n  (windmove-default-keybindings))\n```\n\n"
    },
    {
      "title": "シェルコマンドの実行",
      "level": 3,
      "content": "M-! を使うことで、外部コマンドを呼び出すことができます。前置引数を使用する（C-u M-!）ことで、結果を現在のバッファのポイント位置に出力することができます。\n\nリージョン上で M-| を使うことで、リージョンをコマンドの入力として使うことができます。たとえば、\n\n```\nC-u M-| sort -u RET\n```\n\nによって、リージョンがソートされ、重複を除去して、リージョンをその結果で置き換えることができます。\n\n"
    },
    {
      "title": "シェルバッファ",
      "level": 3,
      "content": "シェルバッファを生成することで、ターミナルと同様にコマンドを実行することができます。 昔ながらのシェルバッファは、shell コマンドによって生成することができます。\n\nEmacs は、すべて Emacs Lisp で書かれた非常に強力なシェル eshell を機能として持っています。csh や zshといったシェルに対する主な優位点は、ネイティブなシェル言語が elisp そのものである点です。そのため、シェル関数として elisp のすべての先進的な機能を使用できます。\n\n"
    },
    {
      "title": "対応する括弧のハイライト",
      "level": 3,
      "content": "show-paren モードを使うことができます。デフォルトでは、対応する括弧が表示されるまで少し遅延がありますが、show-paren-delay を 0 に設定することでなくすことができます。\n\n```\n~/.emacs\n```\n\n```\n(setq show-paren-delay 0)\n(show-paren-mode 1)\n```\n\n"
    },
    {
      "title": "スペルチェック",
      "level": 3,
      "content": "辞書を選択するには:\n\n```\nM-x ispell-change-dictionary\n```\n\n一単語をチェックするには M-$ を使います。 バッファ全体をチェックするには、\n\n```\nM-x ispell-buffer\n```\n\nflyspell-mode を有効にすることで、入力と同時に (on-the-fly) スペルチェックができます。ソースコードに対しては、代わりに flyspell-prog-mode を使うことで、コメントに限定して有効にできます。Emacs でスペルチェックをするには aspell パッケージも必要になります。それぞれの言語に対応したパッケージがあります。英語に対しては、（aspell と共に）aspell-en が必要になります。\n\n"
    },
    {
      "title": "テーブル",
      "level": 3,
      "content": "Emacs は、様々な言語での一般的なテーブルを扱う居力な機能を備えています。例を見てみましょう。\n\n```\nFruits  Quantity\nApples  5\nMelons  2\n```\n\nこの内容をリージョンで選択して、以下を実行します。\n\n```\ntable-capture\n```\n\n半角スペース2文字を列の区切りとして、改行 (C-q C-j) を行の区切りとして使用します。 以下の結果を得ます。\n\n```\n+------+--------+\n|Fruits|Quantity|\n+------+--------+\n|Apples|5       |\n+------+--------+\n|Melons|2       |\n+------+--------+\n```\n\n以下の操作で元に戻せます。\n\n```\ntable-release\n```\n\ntable-insert-row, table-span-cell, table-widen-cell といったような、たくさんの便利な table-* 関数があります。\n\n最後に、table 関数の究極の目的は、指定されたマークアップ言語に変換することです。 それには、table-generate-source が使われます。 LaTeX に対しては、前のテーブルは、以下の結果となります。\n\n```\n% This LaTeX table template is generated by emacs 24.2.1\n\\begin{tabular}{|l|l|}\n\\hline\nFruits & Quantity \\\\\n\\hline\nApples & 5 \\\\\n\\hline\nMelons & 2 \\\\\n\\hline\n\\end{tabular}\n```\n\ntable mode を使用することで、行ごとおよび列ごとの和といった、スプレッドシートの作業を行うこともできます。しかし、すぐに機能が限定的であると分かるでしょう。その上、非常に遅いです。より多くの強力な可能性については、org-mode を見てください。\n\n"
    },
    {
      "title": "予定表、スプレッドシート、文章作成",
      "level": 3,
      "content": "有名でパワフルな Org mode のおかげで、Emacs はパワフルなオフィス系機能をおすすめできます。このモードは、標準の Emacs ディストリビューションに含まれます。\n\nOrg mode は元々強力な TODO およびアジェンダのエージェントですが、すぐにはるかに幅広い機能セットに進化しました。 Org mode は単純に機能が多すぎて、すべての機能をざっと見ることすらできません。そのため、私たちはいくつかの例であなたの欲求を刺激するに留めます。\n\nTODO.org ファイルを新規ファイルとして開きます。Org mode がロードされるはずです。もしロードされなければ、M-x org-mode によって有効にできます。\n\n```\nTODO.org\n```\n\n```\n* First entry\n** Subentry\n   Some comments\n*** Subsubentry\n* Second entry\n  - List item 1\n  - List item 2\n```\n\nここで、いくつかの有用なキーバインドは以下となります：\n\n- TAB 現在のエントリーの折りたたみ・展開を切り替えます。\n- S-TAB すべてのエントリーの折りたたみ・展開を切り替えます。\n- M-RET 現在の項目と同じレベルに新しい項目を開始します。\n- M-<left> および M-<right> レベルを変更します。\n- M-<up> およｂ M-<down> すべてのサブセクションを含めて項目を移動します。\n- S-<left> および S-<right> ステータスを変化させます。リストアイテムでは、項目のスタイルを変更します。\n- S-<up> および S-<down> 優先度を変更します。\n- C-c ^ 現在のエントリーのすべてのサブエントリーをソートします。\n- C-c . 現在のエントリーにタイムスタンプを追加します。Shift と矢印を使って、数日や数週をスキップできます。カレンダーでマウスを使ったり、特定の日で Enter を押したりして、それらを選択できます。\n\nスプレッドシート機能は、非常に包括的です。マニュアルから抜粋してみましょう：\n\n```\n最後に、素晴らしい `calc.el 'パッケージでできることについて欲求を\n 刺激するために、いくつかの関数に対する位置 `x' で次数 `n'のテイラー級数を\n 計算する表を示します。 \n\n     |---+-------------+---+-----+--------------------------------------|\n     |   | 関数        | n | x   | 結果                                  |\n     |---+-------------+---+-----+--------------------------------------|\n     | # | exp(x)      | 1 | x   | 1 + x                                |\n     | # | exp(x)      | 2 | x   | 1 + x + x^2 / 2                      |\n     | # | exp(x)      | 3 | x   | 1 + x + x^2 / 2 + x^3 / 6            |\n     | # | x^2+sqrt(x) | 2 | x=0 | x*(0.5 / 0) + x^2 (2 - 0.25 / 0) / 2 |\n     | # | x^2+sqrt(x) | 2 | x=1 | 2 + 2.5 x - 2.5 + 0.875 (x - 1)^2    |\n     | * | tan(x)      | 3 | x   | 0.0175 x + 1.77e-6 x^3               |\n     |---+-------------+---+-----+--------------------------------------|\n     #+TBLFM: $5=taylor($2,$4,$3);n3\n```\n\nOrg mode は、行においてパイプ | がホワイトスペース以外の最初の文字のとき、テーブルと認識します。前のテキストでは、線を描きませんでした。セル内の内容、または |- のあとに TAB が押されたとき、線が自動的に描かれています。結果列も手動では記述しておらず、最後の行の calc 式から計算されています。C-u C-c C-c を使うことで、テーブル内のすべての値を再計算することができます。\n\nTODO ファイルと同様に、行と列を操作するキーバインディングがあります。Alt + 矢印キーで、列と行を移動することができます。\n\nより深く詳細を知るには、公式マニュアルを参照してください: C-h i m Org mode RET。\n\n"
    },
    {
      "title": "リファクタリングとスマート補完",
      "level": 3,
      "content": "(Eclipse などの) IDE が大抵備えているプログラミング機能が必要な場合、Semantic ツールが役に立ちます。Semantic は Emacs の標準ディストリビューションに含まれています。現在 C, C++, Scheme, Javascript, Java, HTML, Make がサポートされています。現在のサポート状況は CEDET のページ で確認できます。\n\nSemantic がサポートする好みのプログラミング言語で書かれたファイルを開きます。そして Semantic マイナーモードを起動します。\n\n```\nM-x semantic-mode\n```\n\nSemantic は、あなたのファイルに含まれるライブラリ (たとえば C では、ほとんどの場合、標準ライブラリ) を2,3秒パースします。\n\n"
    },
    {
      "title": "機能",
      "level": 4,
      "content": "一旦完了すると、素晴らしい Semantic の機能が使えます。\n\nC-c , SPC を押すことで、ポイントにあるシンボルを補完することができます。それが引数の場合、型が正しいかチェックされます。\n\nC-c , j を押すことでシンボルを入力するプロンプトを表示し、その定義元にジャンプします。TAB で自動補完ができます。文字 J を押すと、シンボルを複数ファイルに渡って探索します。\n\nC-c , g を押すことでシンボルを入力するプロンプトを表示し、参照されている場所のリストを表示します。n と p を押すことで結果表示を巡回できます。RET を押すことで詳細をトグルし、参照箇所で再度 RET を押すことで参照元にジャンプします。G を押すことで、入力したシンボルの場所を複数ファイルに対してリスト表示します。\n\n最初に前述のコマンドでリファクタリングしたいシンボルの使用先をリスト化します。( を押すと、シンボルに対するマクロ定義を開始します。これは実際、リファクタリングに比べてより非常に強力です。なぜなら、シンボルに任意の関数を適用したり、周囲のシンボルに作用することさえしたりできます。C-x ) を押すことで、マクロ定義を終了し、E キーにて実行します。\n\n以下の関数を呼び出すことで、シンボルの詳細を表示します。\n\n```\nsemantic-ia-show-summary\n```\n\nこれは複雑なデータ構造とプロトタイプに対して非常に有用です 。デフォルトではキーバインドがありません。\n\n"
    },
    {
      "title": "設定",
      "level": 4,
      "content": "以下に、サポートされているすべてのプログラミング言語で Semantic を使用するためのサンプル設定を示します。キーバインディングのと表示設定の例です。\n\n```\n;; ghost 表示での Semantic (M-n と M-p で完了をブラウズできます)\n(semantic-mode 1)\n(define-key my-keys-minor-mode-map (kbd \"C-c , d\") 'semantic-ia-show-summary)\n(setq semantic-complete-inline-analyzer-displayor-class 'semantic-displayor-ghost)\n```\n\n特定の言語に対して特化した設定を追加することもできます。ここでは C のために：\n\n```\n(add-hook\n 'c-mode-hook\n (lambda ()\n   (local-set-key (kbd \"M-TAB\") 'semantic-complete-analyze-inline)\n   (local-set-key \".\" 'semantic-complete-self-insert)\n   (local-set-key \">\" 'semantic-complete-self-insert)))\n```\n\n"
    },
    {
      "title": "文献",
      "level": 4,
      "content": "Emacs から直接 info マニュアルにアクセスすることが可能です: C-h i m Semantic RET。\n\n"
    },
    {
      "title": "パッケージ",
      "level": 2,
      "content": "Emacs の機能はサードパーティ製のパッケージで拡張できます。公式にサポートされているパッケージマネージャとして package.el が組み込まれていますが、Emacs のコミュニティメンバーによって書かれたパッケージマネージャが他にも存在します。package.el は package-archives 変数を使ってパッケージを検索します。デフォルトでは Emacs Lisp Package Archive (ELPA) が含まれています。M-x list-packages で Emacs が認識している全てのパッケージが列挙されたバッファが作成されます。マニュアル ((info \"(emacs) Packages\")) にはさらに詳しい情報が載っています。\n\nサードパーティ製のパッケージのアーカイブを追加することもできます。MELPA が広く使われています。\n\n人気の拡張の多くは [community] リポジトリのパッケージや AUR からインストールできます。大抵の場合、パッケージの名前の前に 'emacs-' が付きますが (例: emacs-lua-mode)、常にそうなっているわけではありません (例: auctexAUR)。\n\nパッケージによっては設定ファイルに変更を加えないと機能が有効にならない場合があります。例えば、auctexAUR をインストールしたときは、設定ファイルに以下を追加:\n\n```\n(load \"auctex.el\" nil t t)\n(load \"preview-latex.el\" nil t t)\n```\n\nパッケージのソースコードや README で有効化する方法が書かれているはずです。\n\n"
    },
    {
      "title": "Emacs が 'Undefined color: \"WINDOW_FOREGROUND\"' というエラーメッセージで起動しない",
      "level": 3,
      "content": "mcpp パッケージまたは gcc パッケージをインストールする必要があります。xrdb は X resources を前処理するために C のプリプロセッサ cpp を使用します。C のプリプロセッサがインストールされていない場合、xrdb は C のプリプロセッサを実行しないため WINDOW_FOREGROUND が16進数のカラーコードに展開されません。\n\n"
    },
    {
      "title": "Gccemacs を使用すると Emacs systemd サービスが起動しない",
      "level": 3,
      "content": "Gccemacs (ブランチ emacs-native-comp または pgtk-nativecomp) を使っているときに、systemd サービスを開始しようとすると、.eln ファイルが見つからないというエラーメッセージが記録されることがあります。\n\n```\n$ journalctl --user -xb -g eln\n```\n\n```\nemacs[7507]: emacs: ../native-lisp/28.0.50-x86_64-pc-linux-gnu-fc9c33938bf279333039c28064d363e8/lisp-mode-410874a46ab8852855281f021ca61fe7-1738806322de892570d69dfc55b437c2.eln: cannot open shared object file: No such file or directory\n```\n\n回避策として、[Service] セクションで emacs.service の WorkingDirectory 行を 編集 します。\n\n```\nemacs.service\n```\n\n```\n[Service]\n...\nWorkingDirectory=/usr/lib/emacs/28.0.50/x86_64-pc-linux-gnu/\n...\n```\n\n"
    },
    {
      "title": "カラー出力の問題",
      "level": 3,
      "content": "デフォルトでは、Emacs シェルはカラー表示に使われるエスケープシーケンスをそのまま表示してしまいます。つまり、カラー出力がされるべきところに変な記号が表示されます。\n\nこの問題を解決するには以下を ~/.emacs に記述してください:\n\n```\n(add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)\n```\n\n"
    },
    {
      "title": "X ウィンドウでの文字の表示問題",
      "level": 3,
      "content": "X ウィンドウで emacs を起動した時にメインウィンドウの文字が全て黒縁の白四角になってしまう場合 (対応するフォントがインストールされていない文字を表示したときと同じような記号)、xorg-fonts-75dpi や xorg-fonts-100dpi をインストールして X ウィンドウを再起動してください。\n\n"
    },
    {
      "title": "起動が遅い",
      "level": 3,
      "content": "しばしば起動時間が遅くなる原因は2つあります。\n\nどちらが原因なのか調べるために、次のコマンドで Emacs を実行してください:\n\n```\n$ emacs -q\n```\n\nこのコマンドでも Emacs の起動が遅い場合、不適切なネットワーク設定を参照してください。そうでない場合は、ほぼ確実に .emacs に問題があります。\n\n- /etc/hosts の設定が間違っていると、Emacs の起動が5秒以上遅くなることになります。詳しくはネットワーク設定ガイドの 'ホストネームの設定' を見てください。\n\n- 原因を探るシンプルな方法は、~/.emacs (または ~/.emacs.d/init.el) にて予想されるセクションをコメントアウト(例えば行頭に ';' を入力)し、変化するか確認するため Emacs を再度開始することです。\"require\" と \"load\" を使用することで、特に大きな拡張機能を使った時、起動が遅くなり得ることを心に留めてください。原則として、これらはターゲットが次のいずれかである場合にのみ使用する必要があります。Emacsが起動時に必要とするか、あるいは拡張機能を自動ロードする場合です。そうでなければ、'autoload' 関数を直接使用できます。 たとえば、\n\n```\n(require 'anything)\n```\n\nの代わりに、以下が使えます。\n\n```\n(autoload 'anything \"anything\" \"Select anything\" t)\n```\n\n"
    },
    {
      "title": "Cannot open load file: ...",
      "level": 3,
      "content": "このエラーに共通する主な原因は、'load-path' 変数に拡張機能が置かれているディレクトリのパスが含まれていないことです。解決するには、拡張機能のロードを試みる前に、適切なパスをリストへ追加します:\n\n```\n(add-to-list 'load-path \"/path/to/directory/\")\n```\n\n拡張機能のためのパッケージを使用しようとして、かつ Emacs が '/usr' 以外のプレフィックスで設定されたとき、ロードパスを更新する必要があります。以下を ~/.emacs のパッケージによって提供される処理の前に配置します:\n\n```\n(add-to-list 'load-path \"/usr/share/emacs/site-lisp\")\n```\n\nもし手動で Emacs をコンパイルしたら、デフォルトのプレフィックスは '/usr/local' であることを心に留めてください。\n\n"
    },
    {
      "title": "デッドアクセントキーの問題: '<dead-acute> is undefined'",
      "level": 3,
      "content": "このバグについて Google で検索すると、次のリンクが見つかります: https://lists.gnu.org/archive/html/help-gnu-emacs/2009-05/msg00167.html\n\n問題の説明: Emacs の最近のバージョンでは、 アクセントキーを使用する通常の方法は、期待通りに動きません。'fiancé' のような単語をアクセントしようとすると上のメッセージが表示されます。\n\n解決するには、スタートアップファイル ~/.emacs の上部に以下の行を記述します。\n\n```\n(require 'iso-transl)\n```\n\nさらに、これは不具合ではなく、新しい Emacs バージョンの機能です。メーリングリストでの本件に関するメッセージを読むと、以下であることが分かりました (https://lists.gnu.org/archive/html/help-gnu-emacs/2009-05/msg00179.html):\n\n"
    },
    {
      "title": "C-M-% やその他のバインディングが emacs nox で動作しない",
      "level": 3,
      "content": "これはターミナルが Xorg よりも制限的であることが原因です。ただし、ターミナルによっては多くのバインディングを扱うことができることがあります。2つの解決法が考えられます:\n\n- グラフィカルバージョンを使用する。\n- サポートされているバインディングに変更する。\n\n例:\n\n```\n.emacs\n```\n\n```\n(global-set-key (kbd \"C-M-y\") 'query-replace-regexp)\n```\n\n"
    },
    {
      "title": "Emacs がフリーズする",
      "level": 3,
      "content": "シングルスレッドであるがゆえに、Emacs は様々な操作でブロックします。フリーズが発生する状況は様々です。例えば、Emacs はあなたからの入力を待っているのかもしれません (例えばあるフレームでミニバッファを開いているのに他のフレームで作業しようとしている場合など)。あるいは、Emacs は完了するまで時間のかかるコードを実行中なのかもしれません。あるいはバグを踏んだという可能性もあります。Emacs プロセスを殺さずに Emacs のブロックを解除する方法は複数存在します。\n\n- C-g を押してみる。Emacs が行っていることによっては、複数回押す必要があります。\n- ESC ESC ESC を押してみる。\n- 他のターミナルで killall -SIGUSR2 emacs を実行する。\n\n"
    },
    {
      "title": "Emacs-nox の出力が汚い",
      "level": 3,
      "content": "ターミナル上で動作している時、色、インデント、あるいは出力に関するものが狂ったように見えます。（多分？）Emacs がある点で特別な文字を送り、それが現在のターミナルと競合しているためのようです。 もしこれが起きた時、できることは M-x redraw-display を実行することです。これにより、ターミナルの表示を再描画します。この問題が頻繁に起きるなら、たとえば\n\n```\n(global-set-key (kbd \"<f7>\") 'redraw-display)\n```\n\nといった記述を、.emacs ファイルに置くといった方法で、コマンドをキーに割り当てたいと思うかもしれません。\n\nグラフィカルバージョンの Emacs はこの問題が起きません。\n\n"
    },
    {
      "title": "emacs ターミナルにおかしなエスケープ数字 (utf-8) が表示される",
      "level": 3,
      "content": ".bashrc または .zshrc で以下の変数をエクスポートしてください:\n\n```\n~/.bashrc\n```\n\n```\nexport LANG=\"en_US.UTF-8\"\nexport LC_ALL=\"en_US.UTF-8\"\nexport TERM=xterm-256color\n```\n\n小文字の utf を使っていることがエラーの原因です (例: en_US.utf-8)。\n\n利用可能なロケールは locale -a で確認できます。\n\n"
    },
    {
      "title": "tmux で emacs を使っているときに Shift + 矢印キーが動作しない",
      "level": 3,
      "content": "まず tmux の設定で xterm-keys を有効にしてください:\n\n```\n.tmux.conf\n```\n\n```\nsetw -g xterm-keys on\n```\n\nしかしながら、この設定は他のキーコンビネーションを破壊します。それを修正するために、以下を emacs の設定に記述します:\n\n```\n~/.emacs\n```\n\n```\n(defadvice terminal-init-screen\n  ;; `tmux' と名付けることをアドバイスします。そして `terminal-init-screen' が実行される前に実行します。\n  (before tmux activate)\n  ;; Docstring.  これはアドバイスを記述し、emacs 内部で有効になります;\n  ;; たとえば、 C-h f terminal-init-screen RET を実行したときに表示されます。\n  \"Apply xterm keymap, allowing use of keys passed through tmux.\"\n  ;; これは elisp コードで、`terminal-init-screen' より前に実行されます。\n  (if (getenv \"TMUX\")\n    (let ((map (copy-keymap xterm-function-map)))\n    (set-keymap-parent map (keymap-parent input-decode-map))\n(set-keymap-parent input-decode-map map))))\n```\n\n詳しくは tmux FAQ を参照。\n\n"
    },
    {
      "title": "KDE でウィンドウのリサイズがおかしい",
      "level": 3,
      "content": "KDE ユーザーには Emacs のウィンドウが正しくリサイズされないという現象がおこることがあります。リサイズした部分が透過されマウスでクリックしても下のウィンドウがクリックされます。この挙動を修正するには、KDE の GTK3 テーマを oxygen-gtk 以外のテーマに変更してください。例えば、gtk3 に含まれている Emacs テーマを使って下さい。\n\nKDE で Emacs を完全に最大化するには、タイトルバーの Emacs アイコンをクリックして、More Actions > Special Window Settings を選択してください。そして \"Size & Position\" タブで \"Obey geometry restrictions\" を選択して、ドロップダウンメニューで \"Force\" を選んで右のラジオボタンで \"No\" を選んで下さい。\n\n"
    },
    {
      "title": "派生",
      "level": 2,
      "content": "Emacs の実装は多数存在します。おそらく GNU/Emacs が一番ポピュラーです。軽量な Emacs 互換のテキストエディタは Arch のリポジトリや AUR にあります。\n\n- mg — C で書かれた軽量な Emacs の実装です。mg は UTF-8 をサポートしていません。\n\n- Zile — \"Zile Is Lossy Emacs\" Zile はできる限り Emacs に近づくように書かれている軽量な Emacs クローンです。Zile は UTF-8 をサポートしていません。\n\n- uemacs — Linus Torvalds によるカスタム版 Micro-emacs。\n\n- emacs-ng — Emacsの新しいアプローチ - TypeScript、Threading、Async I/O、WebRender を含む。\n\n- qemacs — \"Quick Emacs\" は、Emacs Lisp インタプリタをベースとしていますが、コードベースが小さく、ユーザーインターフェイスが簡素化されています。\n\n- sxemacs — xemacs のフォーク。\n\n- jove — Jonathan のバージョンの Emacs は、Lisp を含まない Emacs に似たエディタです。\n\n"
    },
    {
      "title": "Emacs ディストリビューション",
      "level": 3,
      "content": "- Spacemacs - コミュニティ主導の Emacs ディストリビューション\n- Doom Emacs - 頑固な火星人ハッカーのための Emacs フレームワーク\n- Witchmacs - 最もかわいい Emacs ディストリビューション\n- Yukimacs - Uncle Dave の Emacs と Witchmacs に大きく影響された (Spacemacs や Doom Emacs ではなく) ゼロから構築された GNU/Emacs 構成\n\nその他: Starter Kits\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- GNU Emacs ホームページ\n- GNU Emacs マニュアル\n- Emacs Wiki\n- WikEmacs - 読みやすいが不完全な Emacs wiki\n- Emacs とそのショートカットの有用な紹介\n- The Emacs 教会 (Google ドライブ)\n- 公式リファレンスカード\n- EXWM - Emacs X Window Manager\n\n"
    }
  ]
}