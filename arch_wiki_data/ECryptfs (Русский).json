{
  "title": "ECryptfs (Русский)",
  "url": "https://wiki.archlinux.org/title/ECryptfs_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "В статье описывается базовое использование eCryptfs. Статья проведёт вас через процесс установки зашифрованной домашней директории, в которой вы можете хранить личные/секретные данные.\n\nРеализация eCryptfs отличается от реализации dm-crypt, которая предоставляет слой шифрования блочного устройства, в то время как eCryptfs является файловой системой — стековая криптографическая файловая система. О сравнении двух методов шифрования можно прочитать в статье Data-at-rest encryption (Русский)#Сравнение типов шифрования. Отличительной особенностью eCryptfs является то, что шифрование работает поверх существующей файловой системы; eCryptfs может быть смонтирован на любой существующий каталог и не требует отдельного раздела (или предварительного выделения места).\n\n"
    },
    {
      "title": "Основы",
      "level": 2,
      "content": "Как уже упоминалось выше, eCryptfs не требует создавать отдельный раздел или предварительно выделять место. Вместо этого вы можете смонтировать eCryptfs поверх любого отдельного каталога для его защиты. Это включает, например, весь домашний каталог пользователя или отдельные каталоги внутри него. Все метаданные, необходимые для работы с шифрованием, хранятся в заголовках файлов, поэтому зашифрованные данные можно легко перемещать, хранить для резервного копирования и восстанавливать. Есть и другие преимущества, но есть и недостатки, например, eCryptfs не подходит для шифрования разделов целиком, что также означает, что вы не можете с его помощью защитить подкачку (но вы, конечно, можете использовать его совместно с dm-crypt/Swap encryption). Если вы только начинаете работать с шифрованием диска, шифрование подкачки и другие моменты, на которые стоит обратить внимание, рассматриваются в разделе Data-at-rest encryption (Русский)#Подготовка.\n\nНесколько моментов для ознакомления с eCryptfs:\n\n- Так как eCryptfs это стековая ФС, монтирование eCryptfs означает монтирование зашифрованного каталога в другую незашифрованную точку монтирования (каталог).\n- Существует возможность совместного использования зашифрованного каталога несколькими пользователями. Однако шифрование выполняется одним паролем, поэтому пароль тоже должен быть общим для всех. Также можно совместно использовать каталог с разными зашифрованными файлами (разные пароли).\n- Некоторые термины eCryptfs, используемые в документации: В документации eCryptfs и в этой статье каталог, в котором хранятся данные в зашифрованном виде, называется нижним (lower), а каталог, в котором отображаются расшифрованные данные, — верхним (upper). Хотя это и не относится к данной статье, файловая система Overlay, представленная в Linux 3.18, использует то же обозначение верхних/нижних каталогов для объединения файловых систем. Пароль монтирования (mount passphrase или key) — это то, что даёт доступ к зашифрованным файлам, то есть выполняет разблокировку зашифрованных данных. eCryptfs использует термин «wrapped passphrase» для обозначения криптографически защищённого пароля монтирования. FEKEK означает File's Encryption Key Encryption Key — ключ шифрования, которым шифруются ключи шифрования файлов (смотрите документацию ядра). FNEK означает File Name Encryption Key, ключ для (опционального) шифрования имён файлов, хранящихся в зашифрованном каталоге.\n\n- В документации eCryptfs и в этой статье каталог, в котором хранятся данные в зашифрованном виде, называется нижним (lower), а каталог, в котором отображаются расшифрованные данные, — верхним (upper). Хотя это и не относится к данной статье, файловая система Overlay, представленная в Linux 3.18, использует то же обозначение верхних/нижних каталогов для объединения файловых систем.\n- Пароль монтирования (mount passphrase или key) — это то, что даёт доступ к зашифрованным файлам, то есть выполняет разблокировку зашифрованных данных. eCryptfs использует термин «wrapped passphrase» для обозначения криптографически защищённого пароля монтирования.\n- FEKEK означает File's Encryption Key Encryption Key — ключ шифрования, которым шифруются ключи шифрования файлов (смотрите документацию ядра).\n- FNEK означает File Name Encryption Key, ключ для (опционального) шифрования имён файлов, хранящихся в зашифрованном каталоге.\n\nПеред использованием eCryptfs проверьте применимость следующих недостатков.\n\n"
    },
    {
      "title": "Недостатки",
      "level": 3,
      "content": "- Простота использования\n\n- Длина имени файла\n\n- Монтирование сетевых хранилищ\n\n- Разрежённые файлы\n\n"
    },
    {
      "title": "Установка и монтирование",
      "level": 2,
      "content": "Перед началом посмотрите документацию eCryptfs.\n\neCryptfs входит в ядро с версии 2.6.19, но для работы с ней, вам нужны дополнительные инструменты: ecryptfs-utils и keyutils.\n\nПосле установки загрузите модуль ядра:\n\n```\n# modprobe ecryptfs\n```\n\nЧтобы примонтировать eCryptfs, нужны пользовательские инструменты из пакета ecryptfs-utils. К сожалению, из-за плохого дизайна этих инструментов лучше выбирать один из следующих трёх способов настройки eCryptfs с различными компромиссами:\n\n1. Высокоуровневые #Инструменты Ubuntu, которые настраивают всё автоматически, но требуют, чтобы нижний каталог был ~/.Private/, и позволяют использовать только одну зашифрованную файловую систему на пользователя.\n1. #ecryptfs-simple, доступный в AUR, который является простым способом монтирования файловых систем eCryptfs, используя любой нижний каталог и верхний каталог.\n1. #Ручная настройка, которая включает отдельные шаги для загрузки пароля и монтирования eCryptfs, но позволяет полностью контролировать каталоги и настройки шифрования.\n\n"
    },
    {
      "title": "Инструменты Ubuntu",
      "level": 3,
      "content": "Большинство удобных инструментов, устанавливаемых пакетом ecryptfs-utils, предполагают очень специфическую настройку eCryptfs, а именно ту, которая официально используется в Ubuntu (где она может быть выбрана в качестве опции при установке). К сожалению, эти варианты не просто заданы по умолчанию, а фактически жёстко закодированы в этих инструментах. Если эта настройка не соответствует вашим потребностям, то вы не сможете использовать удобные инструменты и вам придётся следовать шагам из раздела #Ручная настройка.\n\nНастройка, используемая этими инструментами, выглядит следующим образом:\n\n- у каждого пользователя есть только один зашифрованный каталог, контролируемый этими инструментами: или каталог $HOME полностью, или один каталог с зашифрованными данными (по умолчанию ~/Private/, но это можно изменить).\n- нижний каталог всегда ~/.Private/(если шифруется домашний каталог целиком, это будет символическая ссылка на /home/.ecryptfs/пользователь/.Private/)\n- используемые параметры шифрования: cipher: AES key length: 16 bytes (128 bits) key management scheme: passphrase plaintext passthrough: enabled\n- настройки зашифрованного каталога хранятся в файлах внутри каталога ~/.ecryptfs/:(если шифруется домашний каталог целиком, это будет символическая ссылка на /home/.ecryptfs/пользователь/.ecryptfs/) Private.mnt [текстовый файл] — содержит путь к верхнему каталогу (точке монтирования, например /home/lucy или /home/lucy/Private) Private.sig [текстовый файл] — содержит подпись, используемую для идентификации пароля монтирования в списке ключей ядра wrapped-passphrase [бинарный файл] — пароль монтирования, зашифрованный паролем пользователя auto-mount, auto-umount [пустые файлы] — если они существуют, то модуль pam_ecryptfs.so (если он загружен) будет автоматически монтировать/размонтировать зашифрованный каталог при входе/выходе пользователя\n\n- или каталог $HOME полностью,\n- или один каталог с зашифрованными данными (по умолчанию ~/Private/, но это можно изменить).\n\n- cipher: AES\n- key length: 16 bytes (128 bits)\n- key management scheme: passphrase\n- plaintext passthrough: enabled\n\n- Private.mnt [текстовый файл] — содержит путь к верхнему каталогу (точке монтирования, например /home/lucy или /home/lucy/Private)\n- Private.sig [текстовый файл] — содержит подпись, используемую для идентификации пароля монтирования в списке ключей ядра\n- wrapped-passphrase [бинарный файл] — пароль монтирования, зашифрованный паролем пользователя\n- auto-mount, auto-umount [пустые файлы] — если они существуют, то модуль pam_ecryptfs.so (если он загружен) будет автоматически монтировать/размонтировать зашифрованный каталог при входе/выходе пользователя\n\n"
    },
    {
      "title": "Шифрование каталога",
      "level": 4,
      "content": "Для шифрования домашнего каталога смотрите #Шифрование домашнего каталога.\n\nПеред настройкой шифрования решите, будет ли он монтироваться вручную или автоматически при входе пользователя в систему.\n\nЧтобы зашифровать один каталог и позже смонтировать его вручную, выполните:\n\n```\n$ ecryptfs-setup-private --nopwcheck --noautomount\n```\n\nи следуйте инструкциям. Опция --nopwcheck позволяет выбрать пароль, отличный от пароля входа пользователя, а опция --noautomount отключает автоматическое монтирование. Поэтому, если вы хотите в дальнейшем автоматически монтировать зашифрованный каталог при входе в систему, просто опустите обе опции.\n\nСкрипт автоматически создаст структуры каталогов ~/.Private/ и ~/.ecryptfs/, как описано выше. Он также запросит два пароля:\n\nТочка монтирования («верхний каталог») по умолчанию ~/Private/, но после настройки можно задать свой каталог с помощью следующих команд:\n\n```\n$ mv ~/Private /путь/к/новому/каталогу\n$ echo /путь/к/новому/каталогу > ~/.ecryptfs/Private.mnt\n```\n\nДля использования зашифрованного каталога его нужно примонтировать — смотрите раздел #Монтирование ниже.\n\n"
    },
    {
      "title": "Шифрование домашнего каталога",
      "level": 4,
      "content": "Скрипт-обёртка ecryptfs-migrate-home создаст зашифрованный домашний каталог для пользователя и позаботится о переносе всех существующих файлов из ещё не зашифрованного домашнего каталога.\n\nДля его запуска пользователь должен выйти из системы и не оставить никаких запущенных от его имени процессов. Лучший способ добиться этого — выйти из системы, войти в консоль как root и проверить, что команда ps -U пользователь ничего не выводит. Также убедитесь, что у вас установлены rsync, lsof и which. После того как все необходимые условия выполнены, выполните:\n\n```\n# modprobe ecryptfs\n# ecryptfs-migrate-home -u пользователь\n```\n\nи следуйте инструкциям. После завершения работы скрипта следуйте инструкциям по автомонтированию — смотрите раздел #Автомонтирование ниже. Пользователь должен обязательно войти в систему перед следующей перезагрузкой, чтобы завершить процесс.\n\nКогда всё заработает, можно и нужно удалить незашифрованную резервную копию домашнего каталога пользователя, сохранённую в /home/пользователь.случайные_символы.\n\n"
    },
    {
      "title": "Монтирование",
      "level": 4,
      "content": "Запустите скрипт-обёртку\n\n```\n$ ecryptfs-mount-private\n```\n\nИ введите пароль пользователя, который вы задали при создании зашифрованного каталога. После этого зашифрованный каталог будет примонтирован в верхний каталог (по умолчанию ~/Private/).\n\nДля размонтирования выполните:\n\n```\n$ ecryptfs-umount-private\n```\n\nВ состав инструментов входит ещё один скрипт, который может быть очень удобен для доступа к зашифрованным данным .Private или домашнему каталогу. Выполнение ecryptfs-recover-private от имени root приведёт к поиску каталога в системе (или по опционально указанному пути), запросу пароля для него и монтированию каталога. Это может, например, использоваться с live-CD или другой системы для доступа к зашифрованным данным в случае восстановления. Обратите внимание, что при загрузке из Arch Linux ISO нужно сперва установить ecryptfs-utils. Он может монтировать только каталоги .Private, созданные с помощью инструментов Ubuntu.\n\nСтандартный способ автомонтирования — через PAM. Смотрите pam_ecryptfs(8) и — для более подробной информации — 'PAM MODULE' в:\n\n```\n/usr/share/doc/ecryptfs-utils/README\n```\n\nДля автоматического монтирования необходимо, чтобы пароль для доступа к зашифрованному каталогу совпадал с паролем учётной записи пользователя.\n\nНиже описаны шаги по его настройке:\n\n1. Проверьте, что файлы ~/.ecryptfs/auto-mount, ~/.ecryptfs/auto-umount и ~/.ecryptfs/wrapped-passphrase существуют (их автоматически создаёт ecryptfs-setup-private).\n\n2. Добавьте ecryptfs в pam-стек в точности как описано ниже, чтобы обеспечить прозрачную дешифровку пароля монтирования при входе в систему:\n\nОткройте /etc/pam.d/system-auth и после строки, содержащей auth required pam_unix.so (или auth [default=die] pam_faillock.so authfail если есть), добавьте:\n\n```\nauth [success=1 default=ignore] pam_succeed_if.so service = systemd-user quiet\nauth    required    pam_ecryptfs.so unwrap\n```\n\nДалее, перед строкой, содержащей password required pam_unix.so (или -password [success=1 default=ignore] pam_systemd_home.so если есть) добавьте:\n\n```\npassword    optional    pam_ecryptfs.so\n```\n\nИ, наконец, после строки session required pam_unix.so добавьте:\n\n```\nsession [success=1 default=ignore] pam_succeed_if.so service = systemd-user quiet\nsession    optional    pam_ecryptfs.so unwrap\n```\n\n3. Перелогиньтесь и с помощью команды mount проверьте, появилась ли новая точка монтирования:\n\n```\n/home/пользователь/.Private on /home/пользователь/Private type ecryptfs (...)\n```\n\nКаталог ~/Private/ теперь должен содержать расшифрованные данные.\n\nКаталог должен автоматически размонтироваться и становиться недоступным, когда пользователь выходит из системы.\n\n"
    },
    {
      "title": "ecryptfs-simple",
      "level": 3,
      "content": "Используйте ecryptfs-simple, если вы просто хотите использовать eCryptfs для монтирования произвольных каталогов подобно EncFS. ecryptfs-simple не требует прав root или записей в /etc/fstab, а также не использует жёстко заданные каталоги вроде ~/.Private/. Его можно установить с помощью пакета ecryptfs-simpleAUR или из репозиториев Xyne.\n\nКак следует из названия, использование простое:\n\nПростое монтирование:\n\n```\n$ ecryptfs-simple /path/to/foo /path/to/bar\n```\n\nАвтоматическое монтирование: запрашивает опции при первом монтировании каталога и записывает их в файл настроек, а при следующем монтировании считывает опции из ранее записанного файла:\n\n```\n$ ecryptfs-simple -a /path/to/foo /path/to/bar\n```\n\nРазмонтирование по исходному каталогу:\n\n```\n$ ecryptfs-simple -u /path/to/foo\n```\n\nРазмонтирование по точке монтирования:\n\n```\n$ ecryptfs-simple -u /path/to/bar\n```\n\n"
    },
    {
      "title": "Ручная настройка",
      "level": 3,
      "content": "Ниже приведены инструкции по настройке зашифрованных каталогов eCryptfs вручную. Это включает в себя два этапа. Во-первых, пароль обрабатывается и загружается в список ключей ядра. Во-вторых, файловая система монтируется с использованием ключа из списка ключей.\n\nЕсть два способа добавить пароль в список ключей ядра на первом этапе. Вариант попроще — ecryptfs-add-passphrase, который использует один пароль для шифрования файлов. Недостаток этого способа в том, что вы не сможете изменить пароль после шифрования. Это работает следующим образом:\n\n```\n$ ecryptfs-add-passphrase\nPassphrase:\nInserted auth tok with sig [78c6f0645fe62da0] into the user session keyring\n```\n\nТакже можно передать пароль в стандартный ввод команды ecryptfs-add-passphrase -. Помните, что если вы запишете свой пароль в каком-то файле, это, как правило, сделает всё шифрование бессмысленным.\n\nВариант посложнее — использовать «wrapped passphrase», когда файлы шифруются с помощью случайно сгенерированного ключа, который в свою очередь зашифрован вашим паролем и хранится в файле. В этом случае вы без проблем можете изменить пароль, просто расшифровав файл ключа старым паролем и зашифровав его новым.\n\nПриведённый ниже скрипт запрашивает пароль, генерирует ключ подобно ecryptfs-setup-private, шифрует его введённым вами паролем и записывает в файл ~/.ecryptfs/wrapped-passphrase:\n\n```\n$ mkdir ~/.ecryptfs\n$ ( stty -echo; printf \"Passphrase: \" 1>&2; read PASSWORD; stty echo; echo 1>&2; head -c 48 /dev/random | base64; echo \"$PASSWORD\"; ) \\\n  | ecryptfs-wrap-passphrase ~/.ecryptfs/wrapped-passphrase >/dev/null\n```\n\nПароль должен быть не длиннее 64 символов.\n\nТеперь можно расшифровать ключ паролем и загрузить его в ядро:\n\n```\n$ ( stty -echo; printf \"Passphrase: \" 1>&2; read PASSWORD; stty echo; echo $PASSWORD; ) | ecryptfs-insert-wrapped-passphrase-into-keyring ~/.ecryptfs/wrapped-passphrase -\nInserted auth tok with sig [7c5d3dd8a1b49db0] into the user session keyring\n```\n\nПри любом из этих вариантов после успешного добавления ключа вы получите подпись (sig) вида 78c6f0645fe62da0, которая пригодится в дальнейшем.\n\nСуществует два способа ручного монтирования eCryptfs, описанных в следующих разделах. Первый способ, с использованием mount.ecryptfs_private, позволяет выполнить монтирование от имени обычного пользователя и предполагает настройку некоторых конфигурационных файлов. Этот способ не позволяет изменять параметры шифрования, например, размер ключа. Второй способ — использовать обычную команду mount напрямую, что даст полный контроль над всеми настройками, но требует либо запуска от имени root, либо добавления записи в /etc/fstab, которая разрешит монтирование обычному пользователю.\n\n"
    },
    {
      "title": "С использованием файлов настроек",
      "level": 4,
      "content": "Этот метод использует запуск команды mount.ecryptfs_private из пакета ecryptfs-utils, после предварительной загрузки пароля. Он не требует прав root.\n\nСначала выберите имя для файлов настроек в ~/.ecryptfs/ и определитесь с нижней и верхней директориями. В данном примере используется имя secret для файлов конфигурации, зашифрованные данные находятся в ~/.secret/, а расшифрованные файлы будут доступны в ~/secret/ после монтирования. Создайте все эти каталоги:\n\n```\n$ mkdir ~/.secret ~/secret ~/.ecryptfs\n```\n\nТеперь пропишите полные пути к ним в ~/.ecryptfs/secret.conf. Формат похож на /etc/fstab, но без опций монтирования:\n\n```\n$ echo \"$HOME/.secret $HOME/secret ecryptfs\" > ~/.ecryptfs/secret.conf\n```\n\nЗапишите подпись ключа (sig), которую вам выдала команда ecryptfs-add-passphrase или ecryptfs-insert-wrapped-passphrase-into-keyring (смотрите выше), в файл ~/.ecryptfs/secret.sig:\n\n```\n$ echo 78c6f0645fe62da0 > ~/.ecryptfs/secret.sig\n```\n\nЕсли вы также хотите включить шифрование имён файлов, создайте ещё один пароль (или переиспользуйте предыдущий) и добавьте ещё одну подпись в файл ~/.ecryptfs/secret.sig:\n\n```\n$ echo 326a6d3e2a5d444a >> ~/.ecryptfs/secret.sig\n```\n\nНаконец, примонтируйте ~/.secret/ в ~/secret/:\n\n```\n$ mount.ecryptfs_private secret\n```\n\nПосле завершения работы размонтируйте:\n\n```\n$ umount.ecryptfs_private secret\n```\n\n"
    },
    {
      "title": "С использованием команды mount",
      "level": 4,
      "content": "Запуская команду mount вручную, вы получаете полный контроль над параметрами шифрования. Недостатком является то, что вам нужно либо запускать команду mount от имени root, либо добавить запись в /etc/fstab для каждого каталога eCryptfs, чтобы пользователи могли их монтировать.\n\nСначала создайте личные каталоги. В этом примере используются те же каталоги, что и в предыдущем разделе:\n\n```\n$ mkdir -m 700 ~/.secret\n$ mkdir -m 500 ~/secret\n```\n\nВкратце:\n\n- Зашифрованные данные будут храниться в нижнем каталоге ~/.secret/\n- При монтировании расшифрованные данные станут доступны в каталоге ~/secret/ Пока каталог не смонтирован, в него ничего нельзя записать При монтировании он имеет те же права доступа, что и нижний каталог\n\n- Пока каталог не смонтирован, в него ничего нельзя записать\n- При монтировании он имеет те же права доступа, что и нижний каталог\n\nТеперь, предполагая, что вы создали «wrapped passphrase» как описано в разделе выше, вам нужно загрузить ключ шифрования обычного пользователя один раз в список ключей пользователя root:\n\n```\n# ( stty -echo; printf \"Passphrase: \" 1>&2; read PASSWORD; stty echo; echo $PASSWORD; ) | ecryptfs-insert-wrapped-passphrase-into-keyring /home/пользователь/.ecryptfs/wrapped-passphrase -\nInserted auth tok with sig [7c5d3dd8a1b49db0] into the user session keyring\n```\n\nпосле чего следующая команда монтирования должна успешно сработать (не забудьте указать правильные подписи ключей):\n\n```\n# mount -i -t ecryptfs /home/пользователь/.secret /home/пользователь/secret -o ecryptfs_sig=7c5d3dd8a1b49db0,ecryptfs_fnek_sig=7c5d3dd8a1b49db0,ecryptfs_cipher=aes,ecryptfs_key_bytes=32,ecryptfs_unlink_sigs\n```\n\n- ecryptfs_sig — подпись ключа, которым шифруются данные.\n- ecryptfs_fnek_sig — подпись ключа, которым шифруются имена файлов; если вам это не нужно, опцию можно опустить.\n- ecryptfs_key_bytes может быть 16, 24 или 32 для изменения размера ключа шифрования.\n- ecryptfs_unlink_sigs — удаляет ключи из списка ключей ядра при размонтировании, из-за чего вам нужно будет повторно загружать ключи при повторном монтировании.\n- Также доступны и другие опции; они описаны в документации ecryptfs.\n\nПосле того, как вы выбрали подходящие параметры монтирования, вы можете добавить запись в /etc/fstab, чтобы монтировать каталог мог обычный пользователь. Скопируйте параметры монтирования в новую запись /etc/fstab и добавьте параметры user и noauto. Полный текст записи будет выглядеть примерно так (добавления выделены жирным шрифтом):\n\n```\n/etc/fstab\n```\n\n```\n/home/пользователь/.secret /home/пользователь/secret ecryptfs noauto,user,ecryptfs_sig=7c5d3dd8a1b49db0,ecryptfs_fnek_sig=7c5d3dd8a1b49db0,ecryptfs_cipher=aes,ecryptfs_key_bytes=32,ecryptfs_unlink_sigs 0 0\n```\n\n- Параметр noauto важен, иначе systemd будет пытаться примонтировать зашифрованный каталог автоматически при загрузке системы.\n- Параметр user разрешает монтирование обычному пользователю без прав root. Пользовательское монтирование по умолчанию выполняется с опцией noexec. Если вам нужно разрешить запуск исполняемых файлов из зашифрованного каталога, добавьте параметр exec в записи fstab.\n\n- Пользовательское монтирование по умолчанию выполняется с опцией noexec. Если вам нужно разрешить запуск исполняемых файлов из зашифрованного каталога, добавьте параметр exec в записи fstab.\n\nТеперь настройка завершена, и каталог должен стать доступен для монтирования обычным пользователем.\n\nЧтобы смонтировать зашифрованный каталог от имени пользователя, нужно предварительно загрузить ключ, расшифровав его вашим паролем. Следуя приведённому выше примеру:\n\n```\n$ ecryptfs-insert-wrapped-passphrase-into-keyring ~/.ecryptfs/wrapped-passphrase\nPassphrase:\nInserted auth tok with sig [7c5d3dd8a1b49db0] into the user session keyring\n```\n\nТеперь каталог может быть смонтирован без лишних вопросов:\n\n```\n$ mount -i ~/secret\n```\n\nи файлы, помещаемые в каталог secret, будут шифроваться. Эти два шага нужно выполнять каждый раз для ручного монтировния каталога.\n\nРазмонтирование:\n\n```\n$ umount ~/secret\n```\n\nВ завершение можно изменить пароль, которым шифруется ключ шифрования данных:\n\n```\n$ ecryptfs-rewrap-passphrase ~/.ecryptfs/wrapped-passphrase\nOld wrapping passphrase:\nNew wrapping passphrase:\nNew wrapping passphrase (again):\n```\n\nРазмонтирование должно автоматически очищать список ключей, но вы также можете проверить её состояние и очистить вручную:\n\n```\n$ keyctl list @u\n$ keyctl clear @u\n```\n\nДля автоматического монтирования ранее определённого монтирования в /etc/fstab при входе в систему можно использовать различные методы. В качестве первого общего шага выполните пункты (1) и (2) раздела #Автомонтирование.\n\nЗатем, если вы входите в систему через консоль, простым способом является использование интерактивных команд mount и umount в настройках оболочки пользователя, например, Bash (Русский)#Файлы настроек.\n\nДругой метод — автоматическое монтирование каталога eCryptfs при входе пользователя в систему с помощью pam_mount. Для его настройки добавьте следующие строки в файл /etc/security/pam_mount.conf.xml:\n\n```\n<luserconf name=\".pam_mount.conf.xml\" />\n<mntoptions require=\"\" /> \n<lclmount>mount -i %(VOLUME) \"%(before=\\\"-o\\\" OPTIONS)\"</lclmount>\n```\n\nПерепишите эти строки вручную, а не просто скопируйте/вставьте их (особенно строку lclmount), иначе вы можете получить некоторые поврежденные символы. Пояснения:\n\n- первая строка указывает, где находится пользовательский файл конфигурации (в данном случае ~/.pam_mount.conf.xml)\n- вторая строка очищает ненужные по умолчанию опции монтирования (\"nosuid,nodev\")\n- последняя строка указывает, какую команду монтирования нужно запустить (для eCryptfs нужна опция -i).\n\nТеперь создайте файл ~/.pam_mount.conf.xml с описанием томов для монтирования:\n\n```\n<pam_mount>\n    <volume noroot=\"1\" fstype=\"ecryptfs\" path=\"/home/пользователь/.secret/\" mountpoint=\"/home/пользователь/secret/\" />\n</pam_mount>\n```\n\n\"noroot\" нужен, потому что ключ шифрования нужно добавлять в список ключей пользователя.\n\nНаконец, измените файл /etc/pam.d/system-login как описано в статье pam_mount.\n\nЧтобы не тратить время на ненужную расшифровку пароля, можно создать скрипт, который будет проверять количество открытых сеансов с помощью pmvarrun:\n\n```\n/usr/local/bin/doecryptfs\n```\n\n```\n#!/bin/sh\n\nexit $(/usr/sbin/pmvarrun -u$PAM_USER -o0)\n```\n\nЗатем добавьте следующую строку перед модулем eCryptfs unwrap в вашем стеке PAM:\n\n```\nauth    [success=ignore default=1]    pam_exec.so     quiet /usr/local/bin/doecryptfs\nauth    required                      pam_ecryptfs.so unwrap\n```\n\nСтатья предлагает добавить их в /etc/pam.d/login, но изменения нужно будет добавить во все другие места, где вы входите в систему, например, /etc/pam.d/kde.\n\n"
    },
    {
      "title": "Ссылка в зашифрованный каталог",
      "level": 3,
      "content": "Помимо использования зашифрованного каталога в качестве хранилища конфиденциальных файлов и личных данных, его также можно использовать для защиты данных приложений. Например, в Firefox есть внутренний менеджер паролей, но история просмотров и кэш также могут быть конфиденциальными. Защитить их очень просто:\n\n```\n$ mv ~/.mozilla ~/Private/mozilla\n$ ln -s ~/Private/mozilla ~/.mozilla\n```\n\n"
    },
    {
      "title": "Удаление зашифрованного каталога",
      "level": 3,
      "content": "Для удаления зашифрованного каталога никаких особых действий не требуется. Убедитесь, что он размонтирован, и удалите соответствующий нижний каталог (например, ~/.Private/) вместе со всеми зашифрованными файлами внутри него. Затем нужно удалить каталог ~/.ecryptfs/ с настройками и ключами шифрования, и на этом всё.\n\nЕсли вы использовали #Инструменты Ubuntu для настройки, вы можете использовать команду:\n\n```\n$ ecryptfs-setup-private --undo\n```\n\nи следовать её инструкциям.\n\n"
    },
    {
      "title": "Резервное копирование",
      "level": 3,
      "content": "Если вы хотите переместить файл из зашифрованного каталога наружу, просто переместите его как обычно из смонтированного каталога ~/Private/.\n\nВ eCryptfs криптографические метаданные хранятся в заголовках файлов. Варианты настройки, описанные в этой статье, отделяют каталог с зашифрованными данными от точки монтирования. Точка монтирования с расшифрованными данными полностью прозрачна и доступна для резервного копирования. Очевидно, что это необходимо учитывать при автоматическом резервном копировании, если нужно избежать утечки конфиденциальных незашифрованных данных в резервную копию.\n\nМожно делать резервные копии или инкрементные резервные копии непосредственно зашифрованного каталога (например, ~/.Private/) так же, как и любого другого обычного каталога.\n\nДругие моменты, на которые следует обратить внимание:\n\n- Если вы выполнили #Шифрование домашнего каталога с помощью инструментов Ubuntu, имейте в виду, что нижний каталог с зашифрованными файлами находится вне домашнего каталога обычного пользователя: по адресу /home/.ecryptfs/пользователь/.Private/.\n- Следует убедиться, что для файлов настройки eCryptfs (обычно ~/.ecryptfs/) тоже имеется резервная копия.\n- Если вы используете специальные опции монтирования файловой системы, например ecryptfs_xattr, проведите дополнительную проверку целостности резервной копии.\n\n"
    },
    {
      "title": "При подключении через Mosh может произойти сбой монтирования на удалённом хосте",
      "level": 3,
      "content": "Это известная проблема сервера Mosh, который не оставляет смонтированным каталог eCryptfs /home.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- eCryptfs - сайт проекта и документация\n- Аудит безопасности eCryptfs, выполненный Тейлором Хорнби (22 января 2014).\n- eCryptfs and $HOME by Adrian C. (anrxc) - Article with installation instructions and discussion of eCryptfs usage\n- Chromium data protection (November 2009) - Design document detailing encryption options for Chromium OS, including explanation on its eCryptfs usage\n- eCryptfs design by Michael Halcrow (May 2005) - Original design document detailing and discussing eCryptfs\n\n"
    }
  ]
}