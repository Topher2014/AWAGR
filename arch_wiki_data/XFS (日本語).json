{
  "title": "XFS (日本語)",
  "url": "https://wiki.archlinux.org/title/XFS_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- ファイルシステム\n\nXFS は Silicon Graphics, Inc によって開発された高性能ジャーナリングファイルシステムです。XFS はアロケーショングループを使って設計されているため並列化された IO で特に性能を発揮します。このため複数のストレージデバイスを使用するときは IO スレッド, ファイルシステムの帯域, ファイルとファイルシステムのサイズ全てをスケーリングすることが可能です。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 準備\n- 2 設定 2.1 チェックサム 2.2 Free inode btree 2.3 Reverse mapping btree 2.4 タイムスタンプ 2.4.1 アップグレード\n- 3 パフォーマンス 3.1 ストライプサイズと幅 3.2 バリアの無効化 3.3 アクセス日時 3.4 デフラグ 3.4.1 フラグメンテーションレベルの確認 3.4.2 デフラグの実行 3.5 重複排除 3.5.1 Reflink コピー 3.5.2 重複排除 3.6 外部XFSジャーナル 3.7 同期間隔\n- 4 管理 4.1 リサイズ 4.2 オンラインメタデータチェック (スクラブ) 4.3 リペア 4.4 データレスキュー 4.5 Undelete\n- 5 トラブルシューティング 5.1 ルートファイルシステムクォータ 5.2 ユーザー nobody がマウントポイントにアクセスできない場合、xfs_scrub_all が失敗する 5.3 fsck.xfs が systemd ベースの initramfs で失敗する\n- 6 参照\n\n- 2.1 チェックサム\n- 2.2 Free inode btree\n- 2.3 Reverse mapping btree\n- 2.4 タイムスタンプ 2.4.1 アップグレード\n\n- 2.4.1 アップグレード\n\n- 3.1 ストライプサイズと幅\n- 3.2 バリアの無効化\n- 3.3 アクセス日時\n- 3.4 デフラグ 3.4.1 フラグメンテーションレベルの確認 3.4.2 デフラグの実行\n- 3.5 重複排除 3.5.1 Reflink コピー 3.5.2 重複排除\n- 3.6 外部XFSジャーナル\n- 3.7 同期間隔\n\n- 3.4.1 フラグメンテーションレベルの確認\n- 3.4.2 デフラグの実行\n\n- 3.5.1 Reflink コピー\n- 3.5.2 重複排除\n\n- 4.1 リサイズ\n- 4.2 オンラインメタデータチェック (スクラブ)\n- 4.3 リペア\n- 4.4 データレスキュー\n- 4.5 Undelete\n\n- 5.1 ルートファイルシステムクォータ\n- 5.2 ユーザー nobody がマウントポイントにアクセスできない場合、xfs_scrub_all が失敗する\n- 5.3 fsck.xfs が systemd ベースの initramfs で失敗する\n\n"
    },
    {
      "title": "準備",
      "level": 2,
      "content": "XFS ユーザースペースユーティリティ xfsprogs パッケージを インストール して下さい。 XFS ファイルシステムを管理するために必要なツールが含まれています。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "デバイス に新しいファイルシステムを作成するには、次を使用します。\n\n```\n# mkfs.xfs device\n```\n\n一般に、デフォルトのオプションは一般的な使用に最適です。[1] [2]\n\nサンプル出力:\n\n```\nmeta-data=/dev/device            isize=256    agcount=4, agsize=3277258 blks\n         =                       sectsz=512   attr=2\ndata     =                       bsize=4096   blocks=13109032, imaxpct=25\n         =                       sunit=0      swidth=0 blks\nnaming   =version 2              bsize=4096   ascii-ci=0\nlog      =internal log           bsize=4096   blocks=6400, version=2\n         =                       sectsz=512   sunit=0 blks, lazy-count=1\nrealtime =none                   extsz=4096   blocks=0, rtextents=0\n```\n\n- -L label オプションでファイルシステムにラベルを付けることができます。\n- 既存のファイルシステムを含むブロックデバイス上で mkfs.xfs を使用する場合、 ファイルシステムを上書きするために -f オプションを追加します。[3] 'この操作により、以前のファイルシステムに含まれていたデータは全て破壊されます'\n\n"
    },
    {
      "title": "チェックサム",
      "level": 3,
      "content": "xfsprogs 3.2.0 では、新しいディスクフォーマット (v5) が導入され、Self-Describing Metadata というメタデータのチェックサムスキームが含まれています。 CRC32 に基づいており、例えば予期せぬ停電の際にメタデータが破損しないようにするための追加保護を提供します。チェックサムは xfsprogs を使用している場合、デフォルトで有効になっています。3.2.3以降 古いカーネルで読み書き可能な xfs が必要な場合は、 mkfs.xfs(8) を呼ぶときに -m crc=0 スイッチを使えば、簡単に無効にできます。\n\n```\n# mkfs.xfs -m crc=0 /dev/target_partition\n```\n\nXFS v5 オンディスクフォーマットは Linux Kernel 3.15 以降の実稼働ワークロードでは安定と見なされています。\n\n"
    },
    {
      "title": "Free inode btree",
      "level": 3,
      "content": "Linux 3.16 から、XFS には free inode を追跡する btree が追加されました。これは既存の inode 割り当て btree と同等ですが、free inode btree は少なくとも1つの free inode を持つ inode チャンクを追跡することは例外です。目的は、inode 割り当てのための free inode クラスタのルックアップを改善することです。古くなったファイルシステム、つまり、何百万ものファイルをファイルシステムに追加したり、ファイルシステムから削除したりして、何年も経過したファイルシステムでのパフォーマンスを向上させることができます。この機能を使用しても、ファイルシステム全体の信頼性レベルやリカバリ機能には影響がありません。\n\nこの機能は、Linux Kernel 3.15 以降の実運用ワークロードで安定したと考えられる新しい v5 オンディスク・フォーマットに依存しています。既存のディスク上の構造は変更されませんが、inode 割り当て btree との一貫性を維持する必要がある新しい構造が追加されます。このため、古いカーネルでは free inode btree 機能を持つ読み取り専用ファイルシステムのみをマウントすることができます。\n\nこの機能は xfsprogs 3.2.3 以降を使用している場合、デフォルトで有効になっています。古いカーネルで書き込み可能なファイルシステムが必要な場合、XFS パーティションをフォーマットする際に finobt=0 スイッチで無効にすることができます。このとき、crc=0が一緒に必要になります。\n\n```\n# mkfs.xfs -m crc=0,finobt=0 /dev/target_partition\n```\n\nまたは（finobt は crc に依存するため）\n\n```\n# mkfs.xfs -m crc=0 /dev/target_partition\n```\n\n"
    },
    {
      "title": "Reverse mapping btree",
      "level": 3,
      "content": "Reverse mapping btree は、そのコアで、ストレージスペース使用量のセカンダリインデックスであり、プライマリスペース使用量メタデータの冗長コピーを効果的に提供します。これにより、ファイルシステム操作にいくらかのオーバーヘッドが追加されますが、ファイルシステムに含まれるため、相互参照が非常に高速になります。破損したプライマリメタデータをセカンダリコピーから再構築できるため、オンラインでファイルシステムを修復するために不可欠な機能です [5]\n\nReverse mapping btree は、その核心において次のようなものです:\n\nmkfs.xfs(8) § OPTIONS より:\n\n詳しくは、以下のリンクも参照してください [6] [7]\n\nこの機能は、xfsprogs 6.5.0 以降、新しく作成されるファイルシステムでデフォルトで有効になっています。\n\n"
    },
    {
      "title": "タイムスタンプ",
      "level": 3,
      "content": "Linux 5.10 以降、XFS は、リファクタリングされたタイムスタンプおよび inode encoding 関数を使用して、タイムスタンプを 64ビットナノ秒カウンターとして処理し、ビットシフトして有効サイズを増やすことをサポートしています。これにより、XFS は 2038年問題 を回避して 2486 年まで実行できるようになります。bigtime が有効になると、タイムスタンプの範囲を 1901年12月 から 2038年1月 ではなく、1901年12月 から 2486年7月 にすることができます。 この機能は、クォータタイマーの有効期限を 1970年1月から 2106年2月 ではなく、1970年1月 から 2486年 にすることもできます。\n\nxfsprogs 5.15 以降、新しいファイルシステムではデフォルトでタイムスタンプが有効になっています。\n\n"
    },
    {
      "title": "アップグレード",
      "level": 4,
      "content": "xfs_info(8) を使用して、既存のファイルシステムで bigtime が有効になっているかどうかを確認します。\n\n```\n# xfs_info / | grep bigtime\n... bigtime=0 ...\n```\n\nxfsprogs で、5.11 以降では、既存の (マウントされていない) ファイルシステムを xfs_admin(8) でアップグレードすることができます:\n\n```\n# xfs_admin -O bigtime=1 device\n```\n\nまたは xfs_repair(8):\n\n```\n# xfs_repair -c bigtime=1 device\n```\n\nついでに inobtcount も有効にしておくとよいでしょう (これも新しいデフォルトです)\n\n"
    },
    {
      "title": "パフォーマンス",
      "level": 2,
      "content": "XFS FAQ より:\n\n既に使用されているデフォルト値は、そもそも最高のパフォーマンスを 得られるように最適化されています。mkfs.xfs は、シングルディスクと MD/DM RAID セットアップの違いを検出し、 ファイルシステムを適切に構成するために使用するデフォルト値を変更することができ ます。\n\nほとんどの場合、mkfs.xfs で考慮する必要があるのは、ハードウェア RAID デバイスのストライプユニットと幅を指定することだけです。(参照 XFS#ストライプサイズと幅)\n\n- https://www.beegfs.io/wiki/StorageServerTuning\n- https://help.marklogic.com/Knowledgebase/Article/View/505/0/recommended-xfs-settings-for-marklogic-server\n\nマウントオプションについては、メタデータのパフォーマンスを大きく変えるのは、logbsize マウントオプションだけです。logbsize を増やすと、与えられたワークロードのジャーナル IO 数が減ります。このメタデータ性能の向上と引き換えに、アクティブに修正を行っている間にシステムがクラッシュした場合、リカバリ後に 見つからない 操作が増える可能性があります。\n\nカーネル3.2.12 の時点で、デフォルトの I/O スケジューラーである CFQ は、XFS の並列化の多くを無効にします。\n\nしたがって、最適なパフォーマンスを得るには、ほとんどの場合、設定 に従うだけです。\n\n"
    },
    {
      "title": "ストライプサイズと幅",
      "level": 3,
      "content": "ファイルシステムをストライプする RAID 上に作成する場合は mkfs.xfs コマンドでストライプサイズを指定することで著しい速度の向上が望めます。\n\nHow to calculate the correct sunit,swidth values for optimal performance を見て下さい。\n\n"
    },
    {
      "title": "バリアの無効化",
      "level": 3,
      "content": "/etc/fstab ファイルに nobarrier マウントオプションを追加してファイルシステムのバリアの使用を無効化することでパフォーマンスを上げることができます。\n\n"
    },
    {
      "title": "アクセス日時",
      "level": 3,
      "content": "/etc/fstab ファイルに noatime マウントオプションを追加することでファイルシステムのパフォーマンスが向上することがあります。XFS ファイルシステムではデフォルトの atime の扱い方は relatime になっており、noatime と比べてオーバーヘッドをかなり減らしつつも atime の値を正常に保ちます。現在 Linux の全てのファイルシステムが (2.6.30 あたりから) デフォルトで relatime を使うようになっていますが、XFS が relatime を使うようになったのは2006年からです。そのため、パフォーマンスを理由に XFS で noatime を使う必要はほとんどありません。\n\nまた、noatime には nodiratime が含まれているため、noatime を指定したら nodiratime を指定する必要はなくなります。\n\n"
    },
    {
      "title": "デフラグ",
      "level": 3,
      "content": "XFS はエクステントベースであり遅延アロケーションを利用しているため断片化の問題はなかなか発生しないようになっていますが、マウントされたアクティブな XFS ファイルシステム上のファイルをデフラグできる、ファイルシステムデフラグユーティリティ (xfs_fsr, XFS filesystem reorganizer の略) が用意されています。定期的に XFS の断片化を監視するのにも使えます。\n\nxfs_fsr(8) はマウントされたファイルシステムの編成を改善します。再編成アルゴリズムによって一度に一つのファイルが操作され、コンパクトになる、つまりファイルのエクステント (ファイルデータの連続ブロック) のレイアウトが改善されます。\n\n"
    },
    {
      "title": "フラグメンテーションレベルの確認",
      "level": 4,
      "content": "ファイルシステムにどれくらい断片化が発生しているのか確認するには:\n\n```\n# xfs_db -c frag -r /dev/sda3\n```\n\n"
    },
    {
      "title": "デフラグの実行",
      "level": 4,
      "content": "デフラグを開始するには、xfsprogs パッケージに含まれている xfs_fsr コマンドを使います:\n\n```\n# xfs_fsr /dev/sda3\n```\n\n"
    },
    {
      "title": "重複排除",
      "level": 3,
      "content": "reflink 機能はカーネルバージョン 4.9 から利用可能で、バージョン 5.1.0 からはデフォルトで有効になっており、btrfs と同じようにファイルの高速 reflink コピーと事後重複排除が可能です。\n\n既存のファイルシステムは、duperemove などのツールを使用して重複排除できます。\n\n"
    },
    {
      "title": "Reflink コピー",
      "level": 4,
      "content": "Reflink コピーは、最初は追加のスペースを使用しません:\n\n```\n$ cp --reflink bigfile1 bigfile2\n```\n\nいずれかのファイルが編集され、コピーオンライトが実行されるまで。これは、(大きな)ファイルのスナップショットを作成するのに非常に役立ちます。\n\n"
    },
    {
      "title": "重複排除",
      "level": 4,
      "content": "既存のファイルシステムは、duperemove などのツールを使用して重複排除できます。\n\n"
    },
    {
      "title": "外部XFSジャーナル",
      "level": 3,
      "content": "たとえば、SSD で外部ログ(メタデータジャーナル)を使用すると、パフォーマンスを向上させるのに役立つ場合があります main.html#extjnl-xfs logdev パラメータの詳細については、mkfs.xfs(8) を参照してください。\n\nXFS ファイルシステムを作成する際に、指定したサイズの外部ジャーナルを予約するには、 -l logdev=device,size=size オプションを mkfs.xfs コマンドに指定します。size パラメータを省略した場合、ファイルシステムのサイズに基づいたジャーナルサイズが使用されます。外部ジャーナルを使用するように XFS ファイルシステムをマウントするには、 マウント コマンドに -o logdev=device オプションを指定します。\n\n"
    },
    {
      "title": "同期間隔",
      "level": 3,
      "content": "XFS には専用の sysctl 変数があり、書き込み間隔とバッファサイズ をデフォルト値 3000 で設定することができます。\n\n```\n/etc/sysctl.d/20-xfs-sync-interval.conf\n```\n\n```\nfs.xfs.xfssyncd_centisecs = 10000\n```\n\n"
    },
    {
      "title": "リサイズ",
      "level": 3,
      "content": "XFS は、xfs_growfs(8) を使用してオンラインでサイズ変更できます:\n\n```\n# xfs_growfs -D size /path/to/mnt/point\n```\n\n-D size を省略した場合、ファイルシステムは可能な限り最大のサイズ、つまりパーティションのサイズまで自動的に拡張されます。\n\n"
    },
    {
      "title": "オンラインメタデータチェック (スクラブ)",
      "level": 3,
      "content": "xfs_scrub はカーネルに XFS ファイルシステム内の全てのメタデータオブジェクトをスクラブするように要求します。メタデータレコードは明らかに悪い値をスキャンされ、他のメタデータと相互参照されます。その目的は、ファイルシステム内の他のメタデータに対する個々のメタデータレコードの一貫性を調べることで、ファイルシステム全体の一貫性に対する妥当な信頼性を確立することです。破損したメタデータは、無傷の冗長なデータ構造が存在すれば、他のメタデータから再構築することができる。\n\nxfs_scrub_all.timer を 有効化/起動 します、すべての XFS ファイルシステムのオンライン メタデータを定期的にチェックします。\n\n"
    },
    {
      "title": "リペア",
      "level": 3,
      "content": "Checking and Repairing an XFS File System から:\n\nXFS ファイルシステムをマウントできない場合、xfs_repair -n コマンドを使用してその整合性をチェックすることができます。通常、このコマンドは問題があると思われるアンマウントされたファイルシステムのデバイスファイルに対してのみ実行します。xfs_repair -n コマンドは repair 操作を完了する必要がある場合にファイルシステムに加えられるであろう変更を示す出力を表示しますが、ファイルシステムを直接変更することはありません。\n\nファイルシステムをマウントすることができ、適切なバックアップがない場合、xfsdump を使って既存のファイルシステムのデータのバックアップを試みることができます。\n\nxfs_repair コマンドを使用すると、デバイスファイルで指定された XFS ファイルシステムの修復を試みることができます。このコマンドはジャーナル・ログを再生し、ファイル・システムがきれいにアンマウントされなかったために生じたかもしれないあらゆる不整合を修正します。ファイルシステムに不整合がない限り、XFS ファイルシステムをマウントするたびにジャーナルが再生されるため、通常このコマンドを使用する必要はありません。\n\nまず、ファイルシステムを アンマウント してから、xfs_repair(8) ツールを実行します。\n\n```\n# xfs_repair device\n```\n\nジャーナルログが破損している場合、xfs_repair に -L オプションを指定することでログをリセットすることができます。\n\nファイルシステムをマウントできない場合、または適切なバックアップがない場合は、xfs_db の使用経験がない限り、xfs_repair を実行することが唯一の実行可能なオプションです。\n\nxfs_db は、XFS ファイルシステムを手動でデバッグおよび修復できるようにする内部コマンドセットを提供します。これらのコマンドを使用すると、ファイルシステムでスキャンを実行したり、そのデータ構造をナビゲートして表示したりできます。 -x オプションを指定してエキスパートモードを有効にすると、データ構造を変更できます。\n\n```\n# xfs_db [-x] device\n```\n\n詳しくは、xfs_db(8)とxfs_repair(8)、および xfs_db 内の help コマンドを参照してください。\n\n参照 Which factors influence the memory usage of xfs_repair? と XFS Repair\n\n"
    },
    {
      "title": "データレスキュー",
      "level": 3,
      "content": "mount -o ro で読み取り専用にマウントしても、XFS ファイルシステムがきれいにアンマウントされていなければ、ログは再生されます。\n\n破損したストレージデバイス上の破損した XFS ファイルシステムは、 うまくいけばこれ以上破損させずにファイルをコピーできるように、 読み込み専用でマウントされるべきですが、きれいにアンマウントされず、 ログが再生できないほど破損しているのでマウントできない、という状況がありえます。 また、ログを再生することは、破損したファイルシステムに書き込むことを意味し、それ自体が悪い考えかもしれないことを考慮に入れてください。\n\nXFS ファイルシステムに書き込まず、ログを再生せずにマウントするには、 mount -o ro,norecovery を使ってください。\n\n"
    },
    {
      "title": "Undelete",
      "level": 3,
      "content": "xfs_undeleteAUR は、アンマウントされた、または読み込み専用にマウントされた XFS ファイルシステム上の削除されたファイルを（特定の条件下で）復元することができます。 詳しくは https://github.com/ianka/xfs_undelete を見て下さい。\n\n"
    },
    {
      "title": "ルートファイルシステムクォータ",
      "level": 3,
      "content": "XFS クォータマウントオプション (uquota, gquota, prjquota, etc) はファイルシステムの再マウントの際に失敗します。ルートファイルシステムでクォータを有効にするには、マウントオプションは initramfs に カーネルパラメータ として渡されなければなりません。rootflags= です。その後、ルート (/etc/fstab) ファイルシステムのマウントオプションの中にリストされてはいけません。\n\n"
    },
    {
      "title": "ユーザー nobody がマウントポイントにアクセスできない場合、xfs_scrub_all が失敗する",
      "level": 3,
      "content": "xfs_scrub_all を実行すると、マウントされた各 XFS ファイルシステムに対して xfs_scrub@.service が起動します。このサービスはユーザ nobody として実行されるので、nobody がディレクトリに移動できない場合、エラーで失敗します。\n\n```\nxfs_scrub@mountpoint.service: Changing to the requested working directory failed: Permission denied\nxfs_scrub@mountpoint.service: Failed at step CHDIR spawning /usr/bin/xfs_scrub: Permission denied\nxfs_scrub@mountpoint.service: Main process exited, code=exited, status=200/CHDIR\n```\n\nサービスの実行を許可するには、ユーザー nobody に実行権限があるようにマウントポイントの パーミッション を変更します。\n\n"
    },
    {
      "title": "fsck.xfs が systemd ベースの initramfs で失敗する",
      "level": 3,
      "content": "mkinitcpio で生成された systemd ベースの initramfs を base フックなしで使用すると、journal に次のメッセージが表示されます。\n\n```\nsystemd-fsck[288]: fsck: /usr/bin/fsck.xfs: execute failed: No such file or directory\nsystemd-fsck[286]: fsck failed with exit status 8.\nsystemd-fsck[286]: Ignoring error.\n```\n\nこれは、fsck.xfs(8) がシェルスクリプトであり、実行に /bin/sh が必要なためです。/usr/bin/sh は base フックによって提供されるため、解決策は /etc/mkinitcpio.conf の HOOKS 配列に追加することです。例えば:\n\n```\nHOOKS=(base systemd ... )\n```\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- XFS wiki\n- XFS FAQ\n- Improving Metadata Performance By Reducing Journal Overhead\n- wikipedia:ja:XFS\n- XFS User Guide XFS ユーザーガイドはもう存在しませんが、git リポジトリへのリンクがあります\n\n"
    }
  ]
}