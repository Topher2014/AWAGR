{
  "title": "Nomeação persistente de dispositivo de bloco",
  "url": "https://wiki.archlinux.org/title/Nomea%C3%A7%C3%A3o_persistente_de_dispositivo_de_bloco",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- fstab\n- udev\n- LVM\n\nEste artigo descreve como usar nomes persistentes para seus dispositivos de bloco. Isso foi possível com a introdução do udev e tem algumas vantagens sobre a nomeação baseada em barramento. Se sua máquina tiver mais de um controlador de disco SATA, SCSI ou IDE, a ordem na qual os nós de dispositivos correspondentes são adicionados é arbitrária. Isso pode resultar em nomes de dispositivos como /dev/sda e /dev/sdb alternando em cada inicialização, culminando em uma inicialização não-inicializável sistema, pânico do kernel ou um dispositivo de bloco desaparecendo. A nomeação persistente resolve esses problemas.\n\n- A nomeação persistente possui limites que estão fora do escopo neste artigo. Por exemplo, enquanto mkinitcpio pode ter suporte a um método, o systemd pode impor seus próprios limites (por exemplo, FS#42884) na nomeação de nomes que ele pode processar durante a inicialização.\n- Esse artigo não é relevante para volumes lógicos de LVM, pois os caminhos de dispositivo /dev/NomeGrupoVolume/NomeVolumeLógico são persistentes.\n\n"
    },
    {
      "title": "Métodos de nomeação persistente",
      "level": 2,
      "content": "Há quatro esquemas diferentes para nomeação persistente: by-label, by-uuid, by-id e by-path. Para os que usam discos com Tabela de Partição GUID (GPT), dois esquemas adicionais podem ser usados: by-partlabel e by-partuuid. Você também pode usar nomes estáticos de dispositivos com udev.\n\nOs diretórios em /dev/disk/ são criados e destruídos dinamicamente, dependendo se há dispositivos neles ou não.\n\nAs seções a seguir descrevem quais são os diferentes métodos de nomenclatura persistente e como são usados.\n\nO comando lsblk pode ser usado para visualizar graficamente os primeiros esquemas persistentes:\n\n```\n$ lsblk -f\n```\n\n```\nNAME        FSTYPE LABEL      UUID                                 MOUNTPOINT\nsda                                                       \n├─sda1      vfat              CBB6-24F2                            /boot\n├─sda2      ext4   Arch Linux 0a3407de-014b-458b-b5c1-848e92a327a3 /\n├─sda3      ext4   Data       b411dc99-f0a0-4c87-9e05-184977be8539 /home\n└─sda4      swap              f9fe0b69-a280-415d-a03a-a32752370dee [SWAP]\nmmcblk0\n└─mmcblk0p1 vfat              F4CA-5D75\n```\n\nPara aqueles que usam GPT, use o comando blkid. Este comando é mais conveniente para scripts, mas mais difícil de ler.\n\n```\n# blkid\n```\n\n```\n/dev/sda1: UUID=\"CBB6-24F2\" TYPE=\"vfat\" PARTLABEL=\"EFI system partition\" PARTUUID=\"d0d0d110-0a71-4ed6-936a-304969ea36af\" \n/dev/sda2: LABEL=\"Arch Linux\" UUID=\"0a3407de-014b-458b-b5c1-848e92a327a3\" TYPE=\"ext4\" PARTLABEL=\"GNU/Linux\" PARTUUID=\"98a81274-10f7-40db-872a-03df048df366\" \n/dev/sda3: LABEL=\"Data\" UUID=\"b411dc99-f0a0-4c87-9e05-184977be8539\" TYPE=\"ext4\" PARTLABEL=\"Home\" PARTUUID=\"7280201c-fc5d-40f2-a9b2-466611d3d49e\" \n/dev/sda4: UUID=\"f9fe0b69-a280-415d-a03a-a32752370dee\" TYPE=\"swap\" PARTLABEL=\"Swap\" PARTUUID=\"039b6c1c-7553-4455-9537-1befbc9fbc5b\"\n/dev/mmcblk0: PTUUID=\"0003e1e5\" PTTYPE=\"dos\"\n/dev/mmcblk0p1: UUID=\"F4CA-5D75\" TYPE=\"vfat\" PARTUUID=\"0003e1e5-01\"\n```\n\n"
    },
    {
      "title": "by-label",
      "level": 3,
      "content": "Quase todo tipo de sistema de arquivos pode ter um rótulo (\"label\", em inglês). Todos os seus volumes que têm um são listados no diretório /dev/disk/by-label.\n\n```\n$ ls -l /dev/disk/by-label\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 Data -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 Arch\\x20Linux -> ../../sda2\n```\n\nA maioria dos sistemas de arquivos possui suporte à configuração do rótulo na criação do sistema de arquivos, consulte a página man do utilitário relevante mkfs.*. Para alguns sistemas de arquivos, também é possível alterar os rótulos. A seguir, são apresentados alguns métodos para alterar rótulos em sistemas de arquivos comuns:\n\nO rótulo de um dispositivo pode ser obtido com lsblk:\n\n```\n$ lsblk -dno LABEL /dev/sda2\n```\n\n```\nArch Linux\n```\n\nOu com blkid:\n\n```\n# blkid -s LABEL -o value /dev/sda2\n```\n\n```\nArch Linux\n```\n\n- O sistema de arquivos não deve ser montado para alterar seu rótulo. Para o sistema de arquivos raiz, isso pode ser feito inicializando a partir de outro volume.\n- Os rótulos devem ser inequívocos para evitar possíveis conflitos.\n- As rótulos podem ter até 16 caracteres.\n- Como o rótulo é uma propriedade do sistema de arquivos, não é adequado para endereçar persistentemente um único dispositivo RAID.\n- Ao usar contêineres criptografados com dm-crypt, os rótulos dos sistemas de arquivos dentro dos contêineres não estarão disponíveis enquanto o contêiner estiver bloqueado/criptografado.\n\n"
    },
    {
      "title": "by-uuid",
      "level": 3,
      "content": "UUID é um mecanismo para fornecer a cada sistema de arquivos um identificador exclusivo. Esses identificadores são gerados pelos utilitários do sistema de arquivos (por exemplo, mkfs.*) quando o dispositivo é formatado e projetado para que as colisões sejam improváveis. Todos os sistemas de arquivos GNU/Linux (incluindo cabeçalhos swap e LUKS de dispositivos criptografados não processados) possuem suporte a UUID. Os sistemas de arquivos FAT, exFAT e NTFS não suportam UUID, mas ainda estão listados em /dev/disk/by-uuid/ com um UID mais curto (identificador exclusivo):\n\n```\n$ ls -l /dev/disk/by-uuid/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 0a3407de-014b-458b-b5c1-848e92a327a3 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 b411dc99-f0a0-4c87-9e05-184977be8539 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 CBB6-24F2 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 f9fe0b69-a280-415d-a03a-a32752370dee -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 F4CA-5D75 -> ../../mmcblk0p1\n```\n\nO UUID de um dispositivo pode ser obtido com lsblk:\n\n```\n$ lsblk -dno UUID /dev/sda1\n```\n\n```\nCBB6-24F2\n```\n\nOu com blkid:\n\n```\n# blkid -s UUID -o value /dev/sda1\n```\n\n```\nCBB6-24F2\n```\n\nA vantagem de usar o método UUID é que é muito menos provável que ocorram colisões de nomes do que com rótulos. Além disso, é gerado automaticamente na criação do sistema de arquivos. Por exemplo, ele permanecerá único, mesmo que o dispositivo esteja conectado a outro sistema (que talvez tenha um dispositivo com a mesma etiqueta).\n\nA desvantagem é que os UUIDs dificultam a leitura e quebram as linhas de código em muitos arquivos de configuração (por exemplo, fstab ou crypttab). Além disso, toda vez que um volume é reformatado, um novo UUID é gerado e os arquivos de configuração precisam ser ajustados manualmente.\n\n"
    },
    {
      "title": "by-id e by-path",
      "level": 3,
      "content": "by-id cria um nome exclusivo, dependendo do número de série do hardware, e by-path, dependendo do caminho físico mais curto (de acordo com o sysfs). Ambos contêm strings para indicar a qual subsistema eles pertencem (por exemplo, pci- para by-path e ata- para by-id ), para que estejam vinculados ao hardware que controla o dispositivo. Isso implica em diferentes níveis de persistência: o by-path já será alterado quando o dispositivo estiver conectado a uma porta diferente do controlador, o by-id será alterado quando o dispositivo estiver conectado em uma porta de um controlador de hardware sujeito a outro subsistema. [1] Portanto, ambos não são adequados para obter nomes persistentes e tolerantes a alterações de hardware.\n\nNo entanto, ambos fornecem informações importantes para encontrar um dispositivo específico em uma grande infraestrutura de hardware. Por exemplo, se você não atribuir manualmente rótulos persistentes (by-label ou by-partlabel) e manter um diretório com uso de porta de hardware, by-id e by-path podem ser usados para encontrar um dispositivo específico.[2] [3]\n\nO by-id também cria links World Wide Name de dispositivos de armazenamento que possuem suporte a ele. Diferente de outros links by-id, os WWNs são totalmente persistentes e não serão alterados dependendo do subsistema usado.\n\n```\n$ ls -l /dev/disk/by-id/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470 -> ../../sda\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part1 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part2 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part3 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part4 -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 mmc-SD32G_0x0040006d -> ../../mmcblk0\nlrwxrwxrwx 1 root root 10 May 27 23:31 mmc-SD32G_0x0040006d-part1 -> ../../mmcblk0p1\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f -> ../../sda\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part1 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part2 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part3 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part4 -> ../../sda4\n```\n\n```\n$ ls -l /dev/disk/by-path/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1 -> ../../sda\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part1 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part2 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part3 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part4 -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:07:00.0-platform-rtsx_pci_sdmmc.0 -> ../../mmcblk0\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:07:00.0-platform-rtsx_pci_sdmmc.0-part1 -> ../../mmcblk0p1\n```\n\n"
    },
    {
      "title": "by-partlabel",
      "level": 3,
      "content": "Os rótulos de partição GPT podem ser definidos no cabeçalho da entrada de partição nos discos GPT.\n\nEsse método é muito semelhante aos rótulos de sistema de arquivos, exceto que os rótulos da partição não serão afetados se o sistema de arquivos na partição for alterado.\n\nTodas as partições que possuem rótulos de partição estão listadas no diretório /dev/disk/by-partlabel.\n\n```\nls -l /dev/disk/by-partlabel/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 EFI\\x20system\\x20partition -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 GNU\\x2fLinux -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 Home -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 Swap -> ../../sda4\n```\n\nO rótulo da partição de um dispositivo pode ser obtido com lsblk:\n\n```\n$ lsblk -dno PARTLABEL /dev/sda1\n```\n\n```\nEFI system partition\n```\n\nOu com blkid:\n\n```\n# blkid -s PARTLABEL -o value /dev/sda1\n```\n\n```\nEFI system partition\n```\n\n- Os rótulos das partições GPT também precisam ser diferentes para evitar conflitos. Para alterar o rótulo da sua partição, você pode usar gdisk ou a versão baseada em ncurses cgdisk. Ambos estão disponíveis no pacote gptfdisk. Veja Particionamento#Ferramentas de particionamento.\n- De acordo com a especificação, os rótulos das partições GPT podem ter até 72 caracteres.\n\n"
    },
    {
      "title": "by-partuuid",
      "level": 3,
      "content": "Da mesma forma que rótulos de partição GPT, os UUIDs da partição GPT são definidos em entrada de partição nos discos GPT.\n\nO MBR não possui suporte a UUIDs de partição, mas o Linux[4] e softwares usando libblkid[5] (por exemplo, udev[6]) são capazes de gerar pseudo-PARTUUIDs para partições MBR. O formato é SSSSSSSS-PP, sendo SSSSSSSS uma assinatura de disco MBR de 32 bits preenchida com zeros e PP é um número de partição preenchido com zeros em formato hexadecimal. Ao contrário do PARTUUID regular de uma partição GPT, o pseudo-PARTUUID do MBR pode mudar se o número da partição for alterado.\n\nO diretório dinâmico é semelhante a outros métodos e, como UUIDs de sistema de arquivos, o uso de UUIDs é preferível aos rótulos.\n\n```\nls -l /dev/disk/by-partuuid/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 0003e1e5-01 -> ../../mmcblk0p1\nlrwxrwxrwx 1 root root 10 May 27 23:31 039b6c1c-7553-4455-9537-1befbc9fbc5b -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 7280201c-fc5d-40f2-a9b2-466611d3d49e -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 98a81274-10f7-40db-872a-03df048df366 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 d0d0d110-0a71-4ed6-936a-304969ea36af -> ../../sda1\n```\n\nO UUID da partição de um dispositivo pode ser obtido com lsblk:\n\n```\n$ lsblk -dno PARTUUID /dev/sda1\n```\n\n```\nd0d0d110-0a71-4ed6-936a-304969ea36af\n```\n\nOu com blkid:\n\n```\n# blkid -s PARTUUID -o value /dev/sda1\n```\n\n```\nd0d0d110-0a71-4ed6-936a-304969ea36af\n```\n\n"
    },
    {
      "title": "Nomes estáticos de dispositivos com udev",
      "level": 3,
      "content": "Veja udev#Setting static device names.\n\n"
    },
    {
      "title": "Usando nomeação persistente",
      "level": 2,
      "content": "Há vários aplicativos que podem ser configurados usando nomes persistentes. A seguir, alguns exemplos de como configurá-los.\n\n"
    },
    {
      "title": "fstab",
      "level": 3,
      "content": "Veja o artigo principal: fstab#Identificando sistemas de arquivos.\n\n"
    },
    {
      "title": "Parâmetros de kernel",
      "level": 3,
      "content": "Para usar nomes persistentes em parâmetros do kernel, os seguintes pré-requisitos devem ser atendidos. Em uma instalação padrão, seguindo o guia de instalação, os dois pré-requisitos são atendidos:\n\n- Você esteja usando uma imagem initramfs que tem udev nele. Para mkinitcpio, habilite o hook do udev ou do systemd no /etc/mkinitcpio.conf\n\n- Para mkinitcpio, habilite o hook do udev ou do systemd no /etc/mkinitcpio.conf\n\nO local do sistema de arquivos raiz é fornecido pelo parâmetro root na linha de comando do kernel. A linha de comando do kernel é configurada a partir do gerenciador de boot, consulte Parâmetros do kernel#Configuração. Para alterar para nomeação persistente de dispositivo, altere apenas os parâmetros que especificam dispositivos de bloco, por exemplo root e resume, deixando outros parâmetros como estão. Há suporte a vários esquemas de nomeação:\n\nNomeação persistente de dispositivo usando o rótulo e o formato LABEL=; neste exemplo, Arch Linux é o LABEL do sistema de arquivos raiz.\n\n```\nroot=\"LABEL=Arch Linux\"\n```\n\nA nomeação persistente de dispositivo usando o UUID e o formato UUID=; neste exemplo 0a3407de-014b-458b-b5c1-848e92a327a3, é o UUID de o sistema de arquivos raiz.\n\n```\nroot=UUID=0a3407de-014b-458b-b5c1-848e92a327a3\n```\n\nNomeação persistente de dispositivo usando o ID do disco e o formato do caminho /dev; neste exemplo wwn-0x60015ee0000b237f-part2 é o ID da partição raiz.\n\n```\nroot=/dev/disk/by-id/wwn-0x60015ee0000b237f-part2\n```\n\nA nomeação persistente de dispositivo usando o UUID da partição GPT e o formato PARTUUID=; neste exemplo 98a81274-10f7-40db-872a-03df048df366, é o PARTUUID da partição raiz.\n\n```\nroot=PARTUUID=98a81274-10f7-40db-872a-03df048df366\n```\n\nNomeação persistente de dispositivo usando o rótulo da partição GPT e o formato PARTLABEL=; neste exemplo GNU/Linux é o PARTLABEL da partição raiz.\n\n```\nroot=\"PARTLABEL=GNU/Linux\"\n```\n\n"
    }
  ]
}