{
  "title": "Disk encryption (日本語)",
  "url": "https://wiki.archlinux.org/title/Disk_encryption_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- dm-crypt\n- TrueCrypt\n- eCryptfs\n- EncFS\n- gocryptfs\n- fscrypt\n- Tomb\n- tcplay\n- GnuPG\n- 自己暗号化ドライブ\n\nこの記事では、ブロックデバイスやディスクパーティション、ディレクトリに書き込んだり読み込んだりするデータをその場で暗号化/復号化する、保存データ 暗号化ソフトウェアについて説明します。ブロックデバイスの例としては、ハードディスク、フラッシュドライブ、DVDなどがあります。\n\n保存データの暗号化は、あくまでもオペレーティングシステムの既存のセキュリティ機構を補助するものと考えるべきで、物理的なアクセスの保護に焦点を当て、ネットワークセキュリティやユーザーベースのアクセスコントロールなどは、システムの他の部分に依存することになります。\n\nフルディスク暗号化 (FDE) については、dm-crypt/システム全体の暗号化を参照してください。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 なぜ暗号化を使うのか? 1.1 システムデータ暗号化\n- 2 利用可能な手段 2.1 スタックファイルシステムの暗号化 2.1.1 クラウドストレージの最適化 2.2 ブロックデバイスの暗号化 2.3 ブロックデバイスとスタックファイルシステムの暗号化 2.4 比較表 2.4.1 概要 2.4.2 基本的な分類 2.4.3 実用性 2.4.4 ユーザビリティ 2.4.5 セキュリティ 2.4.6 パフォーマンス 2.4.7 ブロックデバイス暗号化特有の事項 2.4.8 スタックファイルシステム暗号化特有の事項 2.4.9 互換性と普及度\n- 3 準備 3.1 セットアップの選択 3.2 強固なパスフレーズの選択 3.3 ディスクの準備\n- 4 暗号化の仕組み 4.1 基本原理 4.2 鍵とキーファイルとパスフレーズ 4.3 暗号メタデータ 4.4 暗号と利用モード 4.5 もっともらしい否認\n- 5 ディスク暗号化シナリオのバックアップ 5.1 ブロックデバイスの暗号化 5.1.1 ディスクブロックデバイスのバックアップ 5.1.2 ファイルシステムまたはファイルのバックアップ 5.1.3 LUKS ヘッダーバックアップ\n- 6 参照\n\n- 1.1 システムデータ暗号化\n\n- 2.1 スタックファイルシステムの暗号化 2.1.1 クラウドストレージの最適化\n- 2.2 ブロックデバイスの暗号化\n- 2.3 ブロックデバイスとスタックファイルシステムの暗号化\n- 2.4 比較表 2.4.1 概要 2.4.2 基本的な分類 2.4.3 実用性 2.4.4 ユーザビリティ 2.4.5 セキュリティ 2.4.6 パフォーマンス 2.4.7 ブロックデバイス暗号化特有の事項 2.4.8 スタックファイルシステム暗号化特有の事項 2.4.9 互換性と普及度\n\n- 2.1.1 クラウドストレージの最適化\n\n- 2.4.1 概要\n- 2.4.2 基本的な分類\n- 2.4.3 実用性\n- 2.4.4 ユーザビリティ\n- 2.4.5 セキュリティ\n- 2.4.6 パフォーマンス\n- 2.4.7 ブロックデバイス暗号化特有の事項\n- 2.4.8 スタックファイルシステム暗号化特有の事項\n- 2.4.9 互換性と普及度\n\n- 3.1 セットアップの選択\n- 3.2 強固なパスフレーズの選択\n- 3.3 ディスクの準備\n\n- 4.1 基本原理\n- 4.2 鍵とキーファイルとパスフレーズ\n- 4.3 暗号メタデータ\n- 4.4 暗号と利用モード\n- 4.5 もっともらしい否認\n\n- 5.1 ブロックデバイスの暗号化 5.1.1 ディスクブロックデバイスのバックアップ 5.1.2 ファイルシステムまたはファイルのバックアップ 5.1.3 LUKS ヘッダーバックアップ\n\n- 5.1.1 ディスクブロックデバイスのバックアップ\n- 5.1.2 ファイルシステムまたはファイルのバックアップ\n- 5.1.3 LUKS ヘッダーバックアップ\n\n"
    },
    {
      "title": "なぜ暗号化を使うのか?",
      "level": 2,
      "content": "ディスク暗号化は確実にファイルを常に暗号化された状態でディスクに保存することができます。ファイルにアクセスできるのは、システムが動いていて信頼されたユーザーによってロックを解除された間だけで、その場合にのみオペレーティングシステムやアプリケーションは読み取れる状態でファイルにアクセスすることができるようになります。権限のないユーザーが直接ディスクの中身を見たとしても、わかるのは意味がわからないランダムなデータだけで、実際のファイルを読み取ることは不可能です。\n\nディスク暗号化によって、例えば、コンピュータやハードディスクが以下の状態にあるときにデータを勝手に見られることを防げます:\n\n- あなたの離席中に、他の信頼されない人々がアクセスすることができる場所に置かれている場合。\n- ノートパソコンやネットブック、または外付けのストレージデバイスなどのように紛失したり盗まれた場合。\n- 修理に出している間。\n- 寿命が尽きて廃棄した時。\n\nさらに、ディスク暗号化を使うことで、オペレーティングシステムを改竄しようとする不正アクセスに対するセキュリティの強化にもなります。例えば、システムへの物理的なアクセスを手に入れた攻撃者によるキーロガーやトロイの木馬のインストールへの防衛手段になります。\n\nディスク暗号化によっても以下のような場合には対処できません:\n\n- システムが動いていて、あなたがロックを解除してディスクの暗号化している部分をマウントしてしまった後に (インターネットなどを介して) 攻撃者がシステムに侵入した場合。\n- コールドブートアタックに必要な手段を攻撃者が手に入れていて、(画面ロックを使っていたとしても) コンピュータが動作している、または動作していたすぐ後に攻撃者が物理的にアクセスできる場合。\n- 政府機関が、上記の攻撃を簡単に行える資力を持っているだけでなく、もっとシンプルに、様々な強制執行を使って無理矢理キーやパスフレーズを明かさせることができる場合。世界中の非民主的な国々、さらにアメリカやイギリスでも、何か興味深いものをあなたが隠していると法執行機関が疑いをかけた場合、法執行機関によってロックの解除を合法的に迫られる可能性があります。\n- 締め上げ暗号分析 XKCD #538 も参照してください。\n\nディスク暗号化をしたとしてもディスクの消去からは保護されません。データを安全に保つため定期的なバックアップを推奨します。\n\nあなたがシステムを使う前にシステムに細工を施すことができるプロの攻撃者にまともに対抗するには非常に強固なディスク暗号化が必要になります (例: 平文のブートパーティションがなく真正の確認があるフルシステム暗号化)。それでもあらゆるタイプの改竄を押しとどめることができるかというと疑問です (例: ハードウェアキーロガー) おそらくハードウェアベースの完全ディスク暗号化とトラステッドコンピューティングが最善策でしょう。\n\n"
    },
    {
      "title": "システムデータ暗号化",
      "level": 3,
      "content": "- スワップパーティション (救済策: スワップを無効にする、またはスワップも暗号化してしまう)\n- /tmp (ユーザーアプリケーションによって作成される一時ファイル) (救済策: そのようなアプリケーションを使うのをやめる、または /tmp を RAM ディスクにマウントする)\n- /var (ログファイルやデータベースなど。例えば mlocate は全てのファイル名のインデックスを /var/lib/mlocate/mlocate.db に保存します)\n\n- (救済策: スワップを無効にする、またはスワップも暗号化してしまう)\n\n- (救済策: そのようなアプリケーションを使うのをやめる、または /tmp を RAM ディスクにマウントする)\n\n"
    },
    {
      "title": "利用可能な手段",
      "level": 2,
      "content": "あらゆるディスク暗号化の手段というのは、ディスクは暗号化されたデータを保持しながら、暗号コンテナ (つまり暗号化されたデータを保持するディスクの論理部) が\"解除\"されてマウントされているときにかぎり、オペレーティングシステムやアプリケーションからは通常の読み込み可能なデータとして見えるようにするという方法で働きます。\n\n暗号化を使うには、ユーザーによって\"秘密情報\"が供給される必要があり (通常はキーファイルやパスフレーズの形で指定します)、それから実際の暗号化キーが生成されます (そしてセッションの間はカーネルのキーリングに保存されます)。\n\nこの種の仕組みが全くわからないという場合は、下の暗号化の仕組みセクションを読んで下さい。\n\n利用できるディスク暗号化の方法は、稼働するレイヤーによって2つのタイプに分けることができます:\n\n"
    },
    {
      "title": "スタックファイルシステムの暗号化",
      "level": 3,
      "content": "スタックファイルシステムによる暗号化ソリューションは既存のファイルシステム上に積み上げられるレイヤーとして実装され、暗号化が有効になったフォルダへ書き込まれた全てのファイルを、実際のファイルシステムがディスクに書き込む前に即座に暗号化します。そしてファイルシステムがディスクからファイルを読み込んだ時は復号化を行います。この方法では、ホストファイルシステムには暗号化された形でファイルが保存されますが (ファイルの中身や、ファイル名・フォルダ名も、同じ長さのランダムなデータで置き換えられます)、それ以外のファイルはファイルシステム上に通常のファイル/シンボリックリンク/ハードリンクとして暗号化されない形で存在します。\n\nホストファイルシステムにある暗号化されたファイルが保存されたフォルダをロック解除するため、(特殊なスタック擬似ファイルシステムを使って) それ自体または別の場所にマウントされ、同じファイルが読み込める形で現れます。アンマウントしたり、システムの電源が落とされるまでその状態は維持されます。\n\nスタックファイルシステム暗号化で利用できるソリューションには eCryptfs や EncFS があります。\n\n"
    },
    {
      "title": "クラウドストレージの最適化",
      "level": 4,
      "content": "クラウドストレージサービスなど、サードパーティが管理する場所とのゼロ知識同期を実現するためにスタックファイルシステムの暗号化を導入している場合は、eCryptfs や EncFS の代替手段を検討することをお勧めします。これらは、インターネットを介したファイルの送信用に最適化されていないためです。代わりに、この目的のために設計されたソリューションがいくつかあります。\n\n- gocryptfs\n- cryptomatorAUR もしくは cryptomator-binAUR (マルチプラットフォーム)\n- cryfs\n\n一部のクラウドストレージサービスは、独自のサービスを通じてゼロ知識暗号化を直接提供していることに注意してください。クライアントアプリケーション\n\n"
    },
    {
      "title": "ブロックデバイスの暗号化",
      "level": 3,
      "content": "一方、ブロックデバイス暗号化はファイルシステムレイヤーの下で動作して、特定のブロックデバイス (つまり、ディスクやパーティション全体、または仮想的なループバックデバイスとして振る舞うファイル) に書き込まれる全てのデータが暗号化されます。このため、ブロックデバイスがオフラインのときは、中身が全てランダムなデータの巨大なブロブのように見え、ファイルシステムやデータに何が含まれているのか判断できなくなります。データにまたアクセスするときは、保護されたコンテナ (この場合、ブロックデバイス) を特殊な方法で任意の場所にマウントします。\n\nArch Linux では\"ブロックデバイス暗号化\"として以下の方法が利用できます:\n\n- デフォルトで使用される LUKS は dm-crypt をセットアップするのに必要な情報を全てディスクに保存する便利なレイヤーで、使いやすさと暗号のセキュリティを増すためにパーティションとキー管理を抽象化します。\n- plain dm-crypt モードは、オリジナルのカーネルの機能であり、便利なレイヤーを使いません。レイヤーを使った時と同じ暗号強度を確保するのは難しくなります。そうしようとすると、結果的にキー (パスフレーズまたはキーファイル) が長くなってしまいます。しかしながら、下で説明しているように利点も存在します。\n\n選択するレイヤーの実用性については、下の比較表を見て下さい。eCryptfs についての記事も参照。\n\n"
    },
    {
      "title": "ブロックデバイスとスタックファイルシステムの暗号化",
      "level": 3,
      "content": "Table content:\n特徴 | デバイスの暗号化をブロックする | スタックされたファイルシステムの暗号化\n暗号化 | ブロック全体のデバイス | ファイル\n暗号化されたデータのコンテナは次の可能性があります... | ループデバイスとしてのディスクまたはディスクパーティション/ファイル | 既存のファイル システム内のディレクトリ\nファイルシステムとの関係 | ファイルシステム層の下で動作します。暗号化されたブロックデバイスの内容がファイルシステム、パーティションテーブル、LVM セットアップ、またはその他のものであるかどうかは関係ありません。 | 既存のファイルシステムに追加のレイヤーを追加し、ファイルの書き込み/読み取りのたびに自動的にファイルを暗号化/復号化します。\nファイルのメタデータ (ファイル数、ディレクトリ構造、ファイル サイズ、権限、mtimes など) は暗号化されます。 | Yes | No(ファイル名とディレクトリ名は暗号化できます)\nハードドライブ全体 (パーティションテーブルを含む) をカスタム暗号化するために使用できます。 | Yes | No\nスワップスペースの暗号化に使用可能 | Yes | No\n暗号化されたデータコンテナ用に固定量のスペースを事前に割り当てずに使用可能 | No | Yes\nNFS や Samba 共有、クラウドストレージなど、デバイスアクセスをブロックせずに既存のファイルシステムを保護するために使用できます。 | No | Yes\n暗号化されたファイルのファイルベースのオフラインバックアップが可能 | No | Yes\n\n"
    },
    {
      "title": "比較表",
      "level": 3,
      "content": "\"dm-crypt +/- LUKS\" のカラムは LUKS (\"+\") と plain (\"-\") 両方の暗号化モードにおける dm-crypt の機能を示しています。特定の機能が LUKS の使用を必要とする場合、そのことは \"(LUKS を使用)\" で表されます。同じように \"(LUKS を使用しない)\" はその機能を実現するのに LUKS の使用が逆効果であり、plain モードを使うべきことを示しています。\n\nTable content:\n概要 | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs\n | タイプ | ブロックデバイスの暗号化 | スタックファイルシステムの暗号化\n | 主なセールスポイント | 最古の手段であり、おそらく最速であり、レガシーなシステムでも動作します | Linux におけるブロックデバイス暗号化のデファクトスタンダードであり柔軟性があります | 携帯性が高く、洗練された、自己完結型の暗号化ソリューション | 活発に開発されている TrueCrypt のフォークで、デファクトスタンダードの代替 | EncFS よりも若干高速で、暗号化されたファイルは個別にシステム間で移動できます | 一番使うのが簡単で、root 以外による管理をサポートしています\n | Arch Linux における利用手段 | カスタムカーネルの手動コンパイルが必須 | カーネルモジュール: デフォルトのカーネルに含まれています; ツール: device-mapper, cryptsetup [core] | truecrypt [extra] (開発終了) または後方互換のある veracrypt [community] | veracrypt [community] | カーネルモジュール: デフォルトのカーネルに含まれています; ツール: ecryptfs-utils [community] | encfs [community]\n | ライセンス | GPL | GPL | TrueCrypt License 3.1[1] | Apache License 2.0, 一部はTrueCrypt License v3.0[1] | GPL | GPL\n | \n基本的な分類 | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs\n | 暗号化の対象 | ブロックデバイス全体 | ファイル\n | 暗号化されたデータのコンテナ | ディスクまたはディスクパーティション 仮想パーティションとして作用するファイル | 既存のファイルシステムのディレクトリ\n | ファイルシステムとの関係 | ファイルシステムレイヤーの下で動作し、暗号化されたブロックデバイスの中身がファイルシステム、パーティションテーブル、LVM のどれであるかには関しない | 既存のファイルシステムにレイヤーを追加して、ファイルが書き込まれたり読み込まれた時に自動的に暗号化または復号化を行う\n | 暗号化の実装空間 | カーネル空間 | ユーザー空間(FUSE を使用)\n | 暗号メタデータの保存場所 | ? | LUKS を使用: LUKS ヘッダー | (復号化された) デバイスの冒頭/最後 (フォーマット) | 暗号化されたファイルのヘッダー | EncFs コンテナのトップレベルにあるコントロールファイル\n | 暗号鍵の保存場所 | ? | LUKS を使用: LUKS ヘッダー | 何処にでも保存できるキーファイル\n | \n実用性 | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs\n | ファイルのメタデータ (ファイルの数, ディレクトリ構造, ファイルサイズ, パーミッション, 更新時刻など) の暗号化 | ✔ | ✖(ファイルやディレクトリの名前は暗号化できます)\n | (パーティションテーブルを含む) ハードドライブ全体の暗号化 | ✔ | ✖\n | スワップ領域の暗号化 | ✔ | ✖\n | あらかじめ特定のサイズのスペースを暗号化データコンテナに割り当てなくても使用できるか | ✖ | ✔\n | ブロックデバイスにアクセスできない既存のファイルシステム (NFS や Samba の共有、クラウドストレージなど) の保護に使用できるか | ✖[2] | ✔\n | 暗号化されたファイルのファイルベースのオフラインバックアップ | ✖ | ✔\n | \nユーザビリティ | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs\n | ログイン時の自動マウントのサポート | ? | ✔ | ✔ | ✔ | ✔ | ✔\n | アイドル状態による自動アンマウントのサポート | ? | ? | ? | ? | ? | ✔\n | root 以外のユーザーによる暗号化されたデータのコンテナの作成と破壊 | ✖ | ✖ | ✖ | ✖ | 制限あり | ✔\n | GUI | ✖ | ✖ | ✔ | ✔ | ✖ | ✔\n | \nセキュリティ | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs\n | サポートされている暗号 | AES | AES, Anubis, CAST5/6, Twofish, Serpent, Camellia, Blowfish, ... (カーネルの Crypto API が用意している全ての暗号) | AES, Twofish, Serpent | AES, Twofish, Serpernt, Camellia, Kuznyechik | AES, Blowfish, Twofish... | AES, Blowfish, Twofish, その他システムで使える暗号\n | ソルティングのサポート | ? | ✔(LUKS を使用) | ✔ | ✔ | ✔ | ?\n | 複数の暗号による多段処理のサポート | ? | 複数のブロックデバイスを段階的に暗号化することは可能 | ✔ | ✔ | ? | ✖\n | キースロットの拡散のサポート | ? | ✔(LUKS を使用) | ? | ? | ? | ?\n | キースクラブに対する保護 | ✔ | ✔(LUKS を使用しない) | ? | ? | ? | ?\n | 同一の暗号化されたデータに対して複数のキー (別個に無効にできる) のサポート | ? | ✔(LUKS を使用) | ? | ? | ? | ✖\n | \nパフォーマンス | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs\n | マルチスレッドのサポート | ? | ✔[8] | ✔ | ✔ | ? | ?\n | ハードウェア支援暗号化のサポート | ✔ | ✔ | ✔ | ✔ | ✔ | ✔[13]\n |  | \nブロックデバイス暗号化特有の事項 | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | \n | 所定の暗号化済みのブロックデバイスを (手動で) リサイズすることのサポート | ? | ✔ | ✖ | ✖\n |  | \nスタックファイルシステム暗号化特有の事項 | eCryptfs | EncFs\n | サポートされるファイルシステム | ext3, ext4, xfs (注意事項あり), jfs, nfs... | ext3, ext4, xfs (with caveats), jfs, nfs, cifs...[1]\n | ファイル名の暗号化 | ✔ | ✔\n | ファイル名の暗号化をしない機能 | ✔ | ✔\n | スパースファイルの最適化処理 | ✖ | ✔\n | \n互換性と普及度 | Loop-AES | dm-crypt +/- LUKS | TrueCrypt | VeraCrypt | eCryptfs | EncFs\n | サポートされる Linux カーネルバージョン | 2.0 以上 | CBC モード 2.6.4, ESSIV 2.6.10, LRW 2.6.20, XTS 2.6.24 | ? | ? | ? | 2.4 以上\n | 暗号化されたデータにアクセスできるオペレーティングシステム | Windows | ✔[3] | ?[4] | ✔ | ✔ | ? | ✔[9]\n | macOS | ? | ? | ✔ | ✔ | ? | ✔[5]\n | FreeBSD | ? | ? | ✔(VeraCrypt を使用) | ✔ | ? | ✔[6]\n | 使用しているディストリビューション | ? | Debian/Ubuntu インストーラ (システム暗号化) Fedora インストーラ | ? | ? | Ubuntu インストーラ (ホームディレクトリの暗号化) Chromium OS (キャッシュされたユーザーデータの暗号化[7]) | ?\n\nタイプ\n\n主なセールスポイント\n\nArch Linux における利用手段\n\nライセンス\n\n暗号化の対象\n\n暗号化されたデータのコンテナ\n\n- ディスクまたはディスクパーティション\n- 仮想パーティションとして作用するファイル\n\n- 既存のファイルシステムのディレクトリ\n\nファイルシステムとの関係\n\n暗号化の実装空間\n\n暗号メタデータの保存場所\n\n暗号鍵の保存場所\n\nファイルのメタデータ (ファイルの数, ディレクトリ構造, ファイルサイズ, パーミッション, 更新時刻など) の暗号化\n\n(パーティションテーブルを含む) ハードドライブ全体の暗号化\n\nスワップ領域の暗号化\n\nあらかじめ特定のサイズのスペースを暗号化データコンテナに割り当てなくても使用できるか\n\nブロックデバイスにアクセスできない既存のファイルシステム (NFS や Samba の共有、クラウドストレージなど) の保護に使用できるか\n\n暗号化されたファイルのファイルベースのオフラインバックアップ\n\nログイン時の自動マウントのサポート\n\nアイドル状態による自動アンマウントのサポート\n\nroot 以外のユーザーによる暗号化されたデータのコンテナの作成と破壊\n\nGUI\n\nサポートされている暗号\n\nソルティングのサポート\n\n複数の暗号による多段処理のサポート\n\nキースロットの拡散のサポート\n\nキースクラブに対する保護\n\n同一の暗号化されたデータに対して複数のキー (別個に無効にできる) のサポート\n\nマルチスレッドのサポート\n\nハードウェア支援暗号化のサポート\n\n所定の暗号化済みのブロックデバイスを (手動で) リサイズすることのサポート\n\nサポートされるファイルシステム\n\nファイル名の暗号化\n\nファイル名の暗号化をしない機能\n\nスパースファイルの最適化処理\n\nサポートされる Linux カーネルバージョン\n\n使用しているディストリビューション\n\n- Debian/Ubuntu インストーラ (システム暗号化)\n- Fedora インストーラ\n\n- Ubuntu インストーラ (ホームディレクトリの暗号化)\n- Chromium OS (キャッシュされたユーザーデータの暗号化[7])\n\n"
    },
    {
      "title": "セットアップの選択",
      "level": 3,
      "content": "どのディスク暗号化をセットアップするのが適切なのかはあなたの目的 (上の #なぜ暗号化を使うのか? を読んで下さい) とシステムパラメータによって様々です。 とりわけ、以下の質問に答える必要があるでしょう:\n\n- あなたが身を守りたいのはどのような\"攻撃者\"からか? システムの電源がオフになっていたり盗まれたりしたときにディスクを詮索するカジュアルなコンピュータユーザー あなたがシステムを使用する前後に繰り返しシステムに読み書きアクセスをすることができるプロの暗号解読者 その中間\n\n- システムの電源がオフになっていたり盗まれたりしたときにディスクを詮索するカジュアルなコンピュータユーザー\n- あなたがシステムを使用する前後に繰り返しシステムに読み書きアクセスをすることができるプロの暗号解読者\n- その中間\n\n- どの暗号化ストラテジーを使用するのか? データ暗号化 システム暗号化 その中間\n\n- データ暗号化\n- システム暗号化\n- その中間\n\n- スワップや /tmp などはどうすればいいか? 無視する、データが流出しないことを祈る 無効化する、または ramdisk としてマウント 暗号化する (完全なディスク暗号化の一部として、または別個に暗号化)\n\n- 無視する、データが流出しないことを祈る\n- 無効化する、または ramdisk としてマウント\n- 暗号化する (完全なディスク暗号化の一部として、または別個に暗号化)\n\n- どうやってディスクの暗号化された部分を解除するか? パスフレーズ (ログインパスワードと同じパスワード、または別個のパスワード) キーファイル (例: 安全な場所に置いたり常に持ち歩いている USB スティックに保存) 両方\n\n- パスフレーズ (ログインパスワードと同じパスワード、または別個のパスワード)\n- キーファイル (例: 安全な場所に置いたり常に持ち歩いている USB スティックに保存)\n- 両方\n\n- ディスクの暗号化された部分を解除するのはいつか? 起動する前 起動中 ログイン時 (ログイン後に) 必要に応じて手動で\n\n- 起動する前\n- 起動中\n- ログイン時\n- (ログイン後に) 必要に応じて手動で\n\n- 複数のユーザーに便宜をはかるにはどうすればいいか? 気にしない パスフレーズ/キーを共有する ディスクの同一の暗号化部分に対して別個に発行・無効化できるパスフレーズ/キーを使う ユーザーごとにディスクの暗号化部分を分ける\n\n- 気にしない\n- パスフレーズ/キーを共有する\n- ディスクの同一の暗号化部分に対して別個に発行・無効化できるパスフレーズ/キーを使う\n- ユーザーごとにディスクの暗号化部分を分ける\n\nさらに技術的な選択をする必要があります (上の #利用可能な手段 や、下の #暗号化の仕組み を参照):\n\n- スタックファイルシステムの暗号化 vs. ブロックデバイスの暗号化\n- キーの管理\n- 暗号と利用モード\n- メタデータの保管\n- \"下位ディレクトリ\"の場所 (スタックファイルシステムの暗号化を使う場合)\n\n実際にやってみると、以下のような取り合わせが考えられると思われます:\n\nもちろん他にも様々な組み合わせが考えられます。あなたのシステムにとってどのようなセットアップが適切か注意深く計画を練って下さい。\n\n"
    },
    {
      "title": "強固なパスフレーズの選択",
      "level": 3,
      "content": "セキュリティ#パスワードを見てください。\n\n"
    },
    {
      "title": "ディスクの準備",
      "level": 3,
      "content": "ディスク (の一部) に暗号化をセットアップする前に、まず確実にディスクを消去するようにしてください。ディスクを消去する際にはドライブ全体またはパーティション全体をゼロバイトやランダムなバイトのストリームで上書きします。これを行う理由は以下の通り:\n\n- 以前に保存されていたデータのリカバリを防ぐ たとえディスクを暗号化したとしても、実際のセクタは必要に応じて、ファイルシステムが特定のセクタにデータを作成したり修正したときにしか上書きされることはありません (下の #暗号化の仕組み を参照)。ファイルシステムから\"使用されていない\"セクタは弄られることがないため、前に使っていたファイルシステムのデータが残ってしまっている可能性があります。先にドライブに保存していたデータを完全にリカバリ不可能にするには、手動でデータを消去するしか道はないでしょう。データを完全に消去するということについては、ゼロバイトを使用するかランダムバイトを使用するかの違いはありません (ゼロバイトで消去するほうが高速です)。\n- 暗号化されたドライブの利用状況の発覚を防ぐ 理想を言えば、ディスクの暗号化部分はランダムなデータと区別を付かないようにするほうが望ましいでしょう。暗号化データを含んでいるセクタの数を知ることができなくなるということ自体が (完全な機密性を確保する上で) 好ましいですし、暗号化を解除しようと試みる攻撃者に対してセキュリティを増すことにもつながります。利用状況の発覚を防ぐということに関しては、高品質なランダムバイトを使用してディスクを消去するのが重要です。\n\n以前に保存されていたデータのリカバリを防ぐ\n\nたとえディスクを暗号化したとしても、実際のセクタは必要に応じて、ファイルシステムが特定のセクタにデータを作成したり修正したときにしか上書きされることはありません (下の #暗号化の仕組み を参照)。ファイルシステムから\"使用されていない\"セクタは弄られることがないため、前に使っていたファイルシステムのデータが残ってしまっている可能性があります。先にドライブに保存していたデータを完全にリカバリ不可能にするには、手動でデータを消去するしか道はないでしょう。データを完全に消去するということについては、ゼロバイトを使用するかランダムバイトを使用するかの違いはありません (ゼロバイトで消去するほうが高速です)。\n\n暗号化されたドライブの利用状況の発覚を防ぐ\n\n理想を言えば、ディスクの暗号化部分はランダムなデータと区別を付かないようにするほうが望ましいでしょう。暗号化データを含んでいるセクタの数を知ることができなくなるということ自体が (完全な機密性を確保する上で) 好ましいですし、暗号化を解除しようと試みる攻撃者に対してセキュリティを増すことにもつながります。利用状況の発覚を防ぐということに関しては、高品質なランダムバイトを使用してディスクを消去するのが重要です。\n\n二番目の理由はブロックデバイスの暗号化をしている場合にのみ意味をなします。スタックファイルシステムの暗号化では簡単に暗号化データを突き止められてしまいます (ホストファイルシステムに暗号化されたファイルがあることは隠しようがありません)。また、たとえ特定のフォルダだけを暗号化したいという場合でも、暗号化されてない状態でフォルダに保存されていたファイルを削除するためには (断片化している可能性があるため) パーティション全体を消去する必要があります。同一パーティションに別のフォルダが存在する場合、一度バックアップして、削除してから元のパーティションに戻すようにします。\n\nディスク消去することを決めたら、ディスクの完全消去の記事を参照してください。\n\n"
    },
    {
      "title": "暗号化の仕組み",
      "level": 2,
      "content": "このセクションは、一般的なディスク暗号化の心臓部である仕組みと方法についての高レベルなイントロダクションです。\n\n技術的数学的な詳細にまで立ち入ることはありませんが (適当な技術書を読んで下さい)、システム管理者が理解しておくべき、暗号化セットアップの選択がユーザビリティやセキュリティにどう影響をあたえるのかという基礎知識を提供します。\n\n"
    },
    {
      "title": "基本原理",
      "level": 3,
      "content": "ディスクを暗号化するとき、各ブロックデバイス (スタックファイルシステムの暗号化の場合、個々のファイル) は等長のセクタに分割されます。例えば512バイト (4096ビット) など。暗号化・復号化はセクタ単位で行われるので、ディスク上のブロックデバイスやファイルの n 番目のセクタには、元のデータの n 番目のセクタを暗号化したものが保存されます。\n\nオペレーティングシステムやアプリケーションがブロックデバイス・ファイルから特定のデータを要求した場合、そのデータが含まれているセクタ全体がディスクから読み込まれて、即座に復号化され、一時的にメモリに保存されます:\n\n```\n╔═══════╗\n sector 1 ║\"???..\"║\n          ╠═══════╣         ╭┈┈┈┈┈╮\n sector 2 ║\"???..\"║         ┊ key ┊\n          ╠═══════╣         ╰┈┈┬┈┈╯\n          :       :            │\n          ╠═══════╣            ▼             ┣┉┉┉┉┉┉┉┫\n sector n ║\"???..\"║━━━━━━━(decryption)━━━━━━▶┋\"abc..\"┋ sector n\n          ╠═══════╣                          ┣┉┉┉┉┉┉┉┫\n          :       :\n          ╚═══════╝\n \n          encrypted                          unencrypted\n     blockdevice or                          data in RAM\n       file on disk\n```\n\n同じように、書き込み操作のときは、該当箇所のセクタが全て再暗号化されます (他のセクタに変更が加えられることはありません)。\n\nデータを暗号化・復号化するために、ディスク暗号化システムはディスクに関連付けられたユニークな秘密鍵を知る必要があります。暗号化されたブロックデバイスやフォルダをマウントするには、適切な鍵が必要です (以後「マスター鍵」と呼びます)。\n\n暗号化のセキュリティでは鍵のエントロピーが一番重要です。ランダムに生成された一定の長さ (例えば32バイト=256ビット) のバイト文字列が望ましいですが、覚えづらい上にマウント時に手動で入力するのは苦痛です。\n\nそこで2つの方法があります。1番目の方法はマスター鍵のエントロピーを増大させる暗号化アプリケーションです。通常は人間が扱える程度のパスフレーズが用いられます。様々なタイプの暗号化方法があり比較表ではそれぞれの特徴を列記しています。そして、2番目の方法は高エントロピーのキーファイルを作成して暗号化するデータドライブとは別のメディアに保存する方式です。\n\n参照:\n\n- Wikipedia:ja:認証付き暗号\n\n"
    },
    {
      "title": "鍵とキーファイルとパスフレーズ",
      "level": 3,
      "content": "以下はキーファイルでマスター鍵を安全に保存する方法の例です:\n\n- プレーンテキストのキーファイルに保存 マスター鍵をファイルに保存するのは最も単純な方法です。ファイル (キーファイル) は USB メモリなどに保存して、安全な場所に保管しておき、ディスク上の暗号データをマウントしたいときだけコンピュータに接続します (例: 起動時やログイン時)。\n- パスフレーズで保護したキーファイルあるいはディスクに保存 マスター鍵 (と暗号データ) は秘密のパスフレーズで保護することができます。暗号化したブロックデバイスやフォルダをマウントするたびに思い出して入力する必要があります。詳しくは下の#暗号メタデータを見てください。\n- セッションごとにランダムに生成 スワップ領域や /tmp パーティションを暗号化する場合など、ときとしてマスター鍵を必ずしも保存しなくてよい場合があります。セッション毎に使い捨てのキーをランダムに生成するのであれば、ユーザーが何かする必要はありません。その場合、パーティションをアンマウントするとパーティションに書き込まれたデータを誰も復号化できなくなります。暗号化するのが一時ファイルなどの場合はそれで特に問題ありません。\n\nプレーンテキストのキーファイルに保存\n\nマスター鍵をファイルに保存するのは最も単純な方法です。ファイル (キーファイル) は USB メモリなどに保存して、安全な場所に保管しておき、ディスク上の暗号データをマウントしたいときだけコンピュータに接続します (例: 起動時やログイン時)。\n\nパスフレーズで保護したキーファイルあるいはディスクに保存\n\nマスター鍵 (と暗号データ) は秘密のパスフレーズで保護することができます。暗号化したブロックデバイスやフォルダをマウントするたびに思い出して入力する必要があります。詳しくは下の#暗号メタデータを見てください。\n\nセッションごとにランダムに生成\n\nスワップ領域や /tmp パーティションを暗号化する場合など、ときとしてマスター鍵を必ずしも保存しなくてよい場合があります。セッション毎に使い捨てのキーをランダムに生成するのであれば、ユーザーが何かする必要はありません。その場合、パーティションをアンマウントするとパーティションに書き込まれたデータを誰も復号化できなくなります。暗号化するのが一時ファイルなどの場合はそれで特に問題ありません。\n\n"
    },
    {
      "title": "暗号メタデータ",
      "level": 3,
      "content": "暗号技術ではマスター鍵のセキュリティを守るために暗号化関数がよく使われます。暗号化されたデバイスがマウントされたとき、パスフレーズやキーファイルを暗号化関数に入れて、出てきた計算結果を使ってマスター鍵を解錠してデータを復号化します。\n\n一般的なのはパスフレーズのいわゆる「キーストレッチング」です (「鍵導出関数」が使用されます)。パスフレーズはマウントキーとして使用し、実際のマスター鍵を復号化するのに使われます (マスター鍵は暗号化された状態で保存されます):\n\n```\n╭┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╮                         ╭┈┈┈┈┈┈┈┈┈┈┈╮\n ┊ mount passphrase ┊━━━━━⎛key derivation⎞━━━▶┊ mount key ┊\n ╰┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈╯ ,───⎝   function   ⎠    ╰┈┈┈┈┈┬┈┈┈┈┈╯\n ╭──────╮            ╱                              │\n │ salt │───────────´                               │\n ╰──────╯                                           │\n ╭─────────────────────╮                            ▼         ╭┈┈┈┈┈┈┈┈┈┈┈┈╮\n │ encrypted master key│━━━━━━━━━━━━━━━━━━━━━━(decryption)━━━▶┊ master key ┊\n ╰─────────────────────╯                                      ╰┈┈┈┈┈┈┈┈┈┈┈┈╯\n```\n\n鍵導出関数 (例: PBKDF2 や scrypt) は意図的に低速にしか動作しないようになっており (ハッシュ関数を何度も繰り返し使用します、例えば HMAC-SHA-512 を1000回実行)、総当り攻撃によってパスフレーズを見つけ出すことが事実上不可能です。正しいパスワードを持っているユーザーの場合、計算する必要があるのは一度だけなので、多少遅くても問題になりません。\n\nまた、ディスク暗号化をセットアップするときにランダムに生成される \"salt\" を追加引数として使います。salt は暗号メタデータに含まれ暗号化されていない状態で保存されます。セットアップのたびに異なる値となるため、あらかじめ計算済みのテーブルを使って鍵導出関数に対して総当り攻撃をすることが不可能になります。\n\n暗号化されたマスター鍵は暗号化されたデータと一緒にディスク上に保存するため、暗号化データの機密性は完全に秘密のパスフレーズに依存します。\n\nUSB スティックなどのキーファイルに暗号化したマスター鍵を保存することでセキュリティをさらに向上させることも可能です。いわゆる二段階認証です: 暗号化されたデータにアクセスするにはあなただけが知っているもの (パスフレーズ) に加えて、あなただけが持っているもの (キーファイル) も必要となります。\n\n二段階認証を実現する他の方法として、上記の鍵導出を強化してパスフレーズと (USB スティックなどに保存した) 外部のファイルに含まれるバイトデータを数学的に「ミックス」してから鍵導出関数に渡すという手段もあります。使用するファイルは何でもかまいません。通常の JPEG 画像などであれば#もっともらしい否認にも有効でしょう。画像ではありますが、ここでは同じ「キーファイル」となります。\n\n導出したマスター鍵は暗号化ブロックデバイスやフォルダがマウントされている間だけ、メモリ上に安全に保管されます (カーネルのキーリングなど)。\n\n通常はディスクデータを暗号化・復号化するのにマスター鍵が直接使われることはありません。例えば、スタックファイルシステム暗号化の場合、ファイルにはそれぞれ別々の暗号鍵が自動的に割り当てられます。ファイルを読み書きしたくなったら、最初にメイン鍵を使ってファイルの鍵を復号化してから、ファイルの中身が復号化・暗号化できるようになります:\n\n```\n╭┈┈┈┈┈┈┈┈┈┈┈┈╮\n                          ┊ master key ┊\n  file on disk:           ╰┈┈┈┈┈┬┈┈┈┈┈┈╯\n ┌ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┐        │\n ╎╭───────────────────╮╎        ▼          ╭┈┈┈┈┈┈┈┈┈┈╮\n ╎│ encrypted file key│━━━━(decryption)━━━▶┊ file key ┊\n ╎╰───────────────────╯╎                   ╰┈┈┈┈┬┈┈┈┈┈╯\n ╎┌───────────────────┐╎                        ▼           ┌┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┐\n ╎│ encrypted file    │◀━━━━━━━━━━━━━━━━━(de/encryption)━━━▶┊ readable file ┊\n ╎│ contents          │╎                                    ┊ contents      ┊\n ╎└───────────────────┘╎                                    └┈┈┈┈┈┈┈┈┈┈┈┈┈┈┈┘\n └ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┘\n```\n\n同じように、スタックファイルシステム暗号化の場合、ファイル名を暗号化するときは別の鍵 (例: フォルダごとに割り振られた鍵) が使われます。\n\nブロックデバイス暗号化の場合、デバイスごと、つまり全てのデータで使われるのはひとつのマスター鍵です。一部のブロックデバイス暗号化では同一デバイスに複数のパスフレーズやキーファイルを割り当てることができますが、できないものもあります。上記の関数を使ってマスター鍵を保全する場合もあればキーのセキュリティを完全にユーザーに委ねる場合もあります。例として dm-crypt の plain モードと LUKS モードで使用される暗号パラメータで説明しましょう。\n\n両方のモードで使用するパラメータを比較すると、dm-crypt の plain モードではキーファイルの場所に関するパラメータがあることに気づくでしょう (例: --keyfile-size, --keyfile-offset)。dm-crypt の LUKS モードではキーファイルの場所を指定する必要はありません。各ブロックデバイスのヘッダーに暗号のメタデータが含まれるためです。ヘッダーには使用する暗号、暗号化されたマスター鍵、そして鍵導出に必要なパラメータが存在します。最後のパラメータは最初にマスター鍵を暗号化したときに使用したオプションから生成されます (例: --iter-time, --use-random)。\n\n暗号化手段のメリット・デメリットについては#比較表やそれぞれのページを参照してください。\n\n参照:\n\n- Wikipedia:ja:パスワード\n- Wikipedia:ja:鍵 (暗号)\n- Wikipedia:Key_management\n- Wikipedia:ja:鍵導出関数\n\n"
    },
    {
      "title": "暗号と利用モード",
      "level": 3,
      "content": "与えられた暗号鍵を使って実際に暗号化データと非暗号化データ (つまり\"平文\"と\"暗号文\") を変換するのに使われるアルゴリズムは \"cipher\" と呼ばれます。\n\nディスク暗号化では等長なブロックのデータを処理する\"ブロック暗号\" (block cipher) が用いられます。ブロック長は16バイト (128ビット) などになります。執筆時点で、主に使われている暗号は以下のとおり:\n\nTable content:\n | ブロックサイズ | キーサイズ | 注記\nAES | 128 ビット | 128, 192, 256 ビット | アメリカ政府の \"SECRET\" または \"TOP SECRET\" の機密情報を保護するのに足ると NSA によって承認されています (192または256ビットのキーサイズの使用時)。\nBlowfish | 64 ビット | 32–448 ビット | 初期のパテントフリーでセキュアな暗号の一つであり誰でも使えるため、Linux ではかなり定着しています。\nTwofish | 128 ビット | 128, 192, 256 ビット | Blowfish の後継として開発されましたが、それほど幅広くは利用されていません。\nSerpent | 128 ビット | 128, 192, 256 ビット | AES コンペティションの5つの最終候補の中で一番セキュアだと考えられています[10][11][12]。\n\nセクタの暗号化・復号化 (上を参照) を行うときはセクタを暗号のブロックサイズにあわせて小さなブロックに分割します。個々のブロックに暗号をどのように適用していくかは特定のルールセット (いわゆる\"暗号利用モード\") に従います。\n\n特に手を加えずにそれぞれのブロックを独立して暗号化するのはセキュアではありません (\"電子符号表 (electronic codebook, ECB)\" モードと呼ばれます)。平文で同じ16バイトのテキストがあれば、暗号文も常に同じになるため、ディスクに保存されている暗号文から簡単にパターンを見つけ出すことができてしまいます。\n\n実際に広く使われている利用モードは \"暗号ブロック連鎖 (cipher-block chaining, CBC)\" です。CBC モードでセクタを暗号化した場合、平文データの各ブロックは前のブロックの暗号文と数学的に混ぜ合わされてから暗号化されます。最初のブロックは前の暗号文がないため、\"初期化ベクトル (IV)\" と呼ばれる暗号メタデータに保存されている特殊な事前生成済みのデータブロックが使われます:\n\n```\n╭──────────────╮\n                                  │initialization│\n                                  │vector        │\n                                  ╰────────┬─────╯\n          ╭  ╠══════════╣        ╭─key     │      ┣┉┉┉┉┉┉┉┉┉┉┫        \n          │  ║          ║        ▼         ▼      ┋          ┋         . START\n          ┴  ║\"????????\"║◀━━━━(cipher)━━━━(+)━━━━━┋\"Hello, W\"┋ block  ╱╰────┐\n    sector n ║          ║                         ┋          ┋ 1      ╲╭────┘\n  of file or ║          ║──────────────────╮      ┋          ┋         ' \n blockdevice ╟──────────╢        ╭─key     │      ┠┈┈┈┈┈┈┈┈┈┈┨\n          ┬  ║          ║        ▼         ▼      ┋          ┋\n          │  ║\"????????\"║◀━━━━(cipher)━━━━(+)━━━━━┋\"orld !!!\"┋ block\n          │  ║          ║                         ┋          ┋ 2\n          │  ║          ║──────────────────╮      ┋          ┋\n          │  ╟──────────╢                  │      ┠┈┈┈┈┈┈┈┈┈┈┨\n          │  ║          ║                  ▼      ┋          ┋\n          :  :   ...    :        ...      ...     :   ...    : ...\n \n               ciphertext                         plaintext\n                  on disk                         in RAM\n```\n\n復号化するときは、手順が逆になります。\n\n注目に値することの1つは、セクターごとに一意の初期化ベクトルを生成することです。 最も簡単な選択は、セクター番号などのすぐに利用できる値から予測可能な方法で計算することです。 ただし、これにより、システムに繰り返しアクセスする攻撃者が、いわゆる watermarkingattack を実行できる可能性があります。 これを防ぐために、 暗号化されたソルトセクター初期化ベクトル ( ESSIV) と呼ばれる方法を使用して、潜在的な攻撃者に完全にランダムに見えるように初期化ベクトルを生成できます。\n\nディスク暗号化に利用できる他のより複雑な操作モードもいくつかあります。これらは、そのような攻撃に対する組み込みのセキュリティをすでに提供しています(したがって、 ESSIV を必要としません)。 暗号化されたデータの信頼性をさらに保証できるものもあります(つまり、キーにアクセスできない人によってデータが変更/破損されていないことを確認します)。\n\n参照:\n\n- Wikipedia:Disk_encryption_theory\n- Wikipedia:ja:ブロック暗号\n- Wikipedia:ja:暗号利用モード\n\n"
    },
    {
      "title": "もっともらしい否認",
      "level": 3,
      "content": "Wikipedia:Plausible deniability を参照してください。\n\n"
    },
    {
      "title": "ディスク暗号化シナリオのバックアップ",
      "level": 2,
      "content": "データ損失から保護するために、ユーザーデータの バックアップ を作成します。一般に、暗号化されたデータのバックアップも暗号化する必要があります。\n\n"
    },
    {
      "title": "ブロックデバイスの暗号化",
      "level": 3,
      "content": "複数のオプションがあり、暗号化コンテナが存在するディスクブロックデバイスをイメージとしてバックアップできます。 /dev/sdx または暗号化されたコンテナ内のファイルシステムをバックアップできます。 /dev/mapper/dm_name またはファイルをバックアップできます。例: rsync で。次のセクションでは、各オプションの長所と短所を示します。\n\n"
    },
    {
      "title": "ディスクブロックデバイスのバックアップ",
      "level": 4,
      "content": "ディスクブロックデバイスのバックアップは次のとおりです。\n\n- 作業コピーと同じレベルのセキュリティでそのまま暗号化\n- LUKS ヘッダーが含まれています\n- 常にディスクブロックデバイスと同じ大きさ\n- 増分バックアップ、圧縮、重複排除などの高度なバックアップ戦略を簡単に許可することはできません\n- 暗号化コンテナも復元されるため、新しいディスクに簡単に復元できます\n\n"
    },
    {
      "title": "ファイルシステムまたはファイルのバックアップ",
      "level": 4,
      "content": "1つまたは複数のファイルのバックアップは次のとおりです。\n\n- そのまま 暗号化されていない\n- ネットワーク経由で転送する前、またはディスクに保存するときに暗号化する必要があり、追加の作業が必要です\n- 必ずしも作業コピーと同じレベルのセキュリティで暗号化されているとは限りません\n- LUKS ヘッダーは含まれていません\n- ファイルシステムの使用済みスペースと同じ大きさのみ。たとえば、Partclone\n- 増分バックアップ、圧縮、重複排除などの高度なバックアップ戦略を可能にします\n- LUKS ヘッダーのバックアップを復元するなどして、暗号化コンテナを新しいディスクに手動で復元する必要があります\n\n"
    },
    {
      "title": "LUKS ヘッダーバックアップ",
      "level": 4,
      "content": "LUKS を使用している場合、dm-crypt/デバイスの暗号化#バックアップとリストアを作成できます。特にパスフレーズが取り消されている場合は、これらのバックアップを定期的にチェックして同期するのが理にかなっています。\n\nただし、データのバックアップがあり、それを復元する場合は、cryptsetupを使用してLUKS暗号化パーティションを最初から再作成してからデータを復元できます。したがって、LUKSヘッダーのバックアップはデータのバックアップよりも重要ではありません。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "1. ^ http://www.truecrypt.org/legal/license を参照\n1. ^ ファイルシステムのひとつのファイルをコンテナとして使うことはできますが(仮想ループバックデバイス)、ファイルシステム(の機能)を使うことはできなくなります。\n1. ^ CrossCrypt - Windows XP や Windows 2000 と互換性のあるオープンソースの AES と TwoFish による Linux の暗号化\n1. ^ (1) FreeOTFE (on sf.net) (2) FreeOTFE (archived) - Windows 2000 以上 (PC) や Windows Mobile 2003 以上 (PDA) をサポート\n1. ^ EncFs build instructions for Mac を参照\n1. ^ http://www.freshports.org/sysutils/fusefs-encfs/ を参照\n1. ^ https://www.chromium.org/chromium-os/chromiumos-design-docs/protecting-cached-user-data を参照\n1. ^ http://kernelnewbies.org/Linux_2_6_38#head-49f5f735853f8cc7c4d89e5c266fe07316b49f4c\n1. ^ http://members.ferrara.linux.it/freddy77/encfs.html\n1. ^ http://csrc.nist.gov/archive/aes/round2/r2report.pdf\n1. ^ https://www.cl.cam.ac.uk/~rja14/Papers/serpentcase.pdf\n1. ^ https://www.cl.cam.ac.uk/~rja14/Papers/serpent.pdf\n1. ^ https://github.com/vgough/encfs/issues/118\n1. ^ LibreCrypt (旧名 DOXBOX) - 新しいバージョンの Windows におけるオープンな dm-crypt / LUKS のサポート (OTFE のフォークを含む)\n\n"
    }
  ]
}