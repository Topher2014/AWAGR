{
  "title": "Domain name resolution (Français)",
  "url": "https://wiki.archlinux.org/title/Domain_name_resolution_(Fran%C3%A7ais)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Network configuration (Français)\n- DNS over HTTPS servers\n\nEn général, un nom de domaine représente une adresse IP et lui est associé dans le Système de nom de domaine (DNS). Cet article explique comment configurer la résolution des noms de domaine et résoudre les noms de domaine.\n\n"
    },
    {
      "title": "Name Service Switch",
      "level": 2,
      "content": "Le Name Service Switch (NSS) fait partie de la bibliothèque GNU C (glibc) et fournit l'API getaddrinfo(3) utilisée pour résoudre les noms de domaine. NSS permet aux bases de données système d'être fournies par des services distincts, dont l'ordre de recherche peut être configuré par l'administrateur dans nsswitch.conf(5). La base de données responsable de la résolution des noms de domaine est la base de données hosts, pour laquelle la glibc offre les services suivants :\n\n- files : lit le fichier /etc/hosts, consultez hosts(5).\n- dns : le résolveur de glibc qui lit /etc/resolv.conf, consultez resolv.conf(5).\n\nsystemd fournit trois services NSS pour la résolution de noms d'hôtes :\n\n- nss-resolve(8) - un résolveur de stub DNS en cache, décrit dans systemd-resolved.\n- nss-myhostname(8). - fournit une résolution de nom d'hôte local sans avoir à modifier /etc/hosts, décrit dans Network configuration#Local network hostname resolution.\n- nss-mymachines(8). - fournit une résolution de nom d'hôte pour les noms des conteneurs locaux systemd-machined(8).\n\n"
    },
    {
      "title": "Résoudre un nom de domaine à l'aide de NSS",
      "level": 3,
      "content": "Les bases de données NSS peuvent être interrogées avec getent(1). Un nom de domaine peut être résolu par NSS en utilisant :\n\n```\n$ getent hosts nom_de_domaine\n```\n\n"
    },
    {
      "title": "Résolveur de glibc",
      "level": 2,
      "content": "Le résolveur de glibc lit /etc/resolv.conf pour chaque résolution afin de déterminer les serveurs de noms et les options à utiliser.\n\nresolv.conf(5) liste les serveurs de noms ainsi que certaines options de configuration. Les serveurs de noms listés en premier sont essayés en premier, jusqu'à trois serveurs de noms peuvent être listés. Les lignes commençant par un (#) sont ignorées.\n\n"
    },
    {
      "title": "Écrasement de /etc/resolv.conf",
      "level": 3,
      "content": "Les gestionnaires de réseau ont tendance à écraser /etc/resolv.conf, pour plus de détails, consultez la section correspondante :\n\n- dhcpcd#/etc/resolv.conf\n- Netctl#/etc/resolv.conf\n- NetworkManager#/etc/resolv.conf\n- ConnMan#/etc/resolv.conf\n\nPour empêcher les programmes d'écraser /etc/resolv.conf, il est également possible de le protéger en écriture en définissant l'attribut immuable au fichier :\n\n```\n# chattr +i /etc/resolv.conf\n```\n\n"
    },
    {
      "title": "Limiter le temps de recherche",
      "level": 3,
      "content": "Si vous êtes confronté à une très longue recherche de nom d'hôte (que ce soit dans pacman ou en naviguant), il est souvent utile de définir un petit délai après lequel un serveur de noms alternatif est utilisé. Pour ce faire, mettez ce qui suit dans /etc/resolv.conf.\n\n```\noptions timeout:1\n```\n\n"
    },
    {
      "title": "Recherche de nom d'hôte lente avec IPv6",
      "level": 3,
      "content": "Si vous constatez un retard de 5 secondes lors de la résolution de noms d'hôtes, cela peut être dû à un serveur DNS/pare-feu qui se comporte mal et ne donne qu'une seule réponse à une requête parallèle A et AAAA.[1] Vous pouvez corriger cela en définissant l'option suivante dans /etc/resolv.conf :\n\n```\noptions single-request\n```\n\n"
    },
    {
      "title": "Noms de domaine locaux",
      "level": 3,
      "content": "Pour pouvoir utiliser le nom d'hôte des noms de machines locales sans le nom de domaine pleinement qualifié, ajoutez une ligne à /etc/resolv.conf avec le domaine local comme :\n\n```\ndomaine exemple.org\n```\n\nDe cette façon, vous pouvez vous référer à des hôtes locaux tels que mainmachine1.example.org comme étant simplement mainmachine1 lorsque vous utilisez la commande ssh, mais la commande drill nécessite toujours les noms de domaine pleinement qualifiés afin d'effectuer des recherches.\n\n"
    },
    {
      "title": "Utilitaires de recherche",
      "level": 2,
      "content": "Pour interroger des serveurs DNS spécifiques et des enregistrements DNS/DNSSEC, vous pouvez utiliser des utilitaires de recherche DNS dédiés. Ces outils mettent en œuvre le DNS eux-mêmes et n'utilisent pas NSS.\n\nldns fournit drill(1), qui est un outil conçu pour récupérer des informations à partir du DNS.\n\nPar exemple, pour interroger un serveur de noms spécifique avec drill pour les enregistrements TXT d'un domaine :\n\n```\n$ drill @ nameserver TXT domain\n```\n\nSi un serveur DNS n'est pas spécifié, drill utilisera les serveurs de noms définis dans /etc/resolv.conf.\n\n- knot fournit khost(1) et kdig(1).\n- Unbound a unbound-host(1).\n- BIND a dig(1), host(1), nslookup(1) et un tas d'outils dnssec-.\n\n"
    },
    {
      "title": "Performances du résolveur",
      "level": 2,
      "content": "Le résolveur de la Glibc ne met pas en cache les requêtes. Pour mettre en œuvre la mise en cache locale, utilisez systemd-resolved ou configurez un serveur DNS de mise en cache locale et utilisez-le comme serveur de noms en définissant 127.0.0.1 et ::1 comme serveurs de noms dans /etc/resolv.conf ou dans /etc/resolvconf.conf si vous utilisez openresolv.\n\n- Les utilitaires de recherche de type drill ou dig indiquent le temps d'interrogation.\n- Un routeur définit généralement son propre résolveur de cache comme serveur DNS du réseau, fournissant ainsi un cache DNS pour l'ensemble du réseau.\n- Si le passage au serveur DNS suivant prend trop de temps, vous pouvez essayer de réduire le délai d'expiration.\n\n"
    },
    {
      "title": "Confidentialité et sécurité",
      "level": 2,
      "content": "Le protocole DNS n'est pas chiffré et ne prend pas en compte la confidentialité, l'intégrité ou l'authentification. Par conséquent, si vous utilisez un réseau non fiable ou un fournisseur d'accès malveillant, vos requêtes DNS peuvent être écoutées et les réponses manipulées. En outre, les serveurs DNS peuvent mener des opérations d'empoisonnement du cache DNS.\n\nVous devez faire confiance à votre serveur DNS pour traiter vos requêtes de manière confidentielle. Les serveurs DNS sont fournis par les FAI et les tiers. Vous pouvez également faire tourner votre propre serveur, ce qui demande toutefois plus d'efforts. Si vous utilisez un client DHCP dans des réseaux non fiables, veillez à définir des serveurs de noms statiques pour éviter d'utiliser et d'être soumis à des serveurs DNS arbitraires. Pour sécuriser votre communication avec un serveur DNS distant, vous pouvez utiliser un protocole chiffré, comme DNS over TLS. (RFC 7858), DNS sur HTTPS. (RFC 8484), ou DNSCrypt, à condition que le serveur en amont et votre résolveur prennent en charge le protocole. Une alternative peut être un logiciel dédié au chiffrement et au déchiffrement de la communication, tel que stunnel. Pour vérifier que les réponses proviennent bien de serveurs de noms faisant autorité, vous pouvez valider DNSSEC, à condition que le ou les serveurs en amont et votre résolveur le prennent en charge.\n\n"
    },
    {
      "title": "DNS au niveau des applications",
      "level": 3,
      "content": "Sachez que certains logiciels clients, tels que les principaux navigateurs Web [2] [3], commencent à mettre en œuvre le DNS sur HTTPS. Si le chiffrement des requêtes peut souvent être consulté comme un bonus, cela signifie également que le logiciel détourne les requêtes de la configuration du résolveur du système [4].\n\nFirefox fournit options de configuration pour activer ou désactiver le DNS sur HTTPS et sélectionner un serveur DNS.\n\nChromium examinera le résolveur système de l'utilisateur et activera le DNS sur HTTPS si les adresses du résolveur système sont connues pour fournir également le DNS sur HTTPS. Consultez cet article de blog pour plus d'informations et pour savoir comment désactiver le DNS sur HTTPS.\n\nMozilla a proposé de désactiver universellement le DNS au niveau des applications si le résolveur du système ne peut pas résoudre le domaine use-application-dns.net. Actuellement, ceci n'est implémenté que dans Firefox.\n\n"
    },
    {
      "title": "Oblivious DNS",
      "level": 3,
      "content": "Oblivious DNS (RFC:9230) est un système qui répond à un certain nombre de problèmes de confidentialité des DNS. Consultez l'article de Cloudflare pour plus d'informations.\n\n"
    },
    {
      "title": "Services DNS tiers",
      "level": 2,
      "content": "Il existe plusieurs services DNS tiers (en), dont certains disposent également de logiciels dédiés :\n\n- cloudflared — Un client DNS pour Cloudflare DNS over HTTPS\n\n- dingo — Un client DNS pour Google DNS sur HTTPS\n\n- opennic-up — Automate le renouvellement des serveurs DNS avec les serveurs OpenNIC les plus réactifs\n\n- nextdns — Un client CLI DNS-over-HTTPS pour NextDNS\n\nVous pouvez utiliser dnsperftest pour tester les performances des résolveurs DNS les plus populaires depuis votre emplacement. dnsperf.com fournit des points de référence mondiaux entre les fournisseurs.\n\n"
    },
    {
      "title": "Serveurs DNS",
      "level": 2,
      "content": "Les serveurs DNS peuvent être autoritatif et récursif. S'ils ne sont ni l'un ni l'autre, ils sont appelés résolveurs stub (ébauches) et transmettent simplement toutes les requêtes à un autre serveur de noms récursif. Les résolveurs «stub» sont généralement utilisés pour introduire la mise en cache du DNS sur l'hôte ou le réseau local. Notez que la même chose peut également être réalisée avec un serveur de noms à part entière. Cette section compare les serveurs DNS disponibles, pour une comparaison plus détaillée, reportez-vous à Wikipedia:Comparison of DNS server software.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nTable content:\nNom | Paquet | Capacités | resolvconf | Protocoles pris en charge\nAuthoritatif | Recursif | Cache | ValideDNSSEC | DNS | DNSCrypt | DNSover TLS | DNSover HTTPS\nBIND | bind | Oui | Oui | Oui | Oui | Oui | Oui | Non | Serveur1 | Serveur\nCoreDNS | corednsAUR ou coredns-binAUR | ? | ? | ? | ? | ? | ? | ? | Oui | ?\nDeadwood (MaraDNS recursor) | maradnsAUR | Non | Oui | Oui | Non | Non | Oui | Non | Non | Non\ndnscrypt-proxy | dnscrypt-proxy | Non | Non | Oui | Non | Non | Serveur | Résolveur | Non | Oui\ndnsmasq | dnsmasq | Partiel2 | Non | Oui | Oui | Oui | Oui | Non | Non | Non\nKnot Resolver | knot-resolver | Non | Oui | Oui | Oui | Non | Oui | Non | Oui | Serveur\npdnsd | pdnsd | Oui | Oui | Permanent | Non | Oui | Oui | Non | Non | Non\nPowerDNS Recursor | powerdns-recursor | Non | Oui | Oui | Oui | Oui | Oui | Non | Non | Non\nRescached | rescached-gitAUR | Non | Non | Oui | Non | Oui | Oui | Non | Oui | Oui\nSmartDNS | smartdns | Non | Non | Oui | Non | ? | Oui | Non | Résolveur | Résolveur\nStubby | stubby | Non | Non | Non | Oui | Non | Serveur | Non | Résolveur | Non\nsystemd-resolved | systemd | Non | Non | Oui | Oui | Oui | Résolveur et serveur limité | Non | Résolveur | Non\nUnbound | unbound | Partiel | Oui | Oui3 | Oui | Oui | Oui | Serveur | Oui | Serveur\n\n1. BIND peut servir à la fois les DNS sur TLS et les DNS sur HTTPS (voir tls{} et listen-on), mais ne peut pas encore transmettre les requêtes à un DNS sur TLS/DNS sur HTTPS nativement. L'outil dig peut effectuer des requêtes sur des DNS sur TLS et des DNS sur HTTPS (en utilisant les options +tls et +https), mais sans vérification des certificats.\n1. D'après Wikipedia : dnsmasq dispose d'une prise en charge limitée de l'autorité, destinée à un usage interne au réseau plutôt qu'à un usage public sur Internet.\n1. Le backend Redis peut être utilisé pour fournir un cache persistant pour Unbound.\n\n"
    },
    {
      "title": "Serveurs faisant autorité uniquement",
      "level": 3,
      "content": "Table content:\nNom | Paquet | DNSSEC | ÉquilibrageGéographique\ngdnsd | gdnsd | Non | Oui\nKnot DNS | knot | Oui | Oui\nMaraDNS | maradnsAUR | Non | ?\nNSD | nsd | Non | Non\nPowerDNS | powerdns | Oui | Oui\n\n"
    },
    {
      "title": "Redirection conditionnelle",
      "level": 3,
      "content": "Il est possible d'utiliser des résolveurs DNS spécifiques lors de l'interrogation de noms de domaine spécifiques. Ceci est particulièrement utile lors de la connexion à un VPN, afin que les requêtes vers le réseau VPN soient résolues par le DNS du VPN, tandis que les requêtes vers l'Internet seront toujours résolues par votre résolveur DNS standard. Elle peut également être utilisée sur les réseaux locaux.\n\nPour l'implémenter, vous devez utiliser un résolveur local car la glibc ne le prend pas en charge.\n\nDans un environnement dynamique (ordinateurs portables et, dans une certaine mesure, ordinateurs de bureau), vous devez configurer votre résolveur en fonction du ou des réseaux auxquels vous êtes connecté. La meilleure façon de le faire est d'utiliser openresolv car il prend en charge multiple subscribers. Certains gestionnaires de réseau le prennent en charge, soit par le biais d'openresolv, soit en configurant directement le résolveur. NetworkManager prend en charge la redirection conditionnelle sans openresolv.\n\n"
    },
    {
      "title": "Voir aussi",
      "level": 2,
      "content": "- Guide de l'administrateur réseau Linux\n- Manuel Debian\n- RFC:7706 - Diminution du temps d'accès aux serveurs racine en en faisant tourner un sur le loopback\n- Domain name system overview - Diagramme sur le DNS\n- Alternative DNS services\n\n"
    }
  ]
}