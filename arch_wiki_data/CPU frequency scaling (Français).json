{
  "title": "CPU frequency scaling (Français)",
  "url": "https://wiki.archlinux.org/title/CPU_frequency_scaling_(Fran%C3%A7ais)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Power saving\n- Laptop Mode Tools (Français)\n- Undervolting CPU\n\nLa modification des performances du processeur permet au système d'exploitation d'augmenter ou de diminuer la fréquence du CPU afin d'économiser de l'énergie ou d'améliorer les performances. La mise à l'échelle peut se faire automatiquement en réponse à la charge du système, s'ajuster en réponse aux événements ACPI, ou être modifiée manuellement par les programmes de l'espace utilisateur.\n\nLe noyau Linux offre une modification des performances du CPU via le sous-système CPUFreq, qui définit deux couches d'abstraction :\n\n- La politique de gestion implémente les algorithmes pour calculer la fréquence désirée du CPU, potentiellement basée sur les besoins du système.\n- Le pilote de fréquence interagit directement avec le CPU, en mettant en œuvre les fréquences souhaitées par le gouverneur actuel.\n\nUn pilote de fréquence et une politique par défaut sont sélectionnés automatiquement, mais des outils en espace utilisateur comme cpupower, acpid, Laptop Mode Tools, ou des outils GUI fournis pour votre environnement de bureau, peuvent toujours être utilisés pour une configuration avancée.\n\n"
    },
    {
      "title": "thermald",
      "level": 3,
      "content": "thermald est un daemon pour Linux[dead link 2023-09-16 ⓘ] utilisé pour prévenir la surchauffe des processeurs Intel. Ce daemon contrôle de manière proactive les paramètres thermiques en utilisant les P-states, les T-states, et le pilote Intel power clamp. thermald peut également être utilisé pour les anciens CPU Intel. Si les derniers pilotes ne sont pas disponibles, le daemon reviendra aux registres spécifiques au modèle x86 et au \"sous-système cpufreq\" de Linux pour contrôler le refroidissement du système.\n\nPar défaut, il surveille la température du CPU en utilisant les capteurs de température numériques disponibles et maintient la température du CPU sous contrôle, avant que le matériel ne prenne des mesures de correction agressives. S'il y a un capteur de température de la peau dans le sysfs «thermal», alors il essaie de maintenir la température de la peau sous 45C.\n\nSur les ordinateurs portables Tiger Lake (par exemple, Dell Latitude 3420), ce daemon a été signalé comme débloquant plus de performances que ce qui serait autrement disponible.\n\nL'unité systemd associée est thermald.service, qui doit être démarrée et activée.\n\n"
    },
    {
      "title": "i7z",
      "level": 3,
      "content": "i7z est un outil de rapport sur les CPU i7 (et également i3, i5, i9) pour Linux. Il peut être lancé depuis un terminal avec la commande i7z ou en tant qu'interface graphique avec i7z-gui.\n\n"
    },
    {
      "title": "turbostat",
      "level": 3,
      "content": "turbostat peut afficher la fréquence, la consommation d'énergie, l'état de veille et d'autres statistiques des CPU modernes Intel et AMD.\n\n"
    },
    {
      "title": "cpupower",
      "level": 3,
      "content": "cpupower est un ensemble d'utilitaires en espace utilisateur conçus pour aider à la mise à l'échelle de la fréquence des CPU. Ce paquet n'est pas nécessaire pour utiliser la mise à l'échelle, mais il est fortement recommandé car il fournit des utilitaires de ligne de commande utiles et un service systemd pour changer le gouverneur au démarrage.\n\nLe fichier de configuration de cpupower est situé dans /etc/default/cpupower. Ce fichier de configuration est lu par un script bash dans /usr/lib/systemd/scripts/cpupower qui est activé par systemd avec cpupower.service. Vous pouvez vouloir activer cpupower.service pour qu'il démarre au démarrage.\n\n"
    },
    {
      "title": "cpupower-gui",
      "level": 3,
      "content": "cpupower-guiAUR est un utilitaire graphique conçu pour aider à la mise à l'échelle de la fréquence du CPU. L'interface graphique est basée sur GTK et est censée fournir les mêmes options que cpupower. cpupower-gui peut changer la fréquence maximale/minimale du CPU et le gouverneur pour chaque noyau. L'application gère l'octroi de privilèges par le biais de polkit et permet à tout utilisateur connecté dans le groupe d'utilisateurs wheel de modifier la politique ou la fréquence du processeur.\n\n"
    },
    {
      "title": "power-profiles-daemon",
      "level": 3,
      "content": "L'outil de ligne de commande powerprofilesctl de power-profiles-daemon gère les profils d'alimentation (par exemple, équilibré, économie d'énergie, performance) par le biais du service power-profiles-daemon. GNOME et KDE fournissent également interfaces graphiques pour le changement de profil ; consultez les sites suivants :\n\n- GNOME#Power modes.\n- KDE#Power management.\n\nConsultez le README du projet pour plus d'informations sur l'utilisation, les cas d'utilisation et les comparaisons avec des projets similaires.\n\nDémarrez et activez le service power-profiles-daemon. Notez que lorsque powerprofilesctl est lancé, il tente également de démarrer le service (consultez le status de l'unité dbus.service).\n\n"
    },
    {
      "title": "Pilote de fréquence",
      "level": 2,
      "content": "Les pilotes de fréquence implémentent les détails spécifiques au CPU pour appliquer les fréquences spécifiées par la politique. À proprement parler, la norme ACPI requiert des «power-performance states (P-states)» qui commence à P0, et devient de moins en moins performant. Cette fonctionnalité est appelée SpeedStep sur Intel, et PowerNow! sur AMD.\n\nEn pratique, cependant, les processeurs fournissent des méthodes pour spécifier des fréquences spécifiques plutôt que d'être limités à des états P fixes, que les pilotes de mise à l'échelle gèrent.\n\n- Le module CPU natif est chargé automatiquement.\n- Le pilote de fréquence de la puissance du CPU intel_pstate est utilisé automatiquement pour les CPU Intel modernes à la place des autres pilotes ci-dessous. Ce pilote est prioritaire sur les autres pilotes et est intégré par opposition à un module. Ce pilote est actuellement utilisé automatiquement pour les processeurs Sandy Bridge et plus récents. Le pilote intel_pstate peut ignorer les paramètres P-State du BIOS. intel_pstate peut fonctionner en \"mode passif\" via le pilote intel_cpufreq pour les anciens processeurs. Si vous rencontrez un problème en utilisant ce pilote, ajoutez intel_pstate=disable à votre ligne de noyau afin de revenir à l'utilisation du pilote acpi_cpufreq.\n- Le pilote amd_pstate Le pilote de mise à l'échelle de la puissance du processeur peut être activé manuellement s'il est pris en charge. Vérifiez d'abord si votre processeur et votre carte mère prennent en charge le CPPC : lscpu | grep \"cppc\", puis activez le chargement du module amd_pstate au démarrage.\n\ncpupower nécessite des modules pour connaître les limites du CPU natif :\n\nTable content:\nModule | Description\nintel_pstate | Ce pilote implémente un pilote de mise à l'échelle avec une politique interne pour les processeurs Intel Core (Sandy Bridge et plus récents).\namd_pstate | Ce pilote met en œuvre un pilote de mise à l'échelle avec un gouverneur interne pour les processeurs AMD Ryzen (certains Zen 2 et plus récents).\nintel_cufreq | A partir du noyau 5.7, le pilote de mise à l'échelle intel_pstate sélectionne le \"mode passif\" aka intel_cpufreq pour les CPU qui ne prennent pas en charge les P-states gérés par le matériel (HWP), c'est-à-dire les Intel Core i de 5ème génération ou plus anciens.\nacpi_cpufreq | Le pilote CPUFreq utilise les états de performance du processeur ACPI. Ce pilote prend également en charge l'Intel Enhanced SpeedStep (précédemment pris en charge par le module speedstep-centrino déprécié).\nspeedstep_lib | Pilote CPUFreq pour les processeurs Intel SpeedStep (principalement les Atoms et les anciens Pentiums).\npowernow_k8 | Pilote CPUFreq pour les processeurs Athlon 64/Opteron/Phenom K8/K10. Depuis Linux 3.7, 'acpi-cpufreq' sera automatiquement utilisé pour les processeurs AMD plus modernes.\npcc_cpufreq | Ce pilote prend en charge l'interface Processor Clocking Control de Hewlett-Packard et Microsoft Corporation, utile sur certains serveurs ProLiant.\np4_clockmod | Pilote CPUFreq pour les processeurs Intel Pentium 4/Xeon/Celeron qui réduit la température du processeur en sautant des horloges. (Vous voudrez probablement utiliser un pilote SpeedStep à la place).\n\nPour consulter la liste complète des modules disponibles, exécutez :\n\n```\n$ ls /usr/lib/modules/$(uname -r)/kernel/drivers/cpufreq/\n```\n\nChargez le module approprié (consultez Modules du noyau pour plus de détails). Une fois le pilote cpufreq approprié chargé, des informations détaillées sur le(s) CPU(s) peuvent être affichées en exécutant\n\n```\n$ cpupower frequency-info\n```\n\n"
    },
    {
      "title": "Réglage des fréquences maximales et minimales",
      "level": 3,
      "content": "Dans certains cas, il peut être nécessaire de définir manuellement les fréquences maximales et minimales.\n\nPour définir la fréquence d'horloge maximale ('clock_freq est une fréquence d'horloge avec des unités : GHz, MHz) :\n\n```\n# cpupower frequency-set -u clock_freq\n```\n\nPour définir la fréquence d'horloge minimale :\n\n```\n# cpupower frequency-set -d clock_freq\n```\n\nPour régler le CPU pour qu'il fonctionne à une fréquence spécifiée :\n\n```\n# cpupower frequency-set -f clock_freq\n```\n\n- Pour ajuster pour un seul coeur de CPU, ajoutez -c core_number.\n- La politique, les fréquences maximales et minimales peuvent être définis dans /etc/default/cpupower.\n\nAlternativement, vous pouvez définir la fréquence manuellement :\n\n```\n# echo valeur > /sys/devices/system/cpu/cpu*/cpufreq/scaling_max_freq\n```\n\nLes valeurs disponibles peuvent être trouvées dans /sys/devices/system/cpu/cpu*/cpufreq/scaling_available_frequencies ou similaire. [3]\n\n"
    },
    {
      "title": "Configuration de l'augmentation de fréquence",
      "level": 3,
      "content": "Certains processeurs prennent en charge l'élévation de leur fréquence au-dessus du maximum normal pendant une courte période de temps, dans des conditions thermiques appropriées. Sur les processeurs Intel, cela s'appelle Turbo Boost, et sur les processeurs AMD, cela s'appelle Turbo-Core.\n\n"
    },
    {
      "title": "Réglage via sysfs (intel_pstate)",
      "level": 4,
      "content": "intel_pstate possède une interface spécifique au pilote pour interdire au processeur d'entrer dans les états P turbo :\n\n```\n# echo 1 > /sys/devices/system/cpu/intel_pstate/no_turbo\n```\n\n"
    },
    {
      "title": "Réglage via sysfs (autres pilotes de mise à l'échelle)",
      "level": 4,
      "content": "Pour les pilotes de mise à l'échelle autres que intel_pstate, si le pilote prend en charge le boosting, l'attribut /sys/devices/system/cpu/cpufreq/boost sera présent et pourra être utilisé pour désactiver/activer le boosting :\n\n```\n# echo 0 > /sys/devices/system/cpu/cpufreq/boost\n```\n\n"
    },
    {
      "title": "Réglage via x86_energy_perf_policy",
      "level": 4,
      "content": "Sur les processeurs Intel, x86_energy_perf_policy peut également être utilisé pour configurer Turbo Boost :\n\n```\n# x86_energy_perf_policy --turbo-enable 0\n```\n\n"
    },
    {
      "title": "Politique de gestion",
      "level": 2,
      "content": "Les politiques de gestion sont des schémas de puissance qui déterminent la fréquence souhaitée pour le CPU. Certains demandent une fréquence constante, d'autres implémentent des algorithmes pour s'ajuster dynamiquement en fonction de la charge du système. Les politiques incluses dans le noyau sont les suivants :\n\nTable content:\nPolitique | Description\nperformance | Exécute le CPU à la fréquence maximale, obtenue à partir de /sys/devices/system/cpu/cpuX/cpufreq/scaling_max_freq.\npowersave | Lancez le processeur à la fréquence minimale, obtenue à partir de /sys/devices/system/cpu/cpuX/cpufreq/scaling_min_freq.\nuserspace | Exécuter le CPU à des fréquences spécifiées par l'utilisateur, configurables via /sys/devices/system/cpu/cpuX/cpufreq/scaling_setspeed.\nondemand | La mise à l'échelle de la fréquence se fait dynamiquement en fonction de la charge actuelle. Il passe à la fréquence la plus élevée et peut ensuite revenir en arrière au fur et à mesure que le temps d'inactivité augmente.\nconservative | Fait évoluer la fréquence de façon dynamique en fonction de la charge actuelle. La fréquence augmente plus progressivement qu'avec ondemand.\nschedutil | Sélection de la fréquence du CPU pilotée par l'ordonnanceur [4], [5].\n\nSelon le pilote fréquence, l'une de ces politiques sera chargé par défaut :\n\n- powersave pour les CPU Intel utilisant le pilote intel_pstate (Sandy Bridge et plus récents).\n- powersave (pour Linux < 5.10) ou schedutil (depuis Linux 5.10) pour les CPU utilisant le pilote acpi_cpufreq.\n\nPour activer une politique particulière, exécutez :\n\n```\n# cpupower frequency-set -g governor\n```\n\n- Pour régler un seul cœur de processeur, ajoutez -c core_number à la commande ci-dessus.\n- L'activation d'une politique nécessite un module noyau spécifique (nommé cpufreq_governor) chargé. Depuis le noyau 3.4, ces modules sont chargés automatiquement.\n\nAlternativement, vous pouvez activer manuellement une politique sur chaque CPU disponible :\n\n```\n# echo governor > /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor\n```\n\noù governor est le nom de la politique, mentionné dans le tableau ci-dessus, que vous souhaitez activer.\n\n```\n$ watch cat /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_cur_freq\n```\n\n"
    },
    {
      "title": "Réglage de la politique à la demande",
      "level": 3,
      "content": "Consultez la documentation du noyau pour plus de détails.\n\n"
    },
    {
      "title": "Seuil de commutation",
      "level": 4,
      "content": "Pour définir le seuil de passage à une autre fréquence :\n\n```\n# echo -n percent > /sys/devices/system/cpu/cpufreq/governor/up_threshold\n```\n\nPour définir le seuil pour descendre à une autre fréquence :\n\n```\n# echo -n percent > /sys/devices/system/cpu/cpufreq/governor/down_threshold\n```\n\n"
    },
    {
      "title": "Taux d'échantillonnage",
      "level": 4,
      "content": "Le taux d'échantillonnage détermine la fréquence à laquelle la politique vérifie le réglage de l'UC. sampling_down_factor est un paramètre qui multiplie le taux d'échantillonnage lorsque le CPU est à sa fréquence d'horloge la plus élevée, ce qui retarde l'évaluation de la charge et améliore les performances. Les valeurs autorisées pour sampling_down_factor sont de 1 à 100000. Ce paramètre n'a aucun effet sur le comportement à des fréquences/charges inférieures du CPU.\n\nPour lire la valeur (par défaut = 1), exécutez :\n\n```\n$ cat /sys/devices/system/cpu/cpufreq/ondemand/sampling_down_factor\n```\n\nPour définir la valeur, exécutez :\n\n```\n# echo -n valeur > /sys/devices/system/cpu/cpufreq/ondemand/sampling_down_factor\n```\n\n"
    },
    {
      "title": "Rendre les changements permanents",
      "level": 4,
      "content": "Pour avoir la mise à l'échelle désirée activée au démarrage, les options des modules du noyau et systemd-tmpfiles sont des méthodes classiques.\n\nPar exemple, en changeant la valeur de up_threshold à 10 :\n\n```\n/etc/tmpfiles.d/ondemand.conf\n```\n\n```\nw- /sys/devices/system/cpu/cpufreq/ondemand/up_threshold - - - - 10\n```\n\nCependant, comme indiqué dans systemd-tmpfiles, dans certains cas, des conditions de concurrence peuvent exister et on peut utiliser udev pour les éviter. Par exemple :\n\n```\n$ udevadm info -a /sys/devices/cpu\n```\n\n```\n...\n    KERNEL==\"cpu\"\n    SUBSYSTEM==\"event_source\"\n...\n```\n\n```\n/etc/udev/rules.d/cpu.rules\n```\n\n```\nKERNEL==\"cpu\", SUBSYSTEM==\"event_source\", ACTION==\"add\", RUN+=\"/bin/sh -c 'echo performance > /sys/devices/system/cpu/cpufreq/policy*/scaling_governor'\"\n```\n\n```\n$ udevadm test /sys/devices/cpu\n```\n\n```\n...\nReading rules file: /usr/lib/udev/rules.d/99-systemd.rules\nReading rules file: /etc/udev/rules.d/cpu.rules\n...\n```\n\nPour que la règle soit déjà appliquée dans le initramfs, ajoutez le fichier à votre mkinitcpio.conf, comme dans un exemple différent dans Udev (Français)#Sortie de débogage.\n\n- Depuis Linux 5.9, il est possible de configurer l'option noyau cpufreq.default_governor. https://kernelnewbies.org/Linux_5.9#CPU_Frequency_scaling]\n- Alternativement, configurez l'utilitaire cpupower et activez son service systemd.\n\n"
    },
    {
      "title": "Intel performance and energy bias hint",
      "level": 2,
      "content": "Le Intel performance and energy bias hint (EPB) est une interface fournie par les processeurs Intel pour permettre à l'utilisateur de spécifier le compromis puissance-performance souhaité, sur une échelle de 0 (performances maximales) à 15 (économies d'énergie maximales). Le registre EPB est une autre couche de gestion des performances fonctionnant indépendamment de l'échelle de fréquence. Il influence le degré d'agressivité de la sélection de l'état P et de l'état C, et informe la prise de décision interne spécifique au modèle qui affecte la consommation d'énergie.\n\nLes valeurs communes et leurs alias, tels que reconnus par sysfs et x86_energy_perf_policy sont :\n\nTable content:\nValeur EPB | Chaîne de caractères\n0 | performance\n4 | balance-performance\n6 | normal, default\n8 | balance-power\n15 | power\n\n"
    },
    {
      "title": "Paramétrage via sysfs",
      "level": 3,
      "content": "L'EPB peut être défini en utilisant un attribut sysfs :\n\n```\n# echo epb > /sys/devices/system/cpu/cpu*/power/energy_perf_bias\n```\n\n"
    },
    {
      "title": "Réglage via x86_energy_perf_policy",
      "level": 3,
      "content": "Avec x86_energy_perf_policy :\n\n```\n# x86_energy_perf_policy epb\n```\n\n"
    },
    {
      "title": "Réglage via cpupower",
      "level": 3,
      "content": "Avec cpupower :\n\n```\n# cpupower set -b epb_value\n```\n\n"
    },
    {
      "title": "Autres paramètres d'énergie x86",
      "level": 2,
      "content": "Activez les états P matériels avec x86_energy_perf_policy :\n\n```\n# x86_energy_perf_policy -H 1\n# x86_energy_perf_policy -U 1\n```\n\nDéfinir la politique \"par défaut\" :\n\nLes changements sont temporaires. Consultez x86_energy_perf_policy(8) pour plus d'informations.\n\n"
    },
    {
      "title": "Pilote d'inactivité du CPU",
      "level": 2,
      "content": "Le pilote d'inactivité du processeur intel_idle. est utilisé automatiquement pour les processeurs Intel modernes à la place du pilote acpi_idle. Ce pilote est actuellement utilisé automatiquement pour les CPU Sandy Bridge et plus récents. Le pilote intel_idle peut ignorer les paramètres C-State du BIOS. Si vous rencontrez un problème en utilisant ce pilote, ajoutez intel_idle.max_cstate=0 à la ligne de votre noyau.\n\n"
    },
    {
      "title": "Interaction avec les événements ACPI",
      "level": 2,
      "content": "Les utilisateurs peuvent configurer les politiques de mise à l'échelle pour qu'ils commutent automatiquement en fonction de différents événements ACPI tels que la connexion de l'adaptateur secteur ou la fermeture du couvercle d'un ordinateur portable. Un exemple rapide est donné ci-dessous, mais il peut être utile de lire l'article complet sur acpid.\n\nLes événements sont définis dans /etc/acpi/handler.sh. Si le paquet acpid est installé, le fichier devrait déjà exister et être exécutable. Par exemple, pour changer la politique de performance à conservative lorsque l'adaptateur secteur est déconnecté et le changer à nouveau s'il est reconnecté :\n\n```\n/etc/acpi/handler.sh\n```\n\n```\n[...]\n\nac_adapter)\n    case \"$2\" dans\n        AC*)\n            case \"$4\" dans\n                00000000)\n                    echo \"conservative\" >/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor    \n                    echo -n $minspeed >$setspeed\n                    #/etc/laptop-mode/laptop-mode start\n                ; ;\n                00000001)\n                    echo \"performance\" >/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor\n                    echo -n $maxspeed >$setspeed\n                    #/etc/laptop-mode/laptop-mode stop\n                ; ;\n            esac\n        ; ;\n        *) logger \"ACPI action undefined : $2\" ; ;\n    esac\n; ;\n\n[...]\n```\n\n"
    },
    {
      "title": "Dépannage",
      "level": 2,
      "content": "- Certaines applications, comme ntop, ne répondent pas bien à modification automatique de la fréquence. Dans le cas de ntop, cela peut entraîner des défauts de segmentation et beaucoup d'informations perdues, car même la politique on-demand ne peut pas changer la fréquence assez rapidement lorsqu'un grand nombre de paquets arrivent soudainement à l'interface réseau surveillée et ne peuvent pas être traités par la vitesse actuelle du processeur.\n\n- Certains processeurs peuvent présenter des performances médiocres avec les paramètres par défaut de la politique on-demand (par exemple, les vidéos Flash ne sont pas lues correctement ou les animations des fenêtres bégaient). Au lieu de désactiver complètement la mise à l'échelle de la fréquence pour résoudre ces problèmes, l'agressivité de la mise à l'échelle de la fréquence peut être augmentée en diminuant la variable sysctl up_threshold pour chaque CPU. Consultez comment modifier le seuil de la politique à la demande.\n\n- Parfois, la politique à la demande n'accélère pas à la fréquence maximale mais un cran en dessous. Cela peut être résolu en définissant la valeur max_freq légèrement plus élevée que le maximum réel. Par exemple, si la gamme de fréquence du CPU est de 2.00 GHz à 3.00 GHz, définir max_freq à 3.01 GHz peut être une bonne idée.\n\n- Certaines combinaisons de pilotes ALSA et de puces sonores peuvent provoquer des sauts audio lorsque la politique change de fréquence, le retour à une politique non changeant semble arrêter les sauts audio.\n\n"
    },
    {
      "title": "Limitation de fréquence du BIOS",
      "level": 3,
      "content": "Certaines configurations CPU/BIOS peuvent avoir des difficultés à passer à la fréquence maximale ou à passer à des fréquences plus élevées. Ceci est très probablement dû à des événements du BIOS indiquant au système d'exploitation de limiter la fréquence, ce qui a pour conséquence de définir /sys/devices/system/cpu/cpu0/cpufreq/bios_limit à une valeur inférieure.\n\nSoit vous avez effectué un réglage spécifique dans l'utilitaire de configuration du BIOS (fréquence, gestion thermique, etc.), soit vous pouvez accuser un BIOS bogué ou obsolète, soit le BIOS peut avoir une raison sérieuse d'étrangler le processeur de son propre chef.\n\nDe telles raisons peuvent être (en supposant que votre machine est un ordinateur portable) que la batterie est retirée (ou presque morte) et que vous n'avez que l'adaptateur secteur. Dans ce cas, une source de courant alternatif faible peut ne pas fournir assez d'électricité pour répondre aux demandes de pointe extrêmes de l'ensemble du système et, comme il n'y a pas de batterie pour aider, cela peut entraîner une perte de données, une corruption des données ou, dans le pire des cas, des dommages matériels !\n\nTous les BIOS ne limitent pas la fréquence du CPU dans ce cas, mais par exemple la plupart des Thinkpads IBM/Lenovo le font. Reportez-vous à thinkwiki pour plus d'informations sur ce sujet.\n\nSi vous avez vérifié qu'il ne s'agit pas simplement d'un réglage bizarre du BIOS et que vous savez ce que vous faites, vous pouvez faire en sorte que le noyau ignore ces limitations du BIOS.\n\nUn paramètre spécial doit être transmis au module processeur.\n\nPour essayer temporairement, changez la valeur dans /sys/module/processor/parameters/ignore_ppc de 0 à 1.\n\nPour le paramétrer de manière permanente, Kernel module (Français)#Définir les options du module décrit les alternatives. Par exemple, vous pouvez ajouter processor.ignore_ppc=1 à votre ligne de démarrage du noyau, ou créer\n\n```\n/etc/modprobe.d/ignore_ppc.conf\n```\n\n```\n# Si la fréquence de votre machine est limitée à tort par le BIOS, ceci devrait vous aider\noptions processeur ignore_ppc=1\n```\n\n"
    },
    {
      "title": "Voir aussi",
      "level": 2,
      "content": "- Documentation du noyau Linux pour CPUFreq\n- Post sur Reddit parlant de pstate\n- Contrôle du boost des processeurs\n- Documentation du noyau pour intel_pstate\n- Documentation du noyau pour amd-pstate\n- intel_pstate/intel_cpufreq documentation noyau 5.7+\n\n"
    }
  ]
}