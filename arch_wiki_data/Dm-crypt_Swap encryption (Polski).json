{
  "title": "Dm-crypt/Swap encryption (Polski)",
  "url": "https://wiki.archlinux.org/title/Dm-crypt/Swap_encryption_(Polski)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "W zależności od wymagań można zastosować różne metody szyfrowania partycji swap. które są opisane poniżej. Konfiguracja, w której szyfrowanie swapowe jest re-inicjalizowane przy ponownym uruchomieniu (z nowym szyfrowaniem) zapewnia lepszą ochronę danych, ponieważ pozwala uniknąć wrażliwych fragmentów plików, które mogły zostać zamienione dawno temu bez nadpisywania. Jednak ponowne szyfrowanie swapu również uniemożliwia korzystanie z hibernacji\n\n"
    },
    {
      "title": "Bez wsparcia dla hibernacji",
      "level": 2,
      "content": "W systemach, w których wykonuje się hibernację nie jest pożądaną funkcją, można ustawić /etc/crypttab aby odszyfrować partycję wymiany z losowym hasłem z zwykłym dm-crypt podczas startu systemu. Losowe hasło jest odrzucane podczas zamykania, pozostawiając tylko zaszyfrowane, niedostępne dane w urządzeniu wymiany.\n\nAby włączyć tę funkcję, po prostu odkomentuj linię zaczynającą się od swap w /etc/crypttab. Zmień parametr <device> na nazwę twojego urządzenia wymiany, na przykład będzie wyglądał mniej więcej tak:\n\n```\n/etc/crypttab\n```\n\n```\n# <name>  <device>     <password>     <options>\nswap      /dev/sdX#    /dev/urandom   swap,cipher=aes-xts-plain64,size=256\n```\n\nSpowoduje to mapowanie /dev/sdX# na /dev/mapper/swap jako partycję wymiany, która może być dodana w /etc/fstab jak zwykły swap. Jeśli wcześniej była nieszyfrowana partycja wymiany, nie zapomnij jej wyłączyć - lub użyj jej wpisu fstab, zmieniając urządzenie na /dev/mapper/swap. Domyślne opcje powinny być wystarczające dla większości zastosowań. Aby zapoznać się z innymi opcjami i objaśnieniem każdej kolumny, zobacz crypttab(5) oraz point cryptsetup FAQ 2.3.\n\n- Używaj ścieżek by-id i by-path. Oba są jednak podatne na zmiany sprzętowe. Zobacz Persistent block device naming#by-id and by-path.\n- Użyj nazwy woluminu logicznego LVM.\n- Użyj metody opisanej w #UUID i LABEL. Etykiety i UUIDS nie mogą być używane bezpośrednio ze względu na odtwarzanie i ponowne szyfrowanie urządzenia zamieniającego na każdym rozruchu z mkswap, zobacz https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions#2-setup cryptsetup FAQ].\n\nAby użyć stałego nazewnictwa urządzeń by-id zamiast zwykłego nazewnictwa jądra, najpierw należy zidentyfikować urządzenie wymiany:\n\n```\n# find -L /dev/disk -samefile /dev/sdaX\n```\n\n```\n/dev/disk/by-id/ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-partX\n/dev/disk/by-id/wwn-0x60015ee0000b237f-partX\n```\n\nNastępnie użyj jako trwałego odwołania dla partycji przykładowej /dev/sdX# (jeśli dwa wyniki zostaną zwrócone jak wyżej, wybierz jeden z nich):\n\n```\n/etc/crypttab\n```\n\n```\n# <name>  <device>                                                         <password>     <options>\nswap      /dev/disk/by-id/ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-partX  /dev/urandom   swap,cipher=aes-cbc-essiv:sha256,size=256\n```\n\nPo ponownym uruchomieniu, aby aktywować szyfrowaną wymianę, zauważysz, że uruchomione swapon -s pokazuje dla niego dowolny wpis mapowania urządzenia (np. /dev/dm-1, podczas gdy komenda lsblk pokazuje crypt w kolumnie FSTYPE. Ze względu na świeże szyfrowanie każdego rozruchu, UUID dla /dev/mapper/swap będzie się zmieniać za każdym razem.\n\n"
    },
    {
      "title": "UUID i LABEL",
      "level": 3,
      "content": "Niebezpieczne jest używanie zamiany przy użyciu crypttab z prostymi nazwami urządzeń jądra, takimi jak /dev/sdX# lub nawet /dev/disk/by-id/ata-SERIAL-partX Niewielka zmiana nazw urządzeń lub układu partycjonowania i /etc/crypttab spowoduje wyświetlenie cennych danych podczas następnego rozruchu. To samo, jeśli korzystasz z PARTUUID, a następnie decydujesz się użyć tej partycji na coś innego, nie usuwając najpierw wpisu cryptTab.\n\nBardziej wiarygodne jest zidentyfikowanie właściwej partycji przez nadanie jej prawdziwego identyfikatora UUID lub LABEL. Domyślnie to nie działa, ponieważ dm-crypt i mkswap po prostu nadpisują dowolną zawartość na tej partycji, która usunie również UUID i LABEL; jednak możliwe jest określenie przesunięcia wymiany. Pozwala to na utworzenie bardzo małego, pustego, fałszywego systemu plików, który nie ma innego celu niż zapewnienie trwałego identyfikatora UUID lub LABEL do szyfrowania swap.\n\nUtwórz system plików z etykietą do wyboru:\n\n```\n# mkfs.ext2 -L cryptswap /dev/sdX# 1M\n```\n\nNiezwykły parametr po nazwie urządzenia ogranicza rozmiar systemu plików do 1 MiB, pozostawiając miejsce na zaszyfrowaną wymianę za nim.\n\n```\n# blkid /dev/sdX#\n```\n\n```\n/dev/sdX#: LABEL=\"cryptswap\" UUID=\"b72c384e-bd3c-49aa-b7a7-a28ea81a2605\" TYPE=\"ext2\"\n```\n\nDzięki temu /dev/sdX# można łatwo zidentyfikować za pomocą UUID lub LABEL, niezależnie od tego, jak zmieni się nazwa urządzenia, a nawet numer partycji w przyszłości. Pozostały tylko pozycje /etc/crypttab i /etc/fstab:\n\n```\n/etc/crypttab\n```\n\n```\n# <name> <device>         <password>    <options>\nswap     LABEL=cryptswap  /dev/urandom  swap,offset=2048,cipher=aes-xts-plain64,size=512\n```\n\nZauważ przesunięcie: to 2048 sektorów po 512 bajtów, czyli 1 MiB. W ten sposób zaszyfrowana wymiana nie wpłynie na LABEL / UUID systemu plików, a wyrównanie danych również się uda.\n\n```\n/etc/fstab\n```\n\n```\n# <filesystem>    <dir>  <type>  <options>  <dump>  <pass>\n/dev/mapper/swap  none   swap    defaults   0       0\n```\n\nKorzystając z tej konfiguracji, cryptswap spróbuje użyć partycji z odpowiednim LABELEM, niezależnie od tego, jaka może być jego nazwa. Jeśli zdecydujesz się użyć partycji do czegoś innego, przez sformatowanie jej również zniknie etykieta Cryptswap LABEL, więc cryptswap nie zastąpi jej podczas następnego rozruchu.\n\n"
    },
    {
      "title": "Z obsługą hibernacji",
      "level": 2,
      "content": "Aby móc wznowić działanie po zawieszeniu komputera na dysku (hibernacja), należy zachować nienaruszoną przestrzeń wymiany. Dlatego wymagana jest wcześniejsza partycja wymiany LUKS lub plik, który można zapisać na dysku lub ręcznie wprowadzić przy uruchomieniu.\n\nNastępujące trzy metody są alternatywami do konfiguracji szyfrowanej wymiany dla hibernacji. Jeśli zastosujesz którąś z nich, pamiętaj, że krytyczne dane wymieniane przez system mogą potencjalnie pozostać w swapie przez długi okres (tj. Do momentu, gdy zostanie nadpisany). Aby zmniejszyć to ryzyko, rozważ utworzenie zadania systemowego, które ponownie szyfruje wymianę, np. za każdym razem, gdy system przechodzi do regularnego wyłączenia, wraz z wybraną metodą.\n\n"
    },
    {
      "title": "LVM na LUKS",
      "level": 3,
      "content": "Prostym sposobem na zrealizowanie szyfrowanej wymiany z obsługą suspend-to-disk jest użycie zamiennego urządzenia LVM na tej samej warstwie szyfrowania, co wolumin główny, dzięki czemu obie są otwierane podczas encrypt podczas startu. Postępuj zgodnie z instrukcjami na dm-crypt (Polski)/Encrypting an entire system (Polski)#LVM na LUKS a następnie po prostu skonfiguruj wymagane parametry jądra.\n\nZakładając, że ustawiłeś LVM na LUKS z woluminem logicznym swap (na przykład /dev/MyStorage/swap), wystarczy dodać wznowienie mkinitcpio hook i dodać parametr jądra resume=/dev/MyStorage/swap do swojego programu ładującego. W przypadku GRUB można to zrobić, dołączając ją do zmiennej GRUB_CMDLINE_LINUX_DEFAULT w /etc/default/grub.\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_CMDLINE_LINUX_DEFAULT=\"... resume=/dev/MyStorage/swap\"\n```\n\nnastępnie uruchom grub-mkconfig -o /boot/grub/grub.cfg aby zaktualizować plik konfiguracyjny GRUB. Aby dodać mkinitcpio hook, edytuj następujący wiersz w pliku mkinitcpio.conf\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nHOOKS=(... encrypt lvm2 resume ... filesystems ...)\n```\n\nnastępnie zregeneruj initramfs.\n\n"
    },
    {
      "title": "mkinitcpio hook",
      "level": 3,
      "content": "Jeśli urządzenie zamieniające znajduje się na innym urządzeniu niż w systemie plików root, nie zostanie otwarte przez encrypt hook, tzn. Wznowienie nastąpi przed użyciem /etc/crypttab, dlatego wymagane jest utworzenie haka w /etc/mkinitcpio.conf, aby otworzyć urządzenie LUKS wymiany przed wznowieniem.\n\nJeśli chcesz użyć partycji, która jest aktualnie używana przez system, musisz ją najpierw wyłączyć:\n\n```\n# swapoff /dev/<device>\n```\n\nUpewnij się także, że usuniesz linię z /etc/crypttab wskazującą na to urządzenie.\n\nJeśli używasz ponownie istniejącej partycji wymiany i jeśli partycja znajduje się w tabeli partycji GPT, musisz użyć gdisk, aby ustawić atrybut partycji 63 \"nie automount\" na nim. Zapobiegnie to wykrywaniu przez system-gpt-auto-generator i włączaniu partycji podczas rozruchu.\n\nPoniższa konfiguracja ma tę wadę, że podczas każdego rozruchu trzeba ręcznie wstawić dodatkowe hasło dla partycji wymiany.\n\nAby sformatować zaszyfrowany kontener dla partycji wymiany, utwórz klucz dla hasła użytkownika z pamięcią ustawień.\n\n```\n# cryptsetup luksFormat --type luks2 /dev/<device>\n```\n\nOtwórz partycję w /dev/mapper:\n\n```\n# cryptsetup open /dev/<device> swapDevice\n```\n\nUtwórz system plików wymiany wewnątrz zmapowanej partycji:\n\n```\n# mkswap /dev/mapper/swapDevice\n```\n\nTeraz musisz utworzyć hak, aby otworzyć swap podczas startu systemu. Możesz zainstalować i skonfigurować plik mkinitcpio-openswapAUR lub postępować zgodnie z poniższymi instrukcjami. Utwórz plik przechwytujący zawierający polecenie open:\n\n```\n/etc/initcpio/hooks/openswap\n```\n\n```\nrun_hook ()\n{\n    cryptsetup open /dev/<device> swapDevice\n}\n```\n\naby otworzyć urządzenie wymiany, wpisując hasło lub\n\n```\n/etc/initcpio/hooks/openswap\n```\n\n```\nrun_hook ()\n{\n    ## Optional: To avoid race conditions\n    x=0;\n    while [ ! -b /dev/mapper/<root-device> ] && [ $x -le 10 ]; do\n       x=$((x+1))\n       sleep .2\n    done\n    ## End of optional\n\n    mkdir crypto_key_device\n    mount /dev/mapper/<root-device> crypto_key_device\n    cryptsetup open --key-file crypto_key_device/<path-to-the-key> /dev/<device> swapDevice\n    umount crypto_key_device\n}\n```\n\ndo otwierania urządzenia wymiennego przez ładowanie pliku z zaszyfrowanego urządzenia root.\n\nNa niektórych komputerach mogą wystąpić warunki wyścigu, gdy mkinitcpio spróbuje zamontować urządzenie przed procesem odszyfrowywania i wyliczenie urządzenia zostanie zakończone. Skomentowany blok opcjonalny opóźni proces rozruchu do 2 sekund, dopóki urządzenie główne nie będzie gotowe do zamontowania.\n\nNastępnie utwórz i edytuj plik konfiguracyjny przechwytywania:\n\n```\n/etc/initcpio/install/openswap\n```\n\n```\nbuild ()\n{\n   add_runscript\n}\nhelp ()\n{\ncat<<HELPEOF\n  This opens the swap encrypted partition /dev/<device> in /dev/mapper/swapDevice\nHELPEOF\n}\n```\n\nDodaj hook openswap w tablicy HOOKS w pliku /etc/mkinitcpio.conf, przed filesystem ale po encrypt. Nie zapomnij dodać resume hak po openswap.\n\n```\nHOOKS=(... encrypt openswap resume filesystems ...)\n```\n\nRegenerate the initramfs.\n\nDodaj zmapowaną partycję do /etc/fstab, dodając następujący linie\n\n```\n/dev/mapper/swapDevice swap swap defaults 0 0\n```\n\nSkonfiguruj system, aby wznowić działanie z /dev/mapper/swapDevice. Na przykład, jeśli używasz GRUB-a z obsługą hibernacji jądra, dodaj parametr jądra resume=/dev/mapper/swapDevice do GRUB, dołączając go do zmiennej GRUB_CMDLINE_LINUX_DEFAULT w /etc/default/grub. Linia jądra z zaszyfrowanymi partycjami root i swap może wyglądać następująco:\n\n```\nkernel /vmlinuz-linux cryptdevice=/dev/sda2:rootDevice root=/dev/mapper/rootDevice resume=/dev/mapper/swapDevice ro\n```\n\nW czasie rozruchu hak openswap otworzy partycję wymiany, aby wznowić jądro. Jeśli używasz specjalnych haków do wznowienia ze stanu hibernacji, upewnij się, że są one umieszczone po openswap w tablicy HOOKS. Zauważ, że z powodu otwierania initrd, w tym przypadku nie ma wpisu dla swapDevice w /etc/crypttab.\n\n"
    },
    {
      "title": "Używanie pliku wymiany",
      "level": 3,
      "content": "Plik swap może być użyty do zarezerwowania przestrzeni wymiany w obrębie istniejącej partycji i może być również ustawiony na partycji zaszyfrowanego bloku blokowego. Po wznowieniu z pliku wymiany, hak resume musi zostać dostarczony z hasłem, aby odblokować urządzenie, w którym znajduje się plik wymiany.\n\nAby go utworzyć, najpierw wybierz zmapowaną partycję (np. /dev/mapper/rootDevice), której zamontowany system plików (np. /) Zawiera wystarczająco dużo wolnego miejsca, aby utworzyć plik wymiany o pożądanym rozmiarze.\n\nTeraz utwórz plik wymiany (np. /swapfile wewnątrz zamontowanego systemu plików wybranej zmapowanej partycji. Pamiętaj, aby aktywować go za pomocą swapon, a następnie dodać go do pliku /etc/fstab. Zauważ, że poprzednia zawartość pliku wymiany pozostaje przezroczysta po ponownym uruchomieniu.\n\nSkonfiguruj system, aby wznowić działanie z wybranej zmapowanej partycji. Na przykład, jeśli użyjesz GRUB-a z obsługą hibernacji jądra, dodaj resume= wybraną zmapowaną partycję i resume_offset= zobacz polecenie obliczania poniżej do linii jądra w twojej konfiguracji GRUB (zazwyczaj w /etc/default/grub). Linia z zaszyfrowaną partycją root może wyglądać następująco:\n\n```\nkernel /vmlinuz-linux cryptdevice=/dev/sda2:rootDevice root=/dev/mapper/rootDevice resume=/dev/mapper/rootDevice resume_offset=123456789 ro\n```\n\nresume_offset pliku wymiany wskazuje na początek (zakres zero) pliku i można go zidentyfikować w następujący sposób:\n\n```\n# filefrag -v /swapfile | awk '{if($1==\"0:\"){print $4}}'\n```\n\nDodaj hak do resume do pliku etc/mkinitcpio.conf i ponownie wygeneruj initramfs:\n\n```\nHOOKS=(... encrypt resume ... filesystems ...)\n```\n\nJeśli użyjesz klawiatury USB do wprowadzenia hasła odszyfrowania, moduł keyboard musi pojawić się przed hakiem do encrypt, jak pokazano poniżej. W przeciwnym razie nie będzie można uruchomić komputera, ponieważ nie można wprowadzić hasła deszyfrowania w celu odszyfrowania partycji root systemu Linux! (Jeśli nadal masz ten problem po dodaniu keyboard, wypróbuj usbinput, ale jest to przestarzałe).\n\n```\nHOOKS=(... keyboard encrypt ...)\n```\n\n"
    },
    {
      "title": "Znane problemy",
      "level": 2,
      "content": "- Stopped (with error) /dev/dm-1 in logs. See systemd issue 1620.\n\n"
    }
  ]
}