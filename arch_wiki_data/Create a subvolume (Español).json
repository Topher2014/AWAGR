{
  "title": "Create a subvolume (Español)",
  "url": "https://wiki.archlinux.org/title/Create_a_subvolume_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2022-10-28** \n\nArtículos relacionados\n\n- Sistemas de archivos\n- Cifrado de un sistema completo\n\nDe Btrfs Wiki:\n\n"
    },
    {
      "title": "Requisitos",
      "level": 2,
      "content": "Para utilidades de espacio de usuario instale el paquete btrfs-progs que se requiere para operaciones básicas.\n\nSi necesita arrancar desde un sistema de archivos Btrfs (por ejemplo su kernel e initramfs están en una partición Btrfs), revise si su gestor de arranque soporta Btrfs.\n\n"
    },
    {
      "title": "Creación del sistema de archivos",
      "level": 2,
      "content": "A continuación se muestra como crear un sistema de archivos Btrfs. Para convertir una partición ext3/4 a Btrfs, véase #Conversión de Ext3/4 a Btrfs. Para una instalación sin particiones, véase #Disco Btrfs sin particiones.\n\nVéase mkfs.btrfs(8) para más información.\n\n"
    },
    {
      "title": "Sistema de archivos en un único dispositivo",
      "level": 3,
      "content": "Para crear un sistema de archivos en la partición /dev/partición:\n\n```\n# mkfs.btrfs -L mietiqueta /dev/partición\n```\n\nEl tamaño de nodo (nodesize) para los metadatos por defecto es 16 KB, mientras que el tamaño de sector (sectorsize) predeterminado para los datos es igual al tamaño de página y se detecta automáticamente. Para usar un tamaño de nodo para metadatos más grande (debe ser múltiplo del tamaño de sector, se permite hasta 64KB), especifique un valor para el nodesize a través de -n como se muestra en este ejemplo usando bloques de 32KB:\n\n```\n# mkfs.btrfs -L mietiqueta -n 32k /dev/partición\n```\n\n"
    },
    {
      "title": "Sistema de archivos en múltiples dispositivos",
      "level": 3,
      "content": "Múltiples dispositivos pueden ser usados para crear un RAID. Niveles de Raid soportados incluyen RAID 0, RAID 1, RAID 10, RAID 5 y RAID 6. A partir del kernel 5.5 RAID1c3 y RAID1c4 para 3- y 4- copias del nivel RAID 1. Los niveles RAID pueden ser configurados por separado para los datos y metadatos usando las opciones -d y -m respectivamente. Por defecto los datos tienen una copia (single) y los metadatos están reflejados (raid1). Esto es similar a crear configuración de JBOD, donde los discos se ven como un sistema de archivos, pero los ficheros no están duplicados. Véase Usando Btrfs con múltiples dispositivos para mayor información acerca de como crear un volumen Btrfs RAID.\n\n```\n# mkfs.btrfs -d single -m raid1 /dev/part1 /dev/part2 ...\n```\n\nDebe incluir, ya sea el hook udev o el btrfs en /etc/mkinitcpio.conf para utilizar múltiples dispositivos Btrfs. Véase el artículo Mkinitcpio#Common hooks para más información.\n\n- Es posible añadir dispositivos en un sistema de archivos múltiple entonces. Véase este artículo de la wiki de Btrfs Para más información.\n- Los dispositivos pueden estar en diferentes tamaños. De todas formas, si una unidad en la configuración RAID es más grande que los otros, este espacio extra no se usará.\n- Algunos gestores de arranque como Syslinux no tienen soporte para sistemas de archivos con múltiples dispositivos.\n- Btrfs no lee automáticamente del dispositivo más rápido, así que mezclar distintos tipos de discos resulta en un rendimiento inconsistente. Mire [1] para más detalles.\n\nVéase #RAID para conseguir consejos en el mantenimiento específico a sistemas de archivos Btrfs de múltiples dispositivos.\n\n"
    },
    {
      "title": "Copy-on-Write (CoW)",
      "level": 3,
      "content": "Por defecto, Btrfs usa copy-on-write para todos los ficheros en todo momento. Las escrituras no sobrescriben los datos; en su lugar, se escribe una copia modificada del bloque en una nueva ubicación y los metadatos se actualizan para apuntar a la nueva ubicación. Véase la sección Guía Sysadmin de Btrfs para detalles de implementación, como también sus ventajas y desventajas.\n\n"
    },
    {
      "title": "Desactivar CoW",
      "level": 4,
      "content": "Para desactivar copy-on-write para ficheros recién creados en un subvolumen montado, use la opción de montaje nodatacow. Esto solamente afectará a ficheros recién creados. Copy-on-write todavía ocurrirá con archivos existentes. La opción nodatacow además desactiva la compresión. Véase btrfs(5) Para más detalles.\n\nPara desactivar el copy-on-write para ficheros/directorios únicos:\n\n```\n$ chattr +C /dir/file\n```\n\nEsto desactivará copy-on-write para aquellas operaciones en cuales solo haya una referencia al archivo. Si hay más de una referencia, por ejemplo debido a clonaciones / clonaciones ligeras o instantáneas del sistema de archivos, todavía se produce la copia en escritura. Tenga en cuenta que a partir de coreutils 9.0, cp intenta realizar copias ligeras de forma predeterminada; véase cp(1) para obtener más detalles.\n\n```\n$ mv /ruta/al/dir /ruta/al/dir_old\n$ mkdir /ruta/al/dir\n$ chattr +C /ruta/al/dir\n$ cp -a --reflink=never /ruta/al/dir_old/. /ruta/al/dir\n$ rm -rf /ruta/al/dir_old\n```\n\n"
    },
    {
      "title": "Compresión",
      "level": 3,
      "content": "Btrfs soporta compresión automática y transparente. Esto reduce el tamaño de los archivos como también aumenta significativamente la duración de medios basados en flash, reduciendo la amplificación de escritura. [2][3][4] También se puede mejorar el rendimiento, en algunos casos (por ejemplo hilo único con E/S de un archivo pesado), mientras que obviamente dañando el rendimiento en otros casos (por ejemplo multihilo y/o tareas intensivas de E/S de la CPU con un archivo grande). Un mejor rendimiento es generalmente logrado con algoritmos más rapidos de compresión como zstd y lzo, y algunos benchmarks proporcionan comparaciones detalladas.\n\nLZO tiene un nivel de compresión fijo, mientras que ZLIB y ZSTD tienen un rango de niveles de 1 (baja compresión) a 9 (ZLIB) o 15 (ZSTD)[5]. Cambiar los niveles afectará a la CPU y el rendimiento de E/S de manera diferente, por lo que deben verificarse / compararse antes y después de cambiar.\n\nLa opción de montaje compress=alg[:level] activa considerar automáticamente todos los archivos para compresión, donde alg ya sea zlib, lzo, zstd, o no (para no compresión). Usando esta opción, btrfs revisará si comprimiendo la primera porción de datos lo logra encoger. Si lo hace, la escritura entera del archivo será comprimida. Si no, Nada de eso se va a comprimir. Con esta opción, si la primera porción de la escritura no se encoge, la compresión no sera aplicada a la escritura incluso si el resto de la información encoje tremendamente. [6] Esto está hecho para prevenir que el disco espere para empezar a escribir hasta que todos los datos que se van a escribir estén en btrfs por completo y se compriman.\n\nLa opción de montaje compress-force=alg[:level] puede ser usada en su lugar, lo que hace que btrfs omita comprobar si la compresión encogió la primera porción, y activa de forma automática probar la compresión archivo por archivo. En el peor caso, esto puede causar (levemente) más consumo de la CPU sin propósito. En todo caso, pruebas empíricas en múltiples sistemas de uso mixto han mostrado una significativa mejora de al rededor del 10% de compresión de disco usando compress-force=zstd sobre solo compress=zstd, el cual también tenía una compresión de disco del 10%.\n\nSólo archivos creados o modificados después de la opción de montaje estarán comprimidos.\n\nPara aplicar compresión a archivos existentes, utilice la orden btrfs filesystem defragment -calg, cuando alg ya sea zlib, lzo o zstd. Por ejemplo, para volver a comprimir todo el sistema de archivos con zstd, ejecute la siguiente orden:\n\n```\n# btrfs filesystem defragment -r -v -czstd /\n```\n\nPara activar la compresión cuando instala Arch en una partición Btrfs vacía, use la opción compress al montar el sistema de archivos: mount -o compress=zstd /dev/sdxY /mnt/. Durante la configuración, añada compress=zstd a las opciones de montaje del sistema de archivos de root en fstab.\n\n- Sistemas que usan viejos kernels o btrfs-progs sin el soporte de zstd pueden ser incapaces de leer o reparar su sistema de archivos si usa esa opción.\n- GRUB introdujo el soporte de zstd en la versión 2.04. Actualice el gestor de arranque de su MBR/ESP ejecutando grub-install con las opciones apropiadas para su configuración BIOS/UEFI, ya que eso no lo hace automáticamente. Véase FS#63235.\n\n"
    },
    {
      "title": "Ver tipos y proporciones de compresión",
      "level": 4,
      "content": "compsize toma una lista de archivos (o el sistema de archivos btrfs entero) y mide los tipos de compresión usados y proporciones de compresión efectiva. El tamaño sin comprimir puede no coincidir con el número dado por otros programas como du(1), porque cada extensión se cuenta una vez, incluso si se refresca varias veces, e incluso si una parte de ella ya no se usa en ningún lado pero no se ha recogido basura. La opción -x la mantiene en un solo sistema de archivos, lo cual es útil en situaciones como compsize -x / para to evitar que intente buscar en subdirectorios que no sean btrfs y falle toda la ejecución.\n\n"
    },
    {
      "title": "Subvolúmenes",
      "level": 3,
      "content": "\"Un subvolumen de btrfs no es un dispositivo de bloque (ni debe ser tratado como uno) en lugar de eso, un subvolumen btrfs puede considerarse como un archivo de namespace POSIX. Estos namespace pueden ser accesibles vía el subvolumen de nivel superior del sistema de archivos, o puede ser montado por derecho propio\" [7]\n\nCada sistema de archivos Btrfs tiene un nivel superior de subvolumen con ID 5. Puede ser montada como / (por defecto), u otro subvolumen puede ser montado en vez de eso. Los subvolúmenes pueden moverse en el sistema de archivos y se identifican más por su ID que por su ruta.\n\nRevise los siguientes links para más detalles:\n\n- Btrfs Wiki SysadminGuide#Subvolumes\n- Btrfs Wiki Getting started#Basic Filesystem Commands\n- Btrfs Wiki Trees\n\n"
    },
    {
      "title": "Crear un subvolumen",
      "level": 4,
      "content": "Para crear un subvolumen:\n\n```\n# btrfs subvolume create /ruta/al/subvolumen\n```\n\n"
    },
    {
      "title": "Listar subvolúmenes",
      "level": 4,
      "content": "Para ver una lista de los subvolúmenes actuales y sus ID bajo ruta:\n\n```\n# btrfs subvolume list -p ruta\n```\n\n"
    },
    {
      "title": "Eliminar un subvolumen",
      "level": 4,
      "content": "Para eliminar un subvolumen:\n\n```\n# btrfs subvolume delete /ruta/al/subvolumen\n```\n\nDesde Linux 4.18, también se puede eliminar un subvolumen como un directorio regular (rm -r, rmdir).\n\n"
    },
    {
      "title": "Montar subvolúmenes",
      "level": 4,
      "content": "subvolúmenes pueden ser montados como particiones del sistema de archivos usando las flags subvol=/ruta/al/subvolumen o subvolid=objectid. Por ejemplo, puede tener un subvolumen llamado subvol_root y montarlo como /. Uno puede imitar las particiones tradicionales del sistema de archivos creando varios subvolúmenes en el nivel superior del sistema de archivos y luego montándolos en los puntos de montaje apropiados. Se pueden imitar las particiones tradicionales del sistema de archivos creando varios subvolúmenes en el nivel superior del sistema de archivos y luego montándolos en los puntos de montaje apropiados. Es preferible montar utilizando subvol=/ruta/al/subvolumen, en lugar del subvolid, ya que el subvolid puede cambiar al restaurar las #Instantáneas, lo que requiere un cambio de configuración de montaje.\n\nNote: **sistema de archivos entero** Véase Preguntas Frecuentes en la Wiki de Btrfs para cuales opciones pueden ser usadas por subvolumen.\n\nVéase Preguntas Frecuentes en la Wiki de Btrfs para cuales opciones pueden ser usadas por subvolumen.\n\nVéase Snapper#Suggested filesystem layout, Btrfs SysadminGuide#Managing Snapshots, y Btrfs SysadminGuide#Layout para ejemplos de diseños de sistemas de archivo que usan subvolúmenes.\n\nVéase btrfs(5) para una lista completa de opciones específicas de montado para btrfs.\n\n"
    },
    {
      "title": "Montar subvolumen en raíz",
      "level": 4,
      "content": "Para utilizar un subvolumen como punto de montaje raíz, especifique el subvolumen vía parámetros del kernel usando rootflags=subvol=/ruta/al/subvolumen. Edite el punto de montaje raíz en /etc/fstab y especifique el punto de montaje subvol=. Alternativamente el subvolumen puede ser pesecificado con su id, rootflags=subvolid=objectid como parámetro del kernel y subvolid=objectid como opción de montaje en /etc/fstab. Es preferible montar utilizando subvol=/ruta/al/subvolumen, en lugar del subvolid, ya que el subvolid puede cambiar al restaurar las #Instantáneas, lo que requiere un cambio de montar la configuración, de lo contrario el sistema no arrancará.\n\n"
    },
    {
      "title": "Cambiar el subvolumen por defecto",
      "level": 4,
      "content": "El subvolumen por defecto se monta si no se provee la opción de montado subvol=. Para cambiar el subvolumen por defecto, haga:\n\n```\n# btrfs subvolume set-default subvolume-id /\n```\n\ncuando subvolume-id sea encontrado listando.\n\nCambiando el subvolumen por defecto con btrfs subvolume set-default hará que el nivel superior del sistema de archivos sea inaccesible, excepto usando las opciones de montado subvol=/ o subvolid=5 [8].\n\n"
    },
    {
      "title": "Quota",
      "level": 3,
      "content": "El soporte de Quota en Btrfs se implementa al nivel de subvolumen por el uso de quota groups (grupos) o qgroup: Cada subvolumen es asignado a quota groups en forma de 0/subvolume_id por defecto. No obstante, es posible crear un quota group usando cualquier número si lo desea.\n\nPara usar qgroups necesita activar la quota primero, usando:\n\n```\n# btrfs quota enable ruta\n```\n\nA partir de este punto en adelante los subvolúmenes recién creados serán controlados por esos grupos. Con el fin de, retrospectivamente activelos para subvolúmenes existentes, active la quota normalmente, luego cree un qgroup (quota group) para cada uno de esos subvolúmenes usando subvolume_id y reescaneelos:\n\n```\n# btrfs subvolume list ruta | cut -d' ' -f2 | xargs -I{} -n1 btrfs qgroup create 0/{} ruta\n# btrfs quota rescan ruta\n```\n\nQuota groups en Btrfs forma una jerarquía de árbol, por lo cual qgroups está adjunto a los subvolúmenes. El tamaño límite se establece por qgroup y se aplican cuando cualquier límite del árbol que contenga un determinado subvolumen es alcanzado.\n\nLímites en quota groups pueden aplicarse al uso total de los datos, ya sea, uso no compartido, datos comprimidos o ambos. Eliminar y copiar archivos puede afectar los límites de ambos debido a que el límite no compartido de otro qgroup puede cambiar si los archivos del volumen original se eliminan y solo queda una copia. Por ejemplo, una nueva snapshot comparte casi todos los bloques con el subvolumen original, nuevas escrituras a cualquiera de los subvolúmenes hacia el límite exlusivo, eliminaciones de datos comunes en un volumen aumentan hacia el límite exclusivo en el otro.\n\nPara aplicar un límite a un grupo, utilice la orden btrfs qgroup limit. Dependiendo de su uso utilice un límite total, límite sin comprimir (-e) o límite comprimido (-c). Para ver utilización y límites de una ruta dada dentro del sistema de archivos\n\n```\n# btrfs qgroup show -reF ruta\n```\n\n"
    },
    {
      "title": "Intervalo de commit",
      "level": 3,
      "content": "La resolución de cuáles datos son escritos en el sistema de archivos es dictada por el mismo Btrfs y por los ajustes system-wide. Btrfs por defecto tiene 30 segundos de intervalo de punto de control en el cual nuevos datos son cometidos al sistema de archivos. Esto puede ser cambiado añadiendo la opción de montado commit en /etc/fstab para la partición btrfs.\n\n```\nLABEL=arch64 / btrfs defaults,compress=zstd,commit=120 0 0\n```\n\nAjustes en el sistema también afectan el intervalo de commits. Incluyen los archivos debajo de /proc/sys/vm/* y están fuera del foco de este artículo Wiki. La documentación del kernel sobre estos está disponible aquí.\n\n"
    },
    {
      "title": "SSD TRIM",
      "level": 3,
      "content": "Un sistema de archivos Btrfs es capaz de liberar bloques no utilizados de una unidad SSD que admita la orden TRIM. A partir de la versión del kernel 5.6 hay soporte de descarte asíncrono, activado con la opción de montado discard=async. Las extensiones libreadas no se descartan de inmediato, sino que se agrupan y recortan después por un subproceso de trabajo independiente, lo que mejora la latencia del commit.\n\nMás información sobre utilizar y activar TRIM está disponible en Solid State Drives (Español)#TRIM.\n\n"
    },
    {
      "title": "Archivo como espacio de intercambio",
      "level": 3,
      "content": "Btrfs soporta archivo como espacio de intercambio (swap) a partir del kernel de Linux 5.0.[9] La manera apropiada de iniciar un archivo como espacio de intercambio es primero crear un subvolumen sin instantánea para albergar el archivo y luego establecer el atributo No_COW en todo el directorio con chattr:\n\n```\n# chattr +C /ruta/al/subvolumendeintercambio\n```\n\nDe ahora en adelante, cualquier archivo nuevo creado dentro del subvolumen de intercambio tendrá el conjunto de atributos No_COW.\n\nContinúe con los siguientes pasos en Swap (Español)#Creación de archivos de intercambio. Configure la hibernación del archivo como espacio de intercambio como está descrito en Power management (Español)/Suspend and hibernate (Español)#Hibernar en un archivo swap.\n\n"
    },
    {
      "title": "Ver espacio usado/libre",
      "level": 3,
      "content": "Herramientas de espacio de usuario de linux como df(1) reportarán de forma incorrecta espacio libre en una partición Btrfs. Se recomienda usar btrfs filesystem usage para consultar particiones Btrfs. Por ejemplo, para un desglose completo de asignación de dispositivos y estadísticas de utilización:\n\n```\n# btrfs filesystem usage /\n```\n\nAlternativamente, btrfs filesystem df permite un vistazo rápido del uso del espacio asignado sin el requisito de ejecutarse como superusuario:\n\n```\n$ btrfs filesystem df /\n```\n\nVéase [10] para más información.\n\nLas mismas limitaciones se aplican a las herramientas que analizan el uso del espacio para algún subconjunto del sistema de archivos, como du(1) o ncdu(1), ya que no tienen en cuenta los enlaces de referencia, las instantáneas y la compresión. En su lugar, véase btduAUR y compsize para ver alternativas compatibles con btrfs.\n\n"
    },
    {
      "title": "Desfragmentación",
      "level": 3,
      "content": "Btrfs admite la desfragmentación en línea a través de la opción de montaje autodefrag, véase btrfs(5) § MOUNT OPTIONS. Para desfragmentar manualmente su raíz, utilice:\n\n```\n# btrfs filesystem defragment -r /\n```\n\nEl uso de la orden anterior sin el modificador -r dará como resultado que solo se desfragmenten los metadatos del subvolumen que contiene el directorio. Esto permite la desfragmentación de un solo archivo simplemente especificando la ruta.\n\n"
    },
    {
      "title": "RAID",
      "level": 3,
      "content": "Btrfs ofrece \"RAID\" nativo para sistemas de archivos en múltiples dispositivos. Las características notables que distinguen al RAID de btrfs de mdadm son las matrices redundantes de recuperación automática y el balance en línea. Véase la página wiki de Btrfs para obtener más información. La página de administración de sistemas de Btrfs también tiene una sección con más antecedentes técnicos.\n\n"
    },
    {
      "title": "Scrub",
      "level": 3,
      "content": "El Glosario de la Wiki de Btrfs[enlace roto 2023-04-22] dice que Btrfs Scrub es \"[una] herramienta de verificación de sistemas de archivos en línea. Lee todos los datos y metadatos en el sistema de archivos y utiliza sumas de verificación y las copias duplicadas del almacenamiento RAID para identificar y reparar cualquier dato corrupto\".\n\n"
    },
    {
      "title": "Iniciar manualmente",
      "level": 4,
      "content": "Para iniciar una limpieza (de fondo) en el sistema de archivos que contiene /:\n\n```\n# btrfs scrub start /\n```\n\nPara comprobar el estado de una limpieza en ejecución:\n\n```\n# btrfs scrub status /\n```\n\n"
    },
    {
      "title": "Iniciar con un servicio o temporizador",
      "level": 4,
      "content": "El paquete btrfs-progs trae la unidad btrfs-scrub@.timer para limpiar mensualmente el punto de montaje especificado. Active el temporizador con una ruta de escape, por ejemplo btrfs-scrub@-.timer para / y btrfs-scrub@home.timer para /home. Puede utilizar systemd-escape -p /ruta/al/punto/de/montaje para escapar la ruta; véase systemd-escape(1) para obtener más detalles.\n\nTambién puede ejecutar la limpieza iniciando btrfs-scrub@.service (con la misma ruta codificada). La ventaja de esto sobre btrfs scrub (como superusuario root) es que los resultados de la limpieza se registrarán en el registro de systemd.\n\nEn unidades NVMe grandes con refrigeración insuficiente (por ejemplo, en una computadora portátil), la limpieza puede leer la unidad lo suficientemente rápido y durante el tiempo suficiente para calentarla mucho. Si está ejecutando limpiezas con systemd, puede limitar fácilmente la tasa de limpieza con la opción IOReadBandwidthMax descrita en systemd.resource-control(5) usando un archivo insertado.\n\n"
    },
    {
      "title": "Balance",
      "level": 3,
      "content": "\"Un balance pasa todos los datos en el sistema de archivos a través del asignador nuevamente. Su objetivo principal es rebalancear los datos en el sistema de archivos entre los dispositivos cuando se agrega o elimina un dispositivo. Un balance regenerará las copias faltantes para los niveles RAID redundantes, si un el dispositivo ha fallado\". [13][enlace roto 2023-04-22] Véase Página de preguntas frecuentes de upstream.\n\nEn un sistema de archivos de un solo dispositivo, un balance también puede ser útil para (temporalmente) reducir la cantidad de fragmentos de (meta)datos asignados pero no utilizados. A veces, esto es necesario para arreglar problemas de \"sistema de archivos lleno\".\n\n```\n# btrfs balance start --bg /\n# btrfs balance status /\n```\n\n"
    },
    {
      "title": "Instantáneas",
      "level": 3,
      "content": "\"Una instantánea (snapshot) es simplemente un subvolumen que comparte sus datos (y metadatos) con algún otro subvolumen, utilizando las capacidades COW de btrfs\". Véase Btrfs Wiki SysadminGuide#Snapshots para obtener más información.\n\nPara crear una instantánea:\n\n```\n# btrfs subvolume snapshot fuente [destino/]nombre\n```\n\nPara crear una instantánea de solo lectura, añada -r. Para crear una versión de escritura de una instantánea de solo lectura, simplemente cree una instantánea de la misma.\n\n- Es posible convertir una instantánea de solo lectura a escritura. Sin embargo, esto no se recomienda porque causa problemas con cualquier envío/recepción incremental futuro. Crear una nueva instantánea grabable evita estos problemas.\n- Las instantáneas no son recursivas. Cada subvolumen anidado será un directorio vacío dentro de la instantánea.\n\n"
    },
    {
      "title": "Enviar/Recibir",
      "level": 3,
      "content": "Se puede enviar un subvolumen a la salida estándar o a un archivo mediante la orden send. Esto suele ser más útil cuando se canaliza a una orden receive de Btrfs. Por ejemplo, para enviar una instantánea llamada /root_backup (quizás de una instantánea que hizo de / anteriormente) a /backup, haga lo siguiente:\n\n```\n# btrfs send /root_backup | btrfs receive /backup\n```\n\nLa instantánea que se envía debe ser de solo lectura. La orden anterior es útil para copiar un subvolumen a un dispositivo externo (por ejemplo, un disco USB montado en /backup indicado antes).\n\nTambién puede enviar solo la diferencia entre dos instantáneas. Por ejemplo, si ya ha enviado una copia de root_backup y ha creado una nueva instantánea de solo lectura en su sistema llamada root_backup_new, entonces envíe solo la diferencia incremental a /backup mediante:\n\n```\n# btrfs send -p /root_backup /root_backup_new | btrfs receive /backup\n```\n\nAhora, un nuevo subvolumen llamado root_backup_new estará presente en /backup.\n\nVéase la página de copia de seguridad incremental en la Wiki de Btrfs y #Copia de seguridad incremental en disco externo sobre cómo utilizar esto para copias de seguridad incrementales y para las herramientas que automatizan el proceso.\n\n"
    },
    {
      "title": "Deduplicación",
      "level": 3,
      "content": "Utilizando Copy-on-Write, Btrfs puede copiar archivos o subvolúmenes completos sin copiar los datos. Sin embargo, cada vez que se modifica un archivo, se crea una nueva copia adecuada. La deduplicación lleva esto un paso más allá, identificando activamente bloques de datos que comparten secuencias comunes y combinándolos en una extensión con la misma semántica de copia en escritura.\n\nLas herramientas dedicadas a deduplicar una partición con formato Btrfs incluyen duperemove, bees, bedupAUR[enlace roto: package not found] y btrfs-dedup. También es posible que desee simplemente deduplicar datos en un nivel basado en archivos en lugar de utilizar, por ejemplo rmlint-gitAUR, jdupesAUR o dduper-gitAUR. Para obtener una descripción general de las funciones disponibles de esos programas e información adicional, véase upstream Wiki entry.\n\nAdemás, los desarrolladores de Btrfs están trabajando en la deduplicación en banda (también conocida como sincrónica o en línea), lo que significa que la deduplicación se realiza al escribir nuevos datos en el sistema de archivos. Actualmente sigue siendo algo experimental que se desarrolla fuera del árbol principal. Los usuarios que deseen probar la nueva función deben leer la página wiki del kernel correspondiente.\n\n"
    },
    {
      "title": "Cambio de tamaño",
      "level": 3,
      "content": "Puede hacer crecer un sistema de archivos hasta el espacio máximo disponible en el dispositivo o especificar un tamaño exacto. Asegúrese de aumentar el tamaño del dispositivo o volumen lógico antes de intentar aumentar el tamaño del sistema de archivos.\n\nAl especificar un tamaño exacto para el sistema de archivos en un dispositivo, ya sea aumentando o disminuyendo, asegúrese de que el nuevo tamaño cumpla las siguientes condiciones:\n\n- El nuevo tamaño debe ser mayor que el tamaño de los datos existentes; de lo contrario, se produce una pérdida de datos.\n- El nuevo tamaño debe ser igual o menor que el tamaño del dispositivo actual porque el tamaño del sistema de archivos no puede extenderse más allá del espacio disponible.\n\nPara extender el tamaño del sistema de archivos al tamaño máximo disponible del dispositivo:\n\n```\n# btrfs filesystem resize max /\n```\n\nPara extender el sistema de archivos a un tamaño específico:\n\n```\n# btrfs filesystem resize tamaño /\n```\n\nReemplace tamaño con el tamaño deseado en bytes. También puede especificar unidades en el valor, como K (kibibytes), M (mebibytes) o G (gibibytes). Como alternativa, puede especificar un aumento o disminución del tamaño actual anteponiendo el valor con un signo más (+) o menos (-), respectivamente:\n\n```\n# btrfs filesystem resize +tamaño /\n# btrfs filesystem resize -tamaño /\n```\n\n"
    },
    {
      "title": "Problemas conocidos",
      "level": 2,
      "content": "Se deben conocer algunas limitaciones antes de intentarlo.\n\n"
    },
    {
      "title": "Cifrado",
      "level": 3,
      "content": "Btrfs no tiene soporte de cifrado integrado, pero esto puede venir en el futuro. Los usuarios pueden cifrar la partición antes de ejecutar mkfs.btrfs. Véase dm-crypt (Español)/Encrypting an entire system (Español)#Subvolúmenes btrfs con espacio de intercambio.\n\nLos sistemas de archivos Btrfs existentes pueden utilizar algo como EncFS o TrueCrypt, aunque quizás sin algunas de las características de Btrfs.\n\n"
    },
    {
      "title": "Problemas de comprobación de btrfs",
      "level": 3,
      "content": "La herramienta btrfs check tiene problemas conocidos y no debe ejecutarse sin leer más; véase la sección #btrfs check.\n\n"
    },
    {
      "title": "Disco Btrfs sin particiones",
      "level": 3,
      "content": "Btrfs puede ocupar un dispositivo de almacenamiento de datos completo, reemplazando los esquemas de partición MBR o GPT, utilizando subvolúmenes para simular particiones. Sin embargo, no es necesario utilizar una configuración sin particiones para simplemente crear un sistema de archivos Btrfs en una partición existente que se creó con otro método. Existen algunas limitaciones para las configuraciones de un solo disco sin particiones:\n\n- No se pueden colocar otros sistemas de archivos en otra partición del mismo disco.\n- Debido al punto anterior, no es posible tener un ESP en este disco. Se necesita otro dispositivo para el arranque UEFI.\n- Si utiliza una versión del kernel de Linux anterior a la 5.0, no puede usar un espacio de intercambio ya que Btrfs no admitía un archivo como espacio de intercambioswap files anterior a 5.0 y no hay lugar para crear una partición como espacio de intercambio.\n\nPara sobrescribir la tabla de particiones existente con Btrfs, ejecute la siguiente orden:\n\n```\n# mkfs.btrfs /dev/sdX\n```\n\nPor ejemplo, utilice /dev/sda en lugar de /dev/sda1. Este último formatearía una partición existente en lugar de reemplazar todo el esquema de particiones. Debido a que la partición raíz es Btrfs, asegúrese de que btrfs esté compilado en el kernel, o coloque btrfs en mkinitcpio.conf#MODULES y regenere initramfs.\n\nInstale el gestor de arranque como lo haría con un dispositivo de almacenamiento de datos con un Registro de arranque maestro (MBR). Véase Syslinux#Manually o Instalar GRUB en un disco con o sin particiones. Si su kernel no arranca debido a Failed to mount /sysroot., añada GRUB_PRELOAD_MODULES=\"btrfs\" en /etc/default/grub y genere la configuración de GRUB.\n\n"
    },
    {
      "title": "Conversión de Ext3/4 a Btrfs",
      "level": 3,
      "content": "Arranque desde un CD de instalación, luego convierta haciendo:\n\n```\n# btrfs-convert /dev/partición\n```\n\nMonte la partición y pruebe la conversión comprobando los archivos. Asegúrese de cambiar /etc/fstab para reflejar el cambio (type a btrfs y fs_passno [el último campo] a 0 ya que Btrfs no realiza una comprobación del sistema de archivos en el arranque). También tenga en cuenta que el UUID de la partición habrá cambiado, así que actualice fstab en consecuencia cuando utilice UUID. Haga chroot en el sistema y reconstruya la lista de menú de su gestor de arranque (véase Instalar desde un Linux existente). Si está convirtiendo un sistema de archivos raíz (root), mientras aún está en chroot, ejecute mkinitcpio -p linux para regenerar initramfs, o el sistema no se iniciará correctamente.\n\nDespués de confirmar que no hay problemas, complete la conversión eliminando el subvolumen de copia de seguridad ext2_saved. Tenga en cuenta que no puede volver a Ext3/4 sin él.\n\n```\n# btrfs subvolume delete /ext2_saved\n```\n\nFinalmente balancee el sistema de archivos para recuperar el espacio.\n\nRecuerde que algunas aplicaciones que se instalaron previamente deben adaptarse a Btrfs.\n\n"
    },
    {
      "title": "Aceleración por hardware de la suma de comprobación",
      "level": 3,
      "content": "CRC32 es una nueva instrucción en Intel SSE4.2. Para verificar si la suma de comprobación de Btrfs está acelerada por hardware:\n\n```\n# dmesg | grep crc32c\n```\n\n```\nBtrfs loaded, crc32c=crc32c-intel\n```\n\nSi ve crc32c=crc32c-generic, probablemente se deba a que su partición raíz es Btrfs y tendrá que compilar crc32c-intel en el kernel para que funcione. Poner crc32c-intel en mkinitcpio.conf no funciona.\n\n"
    },
    {
      "title": "Recuperación de la corrupción",
      "level": 3,
      "content": "btrfs-check no se puede utilizar en un sistema de archivos montado. Para poder utilizar btrfs-check sin arrancar desde un USB en vivo, agréguelo al ramdisk inicial:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nBINARIES=(btrfs)\n```\n\nRegenere los initramfs.\n\nLuego, si hay un problema al arrancar, la utilidad está disponible para su reparación.\n\nVéase la página Wiki de Btrfs para obtener más información.\n\n"
    },
    {
      "title": "Arrancando en instantáneas",
      "level": 3,
      "content": "Para arrancar en una instantánea, se aplica el mismo procedimiento que para montar un subvolumen como su partición raíz, como se indica en la sección #Montar subvolumen en raíz, porque las instantáneas se pueden montar como subvolúmenes.\n\n- Si utiliza GRUB, puede completar automáticamente su menú de inicio con instantáneas de btrfs al regenerar el archivo de configuración con la ayuda de grub-btrfs o grub-btrfs-gitAUR.\n- Si utiliza rEFInd, puede completar automáticamente su menú de inicio con instantáneas btrfs con la ayuda de refind-btrfsAUR, después de activar refind-btrfs.service.\n\n"
    },
    {
      "title": "Utilizar subvolúmenes Btrfs con systemd-nspawn",
      "level": 3,
      "content": "Véase los artículos Systemd-nspawn#Use Btrfs subvolume as container root y Systemd-nspawn#Use temporary Btrfs snapshot of container.\n\n"
    },
    {
      "title": "Reducción de las actualizaciones del tiempo de acceso de los metadatos",
      "level": 3,
      "content": "Debido a la naturaleza copy-on-write de Btrfs, simplemente acceder a los archivos puede desencadenar la copia y escritura de metadatos. Reducir la frecuencia de las actualizaciones del tiempo de acceso puede eliminar este uso inesperado del disco y aumentar el rendimiento. Véase fstab (Español)#Opciones de atime para conocer las opciones disponibles.\n\n"
    },
    {
      "title": "Copia de seguridad incremental en disco externo",
      "level": 3,
      "content": "Los siguientes paquetes utilizan btrfs send y btrfs receive para enviar copias de seguridad de forma incremental a una unidad externa. Véase su documentación para las diferencias en la implementación, las características y los requisitos.\n\n- btrbk — Herramienta para crear instantáneas y copias de seguridad remotas de subvolúmenes Btrfs.\n\n- snap-sync — Utiliza instantáneas Snapper para realizar una copia de seguridad en una unidad externa o máquina remota.\n\n- snapsync — Una herramienta de sincronización para Snapper.\n\nEl siguiente paquete permite realizar copias de seguridad de instantáneas de Snapper en sistemas de archivos que no sean Btrfs.\n\n- snapborg — Herramienta similar a borgmatic que integra instantáneas de snapper con copias de seguridad borg.\n\n"
    },
    {
      "title": "Solución de problemas",
      "level": 2,
      "content": "Véase Preguntas frecuentes sobre problemas de Btrfs para obtener información general sobre la resolución de problemas.\n\n"
    },
    {
      "title": "Desplazamiento de la partición",
      "level": 4,
      "content": "El problema de desplazamiento (offset) puede ocurrir cuando intenta incrustar core.img en un disco particionado. Significa que está bien para incrustar core.img de GRUB en un grupo Btrfs en un disco sin partición (por ejemplo, /dev/sdX) directamente.\n\nGRUB puede iniciar particiones Btrfs, sin embargo, el módulo puede ser más grande que otros sistemas de archivos. Y es posible que el archivo core.img creado por grub-install no quepa en los primeros 63 sectores (31,5 KiB) de la unidad entre el MBR y la primera partición. Las herramientas de partición actualizadas como fdisk y gdisk evitan este problema desplazando la primera partición en aproximadamente 1MiB o 2MiB.\n\n"
    },
    {
      "title": "Raíz inexistente",
      "level": 4,
      "content": "Los usuarios que experimenten lo siguiente: error no such device: root al iniciar desde una configuración de tipo RAID, modifiquen /usr/share/grub/grub-mkconfig_lib y eliminen ambas comillas de la línea echo \" search --no-floppy --fs-uuid --set=root ${hints} ${fs_uuid}\". Vuelva a generar la configuración para grub y el sistema debería arrancar sin errores.\n\n"
    },
    {
      "title": "Tiempo de montaje agotado",
      "level": 3,
      "content": "A veces, especialmente con matrices RAID1 grandes, el montaje puede expirar durante el arranque con un mensaje de registro como:\n\n```\nJan 25 18:05:12 host systemd[1]: storage.mount: Mounting timed out. Terminating.\nJan 25 18:05:46 host systemd[1]: storage.mount: Mount process exited, code=killed, status=15/TERM\nJan 25 18:05:46 host systemd[1]: storage.mount: Failed with result 'timeout'.\nJan 25 18:05:46 host systemd[1]: Failed to mount /storage.\nJan 25 18:05:46 host systemd[1]: Startup finished in 32.943s (firmware) + 3.097s (loader) + 7.247s (kernel)>\nJan 25 18:05:46 host kernel: BTRFS error (device sda): open_ctree failed\n```\n\nEsto se puede solucionar fácilmente al proporcionar un tiempo de espera más largo a través de la opción de montaje específica de systemd x-systemd.mount-timeout en fstab. Por ejemplo:\n\n```\n/dev/sda      /storage    btrfs       rw,relatime,x-systemd.mount-timeout=5min  0 0\n```\n\n"
    },
    {
      "title": "BTRFS: open_ctree failed",
      "level": 3,
      "content": "A partir de noviembre de 2014, parece haber un error en systemd o mkinitcpio que causa el siguiente error en los sistemas con sistema de archivos Btrfs multidispositivo que utilizan el enlace btrfs en mkinitcpio.conf:\n\n```\nBTRFS: open_ctree failed\nmount: wrong fs type, bad option, bad superblock on /dev/sdb2, missing codepage or helper program, or other error\n\nIn some cases, useful info is found in syslog - try dmesg|tail or so.\n\nYou are now being dropped into an emergency shell.\n```\n\nUna solución consiste en eliminar btrfs de la matriz HOOKS en /etc/mkinitcpio.conf y, en su lugar, añadir btrfs a la matriz MODULES. Luego regenere initramfs y reinicie.\n\nObtendrá el mismo error si intenta montar una matriz RAID sin uno de los dispositivos. En ese caso, debe añadir la opción de montaje degraded a /etc/fstab. Si su raíz reside en la matriz, también debe añadir rootflags=degraded a sus parámetros del kernel.\n\nA partir de agosto de 2016, una posible solución para este error es montar la matriz en una sola unidad en /etc/fstab, y permitir que btrfs descubra y añada las otras unidades automáticamente. Los identificadores basados en grupos como UUID y LABEL parecen contribuir al fallo. Por ejemplo, una matriz RAID1 de dos dispositivos que consta de disco1 y disco2 tendrá un UUID asignado, pero en lugar de utilizar el UUID, use solo /dev/mapper/disk1 en /etc/fstab. Para obtener una explicación más detallada, véase la siguiente entrada de blog.\n\nOtra posible solución es eliminar el enlace udev en mkinitcpio.conf y reemplazarlo con el enlace systemd. En este caso, btrfs no debería estar en las matrices HOOKS o MODULES.\n\nVéase el hilo original de los foros y FS#42884 para obtener más información.\n\n"
    },
    {
      "title": "btrfs check",
      "level": 3,
      "content": "La orden btrfs-check(8) se puede utilizar para verificar o reparar un sistema de archivos Btrfs desmontado. Sin embargo, esta herramienta de reparación aún no está madura y no puede reparar ciertos errores del sistema de archivos, incluso aquellos que no hacen que el sistema de archivos no se pueda montar.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- Sitio oficial Wiki de Btrfs Documentación de Btrfs\n- Relacionado con el rendimiento ¿Btrfs en discos sin formato? Variando el tamaño de hoja y tamaño de nodo en Btrfs Soporte de Btrfs para un funcionamiento eficiente en SSD (alineación de bloques de datos) ¿Btrfs está optimizado para SSD? Evaluación comparativa de opciones de montura de Phoronix Linux 5.8 Linux 5.0 Linux 4.9 Linux 3.14 Linux 3.11 Linux 3.9 Linux 3.7 Linux 3.2 Lzo vs. zLib\n- Misceláneos Funtoo:BTRFS Fun Avi Miller presenting Btrfs at SCALE 10x, Enero 2012. Summary of Chris Mason's talk from LFCS 2012 Btrfs: stop providing a bmap operation to avoid swapfile corruptions 2009-01-21 Doing Fast Incremental Backups With Btrfs Send and Receive\n\n- Wiki de Btrfs\n- Documentación de Btrfs\n\n- ¿Btrfs en discos sin formato?\n- Variando el tamaño de hoja y tamaño de nodo en Btrfs\n- Soporte de Btrfs para un funcionamiento eficiente en SSD (alineación de bloques de datos)\n- ¿Btrfs está optimizado para SSD?\n- Evaluación comparativa de opciones de montura de Phoronix Linux 5.8 Linux 5.0 Linux 4.9 Linux 3.14 Linux 3.11 Linux 3.9 Linux 3.7 Linux 3.2\n- Lzo vs. zLib\n\n- Linux 5.8\n- Linux 5.0\n- Linux 4.9\n- Linux 3.14\n- Linux 3.11\n- Linux 3.9\n- Linux 3.7\n- Linux 3.2\n\n- Funtoo:BTRFS Fun\n- Avi Miller presenting Btrfs at SCALE 10x, Enero 2012.\n- Summary of Chris Mason's talk from LFCS 2012\n- Btrfs: stop providing a bmap operation to avoid swapfile corruptions 2009-01-21\n- Doing Fast Incremental Backups With Btrfs Send and Receive\n\n"
    }
  ]
}