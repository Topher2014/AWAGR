{
  "title": "Nftables (日本語)",
  "url": "https://wiki.archlinux.org/title/Nftables_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- iptables\n- Firewalld\n\nnftables は既存の ip-, ip6-, arp-, ebtables フレームワークを置き換える netfilter のプロジェクトです。新しいパケットフィルタリングフレームワーク、新しいユーザースペースユーティリティ (nft)、そして ip- と ip6tables の互換レイヤーを提供します。現行のフック、接続追跡システム、ユーザースペースのキューイングコンポーネント、そして netfilter のログサブシステムを使っています。\n\nnftables は3つのメインコンポーネントから構成されています: カーネルの実装、libnl netlink communication そして nftables ユーザースペースフロントエンド。カーネルは netlink の設定インターフェイスだけでなく、小さなクラス言語インタプリタを使用するランタイムのルールセットの評価も提供します。libnl にはカーネルと通信するためのローレベルな関数が含まれています。nftables フロントエンドはユーザーが対話するものです。\n\nnftables の公式 wiki には詳しい情報が載っています。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 使用方法 2.1 シンプルなファイアウォール\n- 3 設定 3.1 テーブル 3.1.1 テーブルの作成 3.1.2 テーブルの表示 3.1.3 テーブル内のチェインとルールの表示 3.1.4 テーブルの削除 3.1.5 テーブルのクリア 3.2 チェイン 3.2.1 チェインの作成 3.2.1.1 Regular チェイン 3.2.1.2 Base チェイン 3.2.2 ルールの表示 3.2.3 チェインの編集 3.2.4 チェインの削除 3.2.5 チェインのルールを消去 3.3 ルール 3.3.1 ルールの追加 3.3.1.1 表現 3.3.2 削除 3.4 アトミックリロード\n- 4 サンプル 4.1 ワークステーション 4.2 シンプルな IPv4/IPv6 ファイアウォール 4.3 レート制限 IPv4/IPv6 ファイアウォール 4.4 ジャンプ 4.5 インターフェイスによってルールを変える 4.6 マスカレード\n- 5 ヒントとテクニック 5.1 シンプルなステートフルファイアウォール 5.1.1 シングルマシン 5.2 ブルートフォース攻撃の対策\n- 6 トラブルシューティング 6.1 Docker と共に使う\n- 7 参照\n\n- 2.1 シンプルなファイアウォール\n\n- 3.1 テーブル 3.1.1 テーブルの作成 3.1.2 テーブルの表示 3.1.3 テーブル内のチェインとルールの表示 3.1.4 テーブルの削除 3.1.5 テーブルのクリア\n- 3.2 チェイン 3.2.1 チェインの作成 3.2.1.1 Regular チェイン 3.2.1.2 Base チェイン 3.2.2 ルールの表示 3.2.3 チェインの編集 3.2.4 チェインの削除 3.2.5 チェインのルールを消去\n- 3.3 ルール 3.3.1 ルールの追加 3.3.1.1 表現 3.3.2 削除\n- 3.4 アトミックリロード\n\n- 3.1.1 テーブルの作成\n- 3.1.2 テーブルの表示\n- 3.1.3 テーブル内のチェインとルールの表示\n- 3.1.4 テーブルの削除\n- 3.1.5 テーブルのクリア\n\n- 3.2.1 チェインの作成 3.2.1.1 Regular チェイン 3.2.1.2 Base チェイン\n- 3.2.2 ルールの表示\n- 3.2.3 チェインの編集\n- 3.2.4 チェインの削除\n- 3.2.5 チェインのルールを消去\n\n- 3.2.1.1 Regular チェイン\n- 3.2.1.2 Base チェイン\n\n- 3.3.1 ルールの追加 3.3.1.1 表現\n- 3.3.2 削除\n\n- 3.3.1.1 表現\n\n- 4.1 ワークステーション\n- 4.2 シンプルな IPv4/IPv6 ファイアウォール\n- 4.3 レート制限 IPv4/IPv6 ファイアウォール\n- 4.4 ジャンプ\n- 4.5 インターフェイスによってルールを変える\n- 4.6 マスカレード\n\n- 5.1 シンプルなステートフルファイアウォール 5.1.1 シングルマシン\n- 5.2 ブルートフォース攻撃の対策\n\n- 5.1.1 シングルマシン\n\n- 6.1 Docker と共に使う\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "nftables のユーザーランドユーティリティは nftables パッケージで利用できます。開発版の nftables-gitAUR パッケージも存在します。\n\n"
    },
    {
      "title": "使用方法",
      "level": 2,
      "content": "nftables ではコマンドラインで作成される一時的なルールと、ファイルに保存して読み込まれる永続的なルールを区別していません。デフォルトファイルの /etc/nftables.conf には \"inet filter\" という名前のシンプルな ipv4/ipv6 ファイアウォールテーブルが既に記述されています。\n\nnftables.service を起動・有効化してください。\n\n以下のコマンドでルールセットを確認できます:\n\n```\n# nft list ruleset\n```\n\n"
    },
    {
      "title": "シンプルなファイアウォール",
      "level": 3,
      "content": "​ nftables には、/etc/nftables.conf ファイルに保存されたシンプルで安全なファイアウォール設定が付属しています。 ​ nftables.service は、起動または有効化時に、このファイルからルールを読み込みます。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "nftables のユーザースペースユーティリティ nft は現在カーネルのためにルールセットを処理する前にほとんどのルールセットの評価を行います。ルールはチェインに保存され、チェインはテーブルに保存されます。下のセクションではルールを作成・編集する方法を説明します。\n\n下のセクションで行った変更は全て一時的なものになります。変更を永続化するにはルールセットを /etc/nftables.conf に保存してください (ルールセットは nftables.service によって読み込まれます):\n\n```\n# nft list ruleset > /etc/nftables.conf\n```\n\nファイルから入力するには -f フラグを使用します:\n\n```\n# nft -f filename\n```\n\nロード済みのルールは自動的に消去されることはないので注意してください。\n\n利用可能なコマンドの一覧は nft(8) を参照してください。\n\n"
    },
    {
      "title": "テーブル",
      "level": 3,
      "content": "テーブルはチェインを保持します。iptables のテーブルと違って、nftables には初めから組み込まれているテーブルはありません。テーブルの数や名前はユーザーが自由に決めることができますが、各テーブルにはアドレスファミリーをひとつしか保持することができません。5つのファミリーのうち指定したファミリーのパケットにだけ適用されます:\n\nTable content:\nnftables ファミリー | iptables ユーティリティ\nip | iptables\nip6 | ip6tables\ninet | iptables と ip6tables\narp | arptables\nbridge | ebtables\n\nip (IPv4) がデフォルトのファミリーです。特に指定がなければ ip が使われます。\n\nIPv4 と IPv6 の両方に適用されるルールを作成するには inet を使います。inet を使うには Linux 3.15 以上が必要で、ip と ip6 ファミリーを統一してルールを簡単に定義できます。\n\nアドレスフファミリーの完全な定義は nft(8) の ADDRESS FAMILIES セクションを参照してください。\n\n以下で例示しているコマンドの family は全て任意であり、指定しなかった場合は ip が使われます。\n\n"
    },
    {
      "title": "テーブルの作成",
      "level": 4,
      "content": "以下のコマンドで新しいテーブルが追加されます:\n\n```\n# nft add table family table\n```\n\n"
    },
    {
      "title": "テーブルの表示",
      "level": 4,
      "content": "全てのテーブルを表示するには:\n\n```\n# nft list tables\n```\n\n"
    },
    {
      "title": "テーブル内のチェインとルールの表示",
      "level": 4,
      "content": "指定したテーブルの全てのチェインとルールを表示するには:\n\n```\n# nft list table family table\n```\n\n例えば inet ファミリーの filter テーブルのルールを全て表示するには:\n\n```\n# nft list table inet filter\n```\n\n"
    },
    {
      "title": "テーブルの削除",
      "level": 4,
      "content": "テーブルを削除するには:\n\n```\n# nft delete table family table\n```\n\nテーブルはチェインが全く存在しない場合にのみ削除できます。\n\n"
    },
    {
      "title": "テーブルのクリア",
      "level": 4,
      "content": "テーブルから全てのルールを消去するには:\n\n```\n# nft flush table family table\n```\n\n"
    },
    {
      "title": "チェイン",
      "level": 3,
      "content": "チェインの用途はルールを保持することです。iptables のチェインと違って、nftables には初めから組み込まれているチェインはありません。そのためチェインが netfilter フレームワークにあるタイプやフックをどれも使わない場合、iptables とは異なりチェインを通り抜けるパケットは nftables の影響を受けません。\n\nチェインには2つのタイプがあります。base チェインはネットワークスタックからのパケットのエントリポイントとなります。フックの値を指定することができます。regular チェインはジャンプターゲットとして使用することができます。\n\n以下のコマンドで使っている family は全て任意であり、指定しなかった場合は ip が使われます。\n\n"
    },
    {
      "title": "チェインの作成",
      "level": 4,
      "content": "以下のコマンドは table という名前のテーブルに chain という名前のレギュラーチェインを追加します:\n\n```\n# nft add chain family table chain\n```\n\n例えば、inet アドレスファミリーの filter テーブルに tcpchain という名前のレギュラーチェインを追加するには:\n\n```\n# nft add chain inet filter tcpchain\n```\n\nベースチェインを追加するにはフックとプライオリティの値を指定します:\n\n```\n# nft add chain family table chain { type type hook hook priority priority \\; }\n```\n\ntype は filter, route, nat のどれかから選ぶことができます。\n\nIPv4/IPv6/Inet アドレスファミリーでは hook は prerouting, input, forward, output, postrouting のどれかになります。他のファミリーのフックについては nft(8) を参照してください。\n\npriority には整数値を指定します。低い値のチェインが先に処理され、負の値を指定することもできます [3]。\n\n例えば、input パケットをフィルタリングするベースチェインを追加するには:\n\n```\n# nft add chain inet filter input { type filter hook input priority 0\\; }\n```\n\nadd を create に置き換えると、チェインが既に存在するときにエラーが返ってくるようになります。\n\n"
    },
    {
      "title": "ルールの表示",
      "level": 4,
      "content": "以下のコマンドでチェインの全てのルールを表示できます:\n\n```\n# nft list chain family table chain\n```\n\n例えば、filter という名前の inet テーブルに存在する output という名前のチェインのルールを表示するには:\n\n```\n# nft list chain inet filter output\n```\n\n"
    },
    {
      "title": "チェインの編集",
      "level": 4,
      "content": "チェインを編集したいときは、チェインの名前を指定して変更したいルールを定義します:\n\n```\n# nft chain <table> <family> <chain> { [ type <type> hook <hook> device <device> priority <priority> \\; policy <policy> \\; ] }\n```\n\n例えば、デフォルトテーブルの input チェインポリシーを \"accept\" から \"drop\" に変更したい場合:\n\n```\n# nft chain inet filter input { policy drop \\; }\n```\n\n"
    },
    {
      "title": "チェインの削除",
      "level": 4,
      "content": "チェインを削除するには:\n\n```\n# nft delete chain family table chain\n```\n\n削除するチェインにはルールやジャンプターゲットが含まれていてはいけません。\n\n"
    },
    {
      "title": "チェインのルールを消去",
      "level": 4,
      "content": "チェインからルールを消去するには:\n\n```\n# nft flush chain family table chain\n```\n\n"
    },
    {
      "title": "ルール",
      "level": 3,
      "content": "ルールは表現または宣言から構成され、チェインの中に格納されます。\n\n"
    },
    {
      "title": "ルールの追加",
      "level": 4,
      "content": "チェインにルールを追加するには:\n\n```\n# nft add rule family table chain position statement\n```\n\nルールは position に追加されます。位置は指定しなくてもかまいません。指定しなかった場合、ルールはチェインの末尾に追加されます。\n\n特定の位置の前にルールを追加するには:\n\n```\n# nft insert rule family table chain position statement\n```\n\nposition を指定しなかった場合、ルールはチェインの一番前に追加されます。\n\nstatement にはマッチする表現と判断宣言が入ります。判断宣言には accept, drop, queue, continue, return, jump chain, goto chain などが存在します。判断宣言以外の宣言も指定できます。詳しくは nft(8) を参照してください。\n\nnftables では様々な表現を使うことができ、ほとんどは、iptables と対応するようになっています。一番大きな違いは汎用的なマッチと暗黙的なマッチが存在しないことです。汎用的なマッチとは、--protocol や --source のように、いつでも使うことができるマッチで、暗黙的なマッチとは、--sport のように、特定のプロトコルでしか使えないマッチのことです。\n\n以下は利用できるマッチの一部です:\n\n- meta (メタプロパティ。例: インターフェイス)\n- icmp (ICMP プロトコル)\n- icmpv6 (ICMPv6 プロトコル)\n- ip (IP プロトコル)\n- ip6 (IPv6 プロトコル)\n- tcp (TCP プロトコル)\n- udp (UDP プロトコル)\n- sctp (SCTP プロトコル)\n- ct (接続のトラッキング)\n\n以下はマッチ引数の一部です (完全なリストは nft(8) を見て下さい):\n\n```\nmeta:\n  oif <output interface INDEX>\n  iif <input interface INDEX>\n  oifname <output interface NAME>\n  iifname <input interface NAME>\n\n  (oif and iif accept string arguments and are converted to interface indexes)\n  (oifname and iifname are more dynamic, but slower because of string matching)\n\nicmp:\n  type <icmp type>\n\nicmpv6:\n  type <icmpv6 type>\n\nip:\n  protocol <protocol>\n  daddr <destination address>\n  saddr <source address>\n\nip6:\n  daddr <destination address>\n  saddr <source address>\n\ntcp:\n  dport <destination port>\n  sport <source port>\n\nudp:\n  dport <destination port>\n  sport <source port>\n\nsctp:\n  dport <destination port>\n  sport <source port>\n\nct:\n  state <new | established | related | invalid>\n```\n\n"
    },
    {
      "title": "削除",
      "level": 4,
      "content": "個々のルールはハンドルを使わないと削除することができません。nft --handle list コマンドを使うことでルールのハンドルを確認できます。--handle スイッチを付けると、nft はハンドルを出力するようになります。\n\n以下ではルールのハンドルを確認してルールを削除しています。未解決の IP アドレスのような、数字の出力を表示するときは --number 引数を使うと良いでしょう。\n\n```\n# nft --handle --numeric list chain filter input\n```\n\n```\ntable ip fltrTable {\n     chain input {\n          type filter hook input priority 0;\n          ip saddr 127.0.0.1 accept # handle 10\n     }\n}\n```\n\n```\n# nft delete rule fltrTable input handle 10\n```\n\nnft flush table コマンドを使うことでテーブルの全てのチェインをフラッシュできます。個別のチェインをフラッシュするときは nft flush chain または nft delete rule コマンドを使います。\n\n```\n# nft flush table foo\n# nft flush chain foo bar\n# nft delete rule ip6 foo bar\n```\n\n最初のコマンドでは ip foo テーブルのチェイン全てをフラッシュします。2番目のコマンドは ip foo テーブルの bar チェインをフラッシュします。3番目のコマンドは ip6 foo テーブルの bar チェインの全てのルールを削除します。\n\n"
    },
    {
      "title": "アトミックリロード",
      "level": 3,
      "content": "現在のルールセットをフラッシュする:\n\n```\n# echo \"flush ruleset\" > /tmp/nftables\n```\n\n現在のルールセットをダンプする:\n\n```\n# nft list ruleset >> /tmp/nftables\n```\n\n/tmp/nftables を編集して次のコマンドで変更を適用:\n\n```\n# nft -f /tmp/nftables\n```\n\n"
    },
    {
      "title": "ワークステーション",
      "level": 3,
      "content": "```\n/etc/nftables.conf\n```\n\n```\nflush ruleset\n\ntable inet filter {\n        chain input {\n                type filter hook input priority 0;\n\n                # accept any localhost traffic\n                iif lo accept\n\n                # accept traffic originated from us\n                ct state established,related accept\n\n                # activate the following line to accept common local services\n                #tcp dport { 22, 80, 443 } ct state new accept\n\n                # accept neighbour discovery otherwise IPv6 connectivity breaks.\n                ip6 nexthdr icmpv6 icmpv6 type { nd-neighbor-solicit,  nd-router-advert, nd-neighbor-advert } accept\n\n                # count and drop any other traffic\n                counter drop\n        }\n}\n```\n\n"
    },
    {
      "title": "シンプルな IPv4/IPv6 ファイアウォール",
      "level": 3,
      "content": "```\nfirewall.rules\n```\n\n```\n# A simple firewall\n\nflush ruleset\n\ntable inet filter {\n\tchain input {\n\t\ttype filter hook input priority 0; policy drop;\n\n\t\t# established/related connections\n\t\tct state established,related accept\n\n\t\t# invalid connections\n\t\tct state invalid drop\n\t\t\n\t\t# loopback interface\n\t\tiif lo accept\n\n\t\t# ICMP\n\t\t# routers may also want: mld-listener-query, nd-router-solicit\n\t\tip6 nexthdr icmpv6 icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem, nd-router-advert, nd-neighbor-solicit, nd-neighbor-advert } accept\n\t\tip protocol icmp icmp type { destination-unreachable, router-advertisement, time-exceeded, parameter-problem } accept\n\n\t\t# SSH (port 22)\n\t\ttcp dport ssh accept\n\n\t\t# HTTP (ports 80 & 443)\n\t\ttcp dport { http, https } accept\n\t}\n\n\tchain forward {\n\t\ttype filter hook forward priority 0; policy drop;\n\t}\n\n\tchain output {\n\t\ttype filter hook output priority 0; policy accept;\n\t}\n\n}\n```\n\n"
    },
    {
      "title": "レート制限 IPv4/IPv6 ファイアウォール",
      "level": 3,
      "content": "```\nfirewall.2.rules\n```\n\n```\ntable inet filter {\n\tchain input {\n\t\ttype filter hook input priority 0; policy drop;\n\n\t\t# no ping floods:\n\t\tip6 nexthdr icmpv6 icmpv6 type echo-request limit rate 10/second accept\n\t\tip protocol icmp icmp type echo-request limit rate 10/second accept\n\n\t\tct state established,related accept\n\t\tct state invalid drop\n\n\t\tiif lo accept\n\n\t\t# avoid brute force on ssh:\n\t\ttcp dport ssh limit rate 15/minute accept\n\n\t}\n\n\tchain forward {\n\t\ttype filter hook forward priority 0; policy drop;\n\t}\n\n\tchain output {\n\t\ttype filter hook output priority 0; policy accept;\n\t}\n\n}\n```\n\n"
    },
    {
      "title": "ジャンプ",
      "level": 3,
      "content": "設定ファイルでジャンプを使うときは、先にターゲットチェインを定義する必要があります。そうしないと Error: Could not process rule: No such file or directory というエラーが発生します。\n\n```\njump.rules\n```\n\n```\ntable inet filter {\n    chain web {\n        tcp dport http accept\n        tcp dport 8080 accept\n    }\n    chain input {\n        type filter hook input priority 0;\n        ip saddr 10.0.2.0/24 jump web\n        drop\n    }\n}\n```\n\n"
    },
    {
      "title": "インターフェイスによってルールを変える",
      "level": 3,
      "content": "複数のネットワークインターフェイスが存在する場合、それぞれのインターフェイスごとに別々のフィルターチェインを設定したい場合があるかもしれません。例えば、ホームルーターを構築するとき、LAN 上でアクセスできるウェブサーバーを実行しつつ (nsp3s0 インターフェイス)、インターネットからはアクセスできないようにしたい場合 (enp2s0 インターフェイス) などは以下のように設定します:\n\n```\ntable inet filter {\n  chain input { # this chain serves as a dispatcher\n    type filter hook input priority 0;\n\n    iif lo accept # always accept loopback\n    iifname enp2s0 jump input_enp2s0\n    iifname enp3s0 jump input_enp3s0\n\n    reject with icmp type port-unreachable # refuse traffic from all other interfaces\n  }\n  chain input_enp2s0 { # rules applicable to public interface interface\n    ct state {established,related} accept\n    ct state invalid drop\n    udp dport bootpc accept\n    tcp dport bootpc accept\n    reject with icmp type port-unreachable # all other traffic\n  }\n  chain input_enp3s0 {\n    ct state {established,related} accept\n    ct state invalid drop\n    udp dport bootpc accept\n    tcp dport bootpc accept\n    tcp port http accept\n    tcp port https accept\n    reject with icmp type port-unreachable # all other traffic\n  }\n  chain ouput { # we let everything out\n    type filter hook output priority 0;\n    accept\n  }\n }\n```\n\nもしくは iifname ステートメントを特定のインターフェイスで使用して、他のインターフェイスについてはデフォルトルールを設定するという方法もあります。\n\n"
    },
    {
      "title": "マスカレード",
      "level": 3,
      "content": "nftables には特殊なキーワード masquerade が存在し、送信元アドレスが自動的に出力インターフェイスのアドレスに設定されます (ソース)。ルーターのインターフェイスが多数の ISP に接続されているときなど、インターフェイスの IP アドレスが一定でない場合に有用です。通常は、インターフェイスの IP アドレスが変わるたびにネットワークアドレス変換 (NAT) のルールを更新する必要があります。\n\nmasquerade を使用するには:\n\n- カーネルコンフィグで以下のマスカレード設定が有効になっている必要があります。\n\n```\nCONFIG_NFT_MASQ=m\n```\n\n- masquerade キーワードは nat タイプのチェインでのみ使うことができ、inet ファミリーのテーブルでは利用できません。ip ファミリーや ip6 ファミリーのテーブルを使ってください。\n- マスカレードは一種のソース NAT であり、出力パスでのみ機能します。\n\n2つのインターフェイスが存在し nsp3s0 が LAN に接続され、enp2s0 がインターネットに接続されているマシンでの設定例:\n\n```\ntable ip nat {\n  chain prerouting {\n    type nat hook prerouting priority 0;\n  }\n  chain postrouting {\n    type nat hook postrouting priority 0;\n    oifname \"enp0s2\" masquerade\n  }\n}\n```\n\n"
    },
    {
      "title": "シンプルなステートフルファイアウォール",
      "level": 3,
      "content": "シンプルなステートフルファイアウォールの記事も参照してください。\n\n"
    },
    {
      "title": "シングルマシン",
      "level": 4,
      "content": "現在のルールセットを消去:\n\n```\n# nft flush ruleset\n```\n\nテーブルを追加:\n\n```\n# nft add table inet filter\n```\n\ninput, forward, output ベースチェインを追加。input と forward のポリシーは破棄にして、output のポリシーは許可にする:\n\n```\n# nft add chain inet filter input { type filter hook input priority 0 \\; policy drop \\; }\n# nft add chain inet filter forward { type filter hook forward priority 0 \\; policy drop \\; }\n# nft add chain inet filter output { type filter hook output priority 0 \\; policy accept \\; }\n```\n\nレギュラーチェインを追加して tcp と udp に関連付ける:\n\n```\n# nft add chain inet filter TCP\n# nft add chain inet filter UDP\n```\n\n関連・確立済みトラフィックは許可する:\n\n```\n# nft add rule inet filter input ct state related,established accept\n```\n\nループバックインターフェイスのトラフィックは全て許可する:\n\n```\n# nft add rule inet filter input iif lo accept\n```\n\n不正なトラフィックは全て破棄する:\n\n```\n# nft add rule inet filter input ct state invalid drop\n```\n\n新しいエコー要求 (ping) は許可する:\n\n```\n# nft add rule inet filter input ip protocol icmp icmp type echo-request ct state new accept\n```\n\n新しい udp トラフィックは UDP チェインにジャンプする:\n\n```\n# nft add rule inet filter input ip protocol udp ct state new jump UDP\n```\n\n新しい tcp トラフィックは TCP チェインにジャンプする:\n\n```\n# nft add rule inet filter input ip protocol tcp tcp flags \\& \\(fin\\|syn\\|rst\\|ack\\) == syn ct state new jump TCP\n```\n\n他のルールによって処理されなかったトラフィックは全て拒否する:\n\n```\n# nft add rule inet filter input ip protocol udp reject\n# nft add rule inet filter input ip protocol tcp reject with tcp reset\n# nft add rule inet filter input counter reject with icmp type prot-unreachable\n```\n\nここから TCP と UDP チェインで処理する接続で開きたいポートを決めます。例えばウェブサーバーの接続を開くには:\n\n```\n# nft add rule inet filter TCP tcp dport 80 accept\n```\n\nポート 443 からのウェブサーバーの HTTPS 接続を許可するには:\n\n```\n# nft add rule inet filter TCP tcp dport 443 accept\n```\n\nポート 22 の SSH 接続を許可するには:\n\n```\n# nft add rule inet filter TCP tcp dport 22 accept\n```\n\nDNS リクエストを許可するには:\n\n```\n# nft add rule inet filter TCP tcp dport 53 accept\n# nft add rule inet filter UDP tcp dport 53 accept\n```\n\n設定に満足したら変更を保存して永続化させてください。\n\n"
    },
    {
      "title": "ブルートフォース攻撃の対策",
      "level": 3,
      "content": "Sshguard はブルートフォース攻撃を検出して一時的に IP アドレスに基づきブロックするようにファイアウォールを編集します。Sshguard で nftables を使うように設定する方法は Sshguard#nftables を見てください。\n\n"
    },
    {
      "title": "Docker と共に使う",
      "level": 3,
      "content": "- 次のセットアップでは、--net host --privileged を使用してもコンテナ内で AF_BLUETOOTH などのプロトコルを利用できなくなります。\n- Rootless Dockerコンテナはすでに別のネットワーク名前空間で実行されています。何もする必要がないかもしれません。\n\nnftables を使用すると、Docker のネットワーク (おそらく他のコンテナランタイムも同様) に干渉する可能性があります。 iptables ルールにパッチを適用して定義されたサービス開始順序を確保するか、docker の使用が非常に制限される dockerのiptablesの管理を完全に無効にするなど、さまざまな回避策がインターネット上で見つかります。 (ポートフォワーディングや docker-compose を考えてください)\n\n信頼できる方法は、docker を別のネットワーク名前空間で実行させ、そこで任意の処理を実行できるようにすることです。 Docker が nftables と iptables ルールを混在させないように、iptables-nft を使用しない方が良いでしょう。\n\n以下の docker サービス ドロップインファイル を使用してください:\n\n```\n/etc/systemd/system/docker.service.d/netns.conf\n```\n\n```\n[Service]\nPrivateNetwork=yes\n\n# cleanup\nExecStartPre=-nsenter -t 1 -n -- ip link delete docker0\n\n# add veth\nExecStartPre=nsenter -t 1 -n -- ip link add docker0 type veth peer name docker0_ns\nExecStartPre=sh -c 'nsenter -t 1 -n -- ip link set docker0_ns netns \"$$BASHPID\" && true'\nExecStartPre=ip link set docker0_ns name eth0\n\n# bring host online\nExecStartPre=nsenter -t 1 -n -- ip addr add 10.0.0.1/24 dev docker0\nExecStartPre=nsenter -t 1 -n -- ip link set docker0 up\n\n# bring ns online\nExecStartPre=ip addr add 10.0.0.100/24 dev eth0\nExecStartPre=ip link set eth0 up\nExecStartPre=ip route add default via 10.0.0.1 dev eth0\n```\n\nセットアップにおいてIPアドレス 10.0.0.* が適切でない場合は、調整してください。\n\n以下のポストルーティングルールで、docker0 のIPフォワーディングを有効にし、NATを設定します:\n\n```\niifname docker0 oifname eth0 masquerade\n```\n\n次に、kernel IP forwarding が有効になっていることを確認します。\n\nこれで、nftables を使用して docker0 インターフェイスのファイアウォールとポートフォワーディングを干渉することなくセットアップできるようになります。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- netfilter nftables wiki\n- nftables の最初のリリース\n- nftables クイックハウツー\n- nftables の帰還\n- What comes after ‘iptables’? It’s successor, of course: `nftables`\n\n"
    }
  ]
}