{
  "title": "Ranger (Español)",
  "url": "https://wiki.archlinux.org/title/Ranger_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2019-12-05** \n\nArtículos relacionados\n\n- Midnight Commander\n- nnn\n- vifm\n\nranger es un administrador de archivos basado en texto, escrito en Python. Los directorios se muestran en un panel con tres columnas. Moverse entre ellos se logra pulsando teclas, marcadores, el ratón o el historial de órdenes. Las vistas previas de los archivos y el contenido de los directorios se muestran automáticamente con la selección actual.\n\nLas características incluyen: combinaciones de teclas de estilo vi, marcadores, selecciones, etiquetado, pestañas, historial de órdenes, la capacidad de crear enlaces simbólicos, varios modos de consola y una vista de tareas. ranger tiene órdenes personalizables y definiciones de teclas, incluidos enlaces a scripts externos. ranger también viene con su propia función de apertura de archivos, rifle(1). Los competidores más cercanos son Vifm y lf.\n\n"
    },
    {
      "title": "Instalación",
      "level": 2,
      "content": "Instale el paquete ranger, o ranger-gitAUR para la versión de desarrollo.\n\n"
    },
    {
      "title": "Utilización",
      "level": 2,
      "content": "Para iniciar ranger, lance un terminal e invoque ranger.\n\nTable content:\nClave | Orden\n? | Abre el manual o enumera las combinaciones de teclas, órdenes y configuraciones\nl, Intro | Lanza archivos\nj, k | Selecciona archivos en el directorio actual\nh, l | Viaja arriba y abajo en el árbol de directorios\n\n"
    },
    {
      "title": "Configuración",
      "level": 2,
      "content": "Después de iniciarse, ranger crea un directorio ~/.config/ranger.Para copiar la configuración predeterminada a este directorio, emita la siguiente orden:\n\n```\n$ ranger --copy-config=all\n```\n\n- rc.conf — órdenes de inicio y combinaciones de teclas.\n- commands.py — órdenes que se inician con :.\n- rifle.conf — aplicaciones que se utilizan cuando se lanza un tipo de archivo determinado.\n\nrc.conf solo necesita incluir cambios desde el archivo predeterminado, ya que ambos están cargados. Para commands.py, si no incluye el archivo íntegro, coloque esta línea en la parte superior:\n\n```\nfrom ranger.api.commands import *\n```\n\nVea ranger(1) para conocer la configuración general.\n\n"
    },
    {
      "title": "Mover a la papelera",
      "level": 3,
      "content": "Para agregar una combinación de teclas que mueva archivos a su directorio de reciclaje ~/.local/share/Trash/files/ con DD, añada a ~/.config/ranger/rc.conf:\n\n```\nmap DD shell mv %s /home/${USER}/.local/share/Trash/files/\n```\n\nAlternativamente, use la herramienta de línea de órdenes GIO proporcionada por el paquete glib2:\n\n```\nmap DD shell gio trash %s\n```\n\nLa inspección y el vaciado de la «papelera» normalmente son compatibles con los administradores de archivos gráficos como nautilus, pero también puede ver la papelera con la orden gio list trash://, y vaciarla con: gio trash --empty.\n\n"
    },
    {
      "title": "Definir órdenes",
      "level": 3,
      "content": "Continuando con el ejemplo anterior, añada la siguiente entrada a ~/.config/ranger/commands.py para vaciar la papelera ~/.Trash.\n\n```\nclass empty(Command):\n    \"\"\":empty\n\n    Empties the trash directory ~/.Trash\n    \"\"\"\n\n    def execute(self):\n        self.fm.run(\"rm -rf /home/myname/.Trash/{*,.[^.]*}\")\n```\n\nPara usarla, escriba :empty e Intro con obtener el completado por tabulación según se desee.\n\n"
    },
    {
      "title": "Esquemas de color",
      "level": 3,
      "content": "ranger viene con cuatro esquemas de color: default, jungle, snow y solarized. Puede cambiar su combinación de colores usando:\n\n```\nset colorscheme scheme\n```\n\nLos esquemas de color personalizados se pueden colocar en ~/.config/ranger/colorschemes.\n\n"
    },
    {
      "title": "Asociación de archivos",
      "level": 3,
      "content": "ranger usa su propio lanzador de archivos llamado rifle. Está configurado en ~/.config/ranger/rifle.conf. Ejecute ranger --copy-config=rifle, si no existe. Por ejemplo, la siguiente línea hace que kile sea el programa predeterminado para archivos tex:\n\n```\next tex = kile \"$@\"\n```\n\nPara abrir todos los archivos con xdg-utils, asegúrese de que $EDITOR y $PAGER estén configurados y añadidos:\n\n```\nelse = xdg-open \"$1\"\nlabel editor = \"$EDITOR\" -- \"$@\"\nlabel pager  = \"$PAGER\" -- \"$@\"\n```\n\n"
    },
    {
      "title": "Archivar",
      "level": 3,
      "content": "Estas órdenes usan atool para realizar operaciones de archivo.\n\n"
    },
    {
      "title": "Extracción de archivos",
      "level": 4,
      "content": "La siguiente orden implementa la extracción de archivos copiando (yy) uno o más archivos y luego ejecutando :extracthere en el directorio deseado.\n\n```\nimport os\nfrom ranger.core.loader import CommandLoader\n\nclass extracthere(Command):\n    def execute(self):\n        \"\"\" Extract copied files to current directory \"\"\"\n        copied_files = tuple(self.fm.copy_buffer)\n\n        if not copied_files:\n            return\n\n        def refresh(_):\n            cwd = self.fm.get_directory(original_path)\n            cwd.load_content()\n\n        one_file = copied_files[0]\n        cwd = self.fm.thisdir\n        original_path = cwd.path\n        au_flags = ['-X', cwd.path]\n        au_flags += self.line.split()[1:]\n        au_flags += ['-e']\n\n        self.fm.copy_buffer.clear()\n        self.fm.cut_buffer = False\n        if len(copied_files) == 1:\n            descr = \"extracting: \" + os.path.basename(one_file.path)\n        else:\n            descr = \"extracting files from: \" + os.path.basename(one_file.dirname)\n        obj = CommandLoader(args=['aunpack'] + au_flags \\\n                + [f.path for f in copied_files], descr=descr, read=True)\n\n        obj.signal_bind('after', refresh)\n        self.fm.loader.add(obj)\n```\n\n"
    },
    {
      "title": "Compresión",
      "level": 4,
      "content": "La siguiente orden permite a los usuarios comprimir varios archivos en el directorio actual marcándolos y luego llamando a :compress package name. Admite sugerencias de nombres al obtener el nombre base del directorio actual y agregar varias posibilidades para la extensión. Debe tener instalado atool, de lo contrario, verá un mensaje de error cuando cree el archivo comprimido.\n\n```\nimport os\nfrom ranger.core.loader import CommandLoader\n\nclass compress(Command):\n    def execute(self):\n        \"\"\" Compress marked files to current directory \"\"\"\n        cwd = self.fm.thisdir\n        marked_files = cwd.get_selection()\n\n        if not marked_files:\n            return\n\n        def refresh(_):\n            cwd = self.fm.get_directory(original_path)\n            cwd.load_content()\n\n        original_path = cwd.path\n        parts = self.line.split()\n        au_flags = parts[1:]\n\n        descr = \"compressing files in: \" + os.path.basename(parts[1])\n        obj = CommandLoader(args=['apack'] + au_flags + \\\n                [os.path.relpath(f.path, cwd.path) for f in marked_files], descr=descr, read=True)\n\n        obj.signal_bind('after', refresh)\n        self.fm.loader.add(obj)\n\n    def tab(self, tabnum):\n        \"\"\" Complete with current folder name \"\"\"\n\n        extension = ['.zip', '.tar.gz', '.rar', '.7z']\n        return ['compress ' + os.path.basename(self.fm.thisdir.path) + ext for ext in extension]\n```\n\n"
    },
    {
      "title": "Unidades externas",
      "level": 3,
      "content": "Las unidades externas se pueden montar automáticamente con udev o udisks. Unidades montadas en /media Se puede acceder fácilmente a las unidades montadas con gm (ir a /media).\n\n"
    },
    {
      "title": "Archivos ocultos",
      "level": 3,
      "content": "Puede alternar la visibilidad de los archivos ocultos con la siguiente orden: :set show_hidden!, o utilizar :set show_hidden true para hacer visibles los archivos ocultos.\n\nPara hacer esto permanente, agregue dicho ajuste en su archivo de configuración:\n\n```\nrc.conf\n```\n\n```\nset show_hidden true\n```\n\nDe otro modo, los archivos ocultos se pueden alternar presionando zh.\n\n"
    },
    {
      "title": "Montar imágenes",
      "level": 3,
      "content": "La siguiente orden asume que está utilizando CDemu como su montador de imágenes y algún tipo de sistema como autofs que monta el disco virtual en una ubicación específica («/media/virtualrom» en este caso). No olvide cambiar mountpath para reflejar la configuración de su sistema.\n\nPara montar una imagen (o imágenes) en un disco virtual cdemud desde ranger, seleccione los archivos de imágenes y luego escriba «:mount» en la consola. El montaje puede tardar algo de tiempo dependiendo de su configuración (algunos pueden tardar hasta un minuto), por lo que la orden usa un cargador personalizado que espera hasta que se monte el directorio de montaje y luego lo abre en segundo plano en la pestaña 9.\n\n```\nimport os, time\nfrom ranger.core.loader import Loadable\nfrom ranger.ext.signals import SignalDispatcher\nfrom ranger.ext.shell_escape import *\n\nclass MountLoader(Loadable, SignalDispatcher):\n    \"\"\"\n    Wait until a directory is mounted\n    \"\"\"\n    def __init__(self, path):\n        SignalDispatcher.__init__(self)\n        descr = \"Waiting for dir '\" + path + \"' to be mounted\"\n        Loadable.__init__(self, self.generate(), descr)\n        self.path = path\n\n    def generate(self):\n        available = False\n        while not available:\n            try:\n                if os.path.ismount(self.path):\n                    available = True\n            except:\n                pass\n            yield\n            time.sleep(0.03)\n        self.signal_emit('after')\n\nclass mount(Command):\n    def execute(self):\n        selected_files = self.fm.thisdir.get_selection()\n\n        if not selected_files:\n            return\n\n        space = ' '\n        self.fm.execute_command(\"cdemu -b system unload 0\")\n        self.fm.execute_command(\"cdemu -b system load 0 \" + \\\n                space.join([shell_escape(f.path) for f in selected_files]))\n\n        mountpath = \"/media/virtualrom/\"\n\n        def mount_finished(path):\n            currenttab = self.fm.current_tab\n            self.fm.tab_open(9, mountpath)\n            self.fm.tab_open(currenttab)\n\n        obj = MountLoader(mountpath)\n        obj.signal_bind('after', mount_finished)\n        self.fm.loader.add(obj)\n```\n\n"
    },
    {
      "title": "Nueva pestaña en la carpeta actual",
      "level": 3,
      "content": "Es posible que haya notado que hay dos métodos abreviados para abrir una nueva pestaña (gn y Ctrl+n). Vuelva a vincular Ctrl+n:\n\n```\nrc.conf\n```\n\n```\nmap <c-n>  eval fm.tab_new('%d')\n```\n\n"
    },
    {
      "title": "Vista previa del archivo PDF",
      "level": 3,
      "content": "Por defecto, ranger previsualizará los archivos PDF como texto. Sin embargo, puede obtener una vista previa de los archivos PDF como una imagen en ranger convirtiendo primero el archivo PDF en una imagen. ranger almacena las vistas previas de imágenes en ~/.cache/ranger/. Debe crear este directorio manualmente o establecer preview_images en true en ~/.config/ranger/rc.conf para indicarle a ranger que lo cree automáticamente en el próximo inicio. Sin embargo, tenga en cuenta que preview_images no necesita establecerse en true todo el tiempo para obtener una vista previa del archivo PDF como imágenes, solo se necesita el directorio ~/.cache/ranger.\n\nPara activar esta función, descomente las líneas apropiadas en /usr/share/doc/ranger/config/scope.sh, o agregue/descomente estas líneas en su archivo local ~/.config/ranger/scope.sh.\n\n"
    },
    {
      "title": "Sincronizar ruta",
      "level": 4,
      "content": "ranger proporciona un función para el intérprete de órdenes /usr/share/doc/ranger/examples/bash_automatic_cd.sh. Ejecute ranger-cd en lugar de ranger que realizará automáticamente cd a la última carpeta examinada.\n\nSi inicia ranger desde un lanzador gráfico (como $TERMCMD -e ranger, donde TERMCMD es un terminal de X), no puede usar ranger-cd. En su lugar, cree un script ejecutable:\n\n```\nranger-launcher.sh\n```\n\n```\n#!/bin/sh\nexport RANGERCD=true\n$TERMCMD\n```\n\nY agregue lo siguiente al final de la configuración de su intérprete de órdenes:\n\n```\n.shellrc\n```\n\n```\n$RANGERCD && unset RANGERCD && ranger-cd\n```\n\nEsto lanzará ranger-cd solo si se establece la variable RANGERCD. Es importante desarmar (con la función «unset») esta variable nuevamente, de lo contrario, al iniciar otro intérprete de órdenes desde este terminal, se volverá a lanzar automáticamente ranger.\n\n"
    },
    {
      "title": "Iniciar un intérprete de órdenes desde ranger",
      "level": 4,
      "content": "Con el método anterior, puede cambiar a un intérprete de órdenes en la última ruta explorada simplemente dejando ranger. Sin embargo, es posible que no desee abandonar ranger por varias razones (numerosas pestañas abiertas, copia en progreso, etc.). Puede iniciar otro intérprete de órdenes con (S por defecto) sin perder su sesión de ranger. Desafortunadamente, el intérprete de órdenes no cambiará a la carpeta actual automáticamente. Nuevamente, esto se puede resolver con un script ejecutable:\n\n```\nshellcd\n```\n\n```\n#!/bin/sh\nexport AUTOCD=\"$(realpath \"$1\")\"\n\n$SHELL\n```\n\ny, como antes, agregue esto al final de la configuración del intérprete de órdenes:\n\n```\nshellrc\n```\n\n```\ncd \"$AUTOCD\"\n```\n\nAhora puede cambiar su enlace del intérprete de órdenes para ranger:\n\n```\nrc.conf\n```\n\n```\nmap S shell shellcd %d\n```\n\nAlternativamente, puede hacer uso de su archivo de historial del intérprete de órdenes si tiene uno. Por ejemplo, puede hacer esto para zsh:\n\n```\nshellcd\n```\n\n```\n## Prepend argument to zsh dirstack.\nBUF=\"$(realpath \"$1\")\n$(grep -v \"$(realpath \"$1\")\" \"$ZDIRS\")\"\necho \"$BUF\" > \"$ZDIRS\"\n\nzsh\n```\n\nCambie ZDIRS para su dirstack.\n\n```\nrc.conf\n```\n\n```\nmap S shell bash -c \"cd %d; bash\"\n```\n\nProbablemente esto también se pueda adaptar a otras intérpretes de órdenes. En lugar de ejecutar simplemente un intérprete de órdenes (conforme la configuración predeterminada), la solución anterior ejecutará cd en un intérprete de órdenes, y luego lanzará un terminal interactivo que no hará que termine inmediatamente para que pueda continuar con lo que quería.\n\n"
    },
    {
      "title": "Prevenir instancias de ranger anidadas",
      "level": 4,
      "content": "Puede iniciar un intérprete de órdenes en el directorio actual con S, cuando salga del mismo volverá a su instancia de ranger.\n\nSin embargo, cuando olvida que ya se encuentra en un intérprete de órdenes de ranger y vuelve a iniciar ranger, termina con un ranger que ejecuta un intérprete de órdenes que ejecuta ranger.\n\nPara evitar esto, puede crear la siguiente función en su archivo de inicio de shell:\n\n```\nranger() {\n    if [ -z \"$RANGER_LEVEL\" ]; then\n        /usr/bin/ranger \"$@\"\n    else\n        exit\n    fi\n}\n```\n\n"
    },
    {
      "title": "Alteraciones en la vista previa de imágenes",
      "level": 3,
      "content": "Las columnas sin bordes pueden causar rayas en las vistas previas de imágenes. [1]. En ~/.config/ranger/rc.conf establecer:\n\n```\nset draw_borders true\n```\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- BBS thread\n- DotShare.it configurations\n- GitHub\n- Official User Guide\n- Installing and using ranger\n- Mailing list\n- Ranger tutorial\n\n"
    }
  ]
}