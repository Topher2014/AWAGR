{
  "title": "SysVinit (日本語)",
  "url": "https://wiki.archlinux.org/title/SysVinit_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- init\n- 仮想コンソールに自動ログイン\n- ブートメッセージのクリアの無効化\n- ログイン時に X を起動\n- xinitrc\n- ディスプレイマネージャ\n\nSysVinit を使用するシステムでは、Linux カーネルがロードされたあと init が一番最初のプロセスとして起動します。カーネルによって使われるデフォルトの init プログラムは /sbin/init であり systemd-sysvcompat (新しい環境でのデフォルト、systemd) や sysvinitAUR に含まれています。この記事において init という言葉は sysvinit のことを指します。\n\ninittab は /etc に置かれた init の起動設定ファイルのことです。特定のランレベルに入ったときにどのプログラムやスクリプトを実行すればいいのか init に指定します。\n\nSysVinit ベースでありながら Arch のシステムでは init は使用せず、ほとんどの作業は実際にはメインのブートスクリプトが担っています。この記事では init と inittab について取り上げます。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 init と inittab の概要\n- 3 ランレベルの切り替え 3.1 ブートローダー 3.2 起動後\n- 4 inittab 4.1 デフォルトのランレベル 4.2 メインのブートスクリプト 4.3 シングルユーザーブート 4.4 Getty とログイン 4.5 Ctrl+Alt+Del 4.6 X プログラム 4.7 電源検出スクリプト 4.8 カスタムキーボードリクエスト 4.8.1 kbrequest のトリガー\n- 5 rc.d スクリプトの書き方 5.1 ガイドライン 5.2 利用可能な関数 5.3 サンプル\n- 6 systemd への移行 6.1 移行前に考慮すべきこと 6.2 追加情報\n- 7 参照\n\n- 3.1 ブートローダー\n- 3.2 起動後\n\n- 4.1 デフォルトのランレベル\n- 4.2 メインのブートスクリプト\n- 4.3 シングルユーザーブート\n- 4.4 Getty とログイン\n- 4.5 Ctrl+Alt+Del\n- 4.6 X プログラム\n- 4.7 電源検出スクリプト\n- 4.8 カスタムキーボードリクエスト 4.8.1 kbrequest のトリガー\n\n- 4.8.1 kbrequest のトリガー\n\n- 5.1 ガイドライン\n- 5.2 利用可能な関数\n- 5.3 サンプル\n\n- 6.1 移行前に考慮すべきこと\n- 6.2 追加情報\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "AUR から sysvinitAUR と initscripts-forkAUR パッケージをインストールしてください。インストールすると systemd-sysvcompat が削除され、再起動後に sysvinit が使われるようになります。systemd に戻したい場合、カーネルコマンドラインに init=/usr/lib/systemd/systemd を追加してください。\n\ninit スクリプトの代わりとなるスクリプトが arch-rcscripts に存在します。設定方法については Init#設定を参照してください。\n\n"
    },
    {
      "title": "init と inittab の概要",
      "level": 2,
      "content": "init はいつでもプロセス１であり、スワップ領域の管理を除いて、全ての他のプロセスの親プロセスになります。pstree を使うことでシステムのプロセス階層のどこに init があるか知ることができます:\n\n```\n$ pstree -Ap\n```\n\n```\ninit(1)-+-acpid(3432)\n        |-crond(3423)\n        |-dbus-daemon(3469)\n        |-gpm(3485)\n        |-mylogin(3536)\n        |-ngetty(3535)---login(3954)---zsh(4043)---pstree(4326)\n        |-polkitd(4033)---{polkitd}(4035)\n        |-syslog-ng(3413)---syslog-ng(3414)\n        `-udevd(643)-+-udevd(3194)\n                     `-udevd(3218)\n```\n\n(名前の通り) システムの初期化をする他に、init は再起動やシャットダウン、リカバリモード (シングルユーザーモード) での起動も管理します。これらに対応するために、inittab はエントリを異なるランレベルにグループ化しています。Arch が使用するランレベルはそれぞれ、halt には 0、シングルユーザーモードには 1 (エイリアスで S)、通常の起動時 (マルチユーザーモード) には 3、X には 5、再起動には 6 です。別のディストロではランレベルが異なっている可能性がありますが 0, 1, 6 については全てのディストロで共通です。\n\n起動時に、init は inittab を見て適切なアクションを実行します。inittab のエントリは以下のような形式を取ります:\n\n```\nid:runlevels:action:process\n```\n\nid はエントリのユニークな識別子 (ただの名前で、init に影響は与えません) で、runlevels はランレベルの文字 (区切りなし) です。init のランレベルが runlevels になると、action が実行され、適当なときに process が実行されます。特殊な action を指定すると init は runlevels を無視して特殊なマッチング方法を使います。詳しい説明は次のセクションにあります。\n\nman 5 inittab や man 8 init も参照してください。\n\n"
    },
    {
      "title": "ブートローダー",
      "level": 3,
      "content": "システムが起動するときのランレベルを変更するには、ブートローダーの適当な設定行に起動したいランレベル n を追加します。一度だけ別のランレベルで起動したいときは、ランレベルの数字をカーネルパラメータに追加してください (例: ランレベル 3 の場合 3)。\n\nランレベルは一番最後に付けることでカーネルが起動するべきランレベルを知ることができます。別の init プログラムを使うには (例: systemd)、init=/usr/lib/systemd/systemd などを追加します。\n\n"
    },
    {
      "title": "起動後",
      "level": 3,
      "content": "システムが起動した後は、telinit n を実行することで init にランレベルを n に変更するように要求できます。init は inittab を読み込んでランレベル n と現在のランレベルを比較して、新しいランレベルには存在しないプロセスを終了して、古いランレベルに存在しないアクションを実行します。両方のランレベルに存在するプロセスはそのままで手をつけられません。実際には、終了の方法はもう少し複雑です。技術的な詳細は init の man ページにあります。\n\ninit は inittab を監視しません。inittab に変更を加えて、その変更を適用するには telinit を明示的に呼び出す必要があります。telinit q コマンドは init に inittab を再調査させますがランレベルは変更しません。\n\n"
    },
    {
      "title": "inittab",
      "level": 2,
      "content": "このセクションでは inittab の一般的なエントリについて考察します。Arch で使用されるデフォルトの inittab のエントリと同じ順番で説明します。その後、各自で inittab エントリを作成するのに役立つ例をあげます。\n\n"
    },
    {
      "title": "デフォルトのランレベル",
      "level": 3,
      "content": "デフォルトのランレベルは 3 です。デフォルトで (X で使用することになっている) ランレベル 5 で起動したい場合は以下をアンコメントまたは追加してください:\n\n```\nid:5:initdefault:\n```\n\n"
    },
    {
      "title": "メインのブートスクリプト",
      "level": 3,
      "content": "以下がメインの Arch init スクリプトです。\n\n```\nrc::sysinit:/etc/rc.sysinit\nrs:S1:wait:/etc/rc.single\nrm:2345:wait:/etc/rc.multi\nrh:06:wait:/etc/rc.shutdown\n```\n\n"
    },
    {
      "title": "シングルユーザーブート",
      "level": 3,
      "content": "キーファイルが見つからなかったり、ハードドライブやファイルシステムが破損したり死亡するなどして、カーネルが途中で起動しなくなることがあります。そのような場合、init イメージは自動的にシングルユーザーモードに移行して root ログインができるようになり、/sbin/login の代わりに /sbin/sulogin を使ってログインプロセスを制御します。GRUB, LILO, Syslinux などの設定のカーネルコマンドラインに S という文字を追加することでもシングルユーザーモードで起動できます。sulogin 以外を実行させたい場合は、以下の部分に記述してください。\n\n```\nsu:S:wait:/sbin/sulogin -p\n```\n\n"
    },
    {
      "title": "Getty とログイン",
      "level": 3,
      "content": "以下はターミナルで getty を実行する重要なエントリです。デフォルト設定では複数の getty が tty1-6 で動作するようになっており、ログインプロンプトで画面に表示されます。openvt, chvt, stty, ioctl なども参照してください。\n\n```\nc1:234:respawn:/sbin/agetty 9600 tty1 xterm-color\nc5:5:respawn:/sbin/agetty 57600 tty2 xterm-256color\n```\n\n"
    },
    {
      "title": "Ctrl+Alt+Del",
      "level": 3,
      "content": "特殊なキーシーケンス Ctrl+Alt+Del が押されると、以下が実行されます。\n\n```\nca::ctrlaltdel:/sbin/shutdown -t3 -r now\n```\n\n"
    },
    {
      "title": "X プログラム",
      "level": 3,
      "content": "デバッグを厭わない場合は、inittab からあらゆる種類のプログラムを起動する方法を見つけ出すことができます。有用なプログラムのタイプとしてはランレベルが 5 で、multi-user-x-mode のときにログインマネージャを起動することが挙げられます。以下の例ではランレベルが 5 になったときに SLiM を起動する方法がわかります。\n\n```\nx:5:respawn:/usr/bin/slim >/dev/null 2>&1\n#x:5:respawn:/usr/bin/xdm -nodaemon -confi /etc/X11/xdm/archlinux/xdm-config\n```\n\n"
    },
    {
      "title": "電源検出スクリプト",
      "level": 3,
      "content": "Init は UPS デバイスを照会して UPS の状態にあわせてプロセスを実行することができます。例えば:\n\n```\npf::powerfail:/sbin/shutdown -f -h +2 \"Power Failure; System Shutting Down\"\npr:12345:powerokwait:/sbin/shutdown -c \"Power Restored; Shutdown Cancelled\"\n```\n\n"
    },
    {
      "title": "カスタムキーボードリクエスト",
      "level": 3,
      "content": "以下の行は特別なキーシーケンスが押された時のカスタム関数を追加します。Ctrl+Alt+Del と同じようにこの特別なキーシーケンスは自由に修正することができます。\n\n```\nkb::kbrequest:/usr/bin/wall \"Keyboard Request -- edit /etc/inittab to customize\"\n```\n\n"
    },
    {
      "title": "kbrequest のトリガー",
      "level": 4,
      "content": "init プロセス (1) に root で (sudo を使って) WINCH シグナルを送信することで特殊なキーシーケンス kbrequest を起こすことができます。以下の例では、次のコマンドによって wall が全ての tty に書き込みを行います:\n\n```\nkill -WINCH 1\n```\n\n```\nBroadcast message from root@askapachehost (console) (Wed Oct 27 14:02:26 2010):\nKeyboard Request -- edit /etc/inittab to customize\n```\n\n"
    },
    {
      "title": "rc.d スクリプトの書き方",
      "level": 2,
      "content": "Initscripts は rc.d スクリプトを使用してデーモンの起動・停止・再起動を制御します。\n\n"
    },
    {
      "title": "ガイドライン",
      "level": 3,
      "content": "- /etc/rc.conf, /etc/rc.d/functions, /etc/conf.d/DAEMON_NAME を参照してください。\n- 引数などデーモンオプションは /etc/conf.d/DAEMON_NAME に記述します。ロジックから設定を分離してデーモンスクリプトの形式を乱さないための決まり事です。\n- 無駄な機能を書くのを避けて /etc/rc.d/functions の関数を利用してください。\n- 最低でもスクリプトの引数として start, stop, restart を定義してください。\n\n"
    },
    {
      "title": "利用可能な関数",
      "level": 3,
      "content": "- /etc/rc.d/functions によって様々な関数が提供されています: stat_busy \"message\": メッセージで busy 状態を設定 (例: Starting daemon [BUSY]) stat_done: done 状態を設定 (例: Starting daemon [DONE]) stat_fail: failed 状態を設定 (例: Starting daemon [FAILED]) get_pid program: プログラムの PID を取得 ck_pidfile PID-file program: プログラムの PID ファイルが正しいかどうかチェック (例: ck_pidfile /var/run/daemon.pid daemon || rm -f /var/run/daemon.pid) [add|rm]_daemon program: (/run/daemons/ に存在する) 実行中のデーモンにプログラムを追加・削除\n\n- stat_busy \"message\": メッセージで busy 状態を設定 (例: Starting daemon [BUSY])\n- stat_done: done 状態を設定 (例: Starting daemon [DONE])\n- stat_fail: failed 状態を設定 (例: Starting daemon [FAILED])\n- get_pid program: プログラムの PID を取得\n- ck_pidfile PID-file program: プログラムの PID ファイルが正しいかどうかチェック (例: ck_pidfile /var/run/daemon.pid daemon || rm -f /var/run/daemon.pid)\n- [add|rm]_daemon program: (/run/daemons/ に存在する) 実行中のデーモンにプログラムを追加・削除\n\n関数の完全なリストは長すぎてドキュメント化もされていないため /etc/rc.d/functions のソースから学ぶしかありません。man rc.d も参照してください。\n\n"
    },
    {
      "title": "サンプル",
      "level": 3,
      "content": "以下は crond の例です。/etc/rc.d には様々な亜種が存在します。\n\n設定ファイル:\n\n```\n/etc/conf.d/crond\n```\n\n```\nARGS=\"-S -l info\"\n```\n\n実際のスクリプト:\n\n```\n/etc/rc.d/crond\n```\n\n```\n#!/bin/bash\n\n. /etc/rc.conf\n. /etc/rc.d/functions\n\nDAEMON=crond\nARGS=\n\n[ -r /etc/conf.d/$DAEMON ] && . /etc/conf.d/$DAEMON\n\nPID=$(get_pid $DAEMON)\n\ncase \"$1\" in\n start)\n   stat_busy \"Starting $DAEMON\"\n   [ -z \"$PID\" ] && $DAEMON $ARGS &>/dev/null\n   if [ $? = 0 ]; then\n     add_daemon $DAEMON\n     stat_done\n   else\n     stat_fail\n     exit 1\n   fi\n   ;;\n stop)\n   stat_busy \"Stopping $DAEMON\"\n   [ -n \"$PID\" ] && kill $PID &>/dev/null\n   if [ $? = 0 ]; then\n     rm_daemon $DAEMON\n     stat_done\n   else\n     stat_fail\n     exit 1\n   fi\n   ;;\n restart)\n   $0 stop\n   sleep 1\n   $0 start\n   ;;\n *)\n   echo \"usage: $0 {start|stop|restart}\"  \nesac\n```\n\n"
    },
    {
      "title": "移行前に考慮すべきこと",
      "level": 3,
      "content": "- インタラクティブな initscripts は systemd では動作しません。\n\n"
    },
    {
      "title": "追加情報",
      "level": 3,
      "content": "- systemd を使用している場合、ユーザーのグループ (sys, disk, lp, network, video, audio, optical, storage, scanner, power など) を設定する必要はほとんどありません。グループは機能を破壊することさえあります。例えば audio グループは高速なユーザー切り替えやアプリケーションのソフトウェアミキシングを無効にします。全ての PAM ログインは logind セッションを提供します。オーディオ/ビデオデバイスに POSIX ACL を通して権限を与えたり、udisks を使ってリムーバブルディスクのマウントなどの操作を行います。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Wikipedia:ja:init\n- Linux Knowledge Base and Tutorial. Run Levels.\n- Linux.com. ランレベルと inittab のイントロダクション\n- Linux.com. サービスとランレベル、rc.d スクリプトのイントロダクション\n\n"
    }
  ]
}