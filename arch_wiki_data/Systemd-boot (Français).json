{
  "title": "Systemd-boot (Français)",
  "url": "https://wiki.archlinux.org/title/Systemd-boot_(Fran%C3%A7ais)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Arch boot process (Français)\n- Secure Boot\n- Unified Extensible Firmware Interface\n\nsystemd-boot(7), précédemment appelé gummiboot (Allemand pour \"bateau pneumatique\"), est un chargeur d'amorçage de type UEFI facile à configurer. Il offre un menu textuel pour selectionner l'entrée d'amorçage et un editeur pour le terminal du noyau.\n\nIl faut noter que systemd-boot ne peut seulement lancer des éxécutables EFI (ex: le noyau Linux EFISTUB, shell UEFI, GRUB, ou le Gestionnaire de démarrage Windows).\n\n"
    },
    {
      "title": "Systèmes de fichier supportés",
      "level": 2,
      "content": "systemd-boot hérite du support des systèmes de fichier du système de fichier du micrologiciel (ex: FAT12, FAT16 et FAT32). Additionnellement, il peut lancer des pilotes UEFI placés dans esp/EFI/systemd/drivers.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "systemd-boot est fournit avec le paquet systemd qui est une dépendance du paquet méta base, donc aucun autre paquet additionnel ne doit être installé manuellement.\n\n"
    },
    {
      "title": "Installation du chargeur d'amorçage UEFI",
      "level": 2,
      "content": "Pour installer systemd-boot, veuillez premièrement vous assurer que le système a été démarré dans le mode UEFI et que les variables UEFI sont accessibles. Ceci peut être vérifié en éxécutant efivar --list ou, si efivar n'est pas installé, en éxécutant ls /sys/firmware/efi/efivars (si le répertoire existe, le système a été démarré en mode UEFI.)\n\nDurant l'installation, esp sera utilisé comme terme pour le point de montage, ex: /efi ou /boot. Assumant que vous vous êtes «chrooté» dans le point de montage du système.\n\nUtilisez bootctl(1) pour installer systemd-boot à l'ESP:\n\n```\n# bootctl install\n```\n\nCeci va copier le chargeur d'amorçe UEFI systemd-boot vers l'ESP, créez une entrée d'amorçage UEFI pour celui-ci et définissez le comme premier dans l'ordre de démarrage UEFI.\n\n- Sur un UEFI x64, /usr/lib/systemd/boot/efi/systemd-bootx64.efi sera copié vers esp/EFI/systemd/systemd-bootx64.efi et esp/EFI/BOOT/BOOTX64.EFI.\n- Sur un UEFI IA32, /usr/lib/systemd/boot/efi/systemd-bootia32.efi sera copié vers esp/EFI/systemd/systemd-bootia32.efi et esp/EFI/BOOT/BOOTIA32.EFI.\n\nL'entrée d'amorçage sera appelée \"Linux Boot Manager\" et pointera vers, dépendant de l'architecture, soit \\EFI\\systemd\\systemd-bootx64.efi ou \\EFI\\systemd\\systemd-bootia32.efi sur l'ESP.\n\n- En éxécutant bootctl install, systemd-boot essaiera de localiser l'ESP à /efi, /boot, et /boot/efi. Pour définir l'esp vers un endroit différent, il est requis de rajouter l'option --esp-path=esp. (Voir bootctl(1) § OPTIONS pour des détails.)\n- Installer systemd-boot écrira par dessus n'importe quel esp/EFI/BOOT/BOOTX64.EFI (ou esp/EFI/BOOT/BOOTIA32.EFI pour l'UEFI IA32) existant, ex. la version Microsoft du fichier.\n\nPour conclure l'installation, configurez systemd-boot.\n\n"
    },
    {
      "title": "Installation depuis XBOOTLDR",
      "level": 3,
      "content": "Note: **This article or section is a candidate for moving to Partitioning#Discrete partitions.** This article or section is a candidate for moving to Partitioning#Discrete partitions.\n\nThis article or section is a candidate for moving to Partitioning#Discrete partitions.\n\nUne partition /boot séparée de type \"Linux extended boot\" (XBOOTLDR) peut être créée pour garder le noyeau et l'initramfs séparé de l'ESP. Ceci est particulièrement utile pour dual boot avec Windows avec un ESP qui est trop petit.\n\nPréparez un ESP comme habituellement et créez une autre partition pour XBOOTLDR sur le même disque physique. La partition XBOOTLDR doit avoir le type de partition GUID de bc13c2ff-59e6-4262-a352-b275fd6f7172 [1] (type pour gdisk). La taille de la partition XBOOTLDR doit être assea large pour contenir tous les noyaux que vous allez installer.\n\n- systemd-boot ne fait pas de vérification du système de fichier comme il le fait pour l'ESP. Donc, il est possible d'utiliser n'importe quel système de fichier que votre implémentation UEFI peut lire.\n- UEFI peut passer le chargement de partitions autres que l'ESP quand le mode \"fast boot\" est activé. Cela peut engendrer le fait que systemd-boot n'arrive pas à trouver une entrée sur la partition XBOOTLDR; dans ce cas, désactivez le mode \"fast boot\".\n- La partition XBOOTLDR doit être sur le même disque physique que l'ESP pour que systemd-boot la reconnaisse.\n\nPendant l'installation, montez l'ESP vers /mnt/efi, et la partition XBOOTLDR vers /mnt/boot.\n\nUne fois dans chroot, utilisez la commande:\n\n```\n# bootctl --esp-path=/efi --boot-path=/boot install\n```\n\nPour conclure l'installation, configurez systemd-boot.\n\n"
    },
    {
      "title": "Mettre à jour le gestionnaire d'amorçe UEFI",
      "level": 3,
      "content": "Lorsqu'il y a une nouvelle version de systemd-boot, le gestionnaire d'amorçe UEFI peut optionellement être réinstallé par l'utilisateur. Ceci peut être fait manuellement ou automatiquement; les deux approches sont décrites ci-dessous.\n\n"
    },
    {
      "title": "Mise-à-jour manuelle",
      "level": 4,
      "content": "Utilisez bootctl pour mettre à jour systemd-boot:\n\n```\n# bootctl update\n```\n\n"
    },
    {
      "title": "Mise-à-jour automatique",
      "level": 4,
      "content": "Pour mettre à jour systemd-boot automatiquement, utilisez soit un service systemd ou un hook pacman. Les deux méthodes sont décrites ci-dessous.\n\nDepuis la version 250, systemd est livré avec systemd-boot-update.service. Activer ce service mettra à jour le chargeur d'amorçe après le prochain démarrage.\n\nLe paquet systemd-boot-pacman-hookAUR rajoute un hook pacman qui sera éxécuté à chaque fois que [2][broken link: package not found] est mit à jour.\n\nAu lieu d'installer systemd-boot-pacman-hook, vous pourriez préférer placer le fichier suivant dans /etc/pacman.d/hooks/:\n\n```\n/etc/pacman.d/hooks/95-systemd-boot.hook\n```\n\n```\n[Trigger]\nType = Package\nOperation = Upgrade\nTarget = systemd\n\n[Action]\nDescription = Met gracieusement à jour systemd-boot...\nWhen = PostTransaction\nExec = /usr/bin/systemctl restart systemd-boot-update.service\n```\n\n"
    },
    {
      "title": "Signature pour Secure Boot",
      "level": 3,
      "content": "Si vous avez Secure Boot d'activé, vous pouvez avoir envie d'ajouter un hook pacman pour signer automatique le gestionnaire d'amorçe après chaque mise-à-jour du paquet:\n\n```\n/etc/pacman.d/hooks/80-secureboot.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nType = Path\nTarget = usr/lib/systemd/boot/efi/systemd-boot*.efi\n\n[Action]\nDescription = Signing systemd-boot EFI binary for Secure Boot\nWhen = PostTransaction\nExec = /bin/sh -c 'while read -r i; do sbsign --key /path/to/keyfile.key --cert /path/to/certificate.crt \"$i\"; done;'\nDepends = sh\nDepends = sbsigntools\nNeedsTargets\n```\n\nRemplacez /chemin/vers/fichier-clé.key et /chemin/vers/certificat.crt avec votre clé et certificat de signature respectivement. Pour une meilleure compréhension de ce hook, consultez la page du manuel.\n\nLe /usr/lib/systemd/boot/efi/systemd-boot*.efi.signed créé sera automatiquement détecté par bootctl install ou bootctl update. Voir bootctl(1) § SIGNED .EFI FILES.\n\nEn tant qu'alternative, utilisez sbctl.\n\n"
    },
    {
      "title": "Configuration du chargeur",
      "level": 3,
      "content": "La configuration du chargeur est stockée dans le fichier esp/loader/loader.conf. Voir loader.conf(5) § OPTIONS pour des détails.\n\nUn example de configuration du chargeur est fournie ci-dessous:\n\n```\nesp/loader/loader.conf\n```\n\n```\ndefault  arch.conf\ntimeout  4\nconsole-mode max\neditor   no\n```\n\n- systemd-boot n'accepte pas les tabulations (tabs) comme indentation, utilisez des espaces à la place.\n- default et timeout peuvent être changés dans le menu d'amorçage lui-même, et les modifications seront stockées comme variables UEFI LoaderEntryDefault et LoaderConfigTimeout, remplaçant ces options.\n- bootctl set default \"\" et bootctl set-timeout \"\" peuvent être utilisés pour nettoyer les variables UEFI, remplaçant les options default et timeout, respectivement.\n- Si vous avez mis timeout 0, le menu d'amorçage peut être accédé en appuyant sur Espace.\n- Un fichier de configuration basique du chargeur d'amorçe est située dans /usr/share/systemd/bootctl/loader.conf.\n- Si le chargeur d'amorçe (pendant la selection de l'entrée) apparait déformé/utilise la mauvaise résolution, vous pouvez essayer de mettre le console-mode à auto]] (utilise des heuritiques pour selection la meilleure résolution), keep (garde la résolution fournie du firmware) ou 2 (essaie de selectionner la première résolution non-standard UEFI)\n\n"
    },
    {
      "title": "Se souvenir de la dernière entrée",
      "level": 4,
      "content": "Depuis la version 251 ou plus tard de systemd, default peut être modifiée en @saved afin de se souvenir de la dernière entée choisie au démarrage. Ceci est utile lorsque nous dual bootons Windows et la mise à jour automatique surprise de Windows vous fera démarrer Linux.\n\n```\nesp/loader/loader.conf\n```\n\n```\ndefault @saved\n...\n```\n\npour plus de détails.\n\n"
    },
    {
      "title": "Ajouter un chargeur",
      "level": 3,
      "content": "systemd-boot cherchera automatiquement pour un objet du menu d'amorçage dans esp/loader/entries/*.conf et additionnellement dans boot/loader/entries/*.conf, si vous utilisez #Installation depuis XBOOTLDR. Notez que les entrées dans esp peuvent seulement utiliser des fichiers (ex. noyaux, initramfs, images, etc.) dans esp. Similairement, les entrées dans boot ne peuvent utiliser que des fichiers dans boot.\n\nUn example de fichier d'amorçage démarrant Arch depuis un volume en utilisant son UUID xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx est:\n\n```\nesp/loader/entries/arch.conf\n```\n\n```\ntitle   Arch Linux\nlinux   /vmlinuz-linux\ninitrd  /initramfs-linux.img\noptions root=UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx rw\n```\n\n```\nesp/loader/entries/arch-fallback.conf\n```\n\n```\ntitle   Arch Linux (fallback initramfs)\nlinux   /vmlinuz-linux\ninitrd  /initramfs-linux-fallback.img\noptions root=UUID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx rw\n```\n\nVoir les Spécifications du Chargeur d'Amorçage pour des détails sur toutes les options de configuration.\n\nsystemd-boot regardera à chaque amorçage oour Windows Boot Manager à la position /efi/Microsoft/Boot/Bootmgfw.efi, Apple macOS Boot Manager dans le firmware, le shell UEFI /shellx64.efi et le Chargeur par defaut EFI (EFI Default Loader) /efi/boot/bootx64.efi, ainsi que les fichiers noyau préparés specifiquement dans /efi/Linux. Quand détectées, des entrées correspondantes nommées, respectivement, auto-windows, auto-osx, auto-efi-shell et auto-efi-default seront créées. Ces entrées ne requièrent pas de configuration manuelle du chargeur. En revanche, il ne detectera pas automatiquement d'autres applications EFI (contrairement à rEFInd), donc pour démarrer le noyau Linux, des configurations manuelles d'entrées devront être créées.\n\n- Les entrées d'amorçage disponibles qui ont été configurées peuvent être listées avec la commande bootctl list.\n- Un exemple de fichier d'entrée est disponible à /usr/share/systemd/bootctl/arch.conf.\n- Les paramètres du noyeau pour des scénarios tels que LVM, LUKS, dm-crypt (Français) ou Btrfs peuvent être trouvés sur les pages pertinentes.\n\n"
    },
    {
      "title": "Shells UEFI ou autres applications EFI",
      "level": 4,
      "content": "Dans le cas où vous avez installé un Shell UEFI avec le paquet edk2-shell, systemd-boot détectera automatiquement une nouvelle entrée si le fichier EFI est placé dans esp/shellx64.efi. Pour faire cela, un exemple d'une commande après avoir installé le paquet serait:\n\n```\n# cp /usr/share/edk2-shell/x64/Shell.efi /boot/shellx64.efi\n```\n\nAutrement, dans le cas où vous avez installé d'autres applications EFI dans l'ESP, vous pouvez utilisez les extraits de configuration suivants:\n\n```\nesp/loader/entries/fwupd.conf\n```\n\n```\ntitle  Firmware updater\nefi     /EFI/tools/fwupdx64.efi\n```\n\n```\nesp/loader/entries/gdisk.conf\n```\n\n```\ntitle  GPT fdisk (gdisk)\nefi     /EFI/tools/gdisk_x64.efi\n```\n\nVous avez besoins d'installer memtest86+-efi pour que cela marche. Vous devez également signer le binaire EFI lorsque vous utilisez Secure Boot.\n\n```\nesp/loader/entries/memtest.conf\n```\n\n```\ntitle Memtest86+\nefi /memtest86+/memtest.efi\n```\n\nsystemd-boot peut charger en chaîne Netboot. Téléchargez le binaire EFI ipxe-arch.efi et sa signature, vérifiez-le et placez-le comme proposé dans esp/EFI/arch_netboot/arch_netboot.efi.\n\n```\nesp/loader/entries/arch_netboot.conf\n```\n\n```\ntitle Arch Linux Netboot\nefi /EFI/arch_netboot/arch_netboot.efi\n```\n\nsystemd-boot peut charger en chaîne GRUB. La position du binaire grubx64.efi est égale au --bootloader-id= quand GRUB a été installé à l'ESP.\n\n```\nesp/loader/entries/grub.conf\n```\n\n```\ntitle GRUB\nefi /EFI/GRUB/grubx64.efi\n```\n\n"
    },
    {
      "title": "Amorçer d'un autre disque",
      "level": 4,
      "content": "systemd-boot ne peut pas lancer de binaires EFI depuis une partition autre que l'ESP d'où il a été lancé ou la partition XBOOTLDR sur le même disque, mais il peut diriger le Shell UEFI à le faire.\n\nPremièrement, installez edk2-shell comme décrit ci-dessus. Dans le Shell UEFI, utilisez la commande map pour prendre note du 'Alias FS (ex. HDa6666a2, HD0b, FS1, ou BLK7) de la partition avec la PARTUUID correspondante.\n\nPuis, utilisez la commande exit pour re-amorçer dans Linux, où vous pouvez créer une nouvelle entrée pour éxécuter le programe EFI cible à travers le Shell UEFI:\n\n```\nesp/loader/entries/windows.conf\n```\n\n```\ntitle   Windows\nefi     /shellx64.efi\noptions -nointerrupt -nomap -noversion HD0b:EFI\\Microsoft\\Boot\\Bootmgfw.efi\n```\n\nAssurez-vous que le chemin efi correspond à l'endroit où le shellx64.efi a été copié dans la partition esp. Notez également que le fichier EFI shellx64.efi peut être déplacé quelque part d'autre pour éviter la création automatique d'entrée par systemd-boot.\n\nRemplacez HD0b avec l'alias FS noté précedemment.\n\n- L'option -nointerrupt empêche l'interruption du programme EFI cible avec Ctrl+C.\n- L'option -nomap -noversion cache le message de bienvenue par defaut du Shell UEFI.\n- Pour que le Shell UEFI retourne automatiquement au chargeur d'amorçe si le programme cible EFI s'arrête (ex. à cause d'une erreur), ajoutez l'option -exit.\n- Vous pouvez également ajouter l'option -noconsoleout si il reste des sorties inutiles (de texte) dans le Shell UEFI.\n\n"
    },
    {
      "title": "Amorçer dans le setup du micrologiciel UEFI",
      "level": 3,
      "content": "systemd-boot créera automatiquement une entrée afin d'amorçer dans le setup du firmware UEFI (souvent appelé BIOS) si le firmware de votre appareil permet de redémarrer dans le BIOS depuis le Système d'Exploitation.\n\n"
    },
    {
      "title": "Supporter l'hibernation",
      "level": 3,
      "content": "Voir Suspend and hibernate.\n\n"
    },
    {
      "title": "Editeur de paramètres du Noyau avec une protection par mot de passe",
      "level": 3,
      "content": "Alternativement, vous pouvez installer systemd-boot-passwordAUR ce qui supporte des options basique de configuration de mot de passe. Utilisez sbpctl generate pour générer une valeur pour cette option.\n\nInstallez systemd-boot-password avec la commande suivante:\n\n```\n# sbpctl install esp\n```\n\nAvec un editeur activé vous serez demandé votre mot de passe avant que vous puissez modifier les paramètres du noyau.\n\n"
    },
    {
      "title": "Clés dans le menu d'amorçage",
      "level": 3,
      "content": "Vous pouvez utiliser t et T lorsque vous êtes dans le menu afin d'ajuster le timeout et e pour modifier les paramètres du noyau pour ce démarrage. Appuyez sur h pour voir une courte liste de raccourcis clavier utiles. Voir systemd-boot(7) § KEY BINDINGS pour une liste complète de raccourcis claviers lorsque vous êtes dans le menu d'amorçage.\n\n"
    },
    {
      "title": "Choix du prochain amorçage",
      "level": 3,
      "content": "Le gestionnaire d'amorçage est intégré avec la commande systemctl, vous permettant de choisir quelle option vous voulez amorçer après un redémarrage. Par exemple, supposons que vous avez construit un noyau customisé et créé un fichier d'entrée dans esp/loader/entries/arch-custom.conf pour amorçer dans celui-ci, vous pouvez juste lancer:\n\n```\n$ systemctl reboot --boot-loader-entry=arch-custom.conf\n```\n\net votre système redémarrera dans cette entrée, gardant l'option par défaut intacte pour les amorçages qui suivront. Pour voir une liste d'entrées, utilisez l'option --boot-loader-entry=help.\n\nSi vous voulez amorçer dirèctement dans le firmware de votre carte mère directement, alors, vous pouvez utiliser cette commmande:\n\n```\n$ systemctl reboot --firmware-setup\n```\n\n"
    },
    {
      "title": "Images Noyau Unifiées",
      "level": 3,
      "content": "Les Images Noyau Unifiées (INUs) dans esp/EFI/Linux/ sont automatiquement ressourcées par systemd-boot, et ne nécéssitent pas une nouvelle entrée dans esp/loader/entries. (Notez que les images noyau unifiées doivent avoir une extension .efi afin d'être identifiées par systemd-boot).\n\n"
    },
    {
      "title": "Grml sur l'ESP",
      "level": 3,
      "content": "Grml est un live system léger avec une collection de logiciels pour l'administration et le sauvetage système.\n\nAfin d'installer Grml sur l'ESP, nous devons copier le noyau vmlinuz, l'initramfs initrd.img, et l'image squashé grml64-small.squashfs depuis le fichier ISO vers l'ESP. Pour faire cela, téléchargez grml64-small.iso et montez le fichier (le point de montage est dénoté mnt); le noyau et initramfs sont dans mnt/boot/grml64small/, et l'image squashé est située dans mnt/live/grml64-small.\n\nEnsuite, créez un repertoire pour Grml dans votre ESP,\n\n```\n# mkdir -p esp/grml\n```\n\net copiez les fichiers mentionnés ci-dessus dedans::\n\n```\n# cp mnt/boot/grml64small/vmlinuz esp/grml\n# cp mnt/boot/grml64small/initrd.img esp/grml\n# cp mnt/live/grml64-small/grml64-small.squashfs esp/grml\n```\n\nDans la dernière étape, créez une entée pour le chargeur systemd-boot: Dans esp/loader/entries créez un fichier grml.conf avec le contenu suivant:\n\n```\nesp/loader/entries/grml.conf\n```\n\n```\ntitle   Grml Live Linux\nlinux   /grml/vmlinuz\ninitrd  /grml/initrd.img\noptions apm=power-off boot=live live-media-path=/grml/ nomce net.ifnames=0\n```\n\nPour un survol des options d'amorçage, consultez les cheatcode for Grml.\n\n"
    },
    {
      "title": "Archiso sur l'ESP",
      "level": 3,
      "content": "Avec Grml, il est possible d'utiliser l'ISO d'Arch Linux. Pour cela, nous devons copier le noyau vmlinuz-linux, l'initramfs initramfs-linux.img, et l'image squashfs airootfs.sfs depuis le fichier ISO vers la partition système EFI (ESP).\n\nPremièrement, téléchargez archlinux-YYYY.MM.DD-x86_64.iso.\n\nPuis, créez un répertoire pour l'archiso dans votre ESP:\n\n```\n# mkdir -p esp/EFI/archiso\n```\n\nExtrayez le contenu du répertoire arch dans celui-ci:\n\n```\n# bsdtar -v -x --no-same-permissions --strip-components 1 -f archlinux-YYYY.MM.DD-x86_64.iso -C esp/EFI/archiso arch\n```\n\nDans la dernière étape, créez une entrée d'amorçage pour le chargeur systemd-boot: Dans esp/loader/entries créez un fichier arch-rescue.conf avec le contenu suivant:\n\n```\nesp/loader/entries/arch-rescue.conf\n```\n\n```\ntitle   Arch Linux (rescue system)\nlinux   /EFI/archiso/boot/x86_64/vmlinuz-linux\ninitrd  /EFI/archiso/boot/x86_64/initramfs-linux.img\noptions repertoireDeBaseDuISO=/EFI/archiso rechercheDuNomDuFichierDuISO=/EFI/archiso/boot/x86_64/vmlinuz-linux\n```\n\nPour un aperçu des options d'amorçage disponibles, consultez les README.bootparams pour le mkinitcpio-archiso.\n\n"
    },
    {
      "title": "systemd-boot sur des systèmes BIOS",
      "level": 3,
      "content": "Si vous avez besoins d'un chargeur d'amorçe pour un système BIOS qui suit les spécifications du chargeur d'amorçe, alors systemd-boot peut être mis en service sur des systèmes BIOS. Le chageur d'amorçe Clover supporte l'amorçage depuis un système BIOS et fournit un environment UEFI émulé.\n\n"
    },
    {
      "title": "systemd-boot ne montre pas mon entrée d'amorçage",
      "level": 3,
      "content": "Ceci peut être causé par une variété de problèmes avec le fichier de configuration, tels que le chemin du noyau qui a été spécifié incorrectement. Pour vérifier cela, éxécutez:\n\n```\n# bootctl\n```\n\n"
    },
    {
      "title": "Installation après amorçage en mode BIOS",
      "level": 3,
      "content": "Si amorçé dans le mode BIOS, vous pouvez toujours installer systemd-boot, en revanche, ce processus vous fait dire au micrologiciel de lancer le fichier EFI de systemd-boot durant l'amorçage.\n\n- si vous avez un Shell UEFI fonctionnel à un autre endroit\n- si votre interface micrologiciel vous offre une manière propre de rajouter le fichier EFI qui a besoins d'être chargé à l'amorçage\n- quelques micrologiciels peuvent utiliser esp/efi/boot/BOOTX64.efi par défaut si il n'y a aucune autre entrée définiée dans l'UEFI.\n\nSi voui pouvez le faire, l'installation est plus facile: allez dans votre Shell UEFI ou l'interface de configuration de votre micrologiciel et changez le fichier EFI par defaut vers esp/EFI/systemd/systemd-bootx64.efi.\n\n"
    },
    {
      "title": "Entrée manuelle avec efibootmgr",
      "level": 3,
      "content": "Si la commande bootctl install entraîne une erreur, vous pouvez créer l'entrée d'amorçage UEFI manuellement en utilisant efibootmgr:\n\n```\n# efibootmgr --create --disk /dev/sdX --part Y --loader '\\EFI\\systemd\\systemd-bootx64.efi' --label \"Linux Boot Manager\" --unicode\n```\n\noù /dev/sdXY est l'ESP.\n\n"
    },
    {
      "title": "Entrée manuelle en utilisant bcdedit depuis Windows",
      "level": 3,
      "content": "Si pour n'importe quelle raison vous avez besoins de créer une entrée d'amorçage UEFI depuis Windows, vous pouvez utiliser les commandes suivantes depuis un terminal Administrateur:\n\n```\n> bcdedit /copy {bootmgr} /d \"Linux Boot Manager\"\n> bcdedit /set {guid} path \\EFI\\systemd\\systemd-bootx64.efi\n```\n\nRemplacez guid avec l'id rapportée par la première commande. Vous pouvez également la mettre en tant qu'entrée par défaut en éxécutant:\n\n```\n> bcdedit /default {guid}\n```\n\n"
    },
    {
      "title": "Le menu n'apparaît pas après une mise-à-jour Windows",
      "level": 3,
      "content": "Voir UEFI#Windows changes boot order.\n\n"
    },
    {
      "title": "Ajouter le support pour le débloquage TPM de Windows BitLocker =",
      "level": 3,
      "content": "Pour empêcher BitLocker de demander la clée de récupération, ajoutez ce qui suit à loader.conf:\n\n```\nesp/loader/loader.conf\n```\n\n```\nreboot-for-bitlocker yes\n```\n\nCela ajoutera la variable UEFI BootNext, où Windows Boot Manager est chargé dans que BitLocker demande la clée de récupération. Ce changement doit être fait qu'une seule fois, et systemd-boot reste comme chargeur d'amorçe par défaut. Il n'y a pas besoins de spécifier Windows comme entrée si cela a déjà été détecté automatiquement.\n\nCeci est une fonctionnalité expérimentale, veuillez consulter loader.conf(5).\n\n"
    },
    {
      "title": "Voir également",
      "level": 2,
      "content": "- https://systemd.io/BOOT/\n- https://bbs.archlinux.org/viewtopic.php?id=254374\n- https://uapi-group.org/specifications/specs/boot_loader_specification/\n\n"
    }
  ]
}