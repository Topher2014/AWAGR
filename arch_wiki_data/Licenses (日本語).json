{
  "title": "Licenses (日本語)",
  "url": "https://wiki.archlinux.org/title/Licenses_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Arch パッケージングスタンダード\n- Arch Build System\n- パッケージの作成\n- .SRCINFO\n- カテゴリ:パッケージ開発\n- カスタムローカルリポジトリ\n- pacman ヒント\n- Arch User Repository\n- makepkg\n- pacman\n\nこの記事では PKGBUILD の中でメンテナが定義できる変数について説明します。PKGBUILD の関数や一般的なパッケージの作成については パッケージの作成 を参照してください。PKGBUILD(5) も読んで下さい。\n\nPKGBUILD はシェルスクリプトで、Arch Linux のパッケージが必要とするビルド情報を含んでいます。\n\nArch Linux のパッケージは makepkg ユーティリティを使ってビルドされます。makepkg を実行すると、カレントディレクトリにある PKGBUILD ファイルを探し、その中の指示に従ってコンパイルするか、パッケージアーカイブ (pkgname.pkg.tar.zst) を構築するためのファイルを入手します。出来上がったパッケージにはバイナリファイルとインストール手順が含まれ、pacman で簡単にインストールできます。\n\n必須の変数は、pkgname、pkgver、pkgrel、および arch です。 license は、パッケージをビルドするために厳密に必要というわけではありませんが、makepkg が存在しない場合に警告を生成するため、他のユーザーと共有する PKGBUILD には推奨されます。\n\nここで指定された順番で PKGBUILD の変数を定義するのが一般的なやり方です。しかし、正しい Bash 構文が使われている限り、これは必須ではありません。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 パッケージ名 1.1 pkgbase 1.2 pkgname\n- 2 バージョン 2.1 pkgver 2.2 pkgrel 2.3 epoch\n- 3 汎用 3.1 pkgdesc 3.2 arch 3.3 url 3.4 license 3.5 groups\n- 4 依存関係 4.1 depends 4.2 optdepends 4.3 makedepends 4.4 checkdepends\n- 5 パッケージの関係性 5.1 provides 5.2 conflicts 5.3 replaces\n- 6 その他 6.1 backup 6.2 options 6.3 install 6.4 changelog\n- 7 ソース 7.1 source 7.2 noextract 7.3 validpgpkeys\n- 8 整合性 8.1 cksums 8.2 md5sums 8.3 sha1sums 8.4 sha256sums 8.5 sha224sums, sha384sums, sha512sums 8.6 b2sums\n- 9 参照\n\n- 1.1 pkgbase\n- 1.2 pkgname\n\n- 2.1 pkgver\n- 2.2 pkgrel\n- 2.3 epoch\n\n- 3.1 pkgdesc\n- 3.2 arch\n- 3.3 url\n- 3.4 license\n- 3.5 groups\n\n- 4.1 depends\n- 4.2 optdepends\n- 4.3 makedepends\n- 4.4 checkdepends\n\n- 5.1 provides\n- 5.2 conflicts\n- 5.3 replaces\n\n- 6.1 backup\n- 6.2 options\n- 6.3 install\n- 6.4 changelog\n\n- 7.1 source\n- 7.2 noextract\n- 7.3 validpgpkeys\n\n- 8.1 cksums\n- 8.2 md5sums\n- 8.3 sha1sums\n- 8.4 sha256sums\n- 8.5 sha224sums, sha384sums, sha512sums\n- 8.6 b2sums\n\n"
    },
    {
      "title": "pkgbase",
      "level": 3,
      "content": "通常のパッケージをビルドするときは、この変数を PKGBUILD で明示的に宣言してはいけません: この変数のデフォルトの値は pkgname の値です。\n\n分割パッケージ をビルドするときは、この変数を使って makepkg の出力やソースだけの tarball の名前付けにパッケージのグループを参照するために使う名前を明示的に指定できます。この値はハイフンで始めることはできません。指定しない場合、値はデフォルトで pkgname 配列の最初の要素になります。\n\n分割パッケージのすべてのオプションとディレクティブのデフォルトは PKGBUILD で指定されたグローバルな値です。ただし、以下のものは各分割パッケージのパッケージング関数の中でオーバーライドすることができます。pkgdesc, arch, url, license, groups, depends, optdepends, provides, conflicts, replaces, backup, options, install そして changelog\n\n"
    },
    {
      "title": "pkgname",
      "level": 3,
      "content": "パッケージの名前、例えば pkgname='foo' か、分割パッケージの場合は名前の配列、例えば pkgname=('foo' 'bar') を指定します。パッケージ名は小文字の英数字と以下の文字のみで構成されている必要があります。@._+- は小文字の英数字と以下の文字で構成されています。(アットマーク、ドット、アンダースコア、プラス、ハイフン) ハイフンやドットで名前を始めることはできません。一貫性を保つために、pkgname はソフトウェアのソース tarball の名前と一致させるべきです。例えば、ソフトウェアが foobar-2.5.tar.gz に入っているならば、pkgname=foobar と記述して下さい。\n\n"
    },
    {
      "title": "pkgver",
      "level": 3,
      "content": "パッケージのバージョン。この値はパッケージの作成者によって公開されたバージョンと同じでなくてはなりません。文字と数字、ピリオドとアンダーバーを使えますがハイフンは使うことができません。パッケージの作成者がバージョンのナンバリングにハイフンを使っている時は、アンダーバーに置き換えてください。例えば、バージョンが 0.99-10 の場合、0.99_10 に変更してください。pkgver を後で PKGBUILD で使うときに、ダッシュの代わりにアンダーラインを使うのは簡単にできます 例:\n\n```\nsource=($pkgname-${pkgver//_/-}.tar.gz)\n```\n\n- pacman パッケージに含まれている vercmp を使うことでバージョンの優先度をテストできます。\n- PKGBUILD に pkgver() 関数を定義することで makepkg は自動的に pkgver 変数を 更新 します。詳しくは VCS パッケージガイドライン#関数 pkgver() を見て下さい。\n\n"
    },
    {
      "title": "pkgrel",
      "level": 3,
      "content": "Arch Linux におけるパッケージのリリース番号。パッケージの同じバージョンを続けてビルドするときにそれを区別するためにこの値を使います。新しいバージョンのパッケージが始めてリリースされたとき、リリース番号は1からスタートします。PKGBUILD ファイルに修正や最適化が加えられるたびに、パッケージは再リリースされリリース番号は1づつ増やされます。新しいバージョンのパッケージが出たら、リリース番号は1にリセットします。\n\n"
    },
    {
      "title": "epoch",
      "level": 3,
      "content": "バージョン番号が更新を引き起こさないときでも、(epoch が低い) 以前のバージョンよりもパッケージを新しいものだと強制的に見せるために使用されます。この変数の値は正の整数でなくてはなりません。指定されていない場合、デフォルトの値は 0 になります。パッケージのナンバリングの規則が変更されたり、バージョンの通常の比較ルールを破壊したいときに有用です。例:\n\n```\npkgver=5.13\npkgrel=2\nepoch=1\n```\n\n```\n1:5.13-2\n```\n\nバージョンの比較についての詳細は pacman(8) を見て下さい。\n\n"
    },
    {
      "title": "pkgdesc",
      "level": 3,
      "content": "パッケージの説明。これは 80 文字以下にすることをお勧めします。また、アプリケーション名がパッケージ名と異なる場合を除き、パッケージ名を自己参照的に含めないでください。たとえば、pkgdesc=\"Nedit is a text editor for X11\" の代わりに pkgdesc=\"Text editor for X11\" を使用します。\n\nまた、キーワードを賢く使用して、関連する検索クエリに表示される可能性を高めることも重要です。\n\n"
    },
    {
      "title": "arch",
      "level": 3,
      "content": "PKGBUILD がビルド・動作するアーキテクチャの文字列。現在、i686 と x86_64 が使えます。ただし、Arch Linux ARM などのプロジェクトでは他のアーキテクチャもサポートしています: arm (armv5), armv6h (armv6 hardfloat), armv7h (armv7 hardfloat), aarch64 (armv8 64bit)。\n\nアーキテクチャに依存しないパッケージ (シェルスクリプト, フォント, テーマなど) には any を使うことができます。-i686 や -x86_64 とは対照的に、一度ビルドしたら他のアーキテクチャでも使うことができるようなパッケージには -any を指定してください。全てのアーキテクチャに対応するようにパッケージをコンパイルすることができても、特定のアーキテクチャに向けてコンパイルされる場合は、Arch によって公式にサポートされているアーキテクチャを指定してください: arch=('i686' 'x86_64')。\n\n$CARCH 変数を使うことで、ビルドや、変数を定義する時にターゲットとするアーキテクチャを知ることができます。FS#16352 を参照してください。例:\n\n```\ndepends=(foobar)\nif test \"$CARCH\" == x86_64; then\n  depends+=(lib32-glibc)\nfi\n```\n\n"
    },
    {
      "title": "url",
      "level": 3,
      "content": "パッケージされるソフトウェアの公式サイトの URL。\n\n"
    },
    {
      "title": "license",
      "level": 3,
      "content": "ソフトウェアが配布されるライセンス。[core] の licenses パッケージは /usr/share/licenses/common によく使われるライセンスを保存しています、例えば /usr/share/licenses/common/GPL パッケージのライセンスがここに保存されているライセンスのどれかのときは、ディレクトリの名前を設定してください、例えば license=('GPL') 適切なライセンスが公式の licenses パッケージに含まれていない場合は、やる必要があることがいくつかあります:\n\n1. ライセンスファイルを次のディレクトリに含めなくてはなりません: /usr/share/licenses/pkgname/, 例 /usr/share/licenses/foobar/LICENSE\n1. ソース tarball にライセンスの詳細が含まれずウェブサイトなど他のところで示されている場合は、ライセンスをファイルにコピーしてそのファイルを含めて下さい。\n1. license 行に custom を追加してください。任意で、custom を custom:ライセンスの名前 にすることができます。あるライセンスが ([community] を含む) 公式リポジトリの2つ以上のパッケージで使われると、licenses パッケージに入れられます。\n\n- 特別な事例として BSD, MIT, zlib/png, Python ライセンスは licenses パッケージに含められていません。license 行の目的のために、一般的なライセンス (license=('BSD'), license=('MIT'), license=('ZLIB'), license=('Python')) として扱われておきながらそれぞれ固有の copyright 行を持っているために技術的にカスタムライセンスになっています。これら4つのライセンスを使っている全てのパッケージは /usr/share/licenses/pkgname 内にそのライセンスを保存しておく必要があります。パッケージによってはライセンスがひとつだけではないこともあります。そのような場合は、license 行に複数のエントリを書くことができます、例えば license=('GPL' 'custom:name of license')\n- さらに、(L)GPL には多くのバージョンと組み合わせが存在します。(L)GPL ソフトウェアで使えるのは: (L)GPL - (L)GPLv2 とそれ以降のバージョン (L)GPL2 - (L)GPL2 のみ (L)GPL3 - (L)GPL3 とそれ以降のバージョン\n- license が決められていないと、PKGBUILD.proto は unknown を使うことを提案します。ただし、ソフトウェアが利用できるかできないかについてはアップストリームに連絡をすべきです。\n\n- (L)GPL - (L)GPLv2 とそれ以降のバージョン\n- (L)GPL2 - (L)GPL2 のみ\n- (L)GPL3 - (L)GPL3 とそれ以降のバージョン\n\nこちらも参照 ノンフリーアプリケーションパッケージガイドライン\n\nフリーおよびオープン ソース ソフトウェア ライセンスに関する追加情報と展望は、次のページで見つけることができます。\n\n- 自由ソフトウェアライセンス\n- Wikipedia:Comparison of free and open-source software licenses\n- オープン ソースおよびフリー ソフトウェア プロジェクトの法的問題の入門書\n- GNU Project - さまざまなライセンスとそれらについての解説\n- Debian - ライセンス情報\n- Open Source Initiative - 名前別ライセンス\n\n"
    },
    {
      "title": "groups",
      "level": 3,
      "content": "パッケージが属する group たとえば、plasma をインストールすると、そのグループに属するすべてのパッケージがインストールされます。\n\n"
    },
    {
      "title": "depends",
      "level": 3,
      "content": "ソフトウェアを実行する前にインストールする必要があるパッケージの名前を示す文字列。ソフトウェアが依存パッケージの最低必要バージョンがあるときは、>= 演算子を使ってこれを表して下さい、例 depends=('foobar>=1.8.0')。あなたのソフトウェアが依存している他のパッケージの依存にすでに含まれているパッケージを depends に加える必要はありません。例えば、gtk2 は glib2 と glibc に依存しています。しかしながら、glibc は glib2 の依存にあるので gtk2 の依存として glibc を含める必要はありません。\n\n"
    },
    {
      "title": "optdepends",
      "level": 3,
      "content": "ソフトウェアを機能させるのには必要ないが機能を追加することができるパッケージの名前の文字列。それぞれのパッケージが提供する機能の説明も短く書いておいて下さい。例えば optdepends は以下のようになります:\n\n```\noptdepends=('cups: printing support'\n'sane: scanners support'\n'libgphoto2: digital cameras support'\n'alsa-lib: sound support'\n'giflib: GIF images support'\n'libjpeg: JPEG images support'\n'libpng: PNG images support')\n```\n\n"
    },
    {
      "title": "makedepends",
      "level": 3,
      "content": "ソフトウェアをビルドするためにインストールする必要はあるが、インストール後にソフトウェアを使うために残しておく必要はないパッケージの名前。depends 行と同じフォーマットを使ってパッケージの最小必要バージョンを指定できます。\n\n"
    },
    {
      "title": "checkdepends",
      "level": 3,
      "content": "テストスイートを実行するときに必要だが普通の実行時には必要ないパッケージの文字列。このリストのパッケージは depends と同じフォーマットに従います。check() 関数が makepkg によって実行される時だけこの依存関係が考慮されます。\n\n"
    },
    {
      "title": "provides",
      "level": 3,
      "content": "パッケージの機能を提供するパッケージ (もしくは cron や sh などの仮想パッケージ) の名前の文字列。同じものを提供するパッケージは互いに衝突しないかぎり同時にインストールすることができます。\n\n"
    },
    {
      "title": "conflicts",
      "level": 3,
      "content": "インストールするとパッケージと問題が生じるパッケージの名前の文字列。この名前を持つパッケージとこの名前の仮想パッケージを provides に入れている全てのパッケージが削除されます。depends 行と同じフォーマットを使って衝突するパッケージのバージョンプロパティを指定することもできます。\n\n競合は、pkgname および provides 配列で指定された名前に対してチェックされることに注意してください。したがって、パッケージが provides に foo 機能を備えている場合、conflicts 配列に foo を指定すると、あなたのパッケージと、provides 配列に foo を含む他のすべてのパッケージとの間の競合 (つまり、競合するすべてのパッケージ名を flicts 配列に指定する必要はありません) 具体的な例を挙げてみましょう。\n\n- netbeans は暗黙的に netbeans を pkgname 自身として提供しています。\n- netbeans-cppAUR は netbeans を提供し、netbeans と衝突します。\n- netbeans-phpAUR は netbeans を提供し、netbeans と衝突しますが、同じ機能を提供するパッケージは暗黙のうちに衝突するので、明示的に netbeans-cppAUR と衝突する必要はありません。\n\nパッケージが provides 配列を介して同じ機能を提供する場合、代替パッケージを conflicts 配列に明示的に追加する場合と追加しない場合には違いがあります。conflicts 配列が明示的に宣言されている場合、同じ機能を提供する 2 つのパッケージが 代替 とみなされます。conflicts 配列が欠落している場合、同じ機能を提供する 2 つのパッケージが 共存している可能性がある とみなされます。パッケージャは、conflicts 変数を宣言するかどうかを決定する際に、provides 変数の内容を常に無視する必要があります。\n\n"
    },
    {
      "title": "replaces",
      "level": 3,
      "content": "例えば wireshark-qt は replaces=('wireshark') を使います。同期する時、pacman はインストールされたパッケージがリポジトリで replaces にマッチする別のパッケージに出会ったら即座に置き換えます。既にあるパッケージの別バージョンを提供したり AUR にアップロードする時は conflicts と provides 配列を使ってください。\n\n"
    },
    {
      "title": "backup",
      "level": 3,
      "content": "ユーザーが作成した変更を含んだり、パッケージのアップグレードや削除が行われても維持されるファイルの文字列、主に /etc 内の設定ファイル用。\n\nアップデート時、既存のファイル(ユーザーによって修正されたファイル)を上書きしないために新しいバージョンは file.pacnew として保存されます。同じく、パッケージの削除時、パッケージを削除するのに pacman -Rn コマンドを使わなければ、ユーザーが修正したファイルは file.pacsave として残されます。\n\nこの行のファイルパスは絶対パス (例: /etc/pacman.conf) ではなく相対パス (例: etc/pacman.conf) にしてください。Pacnew と Pacsave ファイルも参照。\n\n"
    },
    {
      "title": "options",
      "level": 3,
      "content": "この文字列を使うと /etc/makepkg.conf で定義された makepkg のデフォルトの挙動の一部を上書きできます。オプションをセットするには、文字列にオプションの名前を入れて下さい。デフォルトの挙動を逆にするには、オプションの前に ! を付けて下さい。options には以下のオプションを置くことが可能です:\n\n- strip - バイナリとライブラリからシンボルを除去。プログラムやライブラリでデバッガを頻繁に使う時は、このオプションを無効にすると便利です。\n- docs - /doc ディレクトリを保存。\n- libtool - パッケージに libtool (.la) ファイルを残す。\n- staticlibs - パッケージに静的ライブラリ (.a) のファイルを残す。\n- emptydirs - パッケージに空のディレクトリを残す。\n- zipman - man と info ページを gzip で圧縮。\n- purge - パッケージの PURGE_TARGETS 変数で指定されたファイルを削除。\n- upx - UPX を使って実行可能バイナリを圧縮。UPXFLAGS 変数を指定することで UPX に追加オプションを渡せます。\n- ccache - ビルド中の ccache の使用を許可。ccache を使ってビルドすると問題が起こるパッケージに無効化の !ccache を使うと便利です。\n- distcc - ビルド中の distcc の使用を許可。distcc を使ってビルドすると問題が起こるパッケージに無効化の !distcc を使うと便利です。\n- buildflags - ビルド中にユーザー定義の buildflags (CFLAGS, CXXFLAGS, LDFLAGS) の使用を許可。カスタムした buildflags を使ってビルドすると問題が起こるパッケージに無効化の !buildflags を使うと便利です。\n- makeflags - ビルド中にユーザー定義の makeflags の使用を許可。カスタムした makeflags を使ってビルドすると問題が起こるパッケージに無効化の !makeflags を使うと便利です。\n\n"
    },
    {
      "title": "install",
      "level": 3,
      "content": "パッケージに含まれる .install スクリプトの名前。pkgname と同じ名前にしてください。パッケージのインストール・削除・アップグレードの際に、pacman はパッケージごとにスクリプトを保存・実行する機能があります。スクリプトには、実行される段階によって以下の関数を含めることができます:\n\n- pre_install - ファイルが展開される前にスクリプトを実行。1つの引数が渡されます: 新しいパッケージのバージョン。\n- post_install - ファイルが展開された後にスクリプトを実行。1つの引数が渡されます: 新しいパッケージのバージョン。\n- pre_upgrade - ファイルが展開される前にスクリプトを実行。2つの引数が渡されます: 新しいパッケージのバージョン, 古いパッケージのバージョン。\n- post_upgrade - ファイルが展開された後にスクリプトを実行。2つの引数が渡されます: 新しいパッケージのバージョン, 古いパッケージのバージョン。\n- pre_remove - ファイルが削除される前にスクリプトを実行。1つの引数が渡されます: 古いパッケージのバージョン。\n- post_remove - ファイルが削除された後にスクリプトを実行。1つの引数が渡されます: 古いパッケージのバージョン。\n\nそれぞれの関数は pacman のインストールディレクトリの中に chroot されて実行されます。このスレッド を見て下さい。\n\n"
    },
    {
      "title": "changelog",
      "level": 3,
      "content": "パッケージの変更履歴の名前。インストールされたパッケージの変更履歴を表示するには:\n\n```\n$ pacman -Qc pkgname\n```\n\n"
    },
    {
      "title": "source",
      "level": 3,
      "content": "パッケージをビルドするのに必要なファイルの文字列。ソフトウェアのソースの場所を入れる必要があり、多くの場合 HTTP や FTP の URL です。前に設定した pkgname や pkgver 変数をここで使うことができます (例: source=(http://example.com/$pkgname-$pkgver.tar.gz))。\n\n自作のパッチなど、オンザフライでダウンロードできないファイルを供給する必要があるときは、PKGBUILD ファイルがあるところと同じディレクトリにそのファイルを入れて source にファイル名を追加するだけです。ここに追加したパスはすべて PKGBUILD があるディレクトリから相対的に考えられます。本当のビルドプロセスが始まる前に、この行で参照されている全てのファイルがダウンロードされるか存在を確認します。もしファイルが欠けている場合は makepkg は次に進みません。\n\n拡張子が .sig, .sign, .asc のファイルを source 配列に指定した場合、makepkg はそれを PGP 署名として認識して、ソースファイルの整合性を確認するのに自動的に用います。\n\n"
    },
    {
      "title": "noextract",
      "level": 3,
      "content": "source 行で makepkg によって圧縮フォーマットを展開してはいけないファイルの文字列。libarchive は unzip とは違い全てのファイルをランダムアクセスではなくストリームで処理するので、/usr/bin/bsdtar によって扱えない圧縮ファイルに noextract を使うのがほとんどです。こういった場合には他の解凍ツール (例: unzip, p7zip など) を makedepends に追加して prepare() 関数の最初の行でソースの圧縮ファイルを手動で展開する必要があります。例えば:\n\n```\nprepare() {\n  lrzip -d source.tar.lrz\n}\n```\n\nsource 行には URL を指定することが可能ですが、noextract にはファイル名の一部だけを指定します。例えば、以下のようにすることができます (grub2 の PKGBUILD から引用):\n\n```\nsource=(\"http://ftp.archlinux.org/other/grub2/grub2_extras_lua_r20.tar.xz\")\nnoextract=(\"grub2_extras_lua_r20.tar.xz\")\n```\n\n何も展開しないようにするには、以下のように工夫してください (firefox-i18n から引用):\n\n```\nnoextract=(${source[@]%%::*})\n```\n\n"
    },
    {
      "title": "validpgpkeys",
      "level": 3,
      "content": "PGP フィンガープリントの配列。validpgpkeys を使用した場合、makepkg は validpgpkeys に記載されている鍵の署名だけを使うようにして鍵束の値は無視します。ソースファイルが副鍵で署名されていた場合、makepkg は主鍵を使って比較します。\n\n指定できるのは完全なフィンガープリントだけです。全て大文字で空白を含めてはいけません。\n\n"
    },
    {
      "title": "整合性",
      "level": 2,
      "content": "以下の変数はどれもチェックサム文字列を指定するようになっており、source 配列に書かれたファイルの整合性を確認するのに使われます。SKIP とすることで特定のファイルのチェックサムを確認しないようにできます。\n\nチェックサムの種類と値は、リリースアナウンスなど上流から提供されたものを常に使用する必要があります。複数のタイプが利用可能な場合は、最も強力なチェックサムが優先されます。sha512 よりも b2, sha384 よりも sha384, sha256 よりも sha512 を優先してください, sha224 に対して sha256、sha1 に対して sha224、md5 に対して sha1、および md5 以上 ck} があります。これは、上流のアナウンスからパッケージのビルドまで、ダウンロードしたファイルの完全性を保証するために最適な方法です。\n\nこれらの変数の値は makepkg の -g/--geninteg オプションで自動生成され、一般に makepkg -g >> PKGBUILD で追加されます。pacman-contrib の updpkgsums(8) コマンドは PKGBUILD 内のどこにあっても変数を更新することが可能です。どちらのツールも PKGBUILD に既に設定されている変数を使い、設定されていない場合は md5sums にフォールバックします。\n\n使用するファイルの整合性チェックは /etc/makepkg.conf の INTEGRITY_CHECK オプションで設定することができます。 makepkg.conf(5) を参照してください。\n\n"
    },
    {
      "title": "cksums",
      "level": 3,
      "content": "source 配列にリストされているファイルの CRC32 チェックサム (UNIX 標準 cksum より)\n\n"
    },
    {
      "title": "md5sums",
      "level": 3,
      "content": "source 行に含まれるファイルの 128 ビット MD5 チェックサムの文字列。\n\n"
    },
    {
      "title": "sha1sums",
      "level": 3,
      "content": "source 行に含まれるファイルの 160ビットの SHA-1 チェックサムの文字列。\n\n"
    },
    {
      "title": "sha256sums",
      "level": 3,
      "content": "ダイジェスト サイズが 256 ビットの SHA-2 チェックサムの配列。\n\n"
    },
    {
      "title": "sha224sums, sha384sums, sha512sums",
      "level": 3,
      "content": "それぞれ 224, 384, 512 ビットのダイジェストサイズの SHA-2 チェックサムの文字列。sha256sums の代替ですが、あまり一般的ではない代替手段です。\n\n"
    },
    {
      "title": "b2sums",
      "level": 3,
      "content": "BLAKE2 チェックサムの配列で、ダイジェスト サイズは 512 ビットです。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- PKGBUILD(5) マニュアルページ\n- サンプル PKGBUILD ファイル\n\n"
    }
  ]
}