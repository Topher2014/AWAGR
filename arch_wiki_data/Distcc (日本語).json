{
  "title": "Distcc (日本語)",
  "url": "https://wiki.archlinux.org/title/Distcc_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- TORQUE\n- Slurm\n\ndistcc は C, C++, Objective C, Objective C++ のコードのビルドをネットワーク上の複数のマシンに分散させるプログラムです。distcc は常にローカルビルドと同じ結果を生成し、インストールと使用方法がシンプルで、ローカルコンパイルよりもずっと高速です。makepkg などの Arch のビルドツールで使うことができます。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 用語\n- 2 インストール\n- 3 設定 3.1 動作モード 3.2 ボランティア 3.3 クライアント 3.3.1 makepkg を使用する場合 3.3.1.1 Plain mode の例 3.3.1.2 Pump mode の例 3.3.2 makepkg を使用しない場合 3.3.2.1 Plain mode の例 3.3.2.2 Pump mode の例\n- 4 コンパイル 4.1 makepkg を使用する場合 4.1.1 Plain mode の例 4.1.2 Pump mode の例 4.2 makepkg を使用しない場合 4.2.1 Plain mode の例 4.2.2 Pump mode の例 4.3 CMake を使用する場合\n- 5 進捗を見る\n- 6 distcc でクロスコンパイル 6.1 クライアントとしての Arch Linux ARM (ボランティアとしての x86_64) 6.1.1 ボランティア 6.1.2 クライアント 6.1.2.1 ARM クライアント上の localhost に関する注意事項 6.2 クライアントとしての Arch Linux (x86_64) (ボランティアとしての Arch ARM) 6.2.1 クライアント 6.2.2 ボランティア 6.3 追加のツールチェーン\n- 7 トラブルシューティング 7.1 ArchLinux カーネルパッケージをコンパイルするコツ 7.2 chromium をコンパイルするコツ 7.3 Journalctl 7.4 ログレベルを設定する 7.5 $HOME/.distcc を移動して HDD/SSD の使用量を制限する 7.6 distccd-alarm の場合 7.6.1 No such file or directory 7.7 distccd.service の起動時に Avahi-daemon が発行を停止する\n- 8 参照\n\n- 3.1 動作モード\n- 3.2 ボランティア\n- 3.3 クライアント 3.3.1 makepkg を使用する場合 3.3.1.1 Plain mode の例 3.3.1.2 Pump mode の例 3.3.2 makepkg を使用しない場合 3.3.2.1 Plain mode の例 3.3.2.2 Pump mode の例\n\n- 3.3.1 makepkg を使用する場合 3.3.1.1 Plain mode の例 3.3.1.2 Pump mode の例\n- 3.3.2 makepkg を使用しない場合 3.3.2.1 Plain mode の例 3.3.2.2 Pump mode の例\n\n- 3.3.1.1 Plain mode の例\n- 3.3.1.2 Pump mode の例\n\n- 3.3.2.1 Plain mode の例\n- 3.3.2.2 Pump mode の例\n\n- 4.1 makepkg を使用する場合 4.1.1 Plain mode の例 4.1.2 Pump mode の例\n- 4.2 makepkg を使用しない場合 4.2.1 Plain mode の例 4.2.2 Pump mode の例\n- 4.3 CMake を使用する場合\n\n- 4.1.1 Plain mode の例\n- 4.1.2 Pump mode の例\n\n- 4.2.1 Plain mode の例\n- 4.2.2 Pump mode の例\n\n- 6.1 クライアントとしての Arch Linux ARM (ボランティアとしての x86_64) 6.1.1 ボランティア 6.1.2 クライアント 6.1.2.1 ARM クライアント上の localhost に関する注意事項\n- 6.2 クライアントとしての Arch Linux (x86_64) (ボランティアとしての Arch ARM) 6.2.1 クライアント 6.2.2 ボランティア\n- 6.3 追加のツールチェーン\n\n- 6.1.1 ボランティア\n- 6.1.2 クライアント 6.1.2.1 ARM クライアント上の localhost に関する注意事項\n\n- 6.1.2.1 ARM クライアント上の localhost に関する注意事項\n\n- 6.2.1 クライアント\n- 6.2.2 ボランティア\n\n- 7.1 ArchLinux カーネルパッケージをコンパイルするコツ\n- 7.2 chromium をコンパイルするコツ\n- 7.3 Journalctl\n- 7.4 ログレベルを設定する\n- 7.5 $HOME/.distcc を移動して HDD/SSD の使用量を制限する\n- 7.6 distccd-alarm の場合 7.6.1 No such file or directory\n- 7.7 distccd.service の起動時に Avahi-daemon が発行を停止する\n\n- 7.6.1 No such file or directory\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "クラスタの PC 全てに distcc パッケージをインストールしてください。\n\n他のディストロや、Cygwin を使用する Windows など他の OS を使う場合は、distcc のドキュメント を参照してください。\n\n"
    },
    {
      "title": "動作モード",
      "level": 3,
      "content": "Distcc は、Plain mode (デフォルト) または Pump モードで実行できます。大まかに言えば、主な違いは、distcc が前処理されたソースを処理する方法にあります。Plain mode では、完全なソースとコンパイラ引数が転送されます。前処理はクライアント上で保持されます。Pump モードでは、前処理とコンパイルの両方が distcc クラスターに分散され、多くの場合、より効率的かつ高速になります。詳細については、distcc(1) を参照してください。\n\n"
    },
    {
      "title": "ボランティア",
      "level": 3,
      "content": "ボランティアの設定は /etc/conf.d/distccd に保存されます。少なくとも、多くの ipv4 プライベートネットワーク範囲をカバーする --allow-private スイッチを追加するか、ipv6 対応ネットワークがある場合は ipv6 CIDR で --allow を使用します。ファイルへのログ記録は、必要に応じてトラブルシューティングにも役立ちます。\n\n```\nDISTCC_ARGS=\"--allow-private --log-file /tmp/distccd.log\"\n```\n\nまたは、IPv6 アクセスを許可する必要があり、ネットワーク CIDR が /64 である場合:\n\n```\nDISTCC_ARGS=\"--allow-private --allow aaaa:bbbb:cccc:dddd:eeee:::/64 --log-file /tmp/distccd.log\"\n```\n\nマシン上に複数のインターフェイスが存在する場合は、--listen ADDRESS オプションも渡すことを検討してください。他のオプションも定義できます。distccd(1) を参照してください。\n\n参加しているすべてのボランティアの distccd.service を 起動/有効化 します。\n\n"
    },
    {
      "title": "makepkg を使用する場合",
      "level": 4,
      "content": "次のセクションの /etc/makepkg.conf を編集します。\n\n1. BUILDENV 配列には distcc をアンバンする必要があります。つまり、感嘆符なしでリストする必要があります。\n1. DISTCC_HOSTS 行のコメントを解除し、ボランティアのホスト名または IP アドレスを追加します。必要に応じて、この後にスラッシュと使用するスレッドの最大数を続けます。後続のノードは空白で区切る必要があります。このリストは、最も強力なものから (処理能力) の順に並べる必要があります。\n1. サーバーあたりの最大スレッド数の約 2 倍に相当するように MAKEFLAGS 変数を調整します。以下の例では、2x(9+5+5+3)=44 となります。\n\n真に汎用的な設定は存在しないことに注意してください。1 つ試してテストし、結果を他の設定と比較します。以下に、一般的な設定をいくつか示します。\n\n```\nBUILDENV=(distcc fakeroot color !ccache check !sign)\nMAKEFLAGS=\"-j44\"\nDISTCC_HOSTS=\"localhost/9 192.168.10.2/5 192.168.10.3/5 192.168.10.4/3\"\n```\n\n```\nBUILDENV=(distcc fakeroot color !ccache check !sign)\nMAKEFLAGS=\"-j70\"\nDISTCC_HOSTS=\"localhost/9 192.168.10.2,cpp,lzo 192.168.10.3,cpp,lzo 192.168.10.4,cpp,lzo\"\n```\n\nここで注意すべき点がいくつかあります。\n\n- Pump mode は、一般に、Plain mode よりも、MAKEFLAGS の 値が高い方が良い性能を発揮します。\n- Pump mode では、IPまたはホスト名は、Pump mode が要求するように、リテラル ',cpp,lzo' でサフィックスされます。さらに、この例の localhost はそうなっていません。これは、distcc が 9 つのジョブが定義された localhost をロードし、より積極的に有志にコード生成を分配することを意味します。より大規模なクラスタでは、クラスタへの分散処理を可能にするために、localhost 上のローカルジョブの数をより少なく制限したいと思うかもしれません。また、localhost の接尾辞に,cpp,lzo を使用することもできます。\n- 前述したように、すべての distcc クラスタで効率的に動作する単一の設定はありません/最適な設定の決定は、テストとベンチマークを通じて経験的に導き出されます。\n\n"
    },
    {
      "title": "makepkg を使用しない場合",
      "level": 4,
      "content": "クライアント上の distcc の最小設定には、利用可能なボランティアの設定と PATH の再定義が含まれます。\n\n```\n$ export PATH=\"/usr/lib/distcc/bin:$PATH\"\n$ export DISTCC_HOSTS=\"localhost/9 192.168.10.2/5 192.168.10.3/5 192.168.10.4/3\"\n```\n\n```\n$ export PATH=\"/usr/lib/distcc/bin:$PATH\"\n$ export DISTCC_HOSTS=\"localhost/9 192.168.10.2,cpp,lzo 192.168.10.3,cpp,lzo 192.168.10.4,cpp,lzo\"\n```\n\n"
    },
    {
      "title": "Plain mode の例",
      "level": 4,
      "content": "/etc/makepkg.conf が設定されたら、特別な手順は必要ありません。通常どおり makepkg を呼び出すだけです。\n\n"
    },
    {
      "title": "Pump mode の例",
      "level": 4,
      "content": "ユーザーは、makepkg を使用するかシェル上でコンパイルする前に Pump を開始する必要があります。Pump には、正しく設定された一連の DISTCC_HOSTS があることを確認するチェックが含まれているため、最初に偽の DISTCC_HOSTS 行を定義する必要があります。makepkg は、/etc/makepkg.conf で指定された値を使用することに注意してください。\n\n```\n$ export DISTCC_HOSTS=\"localhost,cpp,lzo\"\n$ eval $(pump --startup)\n```\n\nここで、通常どおり makepkg を呼び出します。\n\n終了したら、必要に応じて Pump を停止します:\n\n```\n$ pump --shutdown\n```\n\n"
    },
    {
      "title": "Plain mode の例",
      "level": 4,
      "content": "#makepkg を使用しない場合 で説明されている 2 つの変数をエクスポートした後、コンパイラを呼び出すだけです:\n\n```\n$ make -j44\n```\n\n一部のプログラムでは、適切に動作するために CC 変数または CXX 変数、あるいはその両方を定義する必要がある場合があります:\n\n```\n$ make -j44 CC=distcc CXX=distcc\n```\n\n"
    },
    {
      "title": "Pump mode の例",
      "level": 4,
      "content": "上図のように Pump を始動します。コンパイルは Plain mode の例と変わりません。\n\n"
    },
    {
      "title": "CMake を使用する場合",
      "level": 3,
      "content": "distcc で CMake ベースのプロジェクトをビルドするには、次の CMake オプションを使用します:\n\n```\n$ cmake -DCMAKE_C_COMPILER_LAUNCHER=distcc -DCMAKE_CXX_COMPILER_LAUNCHER=distcc ...\n```\n\n"
    },
    {
      "title": "進捗を見る",
      "level": 2,
      "content": "distcc には、コンパイルステータスをチェックするために使用できる cli モニター distccmon-text が付属しています。\n\ncliモニターは、繰り返しクエリーを待つ秒数に相当するスペースと整数をコマンドに付加することで、連続的に実行できます:\n\n```\n$ distccmon-text 3\n```\n\n```\n29291 Preprocess  probe_64.c                                 192.168.10.2[0]\n30954 Compile     apic_noop.c                                192.168.10.2[0]\n30932 Preprocess  kfifo.c                                    192.168.10.2[0]\n30919 Compile     blk-core.c                                 192.168.10.2[1]\n30969 Compile     i915_gem_debug.c                           192.168.10.2[3]\n30444 Compile     block_dev.c                                192.168.10.3[1]\n30904 Compile     compat.c                                   192.168.10.3[2]\n30891 Compile     hugetlb.c                                  192.168.10.3[3]\n30458 Compile     catalog.c                                  192.168.10.4[0]\n30496 Compile     ulpqueue.c                                 192.168.10.4[2]\n30506 Compile     alloc.c                                    192.168.10.4[0]\n```\n\n"
    },
    {
      "title": "distcc でクロスコンパイル",
      "level": 2,
      "content": "distcc を使用すると、クロスコンパイルを支援できます:\n\n- ターゲットアーキテクチャを実行しているマシンをクライアントとして使用する必要があります。\n- 非ネイティブアーキテクチャのボランティアがコンパイルを支援しますが、対応するツールチェーンがインストールされていて、それを指す distccd が必要です。\n\n"
    },
    {
      "title": "クライアントとしての Arch Linux ARM (ボランティアとしての x86_64)",
      "level": 3,
      "content": "このセクションでは、Arch Linux (x86_64) ボランティアを使用して Arch ARM デバイスのクロスコンパイルを支援する方法について詳しく説明します。ARM デバイスのコンパイルを支援する 1 台の x86_64 マシンだけで 2 〜 4 倍程度の速度向上が実現できるという証拠については、これらのテスト を参照してください。\n\n"
    },
    {
      "title": "ボランティア",
      "level": 4,
      "content": "Arch ARM 開発者は、x86_64 ボランティアにインストールする必要がある公式プロジェクト ツールチェーン を使用することを 強く 推奨します。これらを手動で管理するのではなく、AUR は 2 つのツールチェーンと構成および systemd サービス ユニットを提供します。\n\n- distccd-alarm-armv7hAUR\n- distccd-alarm-armv8AUR\n\narm/arm64 ツールチェーンを含むボランティアのセットアップは、構成と systemd サービスファイルの名前がそれぞれのパッケージの名前と一致することを除いて、#ボランティア と同じです。たとえば、armv7h の場合、設定ファイルは /etc/conf.d/distccd-'armv7h で、systemd サービスユニットは distccd-armv7h.service です。\n\n各ツールチェーンは固有のポート上で実行されるため、必要に応じて 4 つすべてがボランティア上で共存できることに注意してください。カテゴリ:ファイアウォール と distcc(1) を参照して、distcc が実行されているポートへのトラフィックを必ず許可してください。\n\nTable content:\nターゲットアーキテクチャ | Distcc ポート\narmv7h | 3635\narmv8h/aarch64 | 3636\n\n"
    },
    {
      "title": "クライアント",
      "level": 4,
      "content": "Arch ARM クライアントをセットアップする最も簡単な方法は、distccd-arch-armAUR を使用することです。これは、Arch ARM の 4 つのフレーバーすべてをカバーする 4 つの構成すべてと systemd サービスユニットを提供します。たとえば、Arch ARM クライアントが armv7h イメージを実行している場合は、必要に応じて /etc/conf.d/distccd-armv7h を編集し、そのデフォルトを変更します。ビルドの準備ができたら、distccd-armv7h.service 有効化 してコンパイルします。\n\nより詳細なチュートリアルについては、use-examples を参照してください。\n\n上記の AUR パッケージを使用せずにクライアントをセットアップしたい場合、クライアントの手動セットアップは #クライアント と同じですが、次の 2 つのファイルを変更してボランティアが使用する非標準ポートを定義する必要がある点が異なります。AUR パッケージを使用する場合は、上の表を参照してください。\n\n1. /etc/conf.d/distccd:armv7h マシンの例: DISTCC_ARGS=\"--allow-private --log-level info --log-file /tmp/distccd-armv7h.log --port 3635\"\n1. /etc/makepkg.conf: armv7h マシンの例: DISTCC_HOSTS=\"192.168.10.2/5:3635 192.168.10.3/5:3635\"\n\nx86_64 ボランティアを使用して Arch ARM デバイス上に構築する場合、多くの ARM デバイスには必要な処理能力がないため、localhost ディレクティブを DISTCC_HOSTS から除外することを強くお勧めします。\n\nこの効果を説明するために、Linux カーネルバージョン 5.10.44' のイメージターゲットをコンパイルする次の例を考えてみましょう。クライアントは RPi4B (aarch64) で、ボランティア (192.168.1.288) はクアッドコア/ハイパースレッドの Intel マシンです。各コンパイルジョブは 1 回だけ実行され、その合間に make clean が実行されました。\n\nTable content:\nDISTCC_HOSTS= | タイム (mm:ss) | Fold slower\n\"192.168.1.288:3636/9\" | 6:50 | -\n\"localhost/5 192.168.1.288:3636/9\" | 10:34 | 2.8x\n\"192.168.1.288:3636/9 localhost/5\" | 10:13 | 2.7x\n\n"
    },
    {
      "title": "クライアントとしての Arch Linux (x86_64) (ボランティアとしての Arch ARM)",
      "level": 3,
      "content": "このセクションでは、Arch ARM ボランティアを使用して x86_64 クライアントのクロスコンパイルを支援する方法について詳しく説明します。コンパイル時間が大幅に長くなる可能性があることを示す証拠については、these testing を参照してください。Arch ARM ボランティアを 1 人でも使用すると速度が向上し、最大 2 つでその効果が 2 倍になります。\n\n"
    },
    {
      "title": "クライアント",
      "level": 4,
      "content": "クライアントのセットアップは #クライアント と同じで、distcc は標準ポート 3632 で実行されます。\n\n"
    },
    {
      "title": "ボランティア",
      "level": 4,
      "content": "distccd-x86_64AUR は、クロスコンパイルを可能にするために Arch ARM デバイスにインストールするツールチェーンを提供します。\n\n"
    },
    {
      "title": "追加のツールチェーン",
      "level": 3,
      "content": "- EmbToolkit: クロスコンパイルツールチェインを作成するためのツール。ARM と MIPS アーキテクチャをサポートしており、LLVM ベースのツールチェインのビルドをサポートしています。\n- crosstool-ng: EmbToolkit と同じようなツール。EmbToolkit よりも多数のアーキテクチャをサポートしています (詳しくはウェブサイトを参照)。\n- Linaro: ARM 開発用のツールチェインを提供しています。\n\nEmbToolkit にはツールチェインを設定するためのグラフィカルな設定メニュー (make xconfig) が付属しています。\n\n"
    },
    {
      "title": "ArchLinux カーネルパッケージをコンパイルするコツ",
      "level": 3,
      "content": "公式の PKGBUILD (または AUR からの多く)からカーネルをビルドする場合は、ビルドコマンドの一部としてCC=distcc 変数と CXX=distcc 変数を渡すように PKGBUILD を編集する必要があります。\n\n```\nmake bzImage modules htmldocs CC=distcc CXX=distcc\n```\n\nこれを行わないと、ビルド中に distcc が機能しなくなります。 FS#64275 を参照してください。\n\n"
    },
    {
      "title": "chromium をコンパイルするコツ",
      "level": 3,
      "content": "clang を使用する chromium のコンパイルは、現在 issue#386 の影響を受けています。 バグを回避するには、 [1] に従って PKGBUILD の _flags 配列に以下を追加します。 こちら ブログ:\n\n```\n'clang_use_default_sample_profile=false'\n'is_cfi=false'\n```\n\n"
    },
    {
      "title": "Journalctl",
      "level": 3,
      "content": "問題が発生したときは journalctl を使って原因を確認してください:\n\n```\n$ journalctl $(which distccd) -e --since \"5 min ago\"\n```\n\n"
    },
    {
      "title": "ログレベルを設定する",
      "level": 3,
      "content": "デフォルトでは、distcc は /var/log/messages.log にログを出力します。このログはファイルに直接出力することができます (distccd の man ページで実際に推奨されています)。ログファイルを /tmp を使って RAM 上に配置することも可能です。また、ログファイルに出力されるエラーのログレベルを下げることもできます。接続のエントリよりもエラーメッセージを見たいというときに有用です。LEVEL は標準的な syslog のレベルで設定でき critical, error, warning, notice, info, debug などを指定します。\n\n以下の行を /etc/conf.d/distccd の DISTCC_ARGS に追記してください:\n\n```\nDISTCC_ARGS=\"--user nobody --allow 192.168.0.0/24 --log-level error --log-file /tmp/distccd.log\"\n```\n\n"
    },
    {
      "title": "$HOME/.distcc を移動して HDD/SSD の使用量を制限する",
      "level": 3,
      "content": "デフォルトでは、distcc は $HOME/.distcc を作成して、一時的に情報を保存してノードにコンパイルさせる作業を割り当てます。/tmp などの RAM に .distcc という名前のディレクトリを作成して $HOME の .distcc にソフトリンクします。これで無駄な HDD の読み書きが減ります。特に SSD の場合は効果的です。\n\n```\n$ mv $HOME/.distcc /tmp\n$ ln -s /tmp/.distcc $HOME/.distcc\n```\n\nsystemd を使って再起動時にこのディレクトリを再作成 (他のファイルと同じように手動で削除されるまでソフトリンクは消えません) します。以下の tmpfile を作成:\n\n```\n/etc/tmpfiles.d/tmpfs-create.conf\n```\n\n```\nd /tmp/.distcc 0755 <username> users -\n```\n\n"
    },
    {
      "title": "No such file or directory",
      "level": 4,
      "content": "次のようなエラーは、ユーザが distcc によって提供される distccd サービスを誤って実行しており、 distccd-alarm パッケージ (つまり、distccd-alarm-armv5AUR、 distccd-alarm-armv6hAUR、distccd-alarm-armv7hAUR、 または distccd-alarm-armv8AURです。) によって提供されていないことを示します。\n\nターゲットアーキテクチャに適したサービスを開始してください。\n\n```\ndistcc[25479] (dcc_execvp) ERROR: failed to exec armv7l-unknown-linux-gnueabihf-g++: No such file or directory\n```\n\n"
    },
    {
      "title": "distccd.service の起動時に Avahi-daemon が発行を停止する",
      "level": 3,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: This does not fix anything if the user 再起動s the service later. (議論: トーク:Distcc#)\n\ndistccd.service をサービスとして起動すると、 avahi-daemon の動作が停止する場合があります。これは、 avahi-daemon.service のユニットファイル (ユニットファイルの編集 を参照してください。) を編集し、 [Unit] セクションの最後に After=distccd.service を追加することで、 avahi-daemon.service が distccd.service の後に開始されるようにすることで軽減できます。\n\n```\n/etc/systemd/system/avahi-daemon.service\n```\n\n```\n...\n\n[Unit]\nDescription=Avahi mDNS/DNS-SD Stack\nRequires=avahi-daemon.socket\nAfter=distccd.service\n\n...\n```\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- https://github.com/distcc/distcc\n\n- icecreamAUR - An easier to configure fork of distcc.\n\n"
    }
  ]
}