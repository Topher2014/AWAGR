{
  "title": "ブートローダー",
  "url": "https://wiki.archlinux.org/title/%E3%83%96%E3%83%BC%E3%83%88%E3%83%AD%E3%83%BC%E3%83%80%E3%83%BC",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Master Boot Record\n- GUID Partition Table\n- Unified Extensible Firmware Interface\n- mkinitcpio\n- init\n- systemd\n- fstab\n- 自動起動\n\nArch Linux を起動するためには、Linux 対応のブートローダーをセットアップする必要があります。ブートローダは、ブートプロセスが始まる前にカーネルや初期 RAM ディスクをロードする仕事を行います。BIOS と UEFI で起動の流れはかなり異なっています。このページや関連するページに詳しい説明があります。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 ファームウェアの種類 1.1 BIOS 1.2 UEFI\n- 2 システムの初期化 2.1 BIOS 2.2 UEFI 2.2.1 UEFI でのマルチブート\n- 3 ブートローダー 3.1 機能比較\n- 4 カーネル\n- 5 initramfs 5.1 initramfs無しで起動\n- 6 初期ユーザ空間\n- 7 後期ユーザ空間 7.1 getty 7.1.1 ログイン 7.1.2 シェル 7.2 ディスプレイマネージャ 7.2.1 グラフィカルセッション (Xorg)\n- 8 参照\n\n- 1.1 BIOS\n- 1.2 UEFI\n\n- 2.1 BIOS\n- 2.2 UEFI 2.2.1 UEFI でのマルチブート\n\n- 2.2.1 UEFI でのマルチブート\n\n- 3.1 機能比較\n\n- 5.1 initramfs無しで起動\n\n- 7.1 getty 7.1.1 ログイン 7.1.2 シェル\n- 7.2 ディスプレイマネージャ 7.2.1 グラフィカルセッション (Xorg)\n\n- 7.1.1 ログイン\n- 7.1.2 シェル\n\n- 7.2.1 グラフィカルセッション (Xorg)\n\n"
    },
    {
      "title": "ファームウェアの種類",
      "level": 2,
      "content": "ファームウェアは、システムの電源を入れた時に一番最初に実行されるプログラムのことです。\n\n"
    },
    {
      "title": "BIOS",
      "level": 3,
      "content": "BIOS (Basic Input-Outout System) は、ほとんどの場合マザーボード内のフラッシュメモリに保存され、システムストレージとは独立しています。元々は IBM PC がハードウェアの初期化やブートプロセスを処理するために作成されました。2010 年より、BIOS にあるような技術的な制約が存在しない UEFI に徐々に置き換えられています。\n\n"
    },
    {
      "title": "UEFI",
      "level": 3,
      "content": "Unified Extensible Firmware Interface は、パーティションテーブルとファイルシステムの両方の読み取りをサポートしています。UEFI は Master Boot Record (MBR) 内のブートコードを起動しません (たとえ、それが有ろうと無かろうと)。代わりに、起動は NVRAM 内のブートエントリに頼っています。\n\nUEFI 仕様では FAT12、FAT16、および FAT32 ファイルシステム (UEFI 仕様バージョン2.8、セクション13.3.1.1 を参照) のサポートが義務付けられていますが、規格に準拠しているベンダーは任意でファイルシステムのサポートを追加できます。たとえば、Apple の一部のファームウェアでは HFS+ か APFS のサポートがあります。UEFI の実装では、光ディスク用の ISO 9660 もサポートされています。\n\nUEFIは、ブートローダー 、ブートマネージャ、 UEFI シェル などの EFI アプリケーションを起動します。これらのアプリケーションは通常、 EFI システムパーティション にファイルとして保存されます。各ベンダーは、EFI システムパーティションの /EFI/vendor_name フォルダにファイルを格納できます。アプリケーションを起動するには、NVRAM に、または UEFI シェルからブートエントリを追加します。\n\nUEFI 仕様では、互換性サポートモジュール (CSM) によるレガシー BIOS ブートがサポートされています。UEFI で CSM が有効な場合、UEFI はすべてのドライブの CSM ブートエントリを生成します。CSM ブートエントリがブート元として選択された場合、UEFI の CSM はドライブの MBR ブートストラップコードからのブートを試みます。\n\n"
    },
    {
      "title": "BIOS",
      "level": 3,
      "content": "1. システムの電源が入れられ POST が実行される。\n1. BIOS が、ブートに必要なシステムハードウェア (ディスクやキーボードコントローラなど) を初期化する。\n1. BIOS のディスク順で最初のディスクの最初の440バイト (Master Boot Record) が BIOS によって実行される。\n1. MBR ブートコード内の、ブートローダの最初のステージが、2番めのステージコードを以下のどれかから実行する: MBR の次のディスクセクタ。つまり、post-MBR gap と呼ばれる部分(MBR パーティションテーブルにしか存在しません)。 パーティション、あるいはパーティションレスディスクの ボリュームブートレコード (VBR)。 GPT でパーティショニングされたディスク上の GRUB の場合、GRUB 固有の BIOS ブートパーティション (GPT には存在しない MBR の後ろの隙間の代わりとして使用されます)。\n1. ブートローダー本体が起動される。\n1. ブートローダーがオペレーティングシステムのカーネルをチェインロード、または直接ロードして、オペレーティングシステムをロードする。\n\n- MBR の次のディスクセクタ。つまり、post-MBR gap と呼ばれる部分(MBR パーティションテーブルにしか存在しません)。\n- パーティション、あるいはパーティションレスディスクの ボリュームブートレコード (VBR)。\n- GPT でパーティショニングされたディスク上の GRUB の場合、GRUB 固有の BIOS ブートパーティション (GPT には存在しない MBR の後ろの隙間の代わりとして使用されます)。\n\n"
    },
    {
      "title": "UEFI",
      "level": 3,
      "content": "1. システムのスイッチが入り、power-on self-test (POST) が実行される。\n1. POST 後に、UEFI は起動に必要なハードウェア(ディスク、キーボード、コントローラなど)を初期化する。\n1. ファームウェアは NVRAM 内のブートエントリを読み込み、どの EFI アプリケーションを起動するかや、どこから(例えば、どのディスクやパーティションから)起動するかを判断する。 ブートエントリは単にディスクであることもあります。この場合、ファームウェアは EFI システムパーティションをそのディスク上から探し、フォールバックブートパス \\EFI\\BOOT\\BOOTx64.EFI(IA32 (32-bit) UEFI のシステムでは BOOTIA32.EFI)から EFI アプリケーションを見つけようとします。これは UEFI の起動可能リムーバブルメディアの動作です。\n1. ファームウェアが EFI アプリケーションを起動する。 そのアプリケーションはブートローダや、EFI ブートスタブを使用する Arch カーネル自体であることもあります。 そのアプリケーションは他の EFI アプリケーション(UEFI シェル や、systemd-boot や rEFInd などの ブートマネージャ)であることもあります。\n\n- ブートエントリは単にディスクであることもあります。この場合、ファームウェアは EFI システムパーティションをそのディスク上から探し、フォールバックブートパス \\EFI\\BOOT\\BOOTx64.EFI(IA32 (32-bit) UEFI のシステムでは BOOTIA32.EFI)から EFI アプリケーションを見つけようとします。これは UEFI の起動可能リムーバブルメディアの動作です。\n\n- そのアプリケーションはブートローダや、EFI ブートスタブを使用する Arch カーネル自体であることもあります。\n- そのアプリケーションは他の EFI アプリケーション(UEFI シェル や、systemd-boot や rEFInd などの ブートマネージャ)であることもあります。\n\nセキュアブート が有効化されている場合、ブートプロセスでは EFI バイナリの正統性を署名によって検証します。\n\n"
    },
    {
      "title": "UEFI でのマルチブート",
      "level": 4,
      "content": "それぞれの OS やベンダーは互いに影響を与えずに EFI システムパーティション 内に固有のファイルを保持することができるので、UEFI を用いたマルチブートは単に、特定のオペレーティングシステムのブートローダに対応する異なる EFI アプリケーションを起動する問題になります。ゆえに、他の OS をロードするためにブートローダのチェインロードメカニズムに頼る必要がありません。\n\nWindows と Arch のデュアルブート も参照してください。\n\n"
    },
    {
      "title": "ブートローダー",
      "level": 2,
      "content": "ブートローダーは、ファームウェア(BIOS または UEFI)によって起動されるソフトウェアの一部です。ブートローダーは、必要なカーネルパラメータと任意の外部の初期 RAM ディスクイメージと共にカーネルをロードします。UEFI の場合、EFI ブートスタブを使用して、UEFI からカーネル自体を直接起動できます。ブート前にカーネルパラメータを編集するために、別のブートローダやブートマネージャを使うこともできます。\n\nしかし、そのようなスタックされたブロックデバイスをサポートするブートローダーは稀ですし、ブートローダーによってまだサポートされていない機能がファイルシステムに追加されることもある (例: archlinux/packaging/packages/grub#7、FS#79857、FS#59047、FS#58137、FS#51879、FS#46856、FS#38750、FS#21733、fscrypt によって暗号化されたディレクトリ) ので、広くサポートされているファイルシステム (FAT32 など) でフォーマットされた個別の /boot パーティションを使うほうがほとんどの場合、現実的です。\n\n"
    },
    {
      "title": "機能比較",
      "level": 3,
      "content": "- GPT は UEFI 仕様の一部であるため、すべての UEFI ブートローダーは GPT ディスクをサポートします。BIOS システム上の GPT は、Hybrid MBR で \"hybrid booting\" を使うか、新しい GPT-only プロトコルを使うことで可能です。ただしこのプロトコルは特定の BIOS 実装で問題を引き起こす可能性があります。詳細については、rodsbooks を参照してください。\n- セキュアブートは UEFI 規格の一部なので、全ての UEFI ブートローダーはそれをサポートしています。ただし、いくつかの制限があります。\n\nTable content:\n名前 | ファームウェア | パーティションテーブル | マルチブート | ファイルシステム | 備考\nBIOS | UEFI | MBR | GPT\nEFI ブートスタブ | – | Yes1 | Yes | Yes | – | ファームウェアから継承2 | カーネルイメージは、UEFI または他の UEFI ブートローダーから直接起動することのできる 有効な EFI 実行ファイルです。\nUnified カーネルイメージ | – | Yes3 | Yes | Yes | – | ファームウェアから継承2 | systemd-stub(7) やカーネル、initramfs、カーネルコマンドラインを EFI 実行ファイルにパックしたものです。UEFI ファームウェアや他のブートローダから直接読み込めます。\nGRUB | Yes | Yes3 | Yes | Yes | Yes | 内蔵 | RAID、LUKS (ただし Argon2 PBKDF 以外)、LVM をサポートします (シンプロビジョニングボリュームはサポートしません)。環境固有の制限については GRUB を見てください。\nLimine | Yes | Yes | Yes | Yes | Yes | 制限有り | \nrEFInd | No | Yes | Yes | Yes | Yes4 | 拡張可能2,5 | 明示的な構成なしでカーネルとパラメーターの自動検出をサポートします。そして、fastboot をサポートします[2]。\nSyslinux | Yes | 部分的1 | Yes | Yes | 部分的 | 制限有り | ファイルシステムの特定の機能はサポートされていません。Syslinux がインストールされているファイルシステムにしかアクセスできません。\nsystemd-boot | No | Yes3 | 手動 | Yes | Yes4 | 拡張可能2,5 | systemd-boot がインストールされている ESP、または、同じディスク上の Extended Boot Loader Partition (XBOOTLDR パーティション) 内のバイナリしか起動できません。esp/EFI/Linux/ 内の unified カーネルイメージ を自動的に検出します。\nGRUB Legacy | Yes | No | Yes | No | Yes | 制限有り | 開発停止。GRUB に移行。\nLILO | Yes | No | Yes | 部分的 | Yes | 制限有り | (Btrfs、GPT、RAID、暗号化などの) 制限により開発停止。\n\n1. バイナリはセキュアブートのために署名することはできますが、検証はされません。なので、信用の鎖はここで切れてしまいます。\n1. ファイルシステムのサポートはファームウェアから継承されます。UEFI 仕様では、FAT12、FAT16、および FAT32 ファイルシステムのサポートが義務付けられていますが [3]、ベンダーはオプションで追加のファイルシステムのサポートを追加できます。たとえば、Apple Mac のファームウェアは HFS+ ファイルシステムをサポートしています。 ファームウェアが起動時に UEFIドライバー をロードするためのインターフェースを提供する場合、ファイルシステムドライバーを(個別に取得して)ロードすることにより、追加のファイルシステムのサポートを追加できます。\n1. Mixed mode ブートをサポートしています。つまり、32 ビット IA32 UEFI 上で 64 ビット x86_64 Linux カーネルをブートできます。\n1. ブートマネージャー。他の EFI アプリケーション、たとえば CONFIG_EFI_STUB = y フラグありでビルドされた Linux カーネルイメージおよび Windows Boot Manager (bootmgfw.efi) のみを起動できます。\n1. UEFI ファイルシステムドライバの読み込みをサポートしています。\n\nWikipedia:Comparison of boot loaders も参照してください。\n\n"
    },
    {
      "title": "カーネル",
      "level": 2,
      "content": "ブートローダー は、カーネルを含んでいる vmlinux イメージを起動します。\n\nカーネルは、マシンのハードウェアとプログラムとの間を仲介する低いレベル(カーネル空間)で機能します。カーネルは、ユーザスペースに移行する前にまずハードウェアの列挙と初期化を行います。より詳細な説明は Wikipedia:ja:カーネル と Wikipedia:ja:Linuxカーネル を見てください。\n\n"
    },
    {
      "title": "initramfs",
      "level": 2,
      "content": "/ のルートファイルシステムは空の rootfs として始まります。これは ramfs や tmpfs の特殊なインスタンスです。これは一時的なルートファイルシステムで、initramfs (initial RAM file system) イメージがここへ解凍されます。\n\nInitramfs の主な目的は root ファイルシステムにアクセスできる位置にシステムをブートストラップすることです (詳しくは FHS を見て下さい)。これには、dm-crypt、dm-verity、systemd-repart(8) などを通してルートファイルシステムが存在しているであろうストレージスタックのセットアップなどが含まれます。また、udev を介して永続的なブロックデバイスの命名を実際のデバイスに解決することも行われます。これは NVMe、SATA、SAS、eMMC、USB (外部ハードウェアから起動する場合) などのデバイスのために必要なモジュールがカーネルに入っていない場合 initramfs からモジュールをロードできなくてはならないということを意味しています; (プログラムやスクリプトから明示的に指定されるか udev を通すかして) 正しいモジュールがロードされると、ブートプロセスが再開されます。従って、initramfs に含めなくてはならないのは root ファイルシステムにアクセスするために必要なモジュールだけで、使用する全てのモジュールを入れる必要はありません。ほとんどのモジュールは後の init プロセス中に、ルート (/) を実際のルートファイルシステムに切り替えた後で udev によってロードされます。\n\nまず、カーネルは組み込みの initramfs を一時的なルートファイルシステムに解凍します。Arch Linux の公式カーネルでは組み込みの initramfs として空のアーカイブが用いられます(Linux のビルドの際のデフォルトです)。そして、カーネルは、ブートローダーから渡されたコマンドラインにより指定された外部の initramfs ファイルを解凍します。この際、組み込みの initramfs にあったファイルは上書きされます。このような外部の initramfs イメージは mkinitcpio や dracut、booster によって生成でき、Arch の初期ユーザ空間のセットアップの方法として推奨されています。\n\nInitramfs には、ルートファイルシステムをセットアップする以外の役割もあります。ルートファイルシステムがマウントされる前にしか行うことができないタスク (fsck やハイバネートからの復帰など) が存在するのです。\n\nまた、Linux カーネルは、カーネルが開始された最初のルートファイルシステムを留めておきます。Initramfs が使用されなかった場合、シャットダウン時に実際のルートファイルシステムが正しくアンマウントされない可能性があります。\n\n"
    },
    {
      "title": "initramfs無しで起動",
      "level": 3,
      "content": "6.13.8から公式にサポートされたカーネルのBtrfsとExt4のドライバはbuilt-inです。 [4].\n\nこれは、カーネルがそれらのファイルシステムのrootパーティションを、他のモジュールなしに直接使用できる事を意味しています。 それでも、いくつか癖があります:\n\n- Systemd#GPT パーティションの自動マウントは使えず、root カーネルパラメータが必要です。\n- rootの続的なブロックデバイスの命名はPARTUUIDとPARTLABELだけ使えます [5].\n- マウントオプションのrootflagsには制限があります,例えばnoatimeは動きません。 [6]. 後でfstab等で再マントしてください。\n- systemd-gpt-auto-generator(8)はBtrfsを使っているとinitramfs無しでは使えません。 [7] systemd.gpt_auto=noで無効化してください。\n\n現時点でSCSI/SATA/AHCIドライバがbuilt-inです。他のストレージデバイス(NVMe,USB,Device mapper等)は動きません。LVMや暗号化も使えません。\n\nマイクロコード#早期ロードもinitramfsが必要ですが、イメージ全体をビルドする必要はなく、マイクロコード#別個のマイクロコード initramfs ファイルを使うを使えます.\n\nIf no initramfs image is provided, the kernel always contains still an empty image to start from [8]. So there should be no issues with root partition pinning.\n\n"
    },
    {
      "title": "初期ユーザ空間",
      "level": 2,
      "content": "初期ユーザ空間の段階は一時的なルートファイルシステムがマウントされている状態で行われ、initramfs により提供されたファイルで動作します。\n\n初期ユーザ空間の機能は設定可能ですが、一般的に以下のようなことを行います:\n\n- systemd-modules-load(8) がカーネルモジュールを読み込みます。例えば、本物のルートファイルシステムをマウントするために必要なブロックデバイスモジュールなどです。\n- 必要ならば、本物のルートファイルシステムの復号処理を行います。\n- DRM モジュールをロードします。KMS の早期開始は、ツリー内のモジュールに対してはデフォルトで有効化されています。\n\n初期ユーザー空間の最終段階として、本物のルートファイルシステムが /sysroot/ (systemd ベースの initramfs の場合) または /new_root/ (busybox ベースの場合) にマウントされ、それに切り替わります。本物のルートファイルシステムから init プログラムを実行することにより、後期ユーザ空間が始まります。\n\n"
    },
    {
      "title": "後期ユーザ空間",
      "level": 2,
      "content": "init プロセスにより後期ユーザ空間のスタートアップが実行されます。Arch では公式には、ユニットとサービスの概念の上に構築された systemd が用いられます。しかし、ここで言及している機能は他の init システムと重なります。\n\n"
    },
    {
      "title": "getty",
      "level": 3,
      "content": "init プロセスは 仮想コンソール(典型的には6つ)ごとに getty を1回呼び出します。getty はそれぞれのターミナルを初期化して、認証されていないユーザからターミナルを保護します。ユーザ名とパスワードが与えられると、getty はそれらを /etc/passwd と /etc/shadow と照合し、login(1) を呼び出します。\n\n"
    },
    {
      "title": "ログイン",
      "level": 4,
      "content": "ログイン プログラムは、環境変数を設定し、/etc/passwd に基づいてユーザーのシェルを起動することによって、ユーザーのセッションを開始します。ログイン プログラムは、ログインに成功するとログインシェルを実行する直前に /etc/motd (message of the day) の内容を表示します。利用規約を表示してユーザーに地域のポリシーや伝えたいことを思い出させるのに適した場所です。\n\n"
    },
    {
      "title": "シェル",
      "level": 4,
      "content": "ユーザーのシェルが起動されると、通常はユーザーにプロンプトを表示する前に bashrc などの実行時設定ファイルが実行されます。アカウントがログイン時に X を起動するように設定されている場合、実行時設定ファイルは startx または xinit を呼び出します。最後については #グラフィカルセッション (Xorg) を見てください。\n\n"
    },
    {
      "title": "ディスプレイマネージャ",
      "level": 3,
      "content": "さらに、init は、指定した仮想コンソールで getty の代わりにディスプレイマネージャを起動するように設定できます。そうするには、該当する systemd service ファイルを手動で有効化する必要があります。そうしたら、ディスプレイマネージャーがグラフィカルセッションを起動します。\n\n"
    },
    {
      "title": "グラフィカルセッション (Xorg)",
      "level": 4,
      "content": "xinit はユーザの xinitrc ランタイム設定ファイルを実行し、通常、ウィンドウマネージャやデスクトップ環境を開始します。ユーザが終了すると、xinit、 startx、 シェル、 ログインの順序で終了して getty、またはディスプレイマネージャに戻ります。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Wikipedia:Booting process of Linux\n- Inside the Linux boot process\n- Rod Smith - Managing EFI Boot Loaders for Linux\n- NeoSmart: The BIOS/MBR Boot Process\n- Lennart Poettering - Linux Boot Partitions and How to Set Them Up\n- Wikipedia:initrd\n- Early Userspace in Arch Linux\n- Kernel Newbie Corner: initrd and initramfs\n- bootup(7) (Systemd initrd とユーザー空間に関する部分についてがほとんど)\n\n"
    }
  ]
}