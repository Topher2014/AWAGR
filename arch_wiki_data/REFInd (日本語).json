{
  "title": "REFInd (日本語)",
  "url": "https://wiki.archlinux.org/title/REFInd_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Arch ブートプロセス\n- ブートローダー\n- Unified Extensible Firmware Interface\n- EFISTUB\n- booster\n\nrEFInd は UEFI ブートマネージャーです。EFISTUB カーネルを起動することができます。既にメンテナンスされてない rEFIt のフォークであり、Mac 以外の UEFI ブートに関して多数の問題が修正されています。プラットフォームに依存せず、複数の OS を簡単に起動できるように設計されています。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 サポートされているファイルシステム\n- 2 インストール\n- 3 rEFInd ブートマネージャをインストールする 3.1 refind-install スクリプトによるインストール 3.1.1 Secure Boot 3.1.1.1 PreLoader を使う 3.1.1.2 shim を使う 3.1.1.2.1 ハッシュを使う 3.1.1.2.2 Machine Owner Key を使う 3.1.1.3 自分の鍵を使う 3.2 手動インストール 3.3 アップグレード 3.3.1 Pacman フック\n- 4 設定 4.1 カーネルパラメータを渡す 4.1.1 rEFInd によって自動的に検出されたカーネルの場合 4.1.1.1 refind_linux.conf 4.1.1.2 設定しない 4.1.2 手動でブートエントリを記述する\n- 5 既存の UEFI Windows 環境で rEFInd を使う\n- 6 ツール 6.1 UEFI シェル 6.2 Memtest86+ 6.3 鍵管理ツール 6.3.1 HashTool 6.3.2 MokManager 6.3.3 KeyTool 6.4 GPT fdisk (gdisk) 6.5 fwupd 6.6 電源オフや再起動\n- 7 ヒントとテクニック 7.1 UEFI シェルでドライバを使用する 7.2 efifb の解像度を設定する 7.3 Btrfs サブボリュームのサポート 7.3.1 自動検出 7.3.2 マニュアルブートの設定 7.4 LoaderDevicePartUUID\n- 8 トラブルシューティング 8.1 Apple Mac 8.2 空の rEFInd メニュースクリーン 8.3 ディストリビューションのロゴを表示してくれない\n- 9 参照\n\n- 3.1 refind-install スクリプトによるインストール 3.1.1 Secure Boot 3.1.1.1 PreLoader を使う 3.1.1.2 shim を使う 3.1.1.2.1 ハッシュを使う 3.1.1.2.2 Machine Owner Key を使う 3.1.1.3 自分の鍵を使う\n- 3.2 手動インストール\n- 3.3 アップグレード 3.3.1 Pacman フック\n\n- 3.1.1 Secure Boot 3.1.1.1 PreLoader を使う 3.1.1.2 shim を使う 3.1.1.2.1 ハッシュを使う 3.1.1.2.2 Machine Owner Key を使う 3.1.1.3 自分の鍵を使う\n\n- 3.1.1.1 PreLoader を使う\n- 3.1.1.2 shim を使う 3.1.1.2.1 ハッシュを使う 3.1.1.2.2 Machine Owner Key を使う\n- 3.1.1.3 自分の鍵を使う\n\n- 3.1.1.2.1 ハッシュを使う\n- 3.1.1.2.2 Machine Owner Key を使う\n\n- 3.3.1 Pacman フック\n\n- 4.1 カーネルパラメータを渡す 4.1.1 rEFInd によって自動的に検出されたカーネルの場合 4.1.1.1 refind_linux.conf 4.1.1.2 設定しない 4.1.2 手動でブートエントリを記述する\n\n- 4.1.1 rEFInd によって自動的に検出されたカーネルの場合 4.1.1.1 refind_linux.conf 4.1.1.2 設定しない\n- 4.1.2 手動でブートエントリを記述する\n\n- 4.1.1.1 refind_linux.conf\n- 4.1.1.2 設定しない\n\n- 6.1 UEFI シェル\n- 6.2 Memtest86+\n- 6.3 鍵管理ツール 6.3.1 HashTool 6.3.2 MokManager 6.3.3 KeyTool\n- 6.4 GPT fdisk (gdisk)\n- 6.5 fwupd\n- 6.6 電源オフや再起動\n\n- 6.3.1 HashTool\n- 6.3.2 MokManager\n- 6.3.3 KeyTool\n\n- 7.1 UEFI シェルでドライバを使用する\n- 7.2 efifb の解像度を設定する\n- 7.3 Btrfs サブボリュームのサポート 7.3.1 自動検出 7.3.2 マニュアルブートの設定\n- 7.4 LoaderDevicePartUUID\n\n- 7.3.1 自動検出\n- 7.3.2 マニュアルブートの設定\n\n- 8.1 Apple Mac\n- 8.2 空の rEFInd メニュースクリーン\n- 8.3 ディストリビューションのロゴを表示してくれない\n\n"
    },
    {
      "title": "サポートされているファイルシステム",
      "level": 2,
      "content": "rEFInd は、ファイルシステムのサポートをファームウェアから継承します (つまり、少なくとも FAT12、FAT16、FAT32 はサポートされることを意味します)。加えて、rEFInd は、ESP 上の自身のインストールディレクトリ内のサブディレクトリ drivers と drivers_x64 (例: esp/EFI/refind/drivers_x64/) 内にある UEFI ドライバもロードします。\n\nまた、rEFInd には少数の読み取り専用 EFI ファイルシステムドライバ (特に ext4 と Btrfs) も同梱されています。\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "refind パッケージをインストールしてください。\n\n"
    },
    {
      "title": "rEFInd ブートマネージャをインストールする",
      "level": 2,
      "content": "rEFInd には、ReiserFS (非推奨)、Ext2、Ext4、Btrfs、ISO-9660、HFS+ の 読み取り専用 サポートを実装する UEFI ドライバが同梱されています。さらに、rEFInd は、UEFI 自体によってアクセス可能な任意のファイルシステムにアクセスできます。これには、FAT (UEFI 仕様によって義務付けられています)、Mac の HFS+、一部のシステムでは ISO-9660 が含まれています。\n\n他のドライバーについては The rEFInd Boot Manager: Using EFI Drivers: Finding Additional EFI Drivers を参照してください。\n\nrEFInd を使うには、refind-install スクリプト を使うか、rEFInd のファイルをコピーし、ブートエントリを手動でセットアップして、rEFInd を EFI システムパーティションにインストールしなければなりません。\n\n"
    },
    {
      "title": "refind-install スクリプトによるインストール",
      "level": 3,
      "content": "rEFInd パッケージには refind-install というスクリプトが含まれており、簡単に rEFInd をデフォルトの EFI ブートエントリに設定できます。このスクリプトにはオプションが存在し、様々なセットアップや UEFI 実装に対応しています。様々なインストールオプションの説明は、refind-install(8) やインストールスクリプトのコメントを見てください。\n\n多くのシステムでは以下を実行するだけで十分なはずです:\n\n```\n# refind-install\n```\n\nこのコマンドは、ESP を検出しマウントしようと試み、rEFInd のファイルを esp/EFI/refind/ にコピーし、efibootmgr を使って rEFInd をデフォルトの EFI ブートアプリケーションにします。\n\nまたは、デフォルト/フォールバックのブートパスである esp/EFI/BOOT/bootx64.efi に rEFInd をインストールすることもできます。ブータブルな USB フラッシュドライブや、efibootmgr による NVRAM の変更に問題を抱えているシステム等で有用です:\n\n```\n# refind-install --usedefault /dev/sdXY\n```\n\n/dev/sdXY は EFI システムパーティションです (マウントポイントではなく、ブロックデバイスを指定してください)。\n\nrEFInd のファイルを ESP にインストールしたら、rEFInd が作成した refind_linux.conf (カーネルと同じディレクトリにあります) に必要なカーネルパラメータが含まれていることを確認してください。--usedefault オプションを使用した場合はこの設定ファイルは作成されません。root として mkrlconf を実行して作成してください。\n\nデフォルトでは、rEFInd は (rEFInd にそのドライブ用のドライバが存在する) すべてのドライブをスキャンし、発見した EFI ブートローダーのブートエントリを追加します。これにはカーネルも含まれているはずです (Arch Linux はデフォルトで EFISTUB が有効化されているからです)。なので、この時点でブータブルなシステムが出来上がっているでしょう。\n\n"
    },
    {
      "title": "Secure Boot",
      "level": 4,
      "content": "rEFInd におけるセキュアブートのサポートについては Managing Secure Boot を参照してください。\n\nセキュアブート#PreLoader をセットアップする を参照して署名済みの PreLoader.efi と HashTool.efi バイナリを用意してください。\n\n--preloader /path/to/preloader オプションを付けて refind-install を実行します:\n\n```\n# refind-install --preloader /usr/share/preloader-signed/PreLoader.efi\n```\n\nセキュアブートを有効にして起動すると、HashTool が起動するので rEFInd のハッシュ (loader.efi) と rEFInd のドライバー (例: ext4_x64.efi) そしてカーネル (例: vmlinuz-linux) を登録してください。\n\n詳しくは refind-install(8) を見てください。\n\nshim-signedAUR をインストールしてください。セキュアブート#shim を読んでください。ただし、ファイルをコピーする部分はすべてスキップしてください。\n\nshim でハッシュだけを使うには、refind-install を --shim /path/to/shim オプションで実行してください:\n\n```\n# refind-install --shim /usr/share/shim-signed/shimx64.efi\n```\n\n次回セキュアブートを有効化した状態で起動すると、MokManager が起動します。その時、rEFInd (grubx64.efi)、rEFInd のドライバ (例: ext4_x64.efi)、カーネル (例: vmlinuz-linux) のハッシュを登録する必要があります。\n\nrEFInd を Machine Owner Key (MOK) で署名するには、sbsigntools をインストールしてください。\n\n--shim /path/to/shim と --localkeys オプションを付けて refind-install を実行します:\n\n```\n# refind-install --shim /usr/share/shim-signed/shimx64.efi --localkeys\n```\n\nrefind-install は鍵を作成して自分自身とドライバーに署名します。同じ鍵を使ってカーネルに署名する必要があります。例:\n\n```\n# sbsign --key /etc/refind.d/keys/refind_local.key --cert /etc/refind.d/keys/refind_local.crt --output /boot/vmlinuz-linux /boot/vmlinuz-linux\n```\n\nMokManager で refind_local.cer を MoKList に追加してください。refind_local.cer は rEFInd のインストールディレクトリ (例えば esp/EFI/refind/keys/refind_local.cer) の keys という名前のディレクトリに存在します。\n\n詳しくは refind-install(8) を参照してください。\n\nセキュアブート#自分の鍵を使う に従って鍵を作成してください。\n\n/etc/refind.d/keys ディレクトリを作成して署名データベース (db) 鍵と証明書を保存します。ファイルの名前は次のとおりにしてください: refind_local.key (PEM 形式秘密鍵)、refind_local.crt (PEM 形式証明書)、refind_local.cer (DER 形式証明書)。\n\nインストールスクリプトの実行時に --localkeys オプションを付け加えます。例:\n\n```\n# refind-install --localkeys\n```\n\nこれで rEFInd の EFI バイナリが自分の鍵と証明書で署名されます。\n\n"
    },
    {
      "title": "手動インストール",
      "level": 3,
      "content": "refind-install スクリプトが上手く動かない場合、rEFInd を手動でセットアップすることができます。\n\nまず実行可能ファイルを ESP にコピーしてください:\n\n```\n# mkdir -p esp/EFI/refind\n# cp /usr/share/refind/refind_x64.efi esp/EFI/refind/\n```\n\nrEFInd をデフォルト/フォールバックブートパスにインストールしたい場合は、以下の指示で esp/EFI/refind/ を esp/EFI/BOOT/ に置き換え、rEFInd の EFI 実行ファイルを esp/EFI/BOOT/bootx64.efi にコピーしてください:\n\n```\n# mkdir -p esp/EFI/BOOT\n# cp /usr/share/refind/refind_x64.efi esp/EFI/BOOT/bootx64.efi\n```\n\nそれから efibootmgr を使って UEFI の NVRAM にブートエントリを作成してください (/dev/sdX と Y はあなたの ESP のマウントポイントに合わせて置き換えて下さい)。rEFInd をデフォルト/フォールバックのブートパス esp/EFI/BOOT/bootx64.efi にインストールした場合は、このステップは省略してもかまいません。\n\n```\n# efibootmgr --create --disk /dev/sdX --part Y --loader /EFI/refind/refind_x64.efi --label \"rEFInd Boot Manager\" --unicode\n```\n\nこの時点で rEFInd で起動することができるようになっているはずです。ただしカーネルを起動することはできません。カーネルが ESP にない場合、(適切なドライバーが存在するとき) rEFInd はパーティションをマウントしてカーネルを検索することができます。\n\nrEFInd はインストールディレクトリに存在する drivers と drivers_arch (例: drivers_x64) サブディレクトリから全てのドライバーを自動的にロードします。\n\n```\n# mkdir esp/EFI/refind/drivers_x64\n# cp /usr/share/refind/drivers_x64/drivername_x64.efi esp/EFI/refind/drivers_x64/\n```\n\nこれで rEFInd はカーネルのブートエントリが用意できているはずですが、適切なカーネルパラメータが渡されていません。#カーネルパラメータを渡す を行って下さい。それによって rEFInd を使ってカーネルを起動することができるようになります。この段階で起動ができない、または rEFInd の設定を変更したい場合、設定ファイルを使ってオプションを変更することができます:\n\n```\n# cp /usr/share/refind/refind.conf-sample esp/EFI/refind/refind.conf\n```\n\nサンプル設定ファイルにたくさんコメントが付いているので開いてみて下さい。\n\n設定ファイルに textonly を設定していない場合、rEFInd のアイコンをコピーしないとプレースホルダが表示されます:\n\n```\n# cp -r /usr/share/refind/icons esp/EFI/refind/\n```\n\nフォントをコピーして refind.conf の font 設定を変更することで他のフォントを使うこともできます:\n\n```\n# cp -r /usr/share/refind/fonts esp/EFI/refind/\n```\n\n"
    },
    {
      "title": "アップグレード",
      "level": 3,
      "content": "Pacman は /usr/share/refind/ にある rEFInd のファイルをアップデートしますが、ESP に新しいファイルをコピーしたりはしません。refind-install で rEFInd のインストールが上手くいっているのであれば、再度実行することでアップデートされたファイルをコピーできます。新しい設定ファイルは refind.conf-sample としてコピーされるので、差分ツールを使って設定ファイルをマージすることができます。rEFInd が#手動インストールを必要とする場合、どのファイルが必要なのかは自分で判断してコピーする必要があります。\n\n"
    },
    {
      "title": "Pacman フック",
      "level": 4,
      "content": "Pacman フックを使うことでアップデートの処理を自動化することができます:\n\n```\n/etc/pacman.d/hooks/refind.hook\n```\n\n```\n[Trigger]\nOperation=Upgrade\nType=Package\nTarget=refind\n\n[Action]\nDescription = Updating rEFInd on ESP\nWhen=PostTransaction\nExec=/usr/bin/refind-install\n```\n\nExec= の部分は、あなたの環境で正しく動作するアップデートコマンドに変更する必要があるかもしれません。#手動インストールを行った場合は、フックから呼び出す独自のアップデートスクリプトを作成することで、アップデートを自動化できます。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "rEFInd の設定ファイル refind.conf は rEFInd の EFI アプリケーションと同じディレクトリに存在します (大抵は esp/EFI/refind あるいは esp/EFI/BOOT)。デフォルト設定ファイルにはオプションの詳細な説明が含まれており、さらに詳しい説明は Configuring the Boot Manager に載っています。\n\n"
    },
    {
      "title": "カーネルパラメータを渡す",
      "level": 3,
      "content": "rEFInd によってカーネルに渡されるカーネルパラメータを設定する方法は2つあります。\n\n"
    },
    {
      "title": "rEFInd によって自動的に検出されたカーネルの場合",
      "level": 4,
      "content": "自動的に検出されたカーネルの場合、/boot/refind_linux.conf に明示的にカーネルパラメータを指定したり、あるいはルータパーティションとカーネルパラメータを特定する rEFInd の機能に頼ったりできます。詳細は Methods of Booting Linux: For Those With Foresight or Luck: The Easiest Method を見てください。\n\n- /etc/os-release がカーネルと同じパーティションに存在する場合、rEFInd は自動的にブートエントリのアイコンとして Arch Linux のアイコン (os_arch.png) を選択します。/boot が別のパーティションにある場合は、Configuring the Boot Manager: Setting OS Icons を見てください。\n- rEFInd は ユニファイドカーネルイメージのディストリビューションの検出をサポートしていません。ユニファイドカーネルイメージのアイコンを表示するには、/usr/share/refind/icons/os_arch.png を esp/EFI/Linux/ にコピーし、ファイル名が一致していることを確認してください。例えば、esp/EFI/Linux/arch-linux.efi が存在する場合、アイコンの名前を esp/EFI/Linux/arch-linux.png としてください。\n\nrEFInd で Arch Linux カーネルの命名規則をサポートし、カーネルとそれぞれの initramfs イメージがマッチするようにするには、refind.conf 内の extra_kernel_version_strings をアンコメントし編集する必要があります。例えば:\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nextra_kernel_version_strings linux-hardened,linux-rt-lts,linux-zen,linux-lts,linux-rt,linux\n...\n```\n\n- rEFInd はカーネルごとに1つの initramfs しか検出しません。つまり、フォールバック initramfs やマイクロコードのイメージは検出されないことになります。それらは手動で指定しなければなりません。\n- 上記の extra_kernel_version_strings 行が無いと、refind_linux.conf 内の %v 変数は Arch Linux カーネルにおいて機能しません。\n\nrEFInd が自動的にカーネルを検出する場合、カーネルパラメータの含まれている refind_linux.conf ファイルはそのカーネルと同じディレクトリに置くことができます。/usr/share/refind/refind_linux.conf-sample を設定ファイルのベースにすることができます。refind_linux.conf の1つ目のアンコメントされている行がカーネルのデフォルトパラメータとなります。それ以降の行は +、F2、Insert を使ってアクセスできるサブメニュー内にエントリを作成します。\n\nあるいは、mkrlconf を root として実行してみてください。このスクリプトは、/boot 内からカーネルを探し、自動的に refind_linux.conf を生成しようと試みます。このスクリプトは、最も基本的なカーネルパラメータしか設定しませんので、作成されたファイルが正しいかを確認してください。\n\ninitrd= パラメータを指定しない場合、カーネルと同じディレクトリから一般的な RAM ディスクのファイル名を探索して自動的にそのパラメータを追加します。複数の initrd= パラメータが必要な場合、手動でそれらを refind_linux.conf で指定しなければなりません。例えば、initramfs の前にマイクロコードを渡す場合:\n\n```\n/boot/refind_linux.conf\n```\n\n```\n\"Boot using default options\"     \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\intel-ucode.img initrd=boot\\amd-ucode.img initrd=boot\\initramfs-%v.img\"\n\"Boot using fallback initramfs\"  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\intel-ucode.img initrd=boot\\amd-ucode.img initrd=boot\\initramfs-%v-fallback.img\"\n\"Boot to terminal\"               \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\intel-ucode.img initrd=boot\\amd-ucode.img initrd=boot\\initramfs-%v.img systemd.unit=multi-user.target\"\n```\n\n- initrd のパスは、カーネルの存在するファイルシステムのルートディレクトリからの相対パスです。これは initrd=\\boot\\initramfs-%v.img だったり、(/boot が ESP などの別のパーティションに存在する場合) initrd=initramfs-%v.img だったりします。\n- initrd パラメータではパスのセパレータとしてバックスラッシュ (\\) を使用してください。さもないと、カーネルは initramfs イメージを見つけることができないかもしれません: EFI stub: ERROR: Failed to open file: /boot/intel-ucode.img。\n- Booster によって生成された initramfs イメージを使用する場合は、initramfs ファイルの名前の initramfs を booster に置き換えてください。例: initrd=\\boot\\booster-%v.img。\n\n- 引用符は、繰り返すことによりエスケープできます (つまり、\"\" は \" のエスケープ版です)。例えば、上記の refind_linux.conf の最初のブートエントリにオプション \"acpi_osi=Windows 2015\" を渡すには: \"Boot using default options\" \"... initrd=boot\\initramfs-%v.img acpi_osi=\"\"Windows 2015\"\" \"\n- rEFInd は、(カーネルのファイル名から抽出することにより) refind_linux.conf 内の %v をカーネルのバージョンに置き換えます。rEFInd で Arch Linux カーネルをサポートするには、esp/EFI/refind/refind.conf 内の extra_kernel_version_strings を #rEFInd によって自動的に検出されたカーネルの場合 で説明されているように編集しなければなりません。\n\n```\n\"Boot using default options\"     \"... initrd=boot\\initramfs-%v.img acpi_osi=\"\"Windows 2015\"\" \"\n```\n\nrEFInd を ESP 上にインストールしただけで、それ以上の操作をせずに (例えば、UEFI シェルや KeyTool、ファームウェアから直接) rEFInd を起動すると、(なんの設定もせずに) 自動検出によって作成されたブートメニュが表示されます。\n\nこれがうまく行くのは、rEFInd にフォールバック機構があるからです。この機能は以下のようなことができます:\n\n- Discoverable Partitions Specification や /etc/fstab を使って (root= パラメータ用に) ルートパーティションを特定する。\n- GPT パーティション属性 (属性 60 \"read-only\" を使用) や /etc/fstab を使ってカーネルオプション (ro や rw) を検出する。\n\n"
    },
    {
      "title": "手動でブートエントリを記述する",
      "level": 4,
      "content": "カーネルが自動検出されない場合、もしくはメニューエントリのオプションを自分で設定したい場合、手動で refind.conf にブートエントリを作成することができます。scanfor には manual を含めて下さい、そうしないとエントリが rEFInd のメニューに表示されません。カーネルパラメータは options キーワードで設定できます。rEFInd は initrd キーワードで指定されたファイルを使って initrd= パラメータを追加します。initrd を追加する必要がある場合 (例: マイクロコード)、options で指定してください (initrd キーワードで指定された initrd が最後に追加されます)。\n\n手動でのブートエントリの記述については Creating Manual Boot Stanzas で説明されています。\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\n\nmenuentry \"Arch Linux\" {\n\ticon     /EFI/refind/icons/os_arch.png\n\tvolume   \"Arch Linux\"\n\tloader   /boot/vmlinuz-linux\n\tinitrd   /boot/initramfs-linux.img\n\toptions  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\intel-ucode.img initrd=boot\\amd-ucode.img\"\n\tsubmenuentry \"Boot using fallback initramfs\" {\n\t\tinitrd /boot/initramfs-linux-fallback.img\n\t}\n\tsubmenuentry \"Boot to terminal\" {\n\t\tadd_options \"systemd.unit=multi-user.target\"\n\t}\n}\n```\n\nカーネルの存在するパーティションのファイルシステム LABEL、PARTLABEL、PARTUUID のどれかとマッチするように volume を変更する必要があるでしょう。PARTUUID は大文字である必要があります。ボリュームラベルの割当の例は 永続的なブロックデバイスの命名#by-label を見てください。volume が指定されていない場合、rEFInd が起動したパーティション (典型的には EFI システムパーティション) のボリュームをデフォルトとして使用します。\n\n- loader と initrd のパスは、カーネルの存在するファイルシステムのルートディレクトリからの相対パスです。/boot が ESP などの別のパーティションに存在する場合、loader と initrd のパスはそれぞれ /vmlinuz-linux と /initramfs-linux.img となります。\n- 引用符で囲まれた initrd パラメータすべてで、パスのセパレータとしてバックスラッシュ (\\) を使用してください。さもないと、カーネルは initramfs イメージを見つけることができないかもしれません: EFI stub: ERROR: Failed to open file: /boot/initramfs-linux.img。\n- Booster によって生成された initramfs イメージを使用する場合は、initramfs ファイルの名前の initramfs を booster に置き換えてください。例: initrd /boot/booster-linux.img。\n\n```\noptions  \"... initrd=boot\\amd-ucode.img acpi_osi=\"\"Windows 2015\"\" \"\n```\n\n"
    },
    {
      "title": "既存の UEFI Windows 環境で rEFInd を使う",
      "level": 2,
      "content": "rEFInd は UEFI の Windows をインストールしたときに作成される EFI システムパーティションに対応しているため、Windows と一緒に Arch をインストールする際にもうひとつ FAT32 パーティションを作成・フォーマットする必要はありません。Windows の ESP をマウントして通常通りに rEFInd をインストールするだけです。デフォルトで、rEFInd の自動検出機能が既存の Windows (リカバリ) ブートローダーを認識するはずです。\n\n"
    },
    {
      "title": "ツール",
      "level": 2,
      "content": "rEFInd は、様々なサードパーティーツールの実行をサポートしています。ツールは別途インストールする必要があります。refind.conf 内の showtools を編集して表示したいツールを選択してください。\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nshowtools shell, memtest, mok_tool, gdisk, fwupdate ...\n...\n```\n\n"
    },
    {
      "title": "UEFI シェル",
      "level": 3,
      "content": "Unified Extensible Firmware Interface#UEFI シェル を見てください。\n\nEFI システムパーティションのルートに shellx64.efi をコピーしてください。\n\n"
    },
    {
      "title": "Memtest86+",
      "level": 3,
      "content": "memtest86+-efi をインストールし、それを esp/EFI/tools/ にコピーしてください。\n\n```\n# cp /boot/memtest86+/memtest.efi esp/EFI/tools/memtest86.efi\n```\n\n"
    },
    {
      "title": "鍵管理ツール",
      "level": 3,
      "content": "rEFInd can detect Secure Boot key management tools if they are placed in rEFInd's directory on ESP, esp/ or esp/EFI/tools/.\n\n"
    },
    {
      "title": "HashTool",
      "level": 4,
      "content": "#PreLoader を使う に従ってください。HashTool.efi は rEFInd のディレクトリに配置されます。\n\n"
    },
    {
      "title": "MokManager",
      "level": 4,
      "content": "#shim を使う に従ってください。MokManager は rEFInd のディレクトリに配置されます。\n\n"
    },
    {
      "title": "KeyTool",
      "level": 4,
      "content": "efitools をインストールしてください。\n\nKeyTool EFI バイナリを KeyTool.efi か KeyTool-signed.efi という名前で esp/ か esp/EFI/tools/ に配置してください。\n\nKeyTool.efi を署名する方法については セキュアブート#KeyTool を使う を見てください。\n\n"
    },
    {
      "title": "GPT fdisk (gdisk)",
      "level": 3,
      "content": "gdisk EFI アプリケーションをダウンロードし、gdisk_x64.efi を esp/EFI/tools/ にコピーしてください。\n\n"
    },
    {
      "title": "fwupd",
      "level": 3,
      "content": "fwupd-efi をインストールし、fwupd をセットアップしてください。\n\nfwupdx64.efi バイナリとファームウェアファイルを esp/EFI/tools/ にコピーしてください:\n\n```\n# cp /usr/lib/fwupd/efi/fwupdx64.efi esp/EFI/tools/\n```\n\n"
    },
    {
      "title": "電源オフや再起動",
      "level": 3,
      "content": "rEFInd には電源オフと再起動のメニューエントリが組み込まれていると報告されています。このツールのリストはこの Wiki ではとても広範囲なものなので、UEFI や他の UEFI ブートマネージャ (例えば systemd-boot) のユーザは、powerofforreboot.efiAUR に興味を持つかもしれません。\n\n"
    },
    {
      "title": "UEFI シェルでドライバを使用する",
      "level": 3,
      "content": "rEFInd のドライバを UEFI シェル内で使用するには、load コマンドを使ってロードし、マッピングされたドライバを map -r コマンドを使ってリフレッシュしてください。\n\n```\nShell> load FS0:\\EFI\\refind\\drivers\\ext4_x64.efi\nShell> map -r\n```\n\nこれで、UEFI シェルからファイルシステムにアクセスできるようになりました。\n\n"
    },
    {
      "title": "efifb の解像度を設定する",
      "level": 3,
      "content": "refind.conf で解像度が間違った値に設定されている場合、Apple Mac を除くすべてのシステムで rEFInd は、サポートされている解像度のリストを表示します。Apple Mac の場合は、rEFInd はサイレントにデフォルトの解像度を使用します。\n\nefifb によってサポートされているフレームバッファの解像度を判断するには、/usr/share/gnu-efi/apps/x86_64/modelist.efi を gnu-efi から ESP のルートディレクトリにコピーしてください。UEFI シェル に入り、modelist.efi を実行してください。\n\n```\nShell> FS0:\\modelist.efi\n```\n\n```\nGOP reports MaxMode 3\n 0: 640x480 BGRR pitch 640\n*1: 800x600 BGRR pitch 800\n 2: 1024x768 BGRR pitch 1024\n```\n\nどれかの解像度を refind.conf で設定してください。再起動し、dmesg | grep efifb を root として実行して設定が反映されていることを確認してください。\n\n"
    },
    {
      "title": "自動検出",
      "level": 4,
      "content": "Btrfs ボリューム上でカーネルの自動検出を有効にするには、refind.conf 内の also_scan_dirs をアンコメントしてください。\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nalso_scan_dirs +,subvolume/boot\n...\n```\n\n次に、refind_linux.conf 内の rootflags に subvol=subvolume を追加してください。そして、initrd のパスの先頭に subvolume を追加してください。\n\n```\n/boot/refind_linux.conf\n```\n\n```\n\"Boot using standard options\"  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw rootflags=subvol=subvolume initrd=subvolume\\boot\\initramfs-%v.img\"\n```\n\n"
    },
    {
      "title": "マニュアルブートの設定",
      "level": 4,
      "content": "btrfs サブボリュームをルートとして起動する場合、サブボリュームへのパスをローダーと initrd のパスの先頭に追加し、options の行を rootflags=subvol=root_subvolume のように変更してください。以下の例では、ルートは 'ROOT' という名前で btrfs サブボリュームとしてマウントされています (例: mount -o subvol=ROOT /dev/sdxY /mnt):\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nmenuentry \"Arch Linux\" {\n        icon     /EFI/refind/icons/os_arch.png\n        volume   \"[bootdevice]\"\n        loader   /ROOT/boot/vmlinuz-linux\n        initrd   /ROOT/boot/initramfs-linux.img\n        options  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw rootflags=subvol=ROOT\"\n...\n}\n```\n\nそうしないと、次のようなエラーが発生します: ERROR: Root device mounted successfully, but /sbin/init does not exist.\n\n"
    },
    {
      "title": "LoaderDevicePartUUID",
      "level": 3,
      "content": "バージョン 0.13.1 以降、rEFInd は UEFI 変数 LoaderDevicePartUUID の設定をサポートしています 。これを有効化すると、systemd-gpt-auto-generator(8) が EFI システムパーティションを、/etc/fstab で指定せずに自動マウントできるようになります。systemd#GPT パーティションの自動マウント を見てください。\n\nrEFInd が LoaderDevicePartUUID を設定できるようにするには、refind.conf を編集して write_systemd_vars true をアンコメントしてください:\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nwrite_systemd_vars true\n...\n```\n\ncat /sys/firmware/efi/efivars/LoaderDevicePartUUID-4a67b082-0a4c-41cf-b6c7-440b29bb8c4f で値を確認するか、bootctl の出力の \"Boot loader sets ESP information\" の状態を見ることで、この変数が設定されていることを確認できます。\n\n"
    },
    {
      "title": "Apple Mac",
      "level": 3,
      "content": "mactel-bootAUR は Linux 用の実験的な bless ユーティリティです。これが動作しないときは、OSX の中から bless を使って rEFInd をデフォルトのブートローダに設定してください:\n\n```\n# bless --setBoot --folder esp/EFI/refind --file esp/EFI/refind/refind_x64.efi\n```\n\n"
    },
    {
      "title": "空の rEFInd メニュースクリーン",
      "level": 3,
      "content": "drivers_x64 フォルダにファイルシステムドライバが複数存在すると (#rEFInd ブートマネージャをインストールする を参照)、ファイルシステムドライバのバグによって rEFInd が正しく機能しなくなり、rEFInd のロゴだけの空白画面 (カスタムテーマの場合は、背景画像) が表示されることがあります。これを修正するには、カーネルの存在するファイルシステム用のドライバ以外のすべてのドライバを削除してください。\n\nまた、Windows とデュアルブートしている場合に rEFInd が他のディスク上の EFI システムパーティションの自動スキャンに失敗して、空白画面が発生することもあります。これを修正するには、blkid を使って Windows パーティションを特定し、それぞれの Windows パーティションの PARTUUID を refind.conf 内の dont_scan_volumes 変数にコンマで区切って追加してください。例えば:\n\n```\n# blkid\n```\n\n```\n/dev/nvme0n1p1: LABEL=\"SYSTEM\" UUID=\"4CE7-C215\" BLOCK_SIZE=\"512\" TYPE=\"vfat\" PARTLABEL=\"EFI system partition\" PARTUUID=\"13aa9955-1234-5678-9098-006c334b5088\"\n/dev/nvme0n1p5: LABEL=\"Windows RE Tools\" BLOCK_SIZE=\"512\" UUID=\"08C4E6C5C4E6B45A\" TYPE=\"ntfs\" PARTLABEL=\"Basic data partition\" PARTUUID=\"4eced110-0987-6543-2123-b0ab8576869b\"\n```\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\ndont_scan_volumes 13aa9955-1234-5678-9098-006c334b5088,4eced110-0987-6543-2123-b0ab8576869b\n...\n```\n\n"
    },
    {
      "title": "ディストリビューションのロゴを表示してくれない",
      "level": 3,
      "content": "Arch のロゴではなく Tux が表示される場合、この問題によるものであるかもしれません (ルートパーティションのタイプが Linux filesystem ではなく Linux x86-64 root (/) である場合)。\n\nパーティションタイプを変更することで、この問題を解決することができます。\n\n加えて、ルートパーティションのラベルが \"Linux\" であったり、\"linux,\" という単語が含まれている場合にも、Tux が表示される場合があります。ディストリビューションの名前に合ったパーティションラベルに変更することを検討してください\n\nこの問題は、ファイルシステムラベルを使用することで解決できます。\n\nTux ではなく Arch のロゴを表示させるもう一つの方法は、Arch のロゴ画像をカーネル (例えば vmlinuz-linux) と同じ場所にコピーし、画像ファイルの名前をカーネルイメージのファイル名と同じにすることです:\n\n```\n# cp /usr/share/refind/icons/os_arch.png /boot/vmlinuz-linux.png\n```\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Roderick W. Smith による The rEFInd Boot Manager\n- Wikipedia:rEFInd\n- /usr/share/refind/docs/README.txt\n- Sourceforge の rEFInd ディスカッションフォーラム\n\n"
    }
  ]
}