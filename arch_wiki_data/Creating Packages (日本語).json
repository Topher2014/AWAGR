{
  "title": "Creating Packages (日本語)",
  "url": "https://wiki.archlinux.org/title/Creating_Packages_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Arch Build System\n- Arch パッケージングスタンダード\n- Arch User Repository\n- 他のディストリビューションのパッケージの作成\n- makepkg\n- pacman\n- PKGBUILD\n- .SRCINFO\n- ABS でパッチを適用\n\nこの記事は、Arch Linux の ports 風のビルドシステムを使ってパッケージを自作するユーザーの助けになることを目的としています。この記事の扱う範囲は PKGBUILD (makepkg によって読み込まれるパッケージ定義ファイル) の書き方についてです。すでに PKGBUILD が用意できている場合、makepkg の項目を参照してください。パッケージの質を向上させるためのルール・方法などの説明は Arch パッケージングスタンダードを参照してください。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 概要\n- 2 準備 2.1 ソフトウェアの準備 2.2 インストールのダウンロードとテスト 2.3 クリーンな chroot を設定する\n- 3 PKGBUILDの作成 3.1 PKGBUILD の変数を定義する 3.2 PKGBUILD の関数 3.2.1 関数 prepare() 3.2.2 関数 pkgver() 3.2.3 関数 build() 3.2.4 関数 check() 3.2.5 関数 package()\n- 4 PKGBUILD とパッケージのテスト 4.1 パッケージの正常性のテスト\n- 5 AUR にパッケージを送信する\n- 6 要約 6.1 注意点\n- 7 自動化 7.1 チェックサム 7.2 PKGBUILD ジェネレーター 7.3 新しいアップストリームリリース\n- 8 参照\n\n- 2.1 ソフトウェアの準備\n- 2.2 インストールのダウンロードとテスト\n- 2.3 クリーンな chroot を設定する\n\n- 3.1 PKGBUILD の変数を定義する\n- 3.2 PKGBUILD の関数 3.2.1 関数 prepare() 3.2.2 関数 pkgver() 3.2.3 関数 build() 3.2.4 関数 check() 3.2.5 関数 package()\n\n- 3.2.1 関数 prepare()\n- 3.2.2 関数 pkgver()\n- 3.2.3 関数 build()\n- 3.2.4 関数 check()\n- 3.2.5 関数 package()\n\n- 4.1 パッケージの正常性のテスト\n\n- 6.1 注意点\n\n- 7.1 チェックサム\n- 7.2 PKGBUILD ジェネレーター\n- 7.3 新しいアップストリームリリース\n\n"
    },
    {
      "title": "概要",
      "level": 2,
      "content": "Arch Linux のパッケージは、makepkg ユーティリティーと PKGBUILD に記載された情報からビルドされます。makepkg が実行されると、カレントディレクトリの PKGBUILD を見て、ソースをコンパイルするか必要なファイルをダウンロードするかの指示に従ってパッケージファイル (pkgname.pkg.tar.zst) が作成されます。こうして出来上がったパッケージはバイナリとインストールの実行スクリプトが含まれ、pacman でインストールできるものになります。\n\nArch パッケージは、zstd(1) を使用して圧縮された tar アーカイブまたは 'tarball' にすぎません。これには、makepkg によって生成された次のファイルが含まれています。\n\n- インストールするバイナリやファイル。\n- .PKGINFO: pacman でパッケージ管理や依存解決をするために必要なすべての情報が書かれたファイル。\n- .BUILDINFO: Reproducible Builds のための情報が含まれます。pacman 5.1 以降でのビルド時のみ含まれます。\n- .MTREE: ファイルのハッシュとタイムスタンプ。ローカルデータベースに含めることで pacman はパッケージの整合性を検証することができます。\n- .INSTALL: 任意のファイル。インストール/アップグレード/削除の後に実行される。 (PKGBUILD で指定された場合のみ存在する)\n- .Changelog: パッケージメンテナによるパッケージの更新についての覚え書き。 (必ず付属するとは限りません)\n\n"
    },
    {
      "title": "ソフトウェアの準備",
      "level": 3,
      "content": "まず、必要なツールが インストール されているか確認してください。 base-devel があれば十分です。このグループには make などのコンパイルに必要なツールが含まれています。\n\npacman で提供される makepkg はパッケージ作成で最も重要なツールの一つです。makepkg は以下を行います:\n\n1. 依存パッケージがインストールされているかどうか確認する。\n1. ソースをサーバーからダウンロードする。\n1. 圧縮されたソースファイルを展開する。\n1. fakeroot 環境でコンパイルし、インストールする。\n1. バイナリやライブラリから不要シンボルを除去する (symbol stripping)\n1. パッケージのメタデータを生成する。\n1. fakeroot 環境をパッケージに圧縮する。\n1. パッケージファイルを出力先ディレクトリに保存する。デフォルトでは作業ディレクトリ。\n\n"
    },
    {
      "title": "インストールのダウンロードとテスト",
      "level": 3,
      "content": "パッケージにしたいソフトウェアのソース tarball をダウンロードして、展開してください。その後ソフトウェアの作成者の指示に従ってプログラムをインストールしてください。ソフトウェアをコンパイル・インストールするのに必要なコマンド・手順を全て手控えておきましょう。PKGBUILD ファイルの中で同じコマンドを使うことになります。\n\nほとんどのソフトウェアは3ステップでビルドします:\n\n```\n./configure\nmake\nmake install\n```\n\nプログラムが正しく動作するか確認すると良いでしょう。\n\n"
    },
    {
      "title": "クリーンな chroot を設定する",
      "level": 3,
      "content": "システムのパッケージや設定が PKGBUILD のミスにつながらないようにするには DeveloperWiki:クリーンな chroot でビルドする に従うことを推奨します。これはより堅牢で正しいパッケージのビルド方法であり、システムに既に存在していたために必要だと気づかなかった依存関係の欠落を見つけることがよくあります。\n\n"
    },
    {
      "title": "PKGBUILDの作成",
      "level": 2,
      "content": "パッケージ作成に必要な情報は全て PKGBUILD に書かれます。makepkg は実行されると、カレントディレクトリに PKGBUILD ファイルがあるか探し、そこに書かれていることに従ってソフトウェアのソースコードをコンパイルします。PKGBUILD に書かれている指示は、Bash として実行可能である必要があります。コンパイルが無事終了すれば、出来上がったバイナリと、バージョンや依存パッケージなどのパッケージのメタデータが パッケージ名.pkg.tar.zstd にまとめられます。このパッケージファイルは pacman -U パッケージファイル でインストールすることができます。\n\n新しいパッケージを作るには、まず空の作業ディレクトリを用意します (~/abs/パッケージ名 が推奨です)。このディレクトリにファイル PKGBUILD を作成します。プロトタイプとして、/usr/share/pacman/PKGBUILD.proto や、類似パッケージの PKGBUILD が使えます。オプションを変更するだけなどの場合、後者が便利になるかもしれません。\n\n"
    },
    {
      "title": "PKGBUILD の変数を定義する",
      "level": 3,
      "content": "PKGBUILD のサンプルは /usr/share/pacman/ にあります。PKGBUILD で利用できる変数は PKGBUILD の記事で説明されています。\n\nパッケージをビルドするために必要な以下の変数は、makepkg によってあらかじめ定義されます:\n\nこれらの変数は全て絶対パスなので、適切にこれらの変数を使う限り作業ディレクトリについて心配する必要はありません。\n\n"
    },
    {
      "title": "PKGBUILD の関数",
      "level": 3,
      "content": "5つの関数が存在し、全て存在する場合ここに記載している順番どおりに実行されます。関数が存在しないときは、スキップされます。\n\n"
    },
    {
      "title": "関数 prepare()",
      "level": 4,
      "content": "Pacman 4.1 から prepare() 関数が導入されました。この関数では、パッチなどの、ソースをビルドする前の準備に使われるコマンドを実行します。この関数は build 関数の前、パッケージの展開の後に実行されます。展開が省略された場合 (makepkg -e)、prepare() は実行されません。\n\n"
    },
    {
      "title": "関数 pkgver()",
      "level": 4,
      "content": "pacman 4.1 から採用され、makepkg の実行中に pkgver 変数を更新することができます。pkgver() はソースが取得・展開されたすぐ後に実行されます。\n\ngit/svn/hg などのパッケージを作成するときにこの関数は特に便利です。なぜならビルドプロセスは同じままでも、ソースは毎日・毎時間更新される可能性があるからです。昔は日時を pkgver フィールドに入れていたため、ソフトウェアが更新されていなくても、makepkg はバージョンが変更されたと考えてリビルドをしていました。この関数では git describe, hg identify -ni などのコマンドが有用です。PKGBUILD を投稿する前に、pkgver() 関数がビルドを停止させないかテストしてください。\n\n"
    },
    {
      "title": "関数 build()",
      "level": 4,
      "content": "さて、PKGBUILD ファイルの中に build() 関数を定義しなくてはなりません。この関数、build() は Bash の文法を使って、ソフトウェアを自動的にコンパイルします。そして pkg ディレクトリを作成しここにソフトウェアをインストールします。これによって makepkg はファイルシステムをふるいにかけることなくファイルをパッケージにまとめることができます。\n\nbuild() 関数はまず展開されたソースコードのディレクトリに入ります。makepkg は build() を実行する前にカレントディレクトリを $srcdir に移動するので、ほとんどの場合最初のコマンドは以下のようになるでしょう:\n\n```\ncd \"$pkgname-$pkgver\"\n```\n\nそして、手動でソフトウェアをコンパイルをするのと同じコマンドを書き連ねます。build() 関数は、煎じ詰めて言えば手でコンパイルするのに必要な操作を自動化したものなのです。今パッケージしているソフトウェアが configure を使っているのなら、--prefix=/usr を使うのが良いでしょう。(多くのソフトウェアがファイルをインストールするのに使う) /usr/local ディレクトリは、手動でインストールする場合のみに限って使われるべきです。すべての Arch Linux パッケージは、/usr ディレクトリを使うべきです。/usr/share/pacman/PKGBUILD.proto に書かれているように、次の2行はだいたい以下のようになるでしょう:\n\n```\n./configure --prefix=/usr\nmake\n```\n\n"
    },
    {
      "title": "関数 check()",
      "level": 4,
      "content": "ここでは make check などのテストを動作させます。ソフトウェアが正しくビルドできたか確認したり依存関係が問題ないか調べるのに役立つので check() を記述することは推奨されています。\n\nテストの必要のないユーザー(や、時にはテストを通過させるようにパッケージを修正できないメンテナ)は、PKGBUILD や makepkg.conf で BUILDENV+=('!check') オプションを指定する (もしくは --nocheck フラグを付けて makepkg を呼び出す) ことで、これをスキップできます。\n\n"
    },
    {
      "title": "関数 package()",
      "level": 4,
      "content": "最後に、コンパイルされたファイルを、makepkg がファイルを読み込むことができる(そしてパッケージを作成する)ディレクトリに置きます。デフォルトでは pkg ディレクトリです。このディレクトリは単なる fakeroot 環境です。すなわち、このディレクトリはインストール先のファイルシステムの / (root ファイルシステム) に相当します。インストールするファイルは全て pkg 以下に、ディレクトリ構造を保ったまま置かれる必要があります。例えば、ファイルを /usr/bin にインストールさせたい場合は ${pkgdir}/usr/bin にファイルを置きます。数ダースのファイルを手動でコピーしなくてはならない場合はほとんどありません。ほとんどのソフトウェアでは、代わりに make install を呼び出すことでコピーが行われます。ソフトウェアを pkg ディレクトリに正しくインストールするために、最後の行は以下のようになるでしょう:\n\n```\nmake DESTDIR=\"$pkgdir/\" install\n```\n\n稀に、一つのディレクトリの中にすべてのファイルが置かれ、ソフトウェアをそこから実行するようにされていることがあります。こうした場合には、そのディレクトリを $pkgdir/opt にコピーするのが賢明です。\n\n多くの場合では、pkg 下のサブディレクトリはインストールプロセスで自動的に作られます。しかし、そうでない場合は makepkg は大量のエラーを吐いて失敗します。この場合、必要なサブディレクトリを build() 関数内で mkdir -p コマンドを実行することで、インストール作業の前にあらかじめ生成してください。\n\n昔のパッケージでは package() 関数はなく、この操作は build() でまとめて行われていました。PKGBUILD に build() がない場合は、build() 全体が fakeroot で実行されます。package() が定義されている場合、build() は makepkg を実行したユーザで実行され、package() だけが fakeroot で実行されます\n\nまた、makepkg --repackage は package() だけを呼び出します。パッケージの depends 変数をだけ変更したときなどに、ソースを再コンパイルせずパッケージを作成ができ、時間を節約することができます。\n\n"
    },
    {
      "title": "PKGBUILD とパッケージのテスト",
      "level": 2,
      "content": "build() 関数を記述している間、バグがないことを確認するために変更をテストしたくなるかもしれません。PKGBUILD ファイルが含まれているディレクトリで makepkg コマンドを実行してすることでテストすることができます。フォーマットが正しい PKGBUILD なら、makepkg はパッケージを作成します。PKGBUILD が壊れていたり未完成だと、エラーを吐きます。\n\nmakepkg は問題なく終了すると、作業ディレクトリに pkgname-pkgver.pkg.tar.zstd という名前のファイルを作成します。このパッケージは pacman -U コマンドでインストールすることができます。ただし、パッケージファイルが作られたというだけでは完全に機能するとは言えません。あるいはディレクトリだけでファイルが全く含まれていない可能性もあります (例えば、prefix が間違って指定されているとか)。pacman の query 関数を使うことでパッケージに含まれているファイルのリスト、パッケージが必要とする依存パッケージを pacman -Qlp [package file] と pacman -Qip [package file] でそれぞれ表示することができます。\n\nパッケージが問題ないようでしたら、これであなたの作業は終了です!ただし、PKGBUILD ファイルを公開するつもりならば、depends の中身を何度もチェックするべきです。\n\nまた、パッケージバイナリが完璧に動くことを確認しましょう!全ての必要なファイルが含まれているが、(システムの他の部分と問題を起こすような)度しがたい設定オプションによってクラッシュするパッケージを公開するのは迷惑です。勿論、あなた自身のためだけにパッケージをコンパイルするのなら、品質保証について心配しすぎる必要はありません。誤りによって苦しむのはあなただけなのですから。\n\n"
    },
    {
      "title": "パッケージの正常性のテスト",
      "level": 3,
      "content": "パッケージが機能するかテストした後 namcap を使ってエラーがないか確認してください:\n\n```\n$ namcap PKGBUILD\n$ namcap <package file name>.pkg.tar.zstd\n```\n\nNamcap は以下を行います:\n\n1. PKGBUILD の中身を見て、よくある間違いやパッケージファイルの階層に不必要な・間違って置かれたファイルがないか確認します。\n1. ldd を使ってパッケージ内の全ての ELF ファイルをスキャンし、必要な共有ライブラリがあるパッケージが depends に欠けていることや、推移的な依存として省略できるパッケージを自動で報告します。\n1. 欠けている、もしくは不要な依存パッケージのヒューリスティック検索。\n\nなどなど。パッケージを namcap でチェックする習慣を実践することでパッケージを投稿した後に単純な間違いを修正する手間が省けます。\n\n"
    },
    {
      "title": "AUR にパッケージを送信する",
      "level": 2,
      "content": "Arch User Repository#パッケージを投稿する に、投稿する方法について詳しい説明があります。\n\n"
    },
    {
      "title": "要約",
      "level": 2,
      "content": "1. パッケージにしたいソフトウェアのソース tarball をダウンロードする。\n1. パッケージのコンパイルを試行し任意のディレクトリにインストールする。\n1. プロトタイプの /usr/share/pacman/PKGBUILD.proto をコピーして PKGBUILD に名前を変更して一時的な作業ディレクトリに置く -- ~/abs/ が推奨。\n1. パッケージの必要に応じて PKGBUILD を編集する。\n1. makepkg を実行して作られたパッケージが正しくビルドされているか確認する。\n1. 正しくビルドされるまで、前の2つの手順を繰り返す。\n\n"
    },
    {
      "title": "注意点",
      "level": 3,
      "content": "- パッケージのビルドプロセスを自動化する前に、あらかじめ何をするのか正確にわかっている場合(その場合あなたはそもそもこの文章を読まないと思いますが)を除いて、少なくとも一度は手動でビルドを行なって下さい。残念ながら、大勢のプログラムの作者が \"./configure; make; make install\" のビルド3ステップに従っているにもかかわらず、これがいつも上手く行くとは限りません。下手をすると、全てを問題なく動かすにはパッチを適用する必要がある場合も考えられます。大雑把に言うと: プログラムをソース tarball からコンパイルして、規定の一時サブディレクトリにインストールすることができない場合、パッケージングを試行する必要さえありません。makepkg にはソースの問題を解決してくれるような妖精の粉はないからです。\n- 稀に、ソースからパッケージを作成することができなくて sh installer.run などのようにコマンドを実行しなくてはならないことがあります。そのようなときは、パッケージを作成するためにドキュメント (README や INSTALL の手順、man ページ、あるいは Gentoo の ebuild や他のパッケージインストーラのソースパッケージ、それでも駄目なら Makefile やソースコードまで) を相当読まなくてはなりません。最悪の場合、ソースファイルに編集を加える必要さえ出てくることもあります。しかしながら、makepkg はユーザーの補助がなくてもビルドが通るように完全に自動化する必要があります。そのため、Makefile を編集しなくてはならないときは、PKGBUILD にカスタムパッチを供えて prepare() 関数の中からパッチをインストールするか、あるいは prepare() 関数の中で sed コマンドを実行してください。\n\n"
    },
    {
      "title": "チェックサム",
      "level": 3,
      "content": "新しいソフトウェアリリースのチェックサムを更新するプロセスは、updpkgsums ツールによって自動化できます。詳細については、新しいチェックサムを生成する を参照してください。\n\n"
    },
    {
      "title": "PKGBUILD ジェネレーター",
      "level": 3,
      "content": "パッケージによっては、PKGBUILD を自動的に生成できます。\n\n- Haskell: cblrepo\n- Node.js: nodejs-npm2archAUR npm2arch\n- Perl: perl-cpanplus-dist-arch\n- Python: pipman-gitAUR, pip2arch-gitAUR, python-pypi2pkgbuildAUR\n- Ruby: gem2archAUR, pacgemAUR\n- Rust: cargo-pkgbuildAUR\n\n"
    },
    {
      "title": "新しいアップストリームリリース",
      "level": 3,
      "content": "pkgctl(devtools パッケージの一部)は、.nvchecker.toml 設定ファイルの形式で nvchecker 統合をサポートしています(このファイルは PKGBUILD と同じディレクトリに配置する必要があります)例として、pacman パッケージの.nvchecker.toml 設定ファイルを参照してください。\n\nその後、pkgctl version check を使用して、新しいアップストリームバージョンがリリースされているかどうかを確認できます(PKGBUILD に指定された pkgver と比較して)また、pkgctl version upgrade を使用して、PKGBUILD をそれに応じて更新できます。詳細については、pkgctl-version(1) を参照してください。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- How to correctly create a patch file\n- Arch Linux Classroom IRC Logs of classes about creating PKGBUILDs\n- Fakeroot approach for package installation\n\n"
    }
  ]
}