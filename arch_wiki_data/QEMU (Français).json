{
  "title": "QEMU (Français)",
  "url": "https://wiki.archlinux.org/title/QEMU_(Fran%C3%A7ais)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **Cet article ou section a besoin d'être traduit(e).** Cet article ou section a besoin d'être traduit(e).\n\nCet article ou section a besoin d'être traduit(e).\n\nRelated articles\n\n- Category:Hypervisors\n- Libvirt\n- QEMU/Guest graphics acceleration\n- PCI passthrough via OVMF\n\nSelon la page QEMU about page, \"QEMU est un émulateur et un virtualiseur de machine générique et open source\".\n\nLorsqu'il est utilisé comme émulateur de machine, QEMU peut exécuter des systèmes d'exploitation et des programmes conçus pour une machine (par exemple, une carte ARM) sur une autre machine (par exemple, votre PC x86). En utilisant une traduction dynamique, il obtient de très bonnes performances.\n\nQEMU peut utiliser d'autres hyperviseurs comme Xen ou KVM pour utiliser des extensions de CPU (HVM) pour la virtualisation. Lorsqu'il est utilisé comme virtualiseur, QEMU atteint des performances proches de celles d'un système natif en exécutant le code invité directement sur le CPU hôte.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Installez le paquet qemu-desktop (ou qemu-base pour la version sans interface graphique) et les paquets optionnels suivants pour vos besoins :\n\n- qemu-emulators-full - support d'architectures supplémentaires\n- qemu-block-gluster - Prise en charge des blocs Glusterfs.\n- qemu-block-iscsi - Prise en charge des blocs iSCSI.\n- samba - Prise en charge du serveur SMB/CIFS.\n\nAlternativement, qemu-user-static existe en tant que variante usermode et statique.\n\n"
    },
    {
      "title": "Variantes de QEMU",
      "level": 3,
      "content": "QEMU est proposé en plusieurs variantes adaptées à différents cas d'utilisation.\n\nEn première classification, QEMU est proposé en modes d'émulation «full-system» et «usermode» :\n\nQEMU est proposé dans des variantes liées dynamiquement et statiquement :\n\nDans le cas d'Arch Linux, l'émulation complète du système est offerte comme :\n\nNotez que les versions headless et non-headless installent des commandes avec le même nom (par exemple qemu-system-x86_64) et ne peuvent donc pas être installées toutes les deux en même temps.\n\n"
    },
    {
      "title": "Détails sur les paquets offerts dans Arch Linux",
      "level": 3,
      "content": "- Le paquet qemu-desktop fournit les émulateurs d'architecture x86_64 pour l'émulation du système complet (qemu-system-x86_64). Le paquet qemu-emulators-full fournit la variante usermode de l'architecture x86_64 (qemu-x86_64) et, pour les autres architectures prises en charge, il inclut les variantes full-system et usermode (par exemple, qemu-system-arm et qemu-arm).\n- Les versions «headless» (sans affichage) de ces paquets (uniquement applicables à l'émulation full-system) sont qemu-base (x86_64 uniquement) et qemu-emulators-full (le reste des architectures).\n- L'émulation du système complet peut être étendue avec certains modules QEMU présents dans des paquets séparés : qemu-block-gluster, qemu-block-iscsi et qemu-guest-agent.\n- Le paquet AUR non officiel qemu-user-static fournit un mode utilisateur et une variante statique pour toutes les architectures cibles prises en charge par QEMU. Les commandes QEMU installées sont nommées qemu-target_architecture-static, par exemple, qemu-x86_64-static pour les CPU intel 64 bits.\n\n"
    },
    {
      "title": "Interfaces graphiques pour QEMU",
      "level": 2,
      "content": "Contrairement à d'autres programmes de virtualisation tels que VirtualBox et VMware, QEMU ne fournit pas d'interface graphique pour gérer les machines virtuelles (autre que la fenêtre qui apparaît lors de l'exécution d'une machine virtuelle), ni de moyen de créer des machines virtuelles persistantes avec des paramètres enregistrés. Tous les paramètres permettant d'exécuter une machine virtuelle doivent être spécifiés sur la ligne de commande à chaque lancement, à moins que vous n'ayez créé un script personnalisé pour démarrer votre ou vos machines virtuelles.\n\nLibvirt fournit un moyen pratique de gérer les machines virtuelles QEMU. Consultez liste des clients libvirt pour connaître les interfaces disponibles.\n\nAutres interfaces graphiques pour QEMU :\n\n- AQEMU — QEMU GUI écrite en Qt5.\n\n"
    },
    {
      "title": "Création d'une image de disque dur",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nPour exécuter QEMU, vous aurez besoin d'une image de disque dur, à moins que vous ne démarriez un système «live» à partir d'un CD-ROM ou du réseau (et non pour installer un système d'exploitation sur une image de disque dur). Une image de disque dur est un fichier qui stocke le contenu du disque dur émulé.\n\nUne image de disque dur peut être brute, c'est-à-dire qu'elle est littéralement identique, octet par octet, à ce que consulte l'invité, et elle utilisera toujours la pleine capacité du disque dur de l'invité sur l'hôte. Cette méthode fournit le moins de surcharge d'E/S, mais peut gaspiller beaucoup d'espace, car l'espace non utilisé sur l'invité ne peut pas être utilisé sur l'hôte.\n\nAlternativement, l'image du disque dur peut être dans un format tel que qcow2 qui n'alloue de l'espace au fichier image que lorsque le système d'exploitation invité écrit réellement dans ces secteurs sur son disque dur virtuel. L'image apparaît comme étant de taille complète pour le système d'exploitation invité, même si elle n'occupe qu'une très petite quantité d'espace sur le système hôte. Ce format d'image prend également en charge la fonctionnalité d'instantané de QEMU (consultez #Création et gestion des snapshots via la console du moniteur pour plus de détails). Cependant, l'utilisation de ce format au lieu de raw affectera probablement les performances.\n\nQEMU fournit la commande qemu-img pour créer des images de disque dur. Par exemple, pour créer une image de 4 Gio au format raw :\n\n```\n$ qemu-img create -f raw image_file 4G\n```\n\nVous pouvez utiliser -f qcow2 pour créer un disque qcow2 à la place.\n\n"
    },
    {
      "title": "Images de stockage superposées",
      "level": 4,
      "content": "Vous pouvez créer une image de stockage une seule fois (l'image \"backing\") et faire en sorte que QEMU conserve les mutations de cette image dans une image de recouvrement. Cela vous permet de revenir à un état antérieur de cette image de stockage. Vous pouvez revenir en arrière en créant une nouvelle image de recouvrement au moment où vous souhaitez revenir en arrière, basée sur l'image de sauvegarde originale.\n\nPour créer une image superposée, lancez une commande comme :\n\n```\n$ qemu-img create -o backing_file=img1.raw,backing_fmt=raw -f qcow2 img1.cow\n```\n\nAprès cela, vous pouvez exécuter votre VM QEMU comme d'habitude (consultez #Exécution du système virtualisé) :\n\n```\n$ qemu-system-x86_64 img1.cow\n```\n\nL'image de sauvegarde sera alors laissée intacte et les mutations vers ce stockage seront enregistrées dans le fichier de l'image de recouvrement.\n\nLorsque le chemin vers l'image de sauvegarde change, une réparation est nécessaire.\n\nAssurez-vous que le chemin de l'image de sauvegarde d'origine mène toujours à cette image. Si nécessaire, créez un lien symbolique entre le chemin d'origine et le nouveau chemin. Ensuite, lancez une commande comme :\n\n```\n$ qemu-img rebase -b /new/img1.raw /new/img1.cow\n```\n\nSi vous le souhaitez, vous pouvez également effectuer un rebasement \"non sécurisé\" où l'ancien chemin vers l'image de sauvegarde n'est pas vérifié :\n\n```\n$ qemu-img rebase -u -b /nouvelle/img1.raw /nouvelle/img1.cow\n```\n\n"
    },
    {
      "title": "Redimensionnement d'une image",
      "level": 4,
      "content": "L'exécutable qemu-img possède l'option resize, qui permet de redimensionner facilement une image de disque dur. Elle fonctionne à la fois pour raw et qcow2. Par exemple, pour augmenter l'espace de l'image de 10 Gio, exécutez :\n\n```\n$ qemu-img resize disk_image +10G\n```\n\nAprès avoir agrandi l'image disque, vous devez utiliser le système de fichiers et les outils de partitionnement dans la machine virtuelle pour commencer à utiliser le nouvel espace. Lors du rétrécissement d'une image disque, vous devez 'd'abord réduire les tailles des systèmes de fichiers et des partitions alloués à l'aide des outils de système de fichiers et de partitionnement dans la machine virtuelle, puis rétrécir l'image disque en conséquence, sinon le rétrécissement de l'image disque entraînera une perte de données ! Pour un Windows virtualisé, ouvrez le panneau de contrôle \"créer et formater les partitions du disque dur\".\n\n"
    },
    {
      "title": "Convertir une image",
      "level": 4,
      "content": "Vous pouvez convertir une image dans d'autres formats en utilisant qemu-img convert. Cet exemple montre comment convertir une image raw en qcow2 :\n\n```\n$ qemu-img convert -f raw -O qcow2 input.img output.qcow2\n```\n\nCeci ne supprimera pas le fichier d'entrée original.\n\n"
    },
    {
      "title": "Préparation du support d'installation",
      "level": 3,
      "content": "Pour installer un système d'exploitation dans votre image disque, vous avez besoin du support d'installation (par exemple, un disque optique, une clé USB ou une image ISO) pour le système d'exploitation. Le support d'installation ne doit pas être monté car QEMU accède directement au support.\n\n```\n$ dd if=/dev/cdrom of=cd_image.iso bs=4k\n```\n\n"
    },
    {
      "title": "Installation du système d'exploitation",
      "level": 3,
      "content": "C'est la première fois que vous devrez démarrer l'émulateur. Pour installer le système d'exploitation sur l'image disque, vous devez attacher l'image disque et le média d'installation à la machine virtuelle, et la faire démarrer à partir du média d'installation.\n\nPar exemple, sur les invités i386, pour installer à partir d'un fichier ISO amorçable comme CD-ROM et une image disque brute :\n\n```\n$ qemu-system-x86_64 -cdrom iso_image -boot order=d -drive file=disk_image,format=raw\n```\n\nConsultez qemu(1) pour plus d'informations sur le chargement d'autres types de supports (tels que des disquettes, des images de disques ou des lecteurs physiques) et #Exécution du système virtualisé pour d'autres options utiles.\n\nUne fois l'installation du système d'exploitation terminée, l'image QEMU peut être démarrée directement (consultez #Exécution du système virtualisé).\n\n- Au lieu de spécifier -boot order=x, certains utilisateurs peuvent se sentir plus à l'aise en utilisant un menu de démarrage : -boot menu=on, au moins pendant la configuration et l'expérimentation.\n- Lorsque QEMU est exécuté en mode sans affichage, il démarre un serveur VNC local sur le port 5900 par défaut. Vous pouvez utiliser TigerVNC pour vous connecter à l'OS invité : vncviewer :5900\n- Si vous devez remplacer des disquettes ou des CD dans le cadre du processus d'installation, vous pouvez utiliser le moniteur de machine QEMU (appuyez sur Ctrl+Alt+2 dans la fenêtre de la machine virtuelle) pour supprimer et attacher des périphériques de stockage à une machine virtuelle. Tapez info block pour consulter les périphériques de bloc, et utilisez la commande change pour échanger un périphérique. Appuyez sur Ctrl+Alt+1 pour revenir à la machine virtuelle.\n\n"
    },
    {
      "title": "Exécution du système virtualisé",
      "level": 2,
      "content": "Les binaires qemu-system-* (par exemple qemu-system-i386 ou qemu-system-x86_64, selon l'architecture de l'invité) sont utilisés pour exécuter l'invité virtualisé. L'utilisation est la suivante :\n\n```\n$ qemu-system-x86_64 options disk_image\n```\n\nLes options sont les mêmes pour tous les binaires qemu-system-*, consultez qemu(1) pour la documentation de toutes les options.\n\nPar défaut, QEMU affichera la sortie vidéo de la machine virtuelle dans une fenêtre. Une chose à garder à l'esprit : lorsque vous cliquez dans la fenêtre de QEMU, le pointeur de la souris est saisi. Pour le relâcher, appuyez sur Ctrl+Alt+g.\n\n"
    },
    {
      "title": "Activation de KVM",
      "level": 3,
      "content": "La virtualisation complète KVM (Kernel-based Virtual Machine) doit être prise en charge par votre noyau Linux et votre matériel, et les modules du noyau nécessaires doivent être chargés. Consultez KVM pour plus d'informations.\n\nPour démarrer QEMU en mode KVM, ajoutez -enable-kvm aux options de démarrage supplémentaires. Pour vérifier si KVM est activé pour une VM en cours d'exécution, entrez dans le #Moniteur de QEMU et tapez info kvm.\n\n- L'argument accel=kvm de l'option -machine est équivalent à l'option -enable-kvm ou -accel kvm}.\n- Le modèle de CPU host nécessite KVM\n- Si vous démarrez votre VM avec un outil GUI et que les performances sont très mauvaises, vous devez vérifier la prise en charge KVM, car QEMU peut se rabattre sur l'émulation logicielle.\n- KVM doit être activé afin de démarrer Windows 7 et Windows 8 correctement sans écran bleu.\n\n"
    },
    {
      "title": "Activation du support IOMMU (Intel VT-d/AMD-Vi)",
      "level": 3,
      "content": "Activez d'abord IOMMU, consultez PCI passthrough via OVMF#Setting up IOMMU.\n\nAjoutez -device intel-iommu pour créer le périphérique IOMMU :\n\n```\n$ qemu-system-x86_64 -enable-kvm -machine q35 -device intel-iommu -cpu host ...\n```\n\n```\nDevice at bus pcie.0 addr 09.0 requires iommu notifier which is currently not supported by intel-iommu emulation\n```\n\n"
    },
    {
      "title": "Réseau",
      "level": 3,
      "content": "Les données peuvent être partagées entre le système d'exploitation hôte et le système d'exploitation invité en utilisant n'importe quel protocole réseau capable de transférer des fichiers, comme NFS, SMB, NBD, HTTP, FTP, ou SSH, à condition que vous ayez configuré le réseau de manière appropriée et activé les services adéquats.\n\nLa mise en réseau en mode utilisateur par défaut permet à l'invité d'accéder au système d'exploitation hôte à l'adresse IP 10.0.2.2. Tous les serveurs que vous exécutez sur votre système d'exploitation hôte, comme un serveur SSH ou un serveur SMB, seront accessibles à cette adresse IP. Ainsi, sur les invités, vous pouvez monter des répertoires exportés sur l'hôte via SMB ou NFS, ou vous pouvez accéder au serveur HTTP de l'hôte, etc. Il ne sera pas possible pour le système d'exploitation hôte d'accéder aux serveurs fonctionnant sur le système d'exploitation invité, mais cela peut être fait avec d'autres configurations réseau (consultez #Mise en réseau avec tap pour QEMU).\n\n"
    },
    {
      "title": "La redirection de port de QEMU",
      "level": 3,
      "content": "QEMU peut transférer des ports de l'hôte vers l'invité pour permettre, par exemple, la connexion de l'hôte à un serveur SSH fonctionnant sur l'invité.\n\nPar exemple, pour lier le port 60022 sur l'hôte avec le port 22 (SSH) sur l'invité, démarrez QEMU avec une commande comme :\n\n```\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::60022-:22\n```\n\nAssurez-vous que le sshd fonctionne sur l'invité et connectez-vous avec :\n\n```\n$ ssh guest-user@127.0.0.1 -p 60022\n```\n\nVous pouvez utiliser SSHFS pour monter le système de fichiers de l'invité sur l'hôte pour un accès partagé en lecture et en écriture.\n\nPour transférer plusieurs ports, il suffit de répéter le hostfwd dans l'argument -nic, par exemple pour le port VNC :\n\n```\n$ qemu-system-x86_64 disk_image -nic user,hostfwd=tcp::60022-:22,hostfwd=tcp::5900-:5900\n```\n\n"
    },
    {
      "title": "Le serveur SMB intégré de QEMU",
      "level": 3,
      "content": "La documentation de QEMU indique qu'il dispose d'un serveur SMB \"intégré\", mais en fait il ne fait que démarrer Samba sur l'hôte avec un fichier smb.conf généré automatiquement et situé dans /tmp/qemu-smb.random_string et le rend accessible à l'invité à une adresse IP différente (10.0.2.4 par défaut). Cela ne fonctionne que pour les réseaux d'utilisateurs, et est utile lorsque vous ne voulez pas démarrer le service Samba normal sur l'hôte, auquel l'invité peut également accéder si vous avez configuré des partages sur celui-ci.\n\nUn seul répertoire peut être défini comme partagé avec l'option smb=, mais ajouter d'autres répertoires (même lorsque la machine virtuelle est en cours d'exécution) pourrait être aussi facile que de créer des liens symboliques dans le répertoire partagé si QEMU configurait SMB pour suivre les liens symboliques. Il ne le fait pas, mais la configuration du serveur SMB en cours d'exécution peut être modifiée comme décrit ci-dessous.\n\nSamba doit être installé sur l'hôte. Pour activer cette fonctionnalité, démarrez QEMU avec une commande comme :\n\n```\n$ qemu-system-x86_64 -nic user,id=nic0,smb=shared_dir_path' disk_image\n```\n\noù shared_dir_path est un répertoire que vous voulez partager entre l'invité et l'hôte.\n\nEnsuite, dans l'invité, vous pourrez accéder au répertoire partagé sur l'hôte 10.0.2.4 avec le nom de partage \"qemu\". Par exemple, dans l'Explorateur Windows, vous accédez à \\\\\\10.0.2.4\\qemu.\n\n- Si vous utilisez plusieurs fois les options de partage comme -net user,smb=shared_dir_path1 -net user,smb=shared_dir_path2 ou -net user,smb=shared_dir_path1,smb=shared_dir_path2 alors il ne partagera que le dernier défini.\n- Si vous ne pouvez pas accéder au dossier partagé et que le système invité est Windows, vérifiez que le protocole NetBIOS est activé[dead link 2023-05-06 ⓘ] et qu'un pare-feu ne bloque pas les ports utilisés par le protocole NetBIOS.\n- Si vous ne pouvez pas accéder au dossier partagé et que le système invité est Windows 10 Entreprise ou Éducation ou Windows Server 2016, activer l'accès invité.\n- Si vous utilisez la #Mise en réseau avec tap pour QEMU, utilisez -device virtio-net,netdev=vmnic -netdev user,id=vmnic,smb=shared_dir_path pour obtenir SMB.\n\nUne façon de partager plusieurs répertoires et de les ajouter ou de les supprimer pendant l'exécution de la machine virtuelle, consiste à partager un répertoire vide et à créer/supprimer des liens symboliques vers les répertoires du répertoire partagé. Pour que cela fonctionne, la configuration du serveur SMB en cours d'exécution peut être modifiée avec le script suivant, qui permet également l'exécution de fichiers sur l'invité qui ne sont pas définis comme exécutables sur l'hôte :\n\n```\n#!/bin/sh\neval $(ps h -C smbd -o pid,args | grep /tmp/qemu-smb | gawk '{print \"pid=\"$1\";conf=\"$6}')\necho \"[global]\nallow insecure wide links = yes\n[qemu]\nfollow symlinks = yes\nwide links = yes\nacl allow execute always = yes\" >> \"$conf\"\n# in case the change is not detected automatically:\nsmbcontrol --configfile=\"$conf\" \"$pid\" reload-config\n```\n\nCeci peut être appliqué au serveur en cours d'exécution démarré par qemu seulement après que l'invité se soit connecté au lecteur réseau pour la première fois. Une alternative à cette méthode est d'ajouter des partages additionnels au fichier de configuration comme ceci :\n\n```\necho \"[myshare]\npath=another_path\nread only=no\nguest ok=yes\nforce user=username\" >> $conf\n```\n\nCe partage sera disponible sur l'invité en tant que \\10.0.2.4\\myshare.\n\n"
    },
    {
      "title": "Utiliser le passage de système de fichiers et VirtFS",
      "level": 3,
      "content": "Consultez la documentation QEMU.\n\n"
    },
    {
      "title": "Partage de fichiers avec virtiofsd",
      "level": 3,
      "content": "virtiofsd est livré avec le paquet QEMU. La documentation est disponible online[dead link 2023-05-06 ⓘ] ou /usr/share/doc/qemu/tools/virtiofsd.html sur le système de fichiers local avec QEMU installé.\n\nAjoutez l'utilisateur qui exécute qemu au groupe 'kvm', car il doit accéder à la socket virtiofsd. Vous devrez peut-être vous déconnecter pour que le changement prenne effet.\n\nNote: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nDémarrez virtiofsd en tant que root :\n\n```\n# /usr/lib/qemu/virtiofsd --socket-path=/var/run/qemu-vm-001.sock -o source=/tmp/vm-001 -o cache=always\n```\n\noù\n\n- /var/run/qemu-vm-001.sock est un fichier socket,\n- /tmp/vm-001 est un répertoire partagé entre l'hôte et le vm invité.\n\nLe fichier socket créé a la permission d'accès de root seulement. Donnez au groupe kvm l'accès à ce fichier avec :\n\n```\n# chgrp kvm qemu-vm-001.sock ; chmod g+rxw qemu-vm-001.sock\n```\n\nAjoutez les options de configuration suivantes lors du démarrage de VM :\n\n```\n-objet memory-backend-memfd,id=mem,size=4G,share=on \\\n-numa node,memdev=mem \\\n-chardev socket,id=char0,path=/var/run/qemu-vm-001.sock \\\n-device vhost-user-fs-pci,chardev=char0,tag=myfs\n```\n\noù\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\n- size=4G doit correspondre à la taille spécifiée avec l'option -m 4G,\n- /var/run/qemu-vm-001.sock pointe vers le fichier de socket démarré précédemment,\n\nRappelez-vous que l'invité doit être configuré pour permettre le partage. Pour Windows, il existe instructions. Une fois configuré, Windows aura le lecteur Z : mappé automatiquement avec le contenu du répertoire partagé.\n\nVotre système invité Windows 10 est correctement configuré s'il possède :\n\n- Le service Windows VirtioFSSService,\n- Le service Windows WinFsp.Launcher,\n- le pilote de périphérique VirtIO FS sous \"Périphériques système\" dans le \"Gestionnaire de périphériques\" de Windows.\n\nSi les éléments ci-dessus sont installés et que le lecteur Z: n'est toujours pas listé, essayez de réparer \"Virtio-win-guest-tools\" dans l'ajout/suppression de programmes de Windows.\n\n"
    },
    {
      "title": "Montage d'une partition de l'invité sur l'hôte",
      "level": 3,
      "content": "Il peut être utile de monter une image de disque sous le système hôte, cela peut être un moyen de transférer des fichiers dans et hors de l'invité. Cela doit être fait lorsque la machine virtuelle n'est pas en cours d'exécution.\n\nLa procédure pour monter le disque sur l'hôte dépend du type d'image qemu, raw ou qcow2. Nous détaillons par la suite les étapes pour monter un disque dans les deux formats dans #Montage d'une partition à partir d'une image brute et #Montage d'une partition à partir d'une image qcow2. Pour la documentation complète, consultez Wikibooks:QEMU/Images#Mounting an image on the host.\n\n"
    },
    {
      "title": "Montage d'une partition à partir d'une image brute",
      "level": 4,
      "content": "Il est possible de monter des partitions qui se trouvent à l'intérieur d'un fichier image disque brut en les configurant comme des périphériques de bouclage.\n\nUne façon de monter une partition d'image disque est de monter l'image disque à un certain décalage en utilisant une commande comme la suivante :\n\n```\n# mount -o loop,offset=32256 image_de_disque mountpoint\n```\n\nL'option offset=32256 est en fait passée au programme losetup pour configurer un périphérique de bouclage qui commence à l'octet 32256 du fichier et continue jusqu'à la fin. Ce périphérique de bouclage est ensuite monté. Vous pouvez également utiliser l'option sizelimit pour spécifier la taille exacte de la partition, mais cela n'est généralement pas nécessaire.\n\nSelon votre image disque, la partition nécessaire peut ne pas commencer à l'offset 32256. Exécutez fdisk -l disk_image pour consulter les partitions dans l'image. fdisk donne les décalages de début et de fin en secteurs de 512 octets, donc multipliez par 512 pour obtenir le décalage correct à passer à mount.\n\nLe pilote de boucle Linux prend en charge les partitions dans les périphériques de bouclage, mais il est pris en charge par défaut. Pour l'activer, faites ce qui suit :\n\n- Débarrassez-vous de tous vos périphériques de bouclage (démontez toutes les images montées, etc.).\n- Déchargez le module noyau loop, et chargez-le avec le paramètre max_part=15. De plus, le nombre maximum de boucles peut être contrôlé avec le paramètre max_loop.\n\nConfigurez votre image comme un périphérique de bouclage :\n\n```\n# losetup -f -P disk_image\n```\n\nEnsuite, si le périphérique créé était /dev/loop0, des périphériques supplémentaires /dev/loop0pX auront été automatiquement créés, où X est le numéro de la partition. Ces périphériques de bouclage de partition peuvent être montés directement. Par exemple :\n\n```\n# mount /dev/loop0p1 mountpoint\n```\n\nPour monter l'image disque avec udisksctl, consultez Udisks#Mount loop devices.\n\nkpartx du paquet multipath-tools peut lire une table de partition sur un périphérique et créer un nouveau périphérique pour chaque partition. Par exemple :\n\n```\n# kpartx -a disk_image\n```\n\nCeci configurera le périphérique de bouclage et créera le(s) périphérique(s) de partition nécessaire(s) dans /dev/mapper/.\n\n"
    },
    {
      "title": "Montage d'une partition à partir d'une image qcow2",
      "level": 4,
      "content": "Nous allons utiliser qemu-nbd, qui permet d'utiliser le protocole NBD (network block device) pour partager l'image disque.\n\nTout d'abord, nous devons charger le module nbd :\n\n```\n# modprobe nbd max_part=16\n```\n\nEnsuite, nous pouvons partager le disque et créer les entrées du périphérique :\n\n```\n# qemu-nbd -c /dev/nbd0 /chemin/vers/image.qcow2\n```\n\nDécouvrez les partitions :\n\n```\n# partprobe /dev/nbd0\n```\n\nfdisk peut être utilisé pour obtenir des informations sur les différentes partitions de nbd0 :\n\n```\n# fdisk -l /dev/nbd0\n```\n\n```\nDisk /dev/nbd0: 25.2 GiB, 27074281472 bytes, 52879456 sectors\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisklabel type: dos\nDisk identifier: 0xa6a4d542\n\nDevice      Boot   Start      End  Sectors  Size Id Type\n/dev/nbd0p1 *       2048  1026047  1024000  500M  7 HPFS/NTFS/exFAT\n/dev/nbd0p2      1026048 52877311 51851264 24.7G  7 HPFS/NTFS/exFAT\n```\n\nEnsuite, montez n'importe quelle partition de l'image du disque, par exemple la partition 2 :\n\n```\n# mount /dev/nbd0p2 mountpoint\n```\n\nAprès l'utilisation, il est important de démonter l'image et d'inverser les étapes précédentes, c'est-à-dire démonter la partition et déconnecter le périphérique nbd :\n\n```\n# umount mountpoint\n# qemu-nbd -d /dev/nbd0\n```\n\n"
    },
    {
      "title": "Utilisation de n'importe quelle partition réelle comme partition primaire unique d'une image de disque dur",
      "level": 3,
      "content": "Parfois, vous pouvez souhaiter utiliser l'une de vos partitions système à partir de QEMU. L'utilisation d'une partition brute pour une machine virtuelle améliorera les performances, car les opérations de lecture et d'écriture ne passent pas par la couche du système de fichiers sur l'hôte physique. Une telle partition fournit également un moyen de partager des données entre l'hôte et l'invité.\n\nDans Arch Linux, les fichiers de périphérique pour les partitions brutes sont, par défaut, la propriété de root et du groupe disk. Si vous souhaitez qu'un utilisateur non root puisse lire et écrire sur une partition brute, vous devez soit changer le propriétaire du fichier de périphérique de la partition pour cet utilisateur, ajouter cet utilisateur au groupe disk, ou utiliser ACL pour un contrôle d'accès plus fin.\n\n- Bien que cela soit possible, il n'est pas recommandé de permettre aux machines virtuelles de modifier des données critiques sur le système hôte, comme la partition racine.\n- Vous ne devez pas monter un système de fichiers sur une partition en lecture-écriture sur l'hôte et l'invité en même temps. Sinon, il y aura corruption des données.\n\nAprès avoir fait cela, vous pouvez attacher la partition à une machine virtuelle QEMU comme un disque virtuel.\n\nCependant, les choses sont un peu plus compliquées si vous souhaitez que la machine virtuelle entière soit contenue dans une partition. Dans ce cas, il n'y aura pas de fichier image de disque pour démarrer la machine virtuelle puisque vous ne pouvez pas installer un chargeur d'amorçage sur une partition qui est elle-même formatée comme un système de fichiers et non comme un périphérique partitionné avec un MBR. Une telle machine virtuelle peut être démarrée soit par : #Spécifier le noyau et l'initrd manuellement, #Simulation d'un disque virtuel avec MBR, #Utilisation du device-mapper, #Utilisation d'un RAID linéaire ou #Utilisation d'un périphérique de bloc en réseau.\n\n"
    },
    {
      "title": "Spécifier le noyau et l'initrd manuellement",
      "level": 4,
      "content": "QEMU prend en charge le chargement direct des noyaux Linux et des init ramdisks, contournant ainsi les chargeurs d'amorçage tels que GRUB. Il peut ensuite être lancé avec la partition physique contenant le système de fichiers racine comme disque virtuel, qui ne semblera pas être partitionné. Pour ce faire, il suffit de lancer une commande similaire à la suivante :\n\n```\n$ qemu-system-x86_64 -kernel /boot/vmlinuz-linux -initrd /boot/initramfs-linux.img -append root=/dev/sda /dev/sda3\n```\n\nDans l'exemple ci-dessus, la partition physique utilisée pour le système de fichiers racine de l'invité est /dev/sda3 sur l'hôte, mais elle apparaît comme /dev/sda sur l'invité.\n\nVous pouvez, bien sûr, spécifier n'importe quel noyau et initrd que vous voulez, et pas seulement ceux qui sont fournis avec Arch Linux.\n\nQuand il y a plusieurs paramètres du noyau à passer à l'option -append, ils doivent être cités en utilisant des guillemets simples ou doubles. Par exemple :\n\n```\n... -append 'root=/dev/sda1 console=ttyS0\n```\n\n"
    },
    {
      "title": "Simulation d'un disque virtuel avec MBR",
      "level": 4,
      "content": "Une manière plus compliquée de faire en sorte qu'une machine virtuelle utilise une partition physique, tout en gardant cette partition formatée en tant que système de fichiers et en ne faisant pas simplement en sorte que l'invité partitionne la partition comme s'il s'agissait d'un disque, est de simuler un MBR pour celle-ci afin qu'elle puisse démarrer à l'aide d'un chargeur d'amorçage tel que GRUB.\n\nPour ce qui suit, supposons que vous ayez une partition non montée /dev/hdaN avec un système de fichiers sur laquelle vous souhaitez faire partie d'une image disque QEMU. L'astuce consiste à faire précéder dynamiquement d'un master boot record (MBR) la partition réelle que vous souhaitez intégrer dans une image disque brute QEMU. Plus généralement, la partition peut être n'importe quelle partie d'un disque simulé plus grand, en particulier un périphérique de bloc qui simule le disque physique original mais qui n'expose /dev/hdaN que la machine virtuelle.\n\nUn disque virtuel de ce type peut être représenté par un fichier VMDK qui contient des références au MBR et à la partition (une copie de ceux-ci), mais QEMU ne prend pas en charge ce format VMDK. Par exemple, un disque virtuel créé par\n\n```\n$ VBoxManage internalcommands createrawvmdk -filename /path/to/file.vmdk -rawdisk /dev/hda\n```\n\nsera rejetée par QEMU avec le message d'erreur suivant\n\n```\nType d'image non supporté 'partitionedDevice'\n```\n\nNotez que VBoxManage crée deux fichiers, file.vmdk et file-pt.vmdk, ce dernier étant une copie du MBR, vers lequel pointe le fichier texte file.vmdk. Les opérations de lecture en dehors de la partition cible ou du MBR donneraient des zéros, tandis que les données écrites seraient rejetées.\n\nUne méthode similaire à l'utilisation d'un fichier descripteur VMDK utilise le device-mapper pour ajouter un périphérique en boucle attaché au fichier MBR à la partition cible. Dans le cas où nous n'avons pas besoin que notre disque virtuel ait la même taille que l'original, nous créons d'abord un fichier pour contenir le MBR :\n\n```\n$ dd if=/dev/zero of=/path/to/mbr count=2048\n```\n\nIci, un fichier de 1 Mio (2048 * 512 octets) est créé conformément aux politiques d'alignement des partitions utilisées par les outils modernes de partitionnement de disques. Pour des raisons de compatibilité avec les anciens logiciels de partitionnement, 63 secteurs au lieu de 2048 peuvent être nécessaires. Le MBR ne nécessite qu'un seul bloc de 512 octets, l'espace libre supplémentaire peut être utilisé pour une partition de démarrage du BIOS et, dans le cas d'un schéma de partitionnement hybride, pour une table de partition GUID. Ensuite, nous attachons un périphérique en boucle au fichier MBR :\n\n```\n# losetup --show -f /path/to/mbr - /dev/loop0\n/dev/loop0\n```\n\nDans cet exemple, le périphérique résultant est /dev/loop0. Le mappeur de périphériques est maintenant utilisé pour joindre le MBR et la partition :\n\n```\n# echo \"0 2048 linear /dev/loop0 0\n2048 `blockdev --getsz /dev/hda' 'N` linear /dev/hda' 'N 0\" | dmsetup create qemu\n```\n\nLe résultat /dev/mapper/qemu est ce que nous allons utiliser comme image disque brute QEMU. Des étapes supplémentaires sont nécessaires pour créer une table de partition (consultez la section qui décrit l'utilisation d'un RAID linéaire pour un exemple) et le code du chargeur d'amorçage sur le disque virtuel (qui sera stocké dans /path/to/mbr).\n\nLa configuration suivante est un exemple où la position de /dev/hdaN sur le disque virtuel doit être la même que sur le disque physique et le reste du disque est caché, à l'exception du MBR, qui est fourni en copie :\n\n```\n# dd if=/dev/hda count=1 of=/path/to/mbr\n# loop=`losetup --show -f /path/to/mbr`\n# start=`blockdev --report /dev/hdaN | tail -1 | awk '{print $5}'`\n# size=`blockdev --getsz /dev/hdaN`\n# disksize=`blockdev --getsz /dev/hda`\n# echo \"0 1 linear $loop 0\n1 $((start-1)) zero\n$start $size linear /dev/hdaN 0\n$((start+size)) $((disksize-start-size)) zero\" | dmsetup create qemu\n```\n\nLa table fournie en entrée standard à dmsetup a un format similaire à celui de la table d'un fichier descripteur VMDK produit par VBoxManage et peut également être chargée à partir d'un fichier avec dmsetup create qemu --table table_file. Pour la machine virtuelle, seul /dev/hdaN est accessible, tandis que le reste du disque dur est lu comme des zéros et rejette les données écrites, sauf pour le premier secteur. Nous pouvons imprimer la table pour /dev/mapper/qemu avec dmsetup table qemu. (utilisez udevadm info -rq name /sys/dev/block/major:minor pour traduire major:minor au nom correspondant /dev/blockdevice). Utilisez dmsetup remove qemu et losetup -d $loop pour supprimer les périphériques créés.\n\nUne situation où cet exemple serait utile est une installation existante de Windows XP dans une configuration multi-boot et peut-être un schéma de partitionnement hybride (sur le matériel physique, Windows XP pourrait être le seul système d'exploitation qui utilise la table de partition MBR, tandis que des systèmes d'exploitation plus modernes installés sur le même ordinateur pourraient utiliser la table de partition GUID). Windows XP prend en charge les profils matériels, de sorte que la même installation peut être utilisée alternativement avec différentes configurations matérielles (dans ce cas, bare metal et virtuel), Windows n'ayant besoin d'installer les pilotes pour le matériel nouvellement détecté qu'une seule fois pour chaque profil. Notez que dans cet exemple, le code du chargeur d'amorçage dans le MBR copié doit être mis à jour pour charger directement Windows XP à partir de /dev/hdaN au lieu d'essayer de lancer le chargeur d'amorçage multi-boot (comme GRUB) présent dans le système d'origine. Alternativement, une copie de la partition de démarrage contenant l'installation du chargeur d'amorçage peut être incluse dans le disque virtuel de la même manière que le MBR.\n\nVous pouvez également le faire en utilisant un RAID logiciel en mode linéaire (vous avez besoin du pilote du noyau linear.ko) et d'un périphérique de bouclage :\n\nD'abord, vous créez un petit fichier pour contenir le MBR :\n\n```\n$ dd if=/dev/zero of=/path/to/mbr count=32\n```\n\nIci, un fichier de 16 Kio (32 * 512 octets) est créé. Il est important de ne pas le rendre trop petit (même si le MBR n'a besoin que d'un seul bloc de 512 octets), car plus il sera petit, plus la taille des morceaux du dispositif RAID logiciel devra être petite, ce qui pourrait avoir un impact sur les performances. Ensuite, vous configurez un périphérique de bouclage vers le fichier MBR :\n\n```\n# losetup -f /path/to/mbr.\n```\n\nSupposons que le périphérique résultant soit /dev/loop0, car nous n'aurions pas déjà utilisé d'autres boucles. L'étape suivante consiste à créer l'image disque MBR + /dev/hdaN \"fusionnée\" en utilisant le RAID logiciel :\n\n```\n# modprobe linear\n# mdadm --build --verbose /dev/md0 --chunk=16 --level=linear --raid-devices=2 /dev/loop0 /dev/hdaN'\n```\n\nLe résultat /dev/md0 est ce que vous utiliserez comme image disque brute QEMU (n'oubliez pas de définir les permissions pour que l'émulateur puisse y accéder). La dernière étape (et quelque peu délicate) consiste à définir la configuration du disque (géométrie du disque et table des partitions) de sorte que le point de départ de la partition primaire dans le MBR corresponde à celui de /dev/hdaN à l'intérieur de /dev/md0. (un décalage d'exactement 16 * 512 = 16384 octets dans cet exemple). Faites ceci en utilisant fdisk sur la machine hôte, pas dans l'émulateur : la routine de détection de disque brut par défaut de QEMU résulte souvent en des décalages non arrondissables en kilooctets (comme 31,5 Kio, comme dans la section précédente) qui ne peuvent pas être gérés par le code RAID logiciel. Par conséquent, depuis l'hôte :\n\n```\n# fdisk /dev/md0\n```\n\nAppuyez sur X pour accéder au menu expert. Définissez le nombre de secteurs par piste de sorte que la taille d'un cylindre corresponde à la taille de votre fichier MBR. Pour deux têtes et une taille de secteur de 512, le nombre de secteurs par piste doit être de 16, ce qui donne des cylindres de taille 2x16x512=16k.\n\nMaintenant, appuyez sur R pour revenir au menu principal.\n\nAppuyez sur P et vérifiez que la taille du cylindre est maintenant de 16k.\n\nMaintenant, créez une partition primaire unique correspondant à /dev/hdaN. Elle doit commencer au cylindre 2 et se terminer à la fin du disque (notez que le nombre de cylindres diffère maintenant de ce qu'il était lorsque vous avez entré fdisk.\n\nEnfin, écrivez le résultat dans le fichier : vous avez terminé. Vous avez maintenant une partition que vous pouvez monter directement depuis votre hôte, ainsi qu'une partie d'une image disque QEMU :\n\n```\n$ qemu-system-x86_64 -hdc /dev/md0 [...]'.\n```\n\nVous pouvez, bien sûr, installer en toute sécurité n'importe quel chargeur d'amorçage sur cette image disque à l'aide de QEMU, à condition que la partition originale /dev/hdaN contienne les outils nécessaires.\n\nAvec Network Block Device, Linux peut utiliser un serveur distant comme l'un de ses périphériques de bloc. Vous pouvez utiliser nbd-server (du paquet nbd) pour créer une enveloppe MBR pour QEMU.\n\nEn supposant que vous avez déjà configuré votre fichier de wrapper MBR comme ci-dessus, renommez-le en wrapper.img.0. Créez ensuite un lien symbolique nommé wrapper.img.1 dans le même répertoire, pointant vers votre partition. Ensuite, mettez le script suivant dans le même répertoire :\n\n```\n#!/bin/sh\ndir=\"$(realpath \"$(dirname \"$0\")\")\"\ncat >wrapper.conf <<EOF\n[generic]\nallowlist = true\nlistenaddr = 127.713705\nport = 10809\n\n[wrap]\nexportname = $dir/wrapper.img\nmultifile = true\nEOF\n\nnbd-server \\\n    -C wrapper.conf \\\n    -p wrapper.pid \\\n    \"$@\"\n```\n\nLes suffixes .0 et .1 sont essentiels ; le reste peut être modifié. Après avoir exécuté le script ci-dessus (que vous devrez peut-être faire en tant que root pour vous assurer que nbd-server est capable d'accéder à la partition), vous pouvez lancer QEMU avec :\n\n```\nqemu-system-x86_64 -drive file=nbd:127.713705:10809:exportname=wrap [...]\".\n```\n\n"
    },
    {
      "title": "Utilisation d'un périphérique de disque physique entier à l'intérieur de la VM",
      "level": 3,
      "content": "Vous pouvez avoir un deuxième disque dur avec un système d'exploitation différent (comme Windows) et vous voulez avoir la possibilité de le démarrer dans une VM. Comme l'accès au disque est brut, le disque fonctionnera très bien à l'intérieur de la VM.\n\n"
    },
    {
      "title": "prérequis pour le démarrage de la VM Windows",
      "level": 4,
      "content": "Assurez-vous d'installer les drivers virtio dans le système d'exploitation sur ce disque avant d'essayer de le démarrer dans la VM. Pour Win 7, utilisez la version 0.1.173-4. Certains pilotes singuliers de versions plus récentes de virtio peuvent être utilisés sur Win 7 mais vous devrez les installer manuellement via le gestionnaire de périphériques. Pour Win 10, vous pouvez utiliser la dernière version de virtio.\n\nIl se peut que vous obteniez un écran bleu 0x0000007B lorsque vous essayez de démarrer la VM. Cela signifie que Windows ne peut pas accéder au lecteur pendant la phase de démarrage précoce parce que le pilote d'interface de disque dont il aurait besoin pour cela n'est pas chargé / est configuré pour démarrer manuellement.\n\nLa solution consiste à activer ces pilotes pour qu'ils démarrent au démarrage.\n\nDans HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Services, trouvez les dossiers aliide, amdide, atapi, cmdide, iastor (peut ne pas exister), iastorV, intelide, LSI_SAS, msahci, pciide et viaide. Dans chacun d'entre eux, définissez toutes les valeurs de \"start\" à 0 afin de les activer au démarrage. Si votre disque est un disque PCIe NVMe, activez également ce pilote (s'il existe).\n\n"
    },
    {
      "title": "trouver le chemin unique de votre disque",
      "level": 4,
      "content": "Exécutez ls /dev/disk/by-id/. Là, vous choisissez l'ID du disque que vous voulez insérer dans la VM, mon ID de disque est ata-TS512GMTS930L_C199211383. Ajoutez maintenant cet ID à /dev/disk/by-id/ pour obtenir /dev/disk/by-id/ata-TS512GMTS930L_C199211383. C'est le chemin unique vers ce disque.\n\n"
    },
    {
      "title": "ajouter le disque dans la CLI QEMU",
      "level": 4,
      "content": "Dans la CLI de QEMU, ce serait probablement :\n\n-drive file=/dev/disk/by-id/ata-TS512GMTS930L_C199211383,format=raw,media=disk\n\nModifiez simplement \"file=\" pour qu'il soit le chemin unique de votre disque.\n\n"
    },
    {
      "title": "ajouter le disque dans libvirt",
      "level": 4,
      "content": "Dans le xml de libvirt, cela se traduit par\n\n```\n$ virsh edit vmname\n```\n\n```\n...\n    <disk type=\"block\" device=\"disk\">\n      <driver name=\"qemu\" type=\"raw\" cache=\"none\" io=\"native\"/>\n      <source dev=\"/dev/disk/by-id/ata-TS512GMTS930L_C199211383\"/>\n      <target dev=\"sda\" bus=\"sata\"/>\n      <address type=\"drive\" controller=\"0\" bus=\"0\" target=\"0\" unit=\"0\"/>\n    </disk>\n...\n```\n\nModifiez simplement \"source dev\" pour qu'il soit le chemin unique de votre disque.\n\n"
    },
    {
      "title": "ajouter le disque dans virt-manager",
      "level": 4,
      "content": "Lorsque vous créez une VM, sélectionnez \"import existing drive\" et collez simplement ce chemin unique. Si vous avez déjà la VM, ajoutez un périphérique, un stockage, puis sélectionnez ou créez un stockage personnalisé. Collez ensuite le chemin d'accès unique.\n\n"
    },
    {
      "title": "Mise en réseau",
      "level": 2,
      "content": "Les performances de la mise en réseau virtuelle devraient être meilleures avec les périphériques tap et les ponts qu'avec la mise en réseau en mode utilisateur ou vde car les périphériques tap et les ponts sont implémentés dans le noyau.\n\nEn outre, les performances de mise en réseau peuvent être améliorées en assignant aux machines virtuelles un périphérique réseau virtio plutôt que l'émulation par défaut d'une carte réseau e1000. Consultez #Installation des pilotes virtio pour plus d'informations.\n\n"
    },
    {
      "title": "Mise en garde concernant l'adresse au niveau du lien",
      "level": 3,
      "content": "En donnant l'argument -net nic à QEMU, celui-ci attribuera, par défaut, à une machine virtuelle une interface réseau avec l'adresse de niveau lien 52:54:00:12:34:56. Cependant, lors de l'utilisation d'une mise en réseau pontée avec plusieurs machines virtuelles, il est essentiel que chaque machine virtuelle ait une adresse unique de niveau lien (MAC) du côté de la machine virtuelle du périphérique de connexion. Sinon, le pont ne fonctionnera pas correctement, car il recevra des paquets de plusieurs sources ayant la même adresse de niveau de liaison. Ce problème se produit même si les périphériques de dérivation eux-mêmes ont des adresses de niveau de lien uniques car l'adresse de niveau de lien source n'est pas réécrite lorsque les paquets passent par le périphérique de dérivation.\n\nAssurez-vous que chaque machine virtuelle possède une adresse de niveau lien unique, mais elle doit toujours commencer par 52:54:. Utilisez l'option suivante, remplacez X par un chiffre hexadécimal arbitraire :\n\n```\n$ qemu-system-x86_64 -net nic,macaddr=52:54:XX:XX:XX:XX -net vde disk_image -net vde disk_image.\n```\n\nLa génération d'adresses uniques au niveau des liens peut se faire de plusieurs manières :\n\n- Spécifier manuellement une adresse unique de niveau lien pour chaque NIC. L'avantage est que le serveur DHCP attribuera la même adresse IP à chaque fois que la machine virtuelle est exécutée, mais cette méthode est inutilisable pour un grand nombre de machines virtuelles.\n- Générer une adresse aléatoire au niveau du lien à chaque fois que la machine virtuelle est exécutée. La probabilité de collisions est pratiquement nulle, mais l'inconvénient est que le serveur DHCP attribuera une adresse IP différente à chaque fois. Vous pouvez utiliser la commande suivante dans un script pour générer une adresse de niveau lien aléatoire dans une variable macaddr :\n\n```\nprintf -v macaddr \"52:54:%02x:%02x:%02x:%02x\" $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff ))\nqemu-system-x86_64 -net nic,macaddr=\"$macaddr\" -net vde disk_image\n```\n\n- Utilisez le script suivant qemu-mac-hasher.py pour générer l'adresse de niveau lien à partir du nom de la machine virtuelle en utilisant une fonction de hachage. Étant donné que les noms des machines virtuelles sont uniques, cette méthode combine les avantages des méthodes susmentionnées : elle génère la même adresse de niveau lien à chaque exécution du script, tout en préservant la probabilité pratiquement nulle de collisions.\n\n```\nqemu-mac-hasher.py\n```\n\n```\n#!/usr/bin/env python\n# utilisation : qemu-mac-hasher.py <VMName>\n\nimport sys\nimport zlib\n\ncrc = str(hex(zlib.crc32(sys.argv[1].encode(\"utf-8\")))).replace(\"x\", \"\")[-8 :]\nprint(\"52:54:%s%s:%s%s:%s%s:%s%s\" % tuple(crc))\n```\n\nDans un script, vous pouvez utiliser par exemple :\n\n```\nvm_name=\"Nom de la VM\"\nqemu-system-x86_64 -name $vm_name -net nic,macaddr=$(qemu-mac-hasher.py $vm_name) -net vde disk_image\n```\n\n"
    },
    {
      "title": "Mise en réseau en mode utilisateur",
      "level": 3,
      "content": "Par défaut, sans aucun argument -netdev, QEMU utilisera un réseau en mode utilisateur avec un serveur DHCP intégré. Vos machines virtuelles se verront attribuer une adresse IP lorsqu'elles exécuteront leur client DHCP, et elles pourront accéder au réseau de l'hôte physique grâce au masquage d'IP effectué par QEMU.\n\nCette configuration par défaut permet à vos machines virtuelles d'accéder facilement à Internet, à condition que l'hôte y soit connecté, mais les machines virtuelles ne seront pas directement visibles sur le réseau externe, et les machines virtuelles ne pourront pas parler entre elles si vous en démarrez plusieurs simultanément.\n\nLa mise en réseau en mode utilisateur de QEMU peut offrir plus de possibilités, comme des serveurs TFTP ou SMB intégrés, la redirection des ports de l'hôte vers l'invité (par exemple pour permettre des connexions SSH vers l'invité) ou l'attachement des invités à des VLAN afin qu'ils puissent se parler entre eux. Consultez la documentation de QEMU sur l'option -net user pour plus de détails.\n\nCependant, la mise en réseau en mode utilisateur a des limites à la fois en termes d'utilité et de performance. Les configurations de réseau plus avancées nécessitent l'utilisation de périphériques de connexion ou d'autres méthodes.\n\n"
    },
    {
      "title": "Mise en réseau avec tap pour QEMU",
      "level": 3,
      "content": "Les périphériques tap sont une fonctionnalité du noyau Linux qui vous permet de créer des interfaces réseau virtuelles qui apparaissent comme des interfaces réseau réelles. Les paquets envoyés à une interface tap sont délivrés à un programme en espace utilisateur, tel que QEMU, qui s'est lié à l'interface.\n\nQEMU peut utiliser la mise en réseau par tap pour une machine virtuelle afin que les paquets envoyés à l'interface tap soient envoyés à la machine virtuelle et apparaissent comme provenant d'une interface réseau (généralement une interface Ethernet) dans la machine virtuelle. Inversement, tout ce que la machine virtuelle envoie via son interface réseau apparaîtra sur l'interface tap.\n\nLes périphériques tap sont pris en charge par les pilotes de pontage Linux, il est donc possible de relier les périphériques tap entre eux et éventuellement avec d'autres interfaces hôtes telles que eth0. Ceci est souhaitable si vous voulez que vos machines virtuelles puissent se parler entre elles ou si vous voulez que d'autres machines sur votre LAN puissent parler aux machines virtuelles.\n\nComme indiqué dans la section sur la mise en réseau en mode utilisateur, les périphériques tap offrent des performances de mise en réseau plus élevées qu'en mode utilisateur. Si le système d'exploitation invité prend en charge le pilote réseau virtio, les performances réseau seront également considérablement améliorées. En supposant l'utilisation du périphérique tap0, que le pilote virtio est utilisé sur l'invité, et qu'aucun script n'est utilisé pour aider à démarrer/arrêter la mise en réseau, voici une partie de la commande qemu que l'on devrait consulter :\n\n```\n-device virtio-net,netdev=network0 -netdev tap,id=network0,ifname=tap0,script=no,downscript=no\n```\n\nMais si vous utilisez déjà un périphérique tap avec le pilote réseau de virtio, vous pouvez encore améliorer les performances réseau en activant vhost, comme suit :\n\n```\n-device virtio-net,netdev=network0 -netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on\n```\n\nConsultez [2] pour plus d'informations.\n\n"
    },
    {
      "title": "Mise en réseau uniquement avec l'hôte",
      "level": 4,
      "content": "Si une adresse IP est attribuée au pont et que le trafic qui lui est destiné est autorisé, mais qu'aucune interface réelle (par exemple, eth0) n'est connectée au pont, les machines virtuelles pourront communiquer entre elles et avec le système hôte. Cependant, elles ne pourront pas parler à quoi que ce soit sur le réseau externe, à condition que vous ne configuriez pas de masquage d'IP sur l'hôte physique. Cette configuration est appelée mise en réseau de l'hôte uniquement par d'autres logiciels de virtualisation tels que VirtualBox.\n\n- Si vous souhaitez configurer le masquage d'adresses IP, par exemple le NAT pour les machines virtuelles, consultez la page Internet sharing (Français)#Activer le NAT.\n- Consultez la page Network bridge pour obtenir des informations sur la création de ponts.\n- Il se peut que vous souhaitiez qu'un serveur DHCP fonctionne sur l'interface du pont pour desservir le réseau virtuel. Par exemple, pour utiliser le sous-réseau 172.20.0.1/16 avec dnsmasq comme serveur DHCP :\n\n```\n# ip addr add 172.20.0.1/16 dev br0\n# ip link set br0 up\n# dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254\n```\n\n"
    },
    {
      "title": "Réseau interne",
      "level": 4,
      "content": "Si vous ne donnez pas d'adresse IP au pont et que vous ajoutez une règle iptables pour supprimer tout le trafic vers le pont dans la chaîne INPUT, les machines virtuelles pourront communiquer entre elles, mais pas avec l'hôte physique ni avec le réseau extérieur. Cette configuration est appelée réseau interne par d'autres logiciels de virtualisation tels que VirtualBox. Vous devrez soit attribuer des adresses IP statiques aux machines virtuelles, soit exécuter un serveur DHCP sur l'une d'entre elles.\n\nPar défaut, iptables laisse tomber les paquets dans le réseau ponté. Vous devrez peut-être utiliser une telle règle iptables pour autoriser les paquets dans un réseau ponté :\n\n```\n# iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT\n```\n\n"
    },
    {
      "title": "Réseau ponté utilisant qemu-bridge-helper",
      "level": 4,
      "content": "Cette méthode ne nécessite pas de script de démarrage et s'adapte facilement à des prises multiples et à des ponts multiples. Elle utilise le binaire /usr/lib/qemu/qemu-bridge-helper, qui permet de créer des périphériques de prise sur un pont existant.\n\n- Consultez Network bridge pour des informations sur la création de ponts.\n- Consultez https://wiki.qemu.org/Features/HelperNetworking pour plus d'informations sur l'aide réseau de QEMU.\n\nTout d'abord, créez un fichier de configuration contenant les noms de tous les ponts à utiliser par QEMU :\n\n```\n/etc/qemu/bridge.conf\n```\n\n```\nallow br0 (autoriser)\nallow br1 (autoriser br1)\n...\n```\n\nAssurez-vous que /etc/qemu/ a 755 permissions. Si ce n'est pas le cas, des problèmes avec QEMU et problèmes avec GNS3 peuvent survenir.\n\nMaintenant démarrez la VM ; l'utilisation la plus basique est d'exécuter QEMU avec l'aide réseau par défaut et le pont par défaut br0 :\n\n```\n$ qemu-system-x86_64 -nic bridge [...]'.\n```\n\nEn utilisant le pont br1 et le pilote virtio :\n\n```\n$ qemu-system-x86_64 -nic bridge,br=br1,model=virtio-net-pci [...]'\n```\n\n"
    },
    {
      "title": "Créer un pont manuellement",
      "level": 4,
      "content": "Ce qui suit décrit comment établir un pont entre une machine virtuelle et une interface hôte telle que eth0, qui est probablement la configuration la plus courante. Cette configuration donne l'impression que la machine virtuelle est située directement sur le réseau externe, sur le même segment Ethernet que la machine hôte physique.\n\nNous allons remplacer l'adaptateur Ethernet normal par un adaptateur pont et lier l'adaptateur Ethernet normal à celui-ci.\n\n- Installer bridge-utils, qui fournit brctl pour manipuler les ponts.\n\n- Activez le transfert d'IPv4 :\n\n```\n# sysctl -w net.ipv4.ip_forward=1\n```\n\nPour rendre le changement permanent, changez net.ipv4.ip_forward = 0 en net.ipv4.ip_forward = 1 dans /etc/sysctl.d/99-sysctl.conf.\n\n- Chargez le module tun et configurez-le pour qu'il soit chargé au démarrage. Consultez Modules du noyau pour plus de détails.\n\n- Créez maintenant le pont. Consultez Bridge with netctl pour plus de détails. N'oubliez pas de nommer votre pont comme br0, ou changez les scripts ci-dessous avec le nom de votre pont.\n\n- Créez le script que QEMU utilise pour faire apparaître l'adaptateur de robinet avec root:kvm, permissions 750 :\n\n```\n/etc/qemu-ifup\n```\n\n```\n#!/bin/sh\n\necho \"Executing /etc/qemu-ifup\"\necho \"Bringing up $1 for bridged mode...\"\nsudo /usr/bin/ip link set $1 up promisc on\necho \"Adding $1 to br0...\"\nsudo /usr/bin/brctl addif br0 $1\nsleep 2\n```\n\n- Créez le script que QEMU utilise pour mettre hors service l'adaptateur tap dans /etc/qemu-ifdown avec root:kvm permissions 750 :\n\n```\n/etc/qemu-ifdown\n```\n\n```\n#!/bin/sh\n\necho \"Executing /etc/qemu-ifdown\"\nsudo /usr/bin/ip link set $1 down\nsudo /usr/bin/brctl delif br0 $1\nsudo /usr/bin/ip link delete dev $1\n```\n\n- Utilisez visudo pour ajouter les éléments suivants à votre fichier sudoers :\n\n```\nCmnd_Alias QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl\n%kvm ALL=NOPASSWD : QEMU\n```\n\n- Vous lancez QEMU en utilisant le script run-qemu suivant :\n\n```\nrun-qemu\n```\n\n```\n#!/bin/bash\nUSERID=$(whoami)\n\n# Obtenir le nom du périphérique TAP nouvellement créé ; consultez https://bbs.archlinux.org/viewtopic.php?pid=1285079#p1285079\nprecreationg=$(/usr/bin/ip tuntap list | /usr/bin/cut -d : -f1 | /usr/bin/sort)\nsudo /usr/bin/ip tuntap add user $USERID mode tap\npostcreation=$(/usr/bin/ip tuntap list | /usr/bin/cut -d : -f1 | /usr/bin/sort)\nIFACE=$(comm -13 <(echo \"$precreationg\") <(echo \"$postcreation\"))\n\n# Cette ligne crée une adresse MAC aléatoire. L'inconvénient est que le serveur DHCP assignera une adresse IP différente à chaque fois\nprintf -v macaddr \"52:54:%02x:%02x:%02x:%02x\" $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff ))\n# Au lieu de cela, décommentez et modifiez cette ligne pour définir une adresse MAC statique. L'avantage est que le serveur DHCP attribuera la même adresse IP.\n# macaddr='52:54:be:36:42:a9'\n\nqemu-system-x86_64 -net nic,macaddr=$macaddr -net tap,ifname=\"$IFACE\" $*\n\nsudo ip link set dev $IFACE down &> /dev/null\nsudo ip tuntap del $IFACE mode tap &> /dev/null\n```\n\nEnsuite, pour lancer une VM, faites quelque chose comme ceci\n\n```\n$ run-qemu -hda myvm.img -m 512\n```\n\n- Il est recommandé, pour des raisons de performance et de sécurité, de désactiver le pare-feu sur le pont :\n\n```\n/etc/sysctl.d/10-disable-firewall-on-bridge.conf\n```\n\n```\nnet.bridge.bridge-nf-call-ip6tables = 0\nnet.bridge.bridge-nf-call-iptables = 0\nnet.bridge.bridge-nf-call-arptables = 0\n```\n\nExécutez sysctl -p /etc/sysctl.d/10-disable-firewall-on-bridge.conf pour appliquer les modifications immédiatement.\n\nConsultez le wiki de libvirt et bug de Fedora n°512206. Si vous obtenez des erreurs par sysctl pendant le démarrage à propos de fichiers inexistants, faites en sorte que le module bridge soit chargé au démarrage. Consultez Kernel module (Français)#Chargement automatique des modules.\n\nAlternativement, vous pouvez configurer iptables pour permettre à tout le trafic d'être transféré à travers le pont en ajoutant une règle comme celle-ci :\n\n```\n-I FORWARD -m physdev --physdev-is-bridged -j ACCEPT\n```\n\n"
    },
    {
      "title": "Partage de réseau entre un périphérique physique et un périphérique Tap via iptables",
      "level": 4,
      "content": "Le réseau ponté fonctionne bien entre une interface câblée (par exemple eth0), et il est facile à configurer. Cependant, si l'hôte est connecté au réseau par un périphérique sans fil, le pontage n'est pas possible.\n\nConsultez Network bridge#Wireless interface on a bridge comme référence.\n\nUne façon de surmonter ce problème est de configurer un périphérique de connexion avec une IP statique, en faisant en sorte que linux gère automatiquement le routage pour lui, puis de transférer le trafic entre l'interface de connexion et le périphérique connecté au réseau par le biais de règles iptables.\n\nConsultez Internet sharing (Français) comme référence.\n\nVous y trouverez tout ce qui est nécessaire pour partager le réseau entre les appareils, y compris les appareils tap et tun. Ce qui suit ne fait que donner des indications supplémentaires sur certaines des configurations d'hôtes requises. Comme indiqué dans la référence ci-dessus, le client doit être configuré pour une IP statique, en utilisant l'IP assignée à l'interface tap comme passerelle. La mise en garde est que les serveurs DNS sur le client peuvent devoir être édités manuellement s'ils changent lors du passage d'un périphérique hôte connecté au réseau à un autre.\n\nPour autoriser la redirection IP à chaque démarrage, il faut ajouter les lignes suivantes au fichier de configuration sysctl dans /etc/sysctl.d :\n\n```\nnet.ipv4.ip_forward = 1\nnet.ipv6.conf.default.forwarding = 1\nnet.ipv6.conf.all.forwarding = 1\n```\n\nLes règles iptables peuvent ressembler à ceci :\n\n```\n# Transfert de/vers l'extérieur\niptables -A FORWARD -i ${INT} -o ${EXT_0} -j ACCEPT\niptables -A FORWARD -i ${INT} -o ${EXT_1} -j ACCEPT\niptables -A FORWARD -i ${INT} -o ${EXT_2} -j ACCEPT\niptables -A FORWARD -i ${EXT_0} -o ${INT} -j ACCEPT\niptables -A FORWARD -i ${EXT_1} -o ${INT} -j ACCEPT\niptables -A FORWARD -i ${EXT_2} -o ${INT} -j ACCEPT\n# NAT/Masquerade (traduction d'adresse réseau)\niptables -t nat -A POSTROUTING -o ${EXT_0} -j MASQUERADE\niptables -t nat -A POSTROUTING -o ${EXT_1} -j MASQUERADE\niptables -t nat -A POSTROUTING -o ${EXT_2} -j MASQUERADE\n```\n\nL'antérieur suppose qu'il y a 3 dispositifs connectés au réseau partageant le trafic avec un dispositif interne, où par exemple :\n\n```\nINT=tap0\nEXT_0=eth0\nEXT_1=wlan0\nEXT_2=tun0\n```\n\nL'exemple précédent montre une redirection qui permettrait de partager des connexions câblées et sans fil avec le périphérique tap.\n\nLes règles de transfert présentées sont sans état, et pour un transfert pur. On pourrait penser à restreindre un trafic spécifique, en mettant en place un pare-feu pour protéger l'invité et les autres. Cependant, ces mesures réduiraient les performances du réseau, alors qu'un simple pont n'inclut rien de tout cela.\n\nBonus : que la connexion soit filaire ou sans fil, si l'on se connecte par VPN à un site distant avec un périphérique tun, en supposant que le périphérique tun ouvert pour cette connexion est tun0, et que les règles iptables précédentes sont appliquées, alors la connexion distante est également partagée avec l'invité. Cela évite à l'invité d'avoir à ouvrir également une connexion VPN. Encore une fois, comme le réseau de l'invité doit être statique, si l'on connecte l'hôte à distance de cette façon, il faudra très probablement modifier les serveurs DNS de l'invité.\n\n"
    },
    {
      "title": "Qu'est-ce que VDE ?",
      "level": 4,
      "content": "VDE est l'abréviation de Virtual Distributed Ethernet. Il a commencé comme une amélioration de uml_switch. Il s'agit d'une boîte à outils pour gérer les réseaux virtuels.\n\nL'idée est de créer des commutateurs virtuels, qui sont en fait des prises, et d'y \"brancher\" des machines physiques et virtuelles. La configuration que nous montrons ici est assez simple ; cependant, VDE est beaucoup plus puissant que cela, il peut brancher des commutateurs virtuels ensemble, les faire fonctionner sur différents hôtes et surveiller le trafic dans les commutateurs. Vous êtes invités à lire la documentation du projet.\n\nL'avantage de cette méthode est que vous ne devez pas ajouter les privilèges sudo à vos utilisateurs. Les utilisateurs ordinaires ne doivent pas être autorisés à exécuter modprobe.\n\n"
    },
    {
      "title": "Notions de base",
      "level": 4,
      "content": "Installez le paquet vde2 si vous souhaitez la prise en charge de VDE.\n\nDans notre configuration, nous utilisons tun/tap pour créer une interface virtuelle sur mon hôte. Chargez le module tun (consultez Modules du noyau pour plus de détails) :\n\n```\n# modprobe tun\n```\n\nCréez maintenant le commutateur virtuel :\n\n```\n# vde_switch -tap tap0 -daemon -mod 660 -group users\n```\n\nCette ligne crée le commutateur, crée tap0, le \"branche\", et permet aux utilisateurs du groupe users de l'utiliser.\n\nL'interface est branchée mais pas encore configurée. Pour la configurer, exécutez cette commande :\n\n```\n# ip addr add 192.168.100.254/24 dev tap0\n```\n\nMaintenant, il vous suffit de lancer KVM avec ces options -net comme un utilisateur normal :\n\n```\n$ qemu-system-x86_64 -net nic -net vde -hda [...]'.\n```\n\nConfigurez le réseau pour votre invité comme vous le feriez dans un réseau physique.\n\n"
    },
    {
      "title": "Scripts de démarrage",
      "level": 4,
      "content": "Exemple de script principal démarrant VDE :\n\n```\n/etc/systemd/scripts/qemu-network-env\n```\n\n```\n#!/bin/sh\n# QEMU/VDE network environment preparation script\n\n# The IP configuration for the tap device that will be used for\n# the virtual machine network:\n\nTAP_DEV=tap0\nTAP_IP=192.168.100.254\nTAP_MASK=24\nTAP_NETWORK=192.168.100.0\n\n# Host interface\nNIC=eth0\n\ncase \"$1\" in\n  start)\n        echo -n \"Starting VDE network for QEMU: \"\n\n        # If you want tun kernel module to be loaded by script uncomment here\n\t#modprobe tun 2>/dev/null\n\t## Wait for the module to be loaded\n \t#while ! lsmod | grep -q \"^tun\"; do echo \"Waiting for tun device\"; sleep 1; done\n\n        # Start tap switch\n        vde_switch -tap \"$TAP_DEV\" -daemon -mod 660 -group users\n\n        # Bring tap interface up\n        ip address add \"$TAP_IP\"/\"$TAP_MASK\" dev \"$TAP_DEV\"\n        ip link set \"$TAP_DEV\" up\n\n        # Start IP Forwarding\n        echo \"1\" > /proc/sys/net/ipv4/ip_forward\n        iptables -t nat -A POSTROUTING -s \"$TAP_NETWORK\"/\"$TAP_MASK\" -o \"$NIC\" -j MASQUERADE\n        ;;\n  stop)\n        echo -n \"Stopping VDE network for QEMU: \"\n        # Delete the NAT rules\n        iptables -t nat -D POSTROUTING -s \"$TAP_NETWORK\"/\"$TAP_MASK\" -o \"$NIC\" -j MASQUERADE\n\n        # Bring tap interface down\n        ip link set \"$TAP_DEV\" down\n\n        # Kill VDE switch\n        pgrep vde_switch | xargs kill -TERM\n        ;;\n  restart|reload)\n        $0 stop\n        sleep 1\n        $0 start\n        ;;\n  *)\n        echo \"Usage: $0 {start|stop|restart|reload}\"\n        exit 1\nesac\nexit 0\n```\n\nExemple de service systemd utilisant le script ci-dessus :\n\n```\n/etc/systemd/system/qemu-network-env.service\n```\n\n```\n[Unit]\nDescription=Manage VDE Switch\n\n[Service]\nType=oneshot\nExecStart=/etc/systemd/scripts/qemu-network-env start\nExecStop=/etc/systemd/scripts/qemu-network-env stop\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n\nChangez les permissions pour que qemu-network-env soit exécutable.\n\nDémarrez qemu-network-env.service comme d'habitude.\n\n"
    },
    {
      "title": "Méthode alternative",
      "level": 4,
      "content": "Si la méthode ci-dessus ne fonctionne pas ou si vous ne voulez pas vous embêter avec les configurations du noyau, TUN, dnsmasq, et iptables, vous pouvez faire ce qui suit pour le même résultat.\n\n```\n# vde_switch -daemon -mod 660 -group users\n# slirpvde --dhcp --daemon\n```\n\nEnsuite, pour démarrer la VM avec une connexion au réseau de l'hôte :\n\n```\n$ qemu-system-x86_64 -net nic,macaddr=52:54:00:00:EE:03 -net vde disk_image\n```\n\n"
    },
    {
      "title": "Pont VDE2",
      "level": 3,
      "content": "Basé sur le graphique tutoriel rapide : mise en réseau de qemu avec vde, tun/tap, et pont. Toute machine virtuelle connectée à vde est exposée à l'extérieur. Par exemple, chaque machine virtuelle peut recevoir une configuration DHCP directement de votre routeur ADSL.\n\n"
    },
    {
      "title": "Notions de base",
      "level": 4,
      "content": "Rappelez-vous que vous avez besoin du module tun et du paquet bridge-utils.\n\nCréez le périphérique vde2/tap :\n\n```\n# vde_switch -tap tap0 -daemon -mod 660 -group users\n# ip link set tap0 up\n```\n\nCréez un pont :\n\n```\n# brctl addbr br0\n```\n\nAjouter des périphériques :\n\n```\n# brctl addif br0 eth0\n# brctl addif br0 tap0\n```\n\nEt configurez l'interface du pont :\n\n```\n# dhcpcd br0\n```\n\n"
    },
    {
      "title": "Scripts de démarrage",
      "level": 4,
      "content": "Tous les périphériques doivent être configurés. Et seul le pont a besoin d'une adresse IP. Pour les périphériques physiques sur le pont (par exemple eth0), cela peut être fait avec netctl en utilisant un profil Ethernet personnalisé avec :\n\n```\n/etc/netctl/ethernet-noip\n```\n\n```\nDescription='A more versatile static Ethernet connection'\nInterface=eth0\nConnection=ethernet\nIP=no\n```\n\nLe service systemd personnalisé suivant peut être utilisé pour créer et activer une interface de connexion VDE2 pour les utilisateurs du groupe users.\n\n```\n/etc/systemd/system/vde2@.service\n```\n\n```\n[Unit]\nDescription=Network Connectivity for %i\nWants=network.target\nBefore=network.target\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=/usr/bin/vde_switch -tap %i -daemon -mod 660 -group users\nExecStart=/usr/bin/ip link set dev %i up\nExecStop=/usr/bin/ip addr flush dev %i\nExecStop=/usr/bin/ip link set dev %i down\n\n[Install]\nWantedBy=multi-user.target\n```\n\nEt enfin, vous pouvez créer l'interface bridge avec netctl.\n\n"
    },
    {
      "title": "Configuration abrégée",
      "level": 3,
      "content": "Si vous utilisez souvent QEMU avec diverses options de réseau, vous avez probablement créé beaucoup de paires d'arguments -netdev et -device, ce qui devient assez répétitif. Vous pouvez plutôt utiliser l'argument -nic pour combiner -netdev et -device ensemble, de sorte que, par exemple, ces arguments :\n\n```\n-netdev tap,id=network0,ifname=tap0,script=no,downscript=no,vhost=on -device virtio-net-pci,netdev=network0\n```\n\ndevient :\n\n```\n-nic tap,script=no,downscript=no,vhost=on,model=virtio-net-pci\n```\n\nRemarquez l'absence d'ID de réseau, et que le périphérique a été créé avec model=. La première moitié des paramètres -nic sont des paramètres -netdev, tandis que la seconde moitié (après model=) est liée au périphérique. Les mêmes paramètres (par exemple, smb=) sont utilisés. Pour désactiver complètement la mise en réseau, utilisez -nic none.\n\nConsultez documentation sur la mise en réseau de QEMU pour plus d'informations sur les paramètres que vous pouvez utiliser.\n\n"
    },
    {
      "title": "Carte graphique",
      "level": 2,
      "content": "QEMU peut émuler le mode texte d'une carte graphique standard en utilisant l'option de ligne de commande -curses. Cela permet de taper du texte et de consulter la sortie texte directement dans un terminal texte. Alternativement, -nographic sert un but similaire.\n\nQEMU peut émuler plusieurs types de cartes VGA. Le type de carte est passé dans l'option de ligne de commande -vga type et peut être std, qxl, vmware, virtio, cirrus ou none.\n\n"
    },
    {
      "title": "std",
      "level": 3,
      "content": "Avec -vga std, vous pouvez obtenir une résolution allant jusqu'à 2560 x 1600 pixels sans avoir besoin de pilotes invités. C'est la valeur par défaut depuis QEMU 2.2.\n\n"
    },
    {
      "title": "qxl",
      "level": 3,
      "content": "QXL est un pilote graphique paravirtuel avec un support 2D. Pour l'utiliser, passez l'option -vga qxl et installez les pilotes dans l'invité. Vous pouvez utiliser #SPICE pour améliorer les performances graphiques en utilisant QXL.\n\nSur les invités Linux, les modules noyau qxl et bochs_drm doivent être chargés afin d'obtenir des performances décentes.\n\nLa taille par défaut de la mémoire VGA pour les périphériques QXL est de 16M, ce qui est suffisant pour gérer des résolutions allant jusqu'à QHD (2560x1440). Pour permettre des résolutions plus élevées, increase vga_memmb.\n\n"
    },
    {
      "title": "vmware",
      "level": 3,
      "content": "Bien qu'il soit un peu bogué, il est plus performant que std et cirrus. Installez les pilotes VMware xf86-video-vmware et xf86-input-vmmouse pour les invités Arch Linux.\n\n"
    },
    {
      "title": "virtio",
      "level": 3,
      "content": "virtio-vga / virtio-gpu est un pilote graphique 3D paravirtuel basé sur virgl. Actuellement en cours de développement, il ne prend en charge que les hôtes Linux très récents (>= 4.4) avec mesa. (>=11.2) compilé avec l'option gallium-drivers=virgl.\n\nPour activer l'accélération 3D sur le système invité, sélectionnez ce vga avec -device virtio-vga-gl et activez le contexte opengl dans le périphérique d'affichage avec -display sdl,gl=on ou -display gtk,gl=on pour les sorties d'affichage sdl et gtk respectivement. Une configuration réussie peut être confirmée en regardant le journal du noyau dans l'invité :\n\n```\n# dmesg | grep drm\n```\n\n```\n[drm] pci : virtio-vga détecté\n[drm] accélération 3d virgl activée\n```\n\n"
    },
    {
      "title": "cirrus",
      "level": 3,
      "content": "L'adaptateur graphique cirrus était l'adaptateur par défaut avant 2.2. Il ne devrait pas être utilisé sur les systèmes modernes.\n\n"
    },
    {
      "title": "none",
      "level": 3,
      "content": "C'est comme un PC qui n'a pas de carte VGA du tout. Vous ne pourriez même pas y accéder avec l'option -vnc. En outre, ceci est différent de l'option -nographic qui permet à QEMU d'émuler une carte VGA, mais désactive l'affichage SDL.\n\n"
    },
    {
      "title": "SPICE",
      "level": 2,
      "content": "Le SPICE project vise à fournir une solution open source complète pour l'accès à distance aux machines virtuelles de manière transparente.\n\n"
    },
    {
      "title": "Activation du support SPICE sur l'hôte",
      "level": 3,
      "content": "Voici un exemple de démarrage avec SPICE comme protocole de bureau à distance, y compris la prise en charge du copier-coller depuis l'hôte :\n\n```\n$ qemu-system-x86_64 -vga qxl -device virtio-serial-pci -spice port=5930,disable-ticketing=on -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent\n```\n\nLes paramètres ont la signification suivante :\n\n1. -device virtio-serial-pci ajoute un périphérique virtio-serial\n1. -spice port=5930,disable-ticketing=on définit le port TCP 5930 pour l'écoute des canaux spice et permet au client de se connecter sans authentificationAstuce: L'utilisation de Unix sockets au lieu des ports TCP n'implique pas l'utilisation de la pile réseau sur le système hôte. Elle n'implique pas que les paquets soient encapsulés et décapsulés pour utiliser le réseau et le protocole correspondant. Les sockets sont identifiés uniquement par les inodes du disque dur. Il est donc considéré comme meilleur pour les performances. Utilisez plutôt -spice unix=on,addr=/tmp/vm_spice.socket,disable-ticketing=on.\n1. -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 ouvre un port pour spice vdagent dans le périphérique virtio-serial,\n1. -chardev spicevmc,id=spicechannel0,name=vdagent ajoute une chardev spicevmc pour ce port. Il est important que l'option chardev= du dispositif virtserialport corresponde à l'option id= donnée à l'option chardev (spicechannel0 dans cet exemple). Il est également important que le nom du port soit com.redhat.spice.0, car c'est l'espace de nom que vdagent recherche dans l'invité. Et enfin, spécifiez name=vdagent pour que spice sache à quoi sert ce canal.\n\n"
    },
    {
      "title": "Se connecter à l'invité avec un client SPICE",
      "level": 3,
      "content": "Un client SPICE est nécessaire pour se connecter à l'invité. Dans Arch, les clients suivants sont disponibles :\n\nvirt-viewer — client SPICE recommandé par les développeurs du protocole, un sous-ensemble du projet virt-manager.\n\nspice-gtk — Client SPICE GTK, un sous-ensemble du projet SPICE. Intégré dans d'autres applications en tant que widget.\n\nPour les clients fonctionnant sur smartphone ou sur d'autres plateformes, reportez-vous à la section Autres clients de spice-space download.\n\n"
    },
    {
      "title": "Exécution manuelle d'un client SPICE",
      "level": 4,
      "content": "Une façon de se connecter à un invité écoutant sur le socket Unix /tmp/vm_spice.socket est d'exécuter manuellement le client SPICE en utilisant $ remote-viewer spice+unix:///tmp/vm_spice.socket ou $ spicy --uri=\"spice+unix:///tmp/vm_spice.socket\", selon le client souhaité. Comme QEMU en mode SPICE agit de la même manière qu'un serveur de bureau à distance, il peut être plus pratique d'exécuter QEMU en mode daemon avec le paramètre -daemonize.\n\nNote: Cet exemple connecte spicy au port local 5999 qui est transféré par SSH au serveur SPICE de l'invité situé à l'adresse my.domain.org, port 5930. Notez l'option -f qui demande à ssh d'exécuter la commande sleep 10 en arrière-plan. De cette façon, la session ssh s'exécute tant que le client est actif et se ferme automatiquement lorsque le client se termine.\n\n```\n$ ssh -fL 5999:localhost:5930 my.domain.org sleep 10 ; spicy -h 127.0.0.1 -p 5999\n```\n\nCet exemple connecte spicy au port local 5999 qui est transféré par SSH au serveur SPICE de l'invité situé à l'adresse my.domain.org, port 5930. Notez l'option -f qui demande à ssh d'exécuter la commande sleep 10 en arrière-plan. De cette façon, la session ssh s'exécute tant que le client est actif et se ferme automatiquement lorsque le client se termine.\n\n"
    },
    {
      "title": "Exécuter un client SPICE avec QEMU",
      "level": 4,
      "content": "QEMU peut automatiquement démarrer un client SPICE avec un socket approprié, si l'affichage est défini sur SPICE avec le paramètre -display spice-app. Cela utilisera le client SPICE par défaut du système comme visualisateur, déterminé par vos fichiers mimeapps.list.\n\n"
    },
    {
      "title": "Activation du support SPICE sur l'invité",
      "level": 3,
      "content": "Pour les invités Arch Linux, pour une meilleure prise en charge de plusieurs moniteurs ou du partage du presse-papiers, les paquets suivants doivent être installés :\n\n- spice-vdagent : Agent Spice client xorg qui permet le copier/coller entre le client et la session X et plus encore.\n- xf86-video-qxl : Pilote vidéo Xorg X11 qxl\n\nPour les invités sous d'autres systèmes d'exploitation, référez-vous à la section Invité dans téléchargement de spice-space.\n\n"
    },
    {
      "title": "Authentification par mot de passe avec SPICE",
      "level": 3,
      "content": "Si vous voulez activer l'authentification par mot de passe avec SPICE, vous devez supprimer disable-ticketing de l'argument -spice et ajouter à la place password=yourpassword. Par exemple :\n\n```\n$ qemu-system-x86_64 -vga qxl -spice port=5900,password=yourpassword -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent\n```\n\nVotre client SPICE devrait maintenant demander le mot de passe pour pouvoir se connecter au serveur SPICE.\n\n"
    },
    {
      "title": "Communication chiffrée TLS avec SPICE",
      "level": 3,
      "content": "Vous pouvez également configurer le chiffrement TLS pour communiquer avec le serveur SPICE. Tout d'abord, vous devez avoir un répertoire qui contient les fichiers suivants (les noms doivent être exactement comme indiqués) :\n\n- ca-cert.pem : le certificat maître de l'AC.\n- server-cert.pem : le certificat du serveur signé avec ca-cert.pem.\n- server-key.pem : la clé privée du serveur.\n\nUn exemple de génération de certificats auto-signés avec votre propre CA pour votre serveur est montré dans le Manuel de l'utilisateur de Spice.\n\nEnsuite, vous pouvez exécuter QEMU avec SPICE comme expliqué ci-dessus mais en utilisant l'argument -spice suivant : -spice tls-port=5901,password=yourpassword,x509-dir=/path/to/pki_certs, où /path/to/pki_certs est le chemin du répertoire qui contient les trois fichiers nécessaires montrés précédemment.\n\nIl est maintenant possible de se connecter au serveur en utilisant virt-viewer :\n\n```\n$ remote-viewer spice://hostname?tls-port=5901 --spice-ca-file=/path/to/ca-cert.pem --spice-host-subject=\"C=XX,L=city,O=organization,CN=hostname\" --spice-secure-channels=all\n```\n\nN'oubliez pas que le paramètre --spice-host-subject doit être défini en fonction de votre sujet server-cert.pem. Vous devez également copier ca-cert.pem sur chaque client pour vérifier le certificat du serveur.\n\n```\n$ openssl x509 -noout -subject -in server-cert.pem | cut -d' ' -f2- | sed 's/\\///' | sed 's/\\/,/g'\n```\n\nLa commande équivalente spice-gtk est :\n\n```\n$ spicy -h hostname -s 5901 --spice-ca-file=ca-cert.pem --spice-host-subject=\"C=XX,L=city,O=organization,CN=hostname\" --spice-secure-channels=all\n```\n\n"
    },
    {
      "title": "VNC",
      "level": 2,
      "content": "On peut ajouter l'option -vnc :X pour que QEMU redirige l'écran VGA vers la session VNC. Remplacez X par le numéro de l'écran (0 écoutera alors sur 5900, 1 sur 5901...).\n\n```\n$ qemu-system-x86_64 -vnc :0\n```\n\nUn exemple est également fourni dans la section #Démarrer des machines virtuelles QEMU au démarrage.\n\n"
    },
    {
      "title": "Authentification par mot de passe de base",
      "level": 3,
      "content": "Un mot de passe d'accès peut être configuré facilement en utilisant l'option password. Le mot de passe doit être indiqué dans le moniteur QEMU et la connexion n'est possible que lorsque le mot de passe est fourni.\n\n```\n$ qemu-system-x86_64 -vnc :0,password -monitor stdio\n```\n\nDans le moniteur QEMU, le mot de passe est défini en utilisant la commande change vnc password et en indiquant ensuite le mot de passe.\n\nLa ligne de commande suivante lance directement vnc avec un mot de passe :\n\n```\n$ printf \"change vnc password\\n%s\\n\" MYPASSWORD | qemu-system-x86_64 -vnc :0,password -monitor stdio\n```\n\n"
    },
    {
      "title": "Créer un backend audio",
      "level": 3,
      "content": "L'option -audiodev définit le pilote dubackend audio et ses options. La liste des pilotes audio disponibles et leurs paramètres optionnels est détaillée dans la page de manuel de qemu(1).\n\nAu minimum, vous devez choisir un backend et définir un id, pour PulseAudio par exemple :\n\n```\n-audiodev pa,id=snd0\n```\n\n"
    },
    {
      "title": "Utiliser le backend audio",
      "level": 3,
      "content": "Pour l'émulation Intel HD Audio, ajoutez les périphériques contrôleur et codec. Pour lister les périphériques audio Intel HDA disponibles :\n\n```\n$ qemu-system-x86_64 -device help | grep hda\n```\n\nAjoutez le contrôleur audio:\n\n```\n-device ich9-intel-hda\n```\n\nAjoutez également le codec audio et mappez-le à un id de backend audio hôte:\n\n```\n-device hda-output,audiodev=snd0\n```\n\nPour l'émulation AC97, il suffit d'ajouter le périphérique de la carte audio et de l'associer à un identifiant de backend audio hôte.\n\n```\n-périphérique AC97, audiodev=snd0\n```\n\n- Si le backend audiodev n'est pas fourni, QEMU le recherche et l'ajoute automatiquement, cela ne fonctionne que pour un seul audiodev. Par exemple, -device intel-hda -device hda-duplex émulera intel-hda sur l'invité en utilisant le backend audiodev par défaut.\n- Les pilotes émulés de carte graphique vidéo pour la machine invitée peuvent également causer un problème de qualité sonore. Testez-les un par un pour qu'ils fonctionnent. Vous pouvez lister les options possibles avec qemu-system-x86_64 -h | grep vga.\n\n"
    },
    {
      "title": "Installation des pilotes virtio",
      "level": 2,
      "content": "QEMU offre aux invités la possibilité d'utiliser des périphériques bloc et réseau paravirtualisés à l'aide des pilotes virtio, qui offrent de meilleures performances et une plus faible surcharge.\n\n- Un périphérique de type bloc virtio nécessite l'option -drive pour passer une image disque, avec le paramètre if=virtio :\n\n```\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio\n```\n\n- Il en va presque de même pour le réseau :\n\n```\n$ qemu-system-x86_64 -nic user,model=virtio-net-pci'\n```\n\n"
    },
    {
      "title": "Préparer un invité Arch Linux",
      "level": 3,
      "content": "Pour utiliser les périphériques virtio après l'installation d'un invité Arch Linux, les modules suivants doivent être chargés dans l'invité : virtio, virtio_pci, virtio_blk, virtio_net, et virtio_ring. Pour les invités 32 bits, le module spécifique \"virtio\" n'est pas nécessaire.\n\nSi vous voulez démarrer à partir d'un disque virtio, le ramdisk initial doit contenir les modules nécessaires. Par défaut, ceci est géré par le hook autodetect de mkinitcpio. Sinon, utilisez le tableau MODULES dans /etc/mkinitcpio.conf pour inclure les modules nécessaires et reconstruire le ramdisk initial.\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nMODULES=(virtio virtio_blk virtio_pci virtio_net)\n```\n\nLes disques Virtio sont reconnus avec le préfixe v (par exemple, vda, vdb, etc.) ; par conséquent, des modifications doivent être apportées au moins dans /etc/fstab et /boot/grub/grub.cfg lors du démarrage à partir d'un disque virtio.\n\nVous trouverez de plus amples informations sur la paravirtualisation avec KVM ici.\n\nVous pouvez également installer qemu-guest-agent pour implémenter la prise en charge des commandes QMP qui amélioreront les capacités de gestion de l'hyperviseur. Après avoir installé le paquet, vous pouvez activer et démarrer le qemu-guest-agent.service.\n\n"
    },
    {
      "title": "Pilotes Virtio pour Windows",
      "level": 4,
      "content": "Windows n'est pas livré avec les pilotes virtio. Les dernières versions stables des pilotes sont régulièrement construites par Fedora, les détails sur le téléchargement des pilotes sont donnés sur virtio-win on GitHub. Dans les sections suivantes, nous utiliserons principalement le fichier ISO stable fourni ici : virtio-win.iso. Vous pouvez également utiliser virtio-winAUR.\n\n"
    },
    {
      "title": "Pilotes de périphérique de bloc",
      "level": 4,
      "content": "Les pilotes doivent être chargés pendant l'installation, la procédure est de charger l'image ISO avec les pilotes virtio dans un cdrom avec le disque primaire et le média d'installation ISO de Windows :\n\n```\n$ qemu-system-x86_64 ... \\\n-drive file=disk_image,index=0,media=disk,if=virtio \\\n-drive file=windows.iso,index=2,media=cdrom \\\n-drive file=virtio-win.iso,index=3,media=cdrom \\\n...\n```\n\nPendant l'installation, à un moment donné, le programme d'installation de Windows demandera \"Où voulez-vous installer Windows ?\", il émettra un avertissement indiquant qu'aucun disque n'a été trouvé. Suivez les instructions de l'exemple ci-dessous (basé sur Windows Server 2012 R2 avec Update) .\n\n- Sélectionnez l'option Load Drivers.\n- Décochez la case pour Masquer les pilotes qui ne sont pas compatibles avec le matériel de cet ordinateur.\n- Cliquez sur le bouton Parcourir et ouvrez le CDROM pour l'iso virtio, généralement nommé \"virtio-win-XX\".\n- Naviguez maintenant jusqu'à E:\\viostor\\[your-os]\\d64, sélectionnez-le et confirmez.\n\nVous devriez maintenant consulter la liste de vos disques virtio, prêts à être sélectionnés, formatés et installés.\n\nModifier une VM Windows existante pour démarrer à partir d'un disque virtio nécessite que le pilote virtio soit chargé par l'invité au moment du démarrage. Nous devrons donc apprendre à Windows à charger le pilote virtio au démarrage avant de pouvoir démarrer une image disque en mode virtio.\n\nPour cela, il faut d'abord créer une nouvelle image disque qui sera attachée en mode virtio et déclencher la recherche du pilote :\n\n```\n$ qemu-img create -f qcow2 dummy.qcow2 1G\n```\n\nExécutez l'invité Windows original avec le disque de démarrage toujours en mode IDE, le faux disque en mode virtio et l'image ISO du pilote.\n\n```\n$ qemu-system-x86_64 -m 4G -drive file=disk_image,if=ide -drive file=dummy.qcow2,if=virtio -cdrom virtio-win.iso\n```\n\nWindows détectera le faux disque et cherchera un pilote approprié. S'il échoue, allez dans le Gestionnaire de périphériques, localisez le lecteur SCSI avec une icône en forme de point d'exclamation (il devrait être ouvert), cliquez sur Mettre à jour le pilote et sélectionnez le CD-ROM virtuel. Ne naviguez pas jusqu'au dossier du pilote dans le CD-ROM, sélectionnez simplement le lecteur de CD-ROM et Windows trouvera automatiquement le pilote approprié (testé pour Windows 7 SP1).\n\nDemandez à Windows de démarrer en mode sans échec lors de son prochain démarrage. Vous pouvez le faire en utilisant l'outil msconfig.exe de Windows. En mode sans échec, tous les pilotes seront chargés au démarrage, y compris le nouveau pilote virtio. Une fois que Windows sait que le pilote virtio est nécessaire au démarrage, il le mémorisera pour les démarrages futurs.\n\nUne fois que vous avez reçu l'instruction de démarrer en mode sans échec, vous pouvez éteindre la machine virtuelle et la relancer, maintenant avec le disque de démarrage attaché en mode virtio :\n\n```\n$ qemu-system-x86_64 -m 4G -drive file=disk_image,if=virtio\n```\n\nVous devriez démarrer en mode sans échec avec le pilote virtio chargé, vous pouvez maintenant retourner à msconfig.exe pour désactiver le démarrage en mode sans échec et redémarrer Windows.\n\n"
    },
    {
      "title": "Pilotes réseau",
      "level": 4,
      "content": "L'installation des pilotes réseau de virtio est un peu plus simple, il suffit d'ajouter l'argument -nic.\n\n```\n$ qemu-system-x86_64 -m 4G -drive file=windows_disk_image,if=virtio -nic user,model=virtio-net-pci -cdrom virtio-win.iso\n```\n\nWindows va détecter l'adaptateur réseau et essayer de trouver un pilote pour celui-ci. S'il échoue, allez dans le Gestionnaire de périphériques, localisez l'adaptateur réseau avec une icône en forme de point d'exclamation (il devrait être ouvert), cliquez sur Mettre à jour le pilote et sélectionnez le CD-ROM virtuel. N'oubliez pas de cocher la case qui dit de rechercher les répertoires de manière récursive.\n\n"
    },
    {
      "title": "Pilote de ballon",
      "level": 4,
      "content": "Si vous souhaitez suivre l'état de la mémoire de votre invité (par exemple via la commande virsh dommemstat) ou modifier la taille de la mémoire de l'invité en cours d'exécution (vous ne pourrez toujours pas modifier la taille de la mémoire, mais vous pourrez limiter l'utilisation de la mémoire en gonflant le pilote ballon), vous devrez installer le pilote ballon de l'invité.\n\nPour cela, vous devez aller dans le Gestionnaire de périphériques, localiser PCI standard RAM Controller dans System devices (ou un contrôleur PCI non reconnu dans Other devices) et choisir Update driver. Dans la fenêtre ouverte, vous devrez choisir Browse my computer... et sélectionner le CD-ROM (et n'oubliez pas de cocher la case Include subdirectories). Redémarrez après l'installation. Cela installera le pilote et vous pourrez gonfler le ballon (par exemple via la commande hmp balloon memory_size, qui fera en sorte que le ballon prenne autant de mémoire que possible afin de réduire la taille de la mémoire disponible de l'invité à memory_size). Cependant, vous ne serez toujours pas en mesure de suivre l'état de la mémoire de l'invité. Pour ce faire, vous devez installer correctement le service Balloon. Pour cela ouvrez la ligne de commande en tant qu'administrateur, allez sur le CD-ROM, dans le répertoire Balloon et plus profondément, en fonction de votre système et de votre architecture. Une fois dans le répertoire amd64 (x86), exécutez blnsrv.exe -i qui fera l'installation. Après cela, la commande virsh dommemstat devrait afficher toutes les valeurs prises en charge.\n\n"
    },
    {
      "title": "Préparer un invité FreeBSD",
      "level": 3,
      "content": "Installez le port emulators/virtio-kmod si vous utilisez FreeBSD 8.3 ou plus jusqu'à 10.0-CURRENT où ils sont inclus dans le noyau. Après l'installation, ajoutez ce qui suit à votre fichier /boot/loader.conf :\n\n```\nvirtio_load=\"YES\"\nvirtio_pci_load=\"YES\" (en anglais)\nvirtio_blk_load=\"YES\"\nif_vtnet_load=\"YES\"\nvirtio_balloon_load=\"YES\"\n```\n\nPuis modifiez votre /etc/fstab en faisant ce qui suit :\n\n```\n# sed -ibak \"s/ada/vtbd/g\" /etc/fstab\n```\n\nEt vérifiez que /etc/fstab est cohérent. Si quelque chose ne va pas, démarrez simplement sur un CD de secours et copiez /etc/fstab.bak vers /etc/fstab.\n\n"
    },
    {
      "title": "Moniteur de QEMU",
      "level": 2,
      "content": "Lorsque QEMU est en cours d'exécution, une console de surveillance est fournie afin d'offrir plusieurs façons d'interagir avec la machine virtuelle en cours d'exécution. Le moniteur QEMU offre des capacités intéressantes telles que l'obtention d'informations sur la machine virtuelle en cours, le branchement à chaud de périphériques, la création d'instantanés de l'état actuel de la machine virtuelle, etc. Pour consulter la liste de toutes les commandes, exécutez help ou ? dans la console du moniteur QEMU ou consultez la section correspondante de la documentation officielle QEMU.\n\n"
    },
    {
      "title": "Vue graphique",
      "level": 4,
      "content": "Lorsque l'option graphique par défaut std est utilisée, on peut accéder au moniteur QEMU en appuyant sur Ctrl+Alt+2 ou en cliquant sur View > compatmonitor0 dans la fenêtre QEMU. Pour revenir à la vue graphique de la machine virtuelle, appuyez sur Ctrl+Alt+1 ou cliquez sur View > VGA.\n\nCependant, la méthode standard d'accès au moniteur n'est pas toujours pratique et ne fonctionne pas avec toutes les sorties graphiques prises en charge par QEMU.\n\n"
    },
    {
      "title": "Telnet",
      "level": 4,
      "content": "Pour activer telnet, exécutez QEMU avec le paramètre -monitor telnet:127.0.0.1:port,server,nowait. Lorsque la machine virtuelle est démarrée, vous pourrez accéder au moniteur via telnet :\n\n```\n$ telnet 127.0.0.1 : port\n```\n\n"
    },
    {
      "title": "Socket UNIX",
      "level": 4,
      "content": "Lancez QEMU avec le paramètre -monitor unix:socketfile,server,nowait. Vous pouvez ensuite vous connecter avec soit socat, nmap ou openbsd-netcat.\n\nPar exemple, si QEMU est lancé via :\n\n```\n$ qemu-system-x86_64 -monitor unix:/tmp/monitor.sock,server,nowait [...]'.\n```\n\nIl est possible de se connecter au moniteur avec :\n\n```\n$ socat - UNIX-CONNECT:/tmp/monitor.sock\n```\n\nOu avec :\n\n```\n$ nc -U /tmp/monitor.sock\n```\n\nAlternativement avec nmap :\n\n```\n$ ncat -U /tmp/monitor.sock\n```\n\n"
    },
    {
      "title": "TCP",
      "level": 4,
      "content": "Vous pouvez exposer le moniteur sur TCP avec l'argument -monitor tcp:127.0.0.1 : port,server,nowait. Ensuite, connectez-vous avec netcat, soit openbsd-netcat ou gnu-netcat en exécutant :\n\n```\n$ nc 127.0.0.1 port\n```\n\n"
    },
    {
      "title": "E/S standard",
      "level": 4,
      "content": "Il est possible d'accéder automatiquement au moniteur à partir du même terminal que celui où QEMU est exécuté en le lançant avec l'argument -monitor stdio.\n\n"
    },
    {
      "title": "Envoyer les frappes du clavier à la machine virtuelle en utilisant la console du moniteur",
      "level": 3,
      "content": "Certaines combinaisons de touches peuvent être difficiles à exécuter sur les machines virtuelles car l'hôte les intercepte à la place dans certaines configurations (un exemple notable est la combinaison de touches Ctrl+Alt+F*, qui change le tty actif). Pour éviter ce problème, la combinaison de touches problématique peut être envoyée via la console du moniteur. Passez au moniteur et utilisez la commande sendkey pour transmettre les pressions de touche nécessaires à la machine virtuelle. Par exemple :\n\n```\n(qemu) sendkey ctrl-alt-f2\n```\n\n"
    },
    {
      "title": "Création et gestion des snapshots via la console du moniteur",
      "level": 3,
      "content": "Note: **uniquement** \n\nIl est parfois souhaitable de sauvegarder l'état actuel d'une machine virtuelle et d'avoir la possibilité de revenir à l'état de la machine virtuelle à celui d'un snapshot précédemment sauvegardé à tout moment. La console de surveillance QEMU fournit à l'utilisateur les utilitaires nécessaires pour créer des snapshots, les gérer et rétablir l'état de la machine à un snapshot sauvegardé.\n\n- Utilisez savevm name pour créer un instantané avec l'étiquette name.\n- Utilisez loadvm name pour ramener la machine virtuelle à l'état du snapshot name.\n- Utilisez delvm name pour supprimer le snapshot marqué comme name.\n- Utilisez info snapshots pour consulter une liste des instantanés sauvegardés. Les snapshots sont identifiés à la fois par un numéro d'identification auto-incrémenté et une balise texte (définie par l'utilisateur lors de la création du snapshot).\n\n"
    },
    {
      "title": "Exécuter la machine virtuelle en mode immuable",
      "level": 3,
      "content": "Il est possible d'exécuter une machine virtuelle dans un état figé de sorte que tous les changements seront supprimés lorsque la machine virtuelle est mise hors tension, simplement en exécutant QEMU avec le paramètre -snapshot. Lorsque l'image disque est écrite par l'invité, les changements seront enregistrés dans un fichier temporaire dans /tmp et seront supprimés lorsque QEMU s'arrêtera.\n\nCependant, si une machine fonctionne en mode gelé, il est toujours possible de sauvegarder les changements dans l'image disque si on le souhaite par la suite en utilisant la console de surveillance et en exécutant la commande suivante :\n\n```\n(qemu) commit all\n```\n\nSi des snapshots sont créés lors d'une exécution en mode gelé, ils seront supprimés dès que QEMU sera quitté, à moins que les changements ne soient explicitement commités sur le disque, également.\n\n"
    },
    {
      "title": "Options de pause et d'alimentation via la console du moniteur",
      "level": 3,
      "content": "Certaines opérations d'une machine physique peuvent être émulées par QEMU en utilisant certaines commandes de la console de surveillance :\n\n- system_powerdown enverra une demande d'arrêt ACPI à la machine virtuelle. Cet effet est similaire au bouton d'alimentation dans une machine physique.\n- system_reset réinitialisera la machine virtuelle de manière similaire à un bouton de réinitialisation dans une machine physique. Cette opération peut entraîner une perte de données et une corruption du système de fichiers puisque la machine virtuelle n'est pas redémarrée proprement.\n- stop mettra en pause la machine virtuelle.\n- cont reprendra une machine virtuelle précédemment mise en pause.\n\n"
    },
    {
      "title": "Prendre des captures d'écran de la machine virtuelle",
      "level": 3,
      "content": "Les captures d'écran de l'affichage graphique de la machine virtuelle peuvent être obtenues au format PPM en exécutant la commande suivante dans la console du moniteur :\n\n```\n(qemu) screendump file.ppm\n```\n\n"
    },
    {
      "title": "Protocole machine QEMU",
      "level": 2,
      "content": "Le protocole machine QEMU (QMP) est un protocole basé sur JSON qui permet aux applications de contrôler une instance QEMU. Comme le #Moniteur de QEMU, il offre des moyens d'interagir avec une machine en fonctionnement et le protocole JSON permet de le faire de manière programmatique. La description de toutes les commandes QMP se trouve dans qmp-commands.\n\n"
    },
    {
      "title": "Démarrer QMP",
      "level": 3,
      "content": "La manière habituelle de contrôler l'invité en utilisant le protocole QMP, est d'ouvrir un socket TCP lors du lancement de la machine en utilisant l'option -qmp. Ici, on utilise par exemple le port TCP 4444 :\n\n```\n$ qemu-system-x86_64 [...] -qmp tcp:localhost:4444,server,nowait\n```\n\nEnsuite, une façon de communiquer avec l'agent QMP est d'utiliser netcat :\n\n```\nnc localhost 4444\n```\n\n```\n{\"QMP\" : {\"version\" : {\"qemu\" : {\"micro\" : 0, \"minor\" : 1, \"major\" : 3}, \"package\" : \"\"}, \"capabilities\" : []} }\n```\n\nÀ ce stade, la seule commande qui peut être reconnue est qmp_capabilities, de sorte que QMP passe en mode commande. Type :\n\n```\n{\"execute\" : \"qmp_capabilities\"}\n```\n\nMaintenant, QMP est prêt à recevoir des commandes, pour récupérer la liste des commandes reconnues, utilisez :\n\n```\n{\"execute\" : \"query-commands\"}\n```\n\n"
    },
    {
      "title": "Fusion en direct de l'image enfant dans l'image parent",
      "level": 3,
      "content": "Il est possible de fusionner un instantané en cours dans son parent en émettant une commande block-commit. Dans sa forme la plus simple, la ligne suivante commet l'enfant dans son parent :\n\n```\n{\"execute\" : \"block-commit\", \"arguments\" : {\"device\" : \"devicename\"}}\n```\n\nÀ la réception de cette commande, le gestionnaire recherche l'image de base et la convertit du mode lecture seule au mode lecture-écriture, puis exécute le travail de validation.\n\nUne fois l'opération de block-commit terminée, l'événement BLOCK_JOB_READY sera émis, signalant que la synchronisation est terminée. Le travail peut alors être terminé en douceur en émettant la commande block-job-complete :\n\n```\n{\"execute\" : \"block-job-complete\", \"arguments\" : {\"device\" : \"devicename\"}}\n```\n\nJusqu'à ce qu'une telle commande soit émise, l'opération commit reste active. Une fois l'opération terminée avec succès, l'image de base reste en mode lecture-écriture et devient la nouvelle couche active. En revanche, l'image enfant devient invalide et il incombe à l'utilisateur de la nettoyer.\n\nNote: **ide0-hd0** \n\n```\n{\"execute\" : \"query-block\"}\n```\n\n```\n{\"return\" : [{\"io-status\" : \"ok\", \"device\" : \"ide0-hd0\", \"locked\" : false, \"removable\" : false, \"inserted\" : {\"iops_rd\" : 0, \"detect_zeroes\" : \"off\", \"image\" : {\"backing-image\" : {\"virtual-size\" : 27074281472, \"filename\" : \"parent.qcow2\", ... }\n```\n\n"
    },
    {
      "title": "Création en direct d'un nouvel instantané",
      "level": 3,
      "content": "Pour créer un nouvel instantané à partir d'une image en cours d'exécution, exécutez la commande :\n\n```\n{\"execute\" : \"blockdev-snapshot-sync\", \"arguments\" : {\"device\" : \"devicename\", \"snapshot-file\" : \"new_snapshot_name.qcow2\"}}\n```\n\nCela crée un fichier de superposition nommé new_snapshot_name.qcow2 qui devient alors la nouvelle couche active.\n\n"
    },
    {
      "title": "Améliorer les performances de la machine virtuelle",
      "level": 3,
      "content": "Il existe un certain nombre de techniques que vous pouvez utiliser pour améliorer les performances de la machine virtuelle. Par exemple :\n\n- Appliquez #Activation de KVM pour une virtualisation complète.\n- Utilisez l'option -cpu host pour que QEMU émule le CPU exact de l'hôte plutôt qu'un CPU plus générique.\n- Surtout pour les invités Windows, activez Hyper-V enlightenments : -cpu host,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time.\n- Si la machine hôte a plusieurs cœurs, assignez à l'invité plus de cœurs en utilisant l'option -smp.\n- Assurez-vous que vous avez attribué suffisamment de mémoire à la machine virtuelle. Par défaut, QEMU n'attribue que 128 MiB de mémoire à chaque machine virtuelle. Utilisez l'option -m pour attribuer plus de mémoire. Par exemple, -m 1024 exécute une machine virtuelle avec 1024 MiB de mémoire.\n- Si les pilotes du système d'exploitation invité le prennent en charge, utilisez virtio pour les périphériques réseau et/ou de bloc, consultez #Installation des pilotes virtio.\n- Utilisez les périphériques TAP au lieu de la mise en réseau en mode utilisateur, consultez #Mise en réseau avec tap pour QEMU.\n- Si le système d'exploitation invité écrit beaucoup sur son disque, vous pouvez bénéficier de certaines options de montage sur le système de fichiers de l'hôte. Par exemple, vous pouvez monter un système de fichiers ext4 avec l'option barrier=0. Vous devez lire la documentation de toutes les options que vous modifiez, car parfois, les options d'amélioration des performances des systèmes de fichiers se font au détriment de l'intégrité des données.\n- Si vous avez une image disque brute, vous pouvez vouloir désactiver le cache : $ qemu-system-x86_64 -drive file=disk_image,if=virtio,cache=none\n- Utiliser l'AIO native de Linux : $ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on'\n- Si vous exécutez simultanément plusieurs machines virtuelles qui ont toutes le même système d'exploitation installé, vous pouvez économiser de la mémoire en activant kernel same-page merging. Consultez #Activation de KSM.\n- Dans certains cas, la mémoire peut être récupérée des machines virtuelles en cours d'exécution en exécutant un pilote de ballon de mémoire dans le système d'exploitation invité et en lançant QEMU à l'aide de -device virtio-balloon.\n- Il est possible d'utiliser une couche d'émulation pour un contrôleur ICH-9 AHCI (bien que cela puisse être instable). L'émulation AHCI prend en charge NCQ, ainsi plusieurs requêtes de lecture ou d'écriture peuvent être en cours en même temps : $ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0\n\n```\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio,cache=none\n```\n\n```\n$ qemu-system-x86_64 -drive file=disk_image,if=virtio,aio=native,cache.direct=on'\n```\n\n```\n$ qemu-system-x86_64 -drive id=disk,file=disk_image,if=none -device ich9-ahci,id=ahci -device ide-drive,drive=disk,bus=ahci.0\n```\n\nConsultez https://www.linux-kvm.org/page/Tuning_KVM pour plus d'informations.\n\n"
    },
    {
      "title": "Avec libvirt",
      "level": 4,
      "content": "Si une machine virtuelle est configurée avec libvirt, elle peut être configurée avec virsh autostart ou via l'interface graphique virt-manager pour démarrer au démarrage de l'hôte en allant dans les options de démarrage de la machine virtuelle et en sélectionnant \"Start virtual machine on host boot up\".\n\n"
    },
    {
      "title": "Avec le service systemd",
      "level": 4,
      "content": "Pour exécuter les VM QEMU au démarrage, vous pouvez utiliser l'unité et la configuration systemd suivantes.\n\n```\n/etc/systemd/system/qemu@.service\n```\n\n```\n[Unit]\nDescription=QEMU virtual machine\n\n[Service]\nEnvironment=\"haltcmd=kill -INT $MAINPID\"\nEnvironmentFile=/etc/conf.d/qemu.d/%i\nExecStart=/usr/bin/qemu-system-x86_64 -name %i -enable-kvm -m 512 -nographic $args\nExecStop=/usr/bin/bash -c ${haltcmd}\nExecStop=/usr/bin/bash -c 'while nc localhost 7100; do sleep 1; done'\n\n[Install]\nWantedBy=multi-user.target\n```\n\nCréez ensuite des fichiers de configuration par VM, nommés /etc/conf.d/qemu.d/vm_name, avec les variables args et haltcmd définies. Exemples de configurations :\n\n```\n/etc/conf.d/qemu.d/one\n```\n\n```\nargs=\"-hda /dev/vg0/vm1 -serial telnet:localhost:7000,server,nowait,nodelay \\\n -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0\"\n\nhaltcmd=\"echo 'system_powerdown' | nc localhost 7100\" # ou netcat/ncat\n```\n\n```\n/etc/conf.d/qemu.d/two\n```\n\n```\nargs=\"-hda /srv/kvm/vm2 -serial telnet:localhost:7001,server,nowait,nodelay -vnc :1\"\n\nhaltcmd=\"ssh powermanager@vm2 sudo poweroff\"\n```\n\nLa description des variables est la suivante :\n\n- args - Arguments de ligne de commande QEMU à utiliser.\n- haltcmd - Commande permettant d'éteindre une VM en toute sécurité. Dans le premier exemple, le moniteur QEMU est exposé via telnet en utilisant -monitor telnet :.. et les VMs sont mises hors tension via ACPI en envoyant system_powerdown au moniteur avec la commande nc. Dans l'autre exemple, SSH est utilisé.\n\nPour définir quelles machines virtuelles démarreront au démarrage, activez l'unité systemd qemu@vm_name.service.\n\n"
    },
    {
      "title": "Intégration de la souris",
      "level": 3,
      "content": "Pour éviter que la souris soit saisie lors d'un clic sur la fenêtre du système d'exploitation invité, ajoutez les options -usb -device usb-tablet. Cela signifie que QEMU est capable de signaler la position de la souris sans avoir à la saisir. Cela remplace également l'émulation de la souris PS/2 lorsqu'elle est activée. Par exemple :\n\n```\n$ qemu-system-x86_64 -hda disk_image -m 512 -usb -device usb-tablet\n```\n\nSi cela ne fonctionne pas, essayez d'utiliser le paramètre -vga qxl, consultez également les instructions #Le curseur de la souris est instable ou erratique.\n\n"
    },
    {
      "title": "Pass-through host USB device",
      "level": 3,
      "content": "Il est possible d'accéder au périphérique physique connecté à un port USB de l'hôte depuis l'invité. La première étape consiste à identifier où le périphérique est connecté, ce qui peut être trouvé en exécutant la commande lsusb. Par exemple :\n\n```\n$ lsusb\n```\n\n```\n...\nBus 003 Device 007 : ID 0781:5406 SanDisk Corp. Cruzer Micro U3\n```\n\nLes sorties en gras ci-dessus seront utiles pour identifier respectivement le host_bus et le host_addr ou le vendor_id et le product_id.\n\nDans qemu, l'idée est d'émuler un contrôleur EHCI (USB 2) ou XHCI (USB 1.1 USB 2 USB 3) avec l'option -device usb-ehci,id=ehci ou -device qemu-xhci,id=xhci respectivement, puis d'y attacher le périphérique physique avec l'option -device usb-host,... Nous considérerons que controller_id est soit ehci soit xhci pour le reste de cette section.\n\nEnsuite, il y a deux façons de se connecter à l'USB de l'hôte avec qemu :\n\n1. Identifiez le périphérique et se connecter à lui sur n'importe quel bus et adresse auquel il est attaché sur l'hôte, la syntaxe générique est : -device usb-host,bus=controller_id.0,vendorid=0xvendor_id,productid=0xproduct_idAppliquée au périphérique utilisé dans l'exemple ci-dessus, elle devient:-device usb-ehci,id=ehci -device usb-host,bus=ehci.0, vendorid=0x'0781,productid=0x5406On peut également ajouter le paramètre ...,port=port_number à l'option précédente pour spécifier dans quel port physique du contrôleur virtuel le périphérique doit être attaché, utile dans le cas où l'on veut ajouter plusieurs périphériques usb à la VM. Une autre option est d'utiliser la nouvelle propriété hostdevice de usb-host qui est disponible depuis QEMU 5.1.0, la syntaxe est : -device qemu-xhci,id=xhci -device usb-host,hostdevice=/dev/bus/usb/003/007\n1. Attachez ce qui est connecté à un bus USB et une adresse donnés, la syntaxe est:-device usb-host,bus=controller_id.0,hostbus=host_bus,host_addr=host_addrAppliqué au bus et à l'adresse dans l'exemple ci-dessus, cela devient:-device usb-ehci,id=ehci -device usb-host,bus=ehci.0, hostbus=3,hostaddr=7\n\n```\n-device usb-host,bus=controller_id.0,vendorid=0xvendor_id,productid=0xproduct_id\n```\n\n```\n-device usb-ehci,id=ehci -device usb-host,bus=ehci.0, vendorid=0x'0781,productid=0x5406\n```\n\n```\n-device qemu-xhci,id=xhci -device usb-host,hostdevice=/dev/bus/usb/003/007\n```\n\n```\n-device usb-host,bus=controller_id.0,hostbus=host_bus,host_addr=host_addr\n```\n\n```\n-device usb-ehci,id=ehci -device usb-host,bus=ehci.0, hostbus=3,hostaddr=7\n```\n\nConsultez émulation QEMU/USB pour plus d'informations.\n\n"
    },
    {
      "title": "Redirection USB avec SPICE",
      "level": 3,
      "content": "En utilisant #SPICE, il est possible de rediriger les périphériques USB du client vers la machine virtuelle sans avoir besoin de les spécifier dans la commande QEMU. Il est possible de configurer le nombre de slots USB disponibles pour les périphériques redirigés (le nombre de slots déterminera le nombre maximum de périphériques pouvant être redirigés simultanément). Les principaux avantages de l'utilisation de SPICE pour la redirection par rapport à la méthode -usbdevice mentionnée précédemment est la possibilité de remplacer à chaud les périphériques USB après le démarrage de la machine virtuelle, sans avoir besoin de l'arrêter pour supprimer les périphériques USB de la redirection ou en ajouter de nouveaux. Cette méthode de redirection USB nous permet également de rediriger les périphériques USB sur le réseau, du client au serveur. En résumé, c'est la méthode la plus flexible pour utiliser les périphériques USB dans une machine virtuelle QEMU.\n\nNous devons ajouter un contrôleur EHCI/UHCI par slot de redirection USB disponible souhaité ainsi qu'un canal de redirection SPICE par slot. Par exemple, en ajoutant les arguments suivants à la commande QEMU que vous utilisez pour démarrer la machine virtuelle en mode SPICE, la machine virtuelle démarrera avec trois slots USB disponibles pour la redirection :\n\n```\n-device ich9-usb-ehci1,id=usb \\\n-device ich9-usb-uhci1,masterbus=usb.0,firstport=0,multifunction=on \\\\\n-dispositif ich9-usb-uhci2,masterbus=usb.0,firstport=2 \\\n-device ich9-usb-uhci3,masterbus=usb.0,firstport=4 \\\n-chardev spicevmc,name=usbredir,id=usbredirchardev1 -device usb-redir,chardev=usbredirchardev1,id=usbredirdev1 \\\n-chardev spicevmc,name=usbredir,id=usbredirchardev2 -device usb-redir,chardev=usbredirchardev2,id=usbredirdev2 \\\n-chardev spicevmc,name=usbredir,id=usbredirchardev3 -device usb-redir,chardev=usbredirchardev3,id=usbredirdev3\n```\n\nConsultez SPICE/usbredir pour plus d'informations.\n\nLes deux spicy de spice-gtk (Entrée > Sélectionner les périphériques USB pour la redirection) et remote-viewer de virt-viewer (File > USB device selection) prennent en charge cette fonctionnalité. Veuillez vous assurer que vous avez installé les outils SPICE Guest Tools nécessaires sur la machine virtuelle pour que cette fonctionnalité fonctionne comme prévu (consultez la section #SPICE pour plus d'informations).\n\n"
    },
    {
      "title": "Redirection USB automatique avec udev",
      "level": 4,
      "content": "Normalement, les périphériques transférés doivent être disponibles au moment du démarrage de la VM pour être transférés. Si ce périphérique est déconnecté, il ne sera plus transféré.\n\nVous pouvez utiliser des règles udev pour attacher automatiquement un périphérique lorsqu'il est en ligne. Créez une entrée hostdev quelque part sur le disque. chown à root pour empêcher les autres utilisateurs de la modifier.\n\n```\n/usr/local/hostdev-mydevice.xml\n```\n\n```\n<hostdev mode='subsystem' type='usb'>\n  <source>\n    <vendor id='0x03f0'/>\n    <product id='0x4217'/>\n  </source>\n</hostdev>\n```\n\nCréez ensuite une règle udev qui attachera/détachera le périphérique :\n\n```\n/usr/lib/udev/rules.d/90-libvirt-mydevice\n```\n\n```\nACTION==\"add\", \\\n    SUBSYSTEM==\"usb\", \\\n    ENV{ID_VENDOR_ID}==\"03f0\", \\\n    ENV{ID_MODEL_ID}==\"4217\", \\\n    RUN+=\"/usr/bin/virsh attach-device GUESTNAME /usr/local/hostdev-mydevice.xml\"\nACTION==\"remove\", \\\n    SUBSYSTEM==\"usb\", \\\n    ENV{ID_VENDOR_ID}==\"03f0\", \\\n    ENV{ID_MODEL_ID}==\"4217\", \\\n    RUN+=\"/usr/bin/virsh detach-device GUESTNAME /usr/local/hostdev-mydevice.xml\"\n```\n\nSource et lecture complémentaire.\n\n"
    },
    {
      "title": "Activation de KSM",
      "level": 3,
      "content": "KSM (Kernel Samepage Merging) est une fonctionnalité du noyau Linux qui permet à une application de s'enregistrer auprès du noyau pour que ses pages soient fusionnées avec d'autres processus qui s'enregistrent également pour que leurs pages soient fusionnées. Le mécanisme KSM permet aux machines virtuelles invitées de partager des pages entre elles. Dans un environnement où de nombreux systèmes d'exploitation invités sont similaires, cela peut permettre de réaliser d'importantes économies de mémoire.\n\nPour activer KSM :\n\n```\n# echo 1 > /sys/kernel/mm/ksm/run\n```\n\nPour le rendre permanent, utilisez les fichiers temporaires de systemd :\n\n```\n/etc/tmpfiles.d/ksm.conf\n```\n\n```\nw /sys/kernel/mm/ksm/run - - - - 1\n```\n\nSi KSM est en cours d'exécution et que des pages doivent être fusionnées (c'est-à-dire qu'au moins deux VM similaires sont en cours d'exécution), alors /sys/kernel/mm/ksm/pages_shared doit être différent de zéro. Consultez https://docs.kernel.org/admin-guide/mm/ksm.html pour plus d'informations.\n\n```\n$ grep -r . /sys/kernel/mm/ksm/\n```\n\n"
    },
    {
      "title": "Prise en charge de plusieurs moniteurs",
      "level": 3,
      "content": "Le pilote Linux QXL prend en charge quatre têtes (écrans virtuels) par défaut. Ceci peut être modifié par le paramètre noyau qxl.heads=N.\n\nLa taille de la mémoire VGA par défaut pour les périphériques QXL est de 16M (la taille de la VRAM est de 64M). Ce n'est pas suffisant si vous souhaitez activer deux moniteurs 1920x1200 car cela nécessite 2 × 1920 × 4 (profondeur de couleur) × 1200 = 17,6 Mio de mémoire VGA. Ceci peut être modifié en remplaçant -vga qxl par -vga none -device qxl-vga,vgamem_mb=32. Si vous augmentez vgamem_mb au-delà de 64M, vous devez également augmenter l'option vram_size_mb.\n\n"
    },
    {
      "title": "Résolution d'affichage personnalisée",
      "level": 3,
      "content": "Une résolution d'affichage personnalisée peut être définie avec -device VGA,edid=on,xres=1280,yres=720. (consultez EDID et display resolution).\n\n"
    },
    {
      "title": "Copier et coller",
      "level": 3,
      "content": "Une façon de partager le presse-papiers entre l'hôte et l'invité est d'activer le protocole de bureau à distance SPICE et d'accéder au client avec un client SPICE. Il faut suivre les étapes décrites dans #SPICE. Un invité exécuté de cette façon prendra en charge le copier-coller avec l'hôte.\n\n"
    },
    {
      "title": "Notes spécifiques à Windows",
      "level": 3,
      "content": "QEMU peut exécuter toute version de Windows, de Windows 95 à Windows 10.\n\nIl est possible d'exécuter Windows PE dans QEMU.\n\n"
    },
    {
      "title": "Démarrage rapide",
      "level": 4,
      "content": "Pour les invités Windows 8 (ou ultérieur), il est préférable de désactiver l'option \"Activer le démarrage rapide (recommandé)\" dans les Options d'alimentation du Panneau de configuration, comme expliqué dans la [page du forum https://www.tenforums.com/tutorials/4189-turn-off-fast-startup-windows-10-a.html] suivante, car elle provoque le blocage de l'invité lors de chaque démarrage.\n\nLe démarrage rapide peut également devoir être désactivé pour que les modifications apportées à l'option -smp soient correctement appliquées.\n\n"
    },
    {
      "title": "Protocole de bureau à distance",
      "level": 4,
      "content": "Si vous utilisez un invité MS Windows, vous voudrez peut-être utiliser RDP pour vous connecter à votre VM invitée. Si vous utilisez un VLAN ou si vous n'êtes pas dans le même réseau que l'invité, utilisez :\n\n```\n$ qemu-system-x86_64 -nographic -nic user,hostfwd=tcp::5555-:3389\n```\n\nEnsuite, connectez-vous avec rdesktop ou freerdp à l'invité. Par exemple :\n\n```\n$ xfreerdp -g 2048x1152 localhost:5555 -z -x lan\n```\n\n"
    },
    {
      "title": "Cloner un système Linux installé sur un équipement physique",
      "level": 3,
      "content": "Le système Linux installé sur un équipement physique peut être cloné pour fonctionner sur une vm QEMU. Consultez Cloner le système Linux à partir du matériel pour la machine virtuelle QEMU.\n\n"
    },
    {
      "title": "Chrooter dans l'environnement arm/arm64 à partir de x86_64",
      "level": 3,
      "content": "Parfois, il est plus facile de travailler directement sur une image disque plutôt que sur le dispositif réel basé sur ARM. Ceci peut être réalisé en montant une carte SD/stockage contenant la partition root et en s'y connectant.\n\nUn autre cas d'utilisation pour un chroot ARM est la construction de paquets ARM sur une machine x86_64. Ici, l'environnement chroot peut être créé à partir d'une image tarball de Arch Linux ARM - consultez [3][dead link 2024-12-15 ⓘ] pour une description détaillée de cette approche.\n\nDans tous les cas, à partir du chroot, il devrait être possible d'exécuter pacman et d'installer plus de paquets, de compiler de grandes bibliothèques, etc. Comme les exécutables sont pour l'architecture ARM, la traduction en x86 doit être effectuée par QEMU.\n\nInstallez qemu-user-static sur la machine/hôte x86_64 et qemu-user-static-binfmt se chargera d'enregistrer les binaires qemu au service binfmt.\n\nRedémarrez systemd-binfmt.service\n\nqemu-user-static est nécessaire pour permettre l'exécution de programmes compilés provenant d'autres architectures. C'est similaire à ce qui est fourni par qemu-emulators-full, mais la variante \"static\" est requise pour chroot. Exemples :\n\n```\nqemu-arm-static path_to_sdcard/usr/bin/ls\nqemu-aarch64-static chemin_vers_sdcard/usr/bin/ls\n```\n\nCes deux lignes exécutent la commande ls compilée pour ARM 32 bits et ARM 64 bits respectivement. Notez que cela ne fonctionnera pas sans chrooting, car il cherchera des bibliothèques non présentes dans le système hôte.\n\nqemu-user-static permet de préfixer automatiquement l'exécutable ARM avec qemu-arm-static ou qemu-aarch64-static.\n\nAssurez-vous que le support de l'exécutable ARM est actif :\n\n```\n$ ls /proc/sys/fs/binfmt_misc\n```\n\n```\n].\nqemu-aarch64 qemu-arm qemu-cris qemu-microblaze qemu-mipsel qemu-ppc64 qemu-riscv64 qemu-sh4 qemu-sparc qemu-sparc64 status\nqemu-alpha qemu-armeb qemu-m68k qemu-mips qemu-ppc qemu-ppc64abi32 qemu-s390x qemu-sh4eb qemu-sparc32plus register\n```\n\nChaque exécutable doit être listé.\n\nS'il n'est pas actif, redémarrez systemd-binfmt.service.\n\nMontez la carte SD sur /mnt/sdcard. (le nom du périphérique peut être différent).\n\n```\n# mkdir -p /mnt/sdcard\n# mount /dev/mmcblk0p2 /mnt/sdcard\n```\n\nMontez la partition de démarrage si nécessaire (encore une fois, utilisez le nom de périphérique approprié) :\n\n```\n# mount /dev/mmcblk0p1 /mnt/sdcard/boot\n```\n\nEnfin, chroot dans la racine de la carte SD comme décrit dans Chroot (Français)#Avec chroot :\n\n```\n# chroot /mnt/sdcard /bin/bash\n```\n\nAlternativement, vous pouvez utiliser arch-chroot à partir de arch-install-scripts, car il fournira un moyen plus facile d'obtenir un support réseau :\n\n```\n# arch-chroot /mnt/sdcard /bin/bash\n```\n\nVous pouvez également utiliser systemd-nspawn pour chrooter dans l'environnement ARM :\n\n```\n# systemd-nspawn -D /mnt/sdcard -M myARMMachine --bind-ro=/etc/resolv.conf\n```\n\n--bind-ro=/etc/resolv.conf est optionnel et donne un DNS réseau fonctionnel dans le chroot.\n\n"
    },
    {
      "title": "Ne pas saisir l'entrée de la souris",
      "level": 3,
      "content": "Le mode tablette a pour effet secondaire de ne pas saisir l'entrée de la souris dans la fenêtre QEMU :\n\n```\n-usb -device usb-tablet\n```\n\nCela fonctionne avec plusieurs backends -vga dont l'un est virtio.\n\n"
    },
    {
      "title": "Le curseur de la souris est instable ou erratique",
      "level": 3,
      "content": "Si le curseur saute à l'écran de manière incontrôlée, entrer ceci dans le terminal avant de démarrer QEMU peut aider :\n\n```\n$ export SDL_VIDEO_X11_DGAMOUSE=0\n```\n\nSi cela aide, vous pouvez ajouter ceci à votre fichier ~/.bashrc.\n\n"
    },
    {
      "title": "Pas de curseur visible",
      "level": 3,
      "content": "Ajoutez -display default,show-cursor=on aux options de QEMU pour consulter un curseur de souris.\n\nSi cela ne fonctionne toujours pas, vérifiez que vous avez configuré votre périphérique d'affichage de manière appropriée, par exemple : -vga qxl.\n\nUne autre option à essayer est -usb -device usb-tablet comme mentionné dans #Intégration de la souris. Cela remplace l'émulation de la souris PS/2 par défaut et synchronise l'emplacement du pointeur entre l'hôte et l'invité comme un bonus supplémentaire.\n\n"
    },
    {
      "title": "Deux curseurs de souris différents sont visibles",
      "level": 3,
      "content": "Appliquez l'astuce #Intégration de la souris.\n\n"
    },
    {
      "title": "Problèmes de clavier lors de l'utilisation de VNC",
      "level": 3,
      "content": "Lors de l'utilisation de VNC, vous pouvez rencontrer des problèmes de clavier décrits (dans les détails sanglants) ici. La solution est de ne pas utiliser l'option -k sur QEMU, et d'utiliser gvncviewer de gtk-vnc. Consultez également le message this posté sur la liste de diffusion de libvirt.\n\n"
    },
    {
      "title": "Le clavier semble cassé ou les touches fléchées ne fonctionnent pas",
      "level": 3,
      "content": "Si vous trouvez que certaines de vos touches ne fonctionnent pas ou \"appuient\" sur la mauvaise touche (en particulier, les touches fléchées), vous devez probablement spécifier votre disposition de clavier en option. Les dispositions de clavier peuvent être trouvées dans /usr/share/qemu/keymaps/.\n\n```\n$ qemu-system-x86_64 -k keymap disk_image\n```\n\n"
    },
    {
      "title": "Impossible de lire le fichier keymap",
      "level": 3,
      "content": "```\nqemu-system-x86_64 : -display vnc=0.0.0.0:0 : could not read keymap file : 'en'.\n```\n\nest causée par un keymap invalide passé à l'argument -k. Par exemple, en est invalide, mais en-us est valide - consultez /usr/share/qemu/keymaps/.\n\n"
    },
    {
      "title": "L'affichage invité s'étire lors du redimensionnement de la fenêtre",
      "level": 3,
      "content": "Pour restaurer la taille de fenêtre par défaut, appuyez sur Ctrl+Alt+u.\n\n"
    },
    {
      "title": "ioctl(KVM_CREATE_VM) failed : 16 Device or resource busy",
      "level": 3,
      "content": "Si un message d'erreur comme celui-ci est imprimé au démarrage de QEMU avec l'option -enable-kvm :\n\n```\nioctl(KVM_CREATE_VM) failed : 16 Périphérique ou ressource occupée\néchec de l'initialisation de KVM : Périphérique ou ressource occupée\n```\n\ncela signifie qu'un autre hyperviseur est en cours d'exécution. Il n'est pas recommandé ou possible d'exécuter plusieurs hyperviseurs en parallèle.\n\n"
    },
    {
      "title": "message d'erreur libgfapi",
      "level": 3,
      "content": "Le message d'erreur affiché au démarrage :\n\n```\nFailed to open module : libgfapi.so.0 : cannot open shared object file : No such file or directory\n```\n\nInstallez glusterfs ou ignorez le message d'erreur car GlusterFS est une dépendance facultative.\n\n"
    },
    {
      "title": "Panique du noyau sur les environnements LIVE",
      "level": 3,
      "content": "Si vous démarrez un environnement vivant (ou mieux : si vous démarrez un système), vous pouvez rencontrer ceci :\n\n```\n[ end Panique du noyau - pas de synchronisation : VFS : Impossible de monter le fs racine sur un bloc inconnu(0,0)\n```\n\nou tout autre processus entravant le démarrage (par exemple, impossible de décompresser initramfs, impossible de démarrer le service foo). Essayez de démarrer la VM avec le paramètre -m VALUE et une quantité appropriée de RAM, si la RAM est trop faible, vous rencontrerez probablement les mêmes problèmes que ci-dessus/sans le paramètre de mémoire.\n\n"
    },
    {
      "title": "L'invité Windows 7 souffre d'un son de mauvaise qualité",
      "level": 3,
      "content": "L'utilisation du pilote audio hda pour l'invité Windows 7 peut entraîner un son de mauvaise qualité. Changer le pilote audio pour ac97 en passant les arguments -soundhw ac97 à QEMU et installer le pilote AC97 de Realtek AC'97 Audio Codecs[dead link 2025-01-22 ⓘ] dans l'invité peut résoudre le problème. Consultez Red Hat Bugzilla - Bug 1176761 pour plus d'informations.\n\n"
    },
    {
      "title": "Impossible d'accéder au module du noyau KVM : Permission refusée",
      "level": 3,
      "content": "Si vous rencontrez l'erreur suivante :\n\n```\nlibvirtError : internal error : process exited while connecting to monitor : Could not access KVM kernel module : Permission refusée failed to initialize KVM : Permission refusée\n```\n\nSystemd 234 attribue un ID dynamique pour le groupe kvm (consultez FS#54943). Pour éviter cette erreur, vous devez éditer le fichier /etc/libvirt/qemu.conf et changer la ligne avec group = \"78\" en group = \"kvm\".\n\n"
    },
    {
      "title": "\"System Thread Exception Not Handled\" lors du démarrage d'une VM Windows",
      "level": 3,
      "content": "Les invités Windows 8 ou Windows 10 peuvent soulever une exception de compatibilité générique au démarrage, à savoir \"System Thread Exception Not Handled\", qui tend à être causée par des pilotes hérités agissant étrangement sur des machines réelles. Sur les machines KVM, ce problème peut généralement être résolu en définissant le modèle de CPU sur core2duo.\n\n"
    },
    {
      "title": "Certains jeux/applications Windows se plantent/provoquent un écran bleu",
      "level": 3,
      "content": "Il arrive que des applications exécutées dans la VM se plantent de manière inattendue, alors qu'elles fonctionneraient normalement sur une machine physique. Si, lors de l'exécution de dmesg -wH en tant que root, vous rencontrez une erreur mentionnant MSR, la raison de ces plantages est que KVM injecte une General protection fault (GPF) lorsque l'invité tente d'accéder à des Model-specific registers non pris en charge. (MSRs) - cela entraîne souvent le plantage des applications/OS invités. Un certain nombre de ces problèmes peuvent être résolus en passant l'option ignore_msrs=1 au module KVM, qui ignorera les MSRs non implémentés.\n\n```\n/etc/modprobe.d/kvm.conf\n```\n\n```\n...\noptions kvm ignore_msrs=1\n...\n```\n\nCas où l'ajout de cette option peut aider :\n\n- GeForce Experience se plaignant de la présence d'un CPU non pris en charge.\n- StarCraft 2 et L.A. Noire affichent un écran bleu fiable sous Windows 10 avec KMODE_EXCEPTION_NOT_HANDLED. Les informations de l'écran bleu n'identifient pas de fichier pilote dans ces cas.\n\n"
    },
    {
      "title": "Les applications dans la VM subissent des retards importants ou prennent beaucoup de temps à démarrer",
      "level": 3,
      "content": "Cela peut être dû à une entropie disponible insuffisante dans la VM. Envisagez d'autoriser l'invité à accéder au pool d'entropie des hôtes en ajoutant un VirtIO RNG device à la VM, ou en installant un daemon de génération d'entropie tel que Haveged.\n\nAnecdotiquement, OpenSSH prend un certain temps avant de commencer à accepter des connexions lorsque l'entropie est insuffisante, sans que les journaux ne révèlent pourquoi.\n\n"
    },
    {
      "title": "Latence élevée des interruptions et microstuttering",
      "level": 3,
      "content": "Ce problème se manifeste par de petites pauses (bégaiements) et est particulièrement visible dans les applications à forte intensité graphique, comme les jeux.\n\n- L'une des causes est les fonctions d'économie d'énergie du processeur, qui sont contrôlées par la modification de la fréquence du processeur. Changez cette valeur en performance pour tous les cœurs du processeur.\n- Une autre cause possible est les entrées PS/2. Passez des entrées PS/2 aux entrées Virtio, consultez PCI passthrough via OVMF#Passing keyboard/mouse via Evdev.\n\n"
    },
    {
      "title": "La vidéo QXL cause une basse résolution",
      "level": 3,
      "content": "QEMU 4.1.0 a introduit une régression où la vidéo QXL peut retomber à de basses résolutions, lorsqu'elle est affichée via spice. [4] Par exemple, lorsque KMS démarre, la résolution du texte peut devenir aussi basse que 4x10 caractères. Lorsque vous essayez d'augmenter la résolution de l'interface graphique, elle peut passer à la résolution la plus faible prise en charge.\n\nComme solution de contournement, créez votre périphérique sous cette forme :\n\n```\n-device qxl-vga,max_outputs=1...\n```\n\n"
    },
    {
      "title": "Hang pendant VM initramfs",
      "level": 3,
      "content": "Linux 5.2.11 a introduit une régression KVM où, dans certaines circonstances, une VM peut se bloquer de manière permanente pendant la phase de démarrage précoce, lorsque l'initramfs est chargé ou exécuté. [5] Linux 5.3 a corrigé la régression. L'hôte montre que qemu utilise 100% du CPU * nombre de CPU virtuels. Le cas rapporté est celui d'un hôte utilisant l'hyperthreading, et d'une VM à qui l'on donne plus que les nproc}/2 CPU virtuels de l'hôte. On ignore quelles circonstances exactes déclenchent la suppression d'une région de mémoire par l'un des threads pour provoquer ce problème. Les solutions de contournement sont les suivantes :\n\n- Mettre à jour vers Linux 5.3.\n- Mise à jour vers Linux 5.2.10.\n- Jusqu'à ce que le problème soit résolu, essayez de ne pas donner à la VM plus que les nproc/2 CPU virtuels de l'hôte.\n- Compilation personnalisée de Linux, rétablissement du commit 2ad350fb4c (notez que cela réintroduit une régression déclenchée lors de la suppression d'un memslot).\n\n"
    },
    {
      "title": "La VM ne démarre pas lorsqu'on utilise un OVMF activé par Secure Boot",
      "level": 3,
      "content": "/usr/share/edk2-ovmf/x64/OVMF_CODE.secboot.fd de edk2-ovmf est construit avec le support SMM. Si le support S3 n'est pas pris en charge dans la VM, la VM peut ne pas démarrer du tout.\n\nAjoutez l'option -global ICH9-LPC.disable_s3=1 à la commande qemu.\n\nConsultez FS#59465 et https://github.com/tianocore/edk2/blob/master/OvmfPkg/README pour plus de détails et les options requises pour utiliser Secure Boot dans QEMU.\n\n"
    },
    {
      "title": "Les interruptions du CPU invité ne se déclenchent pas",
      "level": 3,
      "content": "Si vous écrivez votre propre système d'exploitation en suivant le OSDev wiki, ou si vous vous promenez simplement dans le code d'assemblage de l'architecture invitée en utilisant l'interface gdb de QEMU en utilisant l'option -s, il est utile de savoir que de nombreux émulateurs, y compris QEMU, implémentent généralement certaines interruptions du CPU laissant de nombreuses interruptions matérielles non implémentées. Une façon de savoir si votre code déclenche une interruption, est d'utiliser :\n\n```\n-d int\n```\n\npour activer l'affichage des interruptions/exceptions sur stdout.\n\nPour consulter les autres fonctionnalités de débogage des invités que QEMU a à offrir, consultez :\n\n```\nqemu-system-x86_64 -d help\n```\n\nou remplacez x86_64 par l'architecture invitée de votre choix.\n\n"
    },
    {
      "title": "Voir aussi",
      "level": 2,
      "content": "- Site web officiel de QEMU\n- Site officiel de KVM\n- Documentation utilisateur de l'émulateur QEMU\n- QEMU Wikibook\n- Hardware virtualization with QEMU par AlienBOB (dernière mise à jour en 2008)\n- Construire une armée virtuelle par Falconindy\n- Derniers docs\n- QEMU sous Windows\n- Wikipedia\n- Debian Wiki - QEMU\n- La mise en réseau de QEMU sur gnome.org[dead link 2022-09-22 ⓘ]\n- Mise en réseau de systèmes BSD virtuels avec QEMU\n- QEMU sur gnu.org\n- QEMU sur FreeBSD en tant qu'hôte\n- Guide d'optimisation des machines virtuelles KVM/QEMU Virtio et SSD[dead link 2025-04-06 ⓘ]\n- Gérer les machines virtuelles avec QEMU - documentation openSUSE[dead link 2024-07-30 ⓘ].\n- KVM sur le centre de connaissances IBM * KVM sur le centre de connaissances IBM.\n\n"
    }
  ]
}