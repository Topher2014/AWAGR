{
  "title": "Постоянные имена для блочных устройств",
  "url": "https://wiki.archlinux.org/title/%D0%9F%D0%BE%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%BD%D1%8B%D0%B5_%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0_%D0%B4%D0%BB%D1%8F_%D0%B1%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85_%D1%83%D1%81%D1%82%D1%80%D0%BE%D0%B9%D1%81%D1%82%D0%B2",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- fstab (Русский)\n- udev (Русский)\n- LVM\n\nЭта статья описывает, как использовать постоянные имена для ваших блочных устройств. Это стало возможным благодаря введению udev и имеет переимущества перед именами, основанными на используемых шинах. Если на вашем компьютере несколько контроллеров дисков SATA, SCSI или IDE, порядок добавления устройств может быть любым. Это может привести к тому, что устройства наподобие /dev/sda и /dev/sdb будут меняться местами при каждой загрузке, что может привести к невозможности загрузки системы, панике ядра или исчезновению блочного устройства. Использование постоянных имён решает подобные проблемы.\n\n- Постоянные имена имеют ограничения, которые выходят за рамки данной статьи. Например, в то время как mkinitcpio может поддерживать метод, systemd может налагать свои собственные ограничения (например, FS#42884) на имена, которые он может обрабатывать во время загрузки.\n- Эта статья не относится к LVM, так как пути /dev/VolumeGroupName/LogicalVolumeName являются постоянными.\n\n"
    },
    {
      "title": "Методы постоянного именования",
      "level": 2,
      "content": "Есть четыре схемы создания постоянных имён: by-label, by-uuid, by-id и by-path. Для дисков, использующих таблицу разделов GUID (GPT), также доступны by-partlabel и by-partuuid. Также можно задать #Постоянные имена устройств с использованием udev.\n\nПодкаталоги внутри /dev/disk/ создаются и удаляются автоматически в соответствии с подключенными в данный момент устройствами.\n\nВ следующих разделах описываются различные методы постоянного именования и способы их использования.\n\nМожно использовать команду lsblk для просмотра первых постоянных схем:\n\n```\n$ lsblk -f\n```\n\n```\nNAME        FSTYPE LABEL      UUID                                 MOUNTPOINT\nsda                                                       \n├─sda1      vfat              CBB6-24F2                            /boot\n├─sda2      ext4   Arch Linux 0a3407de-014b-458b-b5c1-848e92a327a3 /\n├─sda3      ext4   Data       b411dc99-f0a0-4c87-9e05-184977be8539 /home\n└─sda4      swap              f9fe0b69-a280-415d-a03a-a32752370dee [SWAP]\nmmcblk0\n└─mmcblk0p1 vfat              F4CA-5D75\n```\n\nДля GPT используйте команду blkid. Она более удобна для скриптов, но читается труднее.\n\n```\n# blkid\n```\n\n```\n/dev/sda1: UUID=\"CBB6-24F2\" TYPE=\"vfat\" PARTLABEL=\"EFI system partition\" PARTUUID=\"d0d0d110-0a71-4ed6-936a-304969ea36af\" \n/dev/sda2: LABEL=\"Arch Linux\" UUID=\"0a3407de-014b-458b-b5c1-848e92a327a3\" TYPE=\"ext4\" PARTLABEL=\"GNU/Linux\" PARTUUID=\"98a81274-10f7-40db-872a-03df048df366\" \n/dev/sda3: LABEL=\"Data\" UUID=\"b411dc99-f0a0-4c87-9e05-184977be8539\" TYPE=\"ext4\" PARTLABEL=\"Home\" PARTUUID=\"7280201c-fc5d-40f2-a9b2-466611d3d49e\" \n/dev/sda4: UUID=\"f9fe0b69-a280-415d-a03a-a32752370dee\" TYPE=\"swap\" PARTLABEL=\"Swap\" PARTUUID=\"039b6c1c-7553-4455-9537-1befbc9fbc5b\"\n/dev/mmcblk0: PTUUID=\"0003e1e5\" PTTYPE=\"dos\"\n/dev/mmcblk0p1: UUID=\"F4CA-5D75\" TYPE=\"vfat\" PARTUUID=\"0003e1e5-01\"\n```\n\n"
    },
    {
      "title": "by-label",
      "level": 3,
      "content": "Почти каждый тип файловой системы позволяет задать метку. Все разделы с метками есть в каталоге /dev/disk/by-label.\n\n```\n$ ls -l /dev/disk/by-label\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 Data -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 Arch\\x20Linux -> ../../sda2\n```\n\nБольшинство файловых систем поддерживают установку метки при создании файловой системы; смотрите справочные страницы соответствующих утилит mkfs.*. Для некоторых файловых систем также возможно изменение меток. Ниже приведены некоторые методы изменения меток в распространённых файловых системах:\n\nУзнать метку устройства можно с помощью lsblk:\n\n```\n$ lsblk -dno LABEL /dev/sda2\n```\n\n```\nArch Linux\n```\n\nИли blkid:\n\n```\n# blkid -s LABEL -o value /dev/sda2\n```\n\n```\nArch Linux\n```\n\n- Файловая система не должна быть примонтирована при изменении метки. Для изменения метки корневой файловой системы нужно загрузиться с другого тома.\n- Метки должны быть однозначными, чтобы предотвратить любые возможные конфликты.\n- Метки могут содержать до 16 символов.\n- Поскольку метка является свойством файловой системы, она не подходит для постоянной адресации одного устройства RAID.\n- При использовании зашифрованных контейнеров с dm-crypt метки файловых систем внутри контейнеров недоступны, пока контейнер заблокирован/зашифрован.\n\n"
    },
    {
      "title": "by-uuid",
      "level": 3,
      "content": "UUID — это механизм присвоения каждой файловой системе уникального идентификатора. Эти идентификаторы генерируются утилитами файловой системы (например, mkfs.*) при форматировании устройства и разработаны таким образом, что случайные совпадения разных идентификаторов маловероятны. Все файловые системы GNU/Linux (включая подкачку и LUKS-заголовки устройств с шифрованием) поддерживают UUID. Файловые системы FAT, exFAT и NTFS не поддерживают UUID, но отображаются в /dev/disk/by-uuid/ с более коротким UID (уникальным идентификатором):\n\n```\n$ ls -l /dev/disk/by-uuid/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 0a3407de-014b-458b-b5c1-848e92a327a3 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 b411dc99-f0a0-4c87-9e05-184977be8539 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 CBB6-24F2 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 f9fe0b69-a280-415d-a03a-a32752370dee -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 F4CA-5D75 -> ../../mmcblk0p1\n```\n\nУзнать UUID устройства можно с помощью lsblk:\n\n```\n$ lsblk -dno UUID /dev/sda1\n```\n\n```\nCBB6-24F2\n```\n\nИли blkid:\n\n```\n# blkid -s UUID -o value /dev/sda1\n```\n\n```\nCBB6-24F2\n```\n\nПреимущество использования метода UUID в том, что вероятность возникновения конфликтов гораздо меньше, чем при использовании меток. Кроме того, он генерируется автоматически при создании файловой системы. Например, он останется уникальным, даже если устройство подключено к другой системе (которая может иметь собственное устройство с такой же меткой).\n\nНедостатком является то, что UUID затрудняют чтение длинных строк кода и нарушают форматирование во многих файлах конфигурации (например, fstab или crypttab). Кроме того, каждый раз при форматировании создаётся новый UUID, и файлы конфигурации придётся обновлять вручную.\n\n"
    },
    {
      "title": "by-id и by-path",
      "level": 3,
      "content": "by-id создаёт уникальное имя по серийному номеру оборудования, by-path по кратчайшему физическому пути (согласно sysfs). Оба содержат строки, указывающие, к какой подсистеме они принадлежат (т. е. pci- для by-path и ata- для by-id), поэтому они связаны с аппаратным обеспечением, управляющим устройством. Это подразумевает разные уровни постоянности: by-path изменится при подключении устройства к другому порту контроллера, by-id изменится при подключении устройства к порту аппаратного контроллера, связанного с другой подсистемой. [1] Таким образом, оба не подходят для достижения постоянного именования, устойчивого к аппаратным изменениям.\n\nОднако оба они предоставляют важную информацию для поиска конкретного устройства в большой аппаратной инфраструктуре. Например, если вы не назначаете постоянные метки вручную (by-label или by-partlabel) и сохраняете каталог с использованием аппаратного порта, by-id и by-path можно использовать для поиска определённого устройства. [2] [3]\n\nby-id также создаёт ссылки World Wide Name для устройств, которые его поддерживают. В отличие от других ссылок by-id, WWN полностью постоянны и не изменяются в зависимости от используемой подсистемы.\n\n```\n$ ls -l /dev/disk/by-id/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470 -> ../../sda\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part1 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part2 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part3 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 ata-WDC_WD2500BEVT-22ZCT0_WD-WXE908VF0470-part4 -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 mmc-SD32G_0x0040006d -> ../../mmcblk0\nlrwxrwxrwx 1 root root 10 May 27 23:31 mmc-SD32G_0x0040006d-part1 -> ../../mmcblk0p1\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f -> ../../sda\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part1 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part2 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part3 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 wwn-0x60015ee0000b237f-part4 -> ../../sda4\n```\n\n```\n$ ls -l /dev/disk/by-path/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1 -> ../../sda\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part1 -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part2 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part3 -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:00:1f.2-ata-1-part4 -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:07:00.0-platform-rtsx_pci_sdmmc.0 -> ../../mmcblk0\nlrwxrwxrwx 1 root root 10 May 27 23:31 pci-0000:07:00.0-platform-rtsx_pci_sdmmc.0-part1 -> ../../mmcblk0p1\n```\n\n"
    },
    {
      "title": "by-partlabel",
      "level": 3,
      "content": "GPT позволяет указывать метки для разделов.\n\nЭто похоже на метки файловой системы, но метки разделов не изменяются при изменении файловой системы на разделе.\n\nВсе разделы, имеющие метки разделов, указаны в каталоге /dev/disk/by-partlabel.\n\n```\n$ ls -l /dev/disk/by-partlabel/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 EFI\\x20system\\x20partition -> ../../sda1\nlrwxrwxrwx 1 root root 10 May 27 23:31 GNU\\x2fLinux -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 Home -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 Swap -> ../../sda4\n```\n\nУзнать метку раздела можно с помощью lsblk:\n\n```\n$ lsblk -dno PARTLABEL /dev/sda1\n```\n\n```\nEFI system partition\n```\n\nИли blkid:\n\n```\n# blkid -s PARTLABEL -o value /dev/sda1\n```\n\n```\nEFI system partition\n```\n\n- Метки разделов GPT также должны быть разными, чтобы избежать конфликтов. Чтобы изменить метку раздела, вы можете использовать gdisk или cgdisk из пакета gptfdisk. Смотрите Разметка дисков#Инструменты разметки.\n- Согласно спецификации, метки разделов GPT могут иметь длину до 72 символов.\n\n"
    },
    {
      "title": "by-partuuid",
      "level": 3,
      "content": "Каждый раздел в GPT имеет свой UUID, не привязанный к файловой системе.\n\nMBR не поддерживает UUID разделов, но Linux[4] и программы, использующие libblkid[5] (например, udev[6]), способны генерировать псевдо-PARTUUID для разделов MBR. Формат — SSSSSSSS-PP, где SSSSSSSS — дополненная нулями 32-битная сигнатура диска MBR, а PP — дополненный нулями номер раздела в шестнадцатеричной форме. В отличие от обычного PARTUUID раздела GPT, псевдо-PARTUUID MBR может измениться при изменении номера раздела.\n\nДинамический каталог аналогичен другим методам и, как в случае с UUID файловой системы, использование UUID разделов предпочтительнее, чем меток.\n\n```\n$ ls -l /dev/disk/by-partuuid/\n```\n\n```\ntotal 0\nlrwxrwxrwx 1 root root 10 May 27 23:31 0003e1e5-01 -> ../../mmcblk0p1\nlrwxrwxrwx 1 root root 10 May 27 23:31 039b6c1c-7553-4455-9537-1befbc9fbc5b -> ../../sda4\nlrwxrwxrwx 1 root root 10 May 27 23:31 7280201c-fc5d-40f2-a9b2-466611d3d49e -> ../../sda3\nlrwxrwxrwx 1 root root 10 May 27 23:31 98a81274-10f7-40db-872a-03df048df366 -> ../../sda2\nlrwxrwxrwx 1 root root 10 May 27 23:31 d0d0d110-0a71-4ed6-936a-304969ea36af -> ../../sda1\n```\n\nУзнать UUID раздела можно с помощью lsblk:\n\n```\n$ lsblk -dno PARTUUID /dev/sda1\n```\n\n```\nd0d0d110-0a71-4ed6-936a-304969ea36af\n```\n\nИли blkid:\n\n```\n# blkid -s PARTUUID -o value /dev/sda1\n```\n\n```\nd0d0d110-0a71-4ed6-936a-304969ea36af\n```\n\n"
    },
    {
      "title": "Постоянные имена устройств с использованием udev",
      "level": 3,
      "content": "Смотрите udev (Русский)#Установка постоянных имен устройств.\n\n"
    },
    {
      "title": "Использование постоянных имён",
      "level": 2,
      "content": "Существуют различные приложения, которые можно настроить с использованием постоянных имён. Ниже приведены некоторые примеры их настройки.\n\n"
    },
    {
      "title": "fstab",
      "level": 3,
      "content": "Смотрите fstab (Русский)#Определение файловой системы.\n\n"
    },
    {
      "title": "Параметры ядра",
      "level": 3,
      "content": "Чтобы использовать постоянные имена в параметрах ядра, должны быть выполнены следующие предварительные условия. При стандартной установке в соответствии с руководством по установке оба условия выполняются:\n\n- Используется образ initramfs, в котором есть udev.\n- Для mkinitcpio включен хук udev или systemd в /etc/mkinitcpio.conf.\n\nРасположение корневой файловой системы задаётся параметром root в командной строке ядра. Командная строка ядра настраивается из загрузчика, смотрите Параметры ядра#Настройка. Чтобы перейти к использованию постоянных имён устройств, измените те параметры, которые определяют блочные устройства, например root и resume, оставив остальные параметры как есть. Поддерживаются различные схемы именования:\n\nC использованием метки и формата LABEL=, в этом примере Arch Linux — это метка корневой файловой системы.\n\n```\nroot=\"LABEL=Arch Linux\"\n```\n\nС использованием UUID и формата UUID=, в этом примере 0a3407de-014b-458b-b5c1-848e92a327a3 — это UUID корневой файловой системы.\n\n```\nroot=UUID=0a3407de-014b-458b-b5c1-848e92a327a3\n```\n\nС использованием id диска и пути в /dev, в данном примере wwn-0x60015ee0000b237f-part2 — это id корневого раздела.\n\n```\nroot=/dev/disk/by-id/wwn-0x60015ee0000b237f-part2\n```\n\nС использованием UUID разделов GPT и формата PARTUUID=, в данном примере 98a81274-10f7-40db-872a-03df048df366 — это PARTUUID корневого раздела.\n\n```\nroot=PARTUUID=98a81274-10f7-40db-872a-03df048df366\n```\n\nС использованием меток разделов GPT и формата PARTLABEL=, в данном примере GNU/Linux — это метка корневого раздела.\n\n```\nroot=\"PARTLABEL=GNU/Linux\"\n```\n\n"
    }
  ]
}