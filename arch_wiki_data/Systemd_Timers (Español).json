{
  "title": "Systemd/Timers (Español)",
  "url": "https://wiki.archlinux.org/title/Systemd/Timers_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2018-11-21** \n\nArtículos relacionados\n\n- systemd (Español)\n- systemd/User (Español)\n- systemd FAQ (Español)\n- cron\n\nLos temporizadores son archivos de unidad de systemd (Español) cuyo nombre termina en .timer que controlan archivos .service o eventos. Los temporizadores se pueden usar como una alternativa a cron (lea #Como un reemplazo de cron). Los temporizadores tienen soporte incorporado para ejecutar eventos basados en el calendario, eventos de tiempo monotónicos y se pueden ejecutar de forma asíncrona.\n\n"
    },
    {
      "title": "Unidades de temporizador",
      "level": 2,
      "content": "Los temporizadores son archivos de unidades de systemd terminados en un sufijo .timer. Los temporizadores son como cualquier otro arcivo de configuración de unidad y se cargan desde las mismas rutas, pero incluyen una sección [Timer] que define cuándo y cómo se activa el temporizador. Los temporizadores se definen como uno de estos dos tipos:\n\n- Temporizadores en tiempo real (también conocido como «wallclock timers») se activan con un evento del calendario, de la misma manera que lo hacen los cronjobs. La opción OnCalendar= se utiliza para definirlos.\n- Temporizadores monotónicos se activan después de un intervalo de tiempo condicionado a un punto de inicio variable. Se detienen si el equipo está temporalmente suspendido o apagado. Hay varios temporizadores monotónicos diferentes, pero todos tienen la forma: OnTypeSec=. Los temporizadores monotónicos comunes incluyen OnBootSec y OnActiveSec.\n\nPara obtener una explicación completa de las opciones del temporizador, consulte systemd.timer(5). La sintaxis de los argumentos para los eventos del calendario y los intervalos de tiempo se definen en systemd.time(7).\n\n"
    },
    {
      "title": "Unidad de servicio",
      "level": 2,
      "content": "Para cada archivo .timer, existe un archivo .service coincidente (por ejemplo, foo.timer y foo.service). El archivo .timer activa y controla el archivo .service. El archivo .service no requiere una sección [Install] ya que son las unidades de temporizador las que se activan. Si es necesario, es posible controlar una unidad con un nombre diferente usando la opción Unit= en la sección [Timer] del archivo temporizador.\n\n"
    },
    {
      "title": "Gestión",
      "level": 2,
      "content": "Para usar una unidad temporizador active e inicie la misma como cualquier otra unidad (recuerde agregar el sufijo .timer). Para ver todos los temporizadores iniciados, ejecute:\n\n```\n$ systemctl list-timers\n```\n\n```\nNEXT                          LEFT        LAST                          PASSED     UNIT                         ACTIVATES\nThu 2014-07-10 19:37:03 CEST  11h left    Wed 2014-07-09 19:37:03 CEST  12h ago    systemd-tmpfiles-clean.timer systemd-tmpfiles-clean.service\nFri 2014-07-11 00:00:00 CEST  15h left    Thu 2014-07-10 00:00:13 CEST  8h ago     logrotate.timer              logrotate.service\n```\n\n- Para enumerar todos los temporizadores (incluido inactivos), use systemctl list-timers --all.\n- El estado de un servicio iniciado por un temporizador probablemente aparecerá inactivo a menos que se esté activando en ese momento.\n- Si un temporizador se desincroniza, puede ayudar eliminar su archivo stamp-* en /var/lib/systemd/timers (o ~/.local/share/systemd/ en caso de temporizadores de usuario). Estos son archivos de longitud cero que marcan la última vez que se ejecutó cada temporizador. Si se eliminan, se reconstruirán en el próximo inicio de su temporizador.\n\n"
    },
    {
      "title": "Ejemplos",
      "level": 2,
      "content": "Un archivo de unidad de servicio se puede programar con un temporizador listo para usar. Los siguientes ejemplos programan que el servicio, foo.service, se ejecutará con el temporizador correspondiente llamado foo.timer.\n\n"
    },
    {
      "title": "Temporizador monotónico",
      "level": 3,
      "content": "Un temporizador que se iniciará 15 minutos después del arranque y nuevamente cada semana mientras el sistema se está ejecutando.\n\n```\n/etc/systemd/system/foo.timer\n```\n\n```\n[Unit]\nDescription=Run foo weekly and on boot\n\n[Timer]\nOnBootSec=15min\nOnUnitActiveSec=1w \n\n[Install]\nWantedBy=timers.target\n```\n\n"
    },
    {
      "title": "Temporizador en tiempo real",
      "level": 3,
      "content": "Un temporizador que comienza una vez a la semana (a las 12:00 AM del lunes). Cuando se activa, activa el servicio inmediatamente si se perdió la última hora de inicio (opción Persistent=true), por ejemplo, debido a que el sistema estaba apagado:\n\n```\n/etc/systemd/system/foo.timer\n```\n\n```\n[Unit]\nDescription=Run foo weekly\n\n[Timer]\nOnCalendar=weekly\nPersistent=true\n\n[Install]\nWantedBy=timers.target\n```\n\nCuando se requieren fechas y horas más específicas, los eventos de OnCalendar utilizan el siguiente formato:\n\n```\nDayOfWeek Year-Month-Day Hour:Minute:Second\n```\n\nes decir:\n\n```\nDíadelaSemana Año-Mes-Día Hora:Minuto:Segundo\n```\n\nSe puede usar un asterisco para especificar cualquier valor y se pueden usar comas para listar posibles valores. Dos valores separados por .. indica un rango contiguo.\n\nEn el ejemplo siguiente, el servicio se ejecuta los primeros cuatro días de cada mes a las 12:00 PM, pero solo si ese día es lunes o martes.\n\n```\nOnCalendar=Mon,Tue *-*-01..04 12:00:00\n```\n\nPara ejecutar un servicio el primer sábado de cada mes, use:\n\n```\nOnCalendar=Sat *-*-1..7 18:00:00\n```\n\nAl usar DayOfWeek, se debe especificar, al menos, un día de la semana. Si quiere algo para ejecutar todos los días a las 4 AM, utilice:\n\n```\nOnCalendar=*-*-* 4:00:00\n```\n\nPara ejecutar un servicio en diferentes momentos, OnCalendar puede especificarse más de una vez. En el siguiente ejemplo, el servicio se ejecuta a las 22:30 los días entre fines de semana y a las 20:00 los fines de semana.\n\n```\nOnCalendar=Mon..Fri 22:30\n OnCalendar=Sat,Sun 20:00\n```\n\nDispone de más información en systemd.time(7).\n\n- OnCalendar se puede probar para verificar su funcionamiento y para calcular la próxima vez en que se producirá la condición suspensiva para el caso de que se utilice una unidad de temporizador con calendar de la utilidad systemd-analyse. Por ejemplo, se puede usar systemd-analyze calendar weekly o systemd-analyze calendar \"Mon,Tue *-*-01..04 12:00:00\".\n- La orden faketime es especialmente útil para probar varios escenarios con la orden anterior; viene con el paquete libfaketime.\n- Expresiones de eventos especiales como daily y weekly hacen referencia a horas de inicio específicas y, por lo tanto, cualquier temporizador que comparta dichos eventos de calendario se iniciará simultáneamente. Los temporizadores que comparten eventos de inicio pueden provocar un rendimiento deficiente del sistema si los servicios de los temporizadores compiten por los recursos del sistema. La opción RandomizedDelaySec en la sección [Timer] evita este problema al alternar aleatoriamente la hora de inicio de cada temporizador. Vea systemd.timer(5).\n\n"
    },
    {
      "title": "Unidades .timer transitorias",
      "level": 2,
      "content": "Se puede utilizar systemd-run para crear unidades .timer transitorias. Es decir, se puede configurar una orden para que se ejecute a una hora específica sin tener un archivo de servicio. Por ejemplo, la siguiente orden muestra un archivo después de 30 segundos:\n\n```\n# systemd-run --on-active=30 /bin/touch /tmp/foo\n```\n\nTambién se puede especificar un archivo de servicio preexistente que no tiene un archivo de temporizador. Por ejemplo, lo siguiente inicia la unidad systemd llamada someunit.service después de que hayan transcurrido 12 horas y media:\n\n```\n# systemd-run --on-active=\"12h 30m\" --unit someunit.service\n```\n\nVéase systemd-run(1) para más información y ejemplos.\n\n"
    },
    {
      "title": "Como un reemplazo de cron",
      "level": 2,
      "content": "Aunque cron es posiblemente el planificador de trabajos más conocido, los temporizadores de systemd pueden ser una alternativa.\n\n"
    },
    {
      "title": "Beneficios",
      "level": 3,
      "content": "Los principales beneficios de usar temporizadores provienen del hecho de que cada trabajo tiene su propio servicio systemd. Algunos de estos beneficios son:\n\n- Los trabajos pueden iniciarse fácilmente independientemente de sus temporizadores. Esto simplifica la depuración de errores.\n- Cada trabajo puede configurarse para ejecutarse en un entorno específico (consulte systemd.exec(5)).\n- Los trabajos se pueden adjuntar a grupos de control.\n- Los trabajos se pueden configurar para que dependan de otras unidades de systemd.\n- Los trabajos se registran en el journal de systemd para una fácil depuración de errores.\n\n"
    },
    {
      "title": "Advertencias",
      "level": 3,
      "content": "Algunas cosas que son fáciles de hacer con cron son difíciles de hacer solo con unidades de temporizador:\n\n- Creación: para configurar un trabajo temporizado con systemd necesita crear dos archivos y ejecutar órdenes systemctl, en comparación con crontab que basta con agregar una sola línea.\n- Correos electrónicos: no hay un equivalente incorporado a MAILTO de cron para enviar correos electrónicos en el caso de que falle el trabajo. Consulte la siguiente sección para ver un ejemplo de cómo configurar una funcionalidad similar utilizando OnFailure=.\n\n"
    },
    {
      "title": "MAILTO",
      "level": 3,
      "content": "Puede configurar systemd para enviar un correo electrónico cuando falla una unidad. Cron envía un correo a MAILTO si el trabajo da una salida stdout o stderr, aunque muchos trabajos se pueden configurar para generar solo un error. Primero, necesita dos archivos: un ejecutable para enviar el correo y un .service para iniciar el ejecutable. Para este ejemplo, el ejecutable es solo un script de intérprete de órdenes que usa sendmail:\n\n```\n/usr/local/bin/systemd-email\n```\n\n```\n#!/bin/bash\n\n/usr/bin/sendmail -t <<ERRMAIL\nTo: $1\nFrom: systemd <root@$HOSTNAME>\nSubject: $2\nContent-Transfer-Encoding: 8bit\nContent-Type: text/plain; charset=UTF-8\n\n$(systemctl status --full \"$2\")\nERRMAIL\n```\n\nCualquiera que sea el ejecutable que utilice, probablemente debería tomar, al menos, dos argumentos, como lo hace este script de intérprete de órdenes: la dirección a la que enviar el correo y el archivo de la unidad para obtener el estado (de no entregado). El .service que creamos pasará estos argumentos:\n\n```\n/etc/systemd/system/status-email-user@.service\n```\n\n```\n[Unit]\nDescription=status email for %i to user\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/systemd-email address %i\nUser=nobody\nGroup=systemd-journal\n```\n\nDonde user es el usuario que recibe el correo electrónico y address es la dirección de correo electrónico de ese usuario. Aunque el receptor esté codificado, el archivo de unidad sobre el que se informa se pasa como un parámetro de instancia, por lo que este servicio puede enviar correo electrónico para muchas otras unidades. En este punto, puede iniciar status-email-user@dbus.service para verificar que puede recibir los correos electrónicos.\n\nLuego simplemente edite el servicio para el que desea correos electrónicos y agregue OnFailure=status-email-user@%n.service a la sección [Unit]. %n pasa el nombre de la unidad a la plantilla.\n\n- Si configura la seguridad sSMTP de acuerdo con sSMTP#Security, el usuario nobody no tendrá acceso a /etc/ssmtp/ssmtp.conf, y la orden systemctl start status-email-user@dbus.service fallará. Una solución para ello es usar root como User en la unidad status-email-user@.service.\n- Si intenta utilizar mail -s somelogs address en su script de correo electrónico, mail se bifurcará y systemd interrumpirá el proceso de correo cuando vea su script salir. Haga que el correo no se bifurque con mail -Ssendwait -s somelogs address.\n\n"
    },
    {
      "title": "Utilizar un crontab",
      "level": 3,
      "content": "Se pueden solucionar varias de las advertencias descritas arriba mediante la instalación de un paquete que pase un crontab tradicional para configurar los temporizadores. systemd-cron-nextAUR[enlace roto: package not found] y systemd-cronAUR son dos de estos paquetes. Estos pueden proporcionar la característica MAILTO que falta.\n\nAdemás, al igual que con crontabs, se puede obtener una vista unificada de todos los trabajos programados con systemctl. Véase #Gestión.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- systemd.timer(5)\n- Página wiki del Proyecto Fedora sobre los temporizadores basados en el calendario de systemd\n- Sección de la wiki de Gentoo sobre los servicios temporizadores de systemd\n- systemd-cron-next — herramienta para generar temporizadores/servicios desde archivos crontab y anacrontab\n\n- systemd-cron — proporciona unidades systemd para ejecutar scripts de cron; utilizando systemd-crontab-generator para convertir crontabs\n\n"
    }
  ]
}