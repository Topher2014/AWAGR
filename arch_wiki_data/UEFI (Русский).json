{
  "title": "UEFI (Русский)",
  "url": "https://wiki.archlinux.org/title/UEFI_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Системный раздел EFI\n- Процесс загрузки Arch\n- Таблица разделов GUID\n- Secure Boot\n- Unified kernel image\n\nUnified Extensible Firmware Interface (UEFI, преемник EFI) — интерфейс между операционной системой и прошивкой устройства. Он обеспечивает стандартную среду для загрузки операционной системы и запуска предзагрузочных приложений.\n\nОн вводит новый способ загрузки операционных систем, который отличается от обычного «загрузочного кода MBR», который использовался в системах BIOS. Различия в процессе загрузки описаны в статье Процесс загрузки Arch. Установка загрузчиков UEFI описана в разделе Процесс загрузки Arch#Загрузчик.\n\n"
    },
    {
      "title": "Версии UEFI",
      "level": 2,
      "content": "- UEFI начинался как EFI от Intel в версиях 1.x.\n- Позже группа компаний под названием UEFI Forum взяла на себя его разработку и переименовала в Unified EFI, начиная с версии 2.0.\n- Если не указано, что имеется в виду EFI 1.x, термины EFI и UEFI используются как взаимозаменяемые для обозначения прошивки UEFI 2.x.\n- Реализация EFI от Apple не является ни версией EFI 1.x, ни версией UEFI 2.x, а смешивает оба варианта. Этот вид прошивок не подпадает ни под одну из спецификаций (U)EFI и поэтому не является стандартной прошивкой UEFI. Если не указано явно, эти инструкции являются общими, и некоторые из них могут не работать или отличаться на устройствах Mac.\n\nСпецификацию последней версии UEFI можно найти на https://uefi.org/specifications.\n\n"
    },
    {
      "title": "Разрядность прошивки UEFI",
      "level": 2,
      "content": "В UEFI каждая программа, будь то загрузчик ОС или утилита (например, приложение для тестирования памяти или средство восстановления), должна быть EFI-приложением, архитектура которого должна совпадать с архитектурой прошивки UEFI.\n\nПодавляющее большинство прошивок UEFI, включая последние модели Apple Mac, используют прошивку UEFI x86_64. Единственными известными устройствами, использующими IA32 (32-битный) UEFI, являются старые (до 2008 года) Apple Mac, системы Intel Atom System-on-Chip (по состоянию на 2 ноября 2013 года)[1] и некоторые старые серверные платы Intel, которые, как известно, работают на прошивке Intel EFI 1.10.\n\nПрошивки x86_64 UEFI не имеют поддержки запуска 32-битных EFI-приложений (в отличие от x86_64 версий Linux и Windows, которые имеют такую поддержку). Поэтому EFI-приложение должно быть скомпилировано для конкретной разрядности/архитектуры процессора, на котором работает прошивка.\n\n"
    },
    {
      "title": "Проверка разрядности прошивки",
      "level": 3,
      "content": "Разрядность прошивки можно проверить из загруженной операционной системы.\n\n"
    },
    {
      "title": "Из Linux",
      "level": 4,
      "content": "В дистрибутивах с ядром Linux версии 4.0 или новее разрядность прошивки UEFI можно узнать через интерфейс sysfs. Выполните:\n\n```\n$ cat /sys/firmware/efi/fw_platform_size\n```\n\nЭто вернёт 64 для 64-битного (x86_64) UEFI или 32 для 32-битного (IA32) UEFI. Если файл не существует, значит, вы загрузились не в режиме UEFI.\n\n"
    },
    {
      "title": "Из macOS",
      "level": 4,
      "content": "Mac, выпущенные до 2008 года, в основном имеют прошивку IA32 EFI, а выпущенные в 2008 или позднее — x86_64 EFI. Все Mac, способные работать с 64-битным ядром Mac OS X Snow Leopard, имеют прошивку x86_64 EFI 1.x.\n\nЧтобы узнать разрядность прошивки EFI в Mac, введите следующую команду в терминале Mac OS X:\n\n```\n$ ioreg -l -p IODeviceTree | grep firmware-abi\n```\n\nЕсли команда возвращает значение EFI32, то прошивка IA32 EFI (32-битная), а если значение EFI64 — прошивка x86_64 EFI (64-битная). Большинство Mac не имеют прошивку UEFI 2.x, так как реализация EFI от Apple не полностью совместима со спецификацией UEFI 2.x.\n\n"
    },
    {
      "title": "Из Microsoft Windows",
      "level": 4,
      "content": "64-битные версии Windows не поддерживают загрузку на 32-битном UEFI. Поэтому, если у вас 32-битная версия Windows, загруженная в режиме UEFI, у вас 32-битный UEFI.\n\nДля проверки разрядности запустите msinfo32.exe. В разделе Сведения о системе смотрите значения записей «Тип» и «Режим BIOS».\n\nДля 64-битного Windows и 64-битного UEFI будет Тип: Компьютер на базе x64 и Режим BIOS: UEFI. Для 32-битного Windows и 32-битного UEFI — Тип: Компьютер на базе x86 и Режим BIOS: UEFI. Если «Режим BIOS» имеет значение не UEFI, значит, Windows загружен не в режиме UEFI.\n\n"
    },
    {
      "title": "Конфигурация ядра Linux для UEFI",
      "level": 2,
      "content": "Необходимая конфигурация для ядра Linux[2] такова:\n\n```\nCONFIG_RELOCATABLE=y\nCONFIG_EFI=y\nCONFIG_EFI_STUB=y\nCONFIG_X86_SYSFB=y\nCONFIG_FB_SIMPLE=y\nCONFIG_FRAMEBUFFER_CONSOLE=y\n```\n\nПоддержка UEFI Runtime Variables (файловая система efivarfs — /sys/firmware/efi/efivars). Эта опция важна, так как нужна для работы с переменными времени выполнения UEFI с помощью инструментов вроде efibootmgr. Эта опция появилась в ядре 3.10.\n\n```\nCONFIG_EFIVAR_FS=y\n```\n\nПоддержка UEFI Runtime Variables (старый интерфейс efivars sysfs — /sys/firmware/efi/vars). Эта опция должна быть отключена, чтобы предотвратить возможные проблемы при одновременно включенных efivarfs и sysfs-efivars.\n\n```\nCONFIG_EFI_VARS=n\n```\n\nТаблица разделов GUID (GPT) — необходима для поддержки UEFI\n\n```\nCONFIG_EFI_PARTITION=y\n```\n\nПоддержка EFI mixed-mode — для загрузки 64-битного ядра на 32-битной прошивке UEFI.\n\n```\nCONFIG_EFI_MIXED=y\n```\n\n"
    },
    {
      "title": "Переменные UEFI",
      "level": 2,
      "content": "UEFI определяет переменные, через которые операционная система может взаимодействовать с прошивкой. Переменные загрузки UEFI используются загрузчиком и применяются ОС только для раннего запуска системы. Переменные времени выполнения (runtime variables) позволяют ОС управлять определёнными настройками прошивки, такими как менеджер загрузки UEFI или управление ключами для протокола UEFI Secure Boot и т. д. Вы можете получить список с помощью команды:\n\n```\n$ efivar --list\n```\n\n"
    },
    {
      "title": "Поддержка переменных UEFI в ядре Linux",
      "level": 3,
      "content": "Ядро Linux даёт пользовательскому пространству доступ к переменным UEFI через интерфейс efivarfs (EFI VARiable FileSystem) (CONFIG_EFIVAR_FS) — монтируется с помощью модуля ядра efivarfs в /sys/firmware/efi/efivars — не имеет ограничений на максимальный размер переменной и поддерживает переменные UEFI Secure Boot. Появилось в ядре 3.8.\n\n"
    },
    {
      "title": "Требования для поддержки переменных UEFI",
      "level": 3,
      "content": "1. Ядро должно быть загружено в режиме UEFI через EFISTUB (опционально с использованием менеджера загрузки) или загрузчиком UEFI, а не через BIOS или CSM, или Apple Boot Camp, который также является CSM.\n1. Ядро должно иметь поддержку EFI Runtime Services (CONFIG_EFI=y, проверить наличие можно командой zgrep CONFIG_EFI /proc/config.gz).\n1. EFI Runtime Services в ядре не должны быть отключены через командную строку ядра, то есть параметр noefi должен отсутствовать.\n1. Файловая система efivarfs должна быть смонтирована в /sys/firmware/efi/efivars, иначе следуйте разделу #Монтирование efivars ниже.\n1. efivar должен отобразить список переменных UEFI (опция -l/--list) без ошибок.\n\nЕсли поддержка переменных UEFI не работает даже после выполнения вышеуказанных условий, попробуйте следующие обходные пути:\n\n1. Если просмотр списка переменных UEFI (efivar -l) приводит к ошибке efivar: error listing variables: Function not implemented и система загружена в ядро реального времени, добавьте efi=runtime в параметры ядра и перезагрузитесь (efivarfs отключен по умолчанию на таких ядрах).\n1. Дополнительные шаги по устранению неполадок смотрите в разделе #Пользовательские инструменты не могут изменить переменные UEFI\n\n"
    },
    {
      "title": "Монтирование efivars",
      "level": 4,
      "content": "Если systemd не смонтировал efivarfs в /sys/firmware/efi/efivars автоматически, смонтируйте его вручную, чтобы у инструментов вроде efibootmgr появился доступ к переменным UEFI:\n\n```\n# mount -t efivarfs efivarfs /sys/firmware/efi/efivars\n```\n\nДокументация ядра доступна здесь: efivarfs.html.\n\n"
    },
    {
      "title": "Пользовательские инструменты",
      "level": 3,
      "content": "Существует несколько инструментов, работающих в пространстве пользователя (userspace), которые могут взаимодействовать с переменными UEFI:\n\n- efivar — Библиотека и инструмент для работы с переменными UEFI (используется в efibootmgr)\n\n- efibootmgr — Инструмент для работы с настройками менеджера загрузки прошивки UEFI\n\n- uefivars — Выгружает список переменных UEFI с некоторой дополнительной информацией, связанной с PCI (использует код efibootmgr).\n\n- efitools — Инструменты для манипулирования платформами UEFI secure boot\n\n- Ubuntu's Firmware Test Suite — Набор тестов, выполняющий проверку исправности прошивок ПК Intel/AMD\n\n"
    },
    {
      "title": "efibootmgr",
      "level": 4,
      "content": "Установите пакет efibootmgr.\n\n- Если efibootmgr не работает в вашей системе, вы можете перезагрузиться в #UEFI Shell и использовать bcfg для создания загрузочной записи для загрузчика.\n- Если вы не можете использовать efibootmgr, некоторые прошивки UEFI позволяют пользователям напрямую управлять загрузочными записями UEFI из интерфейса времени загрузки. Например, некоторые прошивки имеют опцию \"Add New Boot Option\", которая позволяет выбрать локальный системный раздел EFI и вручную ввести расположение приложения EFI, например, \\EFI\\refind\\refind_x64.efi.\n- В приведённых ниже командах в качестве примера используется менеджер загрузки rEFInd.\n\nЧтобы добавить новую загрузочную запись с помощью efibootmgr, необходимо знать три вещи:\n\n- Диск, содержащий системный раздел EFI (ESP). Например: /dev/sda, /dev/nvme0n1.\n- Номер раздела ESP на этом диске. Y в /dev/sdaY или /dev/nvme0n1pY.\n- Путь к приложению EFI (относительно корня ESP).\n\nНапример, если вы хотите добавить запись для /efi/EFI/refind/refind_x64.efi, где /efi — это точка монтирования ESP, выполните\n\n```\n$ findmnt /efi\n```\n\n```\nTARGET SOURCE    FSTYPE OPTIONS\n/efi   /dev/sda1 vfat   rw,flush,tz=UTC\n```\n\nВ данном примере это означает, что ESP находится на диске /dev/sda и имеет номер раздела 1. Путь к EFI-приложению относительно корня ESP — /EFI/refind/refind_x64.efi. Соответственно, можно загрузочную запись так:\n\n```\n# efibootmgr --create --disk /dev/sda --part 1 --loader /EFI/refind/refind_x64.efi --label \"rEFInd Boot Manager\" --unicode\n```\n\n```\n# efibootmgr --create --disk /dev/nvme0n1p1 --loader /EFI/refind/refind_x64.efi --label \"rEFInd Boot Manager\" --unicode\n```\n\nСмотрите efibootmgr(8) или efibootmgr README для более подробной информации.\n\n"
    },
    {
      "title": "Отключение доступа к переменным UEFI",
      "level": 3,
      "content": "Доступ к UEFI потенциально может нанести вред не только на уровне ОС. Иногда возможно даже «окирпичивание» устройства на некоторых забагованных реализациях UEFI. [3]\n\nТак как доступ к переменным UEFI не требуется для ежедневного использования системы, вы можете отключить его, чтобы избежать потенциальных проблем безопасности или случайного вреда.\n\nВозможные решения:\n\n- Монтирование efivars в режиме только для чтения через fstab. Например: efivarfs /sys/firmware/efi/efivars efivarfs ro,nosuid,nodev,noexec 0 0\n- Использование параметра ядра noefi, который полностью отключит доступ к UEFI из ОС.\n\n```\nefivarfs /sys/firmware/efi/efivars efivarfs ro,nosuid,nodev,noexec 0 0\n```\n\n"
    },
    {
      "title": "UEFI Shell",
      "level": 2,
      "content": "Командная оболочка UEFI (UEFI Shell) — это оболочка/терминал для прошивки, позволяющий запускать EFI-приложения, в том числе загрузчики UEFI. Кроме того, оболочка может использоваться для получения различной информации о системе или прошивке, например, распределение памяти (memmap), изменение переменных менеджера загрузки (bcfg), запуск программ разметки (diskpart), загрузки драйверов UEFI, редактирование текстовых файлов (edit), hexedit и т.д.\n\n"
    },
    {
      "title": "Получение UEFI Shell",
      "level": 3,
      "content": "Можно получить UEFI Shell из проекта TianoCore EDK2 (лицензия BSD):\n\n- Shell v2: На установочном носителе Arch: /shellx64.efi — это копия файла /usr/share/edk2-shell/x64/Shell_Full.efi, доступного на момент сборки ISO. edk2-shell предоставляет x86_64 Shell для x86_64 (64-bit) UEFI и IA32 Shell для IA32 (32-bit) UEFI — скомпилировано непосредственно из последнего выпуска TianoCore EDK2. uefi-shell-gitAUR предоставляет x86_64 Shell для x86_64 (64-bit) UEFI и IA32 Shell для IA32 (32-bit) UEFI — компилируется непосредственно из последнего выпуска TianoCore EDK2.\n- Shell v1: Прекомпилированные файлы UEFI Shell v1 от TianoCore (больше не обновляется).\n- С патчами: Прекомпилированный UEFI Shell v2 с bcfg, модифицированный для работы с прошивкой UEFI pre-2.3[устаревшая ссылка 2023-07-30 ⓘ] - из загрузчика Clover EFI. Прекомпилированный UEFI Shell v2, совместимый с широким спектром прошивок - из загрузчика OpenCore. В архиве: EFI/OC/Tools/OpenShell.efi.\n\n- На установочном носителе Arch: /shellx64.efi — это копия файла /usr/share/edk2-shell/x64/Shell_Full.efi, доступного на момент сборки ISO.\n- edk2-shell предоставляет x86_64 Shell для x86_64 (64-bit) UEFI и IA32 Shell для IA32 (32-bit) UEFI — скомпилировано непосредственно из последнего выпуска TianoCore EDK2.\n- uefi-shell-gitAUR предоставляет x86_64 Shell для x86_64 (64-bit) UEFI и IA32 Shell для IA32 (32-bit) UEFI — компилируется непосредственно из последнего выпуска TianoCore EDK2.\n\n- Прекомпилированные файлы UEFI Shell v1 от TianoCore (больше не обновляется).\n\n- Прекомпилированный UEFI Shell v2 с bcfg, модифицированный для работы с прошивкой UEFI pre-2.3[устаревшая ссылка 2023-07-30 ⓘ] - из загрузчика Clover EFI.\n- Прекомпилированный UEFI Shell v2, совместимый с широким спектром прошивок - из загрузчика OpenCore. В архиве: EFI/OC/Tools/OpenShell.efi.\n\nShell v2 лучше всего работает в системах UEFI 2.3+ и рекомендуется вместо Shell v1. Shell v1 должен работать во всех системах UEFI независимо от версии спецификации, которой соответствует прошивка. Дополнительная информация доступна на ShellPkg и в теме из списка рассылки EDK2 — Inclusion of UEFI shell in Linux distro iso.\n\n"
    },
    {
      "title": "Запуск UEFI Shell",
      "level": 3,
      "content": "Некоторые материнские платы Asus и другие материнские платы, использующие AMI Aptio x86_64 UEFI (начиная с Sandy Bridge и далее), имеют опцию под названием Launch EFI Shell from filesystem device. Для этих материнских плат скопируйте x86_64 UEFI Shell в корень системного раздела EFI с именем shellx64.efi.\n\n- Установочный носитель Arch Linux имеет shellx64.efi в корне тома.\n- rEFInd и systemd-boot автоматически добавляют пункт меню для UEFI Shell, если находят shellx64.efi в корне системного раздела EFI.\n\nСистемы с прошивкой Phoenix SecureCore Tiano UEFI имеют встроенный UEFI Shell, которую можно запустить с помощью клавиши F6, F11 или F12.\n\n"
    },
    {
      "title": "Важные команды UEFI Shell",
      "level": 3,
      "content": "Команды UEFI Shell обычно поддерживают опцию -b, которая приостанавливает вывод после каждой страницы. Выполните команду help -b, чтобы получить список доступных внутренних команд. Доступные команды либо встроены в оболочку, либо являются отдельными приложениями EFI.\n\nПодробнее можно почитать Intel Scripting Guide 2008[устаревшая ссылка 2023-07-30 ⓘ] и Intel \"Course\" 2011[устаревшая ссылка 2023-07-30 ⓘ].\n\n"
    },
    {
      "title": "bcfg",
      "level": 4,
      "content": "bcfg изменяет записи UEFI NVRAM, что позволяет пользователю изменить загрузочные записи или опции драйвера. Эта команда подробно описана на странице 96 (раздел 5.3) документа UEFI Shell Specification 2.2.\n\n- Пробуйте bcfg только если efibootmgr не смог создать рабочие загрузочные записи в вашей системе.\n- Официальный бинарный файл UEFI Shell v1 не поддерживает команду bcfg. В разделе #Получение UEFI Shell есть модифицированный бинарный файл UEFI Shell v2, который может работать в прошивках UEFI pre-2.3.\n\nСписок текущих загрузочных записей:\n\n```\nShell> bcfg boot dump -v\n```\n\nДобавление пункта загрузки для rEFInd (например) как четвёртый (нумерация начинается с нуля) пункт в меню загрузки:\n\n```\nShell> bcfg boot add 3 FS0:\\EFI\\refind\\refind_x64.efi \"rEFInd Boot Manager\"\n```\n\nгде FS0: соответствует системному разделу EFI, а FS0:\\EFI\\refind\\refind_x64.efi — запускаемый файл.\n\nЧтобы добавить запись для загрузки непосредственно в систему без загрузчика, настройте пункт загрузки, используя ваше ядро в качестве EFISTUB:\n\n```\nShell> bcfg boot add N fsV:\\vmlinuz-linux \"Arch Linux\"\nShell> bcfg boot -opt N \"root=/dev/sdX# initrd=\\initramfs-linux.img\"\n```\n\nгде N — приоритет, V — номер тома системного раздела EFI, а /dev/sdX# — корневой раздел.\n\nУдаление четвёртого пункта загрузки:\n\n```\nShell> bcfg boot rm 3\n```\n\nПеремещение четвёртого пункта на место первого пункта (что сделает его записью по умолчанию в загрузочном меню UEFI):\n\n```\nShell> bcfg boot mv 3 0\n```\n\nСправка команды bcfg:\n\n```\nShell> help bcfg -v -b\n```\n\nили:\n\n```\nShell> bcfg -? -v -b\n```\n\n"
    },
    {
      "title": "map",
      "level": 4,
      "content": "map отображает список сопоставлений устройств, то есть имена доступных файловых систем (FS0) и устройств хранения (blk0).\n\nПеред выполнением команд, связанных с файловой системой, таких как cd или ls, нужно переключить оболочку на соответствующую файловую систему, набрав её имя:\n\n```\nShell> FS0:\nFS0:\\> cd EFI/\n```\n\n"
    },
    {
      "title": "edit",
      "level": 4,
      "content": "edit предоставляет базовый текстовый редактор с интерфейсом, похожим на nano, но немного менее функциональный. Он обрабатывает кодировку UTF-8 и поддерживает окончания строк LF и CRLF.\n\nНапример, для редактирования файла refind.conf в системном разделе EFI (доступен в прошивке как FS0:):\n\n```\nShell> edit FS0:\\EFI\\refind\\refind.conf\n```\n\nНажмите Ctrl+e для справки.\n\n"
    },
    {
      "title": "Драйверы UEFI",
      "level": 2,
      "content": "Драйверы UEFI — это программы, поддерживающие определённую функциональность. Например, доступ к NTFS-разделам обычно невозможен через UEFI shell. В пакете efifs есть драйверы, поддерживающие чтение многих других файловых систем из EFI shell. Для использования можно скопировать такой драйвер на раздел, доступ к которому возможен из UEFI shell, а затем в UEFI shell выполнить такие команды:\n\n```\nShell> load ntfs_x64.efi\nShell> map -r\n```\n\nПосле выполнения команды map у пользователя появится доступ к разделам, отформатированным в формате NTFS, через UEFI shell.\n\n"
    },
    {
      "title": "Создание загрузочного UEFI USB из ISO",
      "level": 3,
      "content": "Смотрите Установочный образ на USB-накопителе#Создание загрузочного USB для BIOS и UEFI.\n\n"
    },
    {
      "title": "Удаление поддержки UEFI с оптического носителя",
      "level": 3,
      "content": "Note: **только с CD/DVD** \n\n- Этот раздел описывает удаление поддержки загрузки UEFI только с CD/DVD (загрузка с оптического носителя через EL Torito), но не с USB-накопителя.\n- Чтобы скрыть оборудование UEFI на USB-накопителе, используйте редактор разделов после копирования ISO на флэш-накопитель. Удалите раздел типа EF. Не принимайте предложение сконвертировать таблицу разделов в GPT.\n\nБольшинство 32-битных компьютеров Mac с EFI и некоторые 64-битные компьютеры Mac с EFI отказываются загружаться с загрузочного CD/DVD с UEFI(X64)+BIOS. Если вы хотите продолжить установку с оптического носителя, возможно, придётся сначала удалить поддержку UEFI.\n\nРаспакуйте ISO, пропуская каталоги, специфичные для UEFI:\n\n```\n$ mkdir extracted_iso\n$ bsdtar -x --exclude=EFI/ --exclude=loader/ -f archlinux-версия-x86_64.iso -C extracted_iso\n```\n\nЗатем пересоберите ISO, исключив поддержку загрузки оптических носителей UEFI, используя xorriso(1) из пакета libisoburn. Обязательно установите правильную метку тома, например ARCH_202103; её можно получить с помощью file(1) на исходном ISO.\n\n```\n$ xorriso -as mkisofs \\\n    -iso-level 3 \\\n    -full-iso9660-filenames \\\n    -joliet \\\n    -joliet-long \\\n    -rational-rock \\\n    -volid \"ARCH_ГГГГММ\" \\\n    -appid \"Arch Linux Live/Rescue CD\" \\\n    -publisher \"Arch Linux <https://archlinux.org>\" \\\n    -preparer \"prepared by $USER\" \\\n    -eltorito-boot syslinux/isolinux.bin \\\n    -eltorito-catalog syslinux/boot.cat \\\n    -no-emul-boot -boot-load-size 4 -boot-info-table \\\n    -isohybrid-mbr \"extracted_iso/syslinux/isohdpfx.bin\" \\\n    -output archlinux-версия-x86_64-noUEFI.iso extracted_iso/\n```\n\nЗапишите archlinux-версия-x86_64-noUEFI.iso на оптический носитель, и установка с него должна пройти нормально.\n\n"
    },
    {
      "title": "OVMF для виртуальных машин",
      "level": 3,
      "content": "OVMF — это проект TianoCore для поддержки UEFI в виртуальных машинах. OVMF содержит образец прошивки UEFI и отдельное энергонезависимое хранилище переменных для QEMU.\n\nЕго можно установить с помощью пакета edk2-ovmf.\n\nРекомендуется сделать локальную копию хранилища энергонезависимых переменных для вашей виртуальной машины:\n\n```\n$ cp /usr/share/edk2-ovmf/x64/OVMF_VARS.fd my_uefi_vars.fd\n```\n\nЧтобы использовать прошивку OVMF и это хранилище переменных, используйте следующие опции QEMU:\n\n```\n-drive if=pflash,format=raw,readonly,file=/usr/share/edk2-ovmf/x64/OVMF_CODE.fd \\\n-drive if=pflash,format=raw,file=my_uefi_vars.fd\n```\n\nНапример:\n\n```\n$ qemu-system-x86_64 -enable-kvm -m 1G -drive if=pflash,format=raw,readonly,file=/usr/share/edk2-ovmf/x64/OVMF_CODE.fd -drive if=pflash,format=raw,file=my_uefi_vars.fd …\n```\n\n"
    },
    {
      "title": "DUET для BIOS-систем",
      "level": 3,
      "content": "DUET был проектом TianoCore, который позволял сделать chainloading полного окружения UEFI из системы BIOS, способом, аналогичным загрузке ОС BIOS. Этот метод подробно обсуждается. Собранные образы DUET можно загрузить из одного из репозиториев[устаревшая ссылка 2023-04-07 ⓘ]. Смотрите также конкретные инструкции по настройке DUET[устаревшая ссылка 2023-04-07 ⓘ]. Однако по состоянию на ноябрь 2018 года код DUET был удалён из git-репозитория TianoCore.\n\nВы также можете попробовать Clover, который предоставляет модифицированные образы DUET, которые могут содержать некоторые специфические для системы исправления и чаще обновляются по сравнению с репозиториями gitlab.\n\n"
    },
    {
      "title": "Загрузка в Arch Linux после застревания в Windows",
      "level": 3,
      "content": "Если вы застряли в Windows, то для возвращения в Arch Linux зайдите в расширенные параметры запуска в Windows с помощью команды Windows PowerShell shutdown /r /o или через Параметры > Обновление и безопасность > Восстановление > Расширенные параметры запуска и выберите Перезагрузить сейчас. Когда вы достигнете меню выбора действия, выберите Использовать устройство, которое фактически содержит ваши варианты загрузки UEFI (не ограничивается USB или CD, но может также загружать операционную систему на жёстком диске), и выберите \"Arch Linux\".\n\n"
    },
    {
      "title": "Открытие настроек прошивки без функциональных клавиш",
      "level": 3,
      "content": "На некоторых ноутбуках, например Lenovo XiaoXin 15are 2020, использование клавиш вроде F2 или F12 ничего не даёт. Возможно, это можно исправить, вернув ноутбуки OEM-производителю для восстановления информации на материнской плате, но иногда это невозможно или нежелательно. Однако есть и другие способы войти в настройки прошивки:\n\n- Через systemctl: команда $ systemctl reboot --firmware-setup перезагрузит компьютер в настройки прошивки.\n- Через GRUB: нажмите c для открытия командной строки и введите fwsetup.\n- Через Windows: через расширенные параметры запуска, как описано в разделе #Загрузка в Arch Linux после застревания в Windows.\n\n```\n$ systemctl reboot --firmware-setup\n```\n\n"
    },
    {
      "title": "Пользовательские инструменты не могут изменить переменные UEFI",
      "level": 3,
      "content": "Если никакой инструмент пользовательского пространства не может изменить данные переменных UEFI, проверьте существование файлов /sys/firmware/efi/efivars/dump-*. Если они существуют, удалите их, перезагрузитесь и попробуйте ещё раз. Если это не помогло, попробуйте загрузиться с параметром ядра efi_no_storage_paranoia, чтобы отключить проверку пространства хранения переменных UEFI ядра, которая может препятствовать изменению переменных UEFI.\n\n"
    },
    {
      "title": "Не удаётся создать загрузочные записи с помощью efibootmgr",
      "level": 3,
      "content": "Некоторые комбинации версий ядра и efibootmgr могут не работать. Это может быть связано с нехваткой свободного места в NVRAM. Проверьте способы, описанные в разделе #Пользовательские инструменты не могут изменить переменные UEFI.\n\nВы также можете попробовать откатить efibootmgr до версии 0.11.0. Она работает с Linux 4.0.6. Смотрите обсуждение FS#34641, в частности закрывающий комментарий.\n\n"
    },
    {
      "title": "Windows изменяет порядок загрузки",
      "level": 3,
      "content": "Если при двойной загрузке с Windows материнская плата сразу же загружает Windows вместо выбранного приложения EFI, существует несколько возможных причин и способов их устранения.\n\n- Убедитесь, что в настройках Windows отключен быстрый запуск (Fast Startup).\n- Убедитесь, что Secure Boot в настройках прошивки отключен (если у вас неподписанный загрузчик).\n- Убедитесь, что Windows Boot Manager не прописывается прошивкой на первое место: например, сравните вывод efibootmgr с тем, что вы видите в настройках UEFI. Некоторые материнские платы автоматически ставят Windows на первое место, если обнаруживают его. В частности, это наблюдалось на ноутбуке Packard Bell.\n- Если ваша материнская плата загружает путь по умолчанию (\\EFI\\BOOT\\BOOTx64.EFI), этот файл может быть перезаписан загрузчиком Windows. Попробуйте установить правильный путь загрузки, например, с помощью efibootmgr.\n- Если предыдущие шаги не сработали, можно указать загрузчику Windows запустить другое приложение EFI. В командной строке, запущенной от имени администратора, выполните: bcdedit /set \"{bootmgr}\" path \"\\EFI\\путь\\к\\app.efi\"\n- Как вариант, отключите Windows Boot Manager, выполнив efibootmgr -A -b bootnumber от имени root. Замените bootnumber на фактический номер записи Windows Boot Manager; вы можете узнать его, запустив efibootmgr без опций.\n- Ещё можно установить скрипт запуска в Windows, который обеспечивает правильную установку порядка загрузки при каждой загрузке Windows. Запустите командную строку от имени администратора. Выполните bcdedit /enum firmware и найдите нужную загрузочную запись. Скопируйте его идентификатор вместе с фигурными скобками, например {31d0d5f4-22ad-11e5-b30b-806e6f6e6963} Создайте bat-файл с командой bcdedit /set \"{fwbootmgr}\" DEFAULT \"{скопированный-идентификатор}\" Откройте gpedit.msc и в разделе Политика \"Локальный компьютер\" > Конфигурация компьютера > Конфигурация Windows > Сценарии (запуск/завершение) выберите пункт Автозагрузка. На вкладке Сценарии нажмите кнопку Добавить и выберите ваш bat-файл.\n\n1. Запустите командную строку от имени администратора. Выполните bcdedit /enum firmware и найдите нужную загрузочную запись.\n1. Скопируйте его идентификатор вместе с фигурными скобками, например {31d0d5f4-22ad-11e5-b30b-806e6f6e6963}\n1. Создайте bat-файл с командой bcdedit /set \"{fwbootmgr}\" DEFAULT \"{скопированный-идентификатор}\"\n1. Откройте gpedit.msc и в разделе Политика \"Локальный компьютер\" > Конфигурация компьютера > Конфигурация Windows > Сценарии (запуск/завершение) выберите пункт Автозагрузка.\n1. На вкладке Сценарии нажмите кнопку Добавить и выберите ваш bat-файл.\n\n- В качестве альтернативы можно воспользоваться планировщиком заданий: Повторите шаги 1-3, описанные выше, для создания bat-файла. Запустите taskschd.msc и выберите пункт меню Действие > Создать задачу. На вкладке Общие: Введите подходящие Имя и Описание. Убедитесь, что выбранная учётная запись является администратором, а не обычным пользователем. Выберите пункт \"Выполнять для всех пользователей\". Поставьте галочку \"Выполнить с наивысшими правами\". На вкладке Триггеры создайте триггер При входе в систему. На вкладке Действия нажмите Создать, затем Обзор и выберите ваш bat-файл, созданный в первом шаге. На вкладке Условия снимите галочки в секции Питание, чтобы скрипт запускался при работе от батареи (для ноутбуков). Нажмите OK и по необходимости введите пароль от учётной записи администратора, выбранного в шаге 3.\n\n1. Повторите шаги 1-3, описанные выше, для создания bat-файла.\n1. Запустите taskschd.msc и выберите пункт меню Действие > Создать задачу.\n1. На вкладке Общие: Введите подходящие Имя и Описание. Убедитесь, что выбранная учётная запись является администратором, а не обычным пользователем. Выберите пункт \"Выполнять для всех пользователей\". Поставьте галочку \"Выполнить с наивысшими правами\".\n1. На вкладке Триггеры создайте триггер При входе в систему.\n1. На вкладке Действия нажмите Создать, затем Обзор и выберите ваш bat-файл, созданный в первом шаге.\n1. На вкладке Условия снимите галочки в секции Питание, чтобы скрипт запускался при работе от батареи (для ноутбуков).\n1. Нажмите OK и по необходимости введите пароль от учётной записи администратора, выбранного в шаге 3.\n\n"
    },
    {
      "title": "Чёрный экран при загрузке с USB",
      "level": 3,
      "content": "Возможно, это проблемы с KMS. Попробуйте отключить KMS при загрузке с USB.\n\n"
    },
    {
      "title": "Загрузчик UEFI не отображается в меню прошивки",
      "level": 3,
      "content": "Некоторые прошивки не поддерживают пользовательские загрузочные записи. Вместо этого они загружаются только из жёстко закодированных загрузочных записей.\n\nТипичное решение — не полагаться на загрузочные записи в NVRAM и установить загрузчик на один из распространённых путей в системном разделе EFI.\n\nВ следующих разделах описаны варианты.\n\n"
    },
    {
      "title": "Стандартные пути загрузки для съёмных носителей",
      "level": 4,
      "content": "Спецификация UEFI определяет стандартные пути к файлам EFI для загрузки со съёмных носителей:\n\n- esp/EFI/BOOT/BOOTx64.EFI для x86_64 UEFI\n- esp/EFI/BOOT/BOOTIA.EFI для IA32 UEFI.\n\nХотя спецификация определяет их только для съёмных дисков, большинство прошивок поддерживают их загрузку с любого диска.\n\nКак установить или перенести загрузчик на нужный путь, смотрите в соответствующей статье об интересующем вас загрузчике.\n\n"
    },
    {
      "title": "Расположение загрузчика Microsoft Windows",
      "level": 4,
      "content": "На некоторых материнских платах с UEFI, например, на платах с чипсетом Intel Z77, добавление записей с помощью efibootmgr или bcfg из UEFI Shell не работает, поскольку они не отображаются в списке меню загрузки после добавления в NVRAM.\n\nЭта проблема вызвана тем, что материнские платы умеют загружать только Microsoft Windows. Чтобы решить эту проблему, необходимо поместить файл .efi в то место, которое использует Windows.\n\nСкопируйте файл BOOTx64.EFI с установочного носителя Arch Linux (FS0:) в каталог Microsoft вашего раздела ESP на жёстком диске (FS1:). Для этого загрузитесь в UEFI Shell и введите:\n\n```\nShell> mkdir FS1:\\EFI\\Microsoft\nShell> mkdir FS1:\\EFI\\Microsoft\\Boot\nShell> cp FS0:\\EFI\\BOOT\\BOOTx64.EFI FS1:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\n```\n\nПосле перезагрузки все записи, добавленные в NVRAM, должны появиться в меню загрузки.\n\n"
    },
    {
      "title": "Загрузочные записи, созданные с помощью efibootmgr, не отображаются в UEFI",
      "level": 3,
      "content": "efibootmgr может не обнаружить EDD 3.0 и в результате создать непригодные для использования загрузочные записи в NVRAM. Смотрите efibootmgr issue 86 для подробностей.\n\nЧтобы обойти эту проблему, при создании загрузочных записей вручную добавьте опцию -e 3 к команде efibootmgr. Например:\n\n```\n# efibootmgr --create --disk /dev/sda --part 1 --loader /EFI/refind/refind_x64.efi --label \"rEFInd Boot Manager\" --unicode -e 3\n```\n\nДля исправления программ установки загрузчиков, таких как grub-install и refind-install, создайте скрипт-обёртку /usr/local/bin/efibootmgr и сделайте его исполняемым:\n\n```\n/usr/local/bin/efibootmgr\n```\n\n```\n#!/bin/sh\n\nexec /usr/bin/efibootmgr -e 3 \"$@\"\n```\n\n"
    },
    {
      "title": "Загрузочная запись UEFI исчезает после удаления диска, на который она ссылается",
      "level": 3,
      "content": "Некоторые прошивки удаляют загрузочные записи, относящиеся к дискам, которые недоступны во время загрузки. Это может быть проблемой при частом отсоединении/присоединении дисков или при загрузке со съёмного диска.\n\nРешением является установка загрузчика в стандартный путь загрузки.\n\n"
    },
    {
      "title": "Загрузочные записи удаляются случайным образом",
      "level": 3,
      "content": "Некоторые материнские платы могут удалять загрузочные записи из-за нехватки свободного места в NVRAM вместо того, чтобы выдавать ошибку при их создании. Чтобы этого не происходило, уменьшите количество добавляемых загрузочных записей путём минимизации процесса создания записей, а также уменьшите количество автоматических записей от Compatibility Support Module (CSM), отключив его в настройках UEFI. Смотрите BBS#1608838.\n\nДругой причиной может быть то, что спецификация UEFI позволяет производителям выполнять «обслуживание NVRAM» в процессе загрузки. Эти производители делают это просто: они просто ищут приложения EFI в заранее определённых, жёстко закодированных путях на устройстве. Если таковых не обнаруживается, они делают вывод об отсутствии ОС на устройстве и стирают все загрузочные записи из NVRAM, связанные с ним, поскольку предполагают, что NVRAM содержит повреждённые или устаревшие данные. Если вы не планируете устанавливать Windows, но хотите загрузить ядро Linux непосредственно из прошивки, то одним из возможных обходных путей является создание пустого файла esp/EFI/BOOT/BOOTX64.EFI:\n\n```\n# mkdir -p esp/EFI/BOOT\n# touch esp/EFI/BOOT/BOOTX64.EFI\n```\n\nПосле этого восстановите удалённую загрузочную запись. Теперь после перезагрузки материнская плата будет видеть «фальшивую ОС» и не должна стирать другие загрузочные записи из NVRAM. При желании, конечно, можно заменить загрузчик фальшивой ОС на реальное EFI-приложение, если использовать это стандартное имя.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- UEFI (Википедия)\n- UEFI Forum — содержит официальные спецификации UEFI — таблица разделов GUID является частью спецификации UEFI\n- UEFI boot: how does that actually work, then? - A blog post by AdamW\n- x86_64 UEFI — документация ядра\n- Intel's page on EFI\n- Intel Architecture Firmware Resource Center[устаревшая ссылка 2023-07-30 ⓘ]\n- Matt Fleming - The Linux EFI Boot Stub\n- Matt Fleming - Accessing UEFI Variables from Linux\n- Rod Smith - Linux on UEFI: A Quick Installation Guide\n- UEFI Boot problems on some newer machines (LKML)\n- Intel's TianoCore Project для прошивки UEFI с открытым исходным кодом, которая включает DuetPkg для прямой загрузки на основе BIOS и OvmfPkg, используемый в QEMU и Oracle VirtualBox\n- FGA: The EFI boot process\n- Microsoft's Windows and GPT FAQ\n- Convert Windows x64 from BIOS-MBR mode to UEFI-GPT mode without Reinstall\n- Create a Linux BIOS+UEFI and Windows x64 BIOS+UEFI bootable USB drive\n- Rod Smith - A BIOS to UEFI Transformation\n- EFI Shells and Scripting - Intel Documentation\n- UEFI Shell - Intel Documentation\n- UEFI Shell - bcfg command info\n- The bootstrap process on EFI systems\n\n"
    }
  ]
}