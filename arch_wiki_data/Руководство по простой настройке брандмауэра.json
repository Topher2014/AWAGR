{
  "title": "Руководство по простой настройке брандмауэра",
  "url": "https://wiki.archlinux.org/title/%D0%A0%D1%83%D0%BA%D0%BE%D0%B2%D0%BE%D0%B4%D1%81%D1%82%D0%B2%D0%BE_%D0%BF%D0%BE_%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B9_%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B5_%D0%B1%D1%80%D0%B0%D0%BD%D0%B4%D0%BC%D0%B0%D1%83%D1%8D%D1%80%D0%B0",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Межсетевой экран\n- Раздача интернета\n- Nftables (Русский)#Настройка межсетевого экрана\n- Router\n- Uncomplicated Firewall\n\nВ статье рассмотрена настройка межсетевого экрана с контекстной фильтрацией (stateful firewall) посредством iptables, с описанием основных правил и их назначения. Для удобства статья разбита на две части. В первой объясняется настройка межсетевого экрана на одиночной машине, во второй — настройка NAT-шлюза в дополнение к файрволу.\n\n"
    },
    {
      "title": "Требования",
      "level": 2,
      "content": "Прежде всего установите пакет iptables с набором пользовательских утилит, если он ещё не установлен.\n\nВ статье предполагается, что в настоящий момент не заданы никакие правила iptables. Узнать текущий набор правил можно командой:\n\n```\n# iptables-save\n```\n\n```\n# Generated by iptables-save v1.4.19.1 on Thu Aug  1 19:28:53 2013\n*filter\n:INPUT ACCEPT [50:3763]\n:FORWARD ACCEPT [0:0]\n:OUTPUT ACCEPT [30:3472]\nCOMMIT\n# Completed on Thu Aug  1 19:28:53 2013\n```\n\nили\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 156 packets, 12541 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 82 packets, 8672 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nЕсли всё же какие-то правила существуют, можно сбросить их, загрузив базовый набор:\n\n```\n# iptables-restore < /etc/iptables/empty.rules\n```\n\nДругие способы сброса правил можно найти в статье iptables#Сброс правил.\n\n"
    },
    {
      "title": "Создание необходимых цепочек",
      "level": 3,
      "content": "Создадим две пользовательские цепочки, которые будут использоваться для открытия портов.\n\n```\n# iptables -N TCP\n# iptables -N UDP\n```\n\nВ дальнейшем при назначений правил для этих цепочек мы будем всякий раз указывать тип протокола (например, флагом -p tcp). Этим обусловлен выбор названий цепочек, но вообще говоря, названия могут быть любыми.\n\n"
    },
    {
      "title": "Цепочка FORWARD",
      "level": 3,
      "content": "Если вы хотите настроить свою систему в качестве NAT-шлюза, изучите раздел #Настройка NAT-шлюза. Для обычной системы можно просто задать политику DROP для цепочки FORWARD:\n\n```\n# iptables -P FORWARD DROP\n```\n\n"
    },
    {
      "title": "Цепочка OUTPUT",
      "level": 3,
      "content": "Цепочка OUTPUT может быть крайне полезной в деле фильтрации исходящего трафика, особено для серверов и других устройств, не использующих веб-браузеры и peer-to-peer программы для соединения с произвольными узлами сети Интернет. Тем не менее, правильная настройка цепочки OUTPUT требует понимания назначения конкретной системы. Наборы правил безопасности для настольной системы, ноутбука, облачного или домашнего сервера будут сильно отличаться.\n\nВ этом примере весь исходящий трафик разрешён, поэтому для цепочки OUTPUT задаётся политика ACCEPT. Этого недостаточно для полной безопасности, но будет работать на большинстве систем.\n\n```\n# iptables -P OUTPUT ACCEPT\n```\n\n"
    },
    {
      "title": "Цепочка INPUT",
      "level": 3,
      "content": "Назначаем политику DROP для цепочки INPUT на случай, если что-то каким-то образом проскочит мимо наших правил. Лучший способ создать надёжный файрвол — запретить весь трафик, отдельно указав то, что разрешено.\n\n```\n# iptables -P INPUT DROP\n```\n\nВсе входящие пакеты, предназначенные для этой машины и пришедшие на любой сетевой интерфейс, будут проходить через цепочку INPUT. Эта цепочка позволяет принимать только те пакеты, которые действительно нужны.\n\nПервое правило цепочки INPUT будет разрешать трафик установленных соединений и любой новый трафик, относящийся к ним, например, сообщения ICMP об ошибке или эхо-ответы (пакеты, которые хост возвращает, когда его пингуют). ICMP — протокол управляющих сообщений (Internet Control Message Protocol). Некоторые сообщения ICMP имеют важное значение для управления перегрузками и определения MTU, и мы разрешаем их этим правилом:\n\n```\n# iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n```\n\nСостояние соединения ESTABLISHED подразумевает одну из двух ситуаций: либо первичная (--ctstate NEW) попытка соединения была ранее одобрена другим правилом, либо соединение уже было активно (например, удалённое SSH-подключение) на момент задания правила.\n\nВторое правило разрешит весь трафик от петлевого (loopback) интерфейса, который необходим многим приложениям и службам:\n\n```\n# iptables -A INPUT -i lo -j ACCEPT\n```\n\nТретье правило будет отбрасывать все пакеты с состоянием INVALID. Существует четыре категории состояния (state): NEW, ESTABLISHED, RELATED и INVALID. Именно наличие категорий отличает межсетевой экран с контекстной фильтрацией от менее безопасного экрана без оной. Состояния отслеживаются модулями ядра nf_conntrack_*, которые загружаются автоматически после добавления правил.\n\n- Это правило будет отбрасывать все пакеты с неверными заголовками или контрольными суммами, неверными флагами TCP, неправильными ICMP-сообщениями (например, входящее сообщение \"порт недостижим\", если мы не посылали ничего другому хосту), а также пакеты с неправильным порядковым номером, что может быть признаком атаки. Политика DROP означает отбрасывание пакетов безо всякого ответа, в то время как REJECT отклоняет их вежливо, с уведомлением отправителя. Мы используем DROP, поскольку для INVALID-пакетов не существует подходящего REJECT-ответа и в целом подтверждать их получение нет никакой необходимости.\n- Пакеты ICMPv6 Neighbor Discovery остаются неотслеживаемыми и всегда классифицируются как INVALID, хотя они по всем параметрам являются годными. Если их необходимо разрешить, то выполните iptables -A INPUT -p 41 -j ACCEPT с правами root перед следующей командой.\n\n```\n# iptables -A INPUT -m conntrack --ctstate INVALID -j DROP\n```\n\nСледующее правило разрешает входящие ICMP эхо-запросы (ECHO_REQUEST), известные как пинги. Только первый пакет будет считаться относящимся к категории NEW, остальные будут обрабатываться правилом \"RELATED, ESTABLISHED\". Если компьютер не является маршрутизатором, нет необходимости разрешать какой-либо другой ICMP-трафик с состоянием NEW.\n\n```\n# iptables -A INPUT -p icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT\n```\n\nТеперь мы прикрепим TCP- и UDP-цепочки к цепочке INPUT для обработки новых входящих соединений. Если соединение разрешено цепочкой TCP или UDP, оно обрабатывается правилом \"RELATED, ESTABLISHED\". TCP или UDP цепочки будут либо разрешать новые входящие соединения, либо вежливо отклонять их. Новые TCP соединения должны начинаться с SYN-сегмента.\n\n```\n# iptables -A INPUT -p udp -m conntrack --ctstate NEW -j UDP\n# iptables -A INPUT -p tcp --syn -m conntrack --ctstate NEW -j TCP\n```\n\nМы отклоняем TCP-соединения пакетами TCP RESET, а UDP-потоки — сообщениями ICMP \"port unreachable\", если запрашиваемый порт закрыт. Это имитирует стандартное поведение Linux (в соответствии с RFC), и позволяет отправителю быстро закрыть соединение.\n\n```\n# iptables -A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable\n# iptables -A INPUT -p tcp -j REJECT --reject-with tcp-reset\n```\n\nДля прочих протоколов мы добавляем последнее правило в цепочку INPUT, чтобы отклонить остальной входящий трафик с ICMP-сообщением \"protocol unreachable\". Это также соответствует стандартному поведению Linux.\n\n```\n# iptables -A INPUT -j REJECT --reject-with icmp-proto-unreachable\n```\n\n"
    },
    {
      "title": "Итоговый файл iptables.rules",
      "level": 3,
      "content": "Пример файла iptables.rules после выполнения всех команд выше:\n\n```\n/etc/iptables/iptables.rules\n```\n\n```\n# Generated by iptables-save v1.4.18 on Sun Mar 17 14:21:12 2013\n*filter\n:INPUT DROP [0:0]\n:FORWARD DROP [0:0]\n:OUTPUT ACCEPT [0:0]\n:TCP - [0:0]\n:UDP - [0:0]\n-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -m conntrack --ctstate INVALID -j DROP\n-A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT\n-A INPUT -p udp -m conntrack --ctstate NEW -j UDP\n-A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP\n-A INPUT -p udp -j REJECT --reject-with icmp-port-unreachable\n-A INPUT -p tcp -j REJECT --reject-with tcp-reset\n-A INPUT -j REJECT --reject-with icmp-proto-unreachable\nCOMMIT\n# Completed on Sun Mar 17 14:21:12 2013\n```\n\nФайл генерируется и сохраняется командой\n\n```\n# iptables-save -f /etc/iptables/iptables.rules\n```\n\nДанный файл конфигурации можно использовать как исходный для дальнейших настроек в следующих разделах. Если вы настраиваете межсетевой экран удалённо через SSH, перед продолжением добавьте правило, разрешающее новые SSH-подключения (вместо порта 22 выберите нужный):\n\n```\n# iptables -A TCP -p tcp --dport 22 -j ACCEPT\n```\n\n"
    },
    {
      "title": "Цепочки TCP и UDP",
      "level": 3,
      "content": "Цепочки TCP и UDP содержат правила для разрешения новых TCP-соединений и UDP-потоков к определённым портам.\n\n"
    },
    {
      "title": "Открытие портов для входящих соединений",
      "level": 4,
      "content": "Разрешить входящие TCP-соединения на порт 80 для веб-сервера (HTTP):\n\n```\n# iptables -A TCP -p tcp --dport 80 -j ACCEPT\n```\n\nРазрешить входящие TCP-соединения на порт 443 для веб-сервера (HTTPS):\n\n```\n# iptables -A TCP -p tcp --dport 443 -j ACCEPT\n```\n\nРазрешить удаленные SSH-соединения (на порт 22):\n\n```\n# iptables -A TCP -p tcp --dport 22 -j ACCEPT\n```\n\nРазрешить входящие TCP/UDP запросы для DNS-сервера (порт 53):\n\n```\n# iptables -A TCP -p tcp --dport 53 -j ACCEPT\n# iptables -A UDP -p udp --dport 53 -j ACCEPT\n```\n\nБолее сложные правила, вроде проверки по нескольким портам, можно найти в iptables(8).\n\n"
    },
    {
      "title": "Port knocking",
      "level": 4,
      "content": "Port knocking — способ открыть извне порты, которые файрвол по умолчанию держит закрытыми. Port knocking заключается в создании последовательности попыток соединений с заранее выбранными закрытыми портами. При получении корректной последовательности \"простукиваний\" межсетевой экран открывает определенный порт и разрешает соединение. Подробнее см. Port knocking.\n\n"
    },
    {
      "title": "Защита от спуфинга",
      "level": 3,
      "content": "Если из внешней сети пришёл пакет с зарезервированным (т.е. локальным) адресом отправителя, то имеет место подмена адреса (address spoofing). Стандартный способ блокирования таких пакетов — установить с помощью sysctl параметр rp_filter (Reverse Path Filter) в значение 1, что включит встроенную в ядро Linux проверку адреса отправителя пакета. Встроенная проверка будет работать лучше, чем отдельные правила iptables на каждый случай. Добавьте в файл /etc/sysctl.d/90-firewall.conf (подробнее см. sysctl) следующую строку:\n\n```\nnet.ipv4.conf.all.rp_filter=1\n```\n\nТо же самое можно сделать посредством netfilter, если необходимо ведение статистики и лог-файлов:\n\n```\n# iptables -t raw -I PREROUTING -m rpfilter --invert -j DROP\n```\n\nДля случая асинхронной маршрутизации используйте значение rp_filter=2. Флаг --loose в модуле rpfilter делает то же самое посредством netfilter.\n\n"
    },
    {
      "title": "Защита от обнаружения",
      "level": 3,
      "content": "Если вы хотите сделать вашу машину менее заметной в сети, хорошей идеей будет блокировать некоторые входящие запросы.\n\n"
    },
    {
      "title": "Блокирование ping-запросов",
      "level": 4,
      "content": "Запрос \"ping\" представляет собой ICMP-пакет, посланный с целью убедиться, что между двумя хостами есть связь. Если сеть в порядке, вы можете безопасно блокировать все ping-запросы. Нужно отметить, что это не сделает ваш компьютер необнаружимым — каждый входящий пакет будет отклоняться, поэтому вы всё ещё будете видны при простом \"ping-сканировании\" по диапазону IP-адресов посредством nmap. Кроме того, нужно иметь в виду, что эта элементарная \"защита\" усложнит вам жизнь случае возникновения необходимости отладки сети.\n\nЧтобы заблокировать эхо-запросы (echo requests), добавьте следующую строку в файл /etc/sysctl.d/90-firewall.conf (подробную информацию можно найти в статье sysctl):\n\n```\nnet.ipv4.icmp_echo_ignore_all = 1\n```\n\nБольше сведений об этой защите вы найдёте в руководстве iptables(8), а также в документации и примерах на странице http://www.snowman.net/projects/ipt_recent/\n\n"
    },
    {
      "title": "Обман сканеров портов",
      "level": 4,
      "content": "Сканирование портов производится с целью обнаружения тех из них, которые открыты в настоящий момент. Это позволит атакующему определить запущенные на машине службы и подобрать к ним эксплойты.\n\nСостояние INVALID в правилах iptables \"позаботится\" обо всех типах сканирования, за исключением сканирований UDP, ACK и SYN (флаги nmap -sU, -sA и -sS соответственно).\n\nACK-сканирование не используется для определения открытых портов, но зато покажет порты, защищённые межсетевым экраном. Подобно SYN-пакету в TCP-соединениях с состоянием NEW, каждый пакет ACK-сканирования будет отклонен с отправкой ответа TCP RESET по обратному адресу. Некоторые межсетевые экраны вместо этого просто отбрасывают такие пакеты, что позволяет атакующему определить действующие правила.\n\nМодуль recent поможет обмануть остальные типы сканирования портов. Он добавляет хосты к списку недавних соединений, который используется для обнаружения и блокирования попыток атак. Просмотреть списки недавних соединений можно в каталоге /proc/net/xt_recent/.\n\n- Система станет уязвимой к разновидности DoS-атаки. Атакующий посылает пакеты с подменёными IP-адресами, чтобы добиться их блокировки вашими службами.\n- Может оказаться заблокированным обычный IP-адрес, если несколько пакетов с этого адреса на порт получателя будут признаны INVALID модулем conntrack. Чтобы избежать занесения в чёрный список, следует разрешить все пакеты, поступающие на этот порт.\n\nПри SYN-сканировании сканер портов посылает синхронизационные пакеты на каждый порт с целью создать TCP-соединение. Если порт закрыт, то возвращается ответ TCP RESET, межсетевой экран просто отбрасывает входящий пакет, а открытый порт возвращает ответ SYN ACK.\n\nМодуль recent может использоваться для отслеживания хостов с отклонёнными попытками соединения и возвращения ответа TCP RESET для каждого SYN-пакета, поступившего на открытый порт, как если бы порт был закрыт. Если открытый порт оказался первым в порядке сканирования, то будет возвращён ответ SYN ACK, поэтому приложения вроде ssh следует размещать на нестандартных портах.\n\nСначала добавьте правило в начало цепочки TCP. Это правило будет отвечать пакетом TCP RESET любому хосту, входившему в список TCP-PORTSCAN в течение последних 60 секунд. Флаг --update управляет периодическим обновлением списка.\n\n```\n# iptables -I TCP -p tcp -m recent --update --rsource --seconds 60 --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset\n```\n\nЗатем необходимо модифицировать правило отклонения TCP-пакетов, чтобы добавлять все хосты с отклонёнными пакетами к списку TCP-PORTSCAN:\n\n```\n# iptables -D INPUT -p tcp -j REJECT --reject-with tcp-reset\n# iptables -A INPUT -p tcp -m recent --set --rsource --name TCP-PORTSCAN -j REJECT --reject-with tcp-reset\n```\n\nСканирование UDP схоже со сканированием TCP SYN за исключением того факта, что UDP является протоколом без установления соединения. В нём нет \"рукопожатий\" и подтверждений. Вместо этого сканер посылает UDP-пакеты на каждый UDP-порт. Закрытые порты должны возвращать сообщение ICMP port unreachable, а открытые не возвращают ничего. Поскольку UDP — \"ненадежный\" протокол, у сканера нет возможности узнать о потере пакетов, поэтому он посылает серию запросов на каждый порт, с которого не вернулся ответ.\n\nЯдро Linux посылает сообщения ICMP port unreachable довольно медленно, поэтому продолжительность полного UDP-сканирования может превысить 10 часов. Однако часто используемые порты проверяются гораздо быстрее, поэтому хорошей идеей будет применить контрмеры, аналогичные защите от SYN-сканирований.\n\nСначала добавляем правило отклонения пакетов от хостов из списка UDP-PORTSCAN в начало цепочки UDP:\n\n```\n# iptables -I UDP -p udp -m recent --update --rsource --seconds 60 --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable\n```\n\nЗатем модифицируем правило отклонения пакетов для UDP:\n\n```\n# iptables -D INPUT -p udp -j REJECT --reject-with icmp-port-unreachable\n# iptables -A INPUT -p udp -m recent --set --rsource --name UDP-PORTSCAN -j REJECT --reject-with icmp-port-unreachable\n```\n\nЕсли вы применили хотя бы один из способов защиты выше, бывшее последним правило цепочки INPUT более таковым не является. Теперь оно находится перед правилами защиты от сканирования и те по сути бесполезны. Просто удалите (-D) это правило, а затем добавьте его снова (-A), это переместит его в конец цепочки.\n\n```\n# iptables -D INPUT -j REJECT --reject-with icmp-proto-unreachable\n# iptables -A INPUT -j REJECT --reject-with icmp-proto-unreachable\n```\n\n"
    },
    {
      "title": "Защита от других типов атак",
      "level": 3,
      "content": "В статье sysctl#TCP/IP stack hardening можно найти описание важных с точки зрения безопасности параметров ядра.\n\n"
    },
    {
      "title": "Атака полным перебором",
      "level": 4,
      "content": "Доступные по внешнему IP-адресу сервисы подвергаются атакам полным перебором довольно часто. Реализовать атаку этого типа несложно, а инструментарий — обширен и доступен. К счастью, существует несколько способов защиты от атак полным перебором. Первый способ заключается в создании правил iptables, которые заносят IP-адрес в чёрный список после нескольких попыток установить соединение. При втором способе защиты запускается специализированный демон, который отслеживает лог-файл на предмет неудачных попыток соединения.\n\nПриложения Fail2ban и (в случае sshd) Sshguard используются для блокировки IP-адресов при превышении допустимого количества попыток аутентификации. Суть их работы состоит в обновлении правил iptables с целью временно или навсегда воспрепятствовать будущим соединениям атакующих.\n\nНиже представлен пример правил iptables для предотвращения атак полным перебором на сервис SSH.\n\n```\n# iptables -N IN_SSH\n# iptables -N LOG_AND_DROP\n# iptables -A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -j IN_SSH\n# iptables -A IN_SSH -m recent --name sshbf --rttl --rcheck --hitcount 3 --seconds 10 -j LOG_AND_DROP\n# iptables -A IN_SSH -m recent --name sshbf --rttl --rcheck --hitcount 4 --seconds 1800 -j LOG_AND_DROP \n# iptables -A IN_SSH -m recent --name sshbf --set -j ACCEPT\n# iptables -A LOG_AND_DROP -j LOG --log-prefix \"iptables deny: \" --log-level 7\n# iptables -A LOG_AND_DROP -j DROP\n```\n\nБольшая часть правил очевидна: первое разрешает три попытки соединения в течение 10 секунд, после чего дальнейшие попытки будут отклоняться. Второе — добавляет ограничение на четыре попытки в течение получаса. Дело в том, что атаки полным перебором обычно выполняются медленно и за несколько серий попыток. Дополнительную информацию об этих правилах и их опциях можно найти в оригинальной статье на сайте compilefailure.blogspot.com.\n\nПредложенные выше правила могут использоваться для защиты любой службы, но демон SSH нуждается в ней наиболее часто.\n\nНеобходимо также убедиться, что правило -A INPUT -p tcp --dport ssh -m conntrack --ctstate NEW -j IN_SSH находится в верной позиции в последовательности iptables, перед точкой прикрепления цепочки TCP к цепочке INPUT. Это позволит успешно перехватывать новые попытки установления SSH-соединений. Если вы выполнили все предыдущие шаги в этой статье, порядок правил должен быть следующим:\n\n```\n...\n-A INPUT -m conntrack --ctstate INVALID -j DROP\n-A INPUT -p icmp -m icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT\n-A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j IN_SSH\n-A INPUT -p udp -m conntrack --ctstate NEW -j UDP\n-A INPUT -p tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP\n...\n```\n\n"
    },
    {
      "title": "IPv6",
      "level": 3,
      "content": "Если вы не используете протокол IPv6, то лучше будет его отключить. В противном случае стоит создать соответствующий набор правил межсетевого экрана.\n\nСкопируйте созданные ранее правила для протокола IPv4 и замените все IPv4-адреса на адреса формата IPv6:\n\n```\n# cp /etc/iptables/iptables.rules /etc/iptables/ip6tables.rules\n```\n\nНекоторые правила нужно адаптировать под IPv6. Так, для IPv6 используется обновлённая версия протокола ICMP, и коды ответов при отклонении соединений --reject-with icmp-port-unreachable и --reject-with icmp-proto-unreachable необходимо преобразовать в коды ICMPv6.\n\nКоды ошибок ICMPv6 перечислены в RFC 4443, согласно которому при блокировке межсетевым экраном попыток установления соединения необходимо использовать код --reject-with icmp6-adm-prohibited. Это проинформирует удалённую систему о том, что соединение было отклонено брандмауэром, а не прослушивающей порт службой.\n\nЕсли уведомлять удалённую систему о наличии файрвола нежелательно, то можно отклонить пакет без сообщения:\n\n```\n-A INPUT -j REJECT\n```\n\nОтклонение пакетов по этому правилу будет производиться с сообщением об ошибке --reject-with icmp6-port-unreachable. Следует однако отметить, что одной из основных функций приложений-сканеров является как раз обнаружение межсетевых экранов и обмануть их этим правилом не получится.\n\nNote: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nСледующее правило для протокола IPv6 настроит поведение межсетевого экрана по отношению к новым входящим пингам (ICMP echo requests):\n\n```\n# ip6tables -A INPUT -p ipv6-icmp --icmpv6-type 128 -m conntrack --ctstate NEW -j ACCEPT\n```\n\nМодуль conntrack не отслеживает действия ICMPv6 Neighbor Discovery Protocol (аналог протокола ARP), поэтому необходимо разрешить трафик ICMPv6 вне зависимости от его состояния для всех прилежащих подсетей. Следующее правило нужно вставить после правила отбрасывания некорректных пакетов --ctstate INVALID, но перед любыми другими правилами DROP или REJECT. Создаётся по одному правилу на каждую подсеть:\n\n```\n# ip6tables -A INPUT -s fe80::/10 -p ipv6-icmp -j ACCEPT\n```\n\nЕсли вы желаете включить DHCPv6, разрешите входящие соединения на UDP-порт 546:\n\n```\n# ip6tables -A INPUT -p udp --sport 547 --dport 546 -j ACCEPT\n```\n\nПоскольку в ядре Linux нет встроенной фильтрации по обратному маршруту (reverse path filter) для протокола IPv6, то стоит включить её посредством ip6tables:\n\n```\n# ip6tables -t raw -A PREROUTING -m rpfilter -j ACCEPT\n# ip6tables -t raw -A PREROUTING -j DROP\n```\n\n"
    },
    {
      "title": "Сохранение правил",
      "level": 3,
      "content": "Набор правил межсетевого экрана завершён и осталось только сохранить его в файл, который будет загружаться при каждом запуске системы.\n\nСохраняем правила IPv4 и IPv6 командами:\n\n```\n# iptables-save -f /etc/iptables/iptables.rules\n# ip6tables-save -f /etc/iptables/ip6tables.rules\n```\n\n"
    },
    {
      "title": "Итоговый файл ip6tables.rules",
      "level": 3,
      "content": "Пример файла правил ip6tables.rules после выполнения представленных выше команд:\n\n```\n/etc/iptables/ip6tables.rules\n```\n\n```\n# Generated by ip6tables-save v1.8.2 on Sat Apr 20 10:53:41 2019\n*filter\n:INPUT DROP [0:0]\n:FORWARD DROP [0:0]\n:OUTPUT ACCEPT [0:0]\n:TCP - [0:0]\n:UDP - [0:0]\n-A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n-A INPUT -i lo -j ACCEPT\n-A INPUT -m conntrack --ctstate INVALID -j DROP\n-A INPUT -s fe80::/10 -p ipv6-icmp -j ACCEPT\n-A INPUT -p udp --sport 547 --dport 546 -j ACCEPT\n-A INPUT -p udp -m conntrack --ctstate NEW -j UDP\n-A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j TCP\n-A INPUT -p udp -j REJECT --reject-with icmp6-adm-prohibited\n-A INPUT -p tcp -j REJECT --reject-with tcp-reset\n-A INPUT -j REJECT --reject-with icmp6-adm-prohibited\n-A INPUT -p ipv6-icmp -m icmp6 --icmpv6-type 128 -m conntrack --ctstate NEW -j ACCEPT\nCOMMIT\n# Completed on Sat Apr 20 10:53:41 2019\n```\n\nВ завершение включите и запустите службы iptables.service и ip6tables.service. Проверьте статус служб, чтобы убедиться, что правила загрузились корректно.\n\n"
    },
    {
      "title": "Настройка NAT-шлюза",
      "level": 2,
      "content": "В этом разделе рассмотрена настройка межсетевого экрана для NAT-шлюза. Предполагается, что вы уже прочитали первую часть данного руководства и настроили цепочки INPUT, OUTPUT, TCP и UDP как было предложено. До этого момента созданные правила относились к таблице filter, при настройке NAT-шлюза нам также понадобится таблица nat.\n\n"
    },
    {
      "title": "Создание необходимых цепочек",
      "level": 4,
      "content": "Создадим две новые цепочки — fw-interfaces и fw-open:\n\n```\n# iptables -N fw-interfaces\n# iptables -N fw-open\n```\n\n"
    },
    {
      "title": "Цепочка FORWARD",
      "level": 4,
      "content": "Настройка цепочки FORWARD схожа с настройкой цепочки INPUT в первой части.\n\nСначала добавляем правило с модулем conntrack, идентичное правилу из цепочки INPUT:\n\n```\n# iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT\n```\n\nЗатем включаем пересылку для доверенных интерфейсов и пропускаем все пакеты через цепочку fw-open:\n\n```\n# iptables -A FORWARD -j fw-interfaces \n# iptables -A FORWARD -j fw-open\n```\n\nОстальные пакеты блокируются с отправкой ICMP-сообщения:\n\n```\n# iptables -A FORWARD -j REJECT --reject-with icmp-host-unreachable\n# iptables -P FORWARD DROP\n```\n\n"
    },
    {
      "title": "Цепочки fw-interfaces и fw-open",
      "level": 4,
      "content": "Назначение цепочек fw-interfaces и fw-open будет объяснено позже, когда мы будем работать с цепочками POSTROUTING и PREROUTING соответственно в таблице nat.\n\n"
    },
    {
      "title": "Таблица nat",
      "level": 3,
      "content": "В этом разделе предполагается, что исходящий интерфейс (с публичным IP-адресом) носит имя ppp0. Если ваш интерфейс называется иначе, то во всех приведённых ниже правилах следует заменить название на настоящее.\n\n"
    },
    {
      "title": "Цепочка POSTROUTING",
      "level": 4,
      "content": "Сначала мы должны определить, кому разрешено подключаться к сети Интернет. Предположим, имеется подсеть 192.168.0.0/24 (т.е. в неё входят все адреса в диапазоне 192.168.0.0-255), подключённая к интерфейсу eth0. Чтобы разрешить исходящие соединения хостам в этой подсети, настраиваем цепочку fw-interfaces в таблице FORWARD:\n\n```\n# iptables -A fw-interfaces -i eth0 -j ACCEPT\n```\n\nЗатем необходимо отредактировать все исходящие пакеты, чтобы в поле \"адрес отправителя\" значился публичный адрес шлюза вместо локального LAN-адреса. Для этого используем таргет MASQUERADE:\n\n```\n# iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o ppp0 -j MASQUERADE\n```\n\nНе забудьте указать параметр -o ppp0, потому что в противном случае сеть не будет функционировать.\n\nПредположим, что есть другая подсеть, 10.3.0.0/16 (с адресами 10.3.*.*), подключённая к интерфейсу eth1. Добавляем аналогичные правила:\n\n```\n# iptables -A fw-interfaces -i eth1 -j ACCEPT\n# iptables -t nat -A POSTROUTING -s 10.3.0.0/16 -o ppp0 -j MASQUERADE\n```\n\nНаконец, нужно разрешить пересылку пакетов (если она ещё не включена).\n\nХосты данных подсетей теперь могут использовать вашу NAT-систему в качестве шлюза. Возможно, вы также захотите настроить DNS- и DHCP-сервер, например, dnsmasq или комбинацию BIND и dhcpd, с целью упрощения настройки разрешения имён (DNS resolving) на клиентских машинах, но эта тема выходит за рамки данного руководства.\n\n"
    },
    {
      "title": "Цепочка PREROUTING",
      "level": 4,
      "content": "В некоторых случаях может понадобиться изменить адрес получателя в заголовке входящего пакета с адреса шлюза на адрес хоста в локальной сети. Для этого нужно настроить созданную ранее цепочку fw-open, а также цепочку PREROUTING таблицы nat.\n\nНапример, чтобы изменить адрес получателя входящих SSH-пакетов (порт 22) на адрес ssh-сервера 192.168.0.5 выполните команды:\n\n```\n# iptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 22 -j DNAT --to 192.168.0.5\n# iptables -A fw-open -d 192.168.0.5 -p tcp --dport 22 -j ACCEPT\n```\n\nВо втором примере меняется не только адрес получателя, но и порт. Порт входящего соединения 8000 заменяется на порт 80 веб-сервера по адресу 192.168.0.6:\n\n```\n# iptables -t nat -A PREROUTING -i ppp0 -p tcp --dport 8000 -j DNAT --to 192.168.0.6:80\n# iptables -A fw-open -d 192.168.0.6 -p tcp --dport 80 -j ACCEPT\n```\n\nНастройка для UDP-пакетов производится аналогично.\n\n"
    },
    {
      "title": "Сохранение правил",
      "level": 3,
      "content": "Чтобы сохранить новые правила межсетевого экрана для NAT-шлюза, выполните:\n\n```\n# iptables-save -f /etc/iptables/iptables.rules\n```\n\nПри этом поздразумевается, что служба systemd iptables.service уже работает, потому что была включена ранее.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Methods to block SSH attacks — защита от SSH-атак\n- Using iptables to block brute force attacks — защита от атак полным перебором\n- Collection of basic Linux Firewall iptables rules — примеры базовой настройки iptables\n- 25 Most Frequently Used Linux IPTables Rules Examples — ещё примеры\n\n"
    }
  ]
}