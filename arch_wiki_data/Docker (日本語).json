{
  "title": "Docker (日本語)",
  "url": "https://wiki.archlinux.org/title/Docker_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- systemd-nspawn\n- Linux Containers\n- Vagrant\n- Podman\n\nDocker は軽量コンテナとしてあらゆるアプリケーションを詰めて運んで実行できるユーティリティです。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール 1.1 Docker Compose 1.2 Docker Desktop\n- 2 使用法\n- 3 設定 3.1 ストレージドライバー 3.2 デーモンのソケット 3.3 HTTP プロキシ 3.3.1 Docker デーモンのプロキシ設定 3.3.2 Docker コンテナのプロキシ設定 3.4 DNS の設定 3.5 イメージの置き場所 3.6 安全ではないレジストリ 3.7 IPv6 3.8 ユーザ名前空間の隔離 3.9 Rootless Docker デーモン 3.10 ネイティブ overlay diff エンジンを有効化する\n- 4 イメージ 4.1 Arch Linux 4.2 Alpine Linux 4.3 Debian 4.4 Distroless\n- 5 ヒントとテクニック 5.1 実行中のコンテナの IP アドレスを取得する 5.2 コンテナ内でグラフィカルなプログラムを実行する 5.3 ブート時に Docker Compose プロジェクトを開始する 5.4 クロスコンパイルに buildx を使う 5.5 NVIDIA GPU で GPU アクセラレートされた Docker コンテナを動かす 5.5.1 NVIDIA Container Toolkit を使う (推奨) 5.5.2 NVIDIA Container Runtime を使う 5.5.3 CUDA 付き Arch Linux イメージ\n- 6 Docker とイメージの削除\n- 7 トラブルシューティング 7.1 systemd-networkd を使用していると、docker0 ブリッジが IP を取得できない / コンテナからインターネットにアクセスできない 7.2 デフォルトで使用できるプロセスやスレッドの数が少なすぎる 7.3 Error initializing graphdriver: devmapper 7.4 Failed to create some/path/to/file: No space left on device 7.5 virtualbox ドライバーを使用したときに Docker-machine が仮想マシンの作成に失敗する 7.6 Docker を起動すると KVM のブリッジネットワークが壊れる 7.7 Docker Hub からのイメージ取得に速度制限が掛かる 7.8 iptables (legacy): unknown option \"--dport\" 7.9 docker ログイン時に \"Your password will be stored unencrypted\" 7.10 \"Could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network\" 7.11 Slow golang compilation\n- 8 参照\n\n- 1.1 Docker Compose\n- 1.2 Docker Desktop\n\n- 3.1 ストレージドライバー\n- 3.2 デーモンのソケット\n- 3.3 HTTP プロキシ 3.3.1 Docker デーモンのプロキシ設定 3.3.2 Docker コンテナのプロキシ設定\n- 3.4 DNS の設定\n- 3.5 イメージの置き場所\n- 3.6 安全ではないレジストリ\n- 3.7 IPv6\n- 3.8 ユーザ名前空間の隔離\n- 3.9 Rootless Docker デーモン\n- 3.10 ネイティブ overlay diff エンジンを有効化する\n\n- 3.3.1 Docker デーモンのプロキシ設定\n- 3.3.2 Docker コンテナのプロキシ設定\n\n- 4.1 Arch Linux\n- 4.2 Alpine Linux\n- 4.3 Debian\n- 4.4 Distroless\n\n- 5.1 実行中のコンテナの IP アドレスを取得する\n- 5.2 コンテナ内でグラフィカルなプログラムを実行する\n- 5.3 ブート時に Docker Compose プロジェクトを開始する\n- 5.4 クロスコンパイルに buildx を使う\n- 5.5 NVIDIA GPU で GPU アクセラレートされた Docker コンテナを動かす 5.5.1 NVIDIA Container Toolkit を使う (推奨) 5.5.2 NVIDIA Container Runtime を使う 5.5.3 CUDA 付き Arch Linux イメージ\n\n- 5.5.1 NVIDIA Container Toolkit を使う (推奨)\n- 5.5.2 NVIDIA Container Runtime を使う\n- 5.5.3 CUDA 付き Arch Linux イメージ\n\n- 7.1 systemd-networkd を使用していると、docker0 ブリッジが IP を取得できない / コンテナからインターネットにアクセスできない\n- 7.2 デフォルトで使用できるプロセスやスレッドの数が少なすぎる\n- 7.3 Error initializing graphdriver: devmapper\n- 7.4 Failed to create some/path/to/file: No space left on device\n- 7.5 virtualbox ドライバーを使用したときに Docker-machine が仮想マシンの作成に失敗する\n- 7.6 Docker を起動すると KVM のブリッジネットワークが壊れる\n- 7.7 Docker Hub からのイメージ取得に速度制限が掛かる\n- 7.8 iptables (legacy): unknown option \"--dport\"\n- 7.9 docker ログイン時に \"Your password will be stored unencrypted\"\n- 7.10 \"Could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network\"\n- 7.11 Slow golang compilation\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "Docker イメージを pull し Docker コンテナを実行するには、Docker Engine が必要です。Docker Engine には、コンテナを管理するデーモンや docker CLI フロントエンドが含まれています。docker パッケージをインストールしてください。開発版は docker-gitAUR パッケージをインストールしてください。次に、docker.service を起動/有効化して、動作することを確認してください:\n\n```\n# docker info\n```\n\nアクティブな vpn 接続がある場合、docker サービスの起動に失敗することがあることに注意してください。VPN と Docker のブリッジネットワークやオーバーレイネットワークの間で IP が競合するからです。このような場合、docker サービスの起動前に vpn を切断してみてください。その後すぐに vpn に再接続できます。ネットワークの衝突解除を試してみることも可能です (解決策については、 [1] や [2] をご覧ください)。\n\n次に、コンテナが動作することを検証します。次のコマンドは、最新の Arch Linux イメージをダウンロードし、そのイメージを使ってコンテナの中で Hello World プログラムを実行します:\n\n```\n# docker run -it --rm archlinux bash -c \"echo hello world\"\n```\n\ndocker CLI コマンドを非 root ユーザとして実行できるようにしたい場合は、ユーザーを docker グループに追加して、ログインし直し、docker.service を再起動してください。\n\n"
    },
    {
      "title": "Docker Compose",
      "level": 3,
      "content": "Docker Compose (日本語訳ページ) は Docker Engine の代替 CLI フロントエンドです。(例として) docker run のオプションを使うスクリプトではなく、docker-compose.yml YAML ファイルを使ってコンテナのプロパティを指定します。これは、しばしば使用されたり複雑な設定を持っていたりするサービスを何度も設定する際に便利です。Docker Compose を使うには、docker-compose をインストールしてください。\n\n"
    },
    {
      "title": "Docker Desktop",
      "level": 3,
      "content": "Docker Desktop は、Linux 仮想マシン内で Docker Engine を実行するプロプライエタリなデスクトップアプリケーションです。Kubernetes クラスタや脆弱性スキャナなどの追加の機能が含まれています。このアプリケーションは、macOS や Windows を使って Docker コンテナを開発するソフトウェア開発チームにとって便利です。このアプリケーションの Linux 移植は比較的新しく、Docker の CLI フロントエンドを補完します [3]。Arch 向けの実験的なパッケージは Docker によって直接提供されています; 詳細は マニュアル (日本語訳ページ) を見てください。残念ながら、そのパッケージには docker-compose パッケージと衝突するファイルが含まれているため、docker-compose がインストールされている場合はまずそれを削除する必要があります。\n\nまた、Docker Desktop を実行するには、Linux システム要件 (日本語訳ページ) を満たしている必要があります (要件には KVM による仮想化サポートが含まれています)。Gnome でのトレイアイコンを有効化するには、gnome-shell-extension-appindicator が必要です。\n\n最後に、ファイル共有サポートは、ユーザとグループの id を /etc/subuid と /etc/subgid を通してマッピングする必要があります。詳細は Docker Desktop For Linux のファイル共有に関する指示書 (日本語訳ページ) を見てください。\n\n"
    },
    {
      "title": "使用法",
      "level": 2,
      "content": "Docker は複数のパーツから成ります:\n\n- Docker デーモン (Docker Engine とも呼ばれています)。docker.service として実行されるプロセスです。Docker API を提供し、Docker コンテナを管理します。\n- docker CLI コマンド。ユーザがコマンドラインを通して Docker API と対話し、Docker デーモンを管理できるようにします。\n- Docker コンテナ。Docker API を通して要求された通りに Docker デーモンが起動・管理する、名前空間で隔離されたプロセスです。\n\n通常、ユーザは docker CLI コマンドを実行することで Docker を使用します。コマンドは Docker デーモンにアクションの実行を要求し、Docker コンテナを管理します。クライアント (docker)、サーバ (docker.service)、コンテナ間の関係を理解することは、Docker を正しく管理するために重要です。\n\nDocker デーモンが停止/再起動した場合、現在実行中の Docker コンテナもすべて停止/再起動されることに注意してください。\n\nDocker API にリクエストを送信して、docker CLI コマンドを使わずに Docker デーモンを制御することも可能です。詳細は Docker API 開発ドキュメントを見てください。\n\n使用法に関するドキュメントは the Docker Getting Started guide (日本語訳ページ) を見てください。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "設定ファイル /etc/docker/daemon.json を使うか、docker.service systemd ユニットにコマンドラインフラグを追加することで、Docker デーモンを設定することができます。Docker 公式ドキュメント (日本語訳ページ) によると、設定ファイルによる方法が推奨されています。コマンドラインフラグの方を使いたい場合は、systemd のドロップインファイル を使って、docker.service の ExecStart ディレクティブを上書きしてください。\n\ndaemon.json のオプションに関する詳細は、dockerd のドキュメント (日本語訳ページ) を見てください。\n\n"
    },
    {
      "title": "ストレージドライバー",
      "level": 3,
      "content": "ストレージドライバー (日本語訳ページ) は、Docker ホスト上でイメージとコンテナをどのように格納し管理するかを制御します。デフォルトの overlay2 ドライバはパフォーマンスが良く、最近の Linux カーネルとファイルシステムすべてで良い選択肢です。古い Linux カーネルとの互換性のために devicemapper や aufs などのレガシーなドライバがありますが、Arch Linux の overlay2 ではなくこれらを使う利点はありません。\n\nbtrfs や ZFS のユーザは btrfs や zfs のドライバを使用できます。それぞれのドライバは、これらのファイルシステムのユニークな機能を活用します。詳細とステップ・バイ・ステップの説明は btrfs ドライバ (日本語訳ページ) と zfs ドライバ (日本語訳ページ) のドキュメントを見てください。\n\n"
    },
    {
      "title": "デーモンのソケット",
      "level": 3,
      "content": "デフォルトで、Docker デーモンは Unix ソケット /var/run/docker.sock を用いて Docker API を提供します。ほとんどの場合、この方法は適切です。\n\nさらに TCP ソケットをリッスンするようにデーモンを設定できます。これにより、他のコンピュータからリモートで Docker API にアクセスできるようになります [4]。そうすることで、ホストマシン上の docker コマンドから Linux 仮想マシン (Windows や macOS システム上の Arch 仮想マシン) 上の Docker デーモンにアクセスできるようになり、便利です。\n\nデフォルトの docker.service ファイルは -H フラグをデフォルトでセットします。そして、フラグと /etc/docker/daemon.json ファイルの両方にオプションが存在する場合、Docker は起動しません。なので、ソケットの設定を変更する最も単純な方法は、ドロップインファイルを使うことです。以下は、ポート 2376 上に TCP ソケットを追加します:\n\n```\n/etc/systemd/system/docker.service.d/docker.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2376\n```\n\nsystemd デーモンをリロードし、docker.service を再起動して変更を適用してください。\n\n"
    },
    {
      "title": "HTTP プロキシ",
      "level": 3,
      "content": "HTTP プロキシを使うために設定すべきなのは、Docker デーモンと Docker コンテナです。\n\n"
    },
    {
      "title": "Docker デーモンのプロキシ設定",
      "level": 4,
      "content": "HTTP プロキシを設定するための systemd ドロップインユニットの設定に関する Docker ドキュメント (日本語訳ページ) を見てください。\n\n"
    },
    {
      "title": "Docker コンテナのプロキシ設定",
      "level": 4,
      "content": "docker CLI を使用して作成されたすべてのコンテナに対してプロキシを自動で設定する方法は プロキシ設定に関する Docker ドキュメント (日本語訳ページ) を見てください。\n\n"
    },
    {
      "title": "DNS の設定",
      "level": 3,
      "content": "Docker コンテナ内での DNS の動作に関するドキュメントや、DNS の設定のカスタマイズに関する情報は Docker の DNS に関するドキュメント (日本語訳ページ) を見てください。ほとんどの場合、ホストで設定されているリゾルバは、コンテナ内でも設定されています。\n\n127.0.0.0/8 でホストされている DNS リゾルバのほとんどは、コンテナとホストのネットワーク名前空間の衝突により、サポートされていません。そのようなリゾルバは、コンテナの /etc/resolv.conf から削除されます。このせいで /etc/resolv.conf が空になる場合は、Google DNS が代わりに使用されます。\n\nさらに、127.0.0.53 が、設定されている唯一のネームサーバである場合は、特殊なケースとして処理されます。この場合、Docker はリゾルバが systemd-resolved であると仮定し、/run/systemd/resolve/resolv.conf にある 上流の DNS リゾルバを使用します。\n\nIf you are using a service such as dnsmasq to provide a local resolver, consider adding a virtual interface with a link local IP address in the 169.254.0.0/16 block for dnsmasq to bind to instead of 127.0.0.1 to avoid the network namespace conflict.\n\n"
    },
    {
      "title": "イメージの置き場所",
      "level": 3,
      "content": "デフォルトでは、docker のイメージは /var/lib/docker に保存されます。置き場所は別のパーティションに移動することが可能です (例えば、イメージ用の専用のパーティションかディスクを使いたい場合)。ここでは、例として /mnt/docker にイメージを移動することにします。\n\nまず、docker.service を停止してください。すると、現在実行中のコンテナがすべて停止され、実行中のイメージはすべてアンマウントされます。これで、イメージを /var/lib/docker から目的の場所へ移動できるようになります (例: cp -r /var/lib/docker /mnt/docker)。\n\n/etc/docker/daemon.json 内の data-root を設定してください:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"data-root\": \"/mnt/docker\"\n}\n```\n\n変更を適用するために、docker.service を再起動してください。\n\n"
    },
    {
      "title": "安全ではないレジストリ",
      "level": 3,
      "content": "プライベートレジストリに自己署名証明書を使うことにした場合、あなたが信頼すると宣言するまで Docker はその使用を拒否します。例えば、myregistry.example.com:8443 でホストされているレジストリのイメージを許可するには、/etc/docker/daemon.json ファイル内の insecure-registries を設定してください:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"insecure-registries\": [\n    \"my.registry.example.com:8443\"\n  ]\n}\n```\n\n変更を適用するために docker.service を再起動してください。\n\n"
    },
    {
      "title": "IPv6",
      "level": 3,
      "content": "Docker で IPv6 のサポートを有効化するには、いくつかやるべきことがあります。詳細は [5] と [6] を見てください。\n\nまず、/etc/docker/daemon.json で ipv6 の設定を有効化し、特定の IPv6 サブネットを設定してください。ここでは、プライベート fd00::/80 サブネットを使用します。少なくとも 80 ビット以上のサブネットを使用してください。そうすることで、コンテナの IPv6 がコンテナの MAC アドレスで終わり、NDP ネイバーキャッシュの無効化問題を軽減できます。\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"ipv6\": true,\n  \"fixed-cidr-v6\": \"fd00::/80\"\n}\n```\n\n変更を適用するために docker.service を再起動してください。\n\n最後に、コンテナがホストネットワークにアクセスできるようにするために、プライベート IPv6 サブネットの使用に起因するルーティングの問題を解決する必要があります。実際にトラフィックを取得するために、IPv6 NAT を追加してください:\n\n```\n# ip6tables -t nat -A POSTROUTING -s fd00::/80 ! -o docker0 -j MASQUERADE\n```\n\nこれで、Docker で IPv6 が適切に有効化されているはずです。テストするには、以下を実行してください:\n\n```\n# docker run curlimages/curl curl -v -6 archlinux.org\n```\n\n以下のようなルールを追加することで、firewalld を使用できます:\n\n```\n# firewall-cmd --zone=public --add-rich-rule='rule family=\"ipv6\" destination not address=\"fd00::1/80\" source address=\"fd00::/80\" masquerade'\n```\n\nufw を使用する場合、まず Uncomplicated Firewall#Forward ポリシー に従って ipv6 フォワーディングを有効化する必要があります。次に、/etc/default/ufw を編集して、以下の行をアンコメントする必要があります:\n\n```\n/etc/ufw/sysctl.conf\n```\n\n```\nnet/ipv6/conf/default/forwarding=1\nnet/ipv6/conf/all/forwarding=1\n```\n\nそして、iptables のルールを追加できます:\n\n```\n# ip6tables -t nat -A POSTROUTING -s fd00::/80 ! -o docker0 -j MASQUERADE\n```\n\ndocker-compose を使用して作成された Docker コンテナには、対応するネットワークに対して networks 部で enable_ipv6: true を設定する必要がある場合があります。さらに、IPv6 サブネットの設定も必要になる場合があります。詳細は [7] (日本語訳ページ) を見てください。\n\n"
    },
    {
      "title": "ユーザ名前空間の隔離",
      "level": 3,
      "content": "デフォルトでは、Docker コンテナ内のプロセスはメインの dockerd デーモンと同じユーザ名前空間内で実行されます。つまり、コンテナは user_namespaces(7) の機能によって隔離されていません。これにより、ユーザーとグループ#パーミッションと所有権 に従って、コンテナ内のプロセスはホスト上に構成されたリソースにアクセスできます。これは互換性を最大化しますが、ホスト上のリソースに意図せずアクセスできてしまう特権昇格や情報漏えいの脆弱性が発見された場合は、セキュリティリスクが発生してしまいます (そのような脆弱性が2019年2月に公開され、パッチが適用されました)。\n\nそのような脆弱性による影響は、ユーザ名前空間の隔離 (日本語訳ページ) を有効化することで軽減できます。これは、それぞれのコンテナを別のユーザ名前空間内で実行し、ユーザ名前空間内の UID と GID をホスト上の (通常は非特権の) 異なる UID/GID 範囲に割り当てます。\n\n- メインの dockerd デーモンは依然としてホスト上で root として実行されます。Docker を rootless モード (日本語訳ページ) で実行するのは、これとは別の機能です。\n- コンテナ内のプロセスは、コンテナのイメージをビルドするために使用された Dockerfile 内の USER (日本語訳ページ) ディレクティブで定義されているユーザとして起動されます。\n- すべてのコンテナは、同じ UID/GID 範囲に割り当てられます。これにより、コンテナ間でボリュームを共有できることが保証されます。\n- ユーザ名前空間の隔離の有効化には、いくつかの制限 (日本語訳ページ) があります。\n- ユーザ名前空間の隔離を有効化すると、/var/lib/docker/ にある他の Docker オブジェクトだけでなく、既存のイメージやコンテナのレイヤーも効果的にマスクします。Docker はこれらのリソースの所有権を調整する必要があるからです。上流のドキュメントでは、既存の Docker 環境ではなく、新しい Docker 環境でこの機能を有効化することが推奨されています。\n\n/etc/docker/daemon.json 内の userns-remap を設定してください。default は特殊な値で、再割当てによって dockremap という名前のユーザとグループを自動的に作成します。\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"userns-remap\": \"default\"\n}\n```\n\n/etc/subuid と /etc/subgid で、ユーザ名/グループ名、再割当てユーザとグループに割り当てる開始 UID/GID と UID/GID 範囲サイズを設定してください。以下の例では、165536 から始まる、範囲 65536 の UID と GID を dockremap ユーザ・グループに割り当てます。\n\n```\n/etc/subuid\n```\n\n```\ndockremap:165536:65536\n```\n\n```\n/etc/subgid\n```\n\n```\ndockremap:165536:65536\n```\n\n設定を適用するために docker.service を再起動してください。\n\nこの変更を適用したあと、デフォルトですべてのコンテナは隔離されたユーザ名前空間内で実行されます。docker コマンドに --userns=host フラグを渡すことで、特定のコンテナ上で再割当てを部分的に無効化できます。詳細は [8] (日本語訳ページ) を見てください。\n\n"
    },
    {
      "title": "Rootless Docker デーモン",
      "level": 3,
      "content": "Docker デーモン自体を通常ユーザとして実行するには、docker-rootless-extrasAUR パッケージをインストールしてください。\n\n/etc/subuid と /etc/subgid に ユーザ名/グループ名、開始 UID/GID、そして UID/GID 範囲を設定し、再割り当てユーザ/グループに割り当てます:\n\n```\n/etc/subuid\n```\n\n```\nyour_username:165536:65536\n```\n\n```\n/etc/subgid\n```\n\n```\nyour_username:165536:65536\n```\n\ndocker.socket ユーザユニット を 有効化します。これにより、docker は systemd の socket activation を利用して開始されます。\n\n最後に docker ソケットの環境変数を設定します:\n\n```\n$ export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/docker.sock\n```\n\n"
    },
    {
      "title": "ネイティブ overlay diff エンジンを有効化する",
      "level": 3,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: これはあなたのシステムでは必要ないかもしれません。metacopy=on redirect_dir=on は Arch Linux カーネルでデフォルトとなっていますが、これらの設定は実行時に無効化されると一部のユーザが報告しています。 (議論: トーク:Docker#)\n\nデフォルトでは、Docker は Arch Linux 上でネイティブの overlay diff エンジンを使用できません。これにより、Docker イメージのビルドが遅くなります。頻繁にイメージをビルドする場合は、[9] で説明されているようにネイティブの diff エンジンを設定してください:\n\n```\n/etc/modprobe.d/disable-overlay-redirect-dir.conf\n```\n\n```\noptions overlay metacopy=off redirect_dir=off\n```\n\nその後、docker.service を停止し、以下のように overlay モジュールを再読込してください:\n\n```\n# modprobe -r overlay\n# modprobe overlay\n```\n\nそして、docker.service を再起動してください。\n\n確認するには、docker info を実行して、Native Overlay Diff が true になっているかどうか見てください。\n\n"
    },
    {
      "title": "Arch Linux",
      "level": 3,
      "content": "以下のコマンドは archlinux x86_64 イメージを pull します。これはネットワークなどを落とした Arch コア環境です:\n\n```\n# docker pull archlinux\n```\n\nREADME.md も見てください。\n\n完全な Arch ベースは、上記からリポジトリを clone し、独自のイメージをビルドしてください。\n\n```\n$ git clone https://gitlab.archlinux.org/archlinux/archlinux-docker.git\n```\n\nパッケージ devtools、fakechroot、fakeroot はインストールされていることに注意してください。\n\nベースイメージをビルドするには:\n\n```\n$ make image-base\n```\n\n"
    },
    {
      "title": "Alpine Linux",
      "level": 3,
      "content": "Alpine Linux は、(特に静的バイナリとしてコンパイルされたソフトウェアための) 小さなコンテナイメージとして人気の選択肢です。以下のコマンドは最新の Alpine Linux イメージを pull します:\n\n```\n# docker pull alpine\n```\n\nAlpine Linux は、ほとんどの Linux ディストリビューションで使用されている glibc libc 実装ではなく、musl libc 実装を使用します。Arch Linux は glibc を使用するので、Arch Linux ホストと Alpine Linux コンテナの間には機能的な違いが一定数存在し、ソフトウェアのパフォーマンスと正確性に影響を与えます。これらの違いのリストは、ここでドキュメント化されています。\n\nArch Linux (または glibc を使用する他のシステム) でビルドされた動的リンクのソフトウェアは、Alpine Linux (または異なる libc を使用する他のシステム) 上で実行すると、バグとパフォーマンス上の問題を生じる場合があります。例は、[10]、[11]、[12] を見てください。\n\n"
    },
    {
      "title": "Debian",
      "level": 3,
      "content": "次のコマンドは最新の debian イメージを pull します:\n\n```\n# docker pull debian\n```\n\n(各 Debian リリースの標準バージョンとスリムバージョンの療法を含む) 利用可能なタグの完全なリストは Docker Hub ページを見てください。\n\n"
    },
    {
      "title": "Distroless",
      "level": 3,
      "content": "Google は、パッケージマネージャやシェルなどの OS コンポーネントの無い最小イメージである distroless イメージをメンテナンスしています。これにより、ソフトウェアをパッケージングするためにイメージのサイズを非常に小さくできます。\n\nイメージのリストと様々なプログラミング言語での使用法に関する指示は GitHub README を見てください。\n\n"
    },
    {
      "title": "実行中のコンテナの IP アドレスを取得する",
      "level": 3,
      "content": "実行中のコンテナの IP アドレスを取得するには:\n\n```\n$ docker inspect --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' <container-name OR id>\n```\n\n```\n172.17.0.37\n```\n\nそれぞれの実行中のコンテナについて、/etc/hosts で使用するために、名前とそれに対応する IP アドレスを出力:\n\n```\n#!/usr/bin/env sh\nfor ID in $(docker ps -q | awk '{print $1}'); do\n    IP=$(docker inspect --format=\"{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}\" \"$ID\")\n    NAME=$(docker ps | grep \"$ID\" | awk '{print $NF}')\n    printf \"%s %s\\n\" \"$IP\" \"$NAME\"\ndone\n```\n\n"
    },
    {
      "title": "コンテナ内でグラフィカルなプログラムを実行する",
      "level": 3,
      "content": "このセクションでは、グラフィカルなプログラム (OpenGL や Vulkan に依存しているものを含む) をホストの X サーバ上で実行できるようにする手順を説明します。\n\nまず、(ホストのグラフィックハードウェアと互換性のある) 適切なドライバがコンテナ内にインストールされている必要があります。インストール手順はコンテナの種類に依存しますが、Arch Linux イメージベースのコンテナでは、OpenGL#インストール と Vulkan#インストール を参照してあなたのハードウェア固有のパッケージを調べてください。\n\n次に、コンテナがホストの X サーバにアクセスできるようにしなくてはなりません。シングルユーザな環境では、ホスト上で Xhost を実行すれば簡単に行なえます。Xhost は、非ネットワークなローカル接続をアクセス制御リストに追加します:\n\n```\n$ xhost +local:\n```\n\n最後に、以下のパラメータを docker run に渡す必要があります:\n\n- -e \"DISPLAY=$DISPLAY\": ホストのディスプレイを示す環境変数 DISPLAY をコンテナ内で設定します。\n- --mount type=bind,src=/tmp/.X11-unix,dst=/tmp/.X11-unix: ホストの X サーバソケットをコンテナ内部に同じパスでマウントします。\n- --device=/dev/dri:/dev/dri: コンテナにホストの Direct Rendering Infrastructure デバイスへのアクセス権を与えます。\n\nすべて正しくセットアップできたことを確認するには、コンテナ内で mesa-utils パッケージの glxgears や、vulkan-tools パッケージの vkcube を実行してみてください。\n\n"
    },
    {
      "title": "ブート時に Docker Compose プロジェクトを開始する",
      "level": 3,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: これは、compose.yml 内に restart: always がある場合は必須ではありません。[13] en:Talk:Docker#\"Start Docker Compose projects on boot\" Spurious? (議論: トーク:Docker#)\n\nまず、サービスの名前でパラメータ化された Docker Compose のテンプレートユニットを作成してください (systemd.service(5) § SERVICE TEMPLATES を参照):\n\n```\n/etc/systemd/system/docker-compose@.service\n```\n\n```\n[Unit]\nDescription=%i service with docker compose\nRequires=docker.service\nAfter=docker.service\n\n[Service]\nWorkingDirectory=/opt/%i\nExecStartPre=-/usr/bin/docker compose pull\nExecStart=/usr/bin/docker compose up --remove-orphans\nExecStop=/usr/bin/docker compose down\nExecReload=/usr/bin/docker compose pull\nExecReload=/usr/bin/docker compose up --remove-orphans\n\n[Install]\nWantedBy=multi-user.target\n```\n\nそして、実行したい各サービスに対して、Compose ファイルとその他必須のファイル (.env など) が入っているディレクトリを /opt/project_name に作成してください。[14]\n\n最後に、docker-compose@project_name.service を起動/有効化してください。\n\n"
    },
    {
      "title": "クロスコンパイルに buildx を使う",
      "level": 3,
      "content": "buildx CLI プラグイン は新しい BuildKit building toolkit (日本語訳ページ) を使用します。buildx インターフェイスはマルチプラットフォームなイメージのビルドをサポートしています (ホストのアーキテクチャ以外も)。\n\nイメージのクロスコンパイルには QEMU が必要です。Docker 内で QEMU の静的ビルドをセットアップする方法については、multiarch/qemu-user-static イメージの情報を見てください。あるいは、QEMU をホストのシステム上でセットアップして、Docker と一緒に使う方法については、QEMU#x86_64 から arm/arm64 環境への chrooting を見てください。どちらの場合にせよ、あなたのシステムはゲストアーキテクチャのユーザモードエミュレート用に設定されます。\n\n```\n$ docker buildx ls\n```\n\n```\nNAME/NODE DRIVER/ENDPOINT STATUS  PLATFORMS\ndefault * docker                  \n  default default         running linux/amd64, linux/386, linux/arm64, linux/riscv64, linux/s390x, linux/arm/v7, linux/arm/v6\n```\n\n"
    },
    {
      "title": "NVIDIA Container Toolkit を使う (推奨)",
      "level": 4,
      "content": "Docker バージョン 19.03 より、NVIDIA GPU が Docker デバイスとしてネイティブにサポートされています。NVIDIA GPU を活用するコンテナの実行方法として NVIDIA Container Toolkit が推奨されています。\n\nnvidia-container-toolkitAUR パッケージをインストールしてください。次に、docker を再起動してください。これで、--gpus オプションを使うことで、NVIDIA GPU を使用するコンテナを実行できるようになります:\n\n```\n# docker run --gpus all nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nコンテナ内でいくつの GPU を有効化するかを指定するには:\n\n```\n# docker run --gpus 2 nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nどの GPU を使用するかを指定するには:\n\n```\n# docker run --gpus '\"device=1,2\"' nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nあるいは\n\n```\n# docker run --gpus '\"device=UUID-ABCDEF,1\"' nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nTable content:\nこの記事またはセクションの正確性には問題があります。 理由: 以下のエラーが発生する場合のより詳細な情報が必要です。これは機能するはずです。[15][リンク切れ 2023-04-23] を参照してください。en:Talk:Docker#GPU accelerated Docker Nvidia (議論: トーク:Docker#)\n\n上記のコマンドを使っていて、Failed to initialize NVML: Unknown Error のようなエラーが発生する場合、GPU をより具体的に指定してみてください:\n\n```\n# docker run --gpus all --device /dev/nvidiactl:/dev/nvidiactl --device /dev/nvidia-uvm:/dev/nvidia-uvm --device /dev/nvidia0:/dev/nvidia0 nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\nコンテナで使用する機能 (グラフィックス、計算、...) を指定するには (とはいえ、この方法が使用されるのは稀です):\n\n```\n# docker run --gpus all,capabilities=utility nvidia/cuda:12.1.1-runtime-ubuntu22.04 nvidia-smi\n```\n\n詳細は README.md と Wiki を見てください。\n\n"
    },
    {
      "title": "NVIDIA Container Runtime を使う",
      "level": 4,
      "content": "nvidia-container-runtimeAUR パッケージをインストールしてください。次に、/etc/docker/daemon.json を編集して NVIDIA ランタイムを登録してください:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"runtimes\": {\n    \"nvidia\": {\n      \"path\": \"/usr/bin/nvidia-container-runtime\",\n      \"runtimeArgs\": []\n    }\n  }\n}\n```\n\nそして、docker を再起動してください。\n\nランタイムは、dockerd にコマンドラインオプションを渡すことでも登録できます:\n\n```\n# /usr/bin/dockerd --add-runtime=nvidia=/usr/bin/nvidia-container-runtime\n```\n\nその後、GPU アクセラレートされたコンテナを実行するには:\n\n```\n# docker run --runtime=nvidia nvidia/cuda:9.0-base nvidia-smi\n```\n\nあるいは (以下の方法は Docker バージョン 19.03 およびそれ以降が必要です):\n\n```\n# docker run --gpus all nvidia/cuda:9.0-base nvidia-smi\n```\n\nREADME.md も見てください。\n\n"
    },
    {
      "title": "CUDA 付き Arch Linux イメージ",
      "level": 4,
      "content": "以下の Dockerfile を使うことで、CUDA 付きのカスタム Arch Linux イメージをビルドできます。ホスト上で pacman パッケージをキャッシュするために Dockerfile frontend syntax 1.2 を使用します。Docker イメージをビルドする前に、クライアント上で DOCKER_BUILDKIT=1 環境変数を設定する必要があります。\n\n```\nDockerfile\n```\n\n```\n# syntax = docker/dockerfile:1.2\n\nFROM archlinux\n\n# install packages\nRUN --mount=type=cache,sharing=locked,target=/var/cache/pacman \\\n    pacman -Syu --noconfirm --needed base base-devel cuda\n\n# configure nvidia container runtime\n# https://github.com/NVIDIA/nvidia-container-runtime#environment-variables-oci-spec\nENV NVIDIA_VISIBLE_DEVICES all\nENV NVIDIA_DRIVER_CAPABILITIES compute,utility\n```\n\n"
    },
    {
      "title": "Docker とイメージの削除",
      "level": 2,
      "content": "Docker を完全に削除したい場合は以下の手順に従ってください。\n\n実行中のコンテナをチェックする:\n\n```\n# docker ps\n```\n\n削除するために、ホスト上で実行中のコンテナをすべて表示する:\n\n```\n# docker ps -a\n```\n\n実行中のコンテナを停止する:\n\n```\n# docker stop <CONTAINER ID>\n```\n\n依然として実行中のコンテナを kill する:\n\n```\n# docker kill <CONTAINER ID>\n```\n\nID でリストされたコンテナを削除する:\n\n```\n# docker rm <CONTAINER ID>\n```\n\nDocker イメージをすべて表示する:\n\n```\n# docker images\n```\n\nID でイメージを削除する:\n\n```\n# docker rmi <IMAGE ID>\n```\n\nコンテナに関連付けられていない (ダングリング) すべてのイメージ、コンテナ、ボリューム、ネットワークを削除する:\n\n```\n# docker system prune\n```\n\n停止中のコンテナと未使用のイメージ (ダングリングイメージでないもの) を追加で削除するには、-a フラグをコマンドに追加してください:\n\n```\n# docker system prune -a\n```\n\nすべての Docker データを削除する (ディレクトリを削除する):\n\n```\n# rm -R /var/lib/docker\n```\n\n"
    },
    {
      "title": "systemd-networkd を使用していると、docker0 ブリッジが IP を取得できない / コンテナからインターネットにアクセスできない",
      "level": 3,
      "content": "Docker はグローバルに IP フォワーディングを有効化しようと試みますが、デフォルトでは、定義されているネットワークプロファイルのグローバルな sysctl 設定を systemd-networkd が上書きしてしまいます。ネットワークプロファイルに IPForward=yes を設定してください。詳しくは インターネット共有#パケット転送の有効化 を参照してください。\n\nsystemd-networkd が Docker によって作成されたネットワークインターフェイスを管理しようとする場合 (例えば、Match セクションに Name=* を設定した場合)、接続の問題が発生する可能性があります。それらのインターフェイスの管理を無効化してみてください。例えば、networkctl list を実行すると、SETUP 列ですべての Docker によって作成されたネットワークは unmanaged と表示される必要があります。\n\n- systemd-networkd.service や iptables.service を再起動したときは docker.service を再起動する必要があります。\n- また、デフォルトで nftables が docker の接続をブロックする可能性も考慮してください。nft list ruleset を使ってブロックしているルールを確認してください。nft flush chain inet filter forward で一時的に全ての転送ルールを削除できます。変更を永続化するには /etc/nftables.conf を編集してください。設定ファイルからルールをリロードするために nftables.service を再起動することを忘れないでください。Docker での nftables サポートに関する詳細は [16] を見てください。\n\n"
    },
    {
      "title": "デフォルトで使用できるプロセスやスレッドの数が少なすぎる",
      "level": 3,
      "content": "以下のようなエラーメッセージが表示される場合:\n\n```\n# Java の場合\njava.lang.OutOfMemoryError: unable to create new native thread\n# C、bash などの場合\nfork failed: Resource temporarily unavailable\n```\n\nsystemd によって許可されるプロセスの数を調整する必要があります。以下のように docker.service を編集してください:\n\n```\n[Service]\nTasksMax=infinity\n```\n\nより詳細な背景情報は、systemd-system.conf(5) § OPTIONS の DefaultLimitNPROC を見てください。また、systemd.resource-control(5) § OPTIONS の TasksMax も見てください。\n\n"
    },
    {
      "title": "Error initializing graphdriver: devmapper",
      "level": 3,
      "content": "systemctl で docker の起動に失敗して以下のエラーが表示される場合:\n\n```\nError starting daemon: error initializing graphdriver: devmapper: Device docker-8:2-915035-pool is not a thin pool\n```\n\nエラーを解消するには、サービスを停止して、/var/lib/docker/ を (必要に応じて) バックアップし、/var/lib/docker/ の中身を消してから、サービスを起動してみてください。詳しくは GitHub issue を参照。\n\n"
    },
    {
      "title": "Failed to create some/path/to/file: No space left on device",
      "level": 3,
      "content": "以下のようにエラーメッセージが表示される場合:\n\n```\nERROR: Failed to create some/path/to/file: No space left on device\n```\n\nDocker イメージの作成・実行時、ディスク容量が十分に存在するにもかかわらず、上記のメッセージが表示されるときは以下を確認してください:\n\n- Tmpfs が無効になっているか。十分なメモリが割り当てられているか。Docker が /tmp にファイルを書き出そうとしていて、ディスク容量ではなくメモリ使用量が制限となっている可能性があります。\n- XFS を使っている場合、/etc/fstab の (/tmp や /var/lib/docker がある) エントリから noquota マウントオプションを削除するべきかもしれません。詳しくはディスククォータを参照してください。Docker ストレージドライバーの overlay2 を使用するときは特に注意してください。\n- XFS クォータのマウントオプション (uquota, gquota, prjquota など) がファイルシステムの再マウント時に失敗している。ルートファイルシステムでクォータを使うには、マウントオプションを rootflags= カーネルパラメータで initramfs に渡す必要があります。その場合、root (/) ファイルシステムのマウントオプションとして /etc/fstab に指定してはいけません。\n\n"
    },
    {
      "title": "virtualbox ドライバーを使用したときに Docker-machine が仮想マシンの作成に失敗する",
      "level": 3,
      "content": "以下のように virtualbox ドライバーで docker-machine が仮想マシンの作成に失敗する場合:\n\n```\nVBoxManage: error: VBoxNetAdpCtl: Error while adding new interface: failed to open /dev/vboxnetctl: No such file or directory\n```\n\nvboxreload で CLI から virtualbox をリロードしてください。\n\n"
    },
    {
      "title": "Docker を起動すると KVM のブリッジネットワークが壊れる",
      "level": 3,
      "content": "この問題は、Docker のスクリプトがいくつかの iptables ルールを追加し、それ自体のインターフェイス以外のインターフェイスのフォワーディングをブロックしてしまうというものです。これは既知の問題です。\n\n以下の解決策では、br0 をあなたのブリッジ名に置き換えてください。\n\n最も速い解決策は (しかし、これは Docker の iptabkes 自己追加調整機能をすべて無効化してしまいます。これは望ましくない場合があります。):\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"iptables\": false\n}\n```\n\nKVM 用に設定されたネットワークブリッジがすでに存在する場合、Docker にそのことを伝えることで解決できる場合があります。[18] を見て、以下のように docker の設定を変更してください:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"bridge\": \"br0\"\n}\n```\n\n上記の設定がうまく行かない場合や、UFW のようなマネージャ、あるいは iptables を通して直接この問題を解決したい場合、以下を追加してください:\n\n```\niptables -I FORWARD -i br0 -o br0 -j ACCEPT\n```\n\n更に詳しい解決策は ここ にあります。\n\n"
    },
    {
      "title": "Docker Hub からのイメージ取得に速度制限が掛かる",
      "level": 3,
      "content": "2020年11月1日より、無名アカウントや無料アカウントによる Docker Hub からのダウンロードには速度制限がかかるようになりました。詳細は 速度制限に関するドキュメント を見てください。\n\n認証されていない速度制限はソースの IP によって追跡され、認証済みの速度制限はアカウントによって追跡されます。\n\n速度制限を超過する必要がある場合、有料プランに登録するか、必要なイメージを別のイメージレジストリでミラーすることで可能です。自分自身のレジストリをホストする (日本語訳ページ) こともできますし、Amazon ECR、Google Container Registry、Azure Container Registry、Quay Container Registry などのクラウドでホストされているレジストリを使うこともできます。\n\nイメージをミラーするには、Docker CLI のサブコマンド pull、tag、push を使ってください。例えば、Nginx イメージの 1.19.3 タグを、cr.example.com でホストされているレジストリでミラーするには:\n\n```\n$ docker pull nginx:1.19.3\n$ docker tag nginx:1.19.3 cr.example.com/nginx:1.19.3\n$ docker push cr.example.com/nginx:1.19.3\n```\n\nその後に、そのミラーからイメージを pull または実行することができます:\n\n```\n$ docker pull cr.example.com/nginx:1.19.3\n$ docker run cr.example.com/nginx:1.19.3\n```\n\n"
    },
    {
      "title": "iptables (legacy): unknown option \"--dport\"",
      "level": 3,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: Nftables#Docker と共に使う では、iptables-nft を使用しないことが推奨されています。 (議論: トーク:Docker#)\n\nコンテナの実行中にこのエラーが発生する場合は、iptables (legacy) の代わりに iptables-nft をインストールして、再起動してください [19]。\n\n"
    },
    {
      "title": "docker ログイン時に \"Your password will be stored unencrypted\"",
      "level": 3,
      "content": "デフォルトでは、Docker はレジストリパスワードを保存するために pass や secretservice バイナリの使用を試みます。これらのバイナリが見つからない場合、Docker はパスワードを平文 (base64 エンコード) で $HOME/.docker/config.json に保存し、ログイン成功後に以下のメッセージを出力します:\n\n```\n$ WARNING! Your password will be stored unencrypted in /home/username/.docker/config.json.\n```\n\nSecret Service Freedesktop DBUS API を実装しているパスワードマネージャ (KDE の KWallet や GNOME の gnome-keyring など) を使用している場合、パスワードをパスワードマネージャに保存するための docker-credentials-secretserviceAUR パッケージをインストールすることができます。\n\n"
    },
    {
      "title": "\"Could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network\"",
      "level": 3,
      "content": "Sometimes if you use a lot of Docker projects (ex. using docker-compose) it can happens that you run out of available IPs for Docker containers triggering the error:\n\n```\nCould not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network\n```\n\nAs found on this Docker issue, the defaults are:\n\nTable content:\nType | Default Size | Default Pool\nlocal | /16 | 172.17.0.0/12\nlocal* | /20 | 192.168.0.0/16\n\nThis can be easily fixed increasing the Docker IP space by configuring default-address-pools in /etc/docker/daemon.json increasing the size value from 16 to 24 on the first IP range, keeping the second one unaltered to avoid ip collision on the local network:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  ...\n  \"default-address-pools\" : [\n    {\n      \"base\" : \"172.17.0.0/12\",\n      \"size\" : 24\n    },\n    {\n      \"base\" : \"192.168.0.0/16\",\n      \"size\" : 24\n    }\n  ]\n}\n```\n\nRestart docker.service to apply changes.\n\nMore details and technical explanations can be found on the following excellent article: The definitive guide to docker's default-address-pools option.\n\n"
    },
    {
      "title": "Slow golang compilation",
      "level": 3,
      "content": "Due to a ulimit configuration, building a docker image and its dependances with makepkg is very slow (stuck at \"Entering fakeroot environment...\" step).\n\nIt is related to [20] and [21].\n\nYou can add --ulimit \"nofile=1024:524288\" to your docker build option or create/edit:\n\n```\n/etc/docker/daemon.json\n```\n\n```\n{\n  \"default-ulimits\": {\n    \"nofile\": {\n      \"Name\": \"nofile\",\n      \"Soft\": 1024,\n      \"Hard\": 524288\n    }\n  }\n}\n```\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- 公式ウェブサイト\n- docs.docker.com の Arch Linux (日本語訳)\n- Are Docker containers really secure? — opensource.com\n- Awesome Docker\n- Why A Privileged Container in Docker Is a Bad Idea\n\n"
    }
  ]
}