{
  "title": "Bash/Функции",
  "url": "https://wiki.archlinux.org/title/Bash/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Bash также поддерживает функции. Функции можно добавлять напрямую в ~/.bashrc или же в отдельный файл, который затем будет считан и исполнен из ~/.bashrc. Дополнительные примеры можно найти на форуме.\n\n"
    },
    {
      "title": "Отображение кодов ошибок",
      "level": 2,
      "content": "Создайте trap для перехвата ненулевого (означающего ошибку) кода возврата из последней запущенной программы:\n\n```\n~/.bashrc\n```\n\n```\nEC() {\n\techo -e '\\e[1;33m'code $?'\\e[m\\n'\n}\ntrap EC ERR\n```\n\n"
    },
    {
      "title": "Компиляция и запуск кода Cи на лету",
      "level": 2,
      "content": "Представленная ниже функция скомпилирует (в каталоге /tmp/) и запустит файл с исходным кодом на языке Си \"на лету\" (запуск будет произведен без аргументов). После завершения работы программы скомпилированный файл будет удален.\n\n```\ncsource() {\n\t[[ $1 ]]    || { echo \"Missing operand\" >&2; return 1; }\n\t[[ -r $1 ]] || { printf \"File %s does not exist or is not readable\\n\" \"$1\" >&2; return 1; }\n\tlocal output_path=${TMPDIR:-/tmp}/${1##*/};\n\tgcc \"$1\" -o \"$output_path\" && \"$output_path\";\n\trm \"$output_path\";\n\treturn 0;\n}\n```\n\n"
    },
    {
      "title": "Извлечение",
      "level": 2,
      "content": "Следующая функция извлекает данные из архивов различных типов. Запуск производится в виде extract <file1> <file2> ....\n\n```\nextract() {\n    local c e i\n\n    (($#)) || return\n\n    for i; do\n        c=''\n        e=1\n\n        if [[ ! -r $i ]]; then\n            echo \"$0: file is unreadable: \\`$i'\" >&2\n            continue\n        fi\n\n        case $i in\n            *.t@(gz|lz|xz|b@(2|z?(2))|a@(z|r?(.@(Z|bz?(2)|gz|lzma|xz)))))\n                   c=(bsdtar xvf);;\n            *.7z)  c=(7z x);;\n            *.Z)   c=(uncompress);;\n            *.bz2) c=(bunzip2);;\n            *.exe) c=(cabextract);;\n            *.gz)  c=(gunzip);;\n            *.rar) c=(unrar x);;\n            *.xz)  c=(unxz);;\n            *.zip) c=(unzip);;\n            *.zst) c=(unzstd);;\n            *)     echo \"$0: unrecognized file extension: \\`$i'\" >&2\n                   continue;;\n        esac\n\n        command \"${c[@]}\" \"$i\"\n        ((e = e || $?))\n    done\n    return \"$e\"\n}\n```\n\nТо же самое можно сделать с помощью специальных пакетов, см. Archiving and compression tools#Convenience tools.\n\n"
    },
    {
      "title": "cd и ls одной командой",
      "level": 2,
      "content": "Очень часто после смены каталога пользователь запускает ls, чтобы просмотреть его содержимое. Есть определённый смысл объединить cd и ls с помощью функции. Функция будет называться cl (change list) и станет выдавать сообщение об ошибке, если выбранный каталог не существует.\n\n```\ncl() {\n\tlocal dir=\"$1\"\n\tlocal dir=\"${dir:=$HOME}\"\n\tif [[ -d \"$dir\" ]]; then\n\t\tcd \"$dir\" >/dev/null; ls\n\telse\n\t\techo \"bash: cl: $dir: Directory not found\"\n\tfi\n}\n```\n\nКоманду ls можно модифицировать, например ls -hall --color=auto.\n\n"
    },
    {
      "title": "Простая записная книжка",
      "level": 2,
      "content": "```\nnote () {\n    # if file doesn't exist, create it\n    if [[ ! -f $HOME/.notes ]]; then\n        touch \"$HOME/.notes\"\n    fi\n\n    if ! (($#)); then\n        # no arguments, print file\n        cat \"$HOME/.notes\"\n    elif [[ \"$1\" == \"-c\" ]]; then\n        # clear file\n        printf \"%s\" > \"$HOME/.notes\"\n    else\n        # add all arguments to file\n        printf \"%s\\n\" \"$*\" >> \"$HOME/.notes\"\n    fi\n}\n```\n\n"
    },
    {
      "title": "Простой планировщик задач",
      "level": 2,
      "content": "По мотивам #Простая записная книжка.\n\n```\ntodo() {\n    if [[ ! -f $HOME/.todo ]]; then\n        touch \"$HOME/.todo\"\n    fi\n\n    if ! (($#)); then\n        cat \"$HOME/.todo\"\n    elif [[ \"$1\" == \"-l\" ]]; then\n        nl -b a \"$HOME/.todo\"\n    elif [[ \"$1\" == \"-c\" ]]; then\n        > $HOME/.todo\n    elif [[ \"$1\" == \"-r\" ]]; then\n        nl -b a \"$HOME/.todo\"\n        eval printf %.0s- '{1..'\"${COLUMNS:-$(tput cols)}\"\\}; echo\n        read -p \"Type a number to remove: \" number\n        sed -i ${number}d $HOME/.todo \"$HOME/.todo\"\n    else\n        printf \"%s\\n\" \"$*\" >> \"$HOME/.todo\"\n    fi\n}\n```\n\n"
    },
    {
      "title": "Калькулятор",
      "level": 2,
      "content": "```\ncalc() {\n    echo \"scale=3;$@\" | bc -l\n}\n```\n\n"
    },
    {
      "title": "Kingbash",
      "level": 2,
      "content": "Kingbash — автодополнение на основе меню (см. BBS#101010).\n\nУстановите пакет kingbash-gb-gitAUR[ссылка недействительна: package not found] из AUR, после чего добавьте следующий код в ~/.bashrc:\n\n```\nfunction kingbash.fn() {\n    echo -n \"KingBash> $READLINE_LINE\" #Where \"KingBash> \" looks best if it resembles your PS1, at least in length.\n    OUTPUT=$(/usr/bin/kingbash \"$(compgen -ab -A function)\")\n    READLINE_POINT=$(echo \"$OUTPUT\" | tail -n 1)\n    READLINE_LINE=$(echo \"$OUTPUT\" | head -n -1)\n    echo -ne \"\\r\\e[2K\"\n}\nbind -x '\"\\t\":kingbash.fn'\n```\n\n"
    },
    {
      "title": "Информация об IP-адресе",
      "level": 2,
      "content": "Подробная информация об IP-адресе и имени хоста с сайта https://ipinfo.io:\n\n```\nipif() { \n    if grep -P \"(([1-9]\\d{0,2})\\.){3}(?2)\" <<< \"$1\"; then\n\t curl ipinfo.io/\"$1\"\n    else\n\tipawk=($(host \"$1\" | awk '/address/ { print $NF }'))\n\tcurl ipinfo.io/${ipawk[1]}\n    fi\n    echo\n}\n```\n\n"
    }
  ]
}