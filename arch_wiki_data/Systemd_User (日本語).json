{
  "title": "Systemd/User (日本語)",
  "url": "https://wiki.archlinux.org/title/Systemd/User_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- systemd\n- 仮想コンソールに自動ログイン\n- ログイン時に X を起動\n\nsystemd は、ユーザーの制御下でサービスを管理するためのユーザーごとの systemd インスタンスを提供し、ユーザー自身の user units を開始、停止、有効化、無効化できるようにします。これは、mpd のような単一ユーザー向けに一般的に実行されるデーモンやサービス、またはメールの取得のような自動化されたタスクを実行するのに便利です。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 利用方法\n- 2 基本設定 2.1 環境変数 2.1.1 Systemd ユーザーインスタンス 2.1.2 サービス例 2.1.3 DISPLAY と XAUTHORITY 2.1.4 PATH 2.1.5 pam_environment 2.2 systemd のユーザーインスタンスを自動起動\n- 3 ユーザーユニットを書く 3.1 サンプル 3.2 変数を使用したサンプル 3.3 ジャーナルを読み込む\n- 4 一時ファイル\n- 5 Xorg と systemd 5.1 ディスプレイマネージャを使わずに Xorg に自動ログイン 5.2 systemd のユーザーサービスとしての Xorg\n- 6 ユースケース 6.1 永続的なターミナルマルチプレクサ 6.2 ウィンドウマネージャ\n- 7 ログアウト時にユーザープロセスを終了\n- 8 トラブルシューティング 8.1 ランタイムディレクトリ '/run/user/1000' は、UID1000 によって所有されていません 8.2 \"A stop job is running for User Manager for UID 1000\" 8.2.1 問題のあるサービスを特定してオーバーライドする 8.2.2 タイムアウト値の変更\n- 9 参照\n\n- 2.1 環境変数 2.1.1 Systemd ユーザーインスタンス 2.1.2 サービス例 2.1.3 DISPLAY と XAUTHORITY 2.1.4 PATH 2.1.5 pam_environment\n- 2.2 systemd のユーザーインスタンスを自動起動\n\n- 2.1.1 Systemd ユーザーインスタンス\n- 2.1.2 サービス例\n- 2.1.3 DISPLAY と XAUTHORITY\n- 2.1.4 PATH\n- 2.1.5 pam_environment\n\n- 3.1 サンプル\n- 3.2 変数を使用したサンプル\n- 3.3 ジャーナルを読み込む\n\n- 5.1 ディスプレイマネージャを使わずに Xorg に自動ログイン\n- 5.2 systemd のユーザーサービスとしての Xorg\n\n- 6.1 永続的なターミナルマルチプレクサ\n- 6.2 ウィンドウマネージャ\n\n- 8.1 ランタイムディレクトリ '/run/user/1000' は、UID1000 によって所有されていません\n- 8.2 \"A stop job is running for User Manager for UID 1000\" 8.2.1 問題のあるサービスを特定してオーバーライドする 8.2.2 タイムアウト値の変更\n\n- 8.2.1 問題のあるサービスを特定してオーバーライドする\n- 8.2.2 タイムアウト値の変更\n\n"
    },
    {
      "title": "利用方法",
      "level": 2,
      "content": "ユーザーがログインを行うと、systemd は自動的にユーザーサービスを管理する systemd --user インスタンスを起動します。このプロセスは、そのユーザーにセッションが残っているかぎり生存し、ユーザーの最後のセッションが閉じられた時に終了します。systemd のユーザーインスタンスを自動起動している場合、インスタンスはブート時に起動し、終了しません。ユーザーサービスを使うことで、ソケットアクティベーションやタイマー、システムの依存関係や cgroups によるプロセスの制限など、systemd の恩恵を最大限活用して、デーモンや自動化されたタスクを実行できます。\n\nユーザーユニットはシステムサービスと同じように以下のディレクトリに配置されます (優先度が低い順):\n\n- /usr/lib/systemd/user/: インストールしたパッケージに含まれているサービス\n- ~/.local/share/systemd/user/: ホームディレクトリにインストールしたパッケージのユニット\n- /etc/systemd/user/: システムの管理者が配置する、全てのユーザーが使えるユーザーサービス\n- ~/.config/systemd/user/: ユーザーが配置する、そのユーザーのサービス\n\nsystemd のユーザーインスタンスが起動すると、default.target ターゲットが立ち上がります。その後 systemctl --user を使って手動で systemd のユーザーインスタンスを制御できるようになります。\n\n- バージョン206から、systemd --user インスタンスはユーザーごとのプロセスであり、セッションごとのプロセスではないので注意してください。ソケットやステートファイルなどのユーザーサービスによって扱われるリソースはセッションごとではなくユーザーごとに割り振られる (ユーザーのホームディレクトリ上に存在する) というのが原則です。つまりユーザーサービスは全てセッションとは関係なく動作します。結果として、セッションの中で実行する必要があるプログラムはユーザーサービスの中で壊れてしまう可能性があります。systemd のユーザーセッションの扱い方は流動的であり確定していません。[1] や [2] が今後どうなるかのヒントになるでしょう。\n- systemd --user は systemd --system プロセスとは別のプロセスを起動します。ユーザーユニットからシステムユニットに依存したり参照することはできません。\n\n"
    },
    {
      "title": "基本設定",
      "level": 2,
      "content": "すべてのユーザー単位は ~/.config/systemd/user/ に配置されます。最初のログイン時に単位を起動したい場合は、起動したい任意の単位に対して systemctl --user enable unit を実行してください。\n\n"
    },
    {
      "title": "環境変数",
      "level": 3,
      "content": "systemd のユーザーインスタンスは .bashrc などに設定された環境変数を全く継承しません。systemd インスタンスに環境変数を設定する方法は複数存在します:\n\n- $HOME ディレクトリが存在するユーザーの場合、~/.config/environment.d/ ディレクトリに NAME=VAL という形式で環境変数を記述した .conf ファイルを作成する。ユーザーのユニットファイルにのみ影響します。詳しくは environment.d(5) を見てください。\n- /etc/systemd/user.conf で DefaultEnvironment オプションを使う。全てのユーザーユニットに影響します。\n- /etc/systemd/system/user@.service.d/ に設定ファイルを追加する。全てのユーザーユニットに影響します。#サービス例を参照。\n- /etc/systemd/system/user@.service.d/ にドロップイン設定ファイルを追加する (すべてのユーザーに影響)、詳細は #サービス例を参照。\n- 適宜、systemctl --user set-environment や systemctl --user import-environment を使う。環境変数を設定した後に起動したユーザーユニットには影響しますが、既に起動しているユニットには影響しません。\n- D-Bus の dbus-update-activation-environment --systemd --all コマンドを使う。systemctl --user import-environment と同じ効果があり、D-Bus セッションに適用されます。コマンドはシェルの初期化ファイルの末尾に追加できます。\n- ユーザー環境全体の環境変数は systemd のジェネレータによって読み込まれる environment.d ディレクトリを使用できます。詳しくは environment.d(5) を参照。\n- ユーザーごとに異なる環境変数を生成できる systemd.environment-generator(7) スクリプトを作成することもできます。ユーザーごとの環境が必要な場合(XDG_RUNTIME_DIR や DBUS_SESSION_BUS_ADDRESS などが該当)、これはおそらく最適な方法です。\n\n設定するべき変数としては PATH などが考えられます。\n\n設定後、コマンド systemctl --user show-environment を使用して値が正しいことを確認できます。変更を即座に反映させるには、systemctl --user daemon-reload を実行する必要があるかもしれません。\n\n"
    },
    {
      "title": "Systemd ユーザーインスタンス",
      "level": 4,
      "content": "上記はユーザー単位のデフォルト環境変数についてのみ説明しています。しかし、systemd ユーザーインスタンス自体もいくつかの環境変数の影響を受けます。特に、特定の指定子 (systemd.unit(5) § SPECIFIERS を参照) は XDG 変数 の影響を受けます。\n\nただし、systemd ユーザーインスタンスは 起動時に設定された環境変数のみ を使用します。特に、ファイルを解析しようとはしません (upstream bug #29414 (closed WONTFIX) を参照) そのため、このような環境変数が必要な場合は、ドロップイン設定ファイルで設定する必要があります (#サービス例を参照)\n\nsystemd はこれらの値を確認するための内部ツールを提供していませんが、指定子が期待通りに展開されることを確認するために、次のようなサービスを使用できます。\n\n```\n$XDG_CONFIG_HOME/systemd/user/test-specifiers.service\n```\n\n```\n[Service]\nType=oneshot\nExecStart=printf '(systemd)=(envvar)\\n'\nExecStart=printf '%%s=%%s\\n' %C \"${XDG_CACHE_HOME}\"\nExecStart=printf '%%s=%%s\\n' %E \"${XDG_CONFIG_HOME}\"\nExecStart=printf '%%s=%%s\\n' %L \"${XDG_STATE_HOME}\"/log\nExecStart=printf '%%s=%%s\\n' %S \"${XDG_STATE_HOME}\"\nExecStart=printf '%%s=%%s\\n' %t \"${XDG_RUNTIME_DIR}\"\n```\n\n"
    },
    {
      "title": "サービス例",
      "level": 4,
      "content": "ドロップインディレクトリ /etc/systemd/system/user@.service.d/ を作成して、その中に拡張子が .conf のファイルを作成します (例: local.conf):\n\n```\n/etc/systemd/system/user@.service.d/local.conf\n```\n\n```\n[Service]\nEnvironment=\"PATH=/usr/lib/ccache/bin:/usr/local/bin:/usr/bin:/bin\"\nEnvironment=\"EDITOR=nano -c\"\nEnvironment=\"BROWSER=firefox\"\nEnvironment=\"NO_AT_BRIDGE=1\"\n```\n\n"
    },
    {
      "title": "DISPLAY と XAUTHORITY",
      "level": 4,
      "content": "DISPLAY は X アプリケーションがどのディスプレイを使えばいいのか知るために使用されます。XAUTHORITY はユーザーの .Xauthority ファイルのパスと、X サーバーにアクセスするのに必要な cookie を指定します。systemd ユニットから X アプリケーションを起動する場合、これらの変数を設定する必要があります。バージョン 219 から、セッションが開始したときに DISPLAY と XAUTHORITY を systemd --user デーモンの環境にアップロードする X11 セッションアプレット /etc/X11/xinit/xinitrc.d/50-systemd-user.sh が systemd に付属するようになりました。これによって、X を標準の方法で起動しているかぎり、ユーザーサービスは DISPLAY や XAUTHORITY を使用することができるようになっています。\n\n"
    },
    {
      "title": "PATH",
      "level": 4,
      "content": "PATH 変数を .bashrc や .bash_profile で設定しても systemd では使うことができません。PATH をカスタマイズしており、それを利用するアプリケーションを systemd ユニットから起動する予定があるなら、systemd 環境に PATH を設定する必要があります。PATH を .bash_profile に設定している場合、以下を PATH 変数を設定した後の .bash_profile に追加するのが systemd で PATH を設定する一番簡単な方法です:\n\n```\n~/.bash_profile\n```\n\n```\nsystemctl --user import-environment PATH\n```\n\n"
    },
    {
      "title": "pam_environment",
      "level": 4,
      "content": "pam_env.so モジュールを利用することで環境変数を設定できます。~/.pam_environment ファイルを以下のように作成してください:\n\n```\n~/.pam_environment\n```\n\n```\nXDG_CONFIG_HOME DEFAULT=@{HOME}/.local/config\nXDG_DATA_HOME   DEFAULT=@{HOME}/.local/data\n```\n\n.pam_environment ファイルの構文に関する詳細は環境変数#pam_env を使うを見てください。systemctl --user show-environment コマンドを実行することで設定が上手くいっているか確認できます:\n\n```\n$ systemctl --user show-environment\n```\n\n```\n...\nXDG_CONFIG_HOME=/home/user/.local/config\nXDG_DATA_HOME=/home/user/.local/data\n...\n```\n\n"
    },
    {
      "title": "systemd のユーザーインスタンスを自動起動",
      "level": 3,
      "content": "systemd のユーザーインスタンスはデフォルトでユーザーの最初のログイン時に実行され、ユーザーのセッションが閉じられた時に終了します。しかしながら、ブートした直後にインスタンスを起動して、セッションが閉じられてもユーザーインスタンスを実行し続ける方が、例えばセッションが開いてない時もユーザープロセスを実行したいときなどには便利です。linger を利用してこれを行います。特定のユーザーで linger を有効にするには以下のコマンドを使用:\n\n```\n# loginctl enable-linger username\n```\n\n"
    },
    {
      "title": "ユーザーユニットを書く",
      "level": 2,
      "content": "普通の systemd ユニットファイルの書き方は systemd#ユニットファイルを見てください。\n\n"
    },
    {
      "title": "サンプル",
      "level": 3,
      "content": "以下は mpd サービスのユーザーバージョンの例です。\n\n```\n~/.config/systemd/user/mpd.service\n```\n\n```\n[Unit]\nDescription=Music Player Daemon\n\n[Service]\nExecStart=/usr/bin/mpd --no-daemon\n\n[Install]\nWantedBy=default.target\n```\n\n"
    },
    {
      "title": "変数を使用したサンプル",
      "level": 3,
      "content": "以下は sickbeard.service のユーザーバージョンの例で、SickBeard が特定のファイルを見つけられるようホームディレクトリの変数を使っています:\n\n```\n~/.config/systemd/user/sickbeard.service\n```\n\n```\n[Unit]\nDescription=SickBeard Daemon\n\n[Service]\nExecStart=/usr/bin/env python2 /opt/sickbeard/SickBeard.py --config %h/.sickbeard/config.ini --datadir %h/.sickbeard\n\n[Install]\nWantedBy=default.target\n```\n\nman systemd.unit に書かれているように、%h 変数はサービスを実行しているユーザーのホームディレクトリに置き換えられます。他にも systemd のマニュアルページで示されている変数が存在します。\n\n"
    },
    {
      "title": "ジャーナルを読み込む",
      "level": 3,
      "content": "ユーザーのジャーナルも同じようなコマンドで読みことができます:\n\n```\n$ journalctl --user\n```\n\nユニットを指定する場合:\n\n```\n$ journalctl --user -u myunit.service\n```\n\nユーザーユニットを指定する場合:\n\n```\n$ journalctl --user --user-unit myunit.service\n```\n\nときどきユーザーサービスからの出力がサービスユニットに割り当てられないというバグが存在します。-u を使って出力をフィルタリングするとサービスユニットからの出力が見れなくなる可能性があります。\n\n"
    },
    {
      "title": "一時ファイル",
      "level": 2,
      "content": "systemd-tmpfiles を使うことでシステム全体と同じように一時ファイル・ディレクトリを管理することができます (systemd#一時ファイルを参照)。ユーザー個別の設定ファイルは ~/.config/user-tmpfiles.d/ と ~/.local/share/user-tmpfiles.d/ からこの順番で読み込まれます。設定ファイルを使うには、必要な systemd ユーザーユニットを使用しているユーザーで有効にする必要があります:\n\n```\n$ systemctl --user enable systemd-tmpfiles-setup.service systemd-tmpfiles-clean.timer\n```\n\n設定ファイルの構文はシステムユニットと同じです。詳しくは man ページの systemd-tmpfiles(8) や tmpfiles.d(5) を見てください。\n\n"
    },
    {
      "title": "Xorg と systemd",
      "level": 2,
      "content": "systemd ユニットの中で Xorg を実行する方法は複数存在します。以下の2つは、xorg プロセスで新しいユーザーセッションを起動するというのと、systemd のユーザーサービスから xorg を起動するという方法です。\n\n"
    },
    {
      "title": "ディスプレイマネージャを使わずに Xorg に自動ログイン",
      "level": 3,
      "content": "こちらを選択した場合、xorg サーバーでユーザーセッションを起動してその後ウィンドウマネージャなどを起動するために通常の ~/.xinitrc を実行するシステムユニットを起動します。\n\nD-Bus を適切に設定して xlogin-gitAUR をインストールする必要があります。\n\n雛形のファイルから xinitrc を設定して、/etc/X11/xinit/xinitrc.d/ のファイルが読み込まれるようにしてください。~/.xinitrc は実行したときに戻ってこないようにする必要があるため、最後のコマンドとして wait を記述するか、(ウィンドウマネージャなど) exec を追加して戻ってこないようにしてください。\n\nセッションは自らの dbus デーモンを使用しますが、systemd ユーティリティは dbus.service インスタンスに自動的に接続します。\n\n最後に、(root で) xlogin を有効にして起動時に自動ログインするようにしてください:\n\n```\n# systemctl enable xlogin@username\n```\n\nユーザーセッションが systemd の範囲の中に収まるようになってユーザーセッションの全てが問題なく動作するはずです。\n\n"
    },
    {
      "title": "systemd のユーザーサービスとしての Xorg",
      "level": 3,
      "content": "また、systemd のユーザーサービスの中から Xorg を実行することもできます。他の X 関連のユニットを Xorg などに依存させることができるという点では有利な一方、以下で説明するようにいくつか欠点が存在します。\n\nバージョン 1.16 から xorg-server は systemd とのより良い統合を2つの手段で提供しています:\n\n- デバイス管理を logind に委託することで、非特権でも実行することが可能に (このコミット など Hans de Goede のコミットを参照)。\n- ソケットによってサービスを有効化することが可能に (このコミット を参照)。これによって systemd-xorg-launch-helper-gitAUR が不要に。\n\n残念ながら、非特権モードで xorg を実行できるようにするには、セッションの中で xorg を実行する必要があります。そのため、今のところユーザーサービスとして xorg を実行するのには (1.16 以前と同じように) root 権限で実行する必要があるというハンディキャップがあり、1.16 で導入された非特権モードを活用することはできません。\n\n以下がユーザーサービスから xorg を起動する方法です:\n\n1. /etc/X11/Xwrapper.config を編集して、xorg が root 権限を使ってどのユーザーでも動作するようにします:\n\n```\n/etc/X11/Xwrapper.config\n```\n\n```\nallowed_users=anybody\nneeds_root_rights=yes\n```\n\n2. 以下のユニットを ~/.config/systemd/user に追加:\n\n```\n~/.config/systemd/user/xorg@.socket\n```\n\n```\n[Unit]\nDescription=Socket for xorg at display %i\n\n[Socket]\nListenStream=/tmp/.X11-unix/X%i\n```\n\n```\n~/.config/systemd/user/xorg@.service\n```\n\n```\n[Unit]\nDescription=Xorg server at display %i\n\nRequires=xorg@%i.socket\nAfter=xorg@%i.socket\n\n[Service]\nType=simple\nSuccessExitStatus=0 1\n\nExecStart=/usr/bin/Xorg :%i -nolisten tcp -noreset -verbose 2 \"vt${XDG_VTNR}\"\n```\n\n${XDG_VTNR} は xorg が起動する仮想コンソールで、サービスユニットでハードコードするか、以下のコマンドを使って systemd 環境で設定します:\n\n```\n$ systemctl --user set-environment XDG_VTNR=1\n```\n\n3. 上で説明されているように DISPLAY 環境変数を設定します。\n\n4. 次に、display 0 と tty 2 で xorg のソケットアクティベーションを有効化します:\n\n```\n$ systemctl --user set-environment XDG_VTNR=2     # So that xorg@.service knows which vt use\n$ systemctl --user start xorg@0.socket            # Start listening on the socket for display 0\n```\n\nこれで X アプリケーションを実行すると仮想コンソール 2 で自動的に xorg が起動します。\n\nXDG_VTNR 環境変数は .bash_profile から systemd 環境に設定することができ、ウィンドウマネージャなど、あらゆる X アプリケーションを xorg@0.socket に依存する systemd ユニットとして起動することが可能です。\n\n"
    },
    {
      "title": "永続的なターミナルマルチプレクサ",
      "level": 3,
      "content": "ウィンドウマネージャのセッションにログインする代わりに、ユーザーセッションでデフォルトで GNU Screen や Tmux などのターミナルマルチプレクサをバックグラウンドで実行したいということもあるでしょう。X ログインとログインを分割するのはディスプレイマネージャの代わりに TTY で起動したい場合にのみ有用です (その場合すべてを myStuff.target で起動するように記述できます)。\n\n上述のようなタイプのユーザーセッションを作成するには、wm.target を作成する代わりに、multiplexer.target を作成します:\n\n```\n[Unit]\nDescription=Terminal multiplexer\nDocumentation=info:screen man:screen(1) man:tmux(1)\nAfter=cruft.target\nWants=cruft.target\n\n[Install]\nAlias=default.target\n```\n\n上記の mystuff.target と同じように、cruft.target は tmux や screen が起動する前に実行する必要があるサービス (もしくは起動時に即座に起動させたいサービス)、例えば GnuPG デーモンのセッションなどを起動します。\n\n次にマルチプレクサセッションのサービスを作成してください。以下は tmux を使用して /tmp/gpg-agent-info に情報を書き込む gpg-agent セッションを読み込むサービスの例です。また、DISPLAY を設定することで X を起動したときに X プログラムが実行できるようにしています。\n\n```\n[Unit]\nDescription=tmux: A terminal multiplixer\nDocumentation=man:tmux(1)\nAfter=gpg-agent.service\nWants=gpg-agent.service\n\n[Service]\nType=forking\nExecStart=/usr/bin/tmux start\nExecStop=/usr/bin/tmux kill-server\nEnvironment=DISPLAY=:0\nEnvironmentFile=/tmp/gpg-agent-info\n\n[Install]\nWantedBy=multiplexer.target\n```\n\n上記の設定が完了したら、systemctl --user enable で tmux.service, multiplexer.target と cruft.target で実行させるサービスを有効化してください。後は同じように user-session@.service を有効化しますが、ユーザーセッションは TTY を引き継がないので user-session@.service から Conflicts=getty@tty1.service は削除してください。これで、起動時にターミナルマルチプレクサなどのプログラムを実行できるようになります。\n\n"
    },
    {
      "title": "ウィンドウマネージャ",
      "level": 3,
      "content": "systemd のサービスとしてウィンドウマネージャを実行するには、まず Xorg を systemd のユーザーサービスとして実行する必要があります。以下では awesome を例として使います:\n\n```\n~/.config/systemd/user/awesome.service\n```\n\n```\n[Unit]\nDescription=Awesome window manager\nAfter=xorg.target\nRequires=xorg.target\n\n[Service]\nExecStart=/usr/bin/awesome\nRestart=always\nRestartSec=10\n \n[Install]\nWantedBy=wm.target\n```\n\n"
    },
    {
      "title": "ログアウト時にユーザープロセスを終了",
      "level": 2,
      "content": "systemd パッケージのデフォルトは KillUserProcesses=no となっており、ユーザーが完全にログアウトしたときでもユーザープロセスは終了しません。ユーザーがログアウトしたときに全てのユーザープロセスが終了するようにしたい場合、/etc/systemd/logind.conf に KillUserProcesses=yes と設定してください。\n\nただし、この設定を変更すると tmux や screen などのターミナルマルチプレクサが動作しなくなります。以下のように systemd-run を使ってターミナルマルチプレクサを利用してください:\n\n```\n$ systemd-run --scope --user command args\n```\n\n例えば、screen を実行する場合:\n\n```\n$ systemd-run --scope --user screen -S foo\n```\n\nsystemd-run を使うと、ログアウト後も、ユーザがシステム内のどこかで少なくとも 1 回はログインしていて、user@.service がまだ実行されている間だけ、プロセスが実行され続けます。\n\nユーザがすべてのセッションからログアウトした後、user@.service は、そのユーザが「lingering」を有効にしていない限り、デフォルトで終了します [6]。ユーザーが完全にログアウトしていても、長時間のタスクを効果的に実行できるようにするには、そのユーザーに対してリンガリングを有効にする必要があります。詳しくは #Automatic start-up of systemd user instances と loginctl(1) を参照してください。\n\n"
    },
    {
      "title": "ランタイムディレクトリ '/run/user/1000' は、UID1000 によって所有されていません",
      "level": 3,
      "content": "```\nsystemd[1867]: pam_systemd(systemd-user:session): Runtime directory '/run/user/1000' is not owned by UID 1000, as it should.\nsystemd[1867]: Trying to run as user instance, but $XDG_RUNTIME_DIR is not set\n```\n\nこのようなエラーが表示され、ログインセッションが壊れている場合、システム上の別のシステム(ユーザーではない)サービスがこのフォルダを作成している可能性があります。例えば、/run/user/1000 にバインドマウントしている docker コンテナを使用している場合、このようなことが起こる可能性があります。これを解決するには、マウントを削除することでコンテナを修正するか、ドッカーサービスを無効化/遅延させるかのいずれかです。\n\n"
    },
    {
      "title": "\"A stop job is running for User Manager for UID 1000\"",
      "level": 3,
      "content": "シャットダウン中にこのメッセージが表示される場合、通常は2分のタイムアウトが設定されていることが多いですが、これはユーザーサービスの1つがタイムリーに停止しなかったことを意味します。これには、以前に一時的なサービスを生成した問題のあるアプリケーションが原因である可能性があります。タイムアウトが切れるのを待つこともできますが、これが気になる場合は、問題のあるサービスにオーバーライドを作成するか、すべてのユーザーサービスに対してグローバルタイムアウトを短縮することができます。\n\n"
    },
    {
      "title": "問題のあるサービスを特定してオーバーライドする",
      "level": 4,
      "content": "この問題をトラブルシューティングするために、systemd デバッグシェル を起動します:\n\n```\nsystemctl start debug-shell\n```\n\nその後、システムを再起動するかシャットダウンします。問題が発生したときに、Ctrl+Alt+F9 を使用してデバッグシェルに切り替えます。シャットダウンを妨げているサービスを特定するには、次のコマンドを実行します:\n\n```\nsystemctl --user list-jobs\n```\n\nほとんどのオープンソースアプリケーションでは、この問題は該当するメンテナに報告されるべきであり、オーバーライドは必要ありません。しかし、クローズドソースアプリケーションの場合は、次のようにオーバーライドを作成できます:\n\n```\n$ systemctl --user edit --force name@.service\n```\n\n```\n[Service]\nTimeoutStopSec=1s\n```\n\nこれにより、その特定のサービスのタイムアウトが1秒に短縮されます。--force パラメータは、一時的なサービスでディスク上に .service ファイルを作成しない場合にのみ必要です。オーバーライドはそれに関係なく機能します。タイムアウトの代わりに KillSignal=SIGKILL を使用することもできます。これにより、ユーザーマネージャが停止したときにサービスが即座に強制終了されます。この方法は、そのサービスがそれを処理できると確信している場合にのみ使用してください。\n\n"
    },
    {
      "title": "タイムアウト値の変更",
      "level": 4,
      "content": "どのサービスがシャットダウンを妨げているか気にしない場合は、次のようにしてすべてのユーザーサービスのグローバルタイムアウトを変更できます:\n\n```\n# systemctl edit user@.service\n```\n\n```\n[Service]\nTimeoutStopSec=10s\n```\n\nこのタイムアウト後、優雅に停止していないすべてのユーザーサービスは強制終了されます。これは突然の電源断と同じです。この値は特定の使用ケースに合わせて調整してください。タイムアウトを低すぎる値に設定すると、アプリケーションによってはデータ損失が発生する可能性があります。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- KaiSforza's bitbucket wiki\n- Zoqaeski's units on Github\n- Forum thread about changes in systemd 206 user instances\n\n"
    }
  ]
}