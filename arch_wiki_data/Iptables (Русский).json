{
  "title": "Iptables (Русский)",
  "url": "https://wiki.archlinux.org/title/Iptables_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- nftables (Русский)\n- Fail2ban (Русский)\n- sshguard\n- Simple stateful firewall (Русский)\n- Sysctl#TCP/IP stack hardening\n- Uncomplicated Firewall\n\niptables — утилита командной строки для настройки встроенного в ядро Linux межсетевого экрана, разработанного в рамках проекта Netfilter. Термином iptables также часто называют сам межсетевой экран в ядре. Настройка экрана выполняется либо напрямую с помощью iptables, либо через один из фронтендов, консольных или графических. iptables работает с протоколом IPv4, для IPv6 разработана утилита ip6tables. В основном их синтаксис совпадает, но некоторые специфичные для протоколов опции различаются.\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Стандартное ядро Arch Linux скомпилировано с поддержкой iptables. Необходимо лишь установить набор пользовательских утилит, которые собраны в пакет iptables. Поскольку данный пакет является косвенной зависимостью мета-пакета base, то он по умолчанию должен быть установлен в системе.\n\n"
    },
    {
      "title": "Консольные",
      "level": 4,
      "content": "- Arno's firewall — безопасный межсетевой экран как для одиночной машины, так и для разрозненной сети. Лёгок в настройке, удобен в использовании, хорошо кастомизируется. Поддерживает: NAT и SNAT, проброс портов, ADSL ethernet-модемы со статическими и динамическими IP-адресами, фильтрацию MAC-адресов, обнаружение скрытого сканирования портов, DMZ и DMZ-2-LAN пересылку, защиту от SYN/ICMP флуда, обширное логирование с временными ограничениями для предотвращения засорения логов, все IP-протоколы и технологии VPN вроде IPsec, плагины для расширения функциональности.\n\n- ferm — инструмент для обслуживания комплексных межсетевых экранов, помогающий избежать необходимости переписывать сложные правила снова и снова. Позволяет сохранить целый набор правил в одном файле и загрузить его всего одной командой. Настройка экрана производится посредством специального языка, наподобие языка программирования, с помощью уровней и списков.\n\n- FireHOL — не только программа для создания межсетевого экрана, но и специальный язык для задания его настроек. Делает даже тонкую настройку экрана лёгкой — как вам бы и хотелось.\n\n- Firetable — инструмент для межсетевого экрана iptables. Каждый сетевой интерфейс настраивается отдельно в соответствии с собственным файлом настроек, синтаксис которого понятен и удобен.\n\n- firewalld (firewall-cmd) — демон и консольный интерфейс для настройки сети, зональной политики и правил межсетевого экрана.\n\n- Shorewall — высокоуровневый инструмент для настройки Netfilter. Требования к экрану/шлюзу описываются посредством записей в наборе файлов настроек.\n\n- Uncomplicated Firewall — простой интерфейс для iptables.\n\n- PeerGuardian (pglcmd) — ориентированное на приватность firewall-приложение. Занимается блокировкой входящих и исходящих подключений на основе огромного чёрного списка (тысячи или даже миллионы IP-диапазонов).\n\n- Vuurmuur — мощный менеджер сетевого экрана. Лёгкая в освоении настройка, которая позволяет создавать как простые, так и сложные конфигурации межсетевого экрана. Для настройки есть графический интерфейс на основе ncurses, который позволяет осуществлять безопасное удалённое администрирование через SSH или консоль. Vuurmuur поддерживает ограничение трафика, имеет мощную систему мониторинга, которая позволяет администратору следить за логами, подключениями и использованием пропускной способности в режиме реального времени.\n\n"
    },
    {
      "title": "Графические",
      "level": 4,
      "content": "- Firewall Builder — графический интерфейс для настройки и управления межсетевыми экранами, работает с iptables (netfilter), ipfilter, pf, ipfw, Cisco PIX (FWSM, ASA), а также с маршрутизаторами Cisco с поддержкой Extended ACL. Запускается на Linux, FreeBSD, OpenBSD, Windows и macOS, может управлять как локальными, так и удалёнными межсетевыми экранами.\n\n- firewalld (firewall-config) — демон и графический интерфейс для настройки сети, зональной политики и правил межсетевого экрана.\n\n- Gufw — графический GTK-интерфейс для ufw, который, в свою очередь, является интерфейсом командной строки для iptables (gufw–>ufw–>iptables), лёгкий и простой в использовании.\n\n- PeerGuardian GUI (pglgui) — ориентированное на приватность firewall-приложение. Занимается блокировкой входящих и исходящих подключений на основе огромного чёрного списка (тысячи или даже миллионы IP-диапазонов).\n\n"
    },
    {
      "title": "Основные понятия",
      "level": 2,
      "content": "iptables используется для проверки, модификации, перенаправления и отбрасывания пакетов. Код для фильтрации пакетов IPv4 уже встроен в ядро и организован в виде набора таблиц, каждая из которых предназначена для конкретной цели. Таблица состоит из группы предопределённых цепочек, а те, в свою очередь, содержат правила, которые проверяются по очереди. Каждое правило состоит из критерия (набора условий) и действия (т.н. цели); действие применяется к пакету, подпадающему под критерий (т. е. если все условия выполнены). Если пакет достигает конца встроенной цепочки, в том числе пустой, то он отправляется дальше в соответствии с политикой цепочки. iptables — пользовательская утилита для работы с цепочками и правилами. Большинство пользователей находят IP-маршрутизацию Linux сложной и запутанной, однако на практике наиболее распространенные варианты использования (NAT и/или базовый межсетевой экран для интернета) являются значительно менее сложными.\n\nКлюч к пониманию принципа работы iptables находится в этой блок-схеме. Слова в нижнем регистре в верхней части каждого блока являются именами таблиц, а слова в верхнем регистре – цепочками. Каждый IP-пакет, принятый на любом сетевом интерфейсе, проходит через эту блок-схему сверху вниз. Существует заблуждение, что пакеты, приходящие на внутренний интерфейс, обрабатываются как-то иначе нежели те, что приходят на интерфейс, подключённый к интернету. Пакеты на всех интерфейсах обрабатываются одинаково; это ваша задача написать правила, которые будут обрабатывать их по-разному. Некоторые пакеты предназначены для локальных процессов; они проходят по схеме от верхнего блока до блока <Local Process> (локальный процесс). В то же время локальный процесс сам может генерировать пакеты, и они начинают путешествие по схеме с блока <Local Process> и далее вниз. Подробное описание работы этой блок-схемы можно найти здесь.\n\nВ подавляющем большинстве случаев таблицы raw, mangle и security вам не понадобятся. На схеме ниже приведён упрощённый вариант прохождения пакета через iptables:\n\n```\nXXXXXXXXXXXXXXXXXX\n                             XXX      Сеть      XXX\n                               XXXXXXXXXXXXXXXXXX\n                                       +\n                                       |\n                                       v\n+---------------+             +-------------------+\n|таблица: filter| <---+       |таблица: nat       |\n|цепочка: INPUT |     |       |цепочка: PREROUTING|\n+-------+-------+     |       +--------+----------+\n        |             |                |\n        v             |                v\n[локальный процесс]   |         ***************          +----------------+\n        |             +-------+  Маршрутизация  +------> |таблица: filter |\n        v                       ***************          |цепочка: FORWARD|\n ***************                                         +-------+--------+\n  Маршрутизация                                                  |\n ***************                                                 |\n        |                                                        |\n        v                       ***************                  |\n+---------------+     +------>   Маршрутизация   <---------------+\n|таблица: nat   |     |         ***************\n|цепочка: OUTPUT|     |                +\n+------+--------+     |                |\n        |             |                v\n        v             |      +---------------------+\n+---------------+     |      | таблица: nat        |\n|таблица: filter| +---+      | цепочка: POSTROUTING|\n|цепочка: OUTPUT|            +---------+-----------+\n+---------------+                      |\n                                       v\n                               XXXXXXXXXXXXXXXXXX\n                             XXX      Сеть      XXX\n                               XXXXXXXXXXXXXXXXXX\n```\n\n"
    },
    {
      "title": "Таблицы",
      "level": 3,
      "content": "iptables содержит пять таблиц:\n\n1. raw — используется только для настройки пакетов, поэтому они освобождаются от отслеживания.\n1. filter — таблица по умолчанию; в ней сосредоточены все действия, типичные для межсетевых экранов.\n1. nat — используется для преобразования сетевых адресов (например, проброс портов).\n1. mangle — используется для специальных преобразований пакетов.\n1. security — используется в сетевых правилах для Мандатного управления доступом (например, в SELinux – подробнее см. эту статью).\n\nСкорее всего, вам потребуются только две из них: filter и nat. Остальные таблицы используются в сложных конфигурациях с несколькими маршрутизаторами и выходят за рамки данной статьи.\n\n"
    },
    {
      "title": "Цепочки",
      "level": 3,
      "content": "Таблицы состоят из цепочек, которые представляют собой набор правил, следующих друг за другом в определённом порядке. Таблица по умолчанию, filter, содержит три встроенные цепочки: INPUT, OUTPUT и FORWARD, которые, как видно из диаграммы[устаревшая ссылка 2025-01-19 ⓘ], активируются в определённые моменты процесса фильтрации пакетов. Таблица nat включает стандартные цепочки PREROUTING, POSTROUTING и OUTPUT.\n\nОписание стандартных цепочек других таблиц можно найти в руководстве iptables(8).\n\nПо умолчанию все цепочки пусты и не содержат каких-либо правил. Вы должны добавить правила в те цепочки, которые собираетесь использовать. У цепочек также задана политика по умолчанию — обычно ACCEPT, но её можно изменить на DROP, если вы хотите убедиться, что ни один пакет не проскочит мимо вашего набора правил. Тем не менее, политика по умолчанию применяется к пакету только после того, как он пройдёт через все существующие правила.\n\nВы можете добавить собственные цепочки для большей эффективности или удобства. Пример создания таких цепочек можно найти в статье Настройка межсетевого экрана.\n\n"
    },
    {
      "title": "Правила",
      "level": 3,
      "content": "Фильтрация пакетов основана на правилах. Каждое правило состоит из нескольких условий и действия-цели. Если пакет соответствует всем условиям, то к нему применяется указанное действие. Распространённые условия для проверки — на какой интерфейс пришёл пакет (например, eth0 или eth1), какого он типа (ICMP, TCP или UDP) или на какой порт направляется.\n\nЦели указываются опцией -j/--jump. Цель может быть встроеной (built-in), целью-расширением (extension) или переходом на пользовательскую цепочку. Встроенные цели — ACCEPT, DROP, QUEUE и RETURN; цели-расширения, к примеру — REJECT и LOG. Если применяется встроенная цель, то участь пакета решается незамедлительно и обработка пакета в таблице прекращается. Если в качестве цели выбран переход на пользовательскую цепочку, то пакет проходит через неё, возвращается в исходную цепочку и продолжает со следующего после перехода правила. Цели-расширения могут быть завершающими (как встроенные) или незавершающими (как пользовательские цепочки). Подробнее см. iptables-extensions(8).\n\n"
    },
    {
      "title": "Прохождение по цепочке",
      "level": 3,
      "content": "Принятый на сетевом интерфейсе пакет проходит по цепочкам таблиц в порядке, изображённом на диаграмме[устаревшая ссылка 2025-01-19 ⓘ]. В первой точке маршрутизации (routing decision) принимается решение, направляется ли пакет на локальную машину (в таком случае пакет проходит через цепочку INPUT) или куда-то в другое место (в этом случае пакет проходит через цепочку FORWARD). Последующие точки маршрутизации определяют, на какой сетевой интерфейс направить исходящий пакет. В каждой цепочке по пути следования пакета последовательно проверяются все правила, и если пакет удовлетворяет условиям правила, то выполняется соответствующее действие-цель. Три наиболее частых цели – ACCEPT, DROP и переход на пользовательскую цепочку. В противоположность встроенным цепочкам, которые имеют цели по умолчанию, цепочки пользователя такой цели не имеют. Если не удовлетворены условия ни одного из правил пользовательской цепочки, пакет возвращается обратно в вызвавшую её цепочку, как показано здесь. Если в какое-то момент выполнились все условия цепочки с действием DROP, пакет немедленно отбрасывается и над ним более не производится никаких действий. Обратите, однако, внимание, что если пакет принят действием ACCEPT, он принимается только в текущей цепочке и в вышележащих цепочках в текущем стеке вызовов. Он не обрабатывается более той стандартной цепочкой, которая инициировала последовательность переходов, но продолжает проходить по цепочкам в других таблицах обычным образом.\n\n"
    },
    {
      "title": "Модули",
      "level": 3,
      "content": "Существует ряд модулей для расширения возможностей iptables, среди которых connlimit, conntrack, limit и recent. Эти модули добавляют новую функциональность в iptables, что позволяет создавать более сложные правила фильтрации.\n\n"
    },
    {
      "title": "Настройка и использование",
      "level": 2,
      "content": "iptables — служба systemd и запускается соответственно. Пакет iptables при установке добавляет пустой комплект правил /etc/iptables/iptables.rules, который будет загружен при первом запуске службы iptables.service. Как и прочие службы, службу iptables для добавления в автозапуск необходимо включить.\n\nПравила iptables для IPv6 по умолчанию хранятся в файле /etc/iptables/ip6tables.rules, который используется службой ip6tables.service. Эту службу можно запустить так же, как и iptables.service.\n\nПосле добавления правил посредством командной строки файл настроек не изменится автоматически — изменения необходимо сохранять командой:\n\n```\n# iptables-save -f /etc/iptables/iptables.rules\n```\n\nЕсли вы изменяли файл настроек вручную, то либо перезагрузите службу iptables, либо загрузите настройки вручную командой:\n\n```\n# iptables-restore /etc/iptables/iptables.rules\n```\n\n"
    },
    {
      "title": "Вывод текущих правил",
      "level": 4,
      "content": "Основная команда для вывода текущих правил — --list-rules/-S; её вывод похож на вывод утилиты iptables-save. Разница между ними в том, что по умолчанию последняя выводит правила из всех таблиц, в то время как iptables — только из таблицы filter.\n\nКоманда --list/-L принимает больше модификаторов и выводит более подробную информацию. Например, следующая команда позволяет проверить текущий набор правил и количество срабатываний каждого из них:\n\n```\n# iptables -nvL\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain FORWARD (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\n pkts bytes target     prot opt in     out     source               destination\n```\n\nПредставленный выше вывод свидетельствует о том, что в таблице по умолчанию (filter) никакие правила не заданы и все пакеты пропускаются. Выбрать другую таблицу можно опцией -t.\n\nЧтобы вывести номера строк при просмотре правил, запустите команду с опцией --line-numbers. Это бывает удобно для последующего редактирования правил в командной строке.\n\n"
    },
    {
      "title": "Сброс правил",
      "level": 4,
      "content": "Сбросить правила iptables можно следующими командами:\n\n```\n# iptables -F\n# iptables -X\n# iptables -t nat -F\n# iptables -t nat -X\n# iptables -t mangle -F\n# iptables -t mangle -X\n# iptables -t raw -F\n# iptables -t raw -X\n# iptables -t security -F\n# iptables -t security -X\n# iptables -P INPUT ACCEPT\n# iptables -P FORWARD ACCEPT\n# iptables -P OUTPUT ACCEPT\n```\n\nКоманда -F без аргументов просто очищает все цепочки в текущей таблице. Аналогично, команда -X удаляет все пустые пользовательские цепочки в таблице.\n\nОтдельные цепочки могут быть очищены от правил или удалены указанием имени цепочки после команд -F и -X соответственно.\n\n"
    },
    {
      "title": "Редактирование правил",
      "level": 4,
      "content": "Редактирование правил подразумевает одно из следующих действий: добавление правила в конец цепочки (-A), вставка правила в конкретную позицию в цепочке (-I), замена (-R) и удаление (-D) существующего правила.\n\nПримеры ниже приведены исходя из соображения, что компьютер не является маршрутизатором. Поэтому первым делом меняем политику цепочки FORWARD с ACCEPT на DROP:\n\n```\n# iptables -P FORWARD DROP\n```\n\nСинхронизация по локальной сети в Dropbox производится с помощью отправки широковещательных пакетов каждые 30 секунд всем доступным компьютерам сети. Если вы находитесь в локальной сети с клиентами Dropbox и не желаете использовать эту возможность, то следует отклонять такие пакеты:\n\n```\n# iptables -A INPUT -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable\n```\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nТеперь предположим, что вы поменяли своё мнение касательно Dropbox и решили установить его на компьютере. Также вы режили использовать синхронизацию, но с одним конкретным IP-адресом (например, 10.0.0.85). Команда -R позволяет заменить существующее правило:\n\n```\n# iptables -R INPUT 1 -p tcp --dport 17500 ! -s 10.0.0.85 -j REJECT --reject-with icmp-port-unreachable\n```\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 REJECT     tcp  --  *      *      !10.0.0.85            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nНовое правило позволяет хосту 10.0.0.85 отправить данные на порт 17500 вашего компьютера. Но вдруг вы понимаете, что этот подход не масштабируется. Если дружественный пользователь Dropbox пытается получить доступ к порту 17500, то мы хотим предоставлять ему доступ немедленно, не проверяя его последующими правилами!\n\nПоэтому мы пишем новое правило для предоставления доверенному пользователю немедленного доступа и добавляем его командой -I, чтобы вставить его перед предыдущим:\n\n```\n# iptables -I INPUT -p tcp --dport 17500 -s 10.0.0.85 -j ACCEPT -m comment --comment \"Friendly Dropbox\"\n```\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 ACCEPT     tcp  --  *      *       10.0.0.85            0.0.0.0/0            tcp dpt:17500 /* Friendly Dropbox */\n2        0     0 REJECT     tcp  --  *      *      !10.0.0.85            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\nВторое правило теперь можно переписать так, чтобы оно отбрасывало все пакеты на порт 17500 с других хостов:\n\n```\n# iptables -R INPUT 2 -p tcp --dport 17500 -j REJECT --reject-with icmp-port-unreachable\n```\n\nИтоговый список правил теперь выглядит следующим образом:\n\n```\n# iptables -nvL --line-numbers\n```\n\n```\nChain INPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n1        0     0 ACCEPT     tcp  --  *      *       10.0.0.85            0.0.0.0/0            tcp dpt:17500 /* Friendly Dropbox */\n2        0     0 REJECT     tcp  --  *      *       0.0.0.0/0            0.0.0.0/0            tcp dpt:17500 reject-with icmp-port-unreachable\n\nChain FORWARD (policy DROP 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n\nChain OUTPUT (policy ACCEPT 0 packets, 0 bytes)\nnum   pkts bytes target     prot opt in     out     source               destination\n```\n\n"
    },
    {
      "title": "Руководства",
      "level": 3,
      "content": "- Настройка межсетевого экрана\n- Router\n\n"
    },
    {
      "title": "Журналирование",
      "level": 2,
      "content": "Цель LOG позволяет при срабатывании правила добавлять информацию о пакете в журнал. В отличие от прочих целей, вроде ACCEPT или DROP, при срабатывании цели LOG пакет продолжает продвижение по цепочке. Поэтому, например, чтобы включить журналирование всех отброшенных пакетов, необходимо перед каждым DROP-правилом добавить аналогичное LOG-правило. Правда, это не очень выгодно с точки зрения эффективности и удобства, и вместо этого лучше создать отдельную цепочку logdrop:\n\n```\n# iptables -N logdrop\n```\n\nДобавьте в неё следующие правила:\n\n```\n# iptables -A logdrop -m limit --limit 5/m --limit-burst 10 -j LOG\n# iptables -A logdrop -j DROP\n```\n\nОпции limit и limit-burst объяснены следующем разделе.\n\nТеперь для отбрасывания пакета с добавлением соответствующей записи в журнал необходимо просто выполнить переход на цепочку logdrop:\n\n```\n# iptables -A INPUT -m conntrack --ctstate INVALID -j logdrop\n```\n\n"
    },
    {
      "title": "Ограничение скорости логирования",
      "level": 3,
      "content": "Цепочка logdrop из предыдущего раздела использует модуль limit, который помогает предотвратить разрастание журнала и избежать ненужных операций записи на диск. Если этого не сделать, то неправильно настроенная служба, которая пытается установить соединение, или просто злоумышленник, могут привести к исчерпанию свободного места на диске (как минимум в разделе /var) из-за добавления чрезмерного количества записей в журнал.\n\nМодуль limit подключается опцией -m limit. Опцией --limit задаётся средняя скорость журналирования, а опцией --limit-burst — начальная. В примере цепочки logdrop выше команда\n\n```\n# iptables -A logdrop -m limit --limit 5/m --limit-burst 10 -j LOG\n```\n\nдобавляет правило, которое логирует все проходящие через него пакеты. Первые 10 пакетов будут добавлены в журнал, но затем скорость логирования не будет превышать 5 пакетов в минуту. Если значение limit какое-то время не нарушается, то limit-burst снова \"разблокируется\", т.е. журналирование автоматически вернётся к нормальному режиму.\n\n"
    },
    {
      "title": "Просмотр логированных пакетов",
      "level": 3,
      "content": "В журнале systemd логированные пакеты отображаются как сообщения ядра.\n\nСледующая команда выведет список пакетов, добавленных журнал с момента последней загрузки системы:\n\n```\n# journalctl -k --grep=\"IN=.*OUT=.*\"\n```\n\n"
    },
    {
      "title": "syslog-ng",
      "level": 3,
      "content": "Если вы используете syslog-ng, то в файле syslog-ng.conf можно настроить место хранения логов iptables. Замените:\n\n```\nfilter f_everything { level(debug..emerg) and not facility(auth, authpriv); };\n```\n\nна\n\n```\nfilter f_everything { level(debug..emerg) and not facility(auth, authpriv) and not filter(f_iptables); };\n```\n\nПосле этого вывод iptables больше не будет отправляться в /var/log/everything.log.\n\nЕсли необходимо задать произвольный файл для хранения журнала iptables (вместо /var/log/iptables.log), то измените значение пути в параметре d_iptables (в том же файле (syslog-ng.conf):\n\n```\ndestination d_iptables { file(\"/var/log/iptables.log\"); };\n```\n\n"
    },
    {
      "title": "ulogd",
      "level": 3,
      "content": "ulogd — работающий в пространстве пользователя специализированный демон журналирования пакетов для netfilter, который может заменить стандартную цель LOG.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Iptables в Википедии\n- Port knocking\n- Официальный сайт iptables\n- Руководство по iptables версии 1.2.2 от Oskar Andreasson\n- Debian Wiki — iptables\n- Безопасное использование Connection Tracking helpers\n\n"
    }
  ]
}