{
  "title": "Sysctl (日本語)",
  "url": "https://wiki.archlinux.org/title/Sysctl_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "sysctl は稼働中のカーネルパラメータを確認・変更するためのツールです (公式リポジトリの procps-ng パッケージ)。sysctl は procfs (/proc/ の仮想プロセスファイルシステム) で実装されています。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 設定\n- 3 セキュリティ\n- 4 ネットワーク 4.1 パフォーマンスを向上させる 4.1.1 受信キューのサイズを増やす 4.1.2 最大接続数を増やす 4.1.3 ネットワークインターフェイス専用のメモリを増やす 4.1.4 TCP Fast Open を有効にする 4.1.5 保留中の接続処理を微調整する 4.1.6 TCP キープアライブパラメータを変更する 4.1.7 MTU プローブを有効にする 4.1.8 TCP タイムスタンプ 4.1.9 TCP Selective Acknowledgement 4.1.10 BBR を有効にする 4.1.11 エフェメラルポートの範囲を拡大 4.2 TCP/IP スタックの強化 4.2.1 TCP SYN cookie 保護 4.2.2 TCP rfc1337 4.2.3 リバースパスフィルタリング 4.2.4 martian パケットをログに記録する 4.2.5 ICMP リダイレクトを無効にする 4.2.6 ICMP エコー要求を無視する 4.3 その他 4.3.1 特権を持たないユーザが IPPROTO_ICMP ソケットを作成できるようにする\n- 5 仮想メモリ 5.1 VFS キャッシュ\n- 6 MDADM\n- 7 トラブルシューティング 7.1 定期的にシステムがフリーズする\n- 8 参照\n\n- 4.1 パフォーマンスを向上させる 4.1.1 受信キューのサイズを増やす 4.1.2 最大接続数を増やす 4.1.3 ネットワークインターフェイス専用のメモリを増やす 4.1.4 TCP Fast Open を有効にする 4.1.5 保留中の接続処理を微調整する 4.1.6 TCP キープアライブパラメータを変更する 4.1.7 MTU プローブを有効にする 4.1.8 TCP タイムスタンプ 4.1.9 TCP Selective Acknowledgement 4.1.10 BBR を有効にする 4.1.11 エフェメラルポートの範囲を拡大\n- 4.2 TCP/IP スタックの強化 4.2.1 TCP SYN cookie 保護 4.2.2 TCP rfc1337 4.2.3 リバースパスフィルタリング 4.2.4 martian パケットをログに記録する 4.2.5 ICMP リダイレクトを無効にする 4.2.6 ICMP エコー要求を無視する\n- 4.3 その他 4.3.1 特権を持たないユーザが IPPROTO_ICMP ソケットを作成できるようにする\n\n- 4.1.1 受信キューのサイズを増やす\n- 4.1.2 最大接続数を増やす\n- 4.1.3 ネットワークインターフェイス専用のメモリを増やす\n- 4.1.4 TCP Fast Open を有効にする\n- 4.1.5 保留中の接続処理を微調整する\n- 4.1.6 TCP キープアライブパラメータを変更する\n- 4.1.7 MTU プローブを有効にする\n- 4.1.8 TCP タイムスタンプ\n- 4.1.9 TCP Selective Acknowledgement\n- 4.1.10 BBR を有効にする\n- 4.1.11 エフェメラルポートの範囲を拡大\n\n- 4.2.1 TCP SYN cookie 保護\n- 4.2.2 TCP rfc1337\n- 4.2.3 リバースパスフィルタリング\n- 4.2.4 martian パケットをログに記録する\n- 4.2.5 ICMP リダイレクトを無効にする\n- 4.2.6 ICMP エコー要求を無視する\n\n- 4.3.1 特権を持たないユーザが IPPROTO_ICMP ソケットを作成できるようにする\n\n- 5.1 VFS キャッシュ\n\n- 7.1 定期的にシステムがフリーズする\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "procps-ng パッケージは、base メタパッケージ の依存関係であるため、すでに インストール されている必要があります。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "sysctl のプリロード/設定ファイルは /etc/sysctl.d/99-sysctl.conf に作成することができます。systemd では、/etc/sysctl.d/ と /usr/lib/sysctl.d/ はカーネルの sysctl パラメータにどちらも使えるディレクトリです。名前と元のディレクトリによって処理される順番が決まります。最後のパラメータによって前の方のパラメータが置き換えられるので順番は重要です。例えば、/usr/lib/sysctl.d/50-default.conf に書かれたパラメータは /etc/sysctl.d/50-default.conf や両方のディレクトリよりも後に処理される設定ファイルにある同じパラメータによって置き換えられます。\n\n全ての設定ファイルを手動でロードするには、次を実行します:\n\n```\n# sysctl --system\n```\n\n適用される階層が出力されます。単一のパラメータファイルを指定してロードすることも可能です:\n\n```\n# sysctl -p filename.conf\n```\n\n詳しくは the new configuration files や systemd の sysctl.d man ページ を見て下さい。\n\n利用可能なパラメータは /proc/sys/ 以下に並んでいます。例えば、kernel.sysrq パラメータはファイルシステム上の /proc/sys/kernel/sysrq ファイルにあたります。sysctl -a コマンドを使うことで現在利用可能な値を全て表示することができます。\n\n設定の変更はファイルの操作によるか sysctl ユーティリティを使って行います。例えば、一時的にマジック SysRq キーを有効にするには:\n\n```\n# sysctl kernel.sysrq=1\n```\n\nもしくは:\n\n```\n# echo \"1\" > /proc/sys/kernel/sysrq\n```\n\n再起動後も変更を維持させるには、/etc/sysctl.d/99-sysctl.conf や他の /etc/sysctl.d/ 内の適用されるパラメータファイルに適切な行を追加・編集してください。\n\n"
    },
    {
      "title": "セキュリティ",
      "level": 2,
      "content": "セキュリティ#カーネルの堅牢化を見て下さい。\n\n"
    },
    {
      "title": "受信キューのサイズを増やす",
      "level": 4,
      "content": "受信したフレームは、ネットワークカード上のリングバッファから取り出した後、このキューに格納されます。\n\n高速なカードの場合、この値を大きくすると、パケットの損失を防ぐのに役立ちます:\n\n```\nnet.core.netdev_max_backlog = 16384\n```\n\n"
    },
    {
      "title": "最大接続数を増やす",
      "level": 4,
      "content": "カーネルが受け付ける接続数の上限 (デフォルトは 128):\n\n```\nnet.core.somaxconn = 8192\n```\n\n"
    },
    {
      "title": "ネットワークインターフェイス専用のメモリを増やす",
      "level": 4,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: このセクションは Cloudflare のブログ記事が動機となっているようですが、 RedHat の調整済みプロファイルではさらに小さい値を提案しており、これは 40 Gb の速度でのみ必要と思われます と主張しています。したがって、これらの設定は一般的なハードウェアでは役に立たないようです。 (議論: トーク:Sysctl#)\n\nデフォルトでは、Linux ネットワークスタックは、WAN リンクを介して高速で大規模なファイル転送をする (つまり、多くのネットワークパケットを扱う) ように設定されていません。正しい値を設定すると、メモリリソースを節約できる場合があります:\n\n```\nnet.core.rmem_default = 1048576\nnet.core.rmem_max = 16777216\nnet.core.wmem_default = 1048576\nnet.core.wmem_max = 16777216\nnet.core.optmem_max = 65536\nnet.ipv4.tcp_rmem = 4096 1048576 2097152\nnet.ipv4.tcp_wmem = 4096 65536 16777216\n```\n\nデフォルトの UDP 制限 4096 を増やすこともできます:\n\n```\nnet.ipv4.udp_rmem_min = 8192\nnet.ipv4.udp_wmem_min = 8192\n```\n\n詳細および推奨値については、次の資料を参照してください。\n\n- http://www.nateware.com/linux-network-tuning-for-2013.html\n- https://blog.cloudflare.com/the-story-of-one-latency-spike/\n\n"
    },
    {
      "title": "TCP Fast Open を有効にする",
      "level": 4,
      "content": "TCP Fast Open は、Transmission Control Protocol (TCP) の拡張機能であり、送信側の初期 TCP SYN 中にデータを交換できるようにすることで、ネットワーク遅延の低減に役立ちます。[3] デフォルトの 1 の代わりに値 3 を使用すると、着信接続と発信接続の両方で TCP Fast Open が許可されます:\n\n```\nnet.ipv4.tcp_fastopen = 3\n```\n\n"
    },
    {
      "title": "保留中の接続処理を微調整する",
      "level": 4,
      "content": "tcp_max_syn_backlog は、'Waiting Acknowledgment' 状態の保留接続の最大キュー長です。\n\nSYN フラッド DOS 攻撃を受けた場合、このキューはすぐにいっぱいになってしまいます。その時点で TCP SYN cookies が開始され、システムが正規のトラフィックに応答し続け、悪意のある IP をブロックするためのアクセス権を取得できるようにします。\n\nサーバがピーク時に過負荷になる場合は、この値を少し大きくするとよいかもしれません:\n\n```\nnet.ipv4.tcp_max_syn_backlog = 8192\n```\n\ntcp_max_tw_buckets は TIME_WAIT 状態のソケットの最大数です。\n\nこの数に達すると、システムはこの状態のソケットの破棄を開始します。\n\n単純な DOS 攻撃を防ぐには、この値を大きくします:\n\n```\nnet.ipv4.tcp_max_tw_buckets = 2000000\n```\n\ntcp_tw_reuse は、新しいタイムスタンプが以前の接続で記録された最新のタイムスタンプよりも大きい場合に、TCP が TIME-WAIT 状態の既存の接続を新しい発信接続で再利用するかどうかを設定します。\n\nこれにより、使用可能なネットワーク・ソケットの不足を回避するのに役立ちます:\n\n```\nnet.ipv4.tcp_tw_reuse = 1\n```\n\nソケットが強制的にクローズされる前に final FIN パケットを待つ秒数を指定します。これは厳密には TCP 仕様に違反しますが、サービス拒否攻撃を防ぐために必要です。Linux 2.2 では、デフォルト値は 180 [4] でした:\n\n```\nnet.ipv4.tcp_fin_timeout = 10\n```\n\ntcp_slow_start_after_idle は、新しい接続に対してだけ TCP をデフォルトのウィンドウサイズで開始するか、またはアイドル状態が長すぎる既存の接続に対してもTCPを開始するかを設定します。\n\nこの設定は、永続的な単一接続のパフォーマンスを無効にし、オフにすることもできます:\n\n```\nnet.ipv4.tcp_slow_start_after_idle = 0\n```\n\n"
    },
    {
      "title": "TCP キープアライブパラメータを変更する",
      "level": 4,
      "content": "TCPキープアライブは、相手側が応答を停止したかどうかを判断するのに役立つ TCP 接続のメカニズムです。TCP は、アイドル時間が経過すると、ヌルデータを含むキープアライブプローブをネットワークピアに数回送信します。ピアが応答しない場合、ソケットは自動的に閉じられます。デフォルトでは、TCP キープアライブプロセスはソケットのアクティビティを2時間 (7200秒) 待機してから最初のキープアライブプローブを送信し、75秒ごとに再送信します。TCP/IP ソケット通信が行われていてアクティブである限り、キープアライブパケットは必要ありません。\n\n```\nnet.ipv4.tcp_keepalive_time = 60\nnet.ipv4.tcp_keepalive_intvl = 10\nnet.ipv4.tcp_keepalive_probes = 6\n```\n\n"
    },
    {
      "title": "MTU プローブを有効にする",
      "level": 4,
      "content": "maximum transmission unit (MTU) が長いほどパフォーマンスは向上しますが、信頼性は低下します。\n\nこれは、パケットが失われると、より多くのデータが再送信されることになり、インターネット上の多くのルータは非常に長いパケットを配信できないためです:\n\n```\nnet.ipv4.tcp_mtu_probing = 1\n```\n\n詳細については、https://blog.cloudflare.com/path-mtu-discovery-in-practice/ を参照してください。\n\n"
    },
    {
      "title": "TCP タイムスタンプ",
      "level": 4,
      "content": "タイムスタンプ生成を無効にすると、スパイクが減少し、ギガビットネットワークのパフォーマンスが向上する可能性があります:\n\n```\nnet.ipv4.tcp_timestamps = 0\n```\n\n"
    },
    {
      "title": "TCP Selective Acknowledgement",
      "level": 4,
      "content": "TCP Selective Acknowledgement (TCP SACK) は、受信側が損失セグメントに関するより詳細な情報を送信側に与えられるようにして、再転送の量を減らします。これはブーリアン値 tcp_sack によって制御されます。これは高レイテンシなネットワークにおいて有用ですが、高速な LAN においてはこれを無効化することでスループットを増加させることができます。また、tcp_dsack も無効化してください。SACK を送信しない場合、D-SACK を送信したくないでしょうから。Forward Acknowledgement は SACK の上で動作し、SACK が無効化されていると Forward Acknowledgement も無効化されます。[6]\n\n```\nnet.ipv4.tcp_sack = 1\n```\n\n"
    },
    {
      "title": "BBR を有効にする",
      "level": 4,
      "content": "BBR 輻輳制御アルゴリズムは、インターネットトラフィックのより高い帯域幅とより低いレイテンシを実現するのに役立ちます。まず、tcp_bbr モジュールをロードしてください。\n\n```\nnet.core.default_qdisc = cake\nnet.ipv4.tcp_congestion_control = bbr\n```\n\n"
    },
    {
      "title": "エフェメラルポートの範囲を拡大",
      "level": 4,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: この変更によってパフォーマンスはどのように向上しますか? 英語版の議論ページ (議論: トーク:Sysctl#)\n\nエフェメラルポートは通常、Transmission Control Protocol (TCP) 、User Datagram Protocol (UDP) 、または Stream Control Transmission Protocol (SCTP) によって、クライアント/サーバ通信のクライアント側のポート割り当てとして使用されます。\n\n```\nnet.ipv4.ip_local_port_range = 30000 65535\n```\n\n"
    },
    {
      "title": "TCP/IP スタックの強化",
      "level": 3,
      "content": "IPv4 プロトコルのカーネルのネットワークセキュリティオプションを強化するためのパラメータセットと、同等のものが存在する関連する IPv6 パラメータを次に示します。\n\nシステムを ルーター として使用するなど、一部のユースケースでは、他のパラメータも有用な場合や必要な場合があります。\n\n"
    },
    {
      "title": "TCP SYN cookie 保護",
      "level": 4,
      "content": "SYN flood 攻撃からの保護に役立ちます net.ipv4.tcp_max_syn_backlog に到達したときにだけ起動します。詳細については、 [7] を参照してください。linux 5.10 以降では、デフォルトで設定されています。\n\n```\nnet.ipv 4.tcp_syncookies = 1\n```\n\n"
    },
    {
      "title": "TCP rfc1337",
      "level": 4,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: これは TCP 標準の一部ではないようですか?説明が正確でない可能性があります。[8] (議論: トーク:Sysctl#net.ipv4.tcp_rfc1337)\n\ntcp time-wait assassination hazard から保護し、time-wait 状態のソケットの RST パケットを破棄します。Linux 以外では広くサポートされていませんが、RFC に準拠しています。\n\n```\nnet.ipv4.tcp_rfc1337 = 1\n```\n\n"
    },
    {
      "title": "リバースパスフィルタリング",
      "level": 4,
      "content": "リバースパスフィルタリングを有効にすると、カーネルはマシン上のすべてのインタフェースから受信したパケットのソース検証を行います。これにより、IP スプーフィング方式を使用して被害を与える攻撃者から保護できます。\n\nカーネルのデフォルト値は 0 (ソース検証なし) ですが、systemd は /usr/lib/sysctl.d/50 default.conf を、net.ipv 4.conf.all.rp_filter を 2 (loose mode) [9] に設定して出荷します。\n\n次に、リバースパスフィルタリングメカニズムを value 1 (strict モード) に設定します。\n\n```\nnet.ipv4.conf.default.rp_filter = 1\nnet.ipv4.conf.all.rp_filter = 1\n```\n\nnet.ipv4.conf.default.*、net.ipv4.conf.interface.* および net.ipv4.conf.all.* については、 ip-sysctl.html を参照してください。\n\n"
    },
    {
      "title": "martian パケットをログに記録する",
      "level": 4,
      "content": "martian packet は、Internet Assigned Numbers Authority (IANA) による特殊な使用のために予約されている送信元アドレスまたは宛先アドレスを指定する IP パケットです。詳細は、Reserved IP addresses を参照してください。\n\nしばしば martian とルーティング不可能なパケットが危険な目的のために使われるかもしれません。さらなる検査のためにこれらのパケットをログに記録することは有用かもしれません [10]\n\n```\nnet.ipv4.conf.default.log_martians = 1\nnet.ipv4.conf.all.log_martians = 1\n```\n\n"
    },
    {
      "title": "ICMP リダイレクトを無効にする",
      "level": 4,
      "content": "背景は What are ICMP redirects? Should they be blocked? です。\n\nICMP リダイレクト受け入れをディセーブルにするには、次の手順を実行します。\n\n```\nnet.ipv4.conf.all.accept_redirects = 0\nnet.ipv4.conf.default.accept_redirects = 0\nnet.ipv4.conf.all.secure_redirects = 0\nnet.ipv4.conf.default.secure_redirects = 0\nnet.ipv6.conf.all.accept_redirects = 0\nnet.ipv6.conf.default.accept_redirects = 0\n```\n\nルータ以外で ICMP リダイレクト送信をディセーブルにするには、次の手順を実行します。\n\n```\nnet.ipv4.conf.all.send_redirects = 0\nnet.ipv4.conf.default.send_redirects = 0\n```\n\n"
    },
    {
      "title": "ICMP エコー要求を無視する",
      "level": 4,
      "content": "ICMP エコー (別名 ping) リクエストを無効にするには:\n\n```\nnet.ipv4.icmp_echo_ignore_all = 1\nnet.ipv6.icmp.echo_ignore_all = 1\n```\n\n"
    },
    {
      "title": "特権を持たないユーザが IPPROTO_ICMP ソケットを作成できるようにする",
      "level": 4,
      "content": "Table content:\nこの記事またはセクションは情報が古くなっています。 理由: /usr/lib/sysctl.d/50 default.conf は、net.ipv4.ping_group_range を 0 2147483647 に設定します。 (Discuss)\n\nIPPROTO_ICMP (icmp(7)) ソケットタイプを使用すると、raw(7) ソケット (CAP_NET_RAW ケイパビリティ または SUID ビットを適切な特権所有者で開く必要のある操作) を開くことなく、 ICMP_ECHO メッセージを送信し、対応する ICMP_ECHOREPLY メッセージを受信できるようになります。これらの ICMP_ECHO メッセージはアプリケーションによって送信されるため、IPPROTO_ICMP ソケットは ICMP エコーソケットとは別に ping ソケットとも呼ばれます。\n\nping_group_range は、ユーザが IPPROTO_ICMP ソケットを作成できるグループの GID 範囲を決定します。さらに、 CAP_NET_RAW 機能の所有者も IPPROTO_ICMP ソケットを作成することができます。 デフォルトでは、この範囲は 1 0で、root 以外の誰も IPPROTO_ICMP ソケットを作成できないことを意味します。\n\nこの設定を利用するには、現在 raw ソケットを使っているプログラムは、代わりに IPPROTO_ICMP ソケットを使うように移植する必要があります。 たとえば、QEMUはSLIRP (User-mode networking) に IPPROTO_ICMP を使用するため、QEMU を実行しているユーザーが IPPROTO_ICMP ソケットを作成できるようにすると、ゲストから ping を実行できるようになります。\n\nGID 100 のグループのメンバーであるユーザーのみが IPPROTO_ICMP ソケットを作成できるようにするには、次のようにします。\n\n```\nnet.ipv4.ping_group_range = 100 100\n```\n\nシステム内のすべてのユーザーが IPPROTO_ICMP ソケットを作成できるようにするには、次のようにします。\n\n```\nnet.ipv4.ping_group_range = 0 65535\n```\n\n"
    },
    {
      "title": "仮想メモリ",
      "level": 2,
      "content": "Linux カーネルの virtual memory サブシステムの動作や、ディスクへのダーティデータの書き出しを調整するための重要なパラメータがいくつかあります。詳細については、公式の Linux kernel documentation を参照してください。例:\n\n- vm.dirty_ratio = 10\n\n- vm.dirty_background_ratio = 5\n\nパラメータのコメントに記載されているように、これらの値を設定する場合は RAM の合計容量を考慮する必要があります。たとえば、使用可能なメモリの代わりに、インストールされているシステム RAM を使用すると簡単です。\n\n- 比率の値を大きくすると、パフォーマンスが向上し、データ損失のリスクも高くなります。\n- この値を 0 に設定すると、ディスクおよびスパイクで待機時間が長くなる可能性があります。\n\n詳細については、https://lonesysadmin.net/2013/12/22/better-linux-disk-caching-performance-vm-dirty_ratio/ を参照してください。\n\n- RAM の vm.dirty_ratio を 10% に設定することは、RAM が例えば 1GB (10%は 100 MB) の場合、妥当な値です。しかし、マシンの RAM がもっと大きい場合、たとえば 16GB (10%は 1.6 GB) になると、回転中のディスクに数秒の書き戻しが行われるため、割合が不釣り合いになることがあります。この場合、より妥当な値は 3 です (16GB の 3% は約 491MB です) 。\n- 同様に、vm.dirty_background_ratio を 5 に設定することは、メモリ値が小さい場合は問題ありません、RAM 容量を考慮して調整してください。\n\n"
    },
    {
      "title": "VFS キャッシュ",
      "level": 3,
      "content": "virtual file system (VFS) キャッシュパラメータの値を小さくすると、システムの応答性が向上する場合があります。\n\n- vm.vfs_cache_pressure = 50\n\n"
    },
    {
      "title": "MDADM",
      "level": 2,
      "content": "カーネルがソフトウェア raid デバイスの resync を実行するときは、システムに高負担をかけないように速度を制限しています。sysctl を使って速度制限を上げたり下げたりすることが可能です。\n\n```\n# Set maximum and minimum speed of raid resyncing operations\ndev.raid.speed_limit_max = 10000\ndev.raid.speed_limit_min = 1000\n```\n\nmdadm が md_mod モジュールとしてコンパイルされている場合、上記の設定はモジュールがロードされた後にのみ使うことができます。/etc/sysctl.d を使って起動時に設定をロードする場合、md_mod モジュールは /etc/modules-load.d で事前にロードすることができます。\n\n"
    },
    {
      "title": "定期的にシステムがフリーズする",
      "level": 3,
      "content": "ダーティバイトを十分小さい値に設定 (例えば 4M):\n\n```\nvm.dirty_background_bytes = 4194304\nvm.dirty_bytes = 4194304\n```\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- sysctl(8) と sysctl.conf(5)\n- /proc/sys/ の Linux カーネルドキュメント\n- カーネルドキュメント: IP Sysctl\n- sysctl のカーネルネットワークパラメータ\n- sysctl-explorer.net – an initiative to facilitate the access of Linux' sysctl reference documentation\n- Disable Source Routing - Red Hat Customer Portal\n- SUSE handbook about Security Features in the Kernel\n\n"
    }
  ]
}