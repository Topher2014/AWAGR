{
  "title": "Bash (Русский)/Prompt customization (Русский)",
  "url": "https://wiki.archlinux.org/title/Bash_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)/Prompt_customization_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Bash (Русский)\n- Переменные окружения\n- Git#Git prompt\n\nВ Bash существует несколько приглашений командной строки, каждое из которых можно настроить на основе личных представлений об удобстве и эстетичности.\n\n"
    },
    {
      "title": "Приглашения",
      "level": 2,
      "content": "Bash имеет четыре строки приглашения, каждая из которых может быть настроена.\n\n- PS1 — основное приглашение, которое отображается перед каждой командой; по этой причине модифицируется чаще всего.\n- PS2 — второе приглашение, отображается, если команде требуются дополнительные данные для ввода (например, в случае многострочных команд).\n- PS3 — используется довольно редко. Отображается при работе встроенной команды Bash select, выводящей интерактивное меню. В отличие от остальных приглашений, не раскрывает escape-последовательности Bash. Обычно все изменения применяются непосредственно в скрипте, содержащем select, а не в файле .bashrc.\n- PS4 — также используется редко. При отладке скриптов показывает уровни вложенности — первый символ приглашения повторяется столько раз, сколько на данный момент задействовано уровней.\n\nНастройка конкретного приглашения подразумевает присваивание (обычно в файле ~/.bashrc) необходимой строки в переменную, например:\n\n```\nPS2='> '\n```\n\n"
    },
    {
      "title": "Техники",
      "level": 2,
      "content": "Приглашение всегда можно задать строкой в явном виде, но существует ряд техник, позволяющих сделать его более динамичным и полезным.\n\n"
    },
    {
      "title": "Escape-последовательности Bash",
      "level": 3,
      "content": "При выводе строки приглашения Bash ищет экранированные символом слэша символы (escape-последовательности) и конвертирует их в специальные строки. Например, \\u превратится в имя пользователя, а \\A — в текущее время. Таким образом, если переменной PS1 присвоить '\\A \\u $ ', то приглашение будет выглядеть как 17:35 пользователь $ .\n\nПолный список escape-последовательностей можно найти в руководстве bash(1) § PROMPTING и в справочнике Bash.\n\n"
    },
    {
      "title": "Escape-последовательности terminfo",
      "level": 3,
      "content": "Помимо escape-последовательностей, которые понимает Bash, большинство терминалов также распознают специальные последовательности, которые влияют на терминал сам по себе, а не на печатаемые символы. Например, так можно изменить цвет строки символов, сдвинуть курсор в произвольную позицию или очистить экран. Эти последовательности могут быть довольно неудобными и варьируются от терминала к терминалу, поэтому они задокументированы в базе данных terminfo. Чтобы увидеть, какие свойства поддерживает ваш терминал, выполните:\n\n```\n$ infocmp\n```\n\nЗначение свойств можно найти в terminfo(5) по их названиям (часть перед =). Например, свойство setaf настраивает цвет шрифта для всего текста, который будет напечатан после него. Узнать escape-код свойства можно командой tput. Например,\n\n```\n$ tput setaf 2\n```\n\nвыведет escape-последовательности для настройки зелёного цвета шрифта.\n\nНа практике, чтобы использовать эти возможности в приглашении командной строки, можно использовать подстановку команд Bash и интерполяцию строк. Например:\n\n```\nGREEN=\"\\[$(tput setaf 2)\\]\"\nRESET=\"\\[$(tput sgr0)\\]\"\n\nPS1=\"${GREEN}my prompt${RESET}> \"\n```\n\n"
    },
    {
      "title": "Escape-последовательности ANSI",
      "level": 3,
      "content": "К сожалению, ANSI-последовательности могут отсутствовать в базе terminfo вашего терминала. Чаще всего это касается последовательностей для новейших возможностей вроде поддержки 256 цветов. В этом случае использовать tput не получится и придётся вводить escape-последовательности вручную.\n\nПримеры escape-последовательностей можно найти в статье Управляющие последовательности ANSI. Каждая последовательность начинается с литерала escape-последовательности, которую вы можете ввести с помощью escape-последовательности Bash \\e. Например, \\e[48;5;209m задаст персиковый цвет фона (если есть поддержка 256 цветов), а \\e[2;2H сдвинет курсор в левый верхний угол экрана.\n\nВ случаях, когда escape-последовательности Bash не поддерживаются (как в приглашении PS3), их можно добавить командой printf:\n\n```\nESC=$(printf \"\\e\")\nPEACH=\"$ESC[48;5;209m\"\n```\n\n"
    },
    {
      "title": "Встроенные команды",
      "level": 3,
      "content": "Если вы хотите добавить вывод какой-нибудь команды в приглашение, то используйте подстановку команд (command substitution). Например, чтобы добавить величину свободной памяти к приглашению попробуйте что-то вроде:\n\n```\nPS1=\"$(awk '/MemFree/{print $2}' /proc/meminfo) prompt > \"\n```\n\n```\n53718 prompt >\n53718 prompt >\n53718 prompt >\n```\n\nКак видно, это работает не совсем корректно — значение памяти всегда одно и то же! Причина — команда выполняется только один раз при первой настройке PS1. Необходимо предотвратить подстановку либо экранированием символа $, либо определением строки в одиночных кавычках — в обоих случаях подстановка будет производиться каждый раз при настоящем отображении приглашения:\n\n```\nPS1=\"\\$(awk '/MemFree/{print \\$2}' /proc/meminfo) prompt > \"\n# или\nPS1='$(awk \"/MemFree/{print \\$2}\" /proc/meminfo) prompt > '\n```\n\nЕсли команды сделали приглашение слишком длинным, для лучшей читабельности можно вынести их в функцию:\n\n```\nfree_mem()\n{\n    awk '/MemFree/{print $2}' /proc/meminfo\n}\n\nPS1='$(free_mem) prompt > '\n```\n\nNote: **не** \n\n"
    },
    {
      "title": "PROMPT_COMMAND",
      "level": 3,
      "content": "Переменной PROMPT_COMMAND можно присвоить произвольную команду, которая будет выполняться непосредственно перед выводом PS1. Это позволяет создавать довольно мощные эффекты. Например, можно переназначить PS1 на основе некоторых условий, или выполнить какие-то действия с историей Bash при выполнении любой команды.\n\n"
    },
    {
      "title": "Escape-последовательности между вводом и выводом",
      "level": 3,
      "content": "Свойства вводимого текста можно изменить, \"забыв\" отключить свойства в конце PS1. Например, если вставить tput blink в конец PS1, то вводимые команды будут мерцать. Тем не менее, этот эффект также перейдёт и на вывод команды, поскольку свойства не отключаются при нажатии Enter.\n\nЧтобы вставить escape-последовательность после ввода, но перед началом вывода, можно перехватить (trap) Bash-сигнал DEBUG, который посылается перед выполнением каждой команды:\n\n```\n$ trap 'tput sgr0' DEBUG\n```\n\n"
    },
    {
      "title": "Настройка приглашения root",
      "level": 3,
      "content": "Для удобства можно сделать приглашение командной строки root-пользователя визуально отличным от обычного (возможно, мерцающий красный цвет?). Настройка приглашения производится как обычно, но в домашнем каталоге суперпользователя, /root. Начните с копирования шаблонов /etc/skel/.bash_profile и /etc/skel/.bashrc в каталог /root, после чего внесите в файл /root/.bashrc необходимые изменения.\n\n"
    },
    {
      "title": "Цвета",
      "level": 3,
      "content": "Увидеть все цвета вашего терминала можно с помощью простого цикла (замените setab на setaf, если нужен цвет текста, а не фона):\n\n```\nfor C in {0..255}; do\n    tput setab $C\n    echo -n \"$C \"\ndone\ntput sgr0\necho\n```\n\nЕсли это не работает (причём установлено правильное значение TERM), протестируйте вручную разные последовательности:\n\n```\n# стандартные цвета\nfor C in {40..47}; do\n    echo -en \"\\e[${C}m$C \"\ndone\n# цвета высокой интенсивности\nfor C in {100..107}; do\n    echo -en \"\\e[${C}m$C \"\ndone\n# 256 цветов\nfor C in {16..255}; do\n    echo -en \"\\e[48;5;${C}m$C \"\ndone\necho -e \"\\e(B\\e[m\"\n```\n\nАналогичные значения для текста (не фона): стандартные — 30..37, высокая интенсивность — 90..97, а для 256 цветов замените 48 на 38.\n\n"
    },
    {
      "title": "Основные свойства",
      "level": 3,
      "content": "Следующие свойства terminfo будут полезны при настройке приглашения и поддерживаются во многих терминалах. #1 и #2 необходимо заменить на числовые аргументы.\n\nTable content:\nСвойство | Escape-последовательность | Описание\nСвойства текста\nblink | \\E[5m | мерцающий тект вкл\nbold | \\E[1m | полужирный текст вкл\ndim | \\E[2m | тусклый текст вкл\nrev | \\E[7m | обратное отображение вкл (текст/фон меняются цветами)\nsitm | \\E[3m | курсив вкл\nritm | \\E[23m | курсив выкл\nsmso | \\E[7m | выделение текста вкл\nrmso | \\E[27m | выделение текста выкл\nsmul | \\E[4m | подчёркивание вкл\nrmul | \\E[24m | подчёркивание выкл\nsetab #1 | \\E[4#1m | задать цвет фона #1 (0-7)\nsetaf #1 | \\E[3#1m | задать цвет текста #1 (0-7)\nsgr0 | \\E(B\\E[m | отключить все атрибуты текста\nПеремещение курсора\nsc | \\E7 | сохранить позицию курсора\nrc | \\E8 | вернуть курсор в сохранённую позицию\nclear | \\E[H\\E[2J | очистить экран и переместить курсор в левый верхний угол\ncuu #1 | \\E[#1A | переместить курсор вверх на #1 строк\ncud #1 | \\E[#1B | переместить курсор вниз #1 строк\ncuf #1 | \\E[#1C | переместить курсор вправо #1 столбцов\ncub #1 | \\E[#1D | переместить курсор влево #1 столбцов\nhome | \\E[H | переместить курсор в левый верхний угол окна\nhpa #1 | \\E[#1G | переместить курсор в столбец #1\nvpa #1 | \\E[#1d | переместить курсор в строку #1, первый столбец\ncup #1 #2 | \\E[#1;#2H | переместить курсор в строку #1, столбец #2\nУдаление символов\ndch #1 | \\E#1P | удалить #1 символов (аналогично нажатию клавиши backspace)\ndl #1 | \\E#1M | удалить #1 строк\nech #1 | \\E#1X | стереть #1 символов (без перемещения курсора)\ned | \\E[J | очистить до нижнего края экрана\nel | \\E[K | очистить до конца строки\nel1 | \\E[1K | очистить до начала строки\n\n"
    },
    {
      "title": "Отображение кода выхода",
      "level": 3,
      "content": "Тем же приёмом, как в случае встроенных команд, можно отложить интерполяцию специальной переменной Bash вроде $?. Следующие приглашения будут содержать код выхода предыдущей команды:\n\n```\nPS1=\"\\$? > \"\n# или\nPS1='$? > '\n```\n\nЭто можно сделать с помощью условных выражений и функций:\n\n```\nexitstatus()\n{\n    if [[ $? == 0 ]]; then\n        echo ':)'\n    else\n        echo 'D:'\n    fi\n}\nPS1='$(exitstatus) > '\n```\n\n"
    },
    {
      "title": "Позиционирование курсора",
      "level": 3,
      "content": "Курсор можно перемещать по экрану во время нахождения \"внутри\" приглашения PS1, чтобы разные части приглашения появлялись в разных местах. Важный момент — после всех перемещений и вывода символов в любых местах экрана курсор необходимо вернуть в исходную позицию. Это можно сделать с помощью свойств sc и rc, которые сохраняют и восстанавливают позицию курсора соответственно. Общая схема приглашения, содержащего перемещения курсора:\n\n```\nPS1=\"\\[$(tput sc; перемещение курсора) работа с курсором $(tput rc)\\] работа с курсором после возврата\"\n```\n\nВесь блок с перемещениями курсора обёрнут в \\[ \\], чтобы Bash не учитывал непечатаемые символы как часть приглашения.\n\n"
    },
    {
      "title": "Выравнивание по правому краю",
      "level": 4,
      "content": "Простейший способ напечатать текст у правого края экрана — использовать printf:\n\n```\nrightprompt()\n{\n    printf \"%*s\" $COLUMNS \"right prompt\"\n}\n\nPS1='\\[$(tput sc; rightprompt; tput rc)\\]left prompt > '\n```\n\nЗдесь задано поле %*s переменной длины с выравниванием по правому краю. Размер поля равен текущему количеству столбцов в терминале ($COLUMNS).\n\n"
    },
    {
      "title": "Произвольное позиционирование",
      "level": 4,
      "content": "Свойство cup перемещает курсор в конкретную позицию экрана, например, tput cup 20 5 переместит курсор на строку 20, столбец 5 (координаты 0 0 обозначают верхний левый угол). cuu, cud, cuf и cub (вверх, вниз, вперёд, назад) перемещают курсор относительно текущей позиции. Например, tput cuf 10 переместит курсор на 10 символов вправо. В аргументах можно использовать переменные LINES и COLUMNS, если требуется переместить курсор относительно нижнего и правого краёв окна. Например, перемещение на 10 строк и 5 столбцов от правого нижнего угла:\n\n```\n$ tput cup $((LINES - 11)) $((COLUMNS - 6))\n```\n\n"
    },
    {
      "title": "Настройка названия окна терминала",
      "level": 3,
      "content": "Название окна терминала можно настроить так же, как и приглашение: выводом escape-последовательностей в оболочке. Часто пользователи встраивают настройки названия окна в своё приглашение. Технически это возможность xterm, но и другие современные терминалы её поддерживают. В этом случае используют последовательности ESC]2;новое названиеBEL, где ESC и BEL — символы escape (выход) и bell (сигнал). С последовательностями Bash приглашение с встроенным названием окна будет иметь вид:\n\n```\nPS1='\\[\\e]2;новое название\\a\\]prompt > '\n```\n\nСамо собой, строка названия окна может включать вывод встроенных команд или переменные вроде $PWD, так что она может перенастраиваться после каждой команды.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Примеры и скриншоты на теме форума: What's your PS1? (доступно только после входа)\n- Файл /etc/bash/bashrc для Gentoo; см. также gentoo-bashrcAUR\n- tput(1) Цвета и перемещение курсора с tput\n- Приглашение Bash HOWTO\n- Коллекция примеров приглашений от Giles Orr\n- Советы Bash: цвета и форматирование\n- Liquid Prompt — полезное адаптивное приглашение для Bash & zsh\n- Bash POWER PROMPT\n- Wikipedia:ru:Управляющие последовательности ANSI\n- Руководство GNU Bash: управление приглашением\n\n- Цвета и перемещение курсора с tput\n\n"
    }
  ]
}