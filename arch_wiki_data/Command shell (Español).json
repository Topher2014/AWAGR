{
  "title": "Command shell (Español)",
  "url": "https://wiki.archlinux.org/title/Command_shell_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2022-11-01** \n\nArtículos relacionados\n\n- dotfiles\n- Utilidades principales\n\nDe Wikipedia:\n\n"
    },
    {
      "title": "Listado de intérpretes de línea de órdenes",
      "level": 2,
      "content": "Los intérpretes de línea de órdenes que son más o menos compatibles con POSIX se listan bajo #Compatibles POSIX, mientras que los intérpretes de línea de órdenes que tienen una sintaxis diferente están bajo #Intérpretes de línea de órdenes alternativos.\n\n"
    },
    {
      "title": "Compatibles POSIX",
      "level": 3,
      "content": "Todos estos intérpretes de línea de órdenes se pueden enlazar desde /usr/bin/sh. Cuando Bash, mkshAUR y zsh se invocan con el nombre sh, automáticamente se vuelven más compatibles con POSIX.\n\n- Bash — Bash extiende el intérprete de línea de órdenes Bourne con el historial y el completado de la línea de órdenes, matrices indexadas y asociativas, aritmética de enteros, sustitución de procesos, cadenas de caracteres, coincidencia de expresiones regulares y expansión de llaves.\n\n- Dash — Descendiente de la versión NetBSD del intérprete de línea de órdenes Almquist (ash). Un intérprete de línea de órdenes rápido y compatible con POSIX que pretende ser lo más pequeño posible.\n\n- KornShell (ksh) — El lenguaje KornShell es un lenguaje de programación completo, potente y de alto nivel para escribir aplicaciones, a menudo más fácil y rápidamente que con otros lenguajes de alto nivel. Esto lo hace especialmente adecuado para la creación de prototipos. ksh tiene las mejores características del intérprete de línea de órdenes Bourne y el intérprete de línea de órdenes C, además de muchas características nuevas y propias. Por lo tanto, ksh puede hacer mucho para mejorar su productividad y la calidad de su trabajo, tanto en la interacción con el sistema como en la programación. Los programas ksh son más fáciles de escribir, y son más concisos y legibles que los programas escritos en un lenguaje de nivel inferior como C.\n\n- Oil Shell (OSH) — Oil Shell es un intérprete de línea de órdenes UNIX compatible con Bash. OSH se puede ejecutar en la mayoría de los sistemas operativos tipo UNIX, incluido GNU/Linux. Está escrito en Python (v2.7), pero viene con un ejecutable nativo. El dialecto de Bash reconocido por OSH se denomina lenguaje OSH.\n\n- Yash — Otro intérprete más, es un intérprete de línea de órdenes compatible con POSIX escrito en C99 (ISO/IEC 9899:1999). Yash está destinado a ser el intérprete más compatible con POSIX del mundo, al tiempo que soporta funciones para el uso diario interactivo y de secuencias de órdenes.\n\n- Zsh — Intérprete de línea de órdenes diseñado para uso interactivo, aunque también es un poderoso lenguaje de scripting. Muchas de las características útiles de Bash, ksh y tcsh se incorporaron a Zsh; se añadieron también muchas características originales. El documento introductorio detalla algunas de las características únicas de Zsh.\n\n"
    },
    {
      "title": "Intérpretes de línea de órdenes alternativos",
      "level": 3,
      "content": "- C shell (tcsh) — El intérprete de lenguaje de órdenes se puede utilizar como intérprete de línea de órdenes de inicio de sesión interactivo y como procesador de órdenes de script de intérprete de línea de órdenes. Incluye un editor de línea de órdenes, completado programable de palabras, corrección ortográfica, un mecanismo de historial, control de trabajos y una sintaxis tipo C.\n\n- Elvish — Elvish es un intérprete de línea de órdenes moderno y expresivo, que puede llevar valores estructurados internos a través de tuberías (pipelines). Esta característica hace posible evitar una gran cantidad de código de procesamiento de texto complejo. Cuenta con un lenguaje de programación expresivo, con características como excepciones, espacios de nombres y funciones anónimas. También tiene una potente línea de lectura que comprueba la sintaxis mientras se escribe y resaltado de sintaxis de forma predeterminada.\n\n- fish — Intérprete de línea de órdenes inteligente y amigable. Fish realiza el resaltado de sintaxis de la línea de órdenes a todo color, así como el resaltado y el completado de las órdenes y sus argumentos, la existencia del archivo y el historial. Soporta el completado-mientras-escribes del historial y las órdenes. Fish puede analizar las páginas del manual de las órdenes del sistema para determinar los argumentos para las órdenes, lo que le permite resaltar y completar las órdenes. Se puede hacer una fácil revisión de la última orden mediante Alt+Arriba. El demonio fish (fishd) facilita el historial sincronizado en todas las instancias de fish, así como las variables de entorno persistentes y universales. Además, fish presenta una sintaxis de programación y un flujo de control significativamente simplificados (similar a ruby). Para más información, véase el tutorial.\n\n- ion — Ion es un intérprete de sistema moderno que presenta una sintaxis simple pero poderosa. Está escrito completamente en Rust, lo que aumenta en gran medida la calidad general y la seguridad del intérprete, eliminando las posibilidades de una vulnerabilidad similar a ShellShock y facilitando el desarrollo. También ofrece un nivel de rendimiento que supera al de Dash, al aprovechar las características de Ion. Si bien se desarrolla junto con RedoxOS y principalmente para RedoxOS, es totalmente compatible con otras plataformas *nix. Para obtener más detalles, véase su manual.\n\n- nushell — Nu se inspira en lenguajes de programación funcionales y herramientas CLI modernas. En lugar de pensar en los archivos y servicios como flujos de texto sin procesar, Nu considera cada entrada como algo con estructura.\n\n- Oh — Intérprete de línea de órdenes Unix escrito en Go. Es similar en espíritu pero diferente en detalle de otros intérpretes de línea de órdenes de Unix. Oh extiende las funciones del lenguaje de programación del intérprete de línea de órdenes sin sacrificar las funciones interactivas del intérprete de línea de órdenes.\n\n- Powershell — PowerShell es un lenguaje de programación orientado a objetos y un intérprete de línea de órdenes interactivo, originalmente escrito y exclusivo para Windows. Más tarde, fue de código abierto y portado a macOS y Linux.\n\n- rc — Intérprete de órdenes para Plan 9 que proporciona servicios similares al intérprete de línea de órdenes Bourne de UNIX, con algunas pequeñas adiciones y menos sintaxis idiosincrásica.\n\n- xonsh — Intérprete impulsado por Python con primitivas de intérprete adicionales a las que está acostumbrado desde Bash e IPython.\n\n"
    },
    {
      "title": "Cambiar su intérprete de línea de órdenes predeterminado",
      "level": 2,
      "content": "Después de instalar uno de los intérpretes de línea de órdenes anteriores, puede ejecutar ese intérprete de línea de órdenes dentro de su intérprete de línea de órdenes actual, simplemente ejecutándolo. Sin embargo, si quiere que le sirvan ese intérprete de línea de órdenes cuando inicie sesión, deberá cambiar su intérprete de línea de órdenes predeterminado.\n\nPara listar todos los intérpretes de línea de órdenes instalados, ejecute:\n\n```\n$ chsh -l\n```\n\nY para configurar uno como predeterminado para su usuario haga:\n\n```\n$ chsh -s ruta-completa-al-intérprete-de-línea-de-órdenes\n```\n\nSi está utilizando systemd-homed, ejecute:\n\n```\n$ homectl update --shell=ruta-completa-al-intérprete-de-línea-de-órdenes usuario\n```\n\ndonde ruta-completa-al-intérprete-de-línea-de-órdenes es la ruta completa dada por chsh -l.\n\nSi ahora se desconecta y vuelve a iniciar sesión, será recibido por el otro intérprete de línea de órdenes.\n\n"
    },
    {
      "title": "Desinstalar el intérprete",
      "level": 2,
      "content": "Cambie el intérprete predeterminado antes de eliminar el paquete del intérprete.\n\nAlternativamente, modifique la base de datos de usuarios.\n\nUtilícelo para cada usuario con zsh configurado como su intérprete de inicio de sesión (incluido el superusuario si fuera necesario). Cuando se complete, el paquete se puede eliminar.\n\n"
    },
    {
      "title": "Intérprete de línea de órdenes de inicio de sesión",
      "level": 2,
      "content": "Un intérprete de línea de órdenes de inicio de sesión es un modo de invocación, en el que el intérprete de línea de órdenes lee archivos destinados a una inicialización única, como /etc/profile de todo el sistema o el ~/.profile del usuario u otros archivos específicos del intérprete. Estos archivos configuran el entorno inicial, que es heredado por todos los demás procesos iniciados desde el intérprete (incluidos otros intérpretes que no son de inicio de sesión o programas gráficos). Por lo tanto, se leen solo una vez al comienzo de una sesión, que es, por ejemplo, cuando el usuario inicia sesión en la consola o mediante SSH, cambia el usuario con sudo o su utilizando el parámetro --login, o cuando el usuario invoca manualmente un intérprete de línea de órdenes de inicio de sesión (por ejemplo, mediante bash --login).\n\nVéase #Archivos de configuración y los enlaces que contiene para obtener una descripción general de los distintos archivos de inicialización. Para obtener más información sobre el intérprete de línea de órdenes de inicio de sesión, véase también ¿Diferencia entre el intérprete de línea de órdenes de inicio de sesión y el intérprete sin inicio de sesión? y ¿Por qué un intérprete de línea de órdenes de \"inicio de sesión\" sobre un intérprete de \"no inicio de sesión\"? en Stackexchange.\n\n"
    },
    {
      "title": "Archivos de configuración",
      "level": 2,
      "content": "Para iniciar automáticamente los programas en la consola o al iniciar sesión, puede usar los archivos/directorios de inicio del intérprete de línea de órdenes. Lea la documentación de su intérprete de línea de órdenes o su artículo de ArchWiki, por ejemplo Bash (Español)#Archivos de configuración o Zsh#Startup/Shutdown files.\n\nVéase también Archivos de configuración para una comparación de varios archivos de configuración de varios intérpretes de línea de órdenes.\n\n"
    },
    {
      "title": "/etc/profile",
      "level": 3,
      "content": "Al iniciar sesión, todas las cargas (sources) en /etc/profile compatibles con el intérprete de línea de órdenes Bourne, que a su vez cargan los archivos *.sh legible en /etc/profile.d/: estos scripts no requieren una directiva de intérprete, ni necesitan ser ejecutables. Se utilizan para configurar un entorno y definir configuraciones específicas de la aplicación.\n\n"
    },
    {
      "title": "Estandarización",
      "level": 3,
      "content": "Es posible hacer que (algunos) archivos de configuración de los intérpretes de línea de órdenes sigan la misma convención de nomenclatura, así como admitir alguna configuración común entre los intérpretes de línea de órdenes.\n\nVéase el artículo sobre esto y el repositorio relacionado. Véase también xsh.\n\n"
    },
    {
      "title": "Entrada y salida",
      "level": 2,
      "content": "Véase también GregsWiki y Redirección E/S.\n\n- Las redirecciones truncan los archivos antes de ejecutar las órdenes: orden archivo > archivo por lo tanto no funcionará como se esperaba. Mientras que algunas órdenes (sed, por ejemplo) proporcionan una opción para editar archivos al momento, muchos no lo hacen. En esos casos puede utilizar la orden sponge(1) del paquete moreutils.\n- Debido a que cat no está integrado en el intérprete de línea de órdenes, en muchas ocasiones puede resultarle más conveniente utilizar una redirección, por ejemplo en scripts, o si le importa mucho el rendimiento. De hecho, < archivo hace lo mismo que cat archivo.\n\n```\norden archivo > archivo\n```\n\n- Los intérpretes de línea de órdenes compatibles con POSIX soportan Documentos aquí (Here Documents):\n\n```\n$ cat << EOF\nuno\ndos\ntres\nEOF\n```\n\n- Las tuberías del intérprete de línea de órdenes operan en la salida estándar (stdout) por defecto. Para operar en stderr(3) puede redireccionar stderr a stdout con orden 2>&1 | otra-orden o, en Bash 4, orden |& otra-orden.\n- Recuerde que muchas utilidades principales de GNU aceptan archivos como argumentos, por lo que, por ejemplo grep patrón < archivo se puede reemplazar por grep patrón archivo.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- Evolución de los intérpretes de línea de órdenes en Linux en IBM developerWorks\n- terminal.sexy — Diseñador de esquemas de color de terminal\n- Hyperpolyglot — Comparación lado-a-lado de las sintaxis del intérprete de línea de órdenes\n- UNIX Power Tools — Utilización general de la herramienta de línea de comandos\n- commandlinefu.com — Compartir fragmentos de línea de órdenes\n- List of applications/Utilities#Terminal emulators\n\n"
    }
  ]
}