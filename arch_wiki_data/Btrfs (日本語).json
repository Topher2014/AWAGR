{
  "title": "Btrfs (日本語)",
  "url": "https://wiki.archlinux.org/title/Btrfs_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- ファイルシステム\n- Snapper\n- Yabsnap\n\nBtrfs Wiki より:\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 準備\n- 2 ファイルシステムの作成 2.1 単一デバイス上のファイルシステム 2.2 マルチデバイス対応ファイルシステム 2.2.1 プロファイル\n- 3 ファイルシステムの構成 3.1 コピーオンライト (CoW) 3.1.1 CoW の無効化 3.1.1.1 スナップショットへの影響 3.2 圧縮 3.2.1 圧縮の種類と比率を表示する 3.3 サブボリューム 3.3.1 サブボリュームを作成する 3.3.2 サブボリュームを一覧する 3.3.3 サブボリュームの削除 3.3.4 サブボリュームをマウントする 3.3.5 サブボリュームをルートとしてマウントする 3.3.6 デフォルトのサブボリュームを設定する 3.4 クォータ 3.5 コミット間隔の設定 3.6 SSD TRIM\n- 4 使い方 4.1 スワップファイル 4.2 使用領域 空き領域の表示 4.3 デフラグメンテーション 4.4 RAID 4.4.1 Scrub 4.4.1.1 手動で開始する 4.4.1.2 サービスまたはタイマーを使って起動する 4.4.2 Balance 4.5 スナップショット 4.6 送信/受信 4.7 重複排除 4.8 リサイズ\n- 5 既知の問題 5.1 暗号化 5.2 btrfs チェックの問題\n- 6 ヒントとテクニック 6.1 パーティションレス Btrfs ディスク 6.2 Ext3/4 から Btrfs への変換 6.3 ファイルシステム破損のリカバリ 6.4 スナップショットから起動する 6.5 systemd-nspawn で Btrfs サブボリュームを使う 6.6 アクセス時間のメタデータ更新を削減 6.7 外付けドライブへの増分バックアップ 6.8 自動スナップショット 6.9 自動通知\n- 7 トラブルシューティング 7.1 GRUB 7.1.1 パーティションオフセット 7.1.2 root が見つからない 7.2 マウントがタイムアウト 7.3 BTRFS: open_ctree failed 7.4 btrfs check 7.5 絶え間ないドライブアクティビティ 7.6 Device total_bytes should be at most X but found Y 7.7 No space left on device\n- 8 参照\n\n- 2.1 単一デバイス上のファイルシステム\n- 2.2 マルチデバイス対応ファイルシステム 2.2.1 プロファイル\n\n- 2.2.1 プロファイル\n\n- 3.1 コピーオンライト (CoW) 3.1.1 CoW の無効化 3.1.1.1 スナップショットへの影響\n- 3.2 圧縮 3.2.1 圧縮の種類と比率を表示する\n- 3.3 サブボリューム 3.3.1 サブボリュームを作成する 3.3.2 サブボリュームを一覧する 3.3.3 サブボリュームの削除 3.3.4 サブボリュームをマウントする 3.3.5 サブボリュームをルートとしてマウントする 3.3.6 デフォルトのサブボリュームを設定する\n- 3.4 クォータ\n- 3.5 コミット間隔の設定\n- 3.6 SSD TRIM\n\n- 3.1.1 CoW の無効化 3.1.1.1 スナップショットへの影響\n\n- 3.1.1.1 スナップショットへの影響\n\n- 3.2.1 圧縮の種類と比率を表示する\n\n- 3.3.1 サブボリュームを作成する\n- 3.3.2 サブボリュームを一覧する\n- 3.3.3 サブボリュームの削除\n- 3.3.4 サブボリュームをマウントする\n- 3.3.5 サブボリュームをルートとしてマウントする\n- 3.3.6 デフォルトのサブボリュームを設定する\n\n- 4.1 スワップファイル\n- 4.2 使用領域 空き領域の表示\n- 4.3 デフラグメンテーション\n- 4.4 RAID 4.4.1 Scrub 4.4.1.1 手動で開始する 4.4.1.2 サービスまたはタイマーを使って起動する 4.4.2 Balance\n- 4.5 スナップショット\n- 4.6 送信/受信\n- 4.7 重複排除\n- 4.8 リサイズ\n\n- 4.4.1 Scrub 4.4.1.1 手動で開始する 4.4.1.2 サービスまたはタイマーを使って起動する\n- 4.4.2 Balance\n\n- 4.4.1.1 手動で開始する\n- 4.4.1.2 サービスまたはタイマーを使って起動する\n\n- 5.1 暗号化\n- 5.2 btrfs チェックの問題\n\n- 6.1 パーティションレス Btrfs ディスク\n- 6.2 Ext3/4 から Btrfs への変換\n- 6.3 ファイルシステム破損のリカバリ\n- 6.4 スナップショットから起動する\n- 6.5 systemd-nspawn で Btrfs サブボリュームを使う\n- 6.6 アクセス時間のメタデータ更新を削減\n- 6.7 外付けドライブへの増分バックアップ\n- 6.8 自動スナップショット\n- 6.9 自動通知\n\n- 7.1 GRUB 7.1.1 パーティションオフセット 7.1.2 root が見つからない\n- 7.2 マウントがタイムアウト\n- 7.3 BTRFS: open_ctree failed\n- 7.4 btrfs check\n- 7.5 絶え間ないドライブアクティビティ\n- 7.6 Device total_bytes should be at most X but found Y\n- 7.7 No space left on device\n\n- 7.1.1 パーティションオフセット\n- 7.1.2 root が見つからない\n\n"
    },
    {
      "title": "準備",
      "level": 2,
      "content": "ユーザースペースのユーティリティについては、基本的な操作に必要な btrfs-progs パッケージを インストール してください。\n\nBtrfs ファイルシステムから起動する必要がある場合 (つまり、カーネルと initramfs が Btrfs パーティションにある場合)、あなたの ブートローダー が Btrfs をサポートしているか確認してください。\n\n"
    },
    {
      "title": "ファイルシステムの作成",
      "level": 2,
      "content": "以下は、新しい Btrfs ファイルシステム を作成する方法を示しています。ext3/4 パーティションを Btrfs に変換するには、Ext3/4 から Btrfs への変換 を見て下さい。パーティションレスなセットアップを使うには、パーティションレス Btrfs ディスク を見て下さい。\n\n詳しくは mkfs.btrfs(8) を見て下さい。\n\n"
    },
    {
      "title": "単一デバイス上のファイルシステム",
      "level": 3,
      "content": "パーティション /dev/partition に Btrfs ファイルシステムを作るには、次のようにします。\n\n```\n# mkfs.btrfs -L mylabel /dev/partition\n```\n\nメタデータの Btrfs のデフォルトのノードサイズは 16KB ですが、データのデフォルトのセクターサイズはページサイズと同じで、自動検出されます。メタデータに大きなノードサイズを使用するには(セクターサイズの倍数である必要があり、最大 64KB が許可されます)、この例に示すように、-n スイッチを介して nodesize の値を指定します 32KB ブロックの使用例:\n\n```\n# mkfs.btrfs -L mylabel -n 32k /dev/partition\n```\n\n"
    },
    {
      "title": "マルチデバイス対応ファイルシステム",
      "level": 3,
      "content": "- Btrfs の RAID 5 と RAID 6 モードには致命的な欠陥があり、\"捨てデータでのテスト以外\" には使用しないでください。既知の問題と部分的な回避策のリスト。状況の更新については the Btrfs page on RAID5 and RAID6 を見て下さい。\n- デフォルトでは、systemd は /var/log/journal に対して CoW を無効にしていますが、これが原因で RAID 1 上でデータ破損が発生することがあります (#CoW の無効化 を参照) これを防ぐために、/usr/lib/tmpfiles.d/journal-nocow.conf を上書きするための空のファイル /etc/tmpfiles.d/journal-nocow.conf を作成してください(tmpfiles.d(5) § CONFIGURATION DIRECTORIES AND PRECEDENCE を参照)\n\n複数のデバイスを使用して RAID を作成することができます。サポートされている RAID レベルは RAID 0, RAID 1, RAID 10, RAID 5, RAID 6 です。カーネル 5.5 からは RAID1c3 と RAID1c4 で RAID1 レベルの 3-コピーと 4-コピーが可能です。RAIDレベルは、データ用とメタデータ用にそれぞれ -d と -m オプションを使って別々に設定することができます。デフォルトでは、データは1つのコピー (single) で、メタデータはミラーリング (raid1) された状態になっています。これは JBOD configuration を作成すると、ディスクは1つのファイルシステムとして認識されますが、ファイルは複製されません。Btrfs RAID ボリュームを作成する方法についての詳しい情報は Using Btrfs with Multiple Devices を見て下さい。\n\n```\n# mkfs.btrfs -d single -m raid1 /dev/part1 /dev/part2 ...\n```\n\nプールで複数の Btrfs デバイスを使うには udev フックか btrfs フックを /etc/mkinitcpio.conf に記述する必要があります。詳しくは Mkinitcpio#HOOKS の記事を見て下さい。\n\n- マルチデバイスファイルシステムに後からデバイスを追加することも可能です。詳しくは Btrfs wiki article を見て下さい。\n- デバイスは異なるサイズにすることができます。しかし、RAID 構成の1つのドライブが他のドライブより大きい場合、この余分なスペースは使用されません。\n- Syslinux などのいくつかの ブートローダー はマルチデバイスファイルシステムをサポートしません。\n- Btrfs は自動的に最速のデバイスから読み込むわけではないので、異なる種類のディスクを混在させるとパフォーマンスに一貫性がなくなります。詳しくは [1] を見て下さい。\n\nマルチデバイス Btrfs ファイルシステム特有のメンテナンスに関するアドバイスは #RAID をご覧下さい。\n\n"
    },
    {
      "title": "プロファイル",
      "level": 4,
      "content": "Btrfs は、ミラーリング、パリティ、ストライピングを構成するために プロファイル という概念を使用します。標準的な RAID 用語では、これは RAID level と呼ばれます。Btrfs ファイルシステムでは、メタデータ(mkfs.btrfs(8) の -m オプション) とデータ (mkfs.btrfs(8) の -d オプション)のプロファイルが異なる場合があります。\n\nいくつかの注目すべきプロファイル:\n\n"
    },
    {
      "title": "コピーオンライト (CoW)",
      "level": 3,
      "content": "デフォルトでは Btrfs は全てのファイルに対して常に copy-on-write を使用します。書き込みはその場のデータを上書きしません; 代わりに、ブロックの修正されたコピーが新しい場所に書き込まれ、メタデータは新しい場所を指すように更新されます。実装の詳細や利点と欠点については Btrfs Sysadmin Guide セクション を見て下さい。\n\n"
    },
    {
      "title": "CoW の無効化",
      "level": 4,
      "content": "マウントされたサブボリュームで新しく作成されたファイルのコピー オン ライトを無効にするには、nodatacow マウント オプションを使用します。これは、新しく作成されたファイルにのみ影響します。コピーオンライトは、既存のファイルに対して引き続き影響します。 nodatacow オプションも圧縮を無効にします。詳しくは btrfs(5) をご覧ください。\n\nファイルやディレクトリ単体で CoW を無効化するには、次のコマンドを使って下さい:\n\n```\n$ chattr +C </dir/file>\n```\n\nこれにより、ファイルへの参照が 1つしかない操作のコピーオンライトが無効になります。複数の参照がある場合。ファイル クローン/軽量クローンまたはファイルシステムスナップショットが原因で、コピーオンライトが引き続き発生します。coreutils 9.0 以降、cp はデフォルトで軽量コピーを実行しようとすることに注意してください。詳細については、cp(1) を参照してください。\n\n```\n$ mv /path/to/dir /path/to/dir_old\n$ mkdir /path/to/dir\n$ chattr +C /path/to/dir\n$ cp -a --reflink=never /path/to/dir_old/. /path/to/dir\n$ rm -rf /path/to/dir_old\n```\n\nファイルのコピーオンライトが無効 (NOCOW) でスナップショットが作成された場合、スナップショットは古いファイルブロックを所定の位置にロックするため、スナップショット後のファイルブロックへの最初の書き込みは COW 操作 になります。ただし、ファイルは NOCOW 属性を保持し、同じファイルブロックへの後続の書き込みは次のスナップショットまでそのまま残ります。\n\nスナップショットを頻繁に行うと、最初の書き込みで COW が必要になるため、NOCOW の効果が低下する可能性があります。そのようなファイルのコピーオンライトを完全に避けるには、それらを別のサブボリュームに入れ、そのサブボリュームのスナップショットを作成しないでください。\n\n"
    },
    {
      "title": "圧縮",
      "level": 3,
      "content": "Btrfs は 透過的自動圧縮 をサポートしています。これはファイルサイズを小さくするだけでなく、書き込み増幅を減らすことでフラッシュベースのメディアの寿命を大幅に延ばします。Fedora:Changes/BtrfsByDefault#Compression, [2], [3] を参照して下さい。また、パフォーマンスを向上させる 場合もありますが(例:重いファイル I/O を持つシングルスレッド)、(例:大きなファイル I/O を持つマルチスレッドや CPU 集中タスク)では明らかにパフォーマンスを低下させることがあります。一般に、最速の圧縮アルゴリズムである zstd と lzo を用いると、より良いパフォーマンスが得られます。いくつかの benchmarks では、詳細な比較がなされています。\n\nここで alg は zlib, lzo, zstd, あるいは no のいずれかです。(圧縮しない場合) このオプションを使うと、btrfs はデータの最初の部分を圧縮することで縮小されるかどうかをチェックします。 もしそうなら、そのファイルへの書き込み全体が圧縮されます。 そうでない場合は、何も圧縮されません。 このオプションでは、書き込みの最初の部分が縮小しない場合、残りのデータが非常に縮小しても、書き込みに圧縮は適用されません。[4] これは、書き込むべき全てのデータが btrfs に完全に与えられ圧縮されるまで、ディスクの書き込み開始を待たせるのを防ぐために行われます。\n\n代わりに compress-force=alg マウントオプションを使うと、btrfs が最初の部分を圧縮しているかどうかのチェックをスキップし、全てのファイルに対して自動的に圧縮を試行することが可能になります。 最悪の場合、これは何の目的もなく CPU 使用量を (少し) 増加させる可能性があります。しかし、複数の用途が混在するシステムでの経験的なテストでは、 compress-force=zstd を使うことで、ただの compress=zstd に比べて約10%のディスク圧縮という大きな改善がありました、この場合も 10% のディスク圧縮でした。\n\nマウントオプションが追加された後に作成または変更されたファイルのみが圧縮されます。\n\nここで alg は zlib, lzo, zstd のいずれかです。例えば、ファイルシステム全体を zstd で再圧縮する場合、以下のコマンドを実行します。\n\n```\n# btrfs filesystem defragment -r -v -czstd /\n```\n\n空の Btrfs パーティションに Arch をインストールするときに圧縮を有効にするには、ファイルシステムを マウント するときに compress オプションを使ってください。mount -o compress=zstd /dev/sdxY /mnt/ となります。設定時に、fstabでルートファイルシステムのマウントオプションに compress=zstd を追加してください。\n\n- このオプションを使うと、古いカーネルや zstd をサポートしていない btrfs-progs を使っているシステムは、ファイルシステムを読んだり修復したりできない可能性があります。\n- GRUB は 2.04 で zstd のサポートを導入しました。MBR/ESP にインストールされたブートローダを実際にアップグレードしたことを確認してください。BIOS/UEFI セットアップに適したオプションで grub-install を実行して、FS#63235 を見て下さい。\n\n"
    },
    {
      "title": "圧縮の種類と比率を表示する",
      "level": 4,
      "content": "compsize はファイルのリスト (または btrfs ファイルシステム全体) を受け取り、使用された圧縮タイプと有効な圧縮率を測定します。 非圧縮サイズは du(1) のような他のプログラムによって与えられる数値と一致しないかもしれません。なぜなら、たとえ何度も再リンクされていても、たとえその一部がもうどこにも使われていないけれどゴミ収集されていないとしても、全てのエクステントは一度にカウントされるからです。 これは compsize -x / のような状況で便利で、btrfs でないサブディレクトリを探そうとして、実行全体が失敗するのを避けます。\n\n"
    },
    {
      "title": "サブボリューム",
      "level": 3,
      "content": "\"btrfs サブボリュームはブロックデバイスではありません(そしてブロックデバイスとして扱えません)代わりに btrfs サブボリュームは POSIX ファイル名空間として考えることができます。このネームスペースはファイルシステムのトップレベルのサブボリュームからアクセスすることもできますし、それ自体でマウントすることもできます\" [5]\n\n各 Btrfs ファイルシステムには ID 5 のトップレベルのサブボリュームがあります。これは / としてマウントすることができます。(デフォルト) または、代わりに別のサブボリュームを マウントする こともできます。サブボリュームはファイルシステム内で移動することができ、パスよりもむしろその ID で識別されます。\n\n詳細については、次のリンクを参照してください:\n\n- Btrfs Wiki SysadminGuide#Subvolumes\n- Btrfs Wiki Getting started#Basic Filesystem Commands\n- Btrfs Wiki Trees\n\n"
    },
    {
      "title": "サブボリュームを作成する",
      "level": 4,
      "content": "サブボリュームを作成するには:\n\n```\n# btrfs subvolume create /path/to/subvolume\n```\n\n"
    },
    {
      "title": "サブボリュームを一覧する",
      "level": 4,
      "content": "現在のサブボリュームのリストを表示するには:\n\n```\n# btrfs subvolume list -p .\n```\n\n"
    },
    {
      "title": "サブボリュームの削除",
      "level": 4,
      "content": "サブボリュームを削除するには\n\n```\n# btrfs subvolume delete /path/to/subvolume\n```\n\nLinux 4.18 以降では、通常のディレクトリのようにサブボリュームを削除することもできます (rm -r, rmdir)\n\n"
    },
    {
      "title": "サブボリュームをマウントする",
      "level": 4,
      "content": "サブボリュームは subvol=/path/to/subvolume や subvolid=objectid マウントフラグを使うことでファイルシステムのパーティションと同じようにマウントできます。例えば、subvol_root という名前のサブボリュームが存在したら / にマウントすることができます。ファイルシステムのトップレベルにサブボリュームを作成して適切なマウントポイントにマウントすることで、伝統的なファイルシステムのパーティションと同じように使うことができ、スナップショット を使用してファイルシステムを前の状態に簡単に戻すことが可能です。\n\nサブボリュームごとにどのマウントオプションが使えるかは Btrfs Wiki FAQ を見て下さい。\n\nSnapper#推奨ファイルシステムレイアウト, Btrfs SysadminGuide#Managing Snapshots, Btrfs SysadminGuide#Layout などにサブボリュームを使用するファイルシステムレイアウトの例が存在します。\n\nbtrfs 固有のマウントオプションの完全なリストは btrfs(5) を見て下さい。\n\n"
    },
    {
      "title": "サブボリュームをルートとしてマウントする",
      "level": 4,
      "content": "サブボリュームをルートマウントポイントとして使用するには、rootflags=subvol=/path/to/subvolume を使用して カーネルパラメータ 経由でサブボリュームを指定します。/etc/fstab でルート・マウントポイントを編集し、マウント・オプションに subvol= を指定します。または、サブボリュームの ID rootflags=subvolid=objectid をカーネルパラメータとして使い、subvolid=objectid を /etc/fstab のマウントオプションとして指定することもできます。\n\n"
    },
    {
      "title": "デフォルトのサブボリュームを設定する",
      "level": 4,
      "content": "マウントオプションに subvol= が指定されない場合、デフォルトのサブボリュームがマウントされます。デフォルトサブボリュームを変更するには、次のようにします。\n\n```\n# btrfs subvolume set-default subvolume-id /\n```\n\nここで、subvolume-id は listing で見つけることができます。\n\nbtrfs subvolume set-default でデフォルトのサブボリュームを変更すると、ファイルシステムのトップレベルは subvol=/ や subvolid=5 マウントオプションを使ってアクセスする以外ではアクセスできなくなります [6]\n\n"
    },
    {
      "title": "クォータ",
      "level": 3,
      "content": "Btrfs におけるクォータのサポートはクォータグループ (qgroup) を利用してサブボリュームレベルで実装されています: 各サブボリュームにはデフォルトで 0/<subvolume id> という形式でクォータグループが割り当てられています。必要であればクォータグループを作成することもできます。\n\nクォータグループを使うにはまずクォータを有効にする必要があります:\n\n```\n# btrfs quota enable <path>\n```\n\n上記のコマンドを実行してから新しいサブボリュームを作成すると、グループによって制御が可能になります。既存のサブボリュームでも制御を行いたい場合、クォータを有効にしてから、<subvolume id> を使ってサブボリュームごとにクォータグループを作成して再スキャンしてください:\n\n```\n# btrfs subvolume list <path> | cut -d' ' -f2 | xargs -I{} -n1 btrfs qgroup create 0/{} <path>\n# btrfs quota rescan <path>\n```\n\nBtrfs のクォータグループはツリー構造になっていて、サイズ制限はクォータグループごとに設定し、ツリーに属しているサブボリュームに制限が課せられます。\n\nクォータグループで設定できる制限は合計データ使用量・非共有のデータ使用量・圧縮データ使用量、あるいはそれらを組み合わせたものです。元のボリュームファイルを削除してコピーを残す場合、他のクォータグループの非共有制限が変わるため、ファイルのコピーや削除で制限に抵触する可能性があります。例えば、新しいスナップショットが元のサブボリュームの全てのブロックと同じデータを持っている場合、どちらかのサブボリュームだけで共通データを削除するともう片方のサブボリュームの制限に引っかかる可能性があります。\n\nクォータグループに制限を設定するには、btrfs qgroup limit コマンドを使います。合計使用量の制限や非共有制限 (-e) または圧縮制限 (-c) が設定できます。ファイルシステムの特定のパスにおける使用量や制限を表示するには:\n\n```\n# btrfs qgroup show -reF <path>\n```\n\n"
    },
    {
      "title": "コミット間隔の設定",
      "level": 3,
      "content": "データがファイルシステムに書き込まれる解像度は、Btrfs自体とシステム全体の設定によって決まります。 Btrfs のデフォルトは、新しいデータがファイルシステムにコミットされる30秒のチェックポイント間隔です。これは、btrfs パーティションの /etc/fstab に commit マウントオプションを追加することで変更できます。\n\n```\nLABEL=arch64 / btrfs defaults,compress=zstd,commit=120 0 0\n```\n\nシステム全体の設定もコミット間隔に影響します。これらには /proc/sys/vm/* の下のファイルが含まれており、このwiki記事の範囲外です。それらのカーネルドキュメントは、https://www.kernel.org/doc/html/latest/admin-guide/sysctl/vm.html で入手できます。\n\n"
    },
    {
      "title": "SSD TRIM",
      "level": 3,
      "content": "Btrfs ファイルシステムは、TRIM コマンドをサポートする SSD ドライブから未使用のブロックを解放できます。カーネルバージョン 5.6 以降、非同期破棄がサポートされ、マウントオプション discard=async で有効になります。解放されたエクステントはすぐには破棄されませんが、グループ化され、後で別のワーカースレッドによってトリミングされるため、コミットの待ち時間が短縮されます。\n\nTRIM の有効化と使用に関するより詳しい情報は ソリッドステートドライブ#TRIM に記載されています。\n\n"
    },
    {
      "title": "スワップファイル",
      "level": 3,
      "content": "Btrfs の スワップファイル は Linux カーネル5.0 以降でサポートされています。[7] スワップファイルを初期化する適切な方法は、最初にファイルをホストする非圧縮、非スナップショットのサブボリュームを作成し、そのディレクトリに cd してから、長さゼロのファイルを作成し、No_COW を設定することです。 属性を chattr で指定し、圧縮が無効になっていることを確認します。\n\n```\n# cd /path/to/swapfile\n# truncate -s 0 ./swapfile\n# chattr +C ./swapfile\n# btrfs property set ./swapfile compression none\n```\n\n詳細な設定については、 スワップファイルの作成 を参照してください。スワップファイルへの休止状態の構成については、Hibernation into swap file on Btrfsで説明されています。\n\n- スワップファイルをスナップショットサブボリュームに置くことはできません。適切な手順は、スワップファイルを配置する新しいサブボリュームを作成することです。\n- 複数のデバイスにまたがるファイルシステム上のスワップファイルはサポートされていません。 Btrfs wiki: Does btrfs support swap files? および Arch forums discussion。\n\n"
    },
    {
      "title": "使用領域 空き領域の表示",
      "level": 3,
      "content": "df(1) のような一般的な linux ユーザースペースツールは Btrfs パーティションの空き容量を不正確に報告します。Btrfs パーティションを調べるには btrfs filesystem usage を使うことが推奨されます。例えば、デバイスのアロケーションと使用状況の統計の完全な内訳を見るには、btrfs filesystem usage を使って下さい。\n\n```\n# btrfs filesystem usage /\n```\n\nあるいは、btrfs filesystem df を使えば、root で実行しなくても、割り当てられた領域の使用状況を素早くチェックすることができます。\n\n```\n$ btrfs filesystem df /\n```\n\n詳しくは [8] を参照してください。\n\ndu(1) や ncdu(1) のような、ファイルシステムのあるサブセットについて空間の使用状況を分析するツールにも同じ制限が適用され、これらは reflinks, snapshots, 圧縮を考慮しません。代わりに、btrfs を意識した代替手段は btduAUR と 圧縮の種類と比率を表示する を見て下さい。\n\n"
    },
    {
      "title": "デフラグメンテーション",
      "level": 3,
      "content": "Btrfs はマウントオプション autodefrag でオンラインデフラグをサポートしています、btrfs(5) § MOUNT OPTIONS を見て下さい。手動でルートのデフラグをするには:\n\n```\n# btrfs filesystem defragment -r /\n```\n\n上記のコマンドを -r スイッチなしで使用すると、ディレクトリを含むサブボリュームが保持するメタデータのみがデフラグされる結果となります。このため、パスを指定するだけで単一ファイルのデフラグが可能です。\n\nCOW コピー (スナップショット コピーまたは cp や bcp で作成されたもの) を持つファイルに圧縮アルゴリズムで -c スイッチを使用したデフラグを行うと、無関係の 2 つのファイルが効果的にディスク使用量を増加させる結果になることがあります。\n\n"
    },
    {
      "title": "RAID",
      "level": 3,
      "content": "Btrfs は マルチデバイス対応ファイルシステム のためのネイティブな RAID を提供します。btrfs RAID を mdadm と区別する注目すべき機能は自己回復型の冗長アレイとオンラインバランシングです。より詳しい情報は the Btrfs wiki page を見て下さい。Btrfs sysadmin ページにも にセクションがありますので参照して下さい。 技術的な背景があります。\n\n"
    },
    {
      "title": "Scrub",
      "level": 4,
      "content": "Btrfs Wiki Glossary によると、Btrfs スクラブはオンラインファイルシステムチェックツールです。ファイルシステム上のすべてのデータとメタデータを読み取り、チェックサムと RAID ストレージからの複製コピーを使用して、破損したデータを特定して修復します。\n\n/ を含むファイルシステムに対して (バックグラウンド) scrub を開始する場合。\n\n```\n# btrfs scrub start /\n```\n\n実行中の scrub の状態を確認する。\n\n```\n# btrfs scrub status /\n```\n\nbtrfs-progs パッケージは、指定したマウントポイントを毎月 scrubbing するためのユニット btrfs-scrub@.timer を提供します。例えば / の場合は btrfs-scrub@-.timer 、/home の場合は btrfs-scrub@home.timer のように、エスケープしたパスでタイマーを 有効化 してください。パスのエスケープは systemd-escape -p /path/to/mountpoint で行えます、詳しくは systemd-escape(1) を見て下さい。\n\nscrub を実行するには btrfs-scrub@.service を スタート します。(同じエンコードされたパスで) この方法の利点は btrfs scrub と比べても同じです。(root ユーザーで) scrub の結果が systemd/ジャーナル に記録されることです。\n\n冷却が不十分な大きな NVMe ドライブ (ラップトップなど) では、scrub はドライブを速く、長く読み込んで、ドライブを非常に高温にします。systemd で scrub を実行している場合、ドロップインファイル を使って systemd.resource-control(5) にある IOReadBandwidthMax オプションで簡単にスクラブ速度を制限することができます。\n\n"
    },
    {
      "title": "Balance",
      "level": 4,
      "content": "balance はファイルシステム上の全てのデータをアロケータに再度流し込みます。デバイスが追加されたり削除された場合にファイルシステム上のデータを再配置するために実行します。balance はデバイスが故障した場合に、冗長な RAID レベルのコピーを再生成します。\n\nbtrfs-progs-3.12 からバランシングはバックグラウンドプロセスになりました - 詳しくは man 8 btrfs-balance を見て下さい。\n\n```\n# btrfs balance start /\n# btrfs balance status /\n```\n\n"
    },
    {
      "title": "スナップショット",
      "level": 3,
      "content": "\"スナップショットとは、btrfs の COW 機能を使って、そのデータ(とメタデータ)を他のサブボリュームと共有する、サブボリュームのことです\" 詳しくは Btrfs Wiki SysadminGuide#Snapshots を見て下さい。\n\nスナップショットを作成するには\n\n```\n# btrfs subvolume snapshot source [dest/]name\n```\n\n読み取り専用のスナップショットを作成するには、-r フラグを追加します。readonly スナップショットの書き込み可能バージョンを作成するには、単純にそのスナップショットを作成します。\n\n- スナップショットを読み込み専用から書き込み専用に変換することは可能です。しかし、これは将来のインクリメンタル送受信で問題が発生するため、推奨されません[11] 新しい書き込み可能なスナップショットを作成することで、そのような問題を防ぐことができます。\n- スナップショットは再帰的ではありません。ネストされたサブボリュームは、スナップショット内部では空のディレクトリになります。\n\n"
    },
    {
      "title": "送信/受信",
      "level": 3,
      "content": "サブボリュームは send コマンドを使って標準出力やファイルに送信することができます。Btrfs の receive コマンドにパイプで渡すことで非常に便利に使うことが可能です。例えば、/root_backup という名前のスナップショットを /backup に送信するには以下のコマンドを実行します:\n\n```\n# btrfs send /root_backup | btrfs receive /backup\n```\n\n送信するスナップショットは読み取り専用である必要があります。上記のコマンドは外部デバイスにサブボリュームをコピーするのにも使えます (例えば上の /backup を USB ディスクにマウント)。\n\nまた、スナップショットの差分だけを送信することも可能です。例えば、上記のように root_backup のコピーを送信したことがある場合、root_backup_new という名前の読み取り専用のスナップショットを新しく作成してから、増加差分だけを /backup に送信するには:\n\n```\n# btrfs send -p /root_backup /root_backup_new | btrfs receive /backup\n```\n\nこれで root_backup_new という名前の新しいサブボリュームが /backup に作成されます。\n\n差分バックアップをしたり自動的にバックアップを行うツールは Btrfs Wiki's Incremental Backup を見てください。\n\n"
    },
    {
      "title": "重複排除",
      "level": 3,
      "content": "コピーオンライトを使用した場合、Btrfs は実際にはデータをコピーしないでファイルやサブボリュームをコピーできます。ファイルに変更が加えられたときに新しい本当のコピーが作成されます。重複排除はさらに共通部分が存在するデータブロックを認識して、コピーオンライトと同じようにエクステントにまとめてしまいます。\n\nBtrfs パーティションの重複排除に使用するツールについては 上流の Wiki エントリ を見てください。duperemove, bedupAUR, btrfs-dedup などが存在します。rmlint あるいは jdupesAUR などを使うことでファイルベースでデータの重複排除を行うこともできます。\n\nBtrfs の開発者はインバンド (同期的・インライン) 重複排除に取り組んでおり、新しいデータがファイルシステムに書き込まれたときに重複排除が実行されます。現在のところ実験的な機能としてツリー外で開発されています。新しい機能をテストしてみたい場合は カーネルの wiki ページ を参照してください。\n\n"
    },
    {
      "title": "リサイズ",
      "level": 3,
      "content": "ファイルシステムは、デバイスで利用可能な最大のスペースまで拡大することができ、正確なサイズを指定することもできます。ファイルシステムのサイズを大きくする前に、デバイスまたは論理ボリュームのサイズを大きくすることを確認します。 ファイルシステムに正確なサイズを指定する場合、新しいサイズが次の条件を満たすことを確認します。\n\n- 新しいサイズは既存のデータサイズより大きくなければなりません。\n- ファイルシステムのサイズは、使用可能な領域を超えて拡張できないため、新しいサイズは現在のデバイスサイズと同じかそれ以下でなければなりません。\n\nデバイス上のファイルシステムのサイズを小さくする場合は、新しいサイズが以下の条件を満たすことを確認する。\n\n- 新しいサイズは既存のデータサイズより大きくなければなりません。\n- ファイルシステムのサイズは使用可能な領域を超えて拡張できないため、新しいサイズは現在のデバイスのサイズと同じかそれ以下でなければなりません。\n\nファイルシステムのサイズをデバイスの利用可能な最大サイズに拡張するには、次のようにします。\n\n```\n# btrfs filesystem resize max /\n```\n\nファイルシステムを特定のサイズに拡張する場合。\n\n```\n# btrfs filesystem resize size /\n```\n\nsize は、希望するサイズにバイト単位で置き換えてください。K(キロバイト)、M(メガバイト)、G(ギガバイト)など、値の単位を指定することも可能です。また、値の前にプラス (+) 記号、マイナス (-) 記号を付けることで、現在のサイズに対する増減をそれぞれ指定することも可能です。\n\n```\n# btrfs filesystem resize +size /\n# btrfs filesystem resize -size /\n```\n\n"
    },
    {
      "title": "既知の問題",
      "level": 2,
      "content": "試す前に、いくつかの制限を知っておく必要があります。\n\n"
    },
    {
      "title": "暗号化",
      "level": 3,
      "content": "Btrfs には暗号化のサポートが組み込まれていませんが、この [12] は将来的に提供される可能性があります。 ユーザーは、 mkfs.btrfs を実行する前にパーティションを暗号化できます。 dm-crypt/スワップを使用したsystem#Btrfsサブボリューム全体の暗号化 を参照してください。\n\n既存の Btrfs ファイルシステムは EncFS や TrueCrypt のようなものを使用できますが、おそらく Btrfs の機能の一部はありません。\n\n"
    },
    {
      "title": "btrfs チェックの問題",
      "level": 3,
      "content": "ツールbtrfs check には既知の問題があるため、セクション #btrfs check をよく参照してから実行してください。\n\n"
    },
    {
      "title": "パーティションレス Btrfs ディスク",
      "level": 3,
      "content": "Btrfs はデータストレージデバイス全体を占有し、MBR や GPT のパーティション方式を置き換えることができます。この場合、サブボリューム を使用してパーティションをシミュレートします。ただし、既存のパーティション上に Btrfs ファイルシステムを作成 する場合、必ずしもパーティションレス構成にする必要はありません。パーティションレスの単一ディスク構成にはいくつかの制限があります。\n\n- 同じディスク上の別のパーティションに他のファイルシステムを配置することはできません。\n- 前のポイントのため、このディスクに ESP を持つことは不可能です。UEFI ブートには別のデバイスが必要です。\n\n既存のパーティションテーブルを Btrfs で上書きするには、次のコマンドを実行します:\n\n```\n# mkfs.btrfs /dev/sdX\n```\n\nたとえば、 /dev/sda1 ではなく /dev/sda を使用します。後者は、パーティショニングスキーム全体を置き換えるのではなく、既存のパーティションをフォーマットします。ルートパーティションは Btrfs なので、 btrfs がカーネルに組み込まれていることを確認するか、btrfs を mkinitcpio.conf#MODULES に入れて [mkinitcpio#イメージ作成とアクティベーション|initramfs を再生成] して下さい。\n\nブートローダ を、マスターブートレコード を備えたデータ記憶装置の場合と同様にインストールします。Syslinux#手動インストール または GRUB/Tips and tricks#パーティションまたはパーティションレスディスクへのインストール を参照してください。 Failed to mount /sysroot が原因でカーネルがブートしない場合は、 /etc/default/grub に GRUB_PRELOAD_MODULES=\"btrfs\" を追加して、 grub 設定 (GRUB#メイン設定ファイルの生成) を生成してください。\n\n"
    },
    {
      "title": "Ext3/4 から Btrfs への変換",
      "level": 3,
      "content": "インストール CD から起動し、次の手順で変換します:\n\n```\n# btrfs-convert /dev/partition\n```\n\nパーティションをマウントし、ファイルを確認して変換をテストしてください。 必ず /etc/fstab を変更してください (/etc/fstab の type' を btrfs に、 fs_passno をに変更すること) [最後のフィールド] を 0 に設定します(Btrfs は起動時にファイルシステムのチェックを行わないため)また、パーティションの UUID が変更されていることに注意してください、UUID を使うときは fstab もそれに合わせて更新してください。システムに chroot して、ブートローダのメニューリストを再構築します(既存の Linux からインストール を参照)ルートファイルシステムを変換する場合、chroot したまま mkinitcpio -p linux を実行して initramfs を再生成しないと、システムが正常に起動しません。\n\n問題がないことを確認したら、バックアップ ext2_saved サブボリュームを削除して変換を完了します。 これがないと ext3/4 に戻れないことに注意してください。\n\n```\n# btrfs subvolume delete /ext2_saved\n```\n\n最後に balance ファイルシステムでスペースを再利用します。\n\n以前にインストールされていたいくつかのアプリケーションは、btrfs に適合する必要があることを忘れないでください。\n\n"
    },
    {
      "title": "ファイルシステム破損のリカバリ",
      "level": 3,
      "content": "btrfs-check はマウントされているファイルシステムでは使えません。ライブ USB から起動しないで btrfs-check を使えるようにするには、初期 RAM ディスクに以下のように追加してください:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nBINARIES=(btrfs)\n```\n\n設定したら mkinitcpio を使って initramfs を再生成してください。\n\n起動に問題が発生したら、ユーティリティを使って修復することができます。\n\n詳しくは btrfs-check(8) を参照。\n\n"
    },
    {
      "title": "スナップショットから起動する",
      "level": 3,
      "content": "スナップショットをブートするためには、セクション サブボリュームをルートとしてマウントする で説明されているように、サブボリュームをルートパーティションとしてマウントする場合と同じ手順が適用されます。スナップショットはサブボリュームのようにマウントできます。\n\n- GRUB を使用している場合、grub-btrfs または grub-btrfs-gitAUR を使用して設定ファイルを再生成すると、自動的に btrfs スナップショットをブートメニューに取り込むことができます。\n- rEFInd を使用している場合は、refind-btrfs.service を 有効 にして開始後に、refind-btrfsAUR を使用してブートメニューに btrfs スナップショットを自動的に取り込むことができます。\n- Limine を使用する場合、limine-snapper-syncAUR をインストールすることで、limine-snapper-watcher.service を有効化した後、Snapper リストが変更されるたびにブートメニューにスナップショットエントリを自動生成できます。詳しくは Limine#Btrfs の Snapper スナップショットとの統合 を参照してください。\n\n"
    },
    {
      "title": "systemd-nspawn で Btrfs サブボリュームを使う",
      "level": 3,
      "content": "Systemd-nspawn#Btrfs のサブボリュームをコンテナのルートとして使うや Systemd-nspawn#コンテナの一時的な Btrfs スナップショットを使うを見てください。\n\n"
    },
    {
      "title": "アクセス時間のメタデータ更新を削減",
      "level": 3,
      "content": "Btrfs は書き込み時にコピーの性質を持つため、ファイルにアクセスするだけでメタデータのコピーと書き込みを開始します。アクセス時間の更新頻度を減らすと、この予期しないディスク使用がなくなり、パフォーマンスが向上する可能性があります。使用可能なオプションについては、 atime オプション を参照してください。\n\n"
    },
    {
      "title": "外付けドライブへの増分バックアップ",
      "level": 3,
      "content": "以下のパッケージは btrfs send と btrfs receive を使って、外部ドライブに増分バックアップを送信します。実装や機能、要件の違いを見るにはそれぞれのドキュメントを参照してください。\n\n- btrbk — Btrfs サブボリュームのスナップショットとリモートバックアップを作成するためのツール。\n\n- snap-sync — Snapper スナップショットを使用して、外付けドライブまたはリモートマシンにバックアップします。\n\n- snapsync — Snapper の同期ツール。\n\n以下のパッケージでは、Snapper のスナップショットを Btrfs 以外のファイルシステムへバックアップすることができます。\n\n- snapborg — Snapper スナップショットを borg バックアップと統合する borgmatic のようなツール。\n\n"
    },
    {
      "title": "自動スナップショット",
      "level": 3,
      "content": "Btrfs スナップショットの管理および自動作成には、Snapper、Timeshift、Yabsnap などのスナップショットマネージャーを使用できます。\n\n"
    },
    {
      "title": "自動通知",
      "level": 3,
      "content": "デスクトップ通知は、重大な Btrfs の問題に即座に気付くのに役立ち、通知がまったくない場合と比較して、より良い認識を提供します。\n\nbtrfs-desktop-notificationAUR 次のイベントにデスクトップ通知を提供します:\n\n- 読み取り専用スナップショットやシステムへのブート。\n- dmesg ログに表示される Btrfs の警告、エラー、致命的なメッセージ。\n\n詳細および設定については、https://gitlab.com/Zesko/btrfs-desktop-notification を参照してください。\n\n"
    },
    {
      "title": "トラブルシューティング",
      "level": 2,
      "content": "一般的なトラブルシューティングについては Btrfs Problem FAQ を見て下さい。\n\n"
    },
    {
      "title": "パーティションオフセット",
      "level": 4,
      "content": "オフセットの問題は、パーティションのあるディスクに core.img を埋め込もうとしたときに発生する可能性があります。つまり、GRUB の core.img をパーティションレスディスク (例: /dev/sdX) の Btrfs プールに直接埋め込んでも 大丈夫 です。\n\nGRUB は Btrfs パーティションを起動できますが、モジュールが他の ファイルシステム よりも大きくなる可能性があります。また、grub-install で作成した core.img ファイルは、MBR と最初のパーティションの間にあるドライブの最初の 63 セクタ (31.5KiB) に収まらないかもしれません。fdisk や gdisk のような最新のパーティションツールは、最初のパーティションをおよそ 1MiB または 2MiB オフセットすることでこの問題を回避しています。\n\n"
    },
    {
      "title": "root が見つからない",
      "level": 4,
      "content": "RAID セットアップから起動した時にエラー error no such device: root が表示される場合、/usr/share/grub/grub-mkconfig_lib を編集して echo \" search --no-floppy --fs-uuid --set=root ${hints} ${fs_uuid}\" からクォートを削除してください。grub の設定を再生成すればエラーを出さずに起動できるはずです。\n\n"
    },
    {
      "title": "マウントがタイムアウト",
      "level": 3,
      "content": "特に大きな RAID1 アレイでは、ブート中にマウントがタイムアウトして、次のようなジャーナルメッセージが表示されることがあります。\n\n```\nJan 25 18:05:12 host systemd[1]: storage.mount: Mounting timed out. Terminating.\nJan 25 18:05:46 host systemd[1]: storage.mount: Mount process exited, code=killed, status=15/TERM\nJan 25 18:05:46 host systemd[1]: storage.mount: Failed with result 'timeout'.\nJan 25 18:05:46 host systemd[1]: Failed to mount /storage.\nJan 25 18:05:46 host systemd[1]: Startup finished in 32.943s (firmware) + 3.097s (loader) + 7.247s (kernel)>\nJan 25 18:05:46 host kernel: BTRFS error (device sda): open_ctree failed\n```\n\nこの問題は、fstab のシステム固有のマウントオプション x-systemd.mount-timeout で長いタイムアウトを指定することで簡単に回避することが可能です。例:\n\n```\n/dev/sda                /storage    btrfs       rw,relatime,x-systemd.mount-timeout=5min  0 0\n```\n\n"
    },
    {
      "title": "BTRFS: open_ctree failed",
      "level": 3,
      "content": "2014年11月現在、mkinitcpio.conf で btrfs フックを使用してマルチデバイスの Btrfs を使っている場合に以下のエラーが発生するというバグが systemd か mkinitcpio のどちらかに存在します:\n\n```\nBTRFS: open_ctree failed\nmount: wrong fs type, bad option, bad superblock on /dev/sdb2, missing codepage or helper program, or other error\n\nIn some cases useful info is found in syslog - try dmesg|tail or so.\n\nYou are now being dropped into an emergency shell.\n```\n\n/etc/mkinitcpio.conf の HOOKS 行から btrfs を削除して代わりに MODULES 行に btrfs を追加することで解決します。修正を施したら mkinitcpio -p linux で initramfs を再生成して (必要ならプリセットを調整します) 再起動してください。\n\nデバイスが存在しない raid アレイをマウントしようとしたときも同じエラーが表示されます。その場合は /etc/fstab に degraded マウントオプションを追加してください。ルートパーティションがアレイ上にある場合、カーネルパラメータに rootflags=degraded を追加してください。\n\n2016年8月現在、このバグの回避策として考えられるのは、/etc/fstab で単一ドライブのみでアレイをマウントし、他のドライブは btrfs が自動的に発見して追記するようにすることです。UUID や LABEL のようなグループベースの識別子は、この不具合の原因になっているようです。例えば、'disk1' と 'disk2' からなる2デバイスの RAID1 アレイには UUID が割り当てられますが、UUID を使う代わりに /dev/mapper/disk1 のみを /etc/fstab で使用します。より詳しい説明は、以下の ブログ記事 を参照してください。\n\nまた、mkinitcpio.conf の udev フックを削除し、systemd フックに置き換えることも可能な対処法です。この場合、btrfs はHOOKSやMODULES 配列に not とする必要があります。\n\n詳細は フォーラムスレッド や FS#42884 を見て下さい。\n\n"
    },
    {
      "title": "btrfs check",
      "level": 3,
      "content": "btrfs check コマンドを使うことでアンマウントされた Btrfs ファイルシステムをチェックしたり修復することが可能です。ただし、この修復ツールはまだ開発中であり、特定のファイルシステムエラーは修復することができません。\n\n"
    },
    {
      "title": "絶え間ないドライブアクティビティ",
      "level": 3,
      "content": "カーネル バージョン 6.2 以降、discard=async mount(8) オプションがデフォルトで設定されています。これ 報告 により、廃棄キューがいっぱいになると、アイドル状態でも一部のドライブで一定のドライブアクティビティが発生し、処理されるよりも速くなります。これにより、特に NVMe ベースのドライブで電力使用量が増加する可能性があります。\n\n回避策の 1 つは、ドライブのアクティビティが停止するまで破棄 iops_limit を増やすことです。\n\nこれは、sysfs を使用して実現できます。例:\n\n```\n# echo 1000 > /sys/fs/btrfs/uuid/discard/iops_limit\n```\n\nここで、uuid は btrfs ファイルシステムの UUID です。1000 の制限は実験的に調整する必要があります。\n\n起動時にパラメータを設定するには、systemd-tmpfiles を使用できます。たとえば、次のファイルを作成します。\n\n```\n/etc/tmpfiles.d/btrfs-discard.conf\n```\n\n```\nw /sys/fs/btrfs/uuid/discard/iops_limit - - - - 1000\n```\n\nあるいは、fstab の nodiscard マウントオプションを使用してマウントし、代わりに 定期的な TRIM を使用して、非同期破棄を完全に無効にすることもできます。\n\n"
    },
    {
      "title": "Device total_bytes should be at most X but found Y",
      "level": 3,
      "content": "もしドライブが別のコンピュータから移動されたり、デバイスの順序が変更された場合で、報告されるサイズの差が非常に小さい(最大でも数メガバイト程度)場合、HPA (Host Protected Area) が有効になっている可能性があります。\n\nHPA が有効かどうかを確認するには、hdparm を使用します:\n\n```\n# hdparm -N DEVICE\n```\n\n出力には 2 つの数字が表示されます:可視のセクタ数と実際のセクタ数です。これらが異なる場合、HPA が有効になっていることを意味します。\n\nもしマザーボードがこれを強制的に設定し、ファームウェアにそれを無効にするオプションがない場合、唯一の選択肢は影響を受けたファイルシステムを縮小することです。これを行う最も簡単な方法は、元のコンピュータで、または HPA を適用しない任意のマシンで行うことです。\n\n"
    },
    {
      "title": "No space left on device",
      "level": 3,
      "content": "ブログ記事 Fixing Btrfs Filesystem Full Problems では、以下のチェック/手順を提案し、説明しています:\n\n1. 今すぐスペースを解放する(履歴スナップショットを削除)\n1. 本当にファイルシステムが満杯ですか? メタデータおよび/またはデータチャンクのバランスが崩れている(btrfs balance を実行)\n1. 本当にファイルシステムが満杯ですか? データチャンクのバランスが崩れている\n1. 本当にファイルシステムが満杯ですか? メタデータのバランスが崩れている\n1. ファイルシステムが満杯のため、バランスを実行できません(btrfs device add を使用して USB キーやループデバイスなどのデバイスを一時的に Btrfs ファイルシステムに追加してから、btrfs balance を実行)\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- 公式サイト Btrfs Documentation Archived Btrfs Wiki\n- パフォーマンス関連 Btrfs on raw disks? Varying leafsize and nodesize in Btrfs Btrfs support for efficient SSD operation (data blocks alignment) Is Btrfs optimized for SSDs? Lzo vs. zLib\n- その他 Funtoo:BTRFS Fun Avi Miller presenting Btrfs at SCALE 10x, January 2012. Summary of Chris Mason's talk from LFCS 2012 Btrfs: stop providing a bmap operation to avoid swapfile corruptions 2009-01-21 Doing Fast Incremental Backups With Btrfs Send and Receive\n\n- Btrfs Documentation\n- Archived Btrfs Wiki\n\n- Btrfs on raw disks?\n- Varying leafsize and nodesize in Btrfs\n- Btrfs support for efficient SSD operation (data blocks alignment)\n- Is Btrfs optimized for SSDs?\n- Lzo vs. zLib\n\n- Funtoo:BTRFS Fun\n- Avi Miller presenting Btrfs at SCALE 10x, January 2012.\n- Summary of Chris Mason's talk from LFCS 2012\n- Btrfs: stop providing a bmap operation to avoid swapfile corruptions 2009-01-21\n- Doing Fast Incremental Backups With Btrfs Send and Receive\n\n"
    }
  ]
}