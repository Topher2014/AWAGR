{
  "title": "Improve Boot Performance (日本語)",
  "url": "https://wiki.archlinux.org/title/Improve_Boot_Performance_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- パフォーマンスの向上\n- サイレントブート\n- デーモン\n- e4rat\n- Kexec\n\nシステムのブートパフォーマンスを向上させることで、起動待機時間を短縮し、特定のシステムファイルとスクリプトが相互にどう作用しているのかをより良く知ることができます。この記事では Arch Linux システムのブートパフォーマンスを向上させる方法を集めています。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 ブートプロセスを解析する 1.1 systemd-analyze を使う 1.2 bootchart2 を使う\n- 2 起動時に busybox の代わりに systemd を使用する\n- 3 カスタムカーネルをコンパイルする\n- 4 Initramfs\n- 5 サービスの適切な起動方法を選択する\n- 6 スタッガード・スピンアップ\n- 7 ファイルシステムのマウント\n- 8 起動中の出力を減らす\n- 9 ブートローダーの変更\n- 10 カーネルパラメータ\n- 11 RAM にサスペンド\n\n- 1.1 systemd-analyze を使う\n- 1.2 bootchart2 を使う\n\n"
    },
    {
      "title": "systemd-analyze を使う",
      "level": 3,
      "content": "systemd は systemd-analyze という名前のツールを提供しており、これを使えばブートプロセスにかかっている時間の詳細を表示することができます。また、svg のグラフを出力してユニットの依存関係を把握することができます。どのユニットファイルが起動時間を遅くしているのかが一目でわかり、それに応じてシステムを最適化することが可能です。\n\n起動時、カーネルスペースとユーザースペースでどれくらい時間がかかっているか見たい場合、以下のコマンドを実行してください:\n\n```\n$ systemd-analyze\n```\n\n起動するのにかかった時間でユニットファイルを並べて一覧するには:\n\n```\n$ systemd-analyze blame\n```\n\n特定のユニットがきちんと動かないために全体の起動時間が長くなっている場合があります。起動チェインの中でどのユニットが起動を遅くしているのか確認するには、次を実行してください:\n\n```\n$ systemd-analyze critical-chain\n```\n\nBootchart のように、ブートプロセスを視覚的に表す SVG ファイルを生成することもできます:\n\n```\n$ systemd-analyze plot > plot.svg\n```\n\n詳細は systemd-analyze(1) を見て下さい。\n\n"
    },
    {
      "title": "bootchart2 を使う",
      "level": 3,
      "content": "Bootchart2 を使うことでも、ブートシーケンスを視覚化することができます。\n\n"
    },
    {
      "title": "起動時に busybox の代わりに systemd を使用する",
      "level": 2,
      "content": "デフォルトでは、Mkinitcpio の設定は initramfs の構築に base と udev フックを使用します。これらを systemd に置き換えることで、より高速なブートタイムを実現することができます。\n\n詳しくは mkinitcpio#通常のフック を見て下さい。fsck フックを置き換える場合は Fsck#ブート時のチェック も見て下さい。\n\n"
    },
    {
      "title": "カスタムカーネルをコンパイルする",
      "level": 2,
      "content": "カスタムカーネルをコンパイルすれば起動時間やメモリの使用量を減らすことができます。ただし最近は64ビットのアーキテクチャが一般的になっており、Linux カーネルはモジュール設計を取っているため、期待していたよりも効果がないかもしれません。詳しくはカーネル#コンパイルを見てください。\n\n公式のカーネルのモジュールはZSTD_CLEVEL=19で圧縮されています。しかし、SSDではZSTD_CLEVEL=1の方がいいかも知れません。\n\nArch_ブートプロセス#initramfs無しで起動できるようにする為に、/のストレージとファイルシステムのモジュールは組み込みにして下さい。\n\n"
    },
    {
      "title": "Initramfs",
      "level": 2,
      "content": "最も早い方法は、可能ならinitramfs無しで起動する事です。\n\nカスタムカーネルのコンパイルと同じように、initramfs もダイエットさせることができます。mkinitcpio の autodetect フックを使うのが一番簡単です。Boosterはmkinitcpioやdracutより小さなinitramfsを生成します。詳しくは initramfs の最小化やBooster#モジュールを除外するを見てください。\n\nハードウェア (プロセッサとストレージの速度) にもよりますが、デフォルトの zstd 圧縮オプションの代わりに lz4 を使うと、起動時の解凍速度が速くなり、ディスクから読み込む initramfs のサイズが若干大きくなりますが、通常相殺されるため速くなることがあります。mkinitcpio#COMPRESSION を見て下さい。\n\n"
    },
    {
      "title": "サービスの適切な起動方法を選択する",
      "level": 2,
      "content": "systemd の中心的な機能のひとつに D-Bus とソケットのアクティベーションがあります。この機能はほとんどの場合、サービスが最初にアクセスされたときにだけ起動され、一般的に良いことなので好まれるはずです（例えば、起動時に cups.service を有効にすることは通常デスクトップでは有用ではありません、なぜなら cups.socket だけ有効にすると、実際に印刷するときだけサービスを起動することになるからです。）\n\nしかし、あるサービス (upower など) が起動時に常に開始されることがわかっている場合、できるだけ早く開始することで全体の起動時間を短縮できる可能性があります。これは(サービスファイルがそのように設定されている場合、ほとんどの場合)、upower.service を 有効化 することで実現できます。\n\nこれにより、systemd はソケットや D-Bus のアクティベーションで競合することなく、できるだけ早く UPower を起動します。\n\n"
    },
    {
      "title": "スタッガード・スピンアップ",
      "level": 2,
      "content": "一部のハードウェアにはスタッガード・スピンアップ (Staggered spin-up, SSS) が実装されています。SSS が実装されている HDD の場合、OS は ATA インターフェースを連続的に調べるようになり、段階を追ってドライブをスピンアップすることができるため最大電気使用量が減少します。ただしスタッガード・スピンアップは起動時間を遅くし、ほとんどのコンシューマ機では電源を入れたときに瞬時にドライブがスピンアップするので全く利益がありません。SSS が使われているかどうか確認するには:\n\n```\n$ dmesg | grep SSS\n```\n\n使われていない場合は、起動時に何も出力されないはずです。\n\n無効にするには、カーネルパラメータに libahci.ignore_sss=1 を追加してください。\n\n"
    },
    {
      "title": "ファイルシステムのマウント",
      "level": 2,
      "content": "mkinitcpio の fsck フックによって、カーネルラインの ro を rw に変更することで、時間のかかる root パーティションの再マウントを避けることができます。マウントオプションはカーネルラインで rootflags=rw,他のマウントオプション と指定することで設定できます。/etc/fstab からルートパーティションのエントリは必ず削除してください、そうしないと systemd-remount-fs.service が fstab の設定を適用し続けます。もしくは、ユニットをマスクしてもよいです。\n\nbtrfs を root ファイルシステムで使っている場合、他のファイルシステムのように起動毎に毎回 fsck をする必要はありません。この場合、mkinitcpio の fsck フックは削除してかまいません。systemd-fsck-root.service をマスクしたり、カーネルコマンドラインで fsck.mode=skip を使うことで root ファイルシステムの fsck をしないようにできます。mkinitcpio の fsck フックがなくても、systemd は systemd-fsck@.service を使って適切なファイルシステムを全て fsck します。\n\nまた、/etc/fstab から API ファイルシステムを削除することもできます。systemd 自身がそれらをマウントするからです (pacman -Ql systemd | grep '\\.mount$' でそのリストを見れます)。sysvinit から /tmp エントリを持ち越しているユーザーには聞き慣れないかもしれませんが、上のコマンドによって systemd がそれらを管理していることに気づくはずです。従って、エントリは削除しても問題ありません。\n\n/home や EFI システムパーティション などの他のファイルシステムはカスタムマウントユニットでマウントできます。マウントオプションに noauto,x-systemd.automount を追加するとパーティションへの全てのアクセスをバッファし、最初にアクセスしたときに fsck とマウントを行うようになり、ブートプロセスで fsck とマウントをするファイルシステムの数を減らせます。\n\n- 上記の設定を使うと /home ファイルシステムが autofs タイプになり、デフォルトで mlocate によって無視されるようになります。システムによっては /home の自動化による高速化は数秒の効果しかない場合もあります。\n- btrfs サブボリュームにシステムをインストールしていて (ルートディレクトリ / 自体がサブボリュームの場合)、/home を分割して使っている場合、/home サブボリュームの作成をしないように設定したほうが良いでしょう。home.conf の tmpfile をマスクしてください: ln -s /dev/null /etc/tmpfiles.d/home.conf。\n\n"
    },
    {
      "title": "起動中の出力を減らす",
      "level": 2,
      "content": "システムによっては (特に SSD を使っている場合)、TTY のパフォーマンスが遅いことがボトルネックになっている場合があり、出力を減らすことで起動が速くなることがあります。サイレントブートの記事を見てください。\n\n"
    },
    {
      "title": "ブートローダーの変更",
      "level": 2,
      "content": "ブートローダーを (例: systemd-boot などのよりシンプルなブートローダーに) 変更することで、起動時間を秒単位で減らせるかもしれません。\n\nあなたのセットアップで可能なのであれば、EFISTUB だけを使えば更に起動時間を短縮できます。\n\n"
    },
    {
      "title": "カーネルパラメータ",
      "level": 2,
      "content": "幾つかのカーネルパラメータはブートパフォーマンスを向上させます。\n\nsystemd-gpt-auto-generatorが不要ならば、systemd.gpt_auto=noで0.2~3秒短縮できます。 systemd-gpt-auto-generatorはinitramfs無しで、/がBtrfsの場合は動きません[1]。\n\ncryptomgr.notestsは暗号化セルフテストを無効化しますが、効果は僅かかも知れません。\n\n"
    },
    {
      "title": "RAM にサスペンド",
      "level": 2,
      "content": "起動時間を短縮する一番よい方法は起動しないことです。サスペンドを使用することを検討してください。\n\n"
    }
  ]
}