{
  "title": "Zsh (日本語)",
  "url": "https://wiki.archlinux.org/title/Zsh_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Zsh は対話式シェルとしてもスクリプト言語のインタプリタとしても使えるパワフルなシェルです。POSIX sh と互換性がありながら (デフォルトではありません、emulate sh を実行した時だけです)、タブ補完の改善や グロビングなどの利点があります。\n\nZsh FAQ には他にも Zsh をあなたのシェルとして使うべき理由が列挙されています。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール 1.1 初期設定 1.2 Zsh をデフォルトのシェルにする\n- 2 スタートアップ/シャットダウン ファイル\n- 3 Zsh の設定 3.1 シンプルな .zshrc 3.2 $PATH の設定 3.3 コマンド補完 3.3.1 カスタムの補完 3.4 キーバインド 3.4.1 履歴検索 3.4.2 修飾キー Shift、Alt、Ctrl、Meta 3.5 プロンプト 3.5.1 プロンプトテーマ 3.5.1.1 プロンプトテーマを手動でインストールする 3.5.1.2 テーマごとにファイルを分けずにプロンプトテーマを追加する 3.5.2 プロンプトのカスタマイズ 3.5.2.1 色 3.5.2.2 例 3.6 サンプルの .zshrc ファイル\n- 4 ヒントとテクニック 4.1 ログイン時に X を自動起動 4.2 プログラムが異常終了した後、端末の設定を復元する 4.2.1 ttyctl コマンド 4.2.2 エスケープシーケンスで端末をリセットする 4.3 最近のディレクトリを記憶させる 4.3.1 Dirstack 4.3.2 cdr 4.3.3 zoxide 4.4 ヘルプコマンド 4.5 継続的に rehash する 4.5.1 必要なときにだけ rehash する 4.5.2 SIGUSR1 を使って必要なときにだけ rehash する 4.6 ncurses アプリケーションにキーをバインド 4.7 ファイルマネージャー風のキーバインド 4.8 xterm のタイトル 4.8.1 ターミナルエミュレータのタブのタイトル 4.9 シェル環境の検出 4.10 /dev/tcp と等価な ztcp 4.11 コマンドラインに文字があるときにもシェルを終了するショートカット 4.12 pacman -F \"command not found\" ハンドラー 4.13 キーバインドを使ってバックバッファをクリアする\n- 5 サードパーティ拡張 5.1 設定フレームワーク 5.2 プラグインマネージャー 5.3 Fish のようなシンタックスハイライトとオートサジェスト 5.4 pkgfile の \"command not found\" ハンドラー\n- 6 参照\n\n- 1.1 初期設定\n- 1.2 Zsh をデフォルトのシェルにする\n\n- 3.1 シンプルな .zshrc\n- 3.2 $PATH の設定\n- 3.3 コマンド補完 3.3.1 カスタムの補完\n- 3.4 キーバインド 3.4.1 履歴検索 3.4.2 修飾キー Shift、Alt、Ctrl、Meta\n- 3.5 プロンプト 3.5.1 プロンプトテーマ 3.5.1.1 プロンプトテーマを手動でインストールする 3.5.1.2 テーマごとにファイルを分けずにプロンプトテーマを追加する 3.5.2 プロンプトのカスタマイズ 3.5.2.1 色 3.5.2.2 例\n- 3.6 サンプルの .zshrc ファイル\n\n- 3.3.1 カスタムの補完\n\n- 3.4.1 履歴検索\n- 3.4.2 修飾キー Shift、Alt、Ctrl、Meta\n\n- 3.5.1 プロンプトテーマ 3.5.1.1 プロンプトテーマを手動でインストールする 3.5.1.2 テーマごとにファイルを分けずにプロンプトテーマを追加する\n- 3.5.2 プロンプトのカスタマイズ 3.5.2.1 色 3.5.2.2 例\n\n- 3.5.1.1 プロンプトテーマを手動でインストールする\n- 3.5.1.2 テーマごとにファイルを分けずにプロンプトテーマを追加する\n\n- 3.5.2.1 色\n- 3.5.2.2 例\n\n- 4.1 ログイン時に X を自動起動\n- 4.2 プログラムが異常終了した後、端末の設定を復元する 4.2.1 ttyctl コマンド 4.2.2 エスケープシーケンスで端末をリセットする\n- 4.3 最近のディレクトリを記憶させる 4.3.1 Dirstack 4.3.2 cdr 4.3.3 zoxide\n- 4.4 ヘルプコマンド\n- 4.5 継続的に rehash する 4.5.1 必要なときにだけ rehash する 4.5.2 SIGUSR1 を使って必要なときにだけ rehash する\n- 4.6 ncurses アプリケーションにキーをバインド\n- 4.7 ファイルマネージャー風のキーバインド\n- 4.8 xterm のタイトル 4.8.1 ターミナルエミュレータのタブのタイトル\n- 4.9 シェル環境の検出\n- 4.10 /dev/tcp と等価な ztcp\n- 4.11 コマンドラインに文字があるときにもシェルを終了するショートカット\n- 4.12 pacman -F \"command not found\" ハンドラー\n- 4.13 キーバインドを使ってバックバッファをクリアする\n\n- 4.2.1 ttyctl コマンド\n- 4.2.2 エスケープシーケンスで端末をリセットする\n\n- 4.3.1 Dirstack\n- 4.3.2 cdr\n- 4.3.3 zoxide\n\n- 4.5.1 必要なときにだけ rehash する\n- 4.5.2 SIGUSR1 を使って必要なときにだけ rehash する\n\n- 4.8.1 ターミナルエミュレータのタブのタイトル\n\n- 5.1 設定フレームワーク\n- 5.2 プラグインマネージャー\n- 5.3 Fish のようなシンタックスハイライトとオートサジェスト\n- 5.4 pkgfile の \"command not found\" ハンドラー\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "インストールをする前に現在使っているシェルが何なのか知っておくとよいでしょう:\n\n```\n$ echo $SHELL\n```\n\nzsh パッケージをインストールしてください。追加の補完定義を使いたい場合は、zsh-completions パッケージもインストールします。\n\n"
    },
    {
      "title": "初期設定",
      "level": 3,
      "content": "ターミナルで次のコマンドを実行して Zsh が正しくインストールされたか確認してください:\n\n```\n$ zsh\n```\n\n基本的な設定を説明する zsh-newuser-install が表示されるはずです。これをスキップしたい場合、q を押して下さい。表示されない場合は、次のコマンドで手動で呼び出すことができます:\n\n```\n$ autoload -Uz zsh-newuser-install\n$ zsh-newuser-install -f\n```\n\n"
    },
    {
      "title": "Zsh をデフォルトのシェルにする",
      "level": 3,
      "content": "シェルを /usr/bin/zsh に変更してください。コマンドラインシェル#デフォルトシェルを変更する を見てください。\n\n"
    },
    {
      "title": "スタートアップ/シャットダウン ファイル",
      "level": 2,
      "content": "- $ZDOTDIR が設定されていない場合は、代わりに $HOME が使用されます。\n- RCS オプションが以下のファイルのどれかで unset された場合、そのファイル以降、設定ファイルは読み込まれません。\n- GLOBAL_RCS オプションが以下のファイルのどれかで unset された場合、そのファイル以降、グローバルな設定ファイル (/etc/zsh/*) は読み込まれません。\n\nデフォルトで、Zsh は起動時に以下のファイルを以下の順番で実行します (存在しているもののみ実行されます)。\n\n- /etc/zsh/zshenv すべてのユーザに対して環境変数を設定するために使用されます。このファイルには、出力を行うコマンドや、シェルが TTY に接続されていることを期待するコマンドを含めるべきではありません。このファイルが存在する場合、このファイルは 常に 読み込まれます。この挙動を上書きすることはできません。\n- $ZDOTDIR/.zshenv ユーザの環境変数を設定するために使用されます。このファイルには、出力を行うコマンドや、シェルが TTY に接続されていることを期待するコマンドを含めるべきではありません。このファイルが存在する場合、このファイルは 常に 読み込まれます。\n- /etc/zsh/zprofile すべてのユーザに対して起動時にコマンドを実行するために使用されます。ログインシェルとして起動した場合に、このファイルは読み込まれます。Arch Linux においては、このファイルには、/etc/profile を source する 1行がデフォルトで含まれていることを留意しておいてください。その行を削除したい場合は以下の警告を先に読んでください! /etc/profile POSIX sh 互換のシェルはすべて、このファイルをログイン時に source する必要があります。このファイルは $PATH や他の環境変数を設定し、ログイン時にはアプリケーション固有 (/etc/profile.d/*.sh) の設定を行います。\n- $ZDOTDIR/.zprofile 起動時にユーザのコマンドを実行するために使用されます。ログインシェルとして起動した場合に、このファイルは読み込まれます。通常、グラフィカルセッションを自動起動し、セッションの環境変数を設定するために使用されます。\n- /etc/zsh/zshrc すべてのユーザに対して、インタラクティブシェルを設定したりコマンドを実行したりするために使用されます。インタラクティブシェルとして起動した場合に、このファイルは読み込まれます。\n- $ZDOTDIR/.zshrc ユーザのインタラクティブシェルを設定したり、コマンドを実行したりするために使用されます。インタラクティブシェルとして起動した場合に、このファイルは読み込まれます。\n- /etc/zsh/zlogin すべてのユーザに対して初期化処理の最後にコマンドを実行するために使用されます。ログインシェルとして起動した場合に、このファイルは読み込まれます。\n- $ZDOTDIR/.zlogin 初期化処理の最後にユーザのコマンドを実行するために使用されます。ログインシェルとして起動した場合に、このファイルは読み込まれます。通常、コマンドラインユーティリティを自動起動するために使用されます。グラフィカルセッションを自動起動するために使用するべきではありません (この時点では、インタラクティブシェルにおいてのみ意味を持つ設定がセッションに含まれているかもしれないからです)。\n- $ZDOTDIR/.zlogout ログインシェル が 終了 する時にコマンドを実行するために使用されます。\n- /etc/zsh/zlogout ログインシェル が 終了 する時にすべてのユーザに対してコマンドを実行するために使用されます。\n\n- /etc/profile POSIX sh 互換のシェルはすべて、このファイルをログイン時に source する必要があります。このファイルは $PATH や他の環境変数を設定し、ログイン時にはアプリケーション固有 (/etc/profile.d/*.sh) の設定を行います。\n\nthe graphic representation を参照してください。\n\n"
    },
    {
      "title": "Zsh の設定",
      "level": 2,
      "content": "Zsh は何も設定しなくても使うことができますが、ほとんどのユーザが使いたいと思うようには設定されていないことはほぼ確実です。ただし、Zsh で利用できるカスタマイズの量は膨大で、Zsh を設定するのは大変で時間を浪費する経験となるでしょう。自動的に設定するには #サードパーティ拡張 を見てください。\n\n"
    },
    {
      "title": "シンプルな .zshrc",
      "level": 3,
      "content": "以下は設定ファイルのサンプルです。デフォルトのオプションの適切なセットと共に、Zsh でカスタマイズ可能な方法の例を提供します。この設定を使うには、.zshrc という名前のファイルに保存してください。\n\nこれはシンプルな .zshrc です:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz compinit promptinit\ncompinit\npromptinit\n\n# デフォルトのプロンプトを walters テーマに設定する\nprompt walters\n```\n\nプロンプトテーマシステムに関する詳細は #プロンプトテーマ を見てください。\n\n"
    },
    {
      "title": "$PATH の設定",
      "level": 3,
      "content": "Zsh は PATH 変数を path 配列に結びつけます。これにより、path 配列を変更するだけで PATH 変数を操作することができます。詳細は A User's Guide to the Z-Shell を見てください。\n\n~/.local/bin/ を PATH に追加するには:\n\n```\n~/.zshenv\n```\n\n```\ntypeset -U path PATH\npath=(~/.local/bin $path)\nexport PATH\n```\n\n"
    },
    {
      "title": "コマンド補完",
      "level": 3,
      "content": "Zsh の一番魅力的な機能はおそらく先進的な自動補完機能でしょう。少なくとも .zshrc で自動補完を有効化してください。自動補完を有効にするには、以下を ~/.zshrc に追加してください:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz compinit\ncompinit\n```\n\n上記の設定には ssh/scp/sftp ホスト名の補完が含まれていますが、この機能を動作させるためにはユーザは ssh のホスト名ハッシュ化 (つまり、ssh クライアントの設定の HashKnownHosts オプション) を有効化してはなりません。\n\n矢印キーを使うインターフェイスで自動補完を行うには、以下を追加してください:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion:*' menu select\n```\n\nメニューをアクティブにするには、Tab を2回押してください。\n\n特権が与えられたコマンドで特権環境の自動補完を有効化するには (例えば、sudo で始まるコマンドを補完する場合、補完スクリプトは sudo の補完もしようと試みます)、以下を追加してください:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion::complete:*' gain-privileges 1\n```\n\n"
    },
    {
      "title": "カスタムの補完",
      "level": 4,
      "content": "カスタムの補完を自分で作ることもできます。詳細は zshcompsys(1) man ページを参照してください。\n\n公式のドキュメントは難解かもしれません。簡単なスタートポイントとして、よりシンプルな zsh-completion-howto チュートリアルもあります。\n\n"
    },
    {
      "title": "キーバインド",
      "level": 3,
      "content": "Zsh は readline を使用しません。代わりに、よりパワフルな独自の Zsh Line Editor (ZLE) を使用します。ZLE は /etc/inputrc と ~/.inputrc のどちらも読み込みません。ZLE 設定のイントロダクションは A closer look at the zsh line editor and creating custom widgets を読んでください。\n\nZLE には Emacs モードと vi モードがあります。VISUAL か EDITOR のどちらか一方の環境変数に vi という文字列が含まれている場合、vi モードが使用されます。それ以外の場合、Emacs モードをデフォルトで使用します。bindkey -e (Emacs モード) や bindkey -v (vi モード) でモードを明示的に設定することもできます。デフォルトでは、vi モードでの Esc キーを押した時の遅延は 0.4 秒ですが、export KEYTIMEOUT=5 でより短く (0.05 秒) することができます。\n\nキーバインドは、キープレスに対応するエスケープシーケンスを ZLE ウィジェットにマッピングすることにより割り当てます。利用可能なウィジェットは zshzle(1) § STANDARD WIDGETS と zshcontrib(1) § ZLE FUNCTIONS にリストアップされています (アクションとデフォルトのキーバインドの説明付き)。\n\nZsh でキーバインドを設定する方法として推奨されるのは、terminfo(5) の文字列ケーパビリティを使用することです。例えば [1][2]:\n\n```\n~/.zshrc\n```\n\n```\n# zkbd と互換性のあるハッシュテーブルを作成し、\n# 他のキーをこのハッシュテーブルに追加する (man 5 terminfo を参照)\ntypeset -g -A key\n\nkey[Home]=\"${terminfo[khome]}\"\nkey[End]=\"${terminfo[kend]}\"\nkey[Insert]=\"${terminfo[kich1]}\"\nkey[Backspace]=\"${terminfo[kbs]}\"\nkey[Delete]=\"${terminfo[kdch1]}\"\nkey[Up]=\"${terminfo[kcuu1]}\"\nkey[Down]=\"${terminfo[kcud1]}\"\nkey[Left]=\"${terminfo[kcub1]}\"\nkey[Right]=\"${terminfo[kcuf1]}\"\nkey[PageUp]=\"${terminfo[kpp]}\"\nkey[PageDown]=\"${terminfo[knp]}\"\nkey[Shift-Tab]=\"${terminfo[kcbt]}\"\n\n# 適宜キーを設定する\n[[ -n \"${key[Home]}\"      ]] && bindkey -- \"${key[Home]}\"       beginning-of-line\n[[ -n \"${key[End]}\"       ]] && bindkey -- \"${key[End]}\"        end-of-line\n[[ -n \"${key[Insert]}\"    ]] && bindkey -- \"${key[Insert]}\"     overwrite-mode\n[[ -n \"${key[Backspace]}\" ]] && bindkey -- \"${key[Backspace]}\"  backward-delete-char\n[[ -n \"${key[Delete]}\"    ]] && bindkey -- \"${key[Delete]}\"     delete-char\n[[ -n \"${key[Up]}\"        ]] && bindkey -- \"${key[Up]}\"         up-line-or-history\n[[ -n \"${key[Down]}\"      ]] && bindkey -- \"${key[Down]}\"       down-line-or-history\n[[ -n \"${key[Left]}\"      ]] && bindkey -- \"${key[Left]}\"       backward-char\n[[ -n \"${key[Right]}\"     ]] && bindkey -- \"${key[Right]}\"      forward-char\n[[ -n \"${key[PageUp]}\"    ]] && bindkey -- \"${key[PageUp]}\"     beginning-of-buffer-or-history\n[[ -n \"${key[PageDown]}\"  ]] && bindkey -- \"${key[PageDown]}\"   end-of-buffer-or-history\n[[ -n \"${key[Shift-Tab]}\" ]] && bindkey -- \"${key[Shift-Tab]}\"  reverse-menu-complete\n\n# 最後に、zle がアクティブのときにターミナルがアプリケーションモードになるようにする。\n# そのときにだけ、$terminfo の値が有効になる。\nif (( ${+terminfo[smkx]} && ${+terminfo[rmkx]} )); then\n\tautoload -Uz add-zle-hook-widget\n\tfunction zle_application_mode_start { echoti smkx }\n\tfunction zle_application_mode_stop { echoti rmkx }\n\tadd-zle-hook-widget -Uz zle-line-init zle_application_mode_start\n\tadd-zle-hook-widget -Uz zle-line-finish zle_application_mode_stop\nfi\n```\n\n"
    },
    {
      "title": "履歴検索",
      "level": 4,
      "content": "以下の手順を使うには、key 配列を設定し、ZLE がアプリケーションモードとなるようにする必要があります。#キーバインド を見てください。\n\n履歴検索を有効化するには、以下を .zshrc ファイルに追加してください:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz up-line-or-beginning-search down-line-or-beginning-search\nzle -N up-line-or-beginning-search\nzle -N down-line-or-beginning-search\n\n[[ -n \"${key[Up]}\"   ]] && bindkey -- \"${key[Up]}\"   up-line-or-beginning-search\n[[ -n \"${key[Down]}\" ]] && bindkey -- \"${key[Down]}\" down-line-or-beginning-search\n```\n\nこれにより、Up か Down を押したときに、現在の行のカーソル位置までにマッチする過去のコマンドだけが表示されます。\n\n"
    },
    {
      "title": "修飾キー Shift、Alt、Ctrl、Meta",
      "level": 4,
      "content": "xterm 互換端末は user_caps(5) からの拡張キー定義を使うことができます。キー定義は、Shift、Alt、Ctrl、Meta と、Up、Down、Left、Right、PageUp、PageDown、Home、End、Del のどれかを組み合わせたものです。修飾キーとキーの組み合わせに推奨される名前の一覧については、zkbd のソース を参照してください。\n\nたとえば、 Ctrl+Left で前の単語の先頭に移動し、Ctrl+Right で次の単語の先頭に移動させるには:\n\n```\n~/.zshrc\n```\n\n```\nkey[Control-Left]=\"${terminfo[kLFT5]}\"\nkey[Control-Right]=\"${terminfo[kRIT5]}\"\n\n[[ -n \"${key[Control-Left]}\"  ]] && bindkey -- \"${key[Control-Left]}\"  backward-word\n[[ -n \"${key[Control-Right]}\" ]] && bindkey -- \"${key[Control-Right]}\" forward-word\n```\n\n"
    },
    {
      "title": "プロンプト",
      "level": 3,
      "content": "Zsh は2つの選択肢を提供します: プロンプトテーマを使用するか、テーマに不満がある (または、テーマの使いやすさを自分で拡張したい) ユーザはカスタムのプロンプトを構築できます。\n\n"
    },
    {
      "title": "プロンプトテーマ",
      "level": 4,
      "content": "プロンプトテーマは、Zsh で色付きのプロンプトを設定するための手っ取り早く簡単な方法です。プロンプトテーマや、プロンプトテーマを自分で記述する方法については zshcontrib(1) § PROMPT THEMES を参照してください。\n\nテーマを使用するには、プロンプトテーマシステムが自動でロードされるように .zshrc で設定されていることを確認してください。自動ロードを行うには、以下の行を追加します:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz promptinit\npromptinit\n```\n\n以下のコマンドで、利用可能なプロンプトテーマをリストアップできます:\n\n```\n$ prompt -l\n```\n\n例えば、walters テーマを使うには:\n\n```\n$ prompt walters\n```\n\n利用可能なテーマをすべてプレビューするには:\n\n```\n$ prompt -p\n```\n\n外部の設定管理ツールを使わずに、テーマを手動でインストールすることもできます。ローカルにインストールする場合、まずフォルダを作成し、そのフォルダのパスを fpath 配列に追加してください。例えば:\n\n```\n$ mkdir ~/.zprompts\n$ fpath=(\"$HOME/.zprompts\" \"$fpath[@]\")\n```\n\n次に、このフォルダ内にテーマファイルのシンボリックリンクを作成します:\n\n```\n$ ln -s mytheme.zsh ~/.zprompts/prompt_mytheme_setup\n```\n\n代わりにテーマをグローバルにインストールする場合は、次のようにします:\n\n```\n# ln -s mytheme.zsh /usr/share/zsh/functions/Prompts/prompt_mytheme_setup\n```\n\nこれで、次のコマンドを使ってアクティブ化できるはずです:\n\n```\n$ prompt mytheme\n```\n\nすべてが機能する場合は、.zshrc を適宜編集することができます。\n\nプロンプトテーマは、テーマのファイルを使って追加するだけでなく、ある1つのファイル (例えば .zshrc) 内からテーマを追加することもできます。例えば:\n\n```\n~/.zshrc\n```\n\n```\n# promptinit をロードする\nautoload -Uz promptinit && promptinit\n\n# テーマを定義する\nprompt_mytheme_setup() {\n  PS1=\"%~%# \"\n}\n\n# promptsys にそのテーマを追加する\nprompt_themes+=( mytheme )\n\n# テーマをロードする\nprompt mytheme\n```\n\n"
    },
    {
      "title": "プロンプトのカスタマイズ",
      "level": 4,
      "content": "すべてのシェルで一般的な主要な左側のプロンプト PS1 (PROMPT、prompt) に加えて、Zsh では右側のプロンプト RPS1 (RPROMPT) もサポートしています。これら2つの変数は、好きな値にカスタムできます。\n\n他の特殊な目的のためのプロンプト (PS2 (PROMPT2)、PS3 (PROMPT3)、PS4 (PROMPT4)、RPS1 (RPROMPT)、RPS2 (RPROMPT2)、SPROMPT など) は zshparam(1) § PARAMETERS USED BY THE SHELL で説明されています。\n\nすべてのプロンプトは、プロンプトエスケープでカスタマイズできます (例えば、%n はユーザ名になります)。利用可能なプロンプトエスケープは zshmisc(1) § EXPANSION OF PROMPT SEQUENCES でリストアップされています。\n\nZsh は、Bash とは異なる方法で色を設定します。ANSI エスケープシーケンスや、terminfo(5) のターミナルケーパビリティを多用する必要はありません。Zsh は、前景色、背景色、他の視覚エフェクトを設定するための便利なプロンプトエスケープを提供します。エスケープのリストや説明は zshmisc(1) § Visual effects を見てください。\n\n色を指定する方法は3つあります: 10進数の整数、8つの広くサポートされている色の名前、# のあとに16進数の RGB トリプレット。詳細は zshzle(1) § CHARACTER HIGHLIGHTING 内の fg=colour の説明を見てください。\n\nほとんどのターミナルは以下の色を名前でサポートしています:\n\nTable content:\n名前 | 番号\nblack | 0\nred | 1\ngreen | 2\nyellow | 3\nblue | 4\nmagenta | 5\ncyan | 6\nwhite | 7\n\nxterm 256 color と互換性のあるターミナルエミュレータの色番号 0 から 255 は、xterm-256color チャートで見られます。\n\nTERM 環境変数が正しく設定されていれば、ターミナルのサポートする色の最大数は、terminfo(5) データベースから echoti colors を使って確認することができます。24-bit カラーの場合は、print $COLORTERM を使って COLORTERM 環境変数も確認してください。24bit か truecolor を返した場合、たとえ terminfo がより少ない数値を表示したとしても、あなたのターミナルは 16777216 (224) 色をサポートしています。\n\n- 0 から 15 の色は、ターミナルエミュレータやカラースキームごとに異なる場合があります。\n- 多くのターミナルエミュレータは、太文字を明るい色で表示します。\n\n- プロンプトのエスケープは print -P \"prompt escapes\" コマンドでテストできます。例えば、$ print -P '%B%F{red}co%F{green}lo%F{blue}rs%f%b'\n- 24 ビットカラーを使用する場合、24 ビットカラーをサポートしていないターミナルでは zsh/nearcolor モジュールをロードする必要があるかもしれません。例えば: [[ \"$COLORTERM\" == (24bit|truecolor) || \"${terminfo[colors]}\" -eq '16777216' ]] || zmodload zsh/nearcolor zsh/nearcolor モジュールに関する詳細は zshmodules(1) § THE ZSH/NEARCOLOR MODULE を見てください。\n\n```\n$ print -P '%B%F{red}co%F{green}lo%F{blue}rs%f%b'\n```\n\n```\n[[ \"$COLORTERM\" == (24bit|truecolor) || \"${terminfo[colors]}\" -eq '16777216' ]] || zmodload zsh/nearcolor\n```\n\nこれは、シンプルな色無しのプロンプトの例です:\n\n```\nPROMPT='%n@%m %~ %# '\n```\n\n以下のように出力されます:\n\nこれは、色付きの左右両方のプロンプトの例です:\n\n```\nPROMPT='%F{green}%n%f@%F{magenta}%m%f %F{blue}%B%~%b%f %# '\nRPROMPT='[%F{yellow}%?%f]'\n```\n\n以下のように出力されます:\n\n16-255 の範囲の色は、欲しい色に割り当てた 0 から 255 までの数値を使うことで使用できます。また、24 ビットトゥルーカラーは16進数のカラーコードを使うことで使用できます:\n\n```\nPROMPT='%F{2}%n%f@%F{5}%m%f %F{4}%B%~%b%f %# '\nRPROMPT='[%F{3}%?%f]'\n```\n\n```\nPROMPT='%F{#c0c0c0}%n%f@%F{#008000}%m%f %F{#800080}%B%~%b%f %# '\nRPROMPT='[%F{#0000ff}%?%f]'\n```\n\n"
    },
    {
      "title": "サンプルの .zshrc ファイル",
      "level": 3,
      "content": "- 月次 ISO リリース (デフォルトで Zsh を使用します) と同じセットアップにするには、grml-zsh-config をインストールしてください。これには、grml の多くの調整と高度な最適化が含まれています。\n- https://github.com/MrElendig/dotfiles-alice/blob/master/.zshrc - ベーシックなセットアップ。動的なプロンプトとウィンドウのタイトル/hardinfo。\n- https://github.com/slashbeast/conf-mgmt/blob/master/roles/home_files/files/DOTzshrc - 複数の機能を持つ zshrc。コメントをチェックしてください。特出すべき機能: ユーザーが電源オフ・再起動・ハイバネートをすることを尋ねる関数、プロンプトの GIT サポート (vcsinfo を使わずに実現)、メニューの付いたタブ補完、実行中のコマンドをウィンドウのタイトルバーに表示など。\n\nさらに見たい場合は ドットファイル#ユーザーリポジトリ を見てください。\n\n"
    },
    {
      "title": "ログイン時に X を自動起動",
      "level": 3,
      "content": "xinit#ログイン時に X を自動起動を参照してください。\n\n"
    },
    {
      "title": "プログラムが異常終了した後、端末の設定を復元する",
      "level": 3,
      "content": "多くのプログラムはターミナルの状態を変更し、異常終了したときにターミナルの設定を復元しないことがあります (例えば、クラッシュしたときや、SIGINT を受け取ったとき)。\n\n通常、これは reset(1) を実行することで解決できます:\n\n```\n$ reset\n```\n\n以下のセクションでは、手動でターミナルをリセットする手間を省く方法について説明します。\n\n"
    },
    {
      "title": "ttyctl コマンド",
      "level": 4,
      "content": "ttyctl コマンドを使ってターミナルを \"freeze/unfreeze\" することができます。起動時にインタラクティブシェルを freeze させるには、以下を使用してください:\n\n```\n~/.zshrc\n```\n\n```\nttyctl -f\n```\n\n"
    },
    {
      "title": "エスケープシーケンスで端末をリセットする",
      "level": 4,
      "content": "代替の線画文字セットは、ttyctl が防ぐことができない方法でターミナルを台無しにしてしまうことがあります。\n\nシンプルな解決法は、ターミナルをリセットするエスケープシーケンスを precmd フック関数から出力することです。そうすれば、プロンプトが描画される前に毎回、そのエスケープシーケンスが出力されます。例えば、エスケープシーケンス \\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[0;0r\\e8 を使うと:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nfunction reset_broken_terminal () {\n\tprintf '%b' '\\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[0;0r\\e8'\n}\n\nadd-zsh-hook -Uz precmd reset_broken_terminal\n```\n\nうまく行くか試すには、以下を実行してください:\n\n```\n$ print '\\e(0\\e)B'\n```\n\n"
    },
    {
      "title": "Dirstack",
      "level": 4,
      "content": "Zsh は、最後に訪れたフォルダのうち DIRSTACKSIZE 個を記憶するように設定できます。この機能を活用すれば、それらのフォルダへ非常に素早く cd することができます。設定ファイルにいくつかの行を追加する必要があります:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nDIRSTACKFILE=\"${XDG_CACHE_HOME:-$HOME/.cache}/zsh/dirs\"\nif [[ -f \"$DIRSTACKFILE\" ]] && (( ${#dirstack} == 0 )); then\n\tdirstack=(\"${(@f)\"$(< \"$DIRSTACKFILE\")\"}\")\n\t[[ -d \"${dirstack[1]}\" ]] && cd -- \"${dirstack[1]}\"\nfi\nchpwd_dirstack() {\n\tprint -l -- \"$PWD\" \"${(u)dirstack[@]}\" > \"$DIRSTACKFILE\"\n}\nadd-zsh-hook -Uz chpwd chpwd_dirstack\n\nDIRSTACKSIZE='20'\n\nsetopt AUTO_PUSHD PUSHD_SILENT PUSHD_TO_HOME\n\n## 重複するエントリを削除する\nsetopt PUSHD_IGNORE_DUPS\n\n## +/- 演算子をもとに戻す。\nsetopt PUSHD_MINUS\n```\n\nこれで、以下のコマンドを使えば dirstack を出力できます。\n\n```\n$ dirs -v\n```\n\n訪れたフォルダに戻るには cd -<NUM> を使ってください。ダッシュ記号の後でオートコンプリートを使ってください。オートコンプリートメニューを使う場合に便利です。\n\n- 2つ以上の zsh セッションを開いていて cd を試みた場合、両方のセッションが同じファイルに書き込むことで競合が発生するため、これは機能しません。\n- no such file or directory エラーが発生しないように、$HOME/.cache/zsh ディレクトリを作成して下さい。\n\n"
    },
    {
      "title": "cdr",
      "level": 4,
      "content": "cdr により、自動的に管理されるリストを使って現在の作業ディレクトリから以前の作業ディレクトリに移動することができます。cdr は、現在のセッションでセッション間および (デフォルトで) ターミナルエミュレータ間で管理されるファイルにすべてのエントリを保存します。\n\nセットアップの手順は zshcontrib(1) § REMEMBERING RECENT DIRECTORIES を見てください。\n\n"
    },
    {
      "title": "zoxide",
      "level": 4,
      "content": "zoxide は、よりスマートな cd コマンドで、数個のキーストロークで好きな場所に移動できます。zoxide は、頻繁に使用されるディレクトリを記憶し、スコアリングメカニズムを使って、あなたが行きたい場所を推測します。\n\n"
    },
    {
      "title": "ヘルプコマンド",
      "level": 3,
      "content": "Bash とは違い、Zsh は組み込みの help コマンドを有効化しておらず、代わりに run-help を提供しています。デフォルトでは、run-help は man のエイリアスとなっています。コマンドの前に run-help と付けることで実行できますし、または今タイプしたコマンドに対してキーボードショートカット Alt+h か Esc h を入力することでも実行できます。\n\nデフォルトでは man のエイリアスとなっているので、外部コマンドに対してしか動作しません。シェルの組み込みコマンドやシェルの他の機能でも動作するようにするには、run-help 関数を使う必要があります。run-help や補助関数については zshcontrib(1) を見てください。\n\nまず、run-help 関数をロードし、その次に既存の run-help エイリアスを削除してください。help は run-help へのエイリアスにすることもできます。例えば、以下を zshrc に追加してください:\n\n```\nautoload -Uz run-help\n(( ${+aliases[run-help]} )) && unalias run-help\nalias help=run-help\n```\n\n補助関数は別で有効化する必要があります:\n\n```\nautoload -Uz run-help-git run-help-ip run-help-openssl run-help-p4 run-help-sudo run-help-svk run-help-svn\n```\n\n例えば、run-help git commit コマンドは、git(1) ではなく git-commit(1) の man ページを開きます。\n\n"
    },
    {
      "title": "継続的に rehash する",
      "level": 3,
      "content": "通常、compinit は $PATH 内の新しい実行ファイルを自動的には見つけません。例えば、新しいパッケージをインストールした後、/usr/bin/ 内に追加された新しいファイルは即座に、または自動的には補完に含まれないでしょう。なので、そのような新しい実行ファイルを補完に含めるには、以下を実行してください:\n\n```\n$ rehash\n```\n\nこの 'rehash' は、自動的に実行するよう設定できます。[3] 以下を zshrc に追加するだけです:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion:*' rehash true\n```\n\n"
    },
    {
      "title": "必要なときにだけ rehash する",
      "level": 4,
      "content": "しかし、pacman フックを使って、自動的に rehash を要求するように設定できます。こうすれば、先のセクションのように継続的に rehash してパフォーマンスが劣化してしまうようなことは起こりません。これを有効化するには、/etc/pacman.d/hooks ディレクトリと /var/cache/zsh ディレクトリを作成し、フックファイルを作成してください:\n\n```\n/etc/pacman.d/hooks/zsh.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nOperation = Remove\nType = Path\nTarget = usr/bin/*\n[Action]\nDepends = zsh\nWhen = PostTransaction\nExec = /usr/bin/install -Dm644 /dev/null /var/cache/zsh/pacman\n```\n\nこれは、/var/cache/zsh/pacman ファイルの変更日時を、最後にパッケージをインストール/アップグレード/アンインストールした時間に合わせます。次に、zsh のコマンドキャッシュが古くなったときにコマンドキャッシュを rehash するように設定します。以下を ~/.zshrc に追加してください:\n\n```\n~/.zshrc\n```\n\n```\nzshcache_time=\"$(date +%s%N)\"\n\nautoload -Uz add-zsh-hook\n\nrehash_precmd() {\n  if [[ -a /var/cache/zsh/pacman ]]; then\n    local paccache_time=\"$(date -r /var/cache/zsh/pacman +%s%N)\"\n    if (( zshcache_time < paccache_time )); then\n      rehash\n      zshcache_time=\"$paccache_time\"\n    fi\n  fi\n}\n\nadd-zsh-hook -Uz precmd rehash_precmd\n```\n\n/var/cache/zsh/pacman が更新されるまえに precmd フックがトリガーされた場合、新しいプロンプトが始まるまで補完が効かないかもしれません。そういうときは、空のコマンドを実行すれば良いはずです (例えば、enter を押す)。\n\n"
    },
    {
      "title": "SIGUSR1 を使って必要なときにだけ rehash する",
      "level": 4,
      "content": "フックファイルは以下のようになります。\n\n```\n/etc/pacman.d/hooks/zsh-rehash.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nOperation = Remove\nType = Path\nTarget = usr/bin/*\n\n[Action]\nDepends = zsh\nDepends = procps-ng\nWhen = PostTransaction\nExec = /usr/bin/pkill zsh --signal=USR1\n```\n\n```\n~/.zshrc\n```\n\n```\nTRAPUSR1() { rehash }\n```\n\nこの 関数トラップ は、リストトラップ trap 'rehash' USR1 に置き換えることもできます。トラップの種類の違いについては zshmisc(1) § Trap Functions を見てください。\n\nこの方法は、すべての zsh インスタンスを即座に rehash します。なので、precmd をトリガーするためにエンターキーを押す必要がありません。\n\n"
    },
    {
      "title": "ncurses アプリケーションにキーをバインド",
      "level": 3,
      "content": "ncurses アプリケーションをキーストロークにバインドしますが、対話を受け入れません。これを動作させるには BUFFER 変数を使用します。次の例では、Alt+\\ を使用して ncmpcpp を開くことができます。\n\n```\n~/.zshrc\n```\n\n```\nncmpcppShow() {\n  BUFFER=\"ncmpcpp\"\n  zle accept-line\n}\nzle -N ncmpcppShow\nbindkey '^[\\' ncmpcppShow\n```\n\nアプリケーションを呼び出す前に、行に入力した内容をすべて保持する別の方法\n\n```\n~/.zshrc\n```\n\n```\nncmpcppShow() {\n  ncmpcpp <$TTY\n  zle redisplay\n}\nzle -N ncmpcppShow\nbindkey '^[\\' ncmpcppShow\n```\n\n"
    },
    {
      "title": "ファイルマネージャー風のキーバインド",
      "level": 3,
      "content": "グラフィックファイルマネージャで使われているようなキーバインドが便利かもしれません。1つ目はディレクトリ履歴 (Alt+Left) に戻り、2つ目はユーザを親ディレクトリ (Alt+Up) に移動させます。また、ディレクトリの内容も表示されます。\n\n```\n~/.zshrc\n```\n\n```\ncdUndoKey() {\n  popd\n  zle       reset-prompt\n  print\n  ls\n  zle       reset-prompt\n}\n\ncdParentKey() {\n  pushd ..\n  zle      reset-prompt\n  print\n  ls\n  zle       reset-prompt\n}\n\nzle -N                 cdParentKey\nzle -N                 cdUndoKey\nbindkey '^[[1;3A'      cdParentKey\nbindkey '^[[1;3D'      cdUndoKey\n```\n\n"
    },
    {
      "title": "xterm のタイトル",
      "level": 3,
      "content": "あなたのターミナルエミュレータがサポートしていれば、Zsh からターミナルのタイトルを設定できます。これにより、タイトルを動的に変更し、シェルの状態に関する状態 (例えば、ユーザ名とカレントディレクトリや現在実行中のコマンド) を表示できます。\n\nxterm のタイトルは xterm の制御シーケンスオペレーティングシステムコマンドである \\e]2;\\a か \\e]2;\\e\\\\ で設定します。例えば:\n\n```\n$ print -n '\\e]2;My xterm title\\a'\n```\n\nこのコマンドは、タイトルを以下に設定します:\n\n```\nMy xterm title\n```\n\nタイトルを動的にするシンプルな方法は、precmd フック関数と preexec フック関数でタイトルを設定することです。利用可能なフック関数リストと説明は zshmisc(1) § Hook Functions を見てください。\n\nprint -P を使えば、さらに Zsh のプロンプトエスケープも使用できます。\n\n- タイトルの表示は複数のコマンドに分けることができます。ただし、コマンドは連続していなければなりません。\n- GNU Screen は、xterm のタイトルを hardstatus (%h) に送信します。Screen の文字列エスケープを使いたい場合 (例えば、色を付けたい場合など)、エスケープシーケンス \\e_\\e\\\\ を使って hardstatus を設定する必要があります。文字列エスケープを \\e]2;\\a 内で使用した場合、ターミナルエミュレータは、Screen の文字列エスケープを解釈できないため、タイトルが文字化けしてしまいます。\n\n- 変数を表示するときに print の -P オプションは使用しないでください。変数がプロンプトエスケープとしてパースされてしまいます。\n- 変数を表示するときには、パラメータ展開フラグ q を使用してください。変数がエスケープシーケンスとしてパースされないようにするためです。\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nfunction xterm_title_precmd () {\n\tprint -Pn -- '\\e]2;%n@%m %~\\a'\n\t[[ \"$TERM\" == 'screen'* ]] && print -Pn -- '\\e_\\005{2}%n\\005{-}@\\005{5}%m\\005{-} \\005{+b 4}%~\\005{-}\\e\\\\'\n}\n\nfunction xterm_title_preexec () {\n\tprint -Pn -- '\\e]2;%n@%m %~ %# ' && print -n -- \"${(q)1}\\a\"\n\t[[ \"$TERM\" == 'screen'* ]] && { print -Pn -- '\\e_\\005{2}%n\\005{-}@\\005{5}%m\\005{-} \\005{+b 4}%~\\005{-} %# ' && print -n -- \"${(q)1}\\e\\\\\"; }\n}\n\nif [[ \"$TERM\" == (Eterm*|alacritty*|aterm*|foot*|gnome*|konsole*|kterm*|putty*|rxvt*|screen*|wezterm*|tmux*|xterm*) ]]; then\n\tadd-zsh-hook -Uz precmd xterm_title_precmd\n\tadd-zsh-hook -Uz preexec xterm_title_preexec\nfi\n```\n\n"
    },
    {
      "title": "ターミナルエミュレータのタブのタイトル",
      "level": 4,
      "content": "一部のターミナルエミュレータとマルチプレクサは、タブのタイトルの設定をサポートしています。そのためのエスケープシーケンスはターミナルによります:\n\nTable content:\nターミナル | エスケープシーケンス | 説明\nGNU Screen | \\ek\\e\\\\ | Screen のウィンドウタイトル (%t)。\nKonsole | \\e]30;\\a | Konsole のタブタイトル。\n\n"
    },
    {
      "title": "シェル環境の検出",
      "level": 3,
      "content": "シェル環境を検出するテストは、shell environment detection のリポジトリを見てください。これには、ログイン/インタラクティブシェル、Xorg セッション、TTY、SSH セッションの検出も含まれています。\n\n"
    },
    {
      "title": "/dev/tcp と等価な ztcp",
      "level": 3,
      "content": "zsh/net/tcp モジュールを使用してください:\n\n```\n$ zmodload zsh/net/tcp\n```\n\nこれで、TCP 接続を確立できます:\n\n```\n$ ztcp example.com 80\n```\n\n詳細は zshmodules(1) § THE_ZSH/NET/TCP_MODULE と zshtcpsys(1) で見られます。\n\n"
    },
    {
      "title": "コマンドラインに文字があるときにもシェルを終了するショートカット",
      "level": 3,
      "content": "デフォルトでは、コマンドラインに文字が入力されている場合、Ctrl+d はシェルを終了しません。これを修正するには:\n\n```\n.zshrc\n```\n\n```\nexit_zsh() { exit }\nzle -N exit_zsh\nbindkey '^D' exit_zsh\n```\n\n"
    },
    {
      "title": "pacman -F \"command not found\" ハンドラー",
      "level": 3,
      "content": "pacman には、あるファイルを含むパッケージを検索する機能があります。以下の command-not-found ハンドラは、不明なコマンドが実行されたときに、pacman を直接使用してマッチするパッケージを検索します。\n\n```\n~/.zshrc\n```\n\n```\n...\nfunction command_not_found_handler {\n    local purple='\\e[1;35m' bright='\\e[0;1m' green='\\e[1;32m' reset='\\e[0m'\n    printf 'zsh: command not found: %s\\n' \"$1\"\n    local entries=(\n        ${(f)\"$(/usr/bin/pacman -F --machinereadable -- \"/usr/bin/$1\")\"}\n    )\n    if (( ${#entries[@]} ))\n    then\n        printf \"${bright}$1${reset} may be found in the following packages:\\n\"\n        local pkg\n        for entry in \"${entries[@]}\"\n        do\n            # (repo package version file)\n            local fields=(\n                ${(0)entry}\n            )\n            if [[ \"$pkg\" != \"${fields[2]}\" ]]\n            then\n                printf \"${purple}%s/${bright}%s ${green}%s${reset}\\n\" \"${fields[1]}\" \"${fields[2]}\" \"${fields[3]}\"\n            fi\n            printf '    /%s\\n' \"${fields[4]}\"\n            pkg=\"${fields[2]}\"\n        done\n    fi\n    return 127\n}\n...\n```\n\npkgfile を使う代替としては、#pkgfile の \"command not found\" ハンドラー を見てください。\n\n"
    },
    {
      "title": "キーバインドを使ってバックバッファをクリアする",
      "level": 3,
      "content": "デフォルトでは、画面をクリアするキーバインドは、ほとんどのターミナルエミュレータでバックバッファ (上にスクロールしないと見えない部分) をクリアしません。この問題の解決策とｈしては:\n\n```\n~/.zshrc\n```\n\n```\n...\nfunction clear-screen-and-scrollback() {\n    printf '\\x1Bc'\n    zle clear-screen\n}\n\nzle -N clear-screen-and-scrollback\nbindkey '^L' clear-screen-and-scrollback\n...\n```\n\n"
    },
    {
      "title": "設定フレームワーク",
      "level": 3,
      "content": "- oh-my-posh — Oh My Posh は、関数か変数でプロンプト文字列を変更することのできる任意のシェルのためのカスタムプロンプトエンジンです。\n\n- oh-my-zsh — Zsh の設定を管理するためのコミュニティ運営の人気なフレームワークです。たくさんの便利な関数、ヘルパー、プラグイン、テーマをバンドルしています。\n\n- Prezto — Zsh 用の設定フレームワークです。モジュールが同梱されており、適切なデフォルト、エイリアス、関数、オートコンプリート、プロンプトテーマでコマンドラインインターフェイス環境を充実させることができます。\n\n- ZIM — 驚異的なスピードとモジュール式拡張機能の付いた設定フレームワークです。Zim はとても簡単にカスタマイズでき、スピードと機能性を犠牲にせず、モジュールと機能の豊富なセットが付属しています。\n\n"
    },
    {
      "title": "プラグインマネージャー",
      "level": 3,
      "content": "- Antidote — レガシーな Antibody プラグインマネージャの完全な Zsh 実装です。\n\n- zinit (旧 \"zplugin\") — 柔軟な Zsh プラグインマネージャ。クリーンな fpath、レポート、補完管理、ターボモードが付いています。復活しました\n\n- zi (旧 \"zplugin\") — zplugin の代替フォークです。zinit のようにオリジナルのプロジェクトの保持やメンテナンスではなく、オリジナルのプロジェクトを拡張することを目的としています。\n\n- sheldon — 高速で設定可能なシェルプラグインマネージャです。Rust で書かれています。[4]\n\n- Antigen — Zsh 用のプラグインマネージャ。oh-my-zsh と vundle にインスパイアされました。放棄されています\n\n- zgen — Zsh 用の軽量でシンプルなプラグインマネージャ。放棄されています\n\n- zplug — Zsh 用の次世代プラグインマネージャ。放棄されています\n\n"
    },
    {
      "title": "Fish のようなシンタックスハイライトとオートサジェスト",
      "level": 3,
      "content": "Fish には強力なシェルシンタックスハイライトとオートサジェスト機能があります。これらの機能を zsh で使うには、zsh-syntax-highlighting と zsh-autosuggestions をインストールし、提供されたスクリプトの一方または両方を zshrc から source してください:\n\n```\n~/.zshrc\n```\n\n```\nsource /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\nsource /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh\n```\n\n"
    },
    {
      "title": "pkgfile の \"command not found\" ハンドラー",
      "level": 3,
      "content": "pkgfile には、command_not_found_handler 関数を提供する Zsh スクリプトファイルが含まれています。この関数は、認識されないコマンドが入力されたときに、pkgfile のデータベースを自動的に検索します。\n\nこの関数を有効化するには、そのスクリプトを source する必要があります。例えば:\n\n```\n~/.zshrc\n```\n\n```\nsource /usr/share/doc/pkgfile/command-not-found.zsh\n```\n\npacman のネイティブな機能を使う代替は、#pacman -F \"command not found\" ハンドラー を見てください。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Wikipedia:ja:Z Shell\n- Z Shell イントロダクション\n- ZSH ユーザガイド\n- Z Shell マニュアル (このページとは形式が異なります)\n- Zsh FAQ\n- zsh-lovers(1) (zsh-lovers パッケージとして利用可能)\n- Gentoo: Zsh/Guide\n- Bash2Zsh Reference Card\n\n"
    }
  ]
}