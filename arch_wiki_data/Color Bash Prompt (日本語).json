{
  "title": "Color Bash Prompt (日本語)",
  "url": "https://wiki.archlinux.org/title/Color_Bash_Prompt_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Bash\n- 環境変数\n- Git#Git プロンプト\n\nBash には複数のプロンプトが存在しカスタマイズすることで効率を高めたりセンスを良くしたりオタクっぽくできます。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 プロンプト\n- 2 テクニック 2.1 Bash のエスケープシーケンス 2.2 Terminfo のエスケープシーケンス 2.3 ANSI のエスケープシーケンス 2.4 コマンドの埋め込み 2.5 PROMPT_COMMAND 2.6 コマンドの入力完了と実行開始の間でエスケープシーケンス 2.7 root プロンプトのカスタマイズ\n- 3 サンプル 3.1 色 3.2 一般的な機能 3.3 終了コードの視覚化 3.4 カーソルの位置 3.4.1 テキストを右寄せ 3.4.2 任意の位置 3.5 ターミナルのウィンドウタイトルのカスタマイズ\n- 4 参照\n\n- 2.1 Bash のエスケープシーケンス\n- 2.2 Terminfo のエスケープシーケンス\n- 2.3 ANSI のエスケープシーケンス\n- 2.4 コマンドの埋め込み\n- 2.5 PROMPT_COMMAND\n- 2.6 コマンドの入力完了と実行開始の間でエスケープシーケンス\n- 2.7 root プロンプトのカスタマイズ\n\n- 3.1 色\n- 3.2 一般的な機能\n- 3.3 終了コードの視覚化\n- 3.4 カーソルの位置 3.4.1 テキストを右寄せ 3.4.2 任意の位置\n- 3.5 ターミナルのウィンドウタイトルのカスタマイズ\n\n- 3.4.1 テキストを右寄せ\n- 3.4.2 任意の位置\n\n"
    },
    {
      "title": "プロンプト",
      "level": 2,
      "content": "Bash にはカスタマイズ可能な5つのプロンプト文字列が存在します:\n\n- PS0 は、コマンドの入力が完了した後で、そのコマンドの出力が開始される前に表示されます。(つまり、コマンドの実行開始直前。)\n- PS1 は、コマンドの入力が開始される前に表示されるプライマリプロンプトです。なので、ほとんどの人がカスタマイズするのはこのプロンプト文字列です。\n- PS2 は、コマンドにさらに多くの入力 (例えば複数行のコマンド) が必要とされる際に表示されるセカンダリプロンプトです。\n- PS3 は滅多に使われません。これは、Bash の select 組み込みコマンドによってインタラクティブメニューが表示されるときに使われるプロンプト文字列です。他のプロンプトと違って、このプロンプトでは Bash のエスケープシーケンスを展開することはできません。通常、このプロンプトは .bashrc ではなく、select が使用されているスクリプト内でカスタマイズします。\n- PS4 も滅多に使われません。Bash スクリプトをデバッグする際に間接参照のレベルを表示するために使われます。最初の文字が繰り返されて、レベルの深さを表します。\n\n全てのプロンプトは、それぞれに対応する変数を設定することでカスタマイズできます (大抵は ~/.bashrc で設定します)。例えば:\n\n```\nPS2='> '\n```\n\n"
    },
    {
      "title": "テクニック",
      "level": 2,
      "content": "プロンプトを普通の文字列に設定することもできますが、様々なテクニックを駆使することでプロンプトをもっとダイナミックに使いやすくすることができます。\n\n"
    },
    {
      "title": "Bash のエスケープシーケンス",
      "level": 3,
      "content": "プロンプトの文字列を表示するとき、Bash はバックスラッシュでエスケープされた特定の文字列を探し、特殊な文字列に展開します。例えば \\u は現在のユーザー名になり \\A は現在時刻になります。PS1 を '\\A \\u $ ' と設定すると 17:35 username $ といった具合に表示されます。\n\nエスケープシーケンスの完全なリストは、bash(1) § PROMPTING man ページか Bash リファレンスマニュアルを参照してください。\n\n"
    },
    {
      "title": "Terminfo のエスケープシーケンス",
      "level": 3,
      "content": "Bash によって認識されるエスケープシーケンスの他に、大抵のターミナルは、文字を表示するのではなくターミナル自体に何らかの効果を与える特殊なエスケープシーケンスを認識します。例えば、表示される文字列の色を変更したり、カーソルを任意の場所に移動したり、画面を消去したりすることができます。これらのエスケープシーケンスは、どういうわけか読みにくい記述法を使用しており、ターミナルによって違うこともあります。なので、terminfo データベースでドキュメント化されています。ターミナルによってサポートされている機能を確認するには、次のコマンドを実行してください:\n\n```\n$ infocmp\n```\n\n機能の名前 (= よりも前の部分) は terminfo(5) の man ページを読めば何なのか説明を見ることができます。例えば setaf は出力されるテキストの前景色を設定します。特定の機能のエスケープシーケンスを出力するには、tput コマンドを使います。例:\n\n```\n$ tput setaf 2\n```\n\n上記のコマンドは前景色を緑に設定するエスケープシーケンスを表示します。\n\nBash のコマンド置換と文字列補間を使用すれば、これらの機能を実際にプロンプトに組み込むことができます。例えば:\n\n```\nGREEN=\"\\[$(tput setaf 2)\\]\"\nRESET=\"\\[$(tput sgr0)\\]\"\n\nPS1=\"${GREEN}my prompt${RESET}> \"\n```\n\n"
    },
    {
      "title": "ANSI のエスケープシーケンス",
      "level": 3,
      "content": "残念がら、ANSI のエスケープシーケンスはターミナルの terminfo データベースには載っていないことがあります。特に256色のサポートなど新しい機能のエスケープシーケンスはデータベースに入っていないことがよくあります。tput を使えない場合、エスケープシーケンスを手動で入力する必要があります。\n\nエスケープシーケンスの例は Wikipedia:ANSI escape code を見てください。全てのエスケープシーケンスはリテラルのエスケープ文字から始まり、Bash のエスケープシーケンス \\e を使って入力できます。例えば \\e[48;5;209m は背景を桃色 (ターミナルが256色をサポートしている場合) に設定し、\\e[2;2H はカーソルを画面左上に移動します。\n\nBash のエスケープシーケンスがサポートされていない場合 (PS3 など)、Bash の printf 組み込みコマンドを使うことでリテラルのエスケープ文字を使用できます:\n\n```\nESC=$(printf \"\\e\")\nPEACH=\"$ESC[48;5;209m\"\n```\n\n"
    },
    {
      "title": "コマンドの埋め込み",
      "level": 3,
      "content": "何らかのコマンドの出力をプロンプトに追加したい場合、コマンド置換を使えばいいと思うかもしれません。例えば、空きメモリ容量をプロンプトに追加しようと以下のように設定した場合:\n\n```\nPS1=\"$(awk '/MemFree/{print $2}' /proc/meminfo) prompt > \"\n```\n\n```\n53718 prompt >\n53718 prompt >\n53718 prompt >\n```\n\nしかし、上記の設定は上手くいきません。表示されるメモリの容量はいつも同じになってしまいます。原因はコマンドの実行が一回しか行われず、PS1 が一度設定されると、二度と変わらないためです。$ をエスケープするかシングルクォートの中で定義するようにすることで、プロンプトが実際に表示されるときにコマンド置換がされるようになります:\n\n```\nPS1=\"\\$(awk '/MemFree/{print \\$2}' /proc/meminfo) prompt > \"\n# あるいは\nPS1='$(awk \"/MemFree/{print \\$2}\" /proc/meminfo) prompt > '\n```\n\nコマンドが長い場合は、関数を定義することで PS1 をコンパクトにできます:\n\n```\nfree_mem()\n{\n    awk '/MemFree/{print $2}' /proc/meminfo\n}\n\nPS1='$(free_mem) prompt > '\n```\n\n"
    },
    {
      "title": "PROMPT_COMMAND",
      "level": 3,
      "content": "PROMPT_COMMAND 変数または配列が設定されている場合、PS1 が表示される直前に評価されます。これは、非常に強力な使い方ができます。例えば、条件式に応じて PS1 を再定義したり、コマンドを実行するたびに Bash の履歴に何らかの操作を加えたりできます。\n\n"
    },
    {
      "title": "コマンドの入力完了と実行開始の間でエスケープシーケンス",
      "level": 3,
      "content": "PS1 の末尾でテキストのプロパティをリセットせずにそのままにしておくことで、Bash に入力したテキストにもそのプロパティを反映させることができます。例えば、PS1 の最後に tput blink を追加すると、入力されたコマンドが点滅します。ただし、エンターを押してもテキストのプロパティはリセットされないため、実行されたコマンドの出力にも影響が及びます。\n\nPS0 にエスケープシーケンスを設定することで、コマンドを入力した後、かつそのコマンドが実行される前にそのエスケープシーケンスを挿入することができます。あるいは、コマンドが実行される直前に送信される Bash の DEBUG シグナルを捕捉することで、同じことをすることができます:\n\n```\n$ trap 'tput sgr0' DEBUG\n```\n\n"
    },
    {
      "title": "root プロンプトのカスタマイズ",
      "level": 3,
      "content": "root で実行していることを知らせるために、root プロンプトはわかりやすいようにカスタマイズすると良いでしょう (赤字の点滅など)。root のホームディレクトリ (/root) を使うことで通常の Bash プロンプトのカスタマイズと同じようにカスタマイズできます。最初にスケルトンファイルの /etc/skel/.bash_profile と /etc/skel/.bashrc を /root にコピーしてから /root/.bashrc を編集してください。\n\n"
    },
    {
      "title": "色",
      "level": 3,
      "content": "ターミナルでサポートされている色の完全な範囲は、tput を単純なループで回すことで確認できます (背景色ではなく前景色で表示するには setab を setaf に置き換えてください)。\n\n```\nfor C in {0..255}; do\n    tput setab $C\n    echo -n \"$C \"\ndone\ntput sgr0\necho\n```\n\n上記のコマンドが動かない場合 (そして、TERM に適切な値を設定しても問題が解決できない場合)、別のエスケープシーケンスでテストすることもできます:\n\n```\n# 標準色\nfor C in {40..47}; do\n    echo -en \"\\e[${C}m$C \"\ndone\n# 高輝度色\nfor C in {100..107}; do\n    echo -en \"\\e[${C}m$C \"\ndone\n# 256色\nfor C in {16..255}; do\n    echo -en \"\\e[48;5;${C}m$C \"\ndone\necho -e \"\\e(B\\e[m\"\n```\n\nエスケープシーケンスを背景色から前景色に変更したい場合は、標準色の範囲を 30..37 に、高輝度色の範囲を 90..97 にし、256色ではエスケープシーケンスの 48 の部分を 38 に変更してください。\n\n"
    },
    {
      "title": "一般的な機能",
      "level": 3,
      "content": "以下の terminfo の機能はプロンプトをカスタマイズするときに使うことができ多くのターミナルがサポートしています。#1 や #2 は実際に使うときに数字に置き換えてください。\n\nTable content:\n機能 | エスケープシーケンス | 説明\nテキストの属性\nblink | \\e[5m | テキストの点滅をオン\nbold | \\e[1m | 太字テキストをオン\ndim | \\e[2m | 淡色テキストをオン\nrev | \\e[7m | 逆転表示をオン (前景色と背景色が入れ替わります)\nsitm | \\e[3m | 斜字テキストをオン\nritm | \\e[23m | 斜字テキストをオフ\nsmso | \\e[7m | テキストのハイライトをオン\nrmso | \\e[27m | テキストのハイライトをオフ\nsmul | \\e[4m | テキストの下線をオン\nrmul | \\e[24m | テキストの下線をオフ\nsetab #1 | \\e[4#1m | 背景色を #1 (0-7) に設定\nsetaf #1 | \\e[3#1m | テキスト色を #1 (0-7) に設定\nsgr0 | \\e(B\\e[m | テキストの属性をリセット\nカーソルの移動\nsc | \\e7 | カーソルの位置を保存\nrc | \\e8 | 保存したカーソルの位置に戻す\nclear | \\e[H\\e[2J | 画面をクリアし、カーソルを左上に移動\ncuu #1 | \\e[#1A | #1 行分だけカーソルを上に移動\ncud #1 | \\e[#1B | #1 行分だけカーソルを下に移動\ncuf #1 | \\e[#1C | #1 列分だけカーソルを右に移動\ncub #1 | \\e[#1D | #1 列分だけカーソルを左に移動\nhome | \\e[H | カーソルを左上に移動\nhpa #1 | \\e[#1G | カーソルを #1 列目に移動\nvpa #1 | \\e[#1d | カーソルを #1 行目の1列目に移動\ncup #1 #2 | \\e[#1;#2H | カーソルを #1 行目の #2 列目に移動\n文字列の削除\ndch #1 | \\e#1P | (バックスペースと同じように) 文字を #1 個削除\ndl #1 | \\e#1M | 行を #1 個削除\nech #1 | \\e#1X | 文字を #1 個消去 (カーソルの移動は伴わない)\ned | \\eE[J | 画面下端まで消去\nel | \\e[K | 行末まで消去\nel1 | \\e[1K | 行頭まで消去\n\n"
    },
    {
      "title": "終了コードの視覚化",
      "level": 3,
      "content": "コマンドの埋め込みと同じ方法で $? などの特殊な Bash 変数の補完を遅延させることができます。以下のプロンプトは前に実行したコマンドの終了コードを表示します:\n\n```\nPS1=\"\\$? > \"\n# または\nPS1='$? > '\n```\n\n条件式と関数を使うことでさらにわかりやすくすることができます:\n\n```\nexitstatus()\n{\n    if [[ $? == 0 ]]; then\n        echo ':)'\n    else\n        echo 'D:'\n    fi\n}\nPS1='$(exitstatus) > '\n```\n\n"
    },
    {
      "title": "カーソルの位置",
      "level": 3,
      "content": "PS1 の中でカーソルを移動することで、プロンプトをパーツに分けてそれぞれを別々の場所に表示させることができます。しかし、カーソルと出力を正しい位置に表示させるために、プロンプトの表示が終わったらカーソルを元の場所に戻さなければなりません。tput の sc と rc という機能を使うことでカーソルの位置を保存して後で戻すことができます。カーソルを移動するプロンプトは、一般に以下のようになります:\n\n```\nPS1=\"\\[$(tput sc; カーソル移動のコード) 移動されたプロンプト $(tput rc)\\] 通常のプロンプト\"\n```\n\n移動されたプロンプトは、Bash によって通常のプロンプトの一部として認識されないようにするために、\\[ \\] 内に記述します。\n\n"
    },
    {
      "title": "テキストを右寄せ",
      "level": 4,
      "content": "テキストを右寄せで表示させる最も単純な方法は、printf を使うことです:\n\n```\nrightprompt()\n{\n    printf \"%*s\" $COLUMNS \"right prompt\"\n}\n\nPS1='\\[$(tput sc; rightprompt; tput rc)\\]left prompt > '\n```\n\n上記のコードは、右寄せの可変長フィールド %*s を作成し、ターミナルの現在の列数 $COLUMNS に対して文字列のサイズを設定します。\n\n"
    },
    {
      "title": "任意の位置",
      "level": 4,
      "content": "cup 機能では画面の特定の位置にカーソルを移動できます。例えば tput cup 20 5 は20行目5列目にカーソルを移動します (0行目0列目が左上です)。cuu, cud, cuf, cub (上, 下, 右, 左) は現在の位置から相対的にカーソルを移動します。例えば tput cuf 10 はカーソルを10文字分だけ右に移動します。引数で LINES と COLUMNS 変数を使うことで下端と右端からの相対位置にカーソルを移動できます。例えば、右下から10行目5列目にカーソルを移動するには:\n\n```\n$ tput cup $((LINES - 11)) $((COLUMNS - 6))\n```\n\n"
    },
    {
      "title": "ターミナルのウィンドウタイトルのカスタマイズ",
      "level": 3,
      "content": "プロンプトと同じ方法 (シェルにエスケープシーケンスを出力する) で、ターミナルのウィンドウタイトルをカスタマイすできます。なので、プロンプト内にウィンドウタイトルをカスタマイズするコードを含めるのは一般的です。これは技術で器には xterm の機能ですが、最近のターミナルの多くはこの機能をサポートしています。使用するエスケープシーケンスは ESC]2;new titleBEL です。ここで、ESC と BEL はそれぞれエスケープ文字とベル文字です。Bash のエスケープシーケンスを使えば、以下のようにしてプロンプト内でタイトルを変更できます:\n\n```\nPS1='\\[\\e]2;タイトル\\a\\]prompt > '\n```\n\nもちろん、ウィンドウタイトルの文字列にはコマンドの出力結果や $PWD などの変数を含めることができ、プロンプトが表示されるたびにタイトルを変化させることができます。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Arch フォーラムのスレッドに投稿されたコミュニティの作例とスクリーンショット: What's your PS1? (ログインした場合にのみ閲覧可)\n- Gentoo の /etc/bash/bashrc。gentoo-bashrcAUR も参照。\n- tput(1) tput によるカラー出力とカーソル移動\n- Bash Prompt HOWTO\n- Giles Orr1 のプロンプトコレクション\n- Bash ヒント: カラー出力とフォーマット\n- Liquid Prompt — Bash & zsh 用の便利なアダプティブプロンプト\n- Bash POWER PROMPT\n- Wikipedia:ANSI escape code\n- GNU Bash manual: プロンプトの制御\n\n- tput によるカラー出力とカーソル移動\n\n"
    }
  ]
}