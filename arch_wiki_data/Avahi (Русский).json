{
  "title": "Avahi (Русский)",
  "url": "https://wiki.archlinux.org/title/Avahi_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **Эта статья или раздел нуждается в переводе** Эта статья или раздел нуждается в переводе\n\nЭта статья или раздел нуждается в переводе\n\nИз Wikipedia:Avahi (software):\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Установите пакет avahi.\n\nВы можете управлять демоном Avahi avahi-daemon.service используя systemd.\n\n"
    },
    {
      "title": "При использовании dhcpcd",
      "level": 4,
      "content": "Note: **This article or section is a candidate for merging with dhcpcd.** This article or section is a candidate for merging with dhcpcd.\n\nThis article or section is a candidate for merging with dhcpcd.\n\ndhcpcd-клиент пытается получить IPv4LL-адрес, если ему не удалось получить его через DHCP. По умолчанию эта опция отключена. Чтобы включить ее, зaкомментируйте строку noipv4ll:\n\n```\n/etc/dhcpcd.conf\n```\n\n```\n...\n#noipv4ll\n...\n```\n\nИли запустите avahi-autoipd:\n\n```\n# avahi-autoipd -D\n```\n\n"
    },
    {
      "title": "При использовании NetworkManager",
      "level": 4,
      "content": "При использовании NetworkManager, следует добавить альтернативную конфигурацию для получения IPv4LL-адреса, которая задействовалась бы, если не удалось получить IP через DHCP.\n\n```\n# nmcli connection add type ethernet ifname enp0s3 con-name enp0s3-auto\n# nmcli connection modify enp0s3-auto connection.autoconnect-priority 100\n# nmcli connection modify enp0s3-auto connection.autoconnect-retries 2 # reduce DHCP retries [since NM v1.6]\n# nmcli connection modify enp0s3-auto ipv4.dhcp-timeout 3 # reduce timeout time for each DHCP probe [since NM v1.2]\n# nmcli connection add type ethernet ifname enp0s3 con-name enp0s3-ll\n# nmcli connection modify enp0s3-ll connection.autoconnect-priority 50 ipv4.method link-local\n```\n\n"
    },
    {
      "title": "При использовании systemd-networkd",
      "level": 4,
      "content": "При использовании systemd-networkd, следует добавить в конфигурационный файл вида \"/etc/systemd/network/wired.network\" в раздел Network параметр для получения IPv4LL-адреса, в случае, если не удалось получить IP через DHCP:\n\n```\nLinkLocalAddressing=yes\n```\n\n"
    },
    {
      "title": "Сопоставление имён хостов (DNS)",
      "level": 3,
      "content": "Avahi выполняет сопоставление имён хостов из local, имеющих вид \"<имя хоста>.local\". Для включения, установите пакет nss-mdns и запустите/включите avahi-daemon.service.\n\nЗатем отредактируйте файл /etc/nsswitch.conf, в котором измените строку hosts, чтобы она включала mdns_minimal [NOTFOUND=return] перед resolve и dns:\n\n```\nhosts: mymachines mdns_minimal [NOTFOUND=return] resolve [!UNAVAIL=return] files myhostname dns\n```\n\n- Если у вас возникают сбои при разрешении .local хостов (или вы не хотите использовать IPv6), попробуйте использовать mdns4_minimal и mdns4 вместо mdns_minimal и mdns соответственно.\n- Приведенная выше строка делает nss-mdns авторитетным для домена .local, если только ваш одноадресный DNS-сервер не отвечает на запросы SOA для имени верхнего уровня local, или если запрос содержит более двух меток. Смотрите nss-mdns примечания по активации. systemd-resolved отвечает на эти запросы, даже если поддержка mDNS отключена. Смотрите #systemd-resolved препятствует работе nss-mdns. Больше информации о конфигурировании nss можно найти в nss-mymachines(8) и Avahi docs.\n\n- systemd-resolved отвечает на эти запросы, даже если поддержка mDNS отключена. Смотрите #systemd-resolved препятствует работе nss-mdns.\n- Больше информации о конфигурировании nss можно найти в nss-mymachines(8) и Avahi docs.\n\n"
    },
    {
      "title": "Конфигурирование mDNS для произвольного домена верхнего уровня (TLD)",
      "level": 4,
      "content": "Модуль mdns_minimal обрабатывает запросы только для TLD .local. Обратите внимание на [NOTFOUND=return], который указывает, что если mdns_minimal не может найти .local, он не будет продолжать поиск в dns, myhostname и т.д.\n\nВ случае, если вы хотите, чтобы Avahi поддерживал другие TLD, вы должны:\n\n- заменить mdns_minimal [NOTFOUND=return] на mdns (существуют модули только для IPv4 и только для IPv6 mdns[46](_minimal));\n- настроить в /etc/avahi/avahi-daemon.conf выбранное domain-name;\n- внести пользовательские TLD, используемые в Avahi, в белый список в /etc/mdns.allow.\n\n"
    },
    {
      "title": "Межсетевой экран",
      "level": 3,
      "content": "Обязательно откройте UDP-порт 5353, если вы используете брандмауэр.\n\n"
    },
    {
      "title": "Утилиты обнаружения",
      "level": 3,
      "content": "Avahi включает в себя несколько утилит, которые помогут вам обнаружить сервисы, запущенные в сети. Например, запустите это, чтобы обнаружить сервисы в вашей сети:\n\n```\n$ avahi-browse --all --ignore-local --resolve --terminate\n```\n\nЕсли вы просто хотите выполнить запрос mDNS для преобразования имени хоста .local в IP-адрес (аналогично igили slookup), используйте:\n\n```\n$ avahi-resolve-host-name some-host-name.local\n```\n\nОбратите внимание, что команда getent host может выполнять поиск как по DNS, так и по mDNS.\n\nAvahi Zeroconf Browser avahi-discover отображает различные сервисы в вашей сети. Обратите внимание, что для этого нужны необязательные зависимости Avahi gtk3, python-dbus и python-gobject. Вы также можете просматривать SSH-серверы и VNC-серверы, используя соответственно bssh и bvnc.\n\n"
    },
    {
      "title": "Добавление сервисов",
      "level": 3,
      "content": "Avahi оповещает о сервисах, указанных в файлах *.service, которых находятся в /etc/avahi/services. Файлы в этом каталоге должны быть доступны для чтения пользователю/группе avahi.\n\nЕсли вы хотите оповещать о сервисе, для которого нет файла *.service, очень легко создать свой собственный. В качестве примера, допустим, вы хотите оповещать о присутствии на своём компьютере сервиса quote of the day (QOTD), работающего по RFC:865 на TCP-порту 17.\n\nПервое, что нужно сделать, это определить <type>. avahi.service(5) указывает, что тип должен быть \"типом службы DNS-SD для этой службы, например, '_http._tcp'\". Поскольку Реестр DNS-SD был объединен с реестром FIANNA в 2010 году, мы ищем название службы в Реестре IANA или в файле /etc/services. Указанное там имя службы - qotd. Поскольку мы запускаем QOTD по протоколу tcp, теперь мы знаем, что сервис - это _qotd._tcp, а порт (для IANA и RFC 865) - 17.\n\nСоответствующий файл сервиса:\n\n```\nqotd.service\n```\n\n```\n<?xml version=\"1.0\" standalone='no'?><!--*-nxml-*-->\n<!DOCTYPE service-group SYSTEM \"avahi-service.dtd\">\n\n<service-group>\n\n  <name replace-wildcards=\"yes\">%h</name>\n\n  <service>\n    <type>_qotd._tcp</type>\n    <port>17</port>\n  </service>\n\n</service-group>\n```\n\nДля более сложных сценариев, таких как оповещение о сервисах, работающие на другом сервере, подтипах DNS и т.д., обратитесь к avahi.service(5).\n\nИмейте в виду, что Avahi не поддерживает произвольные строки в поле <type>, вы можете задавать только значения, присутствующие в перечень сервисов Avahi. Если вы хотите зарегистрировать что-то своё, вам, скорее всего, придется отредактировать перечень, создать обновленную версию ПО и установить его на своих машинах.\n\n"
    },
    {
      "title": "SSH",
      "level": 4,
      "content": "Avahi поставляется с примером служебного файла для оповещения о доступности SSH-сервера. Чтобы включить его:\n\n```\n# cp /usr/share/doc/avahi/ssh.service /etc/avahi/services/\n```\n\n"
    },
    {
      "title": "Общий доступ к файлам",
      "level": 4,
      "content": "Если у вас настроен общий доступ с использованием NFS, вы можете использовать Avahi для автомонтирования в браузерах с поддержкой Zeroconf (таких как Konqueror на KDE и Finder на macOS) или файловых менеджерах, таких как GNOME/Files.\n\nСоздайте файл .service в /etc/avahi/services со следующим содержимым:\n\n```\n/etc/avahi/services/nfs_Zephyrus_Music.service\n```\n\n```\n<?xml version=\"1.0\" standalone='no'?>\n<!DOCTYPE service-group SYSTEM \"avahi-service.dtd\">\n<service-group>\n  <name replace-wildcards=\"yes\">NFS Music Share on %h</name>\n  <service>\n    <type>_nfs._tcp</type>\n    <port>2049</port>\n    <txt-record>path=/data/shared/Music</txt-record>\n  </service>\n</service-group>\n```\n\nПорт указан правильно, если у вас есть insecure как опция в вашем /etc/exports; в противном случае его необходимо изменить (учтите, что insecure необходим для клиентов с macOS). 'path' - это путь к вашему 'export' или его подкаталогу.\n\nПо какой-то причине функция автоматического монтирования была удалена из Leopard, однако доступен соответствующий скрипт. См. этот пост.\n\nЕсли демон Avahi запущен как на сервере, так и на клиенте, файловый менеджер на клиенте автоматически найдёт сервер.\n\nВы также можете автоматически обнаруживать обычные FTP-серверы, такие как vsftpd. Установите пакет vsftpd и измените настройки vsftpd в соответствии с вашими личными предпочтениями (смотрите эту тему на ubuntuforums.org или vsftpd.conf(5)).\n\nСоздайте файл .service в /etc/avahi/services со следующим содержимым:\n\n```\n/etc/avahi/services/ftp.service\n```\n\n```\n<?xml version=\"1.0\" standalone='no'?>\n<!DOCTYPE service-group SYSTEM \"avahi-service.dtd\">\n<service-group>\n  <name>FTP file sharing</name>\n  <service>\n    <type>_ftp._tcp</type>\n    <port>21</port>\n  </service>\n</service-group>\n```\n\nТеперь Avahi должен оповещать о FTP-сервере, и вы сможете найти FTP-сервер с помощью файлового менеджера на другом компьютере в вашей сети. Возможно, вам потребуется включить #Сопоставление имён хостов (DNS) на клиенте.\n\n"
    },
    {
      "title": "Мессенджеры, поддерживающие Link-Local (Bonjour/Zeroconf)",
      "level": 4,
      "content": "Avahi можно использовать для поддержки протокола Bonjour в Linux. Cписок клиентов, поддерживающих протокол Bonjour можно посмотреть в Сравнение клиентов обмена мгновенными сообщениями или Клиенты обмена мгновенными сообщениями.\n\n"
    },
    {
      "title": "К имени хоста добавляются инкрементирующиеся числа",
      "level": 3,
      "content": "Это известная ошибка, вызванная состоянием гонки имен хостов. Одним из возможных обходных путей является отключение IPv6, чтобы попытаться предотвратить состояние гонки. Если присутствует несколько интерфейсов используйте allow-interfaces, чтобы ограничить Avahi одним интерфейсом. Другим возможным обходным решением является отключить кэш, чтобы вообще запретить Avahi проверять наличие конфликтов имен хостов, но это не позволит Avahi выполнять поиск.\n\n"
    },
    {
      "title": "systemd-resolved препятствует работе nss-mdns",
      "level": 3,
      "content": "nss-mdns работает только в том случае, если DNS-сервер, указанный в /etc/resolv.conf, возвращает NXDOMAIN на запросы SOA для \"локального\" домена.[1]\n\nПрежде всего, проверьте отвечает ли ваш DNS-сервер, после настройки, на запрос SOA для домена \"local\" именно \"NXDOMAIN\". Например:\n\n```\n$ host -t SOA local\n```\n\nЕсли DNS-сервер отвечает \"NXDOMAIN\", вам не нужно выполнять приведенные ниже действия. Avahi должен иметь возможность нормально находить ресурсы в сети, даже если используется systemd-resolved.\n\nВ более старых версиях systemd-resolved глобальная настройка \"MulticastDNS=no\" в resolved.conf(5) приводила к кодам ответа, несовместимым с Avahi, для домена \"local\". Это приводило к тому, что Avahi не смог правильно найти ресурсы (принтеры). См. системная проблема 21659.\n\nОднако, если приведенный выше запрос DNS не возвращает \"NXDOMAIN\" для домена \"local\", вы можете использовать полный mdns-nss модуль вместо mdns_minimal и создать /etc/mdns.allow, где разрешить доступ только к \"локальному\" домену. Например:\n\n```\n/etc/nsswitch.conf\n```\n\n```\nhosts: mymachines mdns [NOTFOUND=return] resolve [!UNAVAIL=return] files myhostname dns\n```\n\n```\n/etc/mdns.allow\n```\n\n```\n.local.\n.local\n```\n\n"
    },
    {
      "title": "ECONNREFUSED (Connection refused) на сокете avahi",
      "level": 3,
      "content": "Если ваш Avahi запускается и работает корректно, но nss, похоже, не перенаправляет запросы в dns, это может быть вызвано зависанием сокета /run/avahi-daemon/socket. В этом можно убедиться, например, с помощью strace. Если это подтвердится, возможно, придется перезапустить как avahi-daemon.service, так и avahi-daemon.socket, чтобы заставить его работать корректно.\n\n"
    },
    {
      "title": "Смотри также",
      "level": 2,
      "content": "- Avahi - Official project website\n- Wikipedia:Avahi (software)\n- iTunes (includes Bonjour) - Enable Zeroconf on Windows\n- http://www.zeroconf.org/\n\n"
    }
  ]
}