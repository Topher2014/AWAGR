{
  "title": "Dd (Español)",
  "url": "https://wiki.archlinux.org/title/Dd_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2019-09-22** \n\nArtículos relacionados\n\n- Disk cloning (Español)\n- USB flash installation media (Español)#Utilizar dd\n- Benchmarking#dd\n\ndd es una de las Core utilities (Español) cuyo objetivo principal es convertir y copiar un archivo.\n\nDe manera similar a cp, por defecto dd hace una copia bit a bit del archivo, pero con funciones de control de flujo de E/S de nivel inferior.\n\nPara obtener más información, consulte dd(1) o la documentación completa.\n\n"
    },
    {
      "title": "Instalación",
      "level": 2,
      "content": "dd es parte de GNU coreutils. Para otras utilidades del paquete, consulte Core utilities (Español).\n\n"
    },
    {
      "title": "Clonación y restauración de discos",
      "level": 2,
      "content": "La orden dd es una herramienta simple, pero versátil y potente. Se puede utilizar para copiar de origen a destino, bloque por bloque, independientemente de los tipos de sistemas de archivos o sistemas operativos. Un método conveniente es usar dd desde un entorno live, como en un CD Live.\n\n"
    },
    {
      "title": "Clonar una partición",
      "level": 3,
      "content": "Desde el disco físico /dev/sda, partición 1, al disco físico /dev/sdb, partición 1:\n\n```\n# dd if=/dev/sda1 of=/dev/sdb1 bs=64K conv=noerror,sync status=progress\n```\n\n"
    },
    {
      "title": "Clonar un disco duro completo",
      "level": 3,
      "content": "Desde el disco físico /dev/sda al disco físico /dev/sdb:\n\n```\n# dd if=/dev/sda of=/dev/sdb bs=64K conv=noerror,sync status=progress\n```\n\nEsta orden clonará toda la unidad, incluido el MBR (y, por lo tanto, el cargador de arranque), todas las particiones, UUID y datos.\n\n- bs= establece el tamaño del bloque. El valor predeterminado es 512 bytes, que es el tamaño de bloque «clásico» para discos duros desde principios de la década de 1980, pero no es el más conveniente. Utilice un valor mayor, 64K o 128K. Además, lea la advertencia siguiente, porque no solo hay que tener encuenta los «tamaños de bloques» en sí, también influyen estos en cómo se propagan los errores de lectura. Consulte [1] y [2] para obtener más información y para determinar el mejor valor de bs para su caso particular.\n- noerror indica a dd que continúe la operación, ignorando todos los errores de lectura. El comportamiento predeterminado para dd es detenerse ante cualquier error.\n- sync rellena los bloques de entrada con ceros si hubo errores de lectura, por lo que las compensaciones de datos permanecerán sincronizadas.\n- status=progress muestra estadísticas de transferencia periódicas que se utilizan para estimar cuándo puede completarse la operación.\n\nLa utilidad dd técnicamente tiene un «tamaño de bloque de entrada» (IBS) y un «tamaño de bloque de salida» (OBS). Cuando configura bs, configura de manera efectiva tanto IBS como OBS. Normalmente, si el tamaño de su bloque es, digamos, 1 MiB, dd leerá 1024×1024 bytes y escribirá bytes iguales. Pero si ocurre un error de lectura, las cosas saldrán mal. Mucha gente parece pensar que dd «llenará los errores de lectura con ceros si usa las opciones noerror, sync, pero esto no es lo que sucede. dd, según la documentación, llenará el OBS al tamaño del IBS después de completar su lectura, lo que significa agregar ceros al final del bloque. Esto significa, para un disco, que efectivamente todo 1 MiB se estropearía debido a un solo error de lectura de 512 bytes al comienzo de la lectura: 12ERROR89 se convertiría en 128900000 en lugar de 120000089.\n\nSi está seguro de que su disco no contiene ningún error, puede continuar usando un tamaño de bloque más grande, lo que aumentará la velocidad de su copia varias veces. Por ejemplo, cambiar bs de 512 a 64K cambiará la velocidad de copia de 35 MB/s a 120 MB/s en un sistema Celeron de 2.7 GHz. Pero tenga en cuenta que los errores de lectura en el disco de origen terminarán como «errores de bloque» en el disco de destino, es decir, un solo error de lectura de 512 bytes dañará todo el bloque de salida de 64 KiB.\n\n- Para recuperar UUID únicos de un sistema de archivos ext2/3/4, utilice tune2fs /dev/sdXY -U random en cada partición. Para particiones de intercambio, utilice mkswap /dev/sdXY en su lugar.\n- El kernel no registra los cambios de la tabla de particiones realizadas por dd . Para notificar los cambios sin reiniciar, utilice una utilidad como partprobe (parte de GNU Parted).\n\n"
    },
    {
      "title": "Crear copia de seguridad de la tabla de particiones",
      "level": 3,
      "content": "Consulte fdisk (Español)#Copia de seguridad y restauración de la tabla de particiones o GPT fdisk#Backup and restore partition table.\n\n"
    },
    {
      "title": "Crear imagen de disco",
      "level": 3,
      "content": "Arranque desde un medio live y asegúrese de que no se monten particiones desde el disco duro de origen.\n\nLuego monte el disco duro externo y haga una copia de seguridad del disco (de origen):\n\n```\n# dd if=/dev/sda conv=sync,noerror bs=64K | gzip -c  > /ruta/a/backup.img.gz\n```\n\nSi es necesario (por ejemplo, cuando los archivos resultantes están almacenados en un sistema de archivos FAT32) divida la imagen del disco en varias partes (consulte también split(1)):\n\n```\n# dd if=/dev/sda conv=sync,noerror bs=64K | gzip -c | split -a3 -b2G - /ruta/a/backup.img.gz\n```\n\nSi no hay suficiente espacio en el disco local, puede enviar la imagen a través de ssh:\n\n```\n# dd if=/dev/sda conv=sync,noerror bs=64K | gzip -c | ssh user@local dd of=backup.img.gz\n```\n\nFinalmente, guarde información adicional sobre la geometría de la unidad necesaria para interpretar la tabla de particiones almacenada dentro de la imagen. La más importante de las cuales es el tamaño del cilindro.\n\n```\n# fdisk -l /dev/sda > /path/to/list_fdisk.info\n```\n\n"
    },
    {
      "title": "Restaurar el sistema",
      "level": 3,
      "content": "Para restaurar su sistema:\n\n```\n# gunzip -c /ruta/a/backup.img.gz | dd of=/dev/sda\n```\n\nCuando la imagen se haya dividido, use lo siguiente:\n\n```\n# cat /ruta/a/backup.img.gz* | gunzip -c | dd of=/dev/sda\n```\n\n"
    },
    {
      "title": "Parchear archivos binarios",
      "level": 2,
      "content": "Si se quiere reemplazar el desplazamiento 0x123AB de un archivo con la secuencia hexadecimal FF C0 14, esto se puede hacer con la línea de órdenes:\n\n```\n# printf '\\xff\\xc0\\x14' | dd seek=$((0x123AB)) conv=notrunc bs=1 of=/ruta/al/archivo\n```\n\n"
    },
    {
      "title": "Copiar y restaurar el MBR",
      "level": 2,
      "content": "Antes de realizar cambios en un disco, es posible que desee hacer una copia de seguridad de la tabla de particioines y del esquema de particionado de la unidad. También puede usar una copia de seguridad para replicar el mismo esquema de particionado en varias unidades.\n\nEl MBR se almacena en los primeros 512 bytes del disco. Consta de 4 partes:\n\n1. Los primeros 440 bytes contienen el código de arranque (cargador de arranque).\n1. Los siguientes 6 bytes contienen la firma del disco.\n1. Los siguientes 64 bytes contienen la tabla de particiones (4 entradas de 16 bytes cada una, una entrada para cada partición primaria).\n1. Los últimos 2 bytes contienen una firma de arranque.\n\nPara guardar el MBR como mbr_file.img:\n\n```\n# dd if=/dev/sdX of=/path/to/mbr_file.img bs=512 count=1\n```\n\nTambién puede extraer el MBR desde una imagen completa de disco con dd :\n\n```\n# dd if=/ruta/al/disco.img of=/ruta/al/mbr_file.img bs=512 count=1\n```\n\nPara restaurar (tenga cuidado, esto destruye la tabla de particiones existente y con ella el acceso a todos los datos en el disco):\n\n```\n# dd if=//ruta/al/mbr_file.img of=/dev/sdX bs=512 count=1\n```\n\nSi solo desea restaurar el cargador de arranque, pero no las entradas de la tabla de partición primaria, simplemente restaure los primeros 440 bytes del MBR:\n\n```\n# dd if=/ruta/al/mbr_file.img of=/dev/sdX bs=440 count=1\n```\n\nPara restaurar solo la tabla de particiones, se debe usar:\n\n```\n# dd if=/ruta/al/mbr_file.img of=/dev/sdX bs=1 skip=446 count=64\n```\n\n"
    },
    {
      "title": "Eliminar el gestor de arranque",
      "level": 3,
      "content": "Para borrar el código de arranque MBR (puede ser útil si tiene que reinstalar completamente otro sistema operativo), solo es necesario poner a cero los primeros 440 bytes:\n\n```\n# dd if=/dev/zero of=/dev/sdX bs=440 count=1\n```\n\n"
    }
  ]
}