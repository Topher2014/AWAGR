{
  "title": "Alternative DNS services (Русский)",
  "url": "https://wiki.archlinux.org/title/Alternative_DNS_services_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Настройка сети\n- DNS over HTTPS servers\n\nДоменное имя — символьное представление IP-адреса в системе доменных имён (Domain Name System, DNS). В статье рассмотрена настройка разрешения (resolution) доменных имён.\n\n"
    },
    {
      "title": "Name Service Switch",
      "level": 2,
      "content": "Name Service Switch (NSS) — функциональность стандартной библиотеки Си (glibc), на основе которой выполняется разрешение доменных имён при вызове getaddrinfo(3). NSS объединяет управление базами данных различных служб, позволяя настраивать порядок поиска в этих базах с помощью файла nsswitch.conf(5). За разрешение доменных имён отвечает база данных hosts, для которой glibc предлагает следующие службы:\n\n- files — читает файл /etc/hosts, см. hosts(5);\n- dns — распознаватель glibc, читает файл /etc/resolv.conf, см. resolv.conf(5).\n\nsystemd предоставляет три службы NSS для разрешения имён:\n\n- nss-resolve(8) — кэширующий распознаватель-заглушка DNS, подробнее в статье systemd-resolved;\n- nss-myhostname(8) — разрешение имён без редактирования /etc/hosts, подробнее в статье Настройка сети#Разрешение имён в локальной сети;\n- nss-mymachines(8) — разрешение имён для локальных контейнеров systemd-machined(8).\n\n"
    },
    {
      "title": "Разрешение доменных имён с NSS",
      "level": 3,
      "content": "Базы данных NSS можно опрашивать утилитой getent(1). Разрешение доменного имени через NSS выполняется следующим образом:\n\n```\n$ getent hosts доменное_имя\n```\n\n"
    },
    {
      "title": "Распознаватель glibc",
      "level": 2,
      "content": "Распознаватель glibc считывает файл /etc/resolv.conf при каждом разрешении имени, определяя сервер доменных имён и используемые опции.\n\nВ файле resolv.conf(5) перечислены сервера имён и настройки. Сервера используются в порядке перечисления, сверху вниз. Можно указать до трёх серверов. Строки, начинающиеся с символа решётки (#), игнорируются.\n\n"
    },
    {
      "title": "Перезапись файла /etc/resolv.conf",
      "level": 3,
      "content": "Сетевые менеджеры иногда перезаписывают файл /etc/resolv.conf. Подробности можно найти в соответствующих статьях:\n\n- dhcpcd#/etc/resolv.conf\n- netctl#/etc/resolv.conf\n- NetworkManager#/etc/resolv.conf\n\nПомешать программам изменять файл /etc/resolv.conf можно с помощью защиты от записи, атрибутом неизменяемости:\n\n```\n# chattr +i /etc/resolv.conf\n```\n\n"
    },
    {
      "title": "Ограничение времени поиска",
      "level": 3,
      "content": "Если поиск выполняется слишком медленно (например, при работе pacman или в браузере), попробуйте задать тайм-аут с небольшим значением. По истечении тайм-аута распознаватель выбирает следующий сервер имён из списка. Добавьте следующую строку в /etc/resolv.conf:\n\n```\noptions timeout:1\n```\n\n"
    },
    {
      "title": "Задержка при разрешении имени с IPv6",
      "level": 3,
      "content": "Из-за неправильной настройки DNS-сервера или межсетевого экрана может возникать пятисекундная задержка при попытке выполнить разрешение имени двумя запросами, A и AAAA [1]. Добавьте следующую опцию в /etc/resolv.conf, чтобы решить проблему:\n\n```\noptions single-request\n```\n\n"
    },
    {
      "title": "Имена в локальном домене",
      "level": 3,
      "content": "Чтобы имена локальных хостов можно было указывать без доменного имени, добавьте следующую строку в файл /etc/resolv.conf (домен замените на необходимый):\n\n```\ndomain example.org\n```\n\nТеперь при работе, например, ssh можно сослаться на локальный хост строкой вида mainmachine1 (вместо mainmachine1.example.org); в то же время другим командам (например, drill) всё ещё может требоваться полное имя домена.\n\n"
    },
    {
      "title": "Утилиты",
      "level": 2,
      "content": "С помощью специализированных DNS-утилит можно отправлять запросы конкретным DNS-серверам и/или запросы к записям DNS/DNSSEC определённого типа. NSS при этом не используется, поскольку в утилитах такого рода обычно имеется собственная реализация протокола DNS.\n\nНапример, для сбора DNS-информации можно использовать утилиту drill(1) из пакета ldns. Следующая команда запросит TXT-запись домена у указанного сервера имён:\n\n```\n$ drill @сервер_имён TXT домен\n```\n\nЕсли DNS-сервер не указать, то drill будет отправлять запросы одному из указанных в /etc/resolv.conf серверов.\n\n- knot — khost(1) и kdig(1).\n- Unbound — unbound-host(1).\n- BIND — dig(1), host(1), nslookup(1), а также набор dnssec- утилит.\n\n"
    },
    {
      "title": "Производительность",
      "level": 2,
      "content": "В распознавателе glibc отсуствует кэширование ответов. Если кэширование всё же необходимо, то либо используйте systemd-resolved, либо запустите локальный кэширующий DNS-сервер. Во втором случае сервер будет работать как локальный сервер имён — добавьте адреса 127.0.0.1 и ::1 в файл /etc/resolv.conf (или в /etc/resolvconf.conf при работе через openresolv).\n\n- Утилиты drill и dig выводят время, затраченное на запрос к серверу.\n- На маршрутизаторах часто установлен собственный распознаватель, который выступает в качестве DNS-сервера для локальной сети; он же обычно предоставляет и DNS-кэш.\n- Если переключение между серверами происходит слишком медленно, попробуйте уменьшить тайм-аут.\n\n"
    },
    {
      "title": "Приватность и безопасность",
      "level": 2,
      "content": "В базовом протоколе DNS шифрование сообщений не предусмотрено. По этой причине ни конфиденциальность запросов, ни целостность/подлинность ответов никак не проверяется и не гарантируются. В итоге ваши запросы могут быть \"подслушаны\", а ответы — изменены, например, при работе в недоверенной сети или при наличии у вашего интернет-провайдера некоего злого умысла. Помимо перечисленных проблем, существует такое явление как перехват DNS со стороны DNS-сервера.\n\nЕсли вы всё же рассчитываете на некоторую конфиденциальность, то в первую очередь необходимо выбрать DNS-сервер, которому можно доверять. Сервера имён предоставляются как интернет-провайдерами, так и сторонними компаниями. Также можно запустить собственный рекурсивный сервер имён, но это, само собой, потребует некоторых дополнительных усилий. Если вы используете DHCP-клиент в недоверенной сети, убедитесь, что ваш распознаватель настроен на использование статических серверов, потому что иначе запросы будут отправляться на неизвестный посторонний сервер. Обезопасить соединение с удалённым DNS-сервером можно с помощью шифрования по протоколам DNS over TLS (RFC 7858), DNS over HTTPS (RFC 8484) и DNSCrypt, при условии, что и выбранный upstream-сервер, и ваш распознаватель одновременно поддерживают конкретный протокол. В качестве отдельного решения можно использовать специализированную программу для шифрования соединяний, — например, stunnel. Для проверки подлинности ответов (в самом ли деле они приходят от авторитативного сервера имён) можно использовать DNSSEC (опять же при условии, что он поддерживается и сервером, и вашим распознавателем).\n\n"
    },
    {
      "title": "DNS в приложениях",
      "level": 3,
      "content": "Некоторые клиентские программы, например, крупнейшие веб-браузеры, начали реализовывать DNS over HTTPS [2], [3]. С одной стороны, шифрование сообщений является неоспоримым плюсом; в то же время такие программы часто отправляют запросы \"мимо\" системного распознавателя [4].\n\nFirefox предоставляет настройки для включения/отключение DNS over HTTPS и выбора сервера имён.\n\nChromium включает DoH, если сервера имён, используемые системным распознавателем, его поддерживают. Подробнее (в т.ч. о том, как отключить DoH) см. этот пост.\n\nТакже разработчики Mozilla предложили отключать DNS в приложениях, если системный распознаватель не может выполнить разрешение имени специального домена use-application-dns.net. В настоящее время эта проверка реализована только в Firefox.\n\n"
    },
    {
      "title": "Oblivious DNS",
      "level": 3,
      "content": "Oblivious DNS (RFC:9230) — система распознавания DNS-имён, которая призвана решить некоторые проблемы приватности. Подробнее см. статью Cloudflare.\n\n"
    },
    {
      "title": "Сторонние службы DNS",
      "level": 2,
      "content": "Существует целый DNS-служб от независимых производителей; для некоторых из них также разработаны специализированные программы.\n\n- cloudflared — DNS-клиент с поддержкой DNS over HTTPS от Coudflare.\n\n- dingo — DNS-клиент с поддержкой DNS over HTTPS от Google.\n\n- opennic-up — позволяет автоматизировать обновление DNS-серверов с помощью серверов OpenNIC.\n\n- nextdns — Консольный DNS-over-HTTPS клиент для NextDNS.\n\nС помощью dnsperftest можно замерить производительность наиболее популярных распознавателей для вашего географического расположения. На сайте dnsperf.com приведено глобальное сравнение производительности резличных провайдеров.\n\n"
    },
    {
      "title": "DNS-серверы",
      "level": 2,
      "content": "DNS-серверы делятся на авторитативные и рекурсивные. Если сервер не принадлежит к одному из этих двух типов, то он представляет из себя так называемый распознаватель-заглушку (stub resolver); его назначение — просто перенаправлять запросы к некоему рекурсивному серверу имён. Заглушки обычно используются для DNS-кэширования на хосте или в локальной сети. Обратите внимание, что то же самое можно получить и установив полноценный сервер имён. В данном разделе представлено сравнение доступных DNS-серверов, более подробное сравнение можно найти в статье Comparison of DNS server software.\n\nTable content:\nНазвание | Пакет | Возможности | resolvconf | Поддерживаемые протоколы\nАвторитативный | Рекурсивный | Кэш | ПроверкаDNSSEC | DNS | DNSCrypt | DNSover TLS | DNSover HTTPS\nBIND | bind | Да | Да | Да | Да | Да | Да | Нет | stunnel#DNS over TLS | Нет\nCoreDNS | corednsAUR или coredns-binAUR | ? | ? | ? | ? | ? | ? | ? | Да | ?\nDeadwood (MaraDNS recursor) | maradnsAUR | Нет | Да | Да | Нет | Нет | Да | Нет | Нет | Нет\ndnscrypt-proxy | dnscrypt-proxy | Нет | Нет | Да | Нет | Нет | Сервер | Распознаватель | Нет | Да\ndnsmasq | dnsmasq | Частично1 | Нет | Да | Да | Да | Да | Нет | Нет | Нет\nKnot Resolver | knot-resolver | Нет | Да | Да | Да | Нет | Да | Нет | Да | Сервер\npdnsd | pdnsd | Да | Да | Стойкий | Нет | Да | Да | Нет | Нет | Нет\nPowerDNS Recursor | powerdns-recursor | Нет | Да | Да | Да | Да | Да | Нет | Нет | Нет\nRescached | rescached-gitAUR | Нет | Нет | Да | Нет | Да | Да | Нет | Нет | Ограниченно2\nSmartDNS | smartdns | Нет | Нет | Да | Нет | ? | Да | Нет | Распознаватель | Распознаватель\nStubby | stubby | Нет | Нет | Нет | Да | Нет | Сервер | Нет | Распознаватель | Нет\nsystemd-resolved | systemd | Нет | Нет | Да | Да | Да | Распознаватель и сервер (ограниченно) | Нет | Распознаватель | Нет\nUnbound | unbound | Частично | Да | Да3 | Да | Да | Да | Сервер | Да | Сервер\n\n1. Из Википедии: dnsmasq имеет ограниченную поддержку авторитативности, предназначенную главным образом для внутренних сетей, а не открытого Интернета.\n1. Только перенаправление, если сам Rescached получил DoH-запрос [5].\n1. Unbound может использовать Redis в качестве бэкэнда для стойкого кэширования.\n\n"
    },
    {
      "title": "Авторитативные серверы",
      "level": 3,
      "content": "Table content:\nНазвание | Пакет | DNSSEC | Географическаябалансировка\ngdnsd | gdnsd | Нет | Да\nKnot DNS | knot | Да | Да\nMaraDNS | maradnsAUR | Нет | ?\nNSD | nsd | Нет | Нет\nPowerDNS | powerdns | Да | Да\n\n"
    },
    {
      "title": "Условное перенаправление",
      "level": 3,
      "content": "Существует возможность настроить систему на использование определённого DNS-распознавателя для разрешения некоторых доменных имён. Например, очень удобно при подключении к VPN-сети запросы к ней же разрешать с помощью её собственного DNS, в то время как запросы к остальному интернету будут по прежнему разрешаться стандартным распознавателем. Также это можно использовать в локальных сетях.\n\nДля реализации условного перенаправления понадобится локальный распознаватель, потому что glibc такую функцию не поддерживает.\n\nВ динамическом окружении (ноутбуки и в некоторой степени настольные компьютеры) необходимо настроить ваш распознаватель на основе сети(-ей), к которой(-ым) вы подключены. Проще всего это сделать с помощью openresolv, поскольку он поддерживает нескольких абонентов. Некоторые сетевые менеджеры также поддерживают этот механизм, либо через openresolv, либо через настройку распознавателя напрямую. Так, в NetworkManager реализовано условное перенаправление без openresolv.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Руководство сетевого администратора Linux\n- Справочник Debian\n- RFC:7706 — снижение времени доступа к корневым серверам при запуске на петлевом устройстве\n- Domain name system overview — Диаграмма DNS\n- Альтернативные службы DNS\n\n"
    }
  ]
}