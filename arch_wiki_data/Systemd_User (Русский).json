{
  "title": "Systemd/User (Русский)",
  "url": "https://wiki.archlinux.org/title/Systemd/User_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- systemd (Русский)\n- Автоматический вход в виртуальную консоль\n- xinitrc (Русский)#Автозапуск X при входе в систему\n\nsystemd позволяет пользователю управлять службами в личном, отдельном экземпляре systemd. Благодаря этому пользователь может запускать, останавливать, включать и отключать свои собственные юниты. Это очень удобно в случае демонов и служб, которые обычно запускаются для отдельного пользователя (mpd), или выполнения автоматизированных задач (например, скачивание почты).\n\n"
    },
    {
      "title": "Как это работает",
      "level": 2,
      "content": "В соответствии с конфигурацией по умолчанию в /etc/pam.d/system-login, модуль pam_systemd автоматически запускает systemd --user в случае, когда пользователь в первый раз входит в систему . Этот процесс будет работать до тех пор, пока существует сессия этого пользователя, и будет убит, как только последний сеанс для пользователя будет закрыт. Когда включен #Автоматический запуск systemd от имени пользователя, то процесс запускается при загрузке и убит не будет. Пользовательский процесс systemd отвечает за управление службами пользователей, которые могут быть использованы для запуска демонов или автоматизированных задач, со всеми преимуществами systemd, таких как активация сокета, таймеры, системы зависимостей или строгий контроль процесса через контрольные группы.\n\nАналогично системным службам, пользовательские службы расположены в следующих каталогах (отсортированы по возрастанию приоритета):\n\n- /usr/lib/systemd/user/ где находятся службы, относящиеся к установленным пакетам.\n- ~/.local/share/systemd/user/ где находятся службы, относящиеся к пакетам, установленным в домашний каталог.\n- /etc/systemd/user/ где находятся общесистемные пользовательские службы, созданные системным администратором.\n- ~/.config/systemd/user/ где пользователь размещает свои собственные службы.\n\nПри запуске пользовательского процесса systemd он привязывается к пользовательской же (то есть отдельной для каждого пользователя) цели default.target. Другие службы могут управляться вручную с помощью команды systemctl --user. См. systemd.special(7) § UNITS MANAGED BY THE USER SERVICE MANAGER.\n\n- Имейте в виду, что systemd --user представляет собой процесс для каждого пользователя, а не для сессии. Смысл заключается в том, что большая часть ресурсов, обрабатываемых пользовательскими службами, такие как сокеты или файлы состояния будут создаваться отдельно для каждого пользователя (в его домашнем каталоге), и не за один сеанс. Это означает, что все пользовательские службы работают вне сеанса. Как следствие, программы, которые должны быть запущены внутри сессии, вероятно, прервут выполнение пользовательских служб. С помощью systemd в пользовательском сеансе обрабатывается довольно много данных. См [1] и [2] для получения подсказок о том, как идут дела.\n- systemd --user выполняется как процесс, отдельный от родительского процесса systemd --system. Службы пользователей не могут ссылаться или зависеть от системных юнитов или юнитов других пользователей.\n\n"
    },
    {
      "title": "Основные настройки",
      "level": 2,
      "content": "Все пользовательские службы размещаются в ~/.config/systemd/user/. Если вы хотите запускать службы при первом входе в систему, выполните systemctl --user enable service для любой службы, которую вы хотите сделать автозагрузочной.\n\n"
    },
    {
      "title": "Переменные окружения",
      "level": 3,
      "content": "Пользовательский процесс systemd не наследует какую-либо из переменных окружения, установленных в .bashrc или других. Существует несколько способов установить переменные окружения для systemd:\n\n1. Для переменной $HOME пользовательского каталога, создайте файл .conf в каталоге ~/.config/environment.d/ со строками вида {{ic | 1 = NAME = VAL}. Применяется только к части пользовательских служб.\n\nСмотрите environment.d(5) для получения дополнительной информации.\n\n1. Используйте опцию DefaultEnvironment в /etc/systemd/user.conf. Применяется ко всем пользовательским службам.\n1. Добавление конфигурационного файла в /etc/systemd/system/user@.service.d/. Применяется ко всем пользовательским процессам; см #Пример службы\n1. Для временного изменения используйте systemctl --user set-environment или systemctl --user import-environment. Применяется ко всем пользовательским службам, созданным после установки переменных окружения, но не к службам, которые уже были запущены.\n1. Используйте dbus-update-activation-environment --systemd --all — команду, которую предоставляет D-Bus. Имеет тот же эффект, что и systemctl --user import-environment, но также влияет на сессию D-Bus. Вы можете добавить это в конец вашего файла инициализации оболочки.\n1. Для \"глобальных\" переменных пользовательского окружения вы можете использовать каталоги environment.d, которые анализируются генераторами systemd. Подробнее см. environment.d(5) и systemd.generator(7).\n1. Вы также можете написать скрипт генератора среды, который может создавать переменные среды, которые варьируются от пользователя к пользователю. Это, вероятно, лучший способ, если вам нужны индивидуальные среды (это относится к XDG_RUNTIME_DIR, DBUS_SESSION_BUS_ADDRESS и т.д.). Смотрите systemd.environment-generator(7).\n\nОдну переменную Вы можете установить в PATH.\n\nПосле настройки можно использовать команду systemctl --user show-environment для проверки правильности значений.\n\n"
    },
    {
      "title": "Пример службы",
      "level": 4,
      "content": "Создайте drop-in каталог /etc/systemd/system/user@.service.d/ и внутри создайте файл с расширением .conf (например, local.conf):\n\n```\n/etc/systemd/system/user@.service.d/local.conf\n```\n\n```\n[Service]\nEnvironment=\"PATH=/usr/lib/ccache/bin:/usr/local/bin:/usr/bin:/bin\"\nEnvironment=\"EDITOR=nano -c\"\nEnvironment=\"BROWSER=firefox\"\nEnvironment=\"NO_AT_BRIDGE=1\"\n```\n\n"
    },
    {
      "title": "DISPLAY и XAUTHORITY",
      "level": 4,
      "content": "Переменная DISPLAY используется любым графическим приложением, чтобы знать, какой дисплей использовать, XAUTHORITY, чтобы указать путь к пользовательскому файлу .Xauthority, а также куки, необходимые для запуска Х-сервера. Если Вы планируете запускать графические приложения из процесса systemd, то эти переменные обязательно должны быть установлены. Systemd предоставляет скрипт в /etc/X11/xinit/xinitrc.d/50-systemd-user.sh для импорта этих переменных в пользовательскую сессию systemd на запуск X. [3] Так что если Вы не запускаете Х нестандартным образом, пользовательские службы должны знать переменные DISPLAY и XAUTHORITY.\n\n"
    },
    {
      "title": "PATH",
      "level": 4,
      "content": "Если изменить PATH и запланированный запуск приложений, которые используют службу systemd, Вы должны убедиться, что модифицированный PATH установлен и в среде systemd. Если предположить, что Вы установили переменную PATH в .bash_profile, то лучшим способом сделать systemd осведомленным о модификации PATH будет добавление в .bash_profile после PATH заданной переменной:\n\n```\n~/.bash_profile\n```\n\n```\nsystemctl --user import-environment PATH\n```\n\nОбратите внимание, что это не повлияет на службы systemd, запущенные до импортирования PATH.\n\n"
    },
    {
      "title": "pam_env",
      "level": 4,
      "content": "Переменные среды можно сделать доступными с помощью модуля pam_env.so. Смотрите Environment variables#Using pam_env для деталей конфигурации.\n\n"
    },
    {
      "title": "Автоматический запуск systemd от имени пользователя",
      "level": 3,
      "content": "Пользовательский процесс systemd запускается сразу после первого входа пользователя в систему, и будет убит после завершения последнего сеанса пользователя. Иногда может быть полезно запустить службу сразу после загрузки, и поддерживать процесс systemd запущенным даже после завершения последнего сеанса пользователя, например, чтобы некоторый пользовательский процесс работал без какой-либо открытой сессии. Для этой цели используются долговременные службы. Используйте следующую команду, чтобы включить долговременную службу для конкретного пользователя:\n\n```\n# loginctl enable-linger username\n```\n\nNote: **вне** \n\n"
    },
    {
      "title": "Написание пользовательских юнитов",
      "level": 2,
      "content": "Смотрите systemd#Writing unit files для получения общей информации о написании юнитов модулей systemd.\n\n"
    },
    {
      "title": "Пример",
      "level": 3,
      "content": "Ниже приведен пример варианта пользовательской службы mpd.\n\n```\n~/.config/systemd/user/mpd.service\n```\n\n```\n[Unit]\nDescription=Music Player Daemon\n\n[Service]\nExecStart=/usr/bin/mpd --no-daemon\n\n[Install]\nWantedBy=default.target\n```\n\n"
    },
    {
      "title": "Пример с переменными",
      "level": 3,
      "content": "Ниже приведен пример пользовательской версии sickbeard.service, которая учитывает все переменные окружения пользовательских каталогов, где SickBeard может найти некоторые файлы:\n\n```\n~/.config/systemd/user/sickbeard.service\n```\n\n```\n[Unit]\nDescription=SickBeard Daemon\n\n[Service]\nExecStart=/usr/bin/env python2 /opt/sickbeard/SickBeard.py --config %h/.sickbeard/config.ini --datadir %h/.sickbeard\n\n[Install]\nWantedBy=default.target\n```\n\nКак указано в systemd.unit(5), переменная %h заменяется домашней директорией пользователя, запускающего службу. Есть и другие переменные, которые учитываются на странице руководства systemd.\n\n"
    },
    {
      "title": "Чтение журнала",
      "level": 3,
      "content": "Журнал для пользователя может быть прочитан с помощью аналогичной команды:\n\n```\n$ journalctl --user\n```\n\nЧтобы указать юнит, можно использовать\n\n```\n$ journalctl --user -u myunit.service\n```\n\nЭквивалентная команда\n\n```\n$ journalctl --user --user-unit myunit.service\n```\n\nОбратите внимание, что journald не будет писать пользовательские журналы для пользователей с UID ниже 1000, вместо этого перенаправляя всё в системный журнал.\n\n"
    },
    {
      "title": "Временные файлы",
      "level": 2,
      "content": "systemd-tmpfiles позволяет пользователям управлять нестабильными и временными файлами и каталогами так же, как общесистемным способом (см. systemd#systemd-tmpfiles — временные файлы). Пользовательские файлы конфигурации считываются из ~/.config/user-tmpfiles.d/ и ~/.local/share/user-tmpfiles.d/ в указанном порядке. Для использования этой функциональности требуется включить необходимые пользовательские юниты systemd для вашего пользователя:\n\n```\n$ systemctl --user enable systemd-tmpfiles-setup.service systemd-tmpfiles-clean.timer\n```\n\nСинтаксис конфигурационных файлов такой же, как и для всей системы. Для получения дополнительной информации смотрите справочные страницы systemd-tmpfiles(8) и tmpfiles.d(5).\n\n"
    },
    {
      "title": "Xorg и systemd",
      "level": 2,
      "content": "Есть несколько способов запустить xorg в системных модулях. Ниже представлены два варианта: либо запустить новый пользовательский сеанс с процессом xorg, либо запустить xorg из пользовательской службы systemd.\n\n"
    },
    {
      "title": "Автоматический логин в Xorg без экранного менеджера",
      "level": 3,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nЭта опция запускает системный блок, который запускает сеанс пользователя с сервером xorg, а затем запускает обычный ~/.xinitrc для запуска оконного менеджера и т.д.\n\nВам необходим установленный xlogin-gitAUR. Настройте свой xinitrc, как указано в разделе Xinit#xinitrc.\n\nСеанс будет использовать собственный dbus демон, но различные утилиты systemd будут автоматически подключаться к экземпляру dbus.service. Наконец, enable службу xlogin@username для автоматического входа при загрузке.Сеанс пользователя полностью находится в области видимости systemd, и все в сеансе пользователя должно работать нормально.\n\n"
    },
    {
      "title": "Xorg как пользовательская служба systemd",
      "level": 3,
      "content": "Кроме того, Xorg можно запустить из службы пользователя systemd. Это хорошо, поскольку другие связанные с X юниты могут зависеть от xorg и т. д. Но с другой стороны, у этого есть некоторые недостатки, объясненные ниже.\n\nxorg-server обеспечивает интеграцию с systemd двумя способами:\n\n- Может быть запущен непривилегированным, делегируя управление устройствами logind (смотрите коммиты Hans de Goede коммит).\n- Может быть превращен в сервис, активируемый сокетом (смотрите этот коммит).\n\nК сожалению, чтобы иметь возможность запускать xorg в непривилегированном режиме, он должен запускаться внутри сеанса. Итак, в данный момент недостаток запуска xorg в качестве пользовательской службы заключается в том, что он должен запускаться с привилегиями суперпользователя (как до 1.16) и не может использовать преимущества непривилегированного режима, представленного в 1.16.\n\nВот как запустить xorg из пользовательского сервиса:\n\n1. Заставить xorg работать с правами суперпользователя и для любого пользователя путем редактирования /etc/X11/Xwrapper.config\n\n```\n/etc/X11/Xwrapper.config\n```\n\n```\nallowed_users=anybody\nneeds_root_rights=yes\n```\n\n2. Добавить следующие юниты в ~/.config/systemd/user\n\n```\n~/.config/systemd/user/xorg@.socket\n```\n\n```\n[Unit]\nDescription=Socket for xorg at display %i\n\n[Socket]\nListenStream=/tmp/.X11-unix/X%i\n```\n\n```\n~/.config/systemd/user/xorg@.service\n```\n\n```\n[Unit]\nDescription=Xorg server at display %i\n\nRequires=xorg@%i.socket\nAfter=xorg@%i.socket\n\n[Service]\nType=simple\nSuccessExitStatus=0 1\n\nExecStart=/usr/bin/Xorg :%i -nolisten tcp -noreset -verbose 2 \"vt${XDG_VTNR}\"\n```\n\nгде ${XDG_VTNR} - виртуальный терминал, на котором будет запущен xorg, либо прописанный в сервисном модуле, либо установленный в среде systemd с помощью\n\n```\n$ systemctl --user set-environment XDG_VTNR=1\n```\n\n3. Обязательно настройте переменную среды DISPLAY, как описано выше.\n\n4. Затем, чтобы активировать сокет для xorg на дисплее 0 и tty 2, следует выполнить:\n\n```\n$ systemctl --user set-environment XDG_VTNR=2     # Так что xorg@.service знает, какой vt использовать\n$ systemctl --user start xorg@0.socket            # начинает слушать на сокете для дисплея 0\n```\n\nТеперь запуск любого X приложения автоматически запустит xorg на виртуальном терминале 2.\n\nПеременная среды XDG_VTNR может быть установлена в среде systemd из .bash_profile, а затем можно запустить любое приложение X, включая диспетчер окон, как системный модуль, зависящий от xorg@0.socket.\n\n"
    },
    {
      "title": "Постоянный терминальный мультиплексор",
      "level": 3,
      "content": "Note: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\nВозможно, вы захотите, чтобы в сеансе пользователя по умолчанию использовался терминальный мультиплексор, например GNU Screen или Tmux, в фоновом режиме, а не для входа в сеанс оконного менеджера. Разделение входа в систему от входа в систему X, скорее всего, полезно только для тех, кто загружается с TTY, а не с экранным менеджером (в этом случае вы можете просто связать все, что вы запускаете, с myStuff.target).\n\nЧтобы создать пользовательский сеанс такого типа, действуйте, как указано выше, но вместо создания wm.target создайте multiplexer.target:\n\n```\n[Unit]\nDescription=Terminal multiplexer\nDocumentation=info:screen man:screen(1) man:tmux(1)\nAfter=cruft.target\nWants=cruft.target\n\n[Install]\nAlias=default.target\n```\n\ncruft.target, как mystuff.target выше, должен запускать все, что, по вашему мнению, должно запускаться до запуска tmux или экрана (или что вы хотите запустить при загрузке независимо от времени), например сеанс демона GnuPG.\n\nЗатем вам нужно создать сервис для сеанса мультиплексора. Вот пример службы, использующей tmux в качестве примера и использующей сеанс gpg-agent, который записал свою информацию в /tmp/gpg-agent-info. Этот пример сеанса при запуске X также сможет запускать программы X, так как установлен DISPLAY.\n\n```\n[Unit]\nDescription=tmux: A terminal multiplixer \nDocumentation=man:tmux(1)\nAfter=gpg-agent.service\nWants=gpg-agent.service\n\n[Service]\nType=forking\nExecStart=/usr/bin/tmux start\nExecStop=/usr/bin/tmux kill-server\nEnvironment=DISPLAY=:0\nEnvironmentFile=/tmp/gpg-agent-info\n\n[Install]\nWantedBy=multiplexer.target\n```\n\nКак только это будет сделано, systemctl --user enable tmux.service, multiplexer.target и любые сервисы, которые вы создали для запуска cruft.target, и вы должны быть готовы к работе! Активирован user-session@.service, как описано выше, но обязательно удалите Conflicts=getty@tty1.service из {{ic|user-session@.service} }, поскольку ваш пользовательский сеанс не будет принимать TTY. Поздравляем! У вас есть работающий терминальный мультиплексор и некоторые другие полезные программы, готовые к запуску при загрузке!\n\n"
    },
    {
      "title": "Оконный менеджер",
      "level": 3,
      "content": "Чтобы запустить оконный менеджер в качестве службы systemd, сначала необходимо запустить Xorg как пользовательскую службу systemd. В следующем примере мы будем использовать awesome (Русский):\n\n```\n~/.config/systemd/user/awesome.service\n```\n\n```\n[Unit]\nDescription=Awesome window manager\nAfter=xorg.target\nRequires=xorg.target\n\n[Service]\nExecStart=/usr/bin/awesome\nRestart=always\nRestartSec=10\n \n[Install]\nWantedBy=wm.target\n```\n\n"
    },
    {
      "title": "Завершение процессов пользователя при выходе из системы",
      "level": 2,
      "content": "Arch Linux создает пакет systemd с помощью --without-kill-user-process, устанавливая KillUserProcesses равным no по умолчанию. Этот параметр предотвращает уничтожение пользовательских процессов, когда пользователь полностью выходит из системы. Чтобы изменить это поведение и убить все пользовательские процессы при выходе из системы, установите KillUserProcesses=yes в /etc/systemd/logind.conf.\n\nОбратите внимание, что изменение этого параметра нарушает работу мультиплексоров терминала, таких как tmux и GNU Screen (Русский). Если вы измените этот параметр, вы все равно сможете использовать терминальный мультиплексор, используя systemd-run следующим образом:\n\n```\n$ systemd-run --scope --user command args\n```\n\nНапример, чтобы запустить screen, вы должны сделать:\n\n```\n$ systemd-run --scope --user screen -S foo\n```\n\nЗапущенные с помощью systemd-run процессы продолжат работу даже после выхода пользователя, если он залогинен в системе где-то ещё и служба user@.service всё ещё работает.\n\nПосле завершения всех активных сеансов user@.service прекращает работу, если для этого пользователя не был включён lingering [7]. Поэтому для запуска и работы долгосрочных процессов после полного выхода пользователя из системы необходимо включить lingering. Подробнее см. #Автоматический запуск systemd от имени пользователя и loginctl(1).\n\n"
    },
    {
      "title": "Runtime directory '/run/user/1000' is not owned by UID 1000, as it should",
      "level": 3,
      "content": "```\nsystemd[1867]: pam_systemd(systemd-user:session): Runtime directory '/run/user/1000' is not owned by UID 1000, as it should.\nsystemd[1867]: Trying to run as user instance, but $XDG_RUNTIME_DIR is not set\n```\n\nЕсли вы видите такую ошибку и ваш сеанс в порядке, то возможно, что другая системная (не пользовательская) служба создала этот каталог. Например, такое могло произойти при использовании контейнера docker, который выполнил bind-монтирование в каталог /run/user/1000. Чтобы это исправить, либо отредактируйте контейнер, удалив монтирование, либо отключите/отложите службу docker.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Вики-ресурс пользователя KaiSforza на Bitbucket\n- Файлы юнитов пользователя Zoqaeski на GitHub\n- Ветка форума Arch Linux об изменениях пользовательских экземпляров в systemd 206\n\n"
    }
  ]
}