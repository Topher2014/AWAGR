{
  "title": "GUID Partition Table (日本語)",
  "url": "https://wiki.archlinux.org/title/GUID_Partition_Table_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- ファイルシステム\n- fdisk\n- gdisk\n- parted\n- fstab\n- LVM\n- スワップ\n- Arch ブートプロセス\n- Unified Extensible Firmware Interface\n\nパーティショニングとは二次記憶装置上に1つ、あるいは複数の領域を作成して、それぞれの領域を分離して管理できるようにすることです。\n\nディスク全体を1つのパーティションに割り当てることもできますし、複数のパーティションに割り当てることもできます (デュアルブートする場合やスワップパーティションを作る場合、オーディオファイルやビデオファイルなどのデータを論理的に分けておきたい場合に便利です)。パーティションスキームは、Master Boot Record (MBR) や GUID Partition Table (GPT) などのパーティションテーブルに格納されています。\n\nパーティションテーブルはパーティショニングツールを使うことで作成したり変更したりできます。Arch Linux で利用できるパーティショニングツールは #パーティショニングツール セクションにリストアップされています。\n\n通常、パーティションにはファイルシステムが直接含まれています。これは、パーティション上にファイルシステムを作成する(つまり、パーティションをフォーマットする)ことで可能です。あるいは、パーティションには LVM、ブロックデバイス暗号化、RAID を含ませることもでき、最終的にこれらは、ファイルを格納できるデバイスファイルを提供します (あるいは、デバイスをさらに積み重ねることもできます)。\n\nブロックデバイス (例えば ディスク、パーティション、LUKS デバイス、LVM 論理ボリューム、RAID アレイ) のうち、マウント可能なファイルシステムを直接含んでいるものは、ボリュームと呼ばれます。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 パーティションテーブル 1.1 Master Boot Record 1.1.1 Master Boot Record (bootstrap code) 1.1.2 Master Boot Record (partition table) 1.2 GUID Partition Table 1.3 GPT か MBR の選択 1.4 パーティションレスディスク 1.4.1 Btrfs パーティショニング\n- 2 パーティションスキーム 2.1 シングルルートパーティション 2.2 パーティションを分割する 2.2.1 / 2.2.2 /boot 2.2.3 /home 2.2.4 スワップ 2.2.5 /data 2.2.6 /var 2.3 レイアウト例 2.3.1 UEFI/GPT レイアウト例 2.3.2 BIOS/MBR レイアウト例 2.3.3 BIOS/GPT レイアウト例\n- 3 ツール 3.1 パーティショニングツール 3.1.1 GUI フロントエンド 3.2 バックアップ 3.3 リカバリ\n- 4 パーティションアライメント\n- 5 GPT カーネルサポート\n- 6 トラブルシューティング 6.1 古い BIOS をだまして GPT から起動させる 6.2 ファームウェア RAID が有効なときにドライブが表示されない\n- 7 参照\n\n- 1.1 Master Boot Record 1.1.1 Master Boot Record (bootstrap code) 1.1.2 Master Boot Record (partition table)\n- 1.2 GUID Partition Table\n- 1.3 GPT か MBR の選択\n- 1.4 パーティションレスディスク 1.4.1 Btrfs パーティショニング\n\n- 1.1.1 Master Boot Record (bootstrap code)\n- 1.1.2 Master Boot Record (partition table)\n\n- 1.4.1 Btrfs パーティショニング\n\n- 2.1 シングルルートパーティション\n- 2.2 パーティションを分割する 2.2.1 / 2.2.2 /boot 2.2.3 /home 2.2.4 スワップ 2.2.5 /data 2.2.6 /var\n- 2.3 レイアウト例 2.3.1 UEFI/GPT レイアウト例 2.3.2 BIOS/MBR レイアウト例 2.3.3 BIOS/GPT レイアウト例\n\n- 2.2.1 /\n- 2.2.2 /boot\n- 2.2.3 /home\n- 2.2.4 スワップ\n- 2.2.5 /data\n- 2.2.6 /var\n\n- 2.3.1 UEFI/GPT レイアウト例\n- 2.3.2 BIOS/MBR レイアウト例\n- 2.3.3 BIOS/GPT レイアウト例\n\n- 3.1 パーティショニングツール 3.1.1 GUI フロントエンド\n- 3.2 バックアップ\n- 3.3 リカバリ\n\n- 3.1.1 GUI フロントエンド\n\n- 6.1 古い BIOS をだまして GPT から起動させる\n- 6.2 ファームウェア RAID が有効なときにドライブが表示されない\n\n"
    },
    {
      "title": "パーティションテーブル",
      "level": 2,
      "content": "主に2種類のパーティションテーブルが利用できます。以下の #Master Boot Record (MBR) セクションと #GUID Partition Table (GPT) セクションで、どちらを選択すればよいかについての議論と共に説明されています。3つ目に、あまり一般的でない代替品としてパーティションレスディスクがあり、これも以下のセクションで説明されています。\n\nブロックデバイスのパーティションテーブルを表示するにはパーティショニングツールを使ってください。\n\n"
    },
    {
      "title": "Master Boot Record",
      "level": 3,
      "content": "Master Boot Record (MBR) は、ストレージデバイスの最初の512バイトです。これには、オペレーティングシステムのブートローダーとストレージデバイスのパーティションテーブルが含まれています。BIOS システムのブートプロセスで重要な役割を果たします。MBR の構造については、Wikipedia:Master boot record#Disk partitioning を参照してください。\n\n- MBR はパーティションにありません。これは、デバイスの最初のセクター(物理オフセット0)にあり、最初のパーティションの前にあります。\n- パーティションレスデバイスまたは個々のパーティション内に存在するブートセクターは、代わりに volume boot record (VBR) と呼ばれます。\n\n"
    },
    {
      "title": "Master Boot Record (bootstrap code)",
      "level": 4,
      "content": "MBR の先頭440バイトは、bootstrap code 領域 です。BIOS システムでは、通常、MBR にブートローダーの最初のステージが含まれています。bootstrap code は、dd を使ってバックアップしたり、バックアップから復元したり、消去したりすることができます。\n\n"
    },
    {
      "title": "Master Boot Record (partition table)",
      "level": 4,
      "content": "MBR パーティションテーブル(またの名を DOS パーティションテーブル、MS-DOS パーティションテーブル)には、3つのパーティションタイプがあります:\n\n- Primary (プライマリ)\n- Extended (拡張) Logical (論理)\n\n- Logical (論理)\n\nプライマリパーティションは起動可能にすることができ、ディスクや RAID ボリュームごとに4つまで作成できます。MBR パーティションテーブルで5つ以上のパーティションが必要になった場合、プライマリパーティションのうち1つを拡張パーティションに置き換えて、その中に論理パーティションを作成する必要があります。\n\n拡張パーティションは論理パーティションの入れ物と考えることができます。1つのハードディスクには2つ以上の拡張パーティションを格納することはできません。拡張パーティションはプライマリパーティションとしてもカウントされるので、ディスクに1つの拡張パーティションが存在している場合、追加できるプライマリパーティションは3つだけです(つまり、3つのプライマリパーティションと1つの拡張パーティション)。拡張パーティション内に存在できる論理パーティションの数に制限はありません。Windows とデュアルブートするシステムでは、Windows をプライマリパーティションに格納する必要があります。\n\nsda1 から sda3 をプライマリパーティションとし、sda4 を拡張パーティションとするのが慣例です。sda4 上の論理パーティションは、sda5、sda6 などのようになります。\n\n"
    },
    {
      "title": "GUID Partition Table",
      "level": 3,
      "content": "GUID パーティションテーブル (GPT) とは、パーティションスキームの1つであり、Unified Extensible Firmware Interface 規格の一部です。GPT では、パーティションとパーティションタイプを定義するためにグローバル一意識別子(GUID)が使われます(Linux の世界では UUID が使用されます)。GPT は Master Boot Record パーティショニングスキーム方式の後継として設計されました。\n\nGUID Partition Table ディスクの先頭には、GPT を検出できないソフトウェアから保護するための protective Master Boot Record (PMBR) が存在します。通常の MBR のような protective MBR には、bootstrap code 領域が存在し、対応しているブートローダで BIOS/BPT ブートを行うために利用できます。\n\n"
    },
    {
      "title": "GPT か MBR の選択",
      "level": 3,
      "content": "GUID Partition Table (GPT) は新しい、現代的なパーティションスタイルです。古い Master Boot Record (MBR) システムを置き換えることを目指しています。GPT には、MS-DOS が使われていた時代にタイムスリップしてしまったような癖がある MBR に対してメリットがいくつかあります。フォーマッティングツールの最近の開発によって、GPT と MBR はどちらも信頼性、パフォーマンスを同じくらいの簡単さで実現できるようになりました。\n\nGPT か MBR を選択する際に考慮すべきポイントは:\n\n- レガシー BIOS を使って(32ビットと64ビットに関わらず) Windows とデュアルブートする場合、MBR スキームを使用する必要があります。\n- BIOS モードではなく UEFI モードで64ビット Windows とデュアルブートする場合、GPT スキームを使用する必要があります。\n- 古いハードウェア(特に、古いノートパソコン)上にインストールする場合、MBR を選択することを検討してください。そのハードウェアの BIOS が GPT に対応していないかもしれないからです(しかし、#古い BIOS をだまして GPT から起動させる に解決策があります)。\n- 2 TiB よりも大きいディスクをパーティショニングする場合、GPT を使う必要があります。\n- UEFI ブートでは常に GPT を使うことが推奨されます。一部の UEFI 実装は UEFI モードでの MBR からの起動をサポートしていないからです。\n- 上記のどれにも当てはまらない場合、GPT と MBR から自由に選んでください。GPT のほうがよりモダンなので、この場合、GPT を選ぶことが推奨されます。\n\nMBR に対する GPT のメリットは:\n\n- GPT はユニークなディスク GUID と、各パーティションごとにユニークなパーティション GUID(PARTUUID)を提供します。これは、パーティションやディスクを参照するための、ファイルシステムに依存しない良い手段です。GUID は、Discoverable Partitions Specification の前提条件であり、Systemd を有効化した initramfs で利用できます。\n- GPT は、ファイルシステムに依存しないパーティション名を提供します(PARTLABEL)。\n- GPT では任意の数のパーティションを作成できます(パーティションテーブルに割り当てられた領域のサイズに依存します)。拡張パーティションや論理パーティションは必要ありません。デフォルトで、GPT には 128 個のパーティションを定義できるスペースが確保されています。パーティションテーブルにより多くのスペースを割り当てることで、より多くのパーティションを定義できるようになります(この機能をサポートしているツールは今の所 gdisk しか知られていません)。\n- GPT では、セクタ番号を格納するために64ビットの LBA を使用します(アドレシング可能な最大ディスクサイズは 2 ZiB です)。MBR では、ドライブごとに 2 TiB までしかアドレシングできません。[1]\n- GPT では、バックアップのヘッダとパーティションテーブルがディスクの末尾に格納されており、プライマリのヘッダが破損してしまった場合にバックアップを使って復元を試みることができます。\n- CRC32 checksum により、ヘッダとパーティションテーブルのエラーと破損を検出します。\n\n#パーティショニングツール のセクションには、GPT や MBR のテーブルを作成/変更するためにどのツールを利用できるかを示す表があります。\n\n"
    },
    {
      "title": "パーティションレスディスク",
      "level": 3,
      "content": "パーティションレスディスク(別名 superfloppy)とは、パーティションテーブルを持たないストレージデバイスのことであり、1つのファイルシステムがストレージデバイス全体を占めます。パーティションレスデバイスに存在するブートセクタは、volume boot record (VBR) と呼ばれます。\n\n"
    },
    {
      "title": "Btrfs パーティショニング",
      "level": 4,
      "content": "Btrfs はデータストレージデバイス全体を占有して、MBR や GPT パーティションスキームを置き換えることができます。詳しい説明は Btrfs#パーティショニング を見て下さい。\n\n"
    },
    {
      "title": "パーティションスキーム",
      "level": 2,
      "content": "ハードドライブをパーティショニングするのに厳格なルールはありませんが、以下に一般的なガイダンスを記します。ディスクのパーティショニングスキームは、使用できるディスク容量の制限のほかに、求められる柔軟性、スピード、セキュリティなどの理由で決定されます。ユーザーの決定はコンピュータを使う癖や条件によって様々なものになりえます。Arch Linux と Windows OS のデュアルブートを考えているのなら、Windows と Arch のデュアルブートを読んでください。\n\n- 通常、UEFI システムでは EFI システムパーティションが必要です。\n- GPT でパーティショニングされた BIOS システムでは、GRUB をブートローダとして使う場合、BIOS ブートパーティションが必要です。\n\n"
    },
    {
      "title": "シングルルートパーティション",
      "level": 3,
      "content": "このスキームが最もシンプルかつ柔軟であり、消費者グレードのデバイスのストレージサイズが増加していることを鑑みると、ほとんどの場合これで十分です。必要に応じてスワップファイルを作成することもでき、簡単にそのサイズを変更できます。通常、まず単一の / パーティションから考え始めて、それから RAID、暗号化、共有メディアパーティションなどのユースケースに合わせてパーティションを分割していくのが道理にかなっています。いくつかの一般的な専用パーティション及び一般的でない専用パーティションの説明は #パーティションを分割する を参照してください\n\nGPT パーティションは、タイプ GUID BC13C2FF-59E6-4262-A352-B275FD6F7172 (\"Linux root (x86-64)\", \"Linux x86-64 root (/)\") である必要があります。MBR パーティションは、デフォルトの \"Linux\" タイプ ID 83 である必要があります。\n\n"
    },
    {
      "title": "パーティションを分割する",
      "level": 3,
      "content": "パーティションをパス毎に分割することで異なるファイルシステムとマウントオプションが使えるようになります。メディアパーティションなどの場合、オペレーティングシステム間で共有できます。\n\nパーティショニングの際に利用できるレイアウト例を以下に挙げています。以下のサブセクションでは、独立したパーティションに配置して / 下のマウントポイントにマウントできるディレクトリのいくつかを詳細に説明しています。これらのディレクトリの内容に関する完全な説明は file-hierarchy(7) を見てください。\n\n"
    },
    {
      "title": "/",
      "level": 4,
      "content": "ルートディレクトリはディレクトリ階層のトップです。このディレクトリでは主要なファイルシステムがマウントされ、他の全てのファイルシステムの幹になります。すべてのファイルとディレクトリはルートディレクトリ / の下に現れます、それらが異なる物理デバイスに保存されている場合でも同様です。ルートファイルシステムには、システムの起動、修復、回復、修繕に必要なものがなければなりません。そのため、/ 下の特定のディレクトリは、分割されたパーティションになりえません。\n\n/ パーティション(ルートパーティション)は必須の、一番重要なパーティションです。このパーティションで他の全てのパーティションを置き換えることができます。\n\n/ には伝統的に /usr ディレクトリが含まれており、インストールされているソフトウェアの量によっては非常に肥大化することがあります。最近のハードディスクでは、ほとんどのユーザにとって 15 から 20 GiB あれば十分でしょう。スワップファイルをここに保存するつもりであれば、パーティションのサイズをもっと大きくする必要があるかもしれません。\n\nGPT パーティションは、タイプ GUID BC13C2FF-59E6-4262-A352-B275FD6F7172 (\"Linux root (x86-64)\", \"Linux x86-64 root (/)\") である必要があります。MBR パーティションは、デフォルトの \"Linux\" タイプ ID 83 である必要があります。\n\n"
    },
    {
      "title": "/boot",
      "level": 4,
      "content": "/boot ディレクトリには、カーネルや initramfs イメージ、ブートローダの設定ファイルやブートローダのステージが含まれています。また、このディレクトリには、カーネルがユーザ空間のプログラムを実行し始める前に使用されるデータも格納されています。/boot は通常のシステム運用では必要ありませんが、ブート時やカーネルのアップグレード(初期 RAM ディスクの生成)の際に必要になります。\n\n- ブートローダーには、/boot パーティションにアクセスする機能が存在している必要があります。よって、カーネルと initramfs のイメージが存在する、ブロックデバイス、スタックされたブロックデバイス (LVM、RAID、dm-crypt、LUKS など)、ファイルシステムに至るまでの全てを、ブートローダーがサポートしていなければならなりません。\n- ファイルシステムには、ブートローダーがまだ対応していない新しい機能が導入されることがあります (例: FS#79857、FS#59047、FS#58137、FS#51879、FS#46856、FS#38750、FS#21733、fscrypt によって暗号化されたディレクトリ)。その場合、ブートローダーと互換性の無い機能を無効化しない限り、そのファイルシステムを /boot に対して使用するべきではありません。この問題は FAT32 を使用することで回避することができます。FAT32 は事実上全てのブートローダーによってサポートされており、新しい機能が追加されることもないからです。\n\nブートローダーの要件と機能に関する詳細は「Arch ブートプロセス#ブートローダー」を参照してください。\n\nEFI システムパーティションを /boot として使用する場合、(EFI システムパーティションの記事で説明されているように) 最小の推奨サイズは 300 MiB であり、適切なパーティションタイプが設定されていなければなりません。\n\nEFI システムパーティションを /boot として使用しない場合、/boot の推奨サイズは 200 MiB であり、パーティションタイプを Extended Boot Loader (XBOOTLDR) Partition に設定することが推奨されます (これは、GPT パーティションタイプ GUID BC13C2FF-59E6-4262-A352-B275FD6F7172 (gdisk ではタイプ ea00)、または MBR パーティションタイプ ID ea です)。\n\n"
    },
    {
      "title": "/home",
      "level": 4,
      "content": "/home ディレクトリには、ユーザー固有の設定ファイル、キャッシュ、アプリケーションのデータ、メディアファイルが含まれます。\n\n/home を分割することで / を別個にパーティションしなおすことができますが、分割してなくとも /home に触れずに Arch を再インストールすることはできます - 他のトップレベルディレクトリは削除する必要があり、それから pacstrap を実行することができます。\n\n異なるディストリビューションのユーザー間で home ディレクトリを共有するべきではありません、なぜならソフトウェアのバージョンやパッチによって互換性がないことがあるからです。代わりに、メディアパーティションを共有したり、少なくとも、同じ /home パーティションにある別の home ディレクトリを使うなどしてください。このパーティションのサイズは様々です。\n\nGPT パーティションは、タイプ GUID 933AC7E1-2EB4-4F13-B844-0E14E2AEF915 (\"Linux home\", \"Linux /home\") である必要があります。MBR パーティションは、デフォルトの \"Linux\" タイプ ID 83 である必要があります。\n\n"
    },
    {
      "title": "スワップ",
      "level": 4,
      "content": "スワップは、仮想メモリとして使用されるディスク領域を提供するファイル、またはパーティションです。スワップファイルとスワップパーティションのパフォーマンスは同等ですが、スワップファイルのほうが必要に応じてサイズを変更しやすいです。スワップパーティションは基本的にオペレーションシステム間で共有することができますが、ハイバネーションが使われる場合はそうでありません。\n\n歴史的に、スワップパーティションのサイズは物理 RAM のサイズの2倍にするという一般的なルールがありました。しかし、コンピュータがより多くのメモリを搭載するようになってから、このルールは時代遅れになりました。例えば、512 MiB の RAM を搭載する平均的なデスクトップマシンでは、通常「2倍ルール」は適切です。十分な量の RAM (1024 MiB 以上)が利用できる場合は、スワップパーティションを小さくしてもよいでしょう。\n\nハイバネート(suspend to disk)する場合、RAM と同じサイズのスワップパーティションを作成することが推奨されます。カーネルは、スワップ領域に収まるように suspend-to-disk イメージを圧縮しようとしますが、スワップ領域のサイズが RAM よりも大幅に小さい場合にハイバネートが成功する保証はありません。詳細は サスペンドとハイバネート#ハイバネーション を見てください。\n\nGPT パーティションは、タイプ GUID 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F (\"Linux swap\") である必要があります。MBR パーティションは、タイプ ID 82 (\"Linux swap\") である必要があります。\n\n"
    },
    {
      "title": "/data",
      "level": 4,
      "content": "「データ」パーティションをマウントして、すべてのユーザが共有する様々なファイルを格納することができます。/home パーティションをこの用途に使うこともできます。このパーティションのサイズは様々です。\n\nGPT パーティションは、デフォルトの \"Linux filesystem\" タイプ GUID 0FC63DAF-8483-4772-8E79-3D69D8477DE4 である必要があります。MBR パーティションは、デフォルトの \"Linux\" タイプ ID 83 である必要があります。\n\n"
    },
    {
      "title": "/var",
      "level": 4,
      "content": "/var ディレクトリには、スプールディレクトリ・ファイル、管理用のログデータ、pacman のキャッシュなどの可変データが置かれます。キャッシングやロギングなどに使われるため頻繁に読み書きされます。分割したパーティションに配置することで、ログなどによってディスク容量が不足するのを回避できます。\n\n/usr を読み込み専用でマウントするための選択肢としても存在します。歴史的に、(インストールやシステムメンテナンスと対照的に)システムオペレーションでは /var に置かれるものは全て /usr に書き出されます。\n\n- /var には小さいファイルが多く入ります。もしパーティションを分割するなら、ファイルシステムタイプ(下を見て下さい)の選択ではこのことを考えて下さい。\n- /var は頻繁に読み書きされるので、回転ディスク上でのこのパーティションの配置について考慮することが推奨されます。\n\n/var には、他のデータに混じって pacman のキャッシュが含まれます。パッケージのアップグレードによってシステムが不安定なった際に、保存されている以前のバージョンのパッケージにダウングレードしなければならなくなった場合に備えて、これらのパッケージを保管しておくと便利です。Pacman のキャッシュは、システムが拡張されたり更新されたりするたびに大きくなります。しかし、スペースの問題が生じた場合は、キャッシュを安全にクリアできます。\n\nデスクトップシステムにおいては 8~12 GiB の /var があれば十分なはずです。どれだけ多くのソフトウェアをインストールするかにも依りますが。NVIDIA、Wayland そして GDM を使用しているユーザは、ビデオメモリ全体を格納するのに十分な空き領域を持つようにこのパーティションのサイズを設定することを検討してください。\n\nGPT パーティションは、タイプ GUID 4D21B016-B534-45C2-A9FB-5C16E091FD2D (\"Linux variable data\", \"Linux /var\") である必要があります。MBR パーティションは、デフォルトの \"Linux\" タイプ ID 83 である必要があります。\n\n"
    },
    {
      "title": "レイアウト例",
      "level": 3,
      "content": "以下の例では、/dev/sda をディスクの例として使い、1番目のパーティションとして /dev/sda1 が存在するとします。パーティショニングするディスクが NVMe ディスク(例えば、/dev/nvme0n1p1 から始まるパーティションを持つ /dev/nvme0n1)であったり、SD カードや eMMC ディスク(例えば、/dev/mmcblk0p1 から始まるパーティションを持つ /dev/mmcblk0)であったりすると、ブロックデバイスの命名規則が異なります。詳細は デバイスファイル#ブロックデバイスの名前 を見てください。\n\n- UEFI ブートは \"boot\" フラグと関係ありません。UEFI ブートは NVRAM 上のブートエントリにのみ依存しています。Parted とそのフロントエンドは、パーティションが EFI システムパーティションであることを示すために GPT 上で \"boot\" フラグを使用します。\n- すべての必要なパーティションを同一のディスク上に置く必要はありませんし、すべてのディスクで同じ種類のパーティションテーブルを使用する必要もありません。\n\n"
    },
    {
      "title": "UEFI/GPT レイアウト例",
      "level": 4,
      "content": "Table content:\nインストールされたシステムでのマウントポイント | パーティション | パーティションタイプ GUID | パーティション属性 | 推奨サイズ\n/boot または /efi1 | /dev/sda1 | C12A7328-F81F-11D2-BA4B-00A0C93EC93B: EFI システムパーティション |  | 1 GiB\n[SWAP] | /dev/sda2 | 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F: Linux スワップ |  | 少なくとも 4 GiB。ハイバネーションを行う場合は RAM と同じサイズ\n/ | /dev/sda3 | 4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709: Linux x86-64 root (/) |  | デバイスの残りの領域。少なくとも 23 GiB から 32 GiB\n\n"
    },
    {
      "title": "BIOS/MBR レイアウト例",
      "level": 4,
      "content": "Table content:\nインストールされたシステムでのマウントポイント | パーティション | パーティションタイプ ID | ブートフラグ | 推奨サイズ\n[SWAP] | /dev/sda1 | 82: Linux スワップ | No | 少なくとも 4 GiB。ハイバネーションを行う場合は RAM と同じサイズ\n/ | /dev/sda2 | 83: Linux | Yes | デバイスの残りの領域。少なくとも 23 GiB から 32 GiB\nN/A | 未割り当て領域2 | N/A | N/A | ディスクの末尾に少なくとも 16.5 KiB\n\n"
    },
    {
      "title": "BIOS/GPT レイアウト例",
      "level": 4,
      "content": "Table content:\nインストールされたシステムでのマウントポイント | パーティション | パーティションタイプ GUID | パーティション属性 | 推奨サイズ\nなし | /dev/sda1 | 21686148-6449-6E6F-744E-656564454649: BIOS ブートパーティション3 |  | 1 MiB\n[SWAP] | /dev/sda2 | 0657FD6D-A4AB-43C4-84E5-0933C84B4F4F: Linux スワップ |  | 少なくとも 4 GiB。ハイバネーションを行う場合は RAM と同じサイズ\n/ | /dev/sda3 | 4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709: Linux x86-64 root (/) |  | デバイスの残りの領域。少なくとも 23 GiB から 32 GiB\n\n1. ブートローダが、カーネルと initramfs のイメージのある /efi のファイルシステム(とそこにあるファイル)にアクセスできる場合、ESP は /efi にマウントすることができます。詳細は EFI システムパーティション#典型的なマウントポイント と Arch ブートプロセス#ブートローダーセクションにある警告を見てください。\n1. 512バイトセクタ33個(16.5 KiB)以上のパーティショニングされていない領域をディスクの末尾に作成します。これは、将来的に GPT に変換できるようにするためのものです。この領域は、バックアップ GPT ヘッダのために必要です。すべての MBR ディスクに対してこのようなパーティショニングされていない領域を確保することが推奨されます。\n1. BIOS ブートパーティションは、GPT ディスクから GRUB を BIOS ブートする場合にのみ必要です。/boot とは関係ありません。このパーティションはファイルシステムでフォーマットしてはいけませんし、マウントしてもいけません。\n\n"
    },
    {
      "title": "パーティショニングツール",
      "level": 3,
      "content": "以下のプログラムは、デバイスのパーティションテーブルとパーティションを作成/操作するために使用されます。使用する正確なコマンドはリンク先の記事を見てください。\n\nこの表は、あなたのニーズにあうユーティリティを選ぶ際に役立ちます:\n\nTable content:\n名称 | パッケージ | MBR | GPT | CLI | TUI | スクリプティングユーティリティ\nfdisk | util-linux | Yes | Yes | fdisk(8) | cfdisk(8) | sfdisk(8)\nGPT fdisk | gptfdisk | No | Yes | gdisk(8) | cgdisk(8) | sgdisk(8)\nParted | parted | Yes | Yes | parted(8) | No | parted(8)\n\n"
    },
    {
      "title": "GUI フロントエンド",
      "level": 4,
      "content": "- blivet-gui — ストレージ設定のためのグラフィカルツール。python-blivetAUR と libblockdev を介して parted をバックエンドとして使用します。\n\n- GNOME Disks — ストレージデバイスを管理するための GNOME ユーティリティ。udisks2 と libblockdev を介して parted をバックエンドとして使用します。gnome の一部です。\n\n- GParted — ディスクパーティションをグラフィカルに管理するためのパーティションエディタ。データ損失無しでパーティションをリサイズ、コピー、移動することができます。parted をバックエンドとして使用します。\n\n- KDE Partition Manager — コンピュータ上のディスク、パーティション、そしてファイルシステムの管理をアシストするユーティリティ。kpmcore を介して sgdisk をバックエンドとして使用します。kde-system の一部です。\n\n"
    },
    {
      "title": "バックアップ",
      "level": 3,
      "content": "- fdisk はパーティションテーブルのバックアップを作成できます。fdisk#パーティションテーブルのバックアップとリストア を見てください。\n- GPT fdisk は、protective MBR、メイン GPT ヘッダ、バックアップ GPT ヘッダ、そしてパーティションテーブルのコピー一つからなるバイナリバックアップを作成できます。GPT fdisk#パーティションテーブルのバックアップとリストア を見てください。\n\n"
    },
    {
      "title": "リカバリ",
      "level": 3,
      "content": "- gpart — 破壊された MBR パーティションテーブルの内容を推測するユーティリティ。使用法は gpart(8) man ページで説明されています。\n\n- GPT fdisk — (ディスクの先頭にある)プライマリ GPT ヘッダを(ディスクの末尾にある)セカンダリ GPT ヘッダから復元できるパーティショニングツール(その逆も可)。\n\n- TestDisk — MBR と GPT の両方の失われたパーティションを復元できるユーティリティ。\n\n"
    },
    {
      "title": "パーティションアライメント",
      "level": 2,
      "content": "経験則として、パーティションの開始位置とサイズをメビバイト単位に揃えるというものがあります。Advanced Format#パーティションのアライメント を見てください。\n\n"
    },
    {
      "title": "GPT カーネルサポート",
      "level": 2,
      "content": "カーネル構成の CONFIG_EFI_PARTITION オプションは、カーネルでの GPT サポートを有効にします (名前は EFI システムパーティションに似た EFI PARTITION ですが)。このオプションはカーネルに組み込まれている必要があり、ロード可能なモジュールとしてコンパイルされてはなりません。このオプションは、GPT ディスクがデータストレージのみに使用され、起動には使用されない場合でも必要です。このオプションは、すべての Arch の 公式にサポートされているカーネル でデフォルトで有効になっています。カスタムカーネルの場合は、CONFIG_EFI_PARTITION=y を実行してこのオプションを有効にします。\n\n"
    },
    {
      "title": "古い BIOS をだまして GPT から起動させる",
      "level": 3,
      "content": "一部の古い BIOS (2010年以前のもの) は、ブートセクターを解析しようとし、ブート可能な MBR パーティションが含まれていない場合はブートを拒否します。これは、このディスクでGPTを使用する場合に問題になります。これは、 BIOS の観点から、タイプee の起動不可能な MBR パーティションが1つだけ含まれているためです(つまり、保護 MBR パーティション) fdisk -t mbr /dev/sda を使用して、保護MBRエントリを起動可能としてマークできます。これは一部の BIOS で機能します。ただし、 UEFI 仕様では、保護 MBR パーティションエントリを起動できないように禁止されており、 UEFI ベースのボードはレガシーブートモードでもこれを考慮します。したがって、これは、最新の UEFI ベースのボードと起動可能な MBR パーティションの検索を要求する古い BIOS の両方で起動することになっている GPT ベースの USB フラッシュドライブを作成する場合に重要です。 fdisk や gdisk などの従来のツールを使用してこの問題を解決することはできませんが、両方の種類の BIOS に適した偽の MBR パーティションエントリをバイトシーケンスとして手動で作成することはできます。\n\n以下のコマンドは、2番目の MBR パーティションスロットを上書きし、タイプ0 (つまり未使用) の起動可能なパーティションを追加して、デバイスの最初のセクターのみをカバーします。 GPT や、通常は保護 MBR パーティションを含む最初の MBR パーティションエントリには干渉しません。\n\n```\n# printf '\\200\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\001\\0\\0\\0' | dd of=/dev/sda bs=1 seek=462\n```\n\n最終的に次のようになります:\n\n```\n# fdisk -t mbr -l /dev/sda\n```\n\n```\nDisk /dev/sda: 232.9 GiB, 250059350016 bytes, 488397168 sectors\nDisk model: ST3250820AS\nUnits: sectors of 1 * 512 = 512 bytes\nSector size (logical/physical): 512 bytes / 512 bytes\nI/O size (minimum/optimal): 512 bytes / 512 bytes\nDisklabel type: dos\nDisk identifier: 0x00000000\n\nDevice     Boot Start       End   Sectors   Size Id Type\n/dev/sda1           1 488397167 488397167 232.9G ee GPT\n/dev/sda2  *        0         0         1   512B  0 Empty\n\nPartition table entries are not in disk order.\n```\n\n"
    },
    {
      "title": "ファームウェア RAID が有効なときにドライブが表示されない",
      "level": 3,
      "content": "SATA ドライブや NVMe ドライブがファームウェアのセットアップ画面で表示されるのに、Linux (例えば fdisk -l) では表示されない場合、コントローラがファームウェア RAID モードになっている可能性があります。\n\nNVMe の場合、journal に以下のように表示されるはずです:\n\n```\nkernel: ahci 0000:00:17.0: Found 1 remapped NVMe devices.\nkernel: ahci 0000:00:17.0: Switch your BIOS from RAID to AHCI mode to use them.\n```\n\n解決方法は、ファームウェアセットアップ画面を開いて SATA コントローラオペレーションモードを RAID から AHCI に変更することです。設定は別の名前 (例: \"Intel Rapid Storage Technology\"、\"Intel RST\"、\"Intel VMD controller\"、\"VMD\" など) であったり、コントローラごとやポートごとの設定があったりする場合があることに注意してください。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Wikipedia:ja:パーティション\n- Wikipedia:Binary prefix\n- Understanding Disk Drive Terminology\n- What is a Master Boot Record (MBR)?\n- Rod Smith 氏のページ What's a GPT? と Booting OSes from GPT\n- Make the most of large drives with GPT and Linux - IBM Developer\n- Microsoft の Windows と GPT FAQ\n- Partition Alignment (例付き)\n\n"
    }
  ]
}