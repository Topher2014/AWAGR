{
  "title": "Rsync (日本語)",
  "url": "https://wiki.archlinux.org/title/Rsync_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- システムバックアップ\n- 同期およびバックアッププログラム\n\nrsync は高速な差分ファイル転送を行うオープンソースのユーティリティです。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール 1.1 フロントエンド\n- 2 cp/mv の代わりとして使う 2.1 ​末尾のスラッシュに関する注意事項\n- 3 バックアップユーティリティとして使う 3.1 自動バックアップ 3.2 SSH を使った自動バックアップ 3.3 NetworkManager を使った自動バックアップ 3.4 systemd と inotify を使った自動バックアップ 3.5 一週間ごとに差分バックアップ 3.6 スナップショットバックアップ 3.7 システムのフルバックアップ 3.8 バックアップを復元する 3.9 フィルター規則の高度な使用法 3.10 パスのリストからコピー\n- 4 ファイルシステムのクローニング\n- 5 デーモンとして 5.1 設定例 5.1.1 ファイルのリストから共有する\n- 6 参照\n\n- 1.1 フロントエンド\n\n- 2.1 ​末尾のスラッシュに関する注意事項\n\n- 3.1 自動バックアップ\n- 3.2 SSH を使った自動バックアップ\n- 3.3 NetworkManager を使った自動バックアップ\n- 3.4 systemd と inotify を使った自動バックアップ\n- 3.5 一週間ごとに差分バックアップ\n- 3.6 スナップショットバックアップ\n- 3.7 システムのフルバックアップ\n- 3.8 バックアップを復元する\n- 3.9 フィルター規則の高度な使用法\n- 3.10 パスのリストからコピー\n\n- 5.1 設定例 5.1.1 ファイルのリストから共有する\n\n- 5.1.1 ファイルのリストから共有する\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "rsync パッケージをインストールしてください。\n\n​rsync をソースマシンと転送先マシンの両方にインストールする必要があります。\n\n"
    },
    {
      "title": "フロントエンド",
      "level": 3,
      "content": "- Grsync — GTK フロントエンド\n\n- luckyBackup — ​C++ で書かれた Qt フロントエンド\n\n- nbRsync — スケジューラーを統合した rsync 用の JavaFX GUI\n\n​その他に rsync を使っているツールは以下の通りです: rdiff-backup 、osyncAUR および yarsyncAUR\n\n"
    },
    {
      "title": "cp/mv の代わりとして使う",
      "level": 2,
      "content": "rsync は cp または mv コマンドの上位互換として使うことができ、特に大きなファイルのコピーに役立ちます:\n\n```\n$ rsync -P source destination\n```\n\n-P オプションは --partial --progress と同じで、一部ずつファイルを転送して、転送中にプログレスバーを表示します。\n\nディレクトリを再帰的にコピーしたいときは -r --recursive オプションを使用し、相対パス名を使いたい時は -R を使います (転送先のフォルダでフォルダ全体の階層を再生成します。)\n\ncp と同様にローカルにコピーする事に使えるだけでなく、例えば異なるホスト間といった、リモート同士でファイルをコピーする事にも使えます。リモートの場所はホスト-コロンシンタックスを使って指示できます:\n\n```\n$ rsync source host:destination\n```\n\nあるいは\n\n```\n$ rsync host:source destination\n```\n\nネットワークを利用したファイルのやりとりには SSH をデフォルトで使い、host は実際のホスト名かもしくは .ssh/config で定義されたプロファイルやエイリアスで指示できます。\n\nローカルかリモートでのファイルのやりとりに関わらず、 rsync はまず始めにファイル情報を含むファイルリストを作成します (デフォルトでは、ファイル情報はサイズと最後に修正したタイムスタンプから成ります。) このファイルリストは次にファイルを構築する必要があるか否かの判断に利用されます。それぞれのファイルを構築する際には、それぞれのブロックが長さ S バイトでオーバーラップがなくまた長さ S で分割可能なようなオフセットを持つようにブロックに分けられ、弱いチェックサムと強いチェックサムを生成します。これら情報によって、rsync はファイル全体をやりとりすることなく巨大なファイルを構築することができます。実用的かつ数学的な詳細な説明は、こちらを参照してください: rsync がどのように動作するか、rsync のアルゴリズム\n\n実用的なデフォルトの設定を手早く使いたい場合は、次の様にしてエイリアスを定義できます:\n\n```\ncpr() {\n  rsync --archive -hh --partial --info=stats1,progress2 --modify-window=1 \"$@\"\n} \nmvr() {\n  rsync --archive -hh --partial --info=stats1,progress2 --modify-window=1 --remove-source-files \"$@\"\n}\n```\n\n- -hh: 数を読み易いフォーマット (human-readable format) で出力します\n- --info=stats1,progress2: stats1 は rsync のファイル移行の統計を verbosity level 1 で出力します。progress2 は全やりとりの進捗を出力し、progress1 はファイル毎に進捗を出力します。\n- --modify-window=1: 2つのファイルのタイムスタンプを比較する際に 1秒以下の違いがあっても同じタイムスタンプとして処理します。\n- --remove-source-files: 正常にファイルのやりとりができた後に、ソースディレクトリからファイルを削除します。\n\n"
    },
    {
      "title": "​末尾のスラッシュに関する注意事項",
      "level": 3,
      "content": "Arch はデフォルトで GNU cp (GNU coreutils の一部) を使用します。 ただし、rsync は BSD cp の規則に従います。これは、末尾にスラッシュ 「/」 が付いたソースディレクトリに特別な処理を与えます。\n\n```\n$ rsync -r source destination\n```\n\nディレクトリ \"destination/source\" を \"source\" の内容で作成するのに対して、\n\n```\n$ rsync -r source/ destination\n```\n\n​は \"source/\" 内のすべてのファイルを \"destination\" にコピーしてその間にサブディレクトリは置きません。もし次を実行した様になります\n\n```\n$ rsync -r source/. destination\n```\n\nGNU cp は \"source\" と \"source/\" を同じように扱うので (\"source/.\" は違います) ​これらの動作は GNU cp の動作とは異なります。​また、シェルによっては、タブを補完するディレクトリ名の末尾にスラッシュを自動的に付加するものもあります。​これらの要因のために、 rsync を初めて使う、あるいは時々使うユーザの間では、 rsync の異なる動作を忘れてしまい、コマンドラインの最後にあるスラッシュを忘れてしまうことで、混乱を招いたり、重要なファイルを上書きしたりする傾向があります。\n\nしたがって、ラッパースクリプトを使用して、rsync を呼び出す前に末尾のスラッシュを自動的に削除することが賢明です:\n\n```\n#!/bin/bash\nnew_args=()\nfor i in \"${@}\"; do\n    case \"${i}\" in\n        /)\n            i=\"/\"\n        ;;\n        */)\n            i=\"${i%/}\"\n        ;;\n        esac\n    new_args+=(\"${i}\")\ndone\nexec rsync \"${new_args[@]}\"\n```\n\nこのスクリプトをパスの通った場所に置き、シェルの init ファイル内で rsync というエイリアスを付けられます。\n\n"
    },
    {
      "title": "バックアップユーティリティとして使う",
      "level": 2,
      "content": "rsync プロトコルは最後にバックアップされた時点から変更があったファイルだけを転送することができ、簡単にバックアップの為に使う事ができます。この節では、リムーバルメディアへコピーするといった、シンプルな定期的なバックアップスクリプトを紹介します。\n\n"
    },
    {
      "title": "自動バックアップ",
      "level": 3,
      "content": "このサンプルを使うには、スクリプトを /etc/cron.daily ディレクトリに作成して下さい。cron デーモン をインストールして適切に設定することで毎日実行せせるようになります。\n\nまず、適切なコマンドオプションを含んだスクリプトを作成:\n\n```\n/etc/cron.daily/backup\n```\n\n```\n#!/bin/sh\nrsync -a --delete --quiet /path/to/backup /location/of/backup\n```\n\n- -a : ファイルをアーカイブする。ファイルの属性も保存 (ただし ACL やハードリンク、ケイパビリティなどの拡張属性は除外)\n- --delete : バックアップ元で削除されたファイルはバックアップ先でも同じように削除する\n\nここで、/path/to/backup はバックアップしたいものに (例えば /home)、/location/of/backup はバックアップの保存先に変更します (例えば /media/disk)\n\n最後に、スクリプトを 実行可能 にします:\n\n"
    },
    {
      "title": "SSH を使った自動バックアップ",
      "level": 3,
      "content": "SSH を使ってリモートホストにバックアップする場合、以下のスクリプトを使用:\n\n```\n/etc/cron.daily/backup\n```\n\n```\n#!/bin/sh\nrsync -a --delete --quiet -e ssh /path/to/backup remoteuser@remotehost:/location/of/backup\n```\n\n- -e ssh : rsync に SSH を使うことを教える\n- remoteuser : ホスト remotehost のユーザー\n- -a : -rlptgoD オプションと同義 (recursive, links, perms, times, group, owner, devices)\n\n"
    },
    {
      "title": "NetworkManager を使った自動バックアップ",
      "level": 3,
      "content": "以下のスクリプトはケーブルを接続した時にバックアップを開始します。\n\nまず、適当なコマンドオプションを含んだスクリプトを作成:\n\n```\n/etc/NetworkManager/dispatcher.d/backup\n```\n\n```\n#!/bin/sh\n\nif [ x\"$2\" = \"xup\" ] ; then\n        rsync --force --ignore-errors -a --delete --bwlimit=2000 --files-from=files.rsync /path/to/backup /location/of/backup\nfi\n```\n\n- -a : -rlptgoD オプションと同義 (recursive, links, perms, times, group, owner, devices)\n- --files-from : ファイルから /path/to/backup の相対パスを読み込み\n- --bwlimit : I/O 帯域を制限、単位はキロバイト毎秒\n\nこのスクリプトの所有者をルートユーザにして下さい (詳しくは NetworkManager dispatcher を参照)\n\n"
    },
    {
      "title": "systemd と inotify を使った自動バックアップ",
      "level": 3,
      "content": "- inotify と systemd の制限により (この質問と答え を参照) 再帰的なファイルシステムの監視は不可能です。ディレクトリとその中身を監視することはできますが、サブディレクトリにまで再帰的に実行してその中身を監視することはされません。監視するディレクトリは全て明示的に指定する必要があります (ディレクトリが既に指定した監視ディレクトリの下にあっても記述する必要があります。)\n- このセットアップは systemd/ユーザー インスタンスをベースにしています。\n\ncron の実装など、スケジュールによって適宜バックアップを実行するのではなく、この方法ではバックアップするファイルに変更があった度にバックアップを実行することが可能です。systemd.path ユニットは inotify を使ってファイルシステムを監視し、systemd.service と一緒に使うことでファイルシステムのイベントに合わせてあらゆるプロセスを開始することができます (この場合は rsync のバックアップ。)\n\nまず、バックアップするファイルを監視する systemd.path ファイルを作成:\n\n```\n~/.config/systemd/user/backup.path\n```\n\n```\n[Unit]\nDescription=Checks if paths that are currently being backed up have changed\n\n[Path]\nPathChanged=%h/documents\nPathChanged=%h/music\n\n[Install]\nWantedBy=default.target\n```\n\nそして変更を検出した時に実行される systemd.service ファイルを作成します。デフォルトで、パスユニット (ここでは backup.path) と同じ名前の、拡張子が .path ではなく .service のサービスファイルが実行されます (ここでは backup.service)\n\n```\n~/.config/systemd/user/backup.service\n```\n\n```\n[Unit]\nDescription=Backs up files\n\n[Service]\nExecStart=/usr/bin/rsync %h/./documents %h/./music -CERrltm --delete ubuntu:\n```\n\nこれで、通常の systemd サービスのように backup.path 起動/有効化 を実行するだけで、ファイルの変更が監視され、backup.service が自動的に開始されます。\n\n"
    },
    {
      "title": "一週間ごとに差分バックアップ",
      "level": 3,
      "content": "実行毎の完全なバックアップを作成して、ファイルに変更があったものだけの差分バックアップのコピーを分かれたディレクトリに保持しつつ、一週間ごとに差分バックアップを行う便利な rsync のオプションです。\n\nまず、適当なコマンドオプションを含むスクリプトを作成:\n\n```\n/etc/cron.daily/backup\n```\n\n```\n#!/bin/sh\n\nDAY=$(date +%A)\n\nif [ -e /location/to/backup/incr/$DAY ] ; then\n  rm -fr /location/to/backup/incr/$DAY\nfi\n\nrsync -a --delete --quiet --inplace --backup --backup-dir=/location/to/backup/incr/$DAY /path/to/backup/ /location/to/backup/full/\n```\n\n--inplace オプションは --partial を伴ない、転送先のファイルを所定の場所に更新します。\n\n"
    },
    {
      "title": "スナップショットバックアップ",
      "level": 3,
      "content": "同じアイデアを使ってファイルのスナップショットのツリーを作ることができます。言い換えれば、ファイルのコピーが含まれる日付順のディレクトリです。コピーはハードリンクで作られ、変更があったファイルだけが場所を取ります。これは Apple の TimeMachine で使われているアイデアです。\n\n次の基本的なスクリプトは簡単な実装であり、変更がないファイルへハードリンクさせる --link-dest オプションを使って素早くインクリメンタルスナップショットを生成します:\n\n```\n/usr/local/bin/snapbackup.sh\n```\n\n```\n#!/bin/sh\n\n# Basic snapshot-style rsync backup script \n\n# Config\nOPT=\"-aPh\"\nLINK=\"--link-dest=/snapshots/username/last/\" \nSRC=\"/home/username/files/\"\nSNAP=\"/snapshots/username/\"\nLAST=\"/snapshots/username/last\"\ndate=`date \"+%Y-%b-%d:_%T\"`\n\n# Run rsync to create snapshot\nrsync $OPT $LINK $SRC ${SNAP}$date\n\n# Remove symlink to previous snapshot\nrm -f $LAST\n\n# Create new symlink to latest snapshot for the next backup to hardlink\nln -s ${SNAP}$date $LAST\n```\n\n--link-dest のために既にターゲットに存在しているフルバックアップへのシンボリックリンクが必須です。最新のスナップショットが削除された場合、最新のスナップショットへのシンボリックリンクを再生成する必要があります。--link-dest が動作しているシンボリックリンクを見付けられなかった場合、rsync は差分だけでなくソースファイルの全てをコピーします。\n\nより洗練されたバージョンは、$SNAP/lates の最新のフルバックアップと最後のバックアップからの数回分の変更を保持します。現在のフルバックアップのスナップショット $SNAP/$DATETAG を、変更がないファイルへハードリンクさせるために cp -al を使って生成します:\n\n```\n/usr/local/bin/rsnapshot.sh\n```\n\n```\n#!/bin/sh\n\n## my own rsync-based snapshot-style backup procedure\n## (cc) marcio rps AT gmail.com\n\n# config vars\n\nSRC=\"/home/username/files/\" #dont forget trailing slash!\nSNAP=\"/snapshots/username\"\nOPTS=\"-rltgoi --delay-updates --delete --chmod=a-w\"\nMINCHANGES=20\n\n# run this process with real low priority\n\nionice -c 3 -p $$\nrenice +12  -p $$\n\n# sync\n\nrsync $OPTS $SRC $SNAP/latest >> $SNAP/rsync.log\n\n# check if enough has changed and if so\n# make a hardlinked copy named as the date\n\nCOUNT=$( wc -l $SNAP/rsync.log|cut -d\" \" -f1 )\nif [ $COUNT -gt $MINCHANGES ] ; then\n        DATETAG=$(date +%Y-%m-%d)\n        if [ ! -e $SNAP/$DATETAG ] ; then\n                cp -al $SNAP/latest $SNAP/$DATETAG\n                chmod u+w $SNAP/$DATETAG\n                mv $SNAP/rsync.log $SNAP/$DATETAG\n               chmod u-w $SNAP/$DATETAG\n         fi\nfi\n```\n\nこのスクリプトを systemd のタイマー ユニットから実行することで、よりシンプルにできます。\n\n"
    },
    {
      "title": "システムのフルバックアップ",
      "level": 3,
      "content": "このセクションでは、 rsync を使用して、選択したいくつかのディレクトリを除く / ツリー全体のコピーを転送する方法について説明します。 このアプローチは、 dd を使用した ディスクのクローン よりも優れていると考えられます。これは、異なるサイズ、パーティションテーブル、およびファイルシステムを使用できるためであり、 cp-a を使用したコピーよりも優れているためです。これにより、ファイルのアクセス許可、属性、 アクセス制御リスト および 拡張属性 をより細かく制御できるようになります。\n\nrsync はシステムの実行中でも機能しますが、転送中に変更されたファイルは転送される場合とされない場合があり、転送されたファイルを使用する一部のプログラムの未定義の動作を引き起こす可能性があります。\n\nこのアプローチは、既存の環境を新しい HDD または SSD に移行する場合に適しています。\n\nrootとして次のコマンドを実行して下さい。root権限で実行することで rsync がすべてのシステムファイルにアクセスし、所有権を保持できます:\n\n```\n# rsync -aAXHv --exclude={\"/dev/*\",\"/proc/*\",\"/sys/*\",\"/tmp/*\",\"/run/*\",\"/mnt/*\",\"/media/*\",\"/lost+found\"} / /path/to/backup\n```\n\n-aAX のオプションセットを使用することにより、ファイルはアーカイブモードで転送され、シンボリックリンク、デバイス、アクセス許可、所有権、変更時間、 ACL、 および拡張属性が保持されます。 ターゲット ファイルシステム がこの機能をサポートしていると仮定します。 オプション -H はハードリンクを保持しますが、より多くのメモリを使用します。\n\n​--exclude オプションを指定すると、指定したパターンに一致するファイルが除外されます。​ディレクトリ /dev、 /proc、 /sys、 /tmp、 /run は上記のコマンドに含まれますが、これらのディレクトリの 内容 は除外されます。​これは、起動時にはディレクトリが作成されますが、ディレクトリ自体は作成されないためです。​/lost+foundはファイルシステム固有です。​上記のコマンドは、 bashおよび zsh シェルの両方で使用できるブレース展開に依存します。​別の シェル を使用する場合は、 --exclude パターンを手動で繰り返す必要があります。​除外パターンを引用符で囲むと、 シェル による展開が回避されます。これは、たとえば SSH のバックアップ時に必要です。​除外パスの最後に * を指定すると、ディレクトリ自体がまだ存在しない場合でも作成されます。\n\n- /mnt または /media 以外の場所でシステムをバックアップする場合は、無限ループを回避するために、除外パターンのリストにシステムを追加することを忘れないでください。\n- システムにバインドマウントがある場合は、それらも除外して、バインドマウントされたコンテンツが1回だけコピーされるようにする必要があります。\n- スワップファイル を使用している場合は、必ず除外してください。\n- /home/ ディレクトリをバックアップするかどうかを検討してください。 データが含まれている場合は、システムよりもかなり大きくなる可能性があります。 それ以外の場合は、 /home/*/.thumbnails/*, /home/*/.cache/mozilla/*, /home/*/.cache/chromium/*, と /home/*/.local/share/Trash/* などの重要でないサブディレクトリを除外することを検討してください。 /home/*/.local/share/Trash/* は、システムにインストールされているソフトウェアによって異なります。\n- GVFS がインストールされている場合、 rsync エラーを防ぐために、 /home/*/.gvfs を除外する必要があります。\n- Dhcpcd ≥9.0.0 がインストールされている場合は、 /var/lib/dhcpcd/* ディレクトリを除外します。これは、いくつかのシステムディレクトリをサブディレクトリとしてマウントするためです。\n\n追加の rsync オプションを含めるか、次のようないくつかを削除することをお勧めします。 完全なリストについては、 rsync(1) を参照してください。\n\n- メモリが非常に少ないシステムで実行している場合は、 -H オプションを削除することを検討してください。ただし、最近のほとんどのマシンでは問題ありません。使用するソフトウェアによっては、ファイルシステムに多くのハードリンクが存在する可能性があります(たとえば、 Flatpak を使用している場合)。多くのハードリンクは /usr/ ディレクトリの下にあります。\n- これを同じバックアップディレクトリで複数回実行している場合は、rsync の --delete オプションを追加することをお勧めします。この場合、ソースパスが /* で終わっていないことを確認してください。そうでない場合、このオプションはソースディレクトリのサブディレクトリ内のファイルにのみ影響しますが、存在するファイルには影響しません。\n- 仮想ディスク、 Docker イメージなどのスパースファイルを使用する場合は、 -S オプションを追加する必要があります。\n- --numeric-ids オプションは、ユーザー名とグループ名のマッピングを無効にします。代わりに、数値のグループ ID とユーザー ID が転送されます。これは、 SSH を介してバックアップする場合、またはライブシステムを使用して別のシステムディスクをバックアップする場合に役立ちます。\n- -v の代わりに -info=progress2 オプションを選択すると、転送されるファイルのリストではなく、全体的な進行状況情報と転送速度が表示されます。\n- 再帰時にファイルシステムの境界を越えないようにするには、オプション -x/--one-file-system を追加します。これにより、階層内のマウントポイントをバックアップできなくなります。\n\n"
    },
    {
      "title": "バックアップを復元する",
      "level": 3,
      "content": "バックアップを復元する場合は、実行されたのと同じ rsync コマンドを使用しますが、ソースと宛先を逆にします。\n\n"
    },
    {
      "title": "フィルター規則の高度な使用法",
      "level": 3,
      "content": "包含ルールと除外ルールを個別に指定する代わりに、rsync は単一のフィルター ファイルからこれらすべてを読み取ることができます。次に、rsync はルールを上から順に処理します。最初に一致したルールが優先されます。\n\n```\nbackup.filter\n```\n\n```\n# Exclude patterns\n\n- .thumbnails/***\n- node_modules/***\n- venv/***\n\n# Include patterns\n\n+ /Documents/***\n+ /Books/***\n+ /Music/***\n\n# Exclude everything else\n- /**\n```\n\n*** は、フォルダーとそのすべてのコンテンツを再帰的に照合する特別な rsync パターンです。\n\n詳細については、rsync(1) § PATTERN MATCHING RULES および rsync(1) § FILTER RULES IN DEPTH を確認してください。\n\n次に、以下のように rsync を実行します。\n\n```\n$ rsync -aAXHv --filter=\"merge backup.filter\" $SRC $DEST\n```\n\nキーワードは --filter \"merge ...\" パラメータで、フィルタファイルを受け取り、同期された各ファイルのルールを順番に解析します。\n\n"
    },
    {
      "title": "パスのリストからコピー",
      "level": 3,
      "content": "#フィルター規則の高度な使用法 方法の代わりに、--files-from オプションを使用することもできます。これは、各エントリが改行で区切られたディレクトリまたはファイルパスのリストを含むテキストファイルから入力を受け取ることができます、ユーザーが再帰的なディレクトリのコピーを望む場合は、-a がすでに含まれている場合でも、このオプションに -r フラグを手動で指定する必要があることに注意してください。\n\nたとえば、ディレクトリのリストとすべての再帰ディレクトリは、次のようにアーカイブできます:\n\n```\n$ rsync -aAXHvr --files-from=\"dir_list.txt\" $SRC $DEST\n```\n\n"
    },
    {
      "title": "ファイルシステムのクローニング",
      "level": 2,
      "content": "rsync は、ファイルシステムのメタデータを含む可能な限り多くの情報を保持しながら、ファイルシステム内のすべてのデータのコピーを実行する方法を提供します。これは、ソースファイルシステムと宛先ファイルシステムが同じタイプである必要がないファイルシステムレベルでのデータ複製の手順です。 バックアップ、ファイルシステムの移行、またはデータ復旧に使用できます。\n\nrsync の \"アーカイブ\" モードは、アクセス制御リスト、拡張属性、スパースファイルプロパティなどの特別なファイルシステムメタデータはバックアップされません。ファイルシステムレベルでのクローンを成功させるには、いくつかのオプションを追加する必要があります。\n\n```\nrsync -qaHAXS SOURCE_DIR DESTINATION_DIR\n```\n\nそして、その意味は (manpage から) 次の通りです:\n\n```\n--hard-links, -H         ハードリンクを保持する\n--acls, -A               ACLを保持する(--perms を意味します)\n--xattrs, -X             拡張属性を保持する\n--sparse, -S             null シーケンスを疎らなブロックに変換する\n```\n\nさらに、コピーから除外するツリーの下に他のファイルシステムがマウントされている場合は、-x を使用します。\n\n作成されたコピーは、ファイルシステムレベルで単純に再読み込みして確認できます(例えば、データ復旧の試み後など)そのためには、diff の再帰オプションを使用します:\n\n```\ndiff -r SOURCE_DIR DESTINATION_DIR\n```\n\nrsync を使用し、新しいハードウェアに移行する で説明されているように fstab と ブートローダー を更新することで、ファイルシステムの移行を成功させることができます。これは、ルートファイルシステムを別のファイルシステムに変換する時にも適しています。\n\n"
    },
    {
      "title": "デーモンとして",
      "level": 2,
      "content": "rsync は、ポート 873 で待機しているサーバー上でデーモンとして実行できます。\n\n​テンプレート /etc/rsyncd.conf を編集して共有を設定し、rsyncd.service を スタート します。\n\nクライアントからの使用法 (例:サーバーのコンテンツリスト):\n\n```\n$ rsync rsync://server/share\n```\n\nクライアントからサーバーにファイルを転送する:\n\n```\n$ rsync local-file rsync://server/share/\n```\n\nファイアウォール で TCP ポート 873 を開き、ユーザー認証を使用することを検討してください。\n\n"
    },
    {
      "title": "ファイルのリストから共有する",
      "level": 4,
      "content": "```\n/etc/rsyncd.conf\n```\n\n```\n...\n\n# Needed when crossing filesystem boundaries.\n#use chroot  = no\nread only = yes\n\n...\n\n[sync]\n    path         = /\n# List of files to copy.\n    include from = /backup.list\n# Exclude the rest.\n    exclude      = *\n```\n\nファイルリスト内では、ワイルドカード *** が使用されている場合を除き、すべての 中間パス が必要です:\n\n```\n/backup.list\n```\n\n```\n/etc/\n/etc/conf.d/\n/etc/conf.d/hwclock\n/etc/fonts/***\n```\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- その他の使用例は、こちらで検索できます。 Community Contributions , General Programming フォーラム\n- Howto – local and remote snapshot backup using rsync with hard links ハードリンクによるファイル重複排除、MD5 完全性署名、\"chattr\" 保護、フィルタールール、ディスククォータ、指数分布による保持ポリシー (古いバックアップより新しいバックアップを保存しながらローテーションする) を含みます。\n- Using SSH keys/identity files with rsync\n\n"
    }
  ]
}