{
  "title": "Dm-crypt/Device encryption (Polski)",
  "url": "https://wiki.archlinux.org/title/Dm-crypt/Device_encryption_(Polski)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "W tej sekcji opisano sposób ręcznego wykorzystania dm-crypt z linii poleceń w celu zaszyfrowania systemu.\n\n"
    },
    {
      "title": "Przygotowanie",
      "level": 2,
      "content": "Przed użyciem cryptsetup, zawsze upewnij się, że dm_crypt kernel module jest załadowany.\n\n"
    },
    {
      "title": "Wykorzystanie Cryptsetup",
      "level": 2,
      "content": "Cryptsetup to narzędzie linii poleceń służące do komunikacji z dm-crypt w celu tworzenia, uzyskiwania dostępu i zarządzania zaszyfrowanymi urządzeniami. Narzędzie zostało później rozszerzone, aby obsługiwać różne typy szyfrowania, które opierają się na narzędziu do mapowania jądra systemu Linux i modułach kryptograficznych. Najbardziej znaczącym rozszerzeniem było rozszerzenie Linux Unified Key Setup (LUKS), które przechowuje wszystkie potrzebne informacje dotyczące instalacji dla dm-crypt na samym dysku i streszcza zarządzanie partycjami i kluczami w celu poprawy łatwości użytkowania. Urządzenia dostępne za pośrednictwem urządzenia odwzorowującego urządzenia nazywane są urządzeniami blokowymi. W celu uzyskania dalszych informacji zobacz Disk encryption#Block device encryption.\n\nNarzędzie jest używane w następujący sposób:\n\n```\n# cryptsetup <OPTIONS> <action> <action-specific-options> <device> <dmname>\n```\n\nMa skompilowane ustawienia domyślne dla opcji i trybu szyfrowania, które będą używane, jeśli w wierszu poleceń nie określono żadnych innych. Spójrz na\n\n```\n$ cryptsetup --help\n```\n\nktóry wyświetla opcje, akcje i domyślne parametry trybów szyfrowania w tej kolejności. Pełną listę opcji można znaleźć na stronie podręcznika. Ponieważ różne parametry są wymagane lub opcjonalne, w zależności od trybu szyfrowania i działania, poniższe sekcje wskazują dalej różnice. Szyfrowanie Blockdevice jest szybkie, ale szybkość też ma duże znaczenie. Ponieważ zmiana szyfru urządzenia blokowego po konfiguracji jest trudna, ważne jest wcześniejsze sprawdzenie wydajności dm-crypt dla poszczególnych parametrów:\n\n```\n$ cryptsetup benchmark\n```\n\nmoże podać wskazówki dotyczące wyboru algorytmu i klucza przed instalacją. Jeśli niektóre szyfry AES przodują ze znacznie większą przepustowością, to prawdopodobnie jest sprzętową obsługą CPU.\n\n"
    },
    {
      "title": "Hasła i klucze programu Cryptsetup",
      "level": 3,
      "content": "Szyfrowane urządzenie blokowe jest chronione kluczem. Klucz jest albo:\n\n- hasło: patrz Security#Passwords.\n- plik klucza, patrz #Pliki kluczy.\n\nOba typy kluczy mają domyślne maksymalne rozmiary: hasła mogą zawierać do 512 znaków, a pliki kluczy do 8192 kiB.\n\nWażnym rozróżnieniem LUKS na uwagę w tym momencie jest to, że klucz jest używany do odblokowania klucza głównego urządzenia zaszyfrowanego LUKS i może być zmieniony przy dostępie root. Inne tryby szyfrowania nie obsługują zmiany klucza po konfiguracji, ponieważ nie używają klucza głównego do szyfrowania. Zobacz Disk encryption#Block device encryption po dalsze szczegóły.\n\n"
    },
    {
      "title": "Opcje szyfrowania z dm-crypt",
      "level": 2,
      "content": "Cryptsetup obsługuje różne tryby operacyjne szyfrowania do użycia z dm-crypt. Najczęstszym (i domyślnym) jest\n\n- --type luks\n\nPozostałe są\n\n- --type plain do używania w trybie zwykłym dm-crypt,\n- --type loopaes dla loopaes tryb Legacy, i\n- --type tcrypt dla TrueCrypt tryb zgodności.\n\nPodstawowe opcje kryptograficzne dla szyfrów i skrótów są dostępne dla wszystkich trybów i polegają na kryptograficznych funkcjach jądra. Wszystkie ładowane w czasie wykonywania można wyświetlać za pomocą\n\n```\n$ less /proc/crypto\n```\n\ni są dostępne do użycia jako opcje. Jeśli lista jest krótka, należy wykonać test porównawczy cryptsetup benchmark, który uruchomi ładowanie dostępnych modułów.\n\nPoniżej przedstawiono opcje szyfrowania dla dwóch pierwszych trybów. Zwróć uwagę, że tabele zawierają opcje używane w odpowiednich przykładach w tym artykule, a nie wszystkie dostępne.\n\n"
    },
    {
      "title": "Opcje szyfrowania dla trybu LUKS",
      "level": 3,
      "content": "cryptsetup służąca do skonfigurowania nowego urządzenia dm-crypt w trybie szyfrowania LUKS to luksFormat. W przeciwieństwie do nazwy oznacza to, że nie formatuje urządzenia, ale ustawia nagłówek urządzenia LUKS i szyfruje klucz główny z żądanymi opcjami kryptograficznymi.\n\nPonieważ LUKS jest domyślnym trybem szyfrowania,\n\n```\n# cryptsetup -v luksFormat device\n```\n\nto wszystko, czego potrzeba, aby stworzyć nowe urządzenie LUKS z domyślnymi parametrami ((-v jest opcjonalne). Dla porównania możemy ręcznie określić domyślne opcje:\n\n```\n# cryptsetup -v --cipher aes-xts-plain64 --key-size 256 --hash sha256 --iter-time 2000 --use-urandom --verify-passphrase luksFormat device\n```\n\nWartości domyślne są porównywane z przykładem kryptograficznie wyższego opisu w poniższej tabeli wraz z towarzyszącymi komentarzami:\n\nTable content:\nOpcje | Domyślne ustawienia Cryptsetup 1.7.0 | Przykład | Komentarz\n--cipher -c | aes-xts-plain64 | aes-xts-plain64 | Release 1.6.0 changed the defaults to an AES cipher in XTS mode (see item 5.16 of the FAQ). It is advised against using the previous default --cipher aes-cbc-essiv because of its known issues and practical attacks against them.\n--key-size -s | 256 | 512 | By default a 256 bit key-size is used. Note however that XTS splits the supplied key in half, so to use AES-256 instead of AES-128 you have to set the XTS key-size to 512.\n--hash -h | sha256 | sha512 | Hash algorithm used for key derivation. Release 1.7.0 changed defaults from sha1 to sha256 \"not for security reasons [but] mainly to prevent compatibility problems on hardened systems where SHA1 is already [being] phased out\"[1]. The former default of sha1 can still be used for compatibility with older versions of cryptsetup since it is considered secure (see item 5.20).\n--iter-time -i | 2000 | 5000 | Number of milliseconds to spend with PBKDF2 passphrase processing. Release 1.7.0 changed defaults from 1000 to 2000 to \"try to keep PBKDF2 iteration count still high enough and also still acceptable for users.\"[2]. This option is only relevant for LUKS operations that set or change passphrases, such as luksFormat or luksAddKey. Specifying 0 as parameter selects the compiled-in default..\n--use-{u,}random | --use-urandom | --use-random | Selects which random number generator to use. Quoting the cryptsetup manual page: \"In a low-entropy situation (e.g. in an embedded system), both selections are problematic. Using /dev/urandom can lead to weak keys. Using /dev/random can block a long time, potentially forever, if not enough entropy can be harvested by the kernel.\"\n--verify-passphrase -y | Yes | - | Default only for luksFormat and luksAddKey. No need to type for Arch Linux with LUKS mode at the moment.\n\n-c\n\n-s\n\n-h\n\n-i\n\n-y\n\nJeśli chcesz zagłębić się w funkcje kryptograficzne LUKS, to LUKS specification (na przykład jego dodatki) jest zasobem.\n\n"
    },
    {
      "title": "Opcje szyfrowania dla trybu zwykłego",
      "level": 3,
      "content": "W trybie zwykłym dm-crypt na urządzeniu nie ma klucza głównego, dlatego nie ma potrzeby konfigurowania go. Zamiast tego opcje szyfrowania, które należy zastosować, są używane bezpośrednio do utworzenia odwzorowania między zaszyfrowanym dyskiem a nazwanym urządzeniem. Mapowanie można utworzyć na partycji lub na pełnym urządzeniu. W tym drugim przypadku nie jest wymagana nawet tablica partycji.\n\nAby utworzyć mapowanie w trybie zwykłym z domyślnymi parametrami cryptsetup:\n\n```\n# cryptsetup <options> open --type plain <device> <dmname>\n```\n\nWykonanie go spowoduje podanie hasła, które powinno mieć bardzo wysoką entropię. Poniżej porównanie domyślnych parametrów z przykładem w dm-crypt (Polski)/Encrypting an entire system (Polski)#Zwykły dm-crypt\n\nTable content:\nOption | Cryptsetup 1.7.0 defaults | Example | Comment\n--hash -h | ripemd160 | - | The hash is used to create the key from the passphrase; it is not used on a keyfile.\n--cipher -c | aes-cbc-essiv:sha256 | twofish-xts-plain64 | The cipher consists of three parts: cipher-chainmode-IV generator. Please see Disk encryption#Ciphers and modes of operation for an explanation of these settings, and the DMCrypt documentation for some of the options available.\n--key-size -s | 256 | 512 | The key size (in bits). The size will depend on the cipher being used and also the chainmode in use. Xts mode requires twice the key size of cbc.\n--offset -o | 0 | 0 | The offset from the beginning of the target disk (in bytes) from which to start the mapping\n--key-file -d | default uses a passphrase | /dev/sdZ (or e.g. /boot/keyfile.enc) | The device or file to be used as a key. See #Pliki kluczy for further details.\n--keyfile-offset | 0 | 0 | Offset from the beginning of the file where the key starts (in bytes). This option is supported from cryptsetup 1.6.7 onwards.\n--keyfile-size -l | 8192kB | - (default applies) | Limits the bytes read from the key file. This option is supported from cryptsetup 1.6.7 onwards.\n\n-h\n\n-c\n\n-s\n\n-o\n\n-d\n\n-l\n\nUżywając urządzenia /dev/sdX, powyższy przykład z prawej kolumny daje:\n\n```\n# cryptsetup --cipher=twofish-xts-plain64 --offset=0 --key-file=/dev/sdZ --key-size=512 open --type=plain /dev/sdX enc\n```\n\nW przeciwieństwie do szyfrowania za pomocą LUKS, powyższe polecenie musi być wykonane w pełni za każdym razem, gdy konieczne jest ponowne ustanowienie mapowania, dlatego ważne jest, aby pamiętać szczegóły szyfrowania, hasza i pliku klucza. Możemy teraz sprawdzić, czy mapowanie zostało wykonane:\n\n```\n# fdisk -l\n```\n\nWpis powinien już istnieć /dev/mapper/enc.\n\n"
    },
    {
      "title": "Szyfrowanie urządzeń za pomocą cryptsetup",
      "level": 2,
      "content": "W tej sekcji pokazano, jak wykorzystać opcje tworzenia nowych zaszyfrowanych urządzeń blokowych i uzyskiwania dostępu do nich ręcznie.\n\n"
    },
    {
      "title": "Formatowanie partycji LUKS",
      "level": 4,
      "content": "Aby ustawić partycję jako zaszyfrowaną partycję LUKS wykonaj:\n\n```\n# cryptsetup luksFormat --type luks2 device\n```\n\nZostaniesz poproszony o podanie hasła i jego weryfikację.\n\nZobacz #Szyfrowanie urządzeń w trybie LUKS dla opcji wiersza poleceń.\n\nMożesz sprawdzić wyniki za pomocą:\n\n```\n# cryptsetup luksDump device\n```\n\nZauważysz, że stos nie tylko pokazuje informacje nagłówka szyfrowania, ale także miejsca na klucze używane na partycji LUKS.\n\nPoniższy przykład utworzy zaszyfrowaną partycję root na {{ic|/dev/sda1} przy użyciu domyślnego szyfrowania AES w trybie XTS z efektywnym 256-bitowym szyfrowaniem\n\n```\n# cryptsetup -s 512 luksFormat --type luks2 /dev/sda1\n```\n\nPodczas tworzenia nowej zaszyfrowanej partycji LUKS, plik klucza może być powiązany z partycją podczas jej tworzenia za pomocą:\n\n```\n# cryptsetup luksFormat --type luks2 device /path/to/mykeyfile\n```\n\nZobacz #Pliki kluczy aby uzyskać instrukcje dotyczące generowania plików kluczy i zarządzania nimi.\n\n"
    },
    {
      "title": "Odblokowywanie / mapowanie partycji LUKS za pomocą device mapper",
      "level": 4,
      "content": "Po utworzeniu partycji LUKS można je odblokować.\n\nProces odblokowania zmapuje partycje do nowej nazwy urządzenia za pomocą urządzenia odwzorowującego. To ostrzega o tym jądrze device jest faktycznie zaszyfrowanym urządzeniem i powinno być adresowane za pomocą LUKS przy użyciu /dev/mapper/dm_name aby nie nadpisywać zaszyfrowanych danych. Aby chronić się przed przypadkowym nadpisaniem, przeczytaj o możliwościach backup the cryptheader po zakończeniu konfiguracji.\n\nAby otworzyć zaszyfrowaną partycję LUKS:\n\n```\n# cryptsetup open device dm_name\n```\n\nZostaniesz poproszony o hasło, aby odblokować partycję. Zwykle nazwa odwzorowana przez urządzenie jest opisowa dla funkcji zamapowanej partycji. Na przykład poniższe odblokowuje partycję luks /dev/sda1 i odwzorowuje go na urządzenie odwzorowujące urządzenie o nazwie cryptroot:\n\n```\n# cryptsetup open /dev/sda1 cryptroot\n```\n\nPo otwarciu adres urządzenia głównego partycji będzie /dev/mapper/cryptroot zamiast partycji (np. /dev/sda1).\n\nAby skonfigurować LVM na wierzchu warstwy szyfrowania, plik urządzenia dla zaszyfrowanej grupy woluminów może być podobny /dev/mapper/cryptroot zamiast /dev/sda1. LVM będzie następnie nadawać dodatkowe nazwy wszystkim utworzonym woluminom logicznym, np. /dev/mapper/lvmpool-root i /dev/mapper/lvmpool-swap.\n\nAby zapisać zaszyfrowane dane w partycji, należy uzyskać do nich dostęp za pomocą nazwy zmapowanej urządzenia. Pierwszym etapem dostępu będzie zazwyczaj utworzenie systemu plików. Na przykład:\n\n```\n# mkfs -t ext4 /dev/mapper/cryptroot\n```\n\nUrządzenie /dev/mapper/cryptroot może być zamontowany jak każda inna partycja.\n\nAby zamknąć kontener luks, odmontuj partycję i wykonaj następujące czynności:\n\n```\n# cryptsetup close cryptroot\n```\n\n"
    },
    {
      "title": "Szyfrowanie urządzeń w trybie zwykłym",
      "level": 3,
      "content": "Stworzenie i późniejszy dostęp do dm-crypt Szyfrowania w trybie zwykłym wymaga nie więcej niż korzystania z cryptsetup open akcję z poprawnymi parametrami. Poniżej pokazano, że z dwoma przykładami urządzeń innych niż root, ale dodaje dziwnie, układając je w stos (tj. Drugi jest tworzony wewnątrz pierwszego). Oczywiście układanie szyfrowania podwaja się narzutowo. Oto przykład użycia innego przykładu użycia opcji szyfrowania.\n\nOtwórz akcję z poprawnymi parametrami.\n\nPierwszy program odwzorowujący jest tworzony z domyślnymi ustawieniami \"cryptsetup\", jak opisano w lewej kolumnie tabeli powyżej\n\n```\n# cryptsetup --type plain -v open /dev/sdaX plain1\n```\n\n```\nEnter passphrase: \nCommand successful.\n```\n\nTeraz dodajemy do niego drugie urządzenie blokowe, używając różnych parametrów szyfrowania oraz z (opcjonalnym) offsetem, tworzymy system plików i montujemy go\n\n```\n# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10  open /dev/mapper/plain1 plain2\n```\n\n```\nEnter passphrase:\n```\n\n```\n# lsblk -p\n```\n\n```\nNAME                                                     \n /dev/sda                                     \n ├─/dev/sdaX          \n │ └─/dev/mapper/plain1     \n │   └─/dev/mapper/plain2              \n ...\n```\n\n```\n# mkfs -t ext2 /dev/mapper/plain2\n# mount -t ext2 /dev/mapper/plain2 /mnt\n# echo \"This is stacked. one passphrase per foot to shoot.\" > /mnt/stacked.txt\n```\n\nZamykamy stos, aby sprawdzić, czy dostęp działa\n\n```\n# cryptsetup close plain2\n# cryptsetup close plain1\n```\n\nNajpierw spróbujmy bezpośrednio otworzyć system plików:\n\n```\n# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/sdaX plain2\n```\n\n```\n# mount -t ext2 /dev/mapper/plain2 /mnt\n```\n\n```\nmount: wrong fs type, bad option, bad superblock on /dev/mapper/plain2,\n      missing codepage or helper program, or other error\n```\n\nDlaczego to nie zadziałało? Ponieważ blok startowy \"plain2\" (10) is still encrypted with the cipher from \"plain1\". It can only be accessed via the stacked mapper. The error is arbitrary though, trying a wrong passphrase or wrong options will yield the same. dla dm-crypt tryb zwykły, open akcja nie spowoduje błędu.\n\nPonowna próba w prawidłowej kolejności:\n\n```\n# cryptsetup close plain2    # dysfunctional mapper from previous try\n```\n\n```\n# cryptsetup --type plain open /dev/sdaX plain1\n```\n\n```\nEnter passphrase:\n```\n\n```\n# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/mapper/plain1 plain2\n```\n\n```\nEnter passphrase:\n```\n\n```\n# mount /dev/mapper/plain2 /mnt && cat /mnt/stacked.txt\n```\n\n```\nThis is stacked. one passphrase per foot to shoot.\n```\n\ndm-crypt poradzi sobie ze skumulowanym szyfrowaniem w niektórych mieszanych trybach. Na przykład tryb LUKS może być ustawiony w stosie na maperze \"\"plain1\". Nagłówek zostałby zaszyfrowany wewnątrz \"plain1\", gdy jest zamknięty.\n\nAvailable for plain mode only is the option --shared. With it a single device can be segmented into different non-overlapping mappers. We do that in the next example, using a loopaes compatible cipher mode for \"plain2\" this time:\n\n```\n# cryptsetup --type plain --offset 0 --size 1000 open /dev/sdaX plain1\n```\n\n```\nEnter passphrase:\n```\n\n```\n# cryptsetup --type plain --offset 1000 --size 1000 --shared --cipher=aes-cbc-lmk --hash=sha256 open /dev/sdaX plain2\n```\n\n```\nEnter passphrase:\n```\n\n```\n# lsblk -p\n```\n\n```\nNAME                    \ndev/sdaX                    \n├─/dev/sdaX               \n│ ├─/dev/mapper/plain1     \n│ └─/dev/mapper/plain2     \n...\n```\n\nJak pokazuje devicetree, oba znajdują się na tym samym poziomie, tj. Nie są ułożone w stos, a \"plain2\" można otwierać indywidualnie.\n\n"
    },
    {
      "title": "Zarządzanie kluczami",
      "level": 3,
      "content": "Możliwe jest zdefiniowanie do 8 różnych kluczy na partycję LUKS. Umożliwia to użytkownikowi tworzenie kluczy dostępu do składowania kopii zapasowej: W tak zwanym kluczowym zabezpieczeniu, jeden klucz jest używany do codziennego użytku, drugi jest przechowywany w depozycie, aby uzyskać dostęp do partycji w przypadku, gdy dzienne hasło zostało zapomniane lub plik klucza jest zagubiony / uszkodzony. Również inny klucz-gniazdo może być użyty do przyznania dostępu do partycji użytkownikowi poprzez wydanie drugiego klucza, a następnie ponowne jego unieważnienie.\n\nPo utworzeniu zaszyfrowanej partycji tworzona jest początkowa partia klawiszy 0 (jeśli żadna inna nie została określona ręcznie). Dodatkowe keyslots są ponumerowane od 1 do 7. Które keyslots są używane można zobaczyć poprzez wydanie\n\n```\n# cryptsetup luksDump /dev/<device> | grep BLED\n```\n\n```\nKey Slot 0: ENABLED\nKey Slot 1: ENABLED\nKey Slot 2: ENABLED\nKey Slot 3: DISABLED\nKey Slot 4: DISABLED\nKey Slot 5: DISABLED\nKey Slot 6: DISABLED\nKey Slot 7: DISABLED\n```\n\nGdzie <urządzenie> jest woluminem zawierającym nagłówek LUKS. To i wszystkie poniższe polecenia w tej sekcji również działają na pliki kopii zapasowej nagłówka.\n\n"
    },
    {
      "title": "Dodawanie kluczy LUKS",
      "level": 4,
      "content": "Dodanie nowych keyslots odbywa się za pomocą cryptsetup z akcją luksAddKey. Dla bezpieczeństwa zawsze, to jest również dla już odblokowanych urządzeń, należy poprosić o ważny istniejący klucz (\"dowolne hasło\") przed wprowadzeniem nowego:\n\n```\n# cryptsetup luksAddKey /dev/<device> (/path/to/<additionalkeyfile>)\n```\n\n```\nEnter any passphrase:\nEnter new passphrase for key slot:\nVerify passphrase:\n```\n\nJeżeli /path/to/<additionalkeyfile> jest podana, cryptsetup doda nowy klucz dla <additionalkeyfile>. W przeciwnym razie nowe hasło zostanie wyświetlone dwukrotnie. Aby użyć istniejącego \"pliku klucza\" do autoryzacji akcji, należy --key-file or -d opcja, po której następuje \"stary\" plik <keyfile>, spróbuje odblokować wszystkie dostępne klucze keysfile:\n\n```\n# cryptsetup luksAddKey /dev/<device> (/path/to/<additionalkeyfile>) -d /path/to/<keyfile>\n```\n\nJeśli zamierza się używać wielu kluczy i zmieniać lub odwoływać je, to --key-slot lub -S Opcja ta może być użyta do określenia gniazda:\n\n```\n# cryptsetup luksAddKey /dev/<device> -S 6\n```\n\n```\nEnter any passphrase: \nEnter new passphrase for key slot: \nVerify passphrase:\n```\n\n```\n# cryptsetup luksDump /dev/sda8 | grep 'Slot 6'\n```\n\n```\nKey Slot 6: ENABLED\n```\n\nAby pokazać powiązaną akcję w tym przykładzie, od razu decydujemy się zmienić klucz:\n\n```\n# cryptsetup luksChangeKey /dev/<device> -S 6\n```\n\n```\nEnter LUKS passphrase to be changed: \nEnter new LUKS passphrase:\n```\n\nprzed dalszym usuwaniem.\n\n"
    },
    {
      "title": "Usuwanie kluczy LUKS",
      "level": 4,
      "content": "Istnieją trzy różne działania mające na celu usuwanie kluczy z nagłówka:\n\n- luksRemoveKey służy do usunięcia klucza, określając jego hasło/plik-klucza.\n- luksKillSlot można użyć do usunięcia klucza z określonego gniazda klucza (przy użyciu innego klucza). Oczywiście jest to niezwykle przydatne, jeśli zapomniałeś hasła, zgubiłeś plik klucza lub nie masz do niego dostępu.\n- luksErase służy do szybkiego usuwania \"aktywnych\" kluczy.\n\n- Wszystkie powyższe czynności można wykorzystać do nieodwracalnego usunięcia ostatniego aktywnego klucza do zaszyfrowanego urządzenia!\n- Polecenie luksErase zostało dodane w wersji 1.6.4, aby szybko uzyskać dostęp do urządzenia Nuke. Ta czynność nie spowoduje wyświetlenia prawidłowego hasła! Nie spowoduje to wyczyszczenia nagłówka LUKS, ale wszystkich kluczy jednocześnie, a zatem nie będzie można odzyskać dostępu, chyba że masz poprawną kopię zapasową nagłówka LUKS.\n\nDla powyższego ostrzeżenia dobrze jest wiedzieć, że klucz, który chcemy zachować, jest ważny. Łatwym sprawdzeniem jest odblokowanie urządzenia za pomocą opcji -v, która określa, który slot zajmuje:\n\n```\n# cryptsetup -v open /dev/<device> testcrypt\n```\n\n```\nEnter passphrase for /dev/<device>: \nKey slot 1 unlocked.\nCommand successful.\n```\n\nTeraz możemy usunąć klucz dodany w poprzednim podsekcji za pomocą jego hasła:\n\n```\n# cryptsetup luksRemoveKey /dev/<device>\n```\n\n```\nEnter LUKS passphrase to be deleted:\n```\n\nGdybyśmy użyli tego samego hasła dla dwóch klawiszy, pierwszy slot zostałby teraz wyczyszczony. Ponowne wykonanie go spowoduje usunięcie drugiego.\n\nAlternatywnie możemy określić kluczowy slot:\n\n```\n# cryptsetup luksKillSlot /dev/<device> 6\n```\n\n```\nEnter any remaining LUKS passphrase:\n```\n\nNależy pamiętać, że w obu przypadkach potwierdzenie nie było wymagane.\n\n```\n# cryptsetup luksDump /dev/sda8 | grep 'Slot 6'\n```\n\n```\nKey Slot 6: DISABLED\n```\n\nAby powtórzyć powyższe ostrzeżenie: jeśli to samo hasło zostało użyte w kluczowym gnieździe 1 i 6, obie karty zniknęłyby teraz.\n\n"
    },
    {
      "title": "Kopia zapasowa i przywracanie",
      "level": 3,
      "content": "Jeśli nagłówek zaszyfrowanej partycji LUKS zostanie zniszczony, nie będzie można odszyfrować danych. Jest to tak samo dylemat, jak zapomnienie hasła lub uszkodzenie pliku klucza używanego do odblokowania partycji. Uszkodzenia mogą pojawić się z własnej winy podczas ponownej partycjonowania dysku w późniejszym czasie lub przez programy innych producentów błędnie interpretujące tabelę partycji. Dlatego posiadanie kopii zapasowej nagłówka i przechowywanie go na innym dysku może być dobrym pomysłem.\n\n"
    },
    {
      "title": "Kopia zapasowa za pomocą cryptsetup",
      "level": 4,
      "content": "Cryptsetup' luksHeaderBackup Działanie przechowuje binarną kopię zapasową nagłówku LUKS i obszaru keyslot:\n\n```\n# cryptsetup luksHeaderBackup /dev/<device> --header-backup-file /mnt/<backup>/<file>.img\n```\n\ngdzie <device> to partycja zawierająca wolumin LUKS.\n\n```\n# mkdir /root/<tmp>/\n# mount ramfs /root/<tmp>/ -t ramfs\n# cryptsetup luksHeaderBackup /dev/<device> --header-backup-file /root/<tmp>/<file>.img\n# gpg2 --recipient <User ID> --encrypt /root/<tmp>/<file>.img \n# cp /root/<tmp>/<file>.img.gpg /mnt/<backup>/\n# umount /root/<tmp>\n```\n\n"
    },
    {
      "title": "Przywracanie za pomocą cryptsetup",
      "level": 4,
      "content": "Aby uniknąć przywrócenia złego nagłówka, możesz upewnić się, że działa, używając go zdalnie --header pierwszy:\n\n```\n# cryptsetup -v --header /mnt/<backup>/<file>.img open /dev/<device> test\n```\n\n```\nKey slot 0 unlocked.\nCommand successful.\n```\n\n```\n# mount /dev/mapper/test /mnt/test && ls /mnt/test \n# umount /mnt/test \n# cryptsetup close test\n```\n\nPo pomyślnym sprawdzeniu można wykonać przywracanie:\n\n```\n# cryptsetup luksHeaderRestore /dev/<device> --header-backup-file ./mnt/<backup>/<file>.img\n```\n\nTeraz wszystkie obszary keyslot są nadpisywane; tylko aktywne keyslots z pliku kopii zapasowej są dostępne po wydaniu polecenia.\n\n"
    },
    {
      "title": "Ręczne tworzenie kopii zapasowych i przywracanie",
      "level": 4,
      "content": "Nagłówek zawsze znajduje się na początku urządzenia, a kopia zapasowa może być również wykonywana bez dostępu do \"cryptsetup\". Najpierw musisz znaleźć offset dla zaszyfrowanej partycji:\n\n```\n# cryptsetup luksDump /dev/<device> | grep \"Payload offset\"\n```\n\n```\nPayload offset:\t4040\n```\n\nPo drugie sprawdź rozmiar sektora dysku\n\n```\n# fdisk -l /dev/<device> | grep \"Sector size\"\n```\n\n```\nSector size (logical/physical): 512 bytes / 512 bytes\n```\n\nTeraz, gdy znasz wartości, możesz wykonać kopię zapasową nagłówka za pomocą prostej komendy dd:\n\n```\n# dd if=/dev/<device> of=/path/to/<file>.img bs=512 count=4040\n```\n\ni przechowuj go bezpiecznie.\n\nPrzywracanie można następnie wykonać przy użyciu tych samych wartości, co podczas tworzenia kopii zapasowej:\n\n```\n# dd if=./<file>.img of=/dev/<device> bs=512 count=4040\n```\n\n"
    },
    {
      "title": "Ponowne szyfrowanie urządzeń",
      "level": 3,
      "content": "The cryptsetup ppakiet zawiera narzędzie \"cryptsetup-reencrypt\". Może być użyty do konwersji istniejącego niezaszyfrowanego systemu plików na zaszyfrowany LUKS (opcja --new) i trwale usunąć szyfrowanie LUKS (--decrypt) z urządzenia. Jak sama nazwa wskazuje, może być również użyty do ponownego zaszyfrowania istniejącego zaszyfrowanego urządzenia LUKS, jednak ponowne szyfrowanie nie jest możliwe w przypadku odłączonego nagłówka LUKS lub innych trybów szyfrowania (na przykład w trybie zwykłym). W celu ponownego szyfrowania można zmienić #Opcje szyfrowania dla trybu LUKS. cryptsetup-reencryptDziałania można wykonywać tylko dla niezamontowanych urządzeń. Zobacz cryptsetup-reencrypt(8) po więcej informacji.\n\nJednym z zastosowań ponownego szyfrowania może być ponowne zabezpieczenie danych po złamaniu hasła lub pliku klucza i nie można mieć pewności, że nie otrzymano żadnej kopii nagłówka LUKS. Na przykład, jeśli tylko hasło zostało naruszone, ale nie nastąpił fizyczny dostęp do urządzenia, wystarczy zmienić odpowiednie hasło / klucz tylko (#Zarządzanie kluczami).\n\nPoniżej przedstawiono przykład szyfrowania niezaszyfrowanej partycji systemu plików i ponownego szyfrowania istniejącego urządzenia LUKS.\n\n"
    },
    {
      "title": "Zaszyfruj niezaszyfrowany system plików",
      "level": 4,
      "content": "Nagłówek szyfrowania LUKS jest zawsze przechowywany na początku dysku. Ponieważ istniejącemu systemowi plików zwykle przydzielane są wszystkie sektory partycji, pierwszym krokiem jest zmniejszenie go, aby zrobić miejsce dla nagłówka LUKS.\n\nDomyślny szyfr LUKS nagłówka wymaga 4096 512-bajtowych sektorów. Sprawdziliśmy już miejsce i utrzymujemy prostotę, zmniejszając istniejący system plików ext4 na /dev/sdaX do jego obecnego możliwego minimum:\n\n```\n# umount /mnt\n```\n\n```\n# e2fsck -f /dev/sdaX\n```\n\n```\ne2fsck 1.43-WIP (18-May-2015)\nPass 1: Checking inodes, blocks, and sizes\n...\n/dev/sda6: 12/166320 files (0.0% non-contiguous), 28783/665062 blocks\n```\n\n```\n# resize2fs -M /dev/sdaX\n```\n\n```\nresize2fs 1.43-WIP (18-May-2015)\nResizing the filesystem on /dev/sdaX to 26347 (4k) blocks.\nThe filesystem on /dev/sdaX is now 26347 (4k) blocks long.\n```\n\nTeraz zaszyfrujemy go, używając domyślnego szyfru, którego nie musimy jawnie określać. Uwaga: nie ma jeszcze opcji (jeszcze) do podwójnego sprawdzenia hasła przed rozpoczęciem szyfrowania, należy uważać, aby nie pomylić:\n\n```\n# cryptsetup-reencrypt /dev/sdaX --new  --reduce-device-size 4096S\n```\n\n```\nWARNING: this is experimental code, it can completely break your data.\nEnter new passphrase: \nProgress: 100,0%, ETA 00:00, 2596 MiB written, speed  37,6 MiB/s\n```\n\nPo zakończeniu szyfrowanie zostało wykonane na pełną partycję, tj. Nie tylko przestrzeń, do której skrócił się system plików (sdaX ma 2.6GiB a procesor użyty w tym przykładzie nie ma instrukcji sprzętowych AES). Ostatnim krokiem jest ponowne rozszerzenie systemu plików zaszyfrowanego urządzenia, aby zajęło dostępne miejsce:\n\n```\n# cryptsetup open /dev/sdaX recrypt\n```\n\n```\nEnter passphrase for /dev/sdaX: \n...\n```\n\n```\n# resize2fs /dev/mapper/recrypt\n```\n\n```\nresize2fs 1.43-WIP (18-May-2015)\nResizing the filesystem on /dev/mapper/recrypt to 664807 (4k) blocks.\nThe filesystem on /dev/mapper/recrypt is now 664807 (4k) blocks long.\n```\n\n```\n# mount /dev/mapper/recrypt /mnt\n```\n\ni gotowe.\n\n"
    },
    {
      "title": "Ponowne szyfrowanie istniejącej partycji LUKS",
      "level": 4,
      "content": "W tym przykładzie istniejące urządzenie LUKS jest ponownie szyfrowane.\n\nNote: **niezawodnej kopii zapasowej** \n\nAby ponownie zaszyfrować urządzenie za pomocą istniejących opcji szyfrowania, nie trzeba ich określać. Prosty:\n\n```\n# cryptsetup-reencrypt /dev/sdaX\n```\n\n```\nWARNING: this is experimental code, it can completely break your data.\nEnter passphrase for key slot 0: \nProgress: 100,0%, ETA 00:00, 2596 MiB written, speed  36,5 MiB/s\n```\n\nwykonuje to.\n\nMożliwym przypadkiem jest ponowne szyfrowanie urządzeń LUKS, które mają nieaktualne opcje szyfrowania. Oprócz powyższego ostrzeżenia o prawidłowym określeniu opcji, możliwość zmiany nagłówka LUKS może być również ograniczona przez jego rozmiar. Na przykład, jeśli urządzenie zostało początkowo zaszyfrowane przy użyciu szyfrowania w trybie CBC i klucza 128-bitowego, nagłówek LUKS będzie o połowę mniejszy od wspomnianych {{ic|4096} sektorów:\n\n```\n# cryptsetup luksDump /dev/sdaX |grep -e \"mode\" -e \"Payload\" -e \"MK bits\"\n```\n\n```\nCipher mode:   \tcbc-essiv:sha256\nPayload offset:\t2048\nMK bits:       \t128\n```\n\nO ile możliwe jest uaktualnienie szyfrowania takiego urządzenia, jest to obecnie możliwe tylko w dwóch etapach. Najpierw ponownie zaszyfruj z tymi samymi opcjami szyfrowania, ale używając --reduce-device-size opcja utworzenia dodatkowej przestrzeni dla większego nagłówka LUKS. Po drugie, ponownie sprowadź całe urządzenie z żądanym szyfrem. Z tego powodu i faktu, że kopia zapasowa powinna być tworzona w każdym przypadku, tworzenie nowego, świeżego urządzenia zaszyfrowanego do przywrócenia jest zawsze szybszą opcją.\n\n"
    },
    {
      "title": "Zmiana rozmiaru zaszyfrowanych urządzeń",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nJeśli urządzenie pamięciowe zaszyfrowane za pomocą dm-crypt jest klonowane (za pomocą narzędzia takiego jak dd) do innego większego urządzenia, podstawowe urządzenie dm-crypt musi zostać powiększone, aby wykorzystać całą przestrzeń.\n\nW tym przykładzie urządzeniem docelowym jest /dev/sdX2, zostanie użyta cała dostępna przestrzeń obok partycji:\n\n```\n# cryptsetup luksOpen /dev/sdX2 sdX2\n# cryptsetup resize sdX2\n```\n\nNastępnie należy zmienić rozmiar podstawowego systemu plików.\n\n"
    },
    {
      "title": "Loopback filesystem",
      "level": 3,
      "content": "Zakładając, że zaszyfrowany system plików loopback jest zamontowany w /mnt/secret, na przykład następujący dm-crypt (Polski)/Encrypting a non-root file system (Polski)#Loop device, najpierw odmontuj zaszyfrowany kontener:\n\n```\n# umount /mnt/secret\n# cryptsetup close secret\n# losetup -d /dev/loop0\n```\n\nNastępnie rozwiń plik kontenera o rozmiar danych, które chcesz dodać:\n\nNote: **two** \n\n```\n# dd if=/dev/urandom bs=1M count=1024 | cat - >> /bigsecret\n```\n\nTeraz zmapuj kontener na loop device:\n\n```\n# losetup /dev/loop0 /bigsecret\n# cryptsetup open /dev/loop0 secret\n```\n\nNastępnie zmień rozmiar zaszyfrowanej części kontenera na maksymalny rozmiar pliku kontenera:\n\n```\n# cryptsetup resize secret\n```\n\nNa koniec przeprowadź test systemu plików i, jeśli jest w porządku, zmień jego rozmiar (przykład dla ext2/3/4):\n\n```\n# e2fsck -f /dev/mapper/secret\n# resize2fs /dev/mapper/secret\n```\n\nMożesz teraz ponownie zamontować kontener:\n\n```\n# mount /dev/mapper/secret /mnt/secret\n```\n\n"
    },
    {
      "title": "Pliki kluczy",
      "level": 2,
      "content": "Co to jest plik klucza?\n\nPlik klucza to plik, którego dane są używane jako hasło do odblokowania zaszyfrowanego woluminu. Oznacza to, że jeśli taki plik zostanie utracony lub zmieniony, odszyfrowanie woluminu może być niemożliwe.\n\nDlaczego warto użyć pliku klucza?\n\nIstnieje wiele rodzajów plików kluczy. Każdy rodzaj użytego pliku klucza ma zalety i wady:\n\n"
    },
    {
      "title": "hasło",
      "level": 4,
      "content": "Jest to plik klucza zawierający proste hasło. Zaletą tego typu pliku kluczy jest to, że jeśli plik zostanie utracony, zawarte w nim dane są znane i, miejmy nadzieję, łatwo zapamiętane przez właściciela zaszyfrowanego woluminu. Jednak wadą jest to, że nie dodaje żadnego zabezpieczenia przed wprowadzeniem hasła podczas początkowego uruchomienia systemu.\n\nPrzykład: 1234\n\n```\n# echo -n 'your_passphrase' > /path/to/<keyfile>\n# chown root:root /path/to/<keyfile>; chmod 400 /path/to/<keyfile>\n```\n\n"
    },
    {
      "title": "randomtext",
      "level": 4,
      "content": "Jest to plik klucza zawierający blok losowych znaków. Zaletą tego typu pliku kluczy jest to, że jest on znacznie bardziej odporny na ataki słownikowe niż proste hasło. W tej sytuacji można wykorzystać dodatkową moc plików kluczy, która jest długością używanych danych. Ponieważ nie jest to ciąg przeznaczony do zapamiętania przez osobę do wpisu, trywialne jest tworzenie plików zawierających tysiące losowych znaków jako klucz. Wadą jest to, że jeśli ten plik zostanie utracony lub zmieniony, najprawdopodobniej dostęp do zaszyfrowanego woluminu bez kopii zapasowej hasła będzie niemożliwy.\n\nPrzykład: fjqweifj830149-57 819y4my1-38t1934yt8-91m 34co3;t8y;9p3y-\n\n"
    },
    {
      "title": "binary",
      "level": 4,
      "content": "Jest to plik binarny, który został zdefiniowany jako plik klucza. Podczas identyfikowania plików jako kandydatów do pliku klucza zaleca się wybrać pliki, które są stosunkowo statyczne, takie jak zdjęcia, muzyka, klipy wideo. Zaletą tych plików jest to, że pełnią podwójną funkcję, co może utrudnić identyfikację ich jako plików kluczy. Zamiast pliku tekstowego z dużą ilością losowego tekstu, plik klucza będzie wyglądać jak zwykły plik obrazu lub klip muzyczny przypadkowego obserwatora. Wadą jest to, że jeśli ten plik zostanie utracony lub zmieniony, najprawdopodobniej dostęp do zaszyfrowanego woluminu bez kopii zapasowej hasła będzie niemożliwy. Dodatkowo istnieje teoretyczna utrata losowości w porównaniu z losowo wygenerowanym plikiem tekstowym. Wynika to z faktu, że obrazy, filmy i muzyka mają pewien nierozerwalny związek między sąsiednimi bitami danych, które nie istnieją dla pliku tekstowego. Jest to jednak kontrowersyjne i nigdy nie zostało publicznie wykorzystane.\n\nPrzykład: obrazy, tekst, wideo ...\n\n"
    },
    {
      "title": "Przechowywanie pliku klucza w systemie plików",
      "level": 4,
      "content": "Plik klucza może mieć dowolną treść i rozmiar.\n\nTutaj dd służy do generowania pliku kluczy o 2048 losowych bajtach, przechowując go w pliku /etc/mykeyfile\n\n```\n# dd bs=512 count=4 if=/dev/urandom of=/etc/mykeyfile\n```\n\nJeśli planujesz przechowywać plik klucza na urządzeniu zewnętrznym, możesz po prostu zmienić plik wyjściowy na odpowiedni katalog:\n\n```\n# dd bs=512 count=4 if=/dev/urandom of=/media/usbstick/mykeyfile\n```\n\nAby odmówić dostępu innym użytkownikom root:\n\n```\n# chmod 600 /etc/mykeyfile\n```\n\nJeśli przechowujesz tymczasowy plik kluczy na fizycznym urządzeniu magazynującym i chcesz go usunąć, pamiętaj, aby nie tylko usunąć plik klucza później, ale użyj czegoś podobnego\n\n```\n# shred --remove --zero mykeyfile\n```\n\naby go bezpiecznie zastąpić. W przypadku nadmiernie obciążonych systemów plików, takich jak FAT lub ext2, będzie to wystarczające, natomiast w przypadku kronikowania systemów plików, sprzętu pamięci flash i innych przypadków zdecydowanie zaleca się wyczyszczenie całego dysku.\n\n"
    },
    {
      "title": "Przechowywanie pliku kluczy w ramfs",
      "level": 4,
      "content": "Alternatywnie możesz zamontować ramfs do tymczasowego przechowywania pliku klucza:\n\n```\n# mkdir /root/myramfs\n# mount ramfs /root/myramfs/ -t ramfs\n# cd /root/myramfs\n```\n\nZaletą jest to, że znajduje się on w pamięci RAM, a nie na dysku fizycznym, dlatego nie można go odzyskać po odmontowaniu ramfów. Po skopiowaniu pliku klucza do innego bezpiecznego i trwałego systemu plików, odmontuj pliki ramfs ponownie\n\n```\n# umount /root/myramfs\n```\n\n"
    },
    {
      "title": "Konfigurowanie LUKS do korzystania z pliku klucza",
      "level": 3,
      "content": "Dodaj keylot dla pliku klucza do nagłówka LUKS:\n\n```\n# cryptsetup luksAddKey /dev/sda2 /etc/mykeyfile\n```\n\n```\nEnter any LUKS passphrase:\nkey slot 0 unlocked.\nCommand successful.\n```\n\n"
    },
    {
      "title": "Ręczne odblokowywanie partycji przy użyciu pliku klucza",
      "level": 3,
      "content": "Użyj opcji --key-file podczas otwierania urządzenia LUKS:\n\n```\n# cryptsetup open /dev/sda2 dm_name --key-file /etc/mykeyfile\n```\n\n"
    },
    {
      "title": "Odblokowywanie dodatkowej partycji podczas rozruchu",
      "level": 3,
      "content": "Jeśli plik klucza dla dodatkowego systemu plików jest przechowywany w zaszyfrowanym katalogu głównym, jest bezpieczny, gdy system jest wyłączony, ale można go pobrać, aby automatycznie odblokować gniazdo podczas rozruchu za pośrednictwem crypttab. Od pierwszego przykładu powyżej przy użyciu UUID:\n\n```\n/etc/crypttab\n```\n\n```\nhome    UUID=<UUID identifier>    /etc/mykeyfile\n```\n\njest wszystko potrzebne do odblokowania, i\n\n```\n/etc/fstab\n```\n\n```\n/dev/mapper/home        /home   ext4        defaults        0       2\n```\n\ndo montowania urządzenia blokowego LUKS z wygenerowanym plikiem klucza.\n\n"
    },
    {
      "title": "Odblokowywanie partycji głównej podczas rozruchu",
      "level": 3,
      "content": "Jest to po prostu kwestia skonfigurowania mkinitcpio w celu włączenia niezbędnych modułów lub plików i skonfigurowania parametru jądra cryptkey, aby wiedział, gdzie znaleźć plik klucza.\n\nPoniżej przedstawiono dwa przypadki:\n\n1. Używanie pliku kluczy przechowywanego na nośniku zewnętrznym (tutaj pamięć USB)\n1. Używanie pliku klucza osadzonego w initramfs\n\n"
    },
    {
      "title": "Z plikiem kluczy przechowywanym na zewnętrznym nośniku",
      "level": 4,
      "content": "Musisz dodać moduł do swojego /etc/mkinitcpio.confdla systemu plików napędu (vfat moduł w poniższym przykładzie):\n\n```\nMODULES=(vfat)\n```\n\nW tym przykładzie zakłada się, że używasz dysku USB sformatowanego w systemie FAT (vfat moduł). Zastąp te nazwy modułów, jeśli używasz innego systemu plików na dysku USB (np. ext2) lub inną codepage. Jeśli skarga dotyczy złej superbloku i złej strony kodowej przy starcie, potrzebny jest dodatkowy moduł codepage do załadowania. Na przykład możesz potrzebować nls_iso8859-1moduł dla iso8859-1 codepage.\n\nJeśli masz klawiaturę inną niż amerykańska, może okazać się użyteczne załadowanie układu klawiatury przed monitem o wprowadzenie hasła w celu odblokowania partycji głównej podczas rozruchu. Do tego będziesz potrzebował keymap hak przed encrypt.\n\nRegenerate the initramfs.\n\nDodaj następujące opcje do kernel parameters jeśli używasz encrypt hak. Jeśli używasz sd-encrypt Zobacz dm-crypt/System configuration#Using systemd-cryptsetup-generator.\n\n```\ncryptdevice=/dev/<partition1>:root cryptkey=/dev/<partition2>:<fstype>:<path>\n```\n\nNa przykład:\n\n```\ncryptdevice=/dev/sda3:root cryptkey=/dev/sdb1:vfat:/keys/secretkey\n```\n\nChoosing a plain filename for your key provides a bit of 'security through obscurity', but be aware the kernel command line is recorded in the kernel's log (dmesg). The keyfile can not be a hidden file, that means the filename must not start with a dot, or the encrypt hook will fail to find the keyfile during the boot process. Alternatively, one could hide the keyfile between the partitions and use:\n\n```\ncryptkey=/dev/sdb1:offset:size\n```\n\nZaletą jest to, że trudniej jest przypadkowo usunąć klucz.\n\nNazwa węzłów urządzeń, takich jak /dev/sdb1, nie ma gwarancji, że pozostanie takie samo podczas restartu. Bardziej niezawodny jest dostęp do urządzenia z trwałym nazwaniem urządzeń blokowych udev. Aby upewnić się, że szyfrowany klucz znajdzie plik klucza podczas odczytu go z zewnętrznego urządzenia pamięci masowej, należy użyć nazw stałych urządzeń blokowych. Zobacz artykuł na temat trwałych nazw urządzeń blokowych.\n\n"
    },
    {
      "title": "Z plikiem kluczy osadzonym w initramfs",
      "level": 4,
      "content": "Note: **wtedy** \n\nTa metoda pozwala na użycie specjalnie nazwanego pliku klucza, który zostanie osadzony w pliku initramfs i odbierane przez encrypt hookaby odblokować główny system plików (cryptdevice) automatycznie. Może być przydatne zastosowanie podczas korzystania z GRUB early cryptodisk w celu uniknięcia wprowadzania dwóch haseł podczas rozruchu.\n\nZaszyfrowanie pozwala użytkownikowi określić plik klucza za pomocą parametru jądra cryptkey: w przypadku initramfs, składnia to rootfs: rootfs:path Zobacz dm-crypt/System configuration#cryptkey. Poza tym ten parametr jądra jest domyślnie używany /crypto_keyfile.bin, a jeśli initramfs zawiera poprawny klucz o tej nazwie, deszyfrowanie nastąpi automatycznie bez potrzeby konfiguracji cryptkey parametr.\n\nJeśli korzystasz z sd-encrypt zamiast encrypt, określ lokalizację pliku klucza za pomocą parametru jądra rd.luks.key. Zobacz dm-crypt/System configuration#rd.luks.key.\n\nWygeneruj plik klucza, nadaj mu odpowiednie uprawnienia i dodaj go jako klucz LUKS:\n\n```\n# dd bs=512 count=4 if=/dev/urandom of=/crypto_keyfile.bin\n# chmod 000 /crypto_keyfile.bin\n# chmod 600 /boot/initramfs-linux*\n# cryptsetup luksAddKey /dev/sdX# /crypto_keyfile.bin\n```\n\nDołącz klucz do mkinitcpio's FILES array:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nFILES=(/crypto_keyfile.bin)\n```\n\nWreszcie zregeneruj initramfs.\n\nPrzy następnym ponownym uruchomieniu należy tylko raz wpisać hasło do odszyfrowania kontenera.\n\n(source)\n\n"
    }
  ]
}