{
  "title": "Unified Extensible Firmware Interface (Español)",
  "url": "https://wiki.archlinux.org/title/Unified_Extensible_Firmware_Interface_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **Este artículo o sección necesita ser traducido.** Este artículo o sección necesita ser traducido.\n\nEste artículo o sección necesita ser traducido.\n\nNote: **2018-08-31** \n\nArtículos relacionados\n\n- EFI system partition (Español)\n- Arch boot process (Español)\n- GUID Partition Table (Español)\n- Secure Boot\n\nLa Unified Extensible Firmware Interface (UEFI o EFI para abreviar) es un nuevo modelo de interfaz para interactuar entre los sistemas operativos y el firmware. Proporciona un entorno estándar para iniciar un sistema operativo y ejecutar aplicaciones previas al inicio.\n\nEs un método distito del comunmente usado «código de arranque MBR» seguido por los sistemas BIOS. Consulte Arch boot process para conocer sus diferencias y el proceso de arranque con UEFI. Para configurar los cargadores de arranque UEFI, vea Category:Boot loaders.\n\n"
    },
    {
      "title": "Versiones de UEFI",
      "level": 2,
      "content": "- UEFI comenzó como EFI de Intel en las versiones 1.x.\n- Luego, un grupo de empresas denominado UEFI Forum, se hizo cargo de su desarrollo, a partir del cual se llamó EFI Unificado desde de la versión 2.0.\n- Salvo que se especifique expresamente como EFI 1.x, los términos EFI y UEFI se utilizarán indistintamente para referirse al firmware 2.x de UEFI .\n- La implementación EFI de Apple no es ni la versión 1.x de EFI ni la versión 2.x, sino una combinación de ambas. Este tipo de firmware no entra dentro de ninguna versión de la especificación (U)EFI uno y, por lo tanto, no es un estándar del firmware de UEFI. A menos que se indique explícitamente, estas instrucciones son generales y algunas de ellas pueden no funcionar o pueden ser diferentes en Apple Macs.\n\nLa última especificación de UEFI se puede encontrar en https://uefi.org/specifications.\n\n"
    },
    {
      "title": "Firmware de UEFI",
      "level": 2,
      "content": "Con UEFI, cada programa, ya sea un cargador de sistema operativo o una utilidad (por ejemplo, una aplicación de prueba de memoria o una herramienta de recuperación), debe ser una aplicación EFI correspondiente a la arquitectura/bitness del firmware de UEFI.\n\nLa gran mayoría de los firmwares UEFI, incluidos los recientes Macs de Apple, usan el firmware UEFI x86_64. Los únicos dispositivos conocidos que utilizan UEFI IA32 (32 bits) son Apple Mac antiguos (anteriores a 2008), algunos ultrabooks Intel Cloverfield y algunas tarjetas del servidor Intel antiguo que se sabe que operan con firmware Intel EFI 1.10.\n\nUn firmware UEFI x86_64 no incluye soporte para el inicio de aplicaciones EFI de 32 bits (a diferencia de las versiones de Linux y Windows x86_64, que incluyen dicho soporte). Por lo tanto, la aplicación EFI debe compilarse para el firmware de esa específica arquitectura del procesador.\n\n"
    },
    {
      "title": "Sistemas UEFI que no son Mac",
      "level": 3,
      "content": "Compruebe si el directorio /sys/firmware/efi existe; si existe, significa que el kernel ha arrancado en modalidad UEFI. En ese caso, se presumirá que la arquitectura de UEFI coincidirá con la del kernel (es decir, i686 o x86_64)\n\n"
    },
    {
      "title": "Mac de Apple",
      "level": 3,
      "content": "Los Mac anteriores a 2008 tienen, en su mayoría, un firware IA32 EFI, mientras que los Mac >=2008 tienen, en su mayoría, x86_64 EFI. Todos los Mac capaces de ejecutar el kernel de Mac OS X Snow Leopard de 64-bit tienen un firmware EFI 1.x para x86_64.\n\nPara saber la arquitectura del firmware EFI en un Mac, debe arrancar Mac OS X y escribir en un terminal la siguiente orden:\n\n```\n$ ioreg -l -p IODeviceTree | grep firmware-abi\n```\n\nSi la orden devuelve EFI32, entonces es el firmware EFI IA32 (32 bits). Si devuelve EFI64, entonces es el firmware EFI x86_64. La mayoría de los Mac no tienen firmware UEFI 2.x ya que la implementación de EFI de Apple no es totalmente compatible con la especificación UEFI 2.x.\n\n"
    },
    {
      "title": "Configuración de las opciones del kernel de Linux para UEFI",
      "level": 2,
      "content": "Las opciones requeridas para la configuración del kernel de Linux para sistemas UEFI son:\n\n```\nCONFIG_RELOCATABLE=y\nCONFIG_EFI=y\nCONFIG_EFI_STUB=y\nCONFIG_FB_EFI=y\nCONFIG_FRAMEBUFFER_CONSOLE=y\n```\n\n- Soporte para las Variables Runtime de UEFI (el sistema de archivos efivarfs —/sys/firmware/efi/efivars—). Esta opción es importante, ya que es necesaria para manipular las variables runtime de UEFI usando herramientas como /usr/bin/efibootmgr. La opción de configuración siguiente está añadida en el kernel 3.10 y posterior.: CONFIG_EFIVAR_FS=y\n\n```\nCONFIG_EFIVAR_FS=y\n```\n\n- Soporte para las Variables Runtime de UEFI (la interfaz antigua efivars sysfs —/sys/firmware/efi/vars—). Esta opción debe ser desactivada para evitar posibles problemas entre efivarfs con sysfs-efivars activados.: CONFIG_EFI_VARS=n\n\n```\nCONFIG_EFI_VARS=n\n```\n\n- Opción de configuración de GUID Partition Table (GPT) —necesaria para dar soporte a UEFI—: CONFIG_EFI_PARTITION=y\n\n```\nCONFIG_EFI_PARTITION=y\n```\n\nObtenido de https://docs.kernel.org/arch/x86/x86_64/uefi.html.\n\n"
    },
    {
      "title": "Variables de UEFI",
      "level": 2,
      "content": "UEFI define las variables como la interacción de un sistema operativo con el firmware. Las variables de arranque de UEFI («UEFI Boot Variables») son utilizadas por el cargador de arranque y por el sistema operativo únicamente durante la primera fase de arranque. Las variables «runtime» de UEFI permiten a un sistema operativo gestionar ciertos ajustes del firmware, como la gestión del arranque de UEFI o la gestión de las claves para el protocolo «Boot Secure» de UEFI, etc. Se puede obtener el listado de las variables utilizando:\n\n```\n$ efivar --list\n```\n\n"
    },
    {
      "title": "Soporte de las variables UEFI en el kernel de Linux",
      "level": 3,
      "content": "El kernel de Linux expone los datos de las variables UEFI en el espacio de usuario a través de la interfaz efivarfs (EFI VARiable FileSystem) (CONFIG_EFIVAR_FS) —montada utilizando el módulo del kernel efivarfs en /sys/firmware/efi/efivars— no tiene límite de tamaño máximo y admite las variables «Secure Boot» de UEFI. Introducido en kernel 3.8.\n\n"
    },
    {
      "title": "Requisitos para que el soporte de las variables UEFI funcione correctamente",
      "level": 3,
      "content": "1. La arquitectura del procesador del Kernel y del procesador de UEFI deben coincidir.\n1. El kernel debe arrancar en modo EFI (a través de EFISTUB o de cualquier otro gestor de arranque EFI, no a través de BIOS/CSM o «bootcamp» de Apple que también es BIOS/CSM)\n1. El soporte para EFI Runtime Services debe estar presente en el kernel (CONFIG_EFI=y, compruebe si están presente con zgrep CONFIG_EFI /proc/config.gz).\n1. Los EFI Runtime Services del kernel NO DEBEN ser desactivados a través de un terminal, es decir, el parámetro noefi del kernel NO DEBE ser usado.\n1. El sistema de archivos efivarfs debe estar montado en /sys/firmware/efi/efivars, en otro caso, debe montar efivarfs.\n1. efivar debe mostar (con la opción -l) las variables EFI sin ningún error.\n\nSi el soporte para las variables de EFI no funciona, incluso después de cumplirse las condiciones precedentes, pruebe las siguientes soluciones:\n\n1. Si cualquier herramienta del espacio de usuario no puede modificar los datos de las variables de EFI, compruebe la existencia de archivos en /sys/firmware/efi/efivars/dump-*. Si existen, elimínelos, reinicie y vuelva a intentarlo de nuevo.\n1. Si el paso anterior no resuelve el problema, intente arrancar con el parámetro del kernel efi_no_storage_paranoia para desactivar la variable efi del kernel que comprueba el espacio de almacenamiento, la cual puede impedir la escritura/modificación de las variables de efi.\n\n"
    },
    {
      "title": "Montar efivarfs",
      "level": 4,
      "content": "Si efivarfs no se monta automáticamente en /sys/firmware/efi/efivars por systemd durante el arranque, entonces necesita montarla manualmente para dejar expuesto el soporte para las variables de UEFI a las herramientas del espacio de usuario tales como efibootmgr:\n\n```\n# mount -t efivarfs efivarfs /sys/firmware/efi/efivars\n```\n\nNote: **fuera (antes)** \n\nConsulte efivarfs.html para documentarse más sobre el kernel.\n\n"
    },
    {
      "title": "Herramientas en el espacio de usuario",
      "level": 3,
      "content": "Existen algunas herramientas que permiten acceder/modificar las variables UEFI, como:\n\n- efivar — Herramienta y biblioteca para modificar las variables de UEFI (utilizada por efibootmgr)\n\n- efibootmgr — Herramienta para modificar las configuraciones del gestor de arranque del firmware de UEFI\n\n- uefivars — Vuelca un listado de las variables de EFI con alguna información adicional sobre la PCI (utiliza el código de efibootmgr)\n\n- efitools — Herramientas para manipular las plataformas de secure boot de UEFI\n\n- Suite de comprobación de firmware, de Ubuntu — Conjunto de herramientas de comprobación que realiza verificaciones de estado en el firmware de ordenadores con Intel/AMD\n\n"
    },
    {
      "title": "efibootmgr",
      "level": 4,
      "content": "- Si efibootmgr no funciona en absoluto en su sistema, puede reiniciar en el intérprete de órdenes UEFI y utilizar la orden bcfg para crear una entrada de arranque en el gestor de arranque.\n- Si no es posible usar efibootmgr, algunos firmwares UEFI permiten a los usuarios gestionar directamente las entradas de inicio de UEFI desde la interfaz que aparece durante el arranque. Por ejemplo, algunas BIOS de ASUS tienen una opción llamada «Add New Boot Option» («Añadir nueva opción de arranque») que permite seleccionar una partición de sistema EFI local e introducir manualmente la ubicación del código de EFI (por ejemplo \\EFI\\refind\\refind_x64.efi).\n- Las siguientes órdenes utilizan el cargador de arranque rEFInd como ejemplo.\n\nPara añadir una nueva opción de arranque usando efibootmgr, necesita saber tres cosas:\n\n1. El disco que contiene la EFI system partition (Español) (ESP): /dev/sdX\n1. El número de partición de la ESP en ese disco: la Y en /dev/sdXY\n1. La ruta a la aplicación EFI (relativa a la raíz de la ESP)\n\nPor ejemplo, si desea agregar una opción de arranque para /efi/EFI/refind/refind_x64.efi donde /efi es el punto de montaje de la partición ESP, ejecute:\n\n```\n$ findmnt /efi\n```\n\n```\nTARGET SOURCE    FSTYPE OPTIONS\n/efi   /dev/sda1 vfat   rw,flush,tz=UTC\n```\n\nEn este ejemplo, esto indica que la partición ESP está en el disco /dev/sda y el número de la partición es 1. La ruta a la aplicación EFI relativa a la raíz de la ESP es /EFI/refind/refind_x64.efi. Sabiendo esto, se crearía la entrada de arranque de la siguiente manera:\n\n```\n# efibootmgr --create --disk /dev/sda --part 1 --loader /EFI/refind/refind_x64.efi --label \"rEFInd Boot Manager\" --verbose\n```\n\nConsulte efibootmgr(8) o el archivo README de efibootmgr para obtener más información.\n\n"
    },
    {
      "title": "Intérprete de órdenes UEFI",
      "level": 2,
      "content": "El intérprete de órdenes de UEFI es una intérprete/terminal para el firmware, que permite ejecutar aplicaciones UEFI que incluyen los cargadores de arranque UEFI. Aparte de esto, el intérprete también se puede utilizar para obtener información variada sobre el sistema o del firmware del mapa de la memoria (memmap), modificar las variables del gestor de arranque (bcfg), ejecutar programas de gestión de particiones (diskpart), cargar los controladores UEFI, editar archivos de texto (edit), hexedit, etc.\n\n"
    },
    {
      "title": "Obtener el intérprete de órdenes UEFI",
      "level": 3,
      "content": "Puede descargar un intérprete de órdenes UEFI con licencia BSD de Tianocore de Intel desde el proyecto UDK/EDK2.\n\n- Paquete de AUR uefi-shell-gitAUR (recomendado) —proporciona la shell x86_64 para x86_64 (64-bit) de UEFI y la shell IA32 para IA32 (32-bit) de UEFI— compilado directamente de la última fuente de TianoCore EDK2.\n- Hay copias de la shell v1 y v2 en el directorio EFI en la imagen de instalación de Arch.\n- Binarios precompilados de la shell v2 de UEFI[enlace roto 2020-08-06] (puede no estar actualizado).\n- Binarios precompilados de UEFI Shell v1[enlace roto 2020-08-06] (no actualizado por los desarrolladores).\n- Binario precompilado de la shell v2 de UEFI con bcfg modificado para trabajar con el firmware UEFI pre-2.3 —del cargador de arranque Clover EFI—.\n\nLa versión 2.0 de la shell únicamente funciona en sistemas UEFI 2.3 + y se recomienda su uso con preferencia a la shell 1.0 en esos sistemas. La versión 1.3 de la shell debería funcionar en todos los sistemas UEFI, independientemente de la especificación de la versión del firmware. Más información en ShellPkg y este correo[enlace roto 2022-09-23].\n\n"
    },
    {
      "title": "Lanzar el intérprete de órdenes UEFI",
      "level": 3,
      "content": "Algunas placas base Asus y otras basadas en el firmware UEFI AMI Aptio x86_64 (de Sandy Bridge en adelante) ofrecen una opción llamada «Launch EFI Shell from filesystem device». Para estas placas base, descargue la shell de UEFI x86_64 y cópiela a la partición del sistema UEFI renombrándola como <UEFI_SYSTEM_PARTITION>/shellx64.efi (normalmente en la carpeta /boot/efi/shellx64.efi).\n\nLos sistemas con un firmware UEFI Phoenix SecureCore Tiano se sabe que llevan integrada la shell de UEFI, la cual se puede iniciar presionando las teclas F6, F11 o F12.\n\n"
    },
    {
      "title": "Órdenes importantes del intérprete UEFI",
      "level": 3,
      "content": "Las órdenes del intérprete UEFI generalmente dan soporte a la opción -b que hace una pausa después de la salida de cada página. Ejecute help -b para ver las órdenes disponibles.\n\nPuede obtener más información en https://software.intel.com/en-us/articles/efi-shells-and-scripting/[enlace roto 2023-07-30]\n\n"
    },
    {
      "title": "bcfg",
      "level": 4,
      "content": "La orden bcfg se utiliza para modificar las entradas en la NVRAM de UEFI, lo que permite cambiar las entradas de arranque o las opciones del controlador. Esta orden se describe con detalle en la página 83 (sección 5.3) del documento UEFI Shell Specification 2.0\n\n- Se recomienda probar bcfg únicamente si efibootmgr no puede crear entradas de inicio que funcionen en el propio sistema.\n- La versión 1 del binario oficial del intérprete de órdenes UEFI no proporciona soporte para la orden bcfg. Consulte #Obtener el intérprete de órdenes UEFI para un binario UEFI shell v2 modificado que puede funcionar en UEFI con firmwares anteriores a 2.3.\n\nPara conocer una lista de entradas de arranque actuales:\n\n```\nShell> bcfg boot dump -v\n```\n\nPara añadir una entrada para rEFInd (por ejemplo) como cuarta (la numeración empieza desde cero) en el menú de arranque:\n\n```\nShell> bcfg boot add 3 FS0:\\EFI\\refind\\refind_x64.efi \"rEFInd\"\n```\n\ndonde FS0: es la asignación correspondiente a la partición del sistema UEFI y FS0:\\EFI\\refind\\refind_x64.efi es el archivo que se pondrá en marcha.\n\nPara agregar una entrada con el fin de iniciar directamente su sistema, sin un gestor de arranque, configure una opción de arranque utilizando su kernel como EFISTUB:\n\n```\nShell> bcfg boot add N fsV:\\vmlinuz-linux \"Arch Linux\"\nShell> bcfg boot -opt N \"root=/dev/sdX# initrd=\\initramfs-linux.img\"\n```\n\ndonde N es la prioridad, V es el número de volumen donde se encuetra la partición de sistema EFI, y /dev/sdX# es la partición raíz.\n\nPara quitar la opción de arranque cuarta:\n\n```\nShell> bcfg boot rm 3\n```\n\nPara mover la opción de arranque #3 a #0 (es decir, a la primera posición o la entrada por defecto en el menú de inicio de UEFI):\n\n```\nShell> bcfg boot mv 3 0\n```\n\nPara mostrar el texto de ayuda de bcfg:\n\n```\nShell> help bcfg -v -b\n```\n\no\n\n```\nShell> bcfg -? -v -b\n```\n\n"
    },
    {
      "title": "map",
      "level": 4,
      "content": "La orden map muestra un mapeado de los dispositivos, es decir, los nombres de los sistemas de archivos disponibles (FS0) y los dispositivos de almacenamiento (blk0).\n\nAntes de ejecutar órdenes relacionadas con el sistema de archivos, como cd o ls, debe cambiar el intérprete de órdenes al sistema de archivos correspondiente, escribiendo su nombre:\n\n```\nShell> FS0:\nFS0:\\> cd EFI/\n```\n\n"
    },
    {
      "title": "edit",
      "level": 4,
      "content": "La orden edit proporciona un editor de texto básico, con una interfaz similar al editor de texto nano, pero ligeramente menos funcional. Maneja codificación UTF-8 y se hace cargo del final de la línea LF frente a CRLF.\n\nPara editar, por ejemplo, refind.conf de rEFInd en la partición del sistema UEFI (FS0: en el firmware):\n\n```\nShell> edit FS0:\\EFI\\refind\\refind.conf\n```\n\nEscriba Ctrl-E para obtener ayuda.\n\n"
    },
    {
      "title": "Crear un USB arrancable con UEFI desde la ISO",
      "level": 3,
      "content": "Siga las instrucciones del siguiente artículo USB Installation Media (Español)#Crear USB para arrancar desde sistemas BIOS y UEFI\n\n"
    },
    {
      "title": "Eliminar el apoyo de arranque de UEFI de una unidad óptica",
      "level": 3,
      "content": "Note: **CD/DVD únicamente** \n\nLa mayoría de los Mac EFI de 32-bit y algunos Mac EFI de 64 bits se niegan a arrancar desde un CD/DVD bootable con una combinación de UEFI(X64)+BIOS. Si se desea continuar con la instalación con soportes ópticos, puede que sea necesario, primero, eliminar el apoyo a UEFI.\n\n- Monte el soporte de instalación oficial y obtenga el archisolabel como se muestra en la sección anterior.\n\n```\n# mount -o loop input.iso /mnt/iso\n```\n\n- Después reconstruya la ISO, excluyendo el soporte de arranque de UEFI de la imágen destinada al disco óptico, utilizando xorriso de libisoburn. Asegúrese de configurar el archisolabel correcto, por ejemplo «ARCH_201411» o similar:\n\n```\n$ xorriso -as mkisofs -iso-level 3 \\\n    -full-iso9660-filenames\\\n    -volid \"archisolabel\" \\\n    -appid \"Arch Linux CD\" \\\n    -publisher \"Arch Linux <https://archlinux.org>\" \\\n    -preparer \"prepared by $USER\" \\\n    -eltorito-boot isolinux/isolinux.bin \\\n    -eltorito-catalog isolinux/boot.cat \\\n    -no-emul-boot -boot-load-size 4 -boot-info-table \\\n    -isohybrid-mbr \"/mnt/iso/isolinux/isohdpfx.bin\" \\\n    -output output.iso /mnt/iso/\n```\n\n- Grabe output.iso en el disco óptico y continúe con la instalación de forma normal.\n\n"
    },
    {
      "title": "OVMF para máquinas virtuales",
      "level": 3,
      "content": "OVMF es un proyecto de TianoCore destinado a activar la compatibilidad de UEFI para máquinas virtuales. OVMF contiene una muestra de firmware UEFI para QEMU.\n\nSe puede instalar edk2-ovmf desde el repositorio extra.\n\nEs recomendable hacer una copia local del conjunto de variables no volátiles para su máquina virtual:\n\n```\n$ cp /usr/share/ovmf/x64/OVMF_VARS.fd my_uefi_vars.bin\n```\n\nPara usar el firmware OVMF y el conjunto de variables, añada la siguiente orden a su QEMU:\n\n```\n-drive if=pflash,format=raw,readonly,file=/usr/share/ovmf/x64/OVMF_CODE.fd \\\n-drive if=pflash,format=raw,file=my_uefi_vars.bin\n```\n\nPor ejemplo:\n\n```\n$ qemu-system-x86_64 -enable-kvm -m 1G -drive if=pflash,format=raw,readonly,file=/usr/share/ovmf/x64/OVMF_CODE.fd -drive if=pflash,format=raw,file=my_uefi_vars.bin …\n```\n\n"
    },
    {
      "title": "DUET para sistemas BIOS únicamente",
      "level": 3,
      "content": "DUET es un proyecto TianoCore que permite cargar en cadena un entorno UEFI completo desde un sistema BIOS, de manera similar al arranque de los sistemas operativos en entorno BIOS. Este método se está discutiendo ampliamente en https://www.insanelymac.com/forum/topic/186440-linux-and-windows-uefi-boot-using-tianocore-duet-firmware/ . Imágenes DUET precompiladas se pueden descargar de uno de los repositorios de https://gitorious.org/tianocore_uefi_duet_builds[enlace roto 2022-09-23]. Instrucciones específicas para la creación de DUET están disponible en https://gitorious.org/tianocore_uefi_duet_builds/tianocore_uefi_duet_installer/blobs/raw/master/Migle_BootDuet_INSTALL.txt[enlace roto 2022-09-23] .\n\nTambién puede probar https://sourceforge.net/projects/cloverefiboot/ que proporciona imágenes DUET modificadas que puedan contener algunos arreglos específicos del sistema y son más frecuentemente actualizadas en comparación con las de los repositorios gitorious.\n\n"
    },
    {
      "title": "Windows 7 no se inicia en la modalidad UEFI",
      "level": 3,
      "content": "Si tiene instalado Windows en un disco duro con particionado GPT y sigue teniendo otro disco duro diferente con particionado MBR en su ordenador, entonces es posible que el firmware (UEFI) está dando su apoyo CSM a este último (para arrancar particiones MBR) y por ello Windows no arranca. Para resolver este problema convierta el particionado de su disco MBR a GPT, o desactive el puerto SATA del disco duro cuando esté conectado, o bien, desenchufe el puerto SATA de este disco duro.\n\nPlacas base con este tipo de problema:\n\n- Gigabyte Z77X-UD3H rev. 1.1 (BIOS UEFI versión F19e)\n\n- La opción «UEFI Only» de la BIOS UEFI no pretende hacer que la BIOS UEFI arranque desde CSM.\n\n- La opción «UEFI Only» de la BIOS UEFI no pretende hacer que la BIOS UEFI arranque desde CSM.\n\n"
    },
    {
      "title": "Windows cambia el orden de arranque",
      "level": 3,
      "content": "Si el arranque dual con Windows y su placa base solo inicia Windows de forma inmediata en lugar mostrar la elección de su aplicación EFI, existen varias causas posibles y soluciones alternativas.\n\n- Asegúrese de que el inicio rápido esté desactivado en las opciones de energía de Windows\n- Asegúrese de que Secure Boot esté desactivado en su BIOS (si no está utilizando un gestor de arranque firmado)\n- Asegúrese de que el orden de arranque de UEFI no tiene establecido primero «Windows Boot Manager» utilizando, por ejemplo, #efibootmgr and what you see in the configuration tool of the UEFI. Algunas placas base anulan, por defecto, cualquier configuración establecida con efibootmgr por Windows, si la detecta. Esto se confirma en una computadora portátil Packard Bell.\n- Si su placa base está iniciando la ruta de inicio predeterminada (\\EFI\\BOOT\\BOOTX64.EFI), este archivo puede haber sido sobrescrito con el cargador de arranque de Windows. Intente configurar la ruta de inicio correcta, por ejemplo utilizando #efibootmgr.\n- Si los pasos anteriores no funcionan, puede decirle al gestor de arranque de Windows que ejecute una aplicación EFI diferente. Desde un prompt de órdenes de «Windows Administrator»: # bcdedit /set \"{bootmgr}\" path \"\\EFI\\path\\to\\app.efi\"\n- Alternativamente, puede establecer una secuencia de órdenes de inicio en Windows que garantice que el orden de inicio esté configurado correctamente cada vez que inicie Windows. Abra un promtp de órdenes (símbolo del sistema) con privilegios de administrador. Ejecute bcdedit /enum firmware y encuentre la entrada de inicio deseada. Copie el Identificador, incluidos los corchetes, por ejemplo {31d0d5f4-22ad-11e5-b30b-806e6f6e6963} Cree un archivo por lotes con la siguiente orden bcdedit /set \"{fwbootmgr}\" DEFAULT \"{copied boot identifier}\" Abra gpedit.msc y en Local Computer Policy > Computer Configuration > Windows Settings > Scripts(Startup/Shutdown), seleccione Startup En la pestaña Scripts, seleccione el botón Add, y seleccione su archivo por lotes.\n\n```\n# bcdedit /set \"{bootmgr}\" path \"\\EFI\\path\\to\\app.efi\"\n```\n\n1. Abra un promtp de órdenes (símbolo del sistema) con privilegios de administrador. Ejecute bcdedit /enum firmware y encuentre la entrada de inicio deseada.\n1. Copie el Identificador, incluidos los corchetes, por ejemplo {31d0d5f4-22ad-11e5-b30b-806e6f6e6963}\n1. Cree un archivo por lotes con la siguiente orden bcdedit /set \"{fwbootmgr}\" DEFAULT \"{copied boot identifier}\"\n1. Abra gpedit.msc y en Local Computer Policy > Computer Configuration > Windows Settings > Scripts(Startup/Shutdown), seleccione Startup\n1. En la pestaña Scripts, seleccione el botón Add, y seleccione su archivo por lotes.\n\n"
    },
    {
      "title": "El soporte USB se topa con una pantalla negra",
      "level": 3,
      "content": "Este problema puede ocurrir debido a un problema con KMS. Pruebe desactivar KMS mientras arranca el USB.\n\n"
    },
    {
      "title": "El cargador de arranque UEFI no aparece en el menú del firmware",
      "level": 3,
      "content": "En ciertas placas base UEFI, como algunas placas con un chipset Intel Z77, agregar entradas con efibootmgr o bcfg desde la shell de UEFI no funcionará, porque no aparecerán en la lista del menú de arranque después de haber sido agregadas a NVRAM.\n\nEste problema se debe a que las placas base solo pueden cargar Microsoft Windows. Para resolver esto, debe colocar el archivo .efi en la ubicación que usa Windows.\n\nCopie el archivo bootx64.efi del soporte de instalación de Arch Linux (FSO:) en el directorio de Microsoft de la partición ESP de su disco duro (FS1:). Haga esto arrancando la shell EFI y escribiendo:\n\n```\nShell> mkdir FS1:\\EFI\\Microsoft\nShell> mkdir FS1:\\EFI\\Microsoft\\Boot\nShell> cp FS0:\\EFI\\BOOT\\bootx64.efi FS1:\\EFI\\Microsoft\\Boot\\bootmgfw.efi\n```\n\nDespués del reinicio, las entradas agregadas a la NVRAM deben aparecer en el menú de inicio.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- Wikipedia:UEFI\n- UEFI Forum - contains the official UEFI Specifications - GUID Partition Table is part of UEFI Specification\n- UEFI boot: how does that actually work, then? - A blog post by AdamW\n- Linux Kernel x86_64 UEFI Documentation\n- Intel's page on EFI\n- Intel Architecture Firmware Resource Center[enlace roto 2023-07-30]\n- Matt Fleming - The Linux EFI Boot Stub[enlace roto 2023-07-30]\n- Matt Fleming - Accessing UEFI Variables from Linux[enlace roto 2023-07-30]\n- Rod Smith - Linux on UEFI: A Quick Installation Guide\n- UEFI Boot problems on some newer machines (LKML)\n- LPC 2012 Plumbing UEFI into Linux[enlace roto 2020-08-06]\n- LPC 2012 UEFI Tutorial : part 1[enlace roto 2020-08-06]\n- LPC 2012 UEFI Tutorial : part 2[enlace roto 2020-08-06]\n- Intel's TianoCore Project for Open-Source UEFI firmware which includes DuetPkg for direct BIOS based booting and OvmfPkg used in QEMU and Oracle VirtualBox\n- FGA: The EFI boot process\n- Microsoft's Windows and GPT FAQ\n- Convert Windows x64 from BIOS-MBR mode to UEFI-GPT mode without Reinstall\n- Create a Linux BIOS+UEFI and Windows x64 BIOS+UEFI bootable USB drive\n- Rod Smith - A BIOS to UEFI Transformation\n- EFI Shells and Scripting - Intel Documentation[enlace roto 2023-07-30]\n- UEFI Shell - Intel Documentation[enlace roto 2023-07-30]\n- UEFI Shell - bcfg command info[enlace roto 2020-08-06]\n\n"
    }
  ]
}