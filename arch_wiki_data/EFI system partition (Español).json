{
  "title": "EFI system partition (Español)",
  "url": "https://wiki.archlinux.org/title/EFI_system_partition_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2018-12-14** \n\nArtículos relacionados\n\n- Interfaz de firmware extensible unificada (UEFI)\n- Gestores de arranque\n\nLa partición del sistema EFI (también llamada, por sus siglas en inglés, ESP) es una partición independiente del sistema operativo, que actúa como el lugar de almacenamiento para los cargadores de arranque EFI, las aplicaciones y los controladores que serán lanzados por el firmware UEFI. Es obligatoria para el arranque UEFI.\n\nLa especificación UEFI exige soporte para los sistemas de archivos FAT12, FAT16 y FAT32 (vea UEFI specification version 2.7, section 13.3.1.1), pero cualquier proveedor puede opcionalmente agregar soporte para otros sistemas de archivos adicionales; por ejemplo, algunos proveedores añaden soporte de Apple Macs (y de forma predeterminada) para sus propios controladores del sistema de archivos HFS +.\n\n"
    },
    {
      "title": "Comprobar la existencia de una partición",
      "level": 2,
      "content": "Si está instalando Arch Linux en un equipo compatible con UEFI que ya tiene un sistema operativo instalado, como Windows 10, por ejemplo, es muy probable que ya tenga una partición del sistema EFI.\n\nPara conocer el esquema de particionado del disco y la «system partition», utilice fdisk como root sobre el disco desde el que desea iniciar:\n\n```\n# fdisk -l /dev/sdx\n```\n\nEsta orden devolverá:\n\n- La tabla de particionado del disco: si indica Disklabel type: gpt la tabla de particionado es GPT o Disklabel type: dos si es MBR.\n- La lista de particiones en el disco: busque la partición del sistema EFI en la lista, es una partición pequeña (generalmente alrededor de 100–550 MiB) con un tipo EFI System o EFI (FAT-12/16/32). Para confirmar que esta es la ESP, móntela y verifique si contiene un directorio llamado EFI, si es así, definitivamente es la ESP.\n\nSi encontró una partición del sistema EFI existente, solo tiene que #Montar la partición. Si no encontró una, deberá crearla, proceda con #Crear la partición.\n\n"
    },
    {
      "title": "Crear la partición",
      "level": 2,
      "content": "Las siguientes dos secciones muestran cómo crear una partición del sistema EFI (ESP).\n\nPara evitar posibles problemas con algunas implementaciones de UEFI, la ESP debería estar formateada con FAT32 y con un tamaño de, al menos, 512 MiB. Se recomienda 550 MiB para evitar la confusión entre MiB/MB y la creación accidental de FAT16 [1], aunque tamaños más grandes también están de más.\n\nDe acuerdo con una nota de Microsoft [2], el tamaño mínimo para la partición del sistema EFI sería de 100 MiB, aunque esto no se recoge en las especificaciones UEFI. Téngase en cuenta que para formatos avanzados de unidades con 4K nativo (4-KiB-por-sector), el tamaño mínimo requerido será de, al menos, 256 MiB, porque es el tamaño mínimo de la partición de las unidades FAT32 (calculado del siguiente modo: tamaño de sector (4KiB) x 65527 = 256 MiB), y ello debido a una limitación presente en el formato del sistema de archivos FAT32.\n\n"
    },
    {
      "title": "Discos particionados con GPT",
      "level": 3,
      "content": "La partición del sistema EFI en una tabla de particionado GUID Partition Table está identificada por la GUID C12A7328-F81F-11D2-BA4B-00A0C93EC93B.\n\nElija uno de los siguientes métodos para crear una ESP para un disco particionado con GPT:\n\n- fdisk: cree una partición con el tipo de partición EFI System.\n- gdisk: cree una partición con el tipo de partición EF00.\n- GNU Parted: cree una partición con fat32 como tipo de sistema de archivos y establezca/active el indicador esp en él.\n\nContinúe en la sección #Formatear la partición a continuación.\n\n"
    },
    {
      "title": "Discos particionados con MBR",
      "level": 3,
      "content": "La partición del sistema EFI en una tabla de particionado Master Boot Record está identificada por el ID EF.\n\nElija uno de los siguientes métodos para crear un ESP para un disco particionado MBR:\n\n- fdisk: crre una partición primaria con el tipo de partición EFI (FAT-12/16/32).\n- GNU Parted: cree una partición primaria con fat32 como el tipo de sistema de archivos y establezca/active el indicador esp en ella.\n\nContinúe en la sección #Formatear la partición a continuación.\n\n"
    },
    {
      "title": "Formatear la partición",
      "level": 2,
      "content": "Después de crear la ESP, debe formatearla con el sistema de archivos FAT32:\n\n```\n# mkfs.fat -F32 /dev/sdxY\n```\n\nSi obtiene el mensaje WARNING: Not enough clusters for a 32 bit FAT!, reduzca el tamaño del clúster con mkfs.fat -s2 -F32 ... o -s1; de lo contrario, la partición puede no ser legible por UEFI. Consulte mkfs.fat(8) para conocer los tamaños de clúster admitidos.\n\n"
    },
    {
      "title": "Montar la partición",
      "level": 2,
      "content": "El kernel y los archivos initramfs deben ser accesibles por el gestor de arranque o el propio UEFI para poder arrancar correctamente el sistema. Por lo tanto, si desea mantener una configuración simple, la elección del cargador de arranque limitará los puntos de montaje disponibles para la partición del sistema EFI.\n\nLos escenarios más simples para montar la partición del sistema EFI son:\n\n- montar ESP en /efi y utilizar un gestor de arranque que sea capaz de dirigirle a su sistema de archivos raíz (por ejemplo, GRUB (Español), rEFInd).\n- montar ESP en /boot. Este es el método preferido cuando se arranca directamente un kernel EFISTUB desde UEFI.\n\n"
    },
    {
      "title": "Puntos de montaje alternativos",
      "level": 3,
      "content": "Si no utiliza uno de los métodos simples para #Montar la partición, tendrá que copiar los archivos de arranque a la ESP (en adelante esp ).\n\n```\n# mkdir -p esp/EFI/arch\n# cp -a /boot/vmlinuz-linux esp/EFI/arch/\n# cp -a /boot/initramfs-linux.img esp/EFI/arch/\n# cp -a /boot/initramfs-linux-fallback.img esp/EFI/arch/\n```\n\nAdemás, deberá mantener actualizados los archivos en el ESP con las últimas actualizaciones del kernel. De lo contrario, podría producirse un sistema no arrancable. Las siguientes secciones muestran varios mecanismos para automatizarlo.\n\nNote: También es posible precargar los módulos requeridos por el kernel en el arranque, por ejemplo:\n\nTambién es posible precargar los módulos requeridos por el kernel en el arranque, por ejemplo:\n\n```\n/etc/modules-load.d/vfat.conf\n```\n\n```\nvfat\nnls_cp437\nnls_iso8859-1\n```\n\n"
    },
    {
      "title": "Utilizar el montaje con bind",
      "level": 4,
      "content": "En lugar de montar la ESP en el mismo punto de montaje que /boot, puede montar un directorio de la ESP en /boot, montándola con bind (vea mount(8)). Esto permite a pacman (Español) actualizar el kernel directamente, mientras mantiene organizada a su gusto la ESP.\n\n- Este método requiere un kernel y un gestor de arranque compatible con FAT32. Esto no es un problema para una instalación normal de Arch, pero podría ser problemático para otras distribuciones (esto es, aquellas que requieren enlaces simbólicos en /boot/). Consulte la publicación del foro aquí.\n- Debe utilizar el parámetro del kernel root= para poder arrancar con este método.\n\nAl igual que se hizo en #Puntos de montaje alternativos, debemos copiar todos los archivos de arranque en un directorio de su ESP, pero monte la ESP fuera de /boot. A continuación, monte el directorio con la opción bind:\n\n```\n# mount --bind esp/EFI/arch /boot\n```\n\nDespués de verificar el éxito de la operación, edite fstab para hacer estos cambios persistentes:\n\n```\n/etc/fstab\n```\n\n```\nesp/EFI/arch /boot none defaults,bind 0 0\n```\n\n"
    },
    {
      "title": "Utilizar systemd",
      "level": 4,
      "content": "Systemd (Español) tiene la capacidad de programar tareas que se desencadenarán cuando se produzca un evento. En este caso particular, la capacidad de detectar un cambio en una ruta determinada es usada para sincronizar los archivos del kernel de EFISTUB e initramfs cuando se actualizan en /boot/. El archivo observado en busca de cambios es initramfs-linux-fallback.img, ya que este es el último archivo creado por mkinitcpio, para asegurarse de que todos los archivos han sido correctamente compilados antes de iniciar la copia. Los archivos de ruta y servicio de system que se crearán son:\n\n```\n/etc/systemd/system/efistub-update.path\n```\n\n```\n[Unit]\nDescription=Copiar el kernel EFISTUB en la partición del sistema EFI\n\n[Path]\nPathChanged=/boot/initramfs-linux-fallback.img\n\n[Install]\nWantedBy=multi-user.target\nWantedBy=system-update.target\n```\n\n```\n/etc/systemd/system/efistub-update.service\n```\n\n```\n[Unit]\nDescription=Copiar el kernel EFISTUB en la partición del sistema EFI\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/cp -af /boot/vmlinuz-linux esp/EFI/arch/\nExecStart=/usr/bin/cp -af /boot/initramfs-linux.img esp/EFI/arch/\nExecStart=/usr/bin/cp -af /boot/initramfs-linux-fallback.img esp/EFI/arch/\n```\n\nDespués, active e inicie efistub-update.path.\n\n```\nExecStart=/usr/bin/sbsign --key /path/to/db.key --cert /path/to/db.crt --output esp/EFI/arch/vmlinuz-linux /boot/vmlinuz-linux\n```\n\n"
    },
    {
      "title": "Utilizar eventos del sistema de archivos",
      "level": 4,
      "content": "Los eventos del sistema de archivos se pueden usar para ejecutar un script que sincronice el kernel EFISTUB después actualizar el kernel. He aquí un ejemplo con incron a continuación.\n\n```\n/usr/local/bin/efistub-update\n```\n\n```\n#!/bin/sh\ncp -af /boot/vmlinuz-linux esp/EFI/arch/\ncp -af /boot/initramfs-linux.img esp/EFI/arch/\ncp -af /boot/initramfs-linux-fallback.img esp/EFI/arch/\n```\n\n```\n/etc/incron.d/efistub-update.conf\n```\n\n```\n/boot/initramfs-linux-fallback.img IN_CLOSE_WRITE /usr/local/bin/efistub-update\n```\n\nCon el fin de utilizar este método, active el servicio incrond.service.\n\n"
    },
    {
      "title": "Utilizar un hook de mkinitcpio",
      "level": 4,
      "content": "Mkinitcpio puede generar un hook que no necesita un demonio de nivel de sistema para funcionar. Mantiene un proceso en segundo plano a la espera de que se genere vmlinuz, initramfs-linux.img y initramfs-linux-fallback.img antes de copiar los archivos.\n\nAñada efistub-update a la lista de hooks en /etc/mkinitcpio.conf.\n\n```\n/etc/initcpio/install/efistub-update\n```\n\n```\n#!/usr/bin/env bash\nbuild() {\n\t/usr/local/bin/efistub-copy $$ &\n}\n\nhelp() {\n\tcat <<HELPEOF\nEste hook espera a que mkinitcpio termine y luego copia el ramdisk y el kernel terminados a la ESP\nHELPEOF\n}\n```\n\n```\n/usr/local/bin/efistub-copy\n```\n\n```\n#!/usr/bin/env bash\n\nif [[ $1 -gt 0 ]]\nthen\n\twhile [ -e /proc/$1 ]\n\tdo\n\t\tsleep .5\n\tdone\nfi\n\nrsync -a /boot/ esp/\n\necho \"Sincronizado /boot con ESP\"\n```\n\n"
    },
    {
      "title": "Utilizar un hook de mkinitcpio (2)",
      "level": 4,
      "content": "Esta es otra alternativa a las soluciones anteriores, que es potencialmente más limpia porque hay menos copias y no necesita tampoco un demonio de nivel de sistema para funcionar. La lógica se invierte en este caso, initramfs se almacena directamente en la partición EFI, no se copia en /boot/. Luego, el kernel y cualquier otro archivo adicional se copian en la partición ESP, gracias a un hook mkinitcpio.\n\nEdite el archivo /etc/mkinitcpio.d/linux.preset :\n\n```\n/etc/mkinitcpio.d/linux.preset\n```\n\n```\n# archivo predeterminado de mkinitcpio para el paquete 'linux'\n\n# Directorio donde copiar el kernel, initramfs...\nESP_DIR=\"esp/EFI/arch\"\n\nALL_config=\"/etc/mkinitcpio.conf\"\nALL_kver=\"/boot/vmlinuz-linux\"\n\nPRESETS=('default' 'fallback')\n\n#default_config=\"/etc/mkinitcpio.conf\"\ndefault_image=\"${ESP_DIR}/initramfs-linux.img\"\ndefault_options=\"-A esp-update-linux\"\n\n#fallback_config=\"/etc/mkinitcpio.conf\"\nfallback_image=\"${ESP_DIR}/initramfs-linux-fallback.img\"\nfallback_options=\"-S autodetect\"\n```\n\nA continuación, cree el archivo /etc/initcpio/install/esp-update-linux y hágalo ejecutable:\n\n```\n/etc/initcpio/install/esp-update-linux\n```\n\n```\n# Directorio donde copiar el kernel, initramfs...\n\nbuild() {\n\tcp -af /boot/vmlinuz-linux \"${ESP_DIR}/\"\n\t[[ -e /boot/intel-ucode.img ]] && cp -af /boot/intel-ucode.img \"${ESP_DIR}/\"\n\t[[ -e /boot/amd-ucode.img ]] && cp -af /boot/amd-ucode.img \"${ESP_DIR}/\"\n}\n\nhelp() {\n\tcat <<HELPEOF\nEste hook copia el kernel a la partición ESP\nHELPEOF\n}\n```\n\nPara probarlo, basta ejecutar:\n\n```\n# rm /boot/initramfs-linux-fallback.img\n# rm /boot/initramfs-linux.img\n# mkinitcpio -p linux\n```\n\n"
    },
    {
      "title": "Utilizar un hook de pacman",
      "level": 4,
      "content": "Una última opción depende de los hooks de pacman que se ejecutan al final de la instalación.\n\nEl primer archivo es un hook que supervisa los archivos relevantes, y se ejecuta si los mismos se modifican en la preinstalación.\n\n```\n/etc/pacman.d/hooks/999-kernel-efi-copy.hook\n```\n\n```\n[Trigger]\nType = File\nOperation = Install\nOperation = Upgrade\nTarget = boot/vmlinuz*\nTarget = usr/lib/initcpio/*\nTarget = boot/*-ucode.img\n\n[Action]\nDescription = Copiando linux y initramfs al directorio EFI...\nWhen = PostTransaction\nExec = /usr/local/bin/kernel-efi-copy.sh\n```\n\nEl segundo archivo es el script en sí. Cree el archivo y hágalo ejecutable:\n\n```\n/usr/local/bin/kernel-efi-copy.sh\n```\n\n```\n#!/usr/bin/env bash\n#\n# Copiar las imágenes kernel e initramfs al directorio EFI\n#\n\nESP_DIR=\"esp/EFI/arch\"\n\nfor file in /boot/vmlinuz*\ndo\n        cp -af \"$file\" \"$ESP_DIR/$(basename \"$file\").efi\"\n        [[ $? -ne 0 ]] && exit 1\ndone\n\nfor file in /boot/initramfs*\ndo\n        cp -af \"$file\" \"$ESP_DIR/\"\n        [[ $? -ne 0 ]] && exit 1\ndone\n\n[[ -e /boot/intel-ucode.img ]] && cp -af /boot/intel-ucode.img \"$ESP_DIR/\"\n[[ -e /boot/amd-ucode.img ]] && cp -af /boot/amd-ucode.img \"$ESP_DIR/\"\n\nexit 0\n```\n\n"
    },
    {
      "title": "Partición ESP sobre RAID",
      "level": 3,
      "content": "Es posible hacer que la partición ESP sea parte de una matriz RAID1, pero al hacerlo se corre el riesgo de dañar los datos, y se deben tomar más consideraciones al crear la ESP. Consulte [3] y [4] para conocer más detalles.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- La partición del sistema EFI y el comportamiento de arranque predeterminado\n\n"
    }
  ]
}