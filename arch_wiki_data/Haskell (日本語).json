{
  "title": "Haskell (日本語)",
  "url": "https://wiki.archlinux.org/title/Haskell_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Haskell パッケージガイドライン\n\nWikipedia から:\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 ネイティブインストール\n- 3 設定 3.1 GHC を直接呼び出す 3.2 Cabal を動的リンク用に構成する 3.3 動的リンク用のスタックの設定\n- 4 Haskell パッケージの管理 4.1 cabal 4.1.1 パッケージのインストール 4.1.2 パッケージの削除 4.2 Stack 4.2.1 パッケージのインストール 4.2.2 パッケージの削除\n- 5 開発ツール 5.1 ツール 5.1.1 haskell-language-server 5.1.2 ghcid 5.1.3 hoogle 5.2 リンター 5.2.1 hlint 5.2.2 stan 5.2.3 weeder 5.3 フォーマッタ 5.4 エディタ 5.4.1 Visual Studio Code 5.4.2 IntelliJ IDEA 5.4.3 Vim 5.4.4 Emacs\n- 6 代替インストール 6.1 ghcup 6.1.1 ネイティブインストールでの使用 6.2 Stack 6.3 Nix\n- 7 ヒントとテクニック 7.1 静的リンク 7.1.1 静的グローバルパッケージデータベース 7.1.2 ghc-pristine 7.1.3 cabal-static 7.1.4 stack-static 7.1.5 hpack-static-bin\n- 8 参照\n\n- 3.1 GHC を直接呼び出す\n- 3.2 Cabal を動的リンク用に構成する\n- 3.3 動的リンク用のスタックの設定\n\n- 4.1 cabal 4.1.1 パッケージのインストール 4.1.2 パッケージの削除\n- 4.2 Stack 4.2.1 パッケージのインストール 4.2.2 パッケージの削除\n\n- 4.1.1 パッケージのインストール\n- 4.1.2 パッケージの削除\n\n- 4.2.1 パッケージのインストール\n- 4.2.2 パッケージの削除\n\n- 5.1 ツール 5.1.1 haskell-language-server 5.1.2 ghcid 5.1.3 hoogle\n- 5.2 リンター 5.2.1 hlint 5.2.2 stan 5.2.3 weeder\n- 5.3 フォーマッタ\n- 5.4 エディタ 5.4.1 Visual Studio Code 5.4.2 IntelliJ IDEA 5.4.3 Vim 5.4.4 Emacs\n\n- 5.1.1 haskell-language-server\n- 5.1.2 ghcid\n- 5.1.3 hoogle\n\n- 5.2.1 hlint\n- 5.2.2 stan\n- 5.2.3 weeder\n\n- 5.4.1 Visual Studio Code\n- 5.4.2 IntelliJ IDEA\n- 5.4.3 Vim\n- 5.4.4 Emacs\n\n- 6.1 ghcup 6.1.1 ネイティブインストールでの使用\n- 6.2 Stack\n- 6.3 Nix\n\n- 6.1.1 ネイティブインストールでの使用\n\n- 7.1 静的リンク 7.1.1 静的グローバルパッケージデータベース 7.1.2 ghc-pristine 7.1.3 cabal-static 7.1.4 stack-static 7.1.5 hpack-static-bin\n\n- 7.1.1 静的グローバルパッケージデータベース\n- 7.1.2 ghc-pristine\n- 7.1.3 cabal-static\n- 7.1.4 stack-static\n- 7.1.5 hpack-static-bin\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "Haskell のインストールにはいくつかの選択肢があります。そのうちのひとつは Arch Linux によってサポートされているものであり、その他は Haskell によって公式にサポートされており、どの Linux ディストリビューションでも利用可能です。\n\nバージョン 8.0.2-1 以降、Arch の ghc パッケージおよび extra リポジトリ内のすべての haskell-* パッケージは、動的リンクされたライブラリのみを提供するようになりました。\n\n動的リンクを使用すると、通常はビルドが高速化し、ディスクやRAMの使用量が削減されます(複数の Haskell プログラム間でページを共有するため)また、異なる GHC バージョン間の混在に伴うトラブルから解放されます。このため、エンドユーザー向けアプリケーションの管理には、pacman と 公式リポジトリ を使用することが推奨されます。 しかし、これには欠点もあります。GHC、ghc-libs、またはhaskell-* パッケージのアップデートごとに、ソースからインストールしたすべてのツールが動作しなくなるという点です。これは、GHC でコンパイルされたライブラリが安定した ABI を提供しないためです。そのような壊れたバイナリを実行すると、通常次のようなメッセージが表示されます。\n\nerror while loading shared libraries: libHS...so: cannot open shared object file: No such file or directory\n\nこれを修正するには、壊れたツールを再構築して再インストールし、新しいライブラリに再リンクします。\n\n一方、静的リンクは一般的に管理が容易であり、依存関係の更新後にすべてのツールをソースから再ビルドする必要がなく、現在のところ GHC によってより良くサポートされています。このため、ローカル開発においては静的リンクが推奨される優先オプションとなっています。\n\nただし、動的リンクを使用したい場合は、GHC、Cabal、そして Stack をそれに対応するよう設定する必要があります。デフォルトでは静的リンクが使用されるため、そのままでは動的リンクが成功しません。\n\n- Arch の 公式リポジトリ から pacman を使用して Haskell をインストールするには、#ネイティブインストール を読み進めてください。ただし、これによりシステムに数百の haskell-* パッケージがインストールされる可能性があることに注意してください。\n- それ以外の場合は、#代替インストール セクションに進んでください。\n\nghc (公式リポジトリ から) を静的リンクで使用することは可能ですが、設定がより複雑になります。#静的リンク を参照してください。\n\n"
    },
    {
      "title": "ネイティブインストール",
      "level": 2,
      "content": "Haskell を使用するには、次のパッケージを インストール します。\n\n1. ghc - Haskell コンパイラ。いくつかの 実装 がありますが、最もよく使われている (現在では 事実上 リファレンスとなっている) のは GHC (Glasgow Haskell Compiler) です。\n1. cabal-install または stack です。- GHC に依存して Haskell ソースをコンパイルするビルドツール。Cabal は依存関係の解決と Hackage (Haskell コミュニティのオープンソースソフトウェアの中央パッケージアーカイブ) からのソースパッケージに焦点を当てた古典的なビルドツールです。Stack は、Stackage (Hackage の安定したサブセットで、互いにうまく動作することが知られているパッケージのキュレーションセット (スナップショット) を提供する) のキュレーションされたスナップショットとソースパッケージに焦点を当てた別のビルドツールです。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "バージョン 8.0.2-1 以降、extra に含まれる Arch ghc パッケージと全ての haskell-* パッケージは動的にリンクされるライブラリのみを提供します。そのため、リンクに成功するためには GHC, Cabal, Stack を動的リンクに設定する必要があります。\n\n動的リンクを使用すると、通常、(実行中の複数の Haskell プログラム間でページを共有することにより) ビルドが高速化され、ディスクと RAM の使用量が削減され、GHC 間の混合エラーのトラブルシューティングから解放されます。しかし、これには独自の欠点もあります。それは、ghc、ghc-libs、または org/packages/?q=haskell haskell-* パッケージは、GHC でコンパイルされたライブラリが安定した ABI を提供しないためです。このような壊れたバイナリを実行すると、通常のメッセージ error whileloadingsharedlibraries:libHS...so:cannotopensharedobjectfile:No such file or directory が表示されます。これを修正するには、壊れたツールを再構築して再インストールし、新しいライブラリに再リンクします。\n\n一方、静的リンクは一般に保守が容易で、依存関係を更新するたびにすべてのツールをソースから再構築する必要がありません。これらの理由から、静的リンクは、パッケージシステム外のローカル開発では多くの場合推奨されるオプションです。 静的リンクを希望する場合、詳細については 静的リンク または 代替インストール を参照してください。\n\n"
    },
    {
      "title": "GHC を直接呼び出す",
      "level": 3,
      "content": "正常にリンクするには、-dynamic フラグを GHC に渡す必要があります。次のファイルで試すことができます。\n\n```\nMain.hs\n```\n\n```\nmain = putStrLn \"Hello, World\"\n```\n\n次のようにコンパイルして実行します。\n\n```\n$ ghc -dynamic Main.hs\n$ ./Main\n```\n\n```\nHello, World\n```\n\n"
    },
    {
      "title": "Cabal を動的リンク用に構成する",
      "level": 3,
      "content": "まず、次のコマンドを実行して、Hackage からパッケージの最新リストをダウンロードし、グローバル設定ファイル ~/.cabal/config (または、$CABAL_CONFIG が指すファイル) を作成します。\n\n```\n$ cabal update\n```\n\nCabal を動的リンク用に設定するには、~/.cabal/config 内の次のオプションのコメントを解除して編集します。\n\n```\n~/.cabal/config\n```\n\n```\nlibrary-vanilla: False\nshared: True\nexecutable-dynamic: True\nprogram-default-options\n  ghc-options: -dynamic\n```\n\n- library-vanilla: False は静的ライブラリの作成を抑制します (プロジェクトにライブラリが含まれている場合)\n- shared: True は共有ライブラリの作成を有効にします(プロジェクトにライブラリが含まれている場合)\n- executable-dynamic: True は実行ファイルにダイナミックリンクを使用します (プロジェクトに実行ファイルが含まれている場合)\n- ghc-options: -dynamic は GHC の全ての呼び出しに -dynamic フラグを追加します (例えば、パッケージが自明でないSetup.hs を持っている場合)\n\n"
    },
    {
      "title": "動的リンク用のスタックの設定",
      "level": 3,
      "content": "stack setup コマンドを使用してスタックを初期化し、グローバル設定ファイル ~/.stack/config.yaml を作成できます。デフォルトでは、スタックは最初の呼び出し時に独自のバージョンの GHC を隔離された場所に自動的にダウンロードします。代わりにスタックにシステム GHC インストールを使用させるには、--system-ghc フラグと --resolver フラグを指定して stack setup を実行します。\n\n```\n$ stack setup --system-ghc --resolver resolver\n```\n\nシステムの GHC と互換性のあるリゾルバーを指定する必要があることに注意してください。それ以外の場合、スタックは --system-ghc フラグを喜んで無視し、GHC の独自のコピーをダウンロードします。システム GHC のバージョンは、ghc --version コマンドを使用して確認できます。\n\n```\n$ ghc --version\n```\n\n```\nThe Glorious Glasgow Haskell Compilation System, version 8.10.2\n```\n\n次に、Stackage Web サイトにアクセスし、システムの GHC バージョンに一致する適切な長期サポート (LTS) または夜間スナップショットを選択します。コマンドラインの --resolver フラグに対して選択したスナップショットを使用します。例:--resolver lts-16.15 または --resolver nightly-2020-09-01\n\nStackage は通常、新しい GHC リリースより遅れます。システム GHC のスタックスナップショットがまだリリースされていない場合があります。この場合、GHC の以前のマイナーバージョンのスナップショットを選択するか、Haskell インストールを一時的にダウングレードして、新しい GHC リリースのサポートが最終的に Stackage に提供されるまで待つことをお勧めします。\n\n動的リンク用にスタックを構成するには、次のスニペットを ~/.stack/config.yaml に追加します。\n\n```\n~/.stack/config.yaml\n```\n\n```\n# Stop downloading GHCs into isolated locations under ~/.stack.\ninstall-ghc: false\n\n# Allow Stack to pick the system GHC (false by default).\nsystem-ghc: true\n\n# Allow to use, say, Stackage snapshot for GHC 8.8.2 with system GHC 8.8.3.\ncompiler-check: newer-minor\n\n# Add the -dynamic flag to every invocation of GHC.\nghc-options:\n  \"$everything\": -dynamic\n```\n\n"
    },
    {
      "title": "Haskell パッケージの管理",
      "level": 2,
      "content": "Haskell のライブラリと実行可能ファイルのほとんどは、Hackage および Stackage から入手できるソースパッケージの単位で配布されます。\n\n他のコンパイル言語では一般的なことですが、多くの人気のある Haskell パッケージは、事前構築された形式で公式 Arch リポジトリから入手できます。いくつかの追加パッケージは AUR からインストールできます。\n\nGHC、ライブラリ、およびツールをインストールするには pacman を使用することが推奨されますが、ある時点で、Hackage/Stackage から直接 Haskell パッケージをインストールしたり、ソースから独自の (または他の人の) パッケージをコンパイルしたくなるかもしれません。これを行うには、Cabal または Stack が必要になります。\n\n次の表は、さまざまなパッケージ管理スタイルの長所と短所をまとめたものです。\n\nTable content:\n方法 | 良い点 | 悪い点\n公式リポジトリ | ArchLinux 開発者が運営、パッケージのバージョンの整合性に問題なし、コンパイル済み | 利用できるパッケージの数が限られる、動的ライブラリのみ\ncabal-install | 全てのパッケージが利用可能、root 権限が不要 | インストール先がホームフォルダ、cabal-install はパッケージマネージャではない、パッケージのバージョンの整合性に問題がある可能性 (別名 cabal hell)\nstack | (Stackage にある) 全てのパッケージが利用可能、root 権限が不要 | インストール先がホームフォルダで、バージョンがスナップショットに固定、特定のパッケージを削除するのは難しい\nArch User Repository | 始めるのが簡単 | パッケージのメンテナンスがなくなる可能性、パッケージのバージョンの整合性に問題がある可能性\n\n"
    },
    {
      "title": "cabal",
      "level": 3,
      "content": "- Haskell パッケージとその依存関係を記述する Cabal ファイルフォーマット;\n- Cabal ファイルフォーマットで動作する Cabal ライブラリ;\n- Haskell パッケージをビルドするために Cabal ライブラリを使用する cabal コマンドラインツール (cabal-install パッケージで提供されます)\n\nCabal は Haskell の \"オリジナル\" のビルドシステムです。Hackage で見つかるライブラリやツールのほとんどは、Cabal 経由でインストールできます。\n\n"
    },
    {
      "title": "パッケージのインストール",
      "level": 4,
      "content": "Cabal によってインストールされたユーザー全体の実行可能ファイルを実行するには、~/.cabal/bin を $PATH 環境変数 に追加する必要があります。\n\n```\nPATH=\"$HOME/.cabal/bin:$PATH\"\n```\n\n次のコマンドを実行して、Hackage パッケージとそのすべての依存関係を 1 つのステップでインストールします。\n\n```\n$ cabal install --ghc-options=-dynamic package\n```\n\nHaskell パッケージをソースからビルドしてインストールすることもできます。これを行うには、パッケージディレクトリから次のコマンドを実行します。\n\n```\n$ cabal install --ghc-options=-dynamic\n```\n\n各 Cabal パッケージは、パッケージ バージョン管理ポリシー (PVP) に従って、依存関係のリストとそのバージョン制約を .cabal ファイルに指定する必要があります。パッケージのインストール中に、Cabal はすべての制約を満たす一連の依存関係を見つけようとします。このプロセスは 依存関係の解決 と呼ばれます。\n\nスタックが存在するのには理由があります。cabal は初心者との間に多くの軋轢を生むことで知られています。ほとんどの場合、依存関係の解決はうまく機能しますが、失敗する場合もあります。この場合、問題の原因を突き止め、問題のある依存関係を解決する方法について Cabal にヒントを与える必要があります。たとえば、場合によっては、Cabal がパッケージの PVP によって規定された依存関係の上限を無視できるようにするために、cabal install --allow-newer --ghc-options=-dynamic package と言う必要があります。バージョンを変更し、パッケージ作成者が許可したものよりも新しい依存関係を持つパッケージを効果的にインストールします。 あまり適切に管理されていないパッケージの場合は、さらに面倒になります。別の例については、Idris (Haskell で書かれた別のプログラミング言語) のインストールに関する このスレッド を参照してください。--allow-newer および --constraint='haskeline < 0.8.0.0' コマンドラインフラグを使用してコンパイルを成功させます。\n\n"
    },
    {
      "title": "パッケージの削除",
      "level": 4,
      "content": "簡単な方法はありません。 Cabal はこの機能をサポートしていませんが、cabal-store-gc のような外部ツールがあります。\n\nユーザー全体の Haskell パッケージ システム全体を再インストールするには、~/.cabal と ~/.ghc を削除して、最初から始めます。これは、GHC をアップグレードするときに必要になることがよくあります。\n\nより正確に行うには、ghc-pkg unregister package または ghc-pkg hide package/ghc-pkg expose package を user package database 上で直接使うことができます。しかし、どちらもファイルを削除しません。\n\n"
    },
    {
      "title": "Stack",
      "level": 3,
      "content": "Stack は、Haskell パッケージを管理するためのもう 1 つのツールです。それは cabal とは少し異なる目標を持ち、少し異なる哲学を持っています。これは内部で Cabal ライブラリを使用し、Hackage と統合します。ただし、スナップショットが厳選され、連携して適切に動作するパッケージが含まれることを約束して、独自のパッケージ (スナップショット) リポジトリを Stackage 上に維持します。\n\n"
    },
    {
      "title": "パッケージのインストール",
      "level": 4,
      "content": "デフォルトの設定では、Stack はコンパイル済みの実行ファイルを ~/.local/bin にインストールします。このディレクトリをシェル設定ファイルの $PATH 環境変数に追加してください。例えば bash なら ~/.bashrc、zsh なら ~/.zshrc です:\n\n```\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\n次のコマンドを実行して、Stackage パッケージをダウンロード、ビルド、インストールします。\n\n```\nstack install package\n```\n\nパッケージディレクトリから次のコマンドを実行して、ソースから Haskell パッケージをビルドしてインストールすることもできます。\n\n```\nstack install --resolver resolver\n```\n\nstack setup コマンドで使用したものと同じリゾルバーを指定する必要があることに注意してください。\n\n"
    },
    {
      "title": "パッケージの削除",
      "level": 4,
      "content": "スタックは \"アンインストール\" 操作をサポートしていません。\n\nユーザー全体の Haskell パッケージシステム全体を再インストールする場合は、~/.stack ディレクトリを削除して、最初から始めてください。これは、GHC をアップグレードするときに必要になることがよくあります。\n\n"
    },
    {
      "title": "haskell-language-server",
      "level": 4,
      "content": "haskell-language-server は、Haskell の 言語サーバープロトコル (LSP) 実装です。これは、コード補完、\"定義に移動\"、ホバーに関するドキュメント、リンティング、書式設定、または LSP と統合されたエディターのリファクタリングなどの IDE のような機能を提供します。\n\npacman から動的にリンクされた Haskell パッケージを使用している場合は、haskell- language-server をインストールします。それ以外の場合、静的リンクを希望する場合は、haskell-langage-server-staticAUR をインストールしてください。このパッケージには、サポートされている GHC バージョンごとに静的にリンクされたバイナリが含まれています。あるいは、haskell-language-server は ghcup 経由、または Visual Studio Code の Haskell 拡張機能 によってインストールできます。\n\nhaskell-language-serverは、プロジェクトを開いたときに自動的にビルド構成を決定しようとします。自動判別に失敗した場合は、プロジェクトのルートディレクトリにある hie.yaml ファイルを使って 手動で設定する とよいでしょう。\n\n"
    },
    {
      "title": "ghcid",
      "level": 4,
      "content": "ghcid は、Haskell 開発用の GHCi ベースのツールです。は、ソースコードの変更ごとにコンパイラエラーと警告を表示するシンプルかつ堅牢な方法を提供します。ghcidAUR パッケージ経由でインストールできます。\n\n"
    },
    {
      "title": "hoogle",
      "level": 4,
      "content": "hoogle を使用すると、関数名またはおおよその型シグネチャによって Haskell ライブラリを検索できます。hoogle パッケージ経由でインストールできます。\n\nhoogle のオンライン版は https://hoogle.haskell.org で入手できます。\n\n"
    },
    {
      "title": "hlint",
      "level": 4,
      "content": "hlint は、代替関数の使用、コードの簡素化、冗長性の特定など、Haskell コードの改善の可能性を示唆しています。これは、hlint パッケージを通じて入手できます。\n\n"
    },
    {
      "title": "stan",
      "level": 4,
      "content": "stan は、hlint を補完する Haskell 静的アナライザーです。2021 年 6 月現在はベータ段階です。\n\n"
    },
    {
      "title": "weeder",
      "level": 4,
      "content": "weeder はプログラム全体のデッドコード解析を行うアプリケーションです。\n\n"
    },
    {
      "title": "フォーマッタ",
      "level": 3,
      "content": "- brittany — Haskell ソースコードフォーマッタ\n\n- Floskell — 柔軟性と設定可能性に焦点を当てた hindent のフォーク\n\n- fourmolu — 様々な書式パラメータを設定する機能を追加した Ormolu のフォーク\n\n- hindent — 拡張可能な Haskell プリンター\n\n- Ormolu — Haskell ソースコード用のフォーマッタで、設定を必要としない \"真の\" 書式スタイルを実装しています。\n\n- stylish-haskell — シンプルな Haskell コードの整形ツール。\n\n"
    },
    {
      "title": "Visual Studio Code",
      "level": 4,
      "content": "Visual Studio Code には、haskell-language-server を利用した Haskell 拡張機能 があります。haskell-language-server がインストールされていない場合は、Haskell 拡張機能が静的にリンクされた Linux バイナリを自動的にダウンロードしてインストールします。\n\n"
    },
    {
      "title": "IntelliJ IDEA",
      "level": 4,
      "content": "IntelliJ IDEA Haskell のサポートは、Haskell プラグイン によって提供されます。 intellij-idea-community-edition を含む IntelliJ IDEA のどのエディションでも動作します。\n\n新しいプロジェクトを作成するか、既存のプロジェクトを IntelliJ IDEA にインポートするには、Stack をインストールする必要があります。2021 年 6 月現在、Cabal のみのプロジェクト はサポートされていません\n\n"
    },
    {
      "title": "Vim",
      "level": 4,
      "content": "Vim の基本的な設定のハイライトとインデントは、haskell-vim プラグインを介して取得できます。IDE のようなエクスペリエンスを向上させるには、LSP client プラグイン (例:coc.nvim、ALE、LanguageClient-neovim) と haskell- language-server\n\n"
    },
    {
      "title": "Emacs",
      "level": 4,
      "content": "Haskell の基本的な Emacs サポートは、公式 haskell-mode によって提供されます。より高度な機能については、lsp-haskell を haskell-language-server とともに使用してください。\n\n"
    },
    {
      "title": "代替インストール",
      "level": 2,
      "content": "汎用 Linux ディストリビューションに Haskell をインストールするには、ghcup と Stack という 2 つの公式に推奨される方法があります。どちらの方法でも、静的にリンクされた GHC、ツール、ライブラリがホーム ディレクトリにインストールされます。\n\n公式リポジトリの Haskell パッケージの代わりに ghcup または Stack を使用する利点は、複数のバージョンの GHC を並べてインストールして管理できることです。この方法でインストールされた Cabal と Stack は通常、追加の設定を行わずにすぐに動作するため、初心者にとっては簡単かもしれません。\n\nHaskell をインストールするまったく異なる方法は、Nix パッケージ マネージャーです。Nix は学習曲線がより急峻ですが、Haskell パッケージと非 Haskell パッケージの両方を信頼性が高く再現可能な方法で管理する上でより高い柔軟性を提供します。\n\n"
    },
    {
      "title": "ghcup",
      "level": 3,
      "content": "ghcup は、GHC の複数のバージョンを簡単にインストールし、それらを切り替えることができるコマンドラインツールです。これは、[1]、pyenv、および jenv とスコープが似ています。\n\nghcup-hs-binAUR パッケージをインストールしてください。あるいは、公式の インストール手順 に従うか、手動で ghcup バイナリ をダウンロードして $PATH のどこかに置いてください。\n\nデフォルトでは、ghcup は GHC 実行ファイルを ~/.ghcup/bin にインストールします。このディレクトリをシェル設定ファイルの $PATH 環境変数に追加する必要があります。例えば bash なら ~/.bashrc、zsh なら ~/.zshrc です。Cabal によってインストールされた実行可能ファイルを実行したい場合は、~/.cabal/bin も $PATH に追加してください:\n\n```\nexport PATH=\"$HOME/.cabal/bin:$HOME/.ghcup/bin:$PATH\"\n```\n\nghcup は、その機能のほとんどをサポートする便利な TUI を提供します。\n\n```\n$ ghcup tui\n```\n\nあるいは、次の CLI コマンドを使用することもできます。\n\nGHC と Cabal の利用可能なバージョンをリストします。\n\n```\n$ ghcup list\n```\n\n推奨バージョンの GHC をインストールします。\n\n```\n$ ghcup install ghc\n```\n\nたとえば、GHC の特定のバージョンをインストールすることもできます。\n\n```\n$ ghcup install ghc 8.10.2\n```\n\n上記のコマンドでは、GHC が $PATH で自動的に利用可能になるわけではありません。デフォルトで使用する GHC バージョンを選択する必要があります。\n\n```\n$ ghcup set ghc 8.10.2\n```\n\nCabal の推奨バージョンをインストールします。\n\n```\n$ ghcup install cabal\n```\n\nCabal を使用して、特別な設定やコマンドラインフラグを必要とせずに、静的にリンクされた Haskell 実行可能ファイルをビルドおよびインストールできるようになりました。\n\n```\n$ cabal update\n$ cabal install executable\n```\n\n新しい Cabal プロジェクトを開始するには:\n\n```\n$ cd /path/to/my-project\n$ cabal init\n$ cabal build\n$ cabal run\n```\n\n```\nUp to date\nHello, Haskell!\n```\n\nhaskell-language-server をインストールするには、次のコマンドを使用します。\n\n```\n$ ghcup install hls\n```\n\n詳細については、公式 ghcup および Cabal ドキュメントを参照してください。\n\n"
    },
    {
      "title": "ネイティブインストールでの使用",
      "level": 4,
      "content": "ネイティブインストールと一緒に GHCup と Cabal を使用することを決めた場合、Cabal にどの GHC を使用するかを指定する必要があります。$HOME/.config/cabal/config ファイルで使用する GHC バージョンのパスを指定し、with-compiler: 行を探してコメントを解除してください。\n\n```\nwith-compiler: path_of_your_ghc\n```\n\nGHCup を使用する場合、GHC のパスは $HOME/.ghcup/bin 配下に配置されることを覚えておいてください。また、GHCup は使用したい GHC のバージョンを設定すると、そのバージョンを $HOME/.ghcup/bin/ghc にリンクします。このパスを Cabal の設定に指定しておけば、GHCup を使って Cabal が使用する GHC のバージョンを切り替えることができます。\n\n"
    },
    {
      "title": "Stack",
      "level": 3,
      "content": "stack-staticAUR パッケージをインストールします。あるいは、公式の インストール手順 に従うか、スタックバイナリ を手動でダウンロードして、それをあなたの $PATH に配置することもできます。\n\nスタックによってインストールされた実行可能ファイルを実行したい場合は、シェル設定ファイルの $PATH 環境変数に ~/.local/bin ディレクトリを追加します (例:<code~/.bashrc>~/) bash の場合は、{ic zsh の場合は ~/.zshrc:\n\n```\nexport PATH=\"$HOME/.local/bin:$PATH\"\n```\n\nstack setup を実行して、最新のスタック LTS スナップショットから GHC を自動的にインストールします。\n\n```\n$ stack setup\n```\n\n特別な設定やコマンドラインフラグを必要とせずに、Stack を使用して静的にリンクされた Haskell パッケージを構築およびインストールできるようになりました。\n\n```\n$ stack install package\n```\n\n詳細については、公式 Stack ドキュメント を参照してください。\n\n"
    },
    {
      "title": "Nix",
      "level": 3,
      "content": "Table content:\nこの記事またはセクションは加筆を必要としています。 理由: I cannot offer a good enough overview, due to no experience with it (議論: トーク:Haskell#)\n\n"
    },
    {
      "title": "静的リンク",
      "level": 3,
      "content": "- このセクションでは、静的にリンクされた Haskell パッケージを Arch 上でビルドしながら、公式リポジトリからインストールされた GHC を使用する方法について説明します。続行する前に、~/.cabal ディレクトリと ~/.stack ディレクトリが存在する場合は必ず削除してください。\n- この記事の文脈において、静的リンクは完全に静的な ELF バイナリを生成することを意味するものではありません。Haskell コードのみが単一の ELF バイナリに静的にリンクされ、それは glibc などの他のシステムライブラリに動的にリンクされる場合があります。\n\n静的リンクを使用するには、少なくとも、ghc-static パッケージを通じて静的ブートライブラリをインストールする必要があります。これにより、ブートライブラリだけでなく、公式リポジトリから haskell-* パッケージを通じてインストールされない他のライブラリにもっぱら依存するプロジェクトをビルドできるようになります。\n\n残念ながら、プロジェクトがインストールした動的にリンクされた haskell-* パッケージのいずれかに依存している場合、Cabal は依存関係の解決時に静的ライブラリの不在を考慮しません。その結果、既存の haskell-* パッケージを使用しようとし、静的ライブラリを検出すると linker errors で失敗します。:\n\n```\nCould not find module ‘SomePackage.SomeModule’\nThere are files missing in the ‘somepackage-0.1.0.0’ package,\ntry running 'ghc-pkg check'.\nUse -v (or `:set -v` in ghci) to see a list of the files searched for.\n```\n\nghc-staticとは異なり、連携可能な \"haskell-*-static\" パッケージはありません。ただし、以下の各セクションで説明するように、この問題を回避する他の方法もあります。\n\n"
    },
    {
      "title": "静的グローバルパッケージデータベース",
      "level": 4,
      "content": "直接的な アプローチ は、公式の ghc-static パッケージによって提供されており、代替の \"静的\" パッケージが公開されています。グローバルパッケージデータベース(/usr/lib/ghc-version/static-package.conf.d)静的データベースは、静的にリンク可能なブートパッケージのみに制限されているため、デフォルトデータベースの代わりに静的データベースを使用するように Cabal が再構成されている場合、動的専用の haskell-* パッケージがリンクされていないかのように動作します。\n\n静的データベースの正確なパスは、次のようなコマンドを使用して構築時に決定できます。\n\n```\n$ ghc --print-global-package-db | sed 's/\\(package\\.conf\\.d\\)$/static-\\1/'\n```\n\n```\n/usr/lib/ghc-version/static-package.conf.d\n```\n\n静的データベースを使用できるようにする方法は次のとおりです。\n\n- Cabal でパッケージを構築する場合、次のフラグを渡すと、グローバルパッケージの選択をブートパッケージのみに制限できます。\n\n```\n$ cabal configure --ghc-pkg-option=\"--global-package-db=$(ghc --print-global-package-db | sed 's/\\(package\\.conf\\.d\\)$/static-\\1/')\"\n```\n\n- Cabal ではなく GHC を使用して直接ビルドする場合、次のフラグを渡してグローバルパッケージデータベースをオーバーライドできます。\n\n```\n$ ghc -clear-package-db -package-db \"$(ghc --print-global-package-db | sed 's/\\(package\\.conf\\.d\\)$/static-\\1/')\" -user-package-db ...\n```\n\n"
    },
    {
      "title": "ghc-pristine",
      "level": 4,
      "content": "ghc-pristineAUR パッケージをインストールします。このパッケージは既存の GHC インストールをラップして、ブートライブラリのみを含むパッケージデータベースを備えた別の GHC ディストリビューションを /usr/share/ghc-pristine に作成します。これにより、動的にリンクされた haskell-* パッケージを使用せずに半分離環境が効果的に作成されますが、それでも公式リポジトリの GHC コンパイラーが利用されます。次に、静的リンクを使用してソフトウェアを構築するには、ラップされたコンパイラー /usr/share/ghc-pristine/bin/ghc を呼び出すだけです。Cabal の場合、これは ~/.cabal/config の次の構成に相当します。\n\n```\n~/.cabal/config\n```\n\n```\nwith-compiler: /usr/share/ghc-pristine/bin/ghc\n```\n\nプロジェクトディレクトリから次のコマンドを実行して、プロジェクトごとにコンパイラへのパスを指定することもできます。\n\n```\n$ cabal configure --with-compiler=/usr/share/ghc-pristine/bin/ghc\n```\n\n"
    },
    {
      "title": "cabal-static",
      "level": 4,
      "content": "Arch で静的リンクを取り戻すもう 1 つの方法は、cabal-staticAUR パッケージをインストールすることです。公式の cabal-install とは異なり、これは動的にリンクされた haskell-* の依存関係を公式リポジトリから取得せず、同じシステムにインストールされた静的 Haskell ライブラリと共有 Haskell ライブラリの混合を回避します。その後、次の制限付きで通常どおり Cabal を使用できます: インストールした他の Haskell パッケージが ghc、ghc-libs のみであることを確認する必要があります。および ghc-static (cabal-install、stack、および公式リポジトリで入手可能な haskell-* パッケージではありません。)\n\n"
    },
    {
      "title": "stack-static",
      "level": 4,
      "content": "stack-staticAUR パッケージをインストールします。cabal-static メソッドと同様に、公式リポジトリからインストールした他の Haskell パッケージが ghc、ghc-libs、および ghc-static のみであることを確認してください。次に、動的リンク用のスタックの設定 で説明されているように、システム GHC を使用するようにスタックをセットアップします。\n\n```\n$ stack setup --system-ghc --resolver resolver\n```\n\nこれらのオプションを永続的にするには、次のスニペットを ~/.stack/config.yaml に貼り付けます。\n\n```\n~/.stack/config.yaml\n```\n\n```\n# Stop downloading GHCs into isolated locations under ~/.stack.\ninstall-ghc: false\n\n# Allow Stack to pick the system GHC (false by default).\nsystem-ghc: true\n\n# Allow to use, say, Stackage snapshot for GHC 8.8.2 with system GHC 8.8.3.\ncompiler-check: newer-minor\n```\n\nこの設定では、通常と同じように静的にリンクされたパッケージをビルドできますが、Stack によって提供される GHC の代わりにシステム GHC インストールを使用します。\n\n"
    },
    {
      "title": "hpack-static-bin",
      "level": 4,
      "content": "hpack-static-binAUR は、haskell-hpack の代わりに静的にリンクされた (haskell-* 依存関係がないことを意味します) を提供します。プリコンパイルされているため、make 依存関係は必要ありません。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Official website of the Haskell programming language\n- Haskell documentation\n- Haskell Wiki\n- GHC User Guide\n- Cabal User Guide\n- Stack User Guide\n- Haskell community's central package archive\n- Stable source of Haskell packages\n- Haskell API search engine\n- Learn You a Haskell for Great Good!\n- Real World Haskell\n- Haskell Wikibook\n- What I Wish I Knew When Learning Haskell\n- Awesome Haskell: an auxiliary list of awesome Haskell links, frameworks, libraries and software\n\n"
    }
  ]
}