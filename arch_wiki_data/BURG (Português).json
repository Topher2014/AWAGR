{
  "title": "BURG (Português)",
  "url": "https://wiki.archlinux.org/title/BURG_(Portugu%C3%AAs)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- Processo de inicialização do Arch\n- Master Boot Record\n- Tabela de Partição GUID\n- Unified Extensible Firmware Interface\n- GRUB Legacy\n- GRUB/Exemplos de EFI\n- GRUB/Dicas e truques\n- Multiboot USB drive\n\nGRUB (GRand Unified Bootloader) é um gerenciador de boot. O GRUB atual também é chamado de GRUB 2. O GRUB original, ou GRUB Legacy, corresponde às versões 0.9x. Esta página descreve exclusivamente o GRUB 2.\n\n"
    },
    {
      "title": "Sistemas UEFI",
      "level": 2,
      "content": "- É recomendável ler e entender as páginas Unified Extensible Firmware Interface, Particionamento#Tabela de Partição GUID e Processo de inicialização do Arch#No UEFI.\n- Ao instalar o UEFI, é importante inicializar a mídia de instalação no modo UEFI, caso contrário o efibootmgr não poderá adicionar a entrada de inicialização UEFI do GRUB. A instalação no caminho de inicialização reserva continuará funcionando mesmo no modo BIOS, já que ele não toca na NVRAM.\n- Para inicializar a partir de um disco usando UEFI, é necessária uma partição de sistema EFI. Siga Partição de sistema EFI#Verificar uma partição existente para descobrir se você já tem uma, caso contrário você precisa criá-la.\n- Este artigo inteiro assume que é possível inserir módulos GRUB2 adicionais via insmod. Conforme discutido em Unified Extensible Firmware Interface/Secure Boot#shim with key and GRUB, esse não é o caso em sistemas UEFI com Secure Boot ativado. Se você quiser usar qualquer módulo GRUB adicional que não esteja incluído no arquivo GRUB EFI padrão grubx64.efi em um sistema de inicialização segura, será necessário gerar novamente o GRUB EFI grubx64.efi com grub-mkstandalone com os módulos GRUB adicionais incluídos.\n\n"
    },
    {
      "title": "Instalação",
      "level": 3,
      "content": "- Os firmwares da UEFI não são implementados de forma consistente entre os fabricantes. O procedimento descrito abaixo destina-se a funcionar em uma ampla variedade de sistemas UEFI, mas os que enfrentam problemas, apesar de aplicarem esse método, são encorajados a compartilhar informações detalhadas e, se possível, as soluções alternativas encontradas para o caso específico do hardware. Um artigo /Exemplos de EFI foi fornecido para esses casos.\n- A seção supõe que você esteja instalando o GRUB para sistemas x86_64. Para sistemas UEFI IA32 (32 bits) (não confundir com CPUs de 32 bits), substitua x86_64-efi por i386-efi onde apropriado.\n- Veja Secure Boot para instruções sobre como implementá-lo.\n\nPrimeiro, instale os pacotes grub e efibootmgr: GRUB é o gerenciador de boot, enquanto efibootmgr é usado pelo script de instalação do GRUB para escrever entradas de inicialização para NVRAM.\n\nEntão, siga os seguintes passos para instalar o GRUB em seu disco:\n\n1. Monte a partição de sistema EFI e, no restante da sessão, substitua esp com seu ponto de montagem.\n1. Escolha um identificador de gerenciador de boot, aqui chamado GRUB. Um diretório com esse nome será criado em esp/EFI/ para armazenar o binário EFI e esse é o nome que aparecerá no menu de inicialização UEFI para identificar a entrada de inicialização do GRUB.\n1. Execute o seguinte comando para instalar o aplicativo EFI do GRUB grubx64.efi em esp/EFI/GRUB/ e instalar seus módulos para /boot/grub/x86_64-efi/. {{Nota|Certifique-se de instalar os pacotes e executar o comando grub-install do sistema no qual o GRUB será instalado como o gerenciador de boot. Isso significa que se você estiver inicializando a partir do ambiente de instalação live, você precisa estar dentro do chroot quando estiver executando grub-install. Se por algum motivo for necessário executar grub-install de fora do sistema instalado, anexe a opção --boot-directory= com o caminho para o /boot, por exemplo, --boot-directory=/mnt/boot. # grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB\n```\n\nApós a conclusão da instalação acima, o diretório principal do GRUB está localizado em /boot/grub/. Leia GRUB/Tips and tricks#Alternative install method para saber como especificar um local alternativo. Note que grub-install também tenta criar uma entrada no gerenciador de boot do firmware, chamado GRUB no exemplo acima -– isso pode, no entanto, falhar se suas entradas de inicialização estiverem lotadas; use efibootmgr para remover entradas desnecessárias.\n\nLembre-se de gerar o arquivo de configuração principal após finalizar a configuração.\n\n- --efi-directory e --bootloader-id são específicos para UEFI do GRUB, --efi-directory substitui --root-directory que está obsoleto.\n- Você pode notar a ausência de uma opção caminho_dispositivo (por exemplo: /dev/sda) no comando grub-install. Na verdade, qualquer caminho_dispositivo fornecido será ignorado pelo script de instalação do GRUB UEFI. De fato, os gerenciadores de boot de UEFI não usam um código de inicialização da MBR ou um setor de inicialização de partição.\n\nVeja a solução de problemas do UEFI caso tenha problemas. Além disso, veja GRUB/Tips and tricks#UEFI further reading.\n\n"
    },
    {
      "title": "Instruções específicas de Tabela de Partição GUID (GPT)",
      "level": 3,
      "content": "Em uma configuração de BIOS/GPT, é necessária uma partição de inicialização de BIOS. O GRUB incorpora seu core.img nessa partição.\n\n- Antes de tentar este método, lembre-se de que nem todos os sistemas poderão ter suporte a este esquema de particionamento. Leia mais sobre Particionamento#Tabela de Partição GUID.\n- A partição de inicialização de BIOS é necessária apenas pelo GRUB em uma configuração de BIOS/GPT. Em uma configuração de BIOS/MBR, o GRUB usa a lacuna pós-MBR para a incorporação do core.img. No GPT, no entanto, não há espaço não utilizado garantido antes da primeira partição.\n- Para sistemas UEFI, essa partição extra não é necessária, pois não há incorporação de setores de inicialização nesse caso. No entanto, os sistemas UEFI ainda requerem uma partição de sistema EFI.\n\nCrie uma partição de mebibyte (+1M com fdisk ou gdisk) no disco sem sistema de arquivos e com o tipo de partição GUID 21686148-6449-6E6F-744E-656564454649.\n\n- Selecione o tipo de partição BIOS inicialização para fdisk.\n- Selecione o código de tipo de partição ef02 para gdisk.\n- Para o parted defina/ative a opção bios_grub a partição.\n\nEsta partição pode estar em qualquer ordem de posição, mas deve estar nos primeiros 2 TiB do disco. Esta partição precisa ser criada antes da instalação do GRUB. Quando a partição estiver pronta, instale o gerenciador de boot conforme as instruções abaixo.\n\nO espaço antes da primeira partição também pode ser usado como partição de inicialização de BIOS, embora esteja fora da especificação de alinhamento da GPT. Como a partição não será acessada regularmente, problemas de desempenho podem ser desconsiderados, embora alguns utilitários de disco exibam um aviso sobre isso. Em fdisk ou gdisk crie uma nova partição a partir do setor 34 e abrangendo até 2047 e defina o tipo. Para que as partições visualizáveis comecem na base, considere adicionar essa partição por último.\n\n"
    },
    {
      "title": "Instruções específicas de Master Boot Record (MBR)",
      "level": 3,
      "content": "Normalmente, o intervalo pós-MBR (após a região de 512 bytes MBR e antes do início da primeira partição) em muitos sistemas particionados MBR é de 31 KiB quando os problemas de alinhamento do cilindro de compatibilidade do DOS são atendidos na tabela de partições. No entanto, uma lacuna pós-MBR de cerca de 1 a 2 MiB é recomendada para fornecer espaço suficiente para incorporar o core.img do GRUB (FS#24103). É aconselhável usar uma ferramenta de particionamento que suporte alinhamento de partições de 1 MiB para obter este espaço, bem como para satisfazer outros problemas de setor não-512-byte (que não estão relacionados à incorporação de core.img).\n\n"
    },
    {
      "title": "Instalação",
      "level": 3,
      "content": "Instale o pacote grub. (Ele vai substituir o grub-legacyAUR se este ainda estiver instalado.) Então, execute:\n\n```\n# grub-install --target=i386-pc /dev/sdX\n```\n\nsendo i386-pc usado deliberadamente, independentemente de sua arquitetura real, e /dev/sdX o disco (não a partição) no qual o GRUB deve ser instalado. Por exemplo, o disco /dev/sda ou /dev/nvme0n1 ou /dev/mmcblk0. Veja Arquivo de dispositivo#Nomes de dispositivos de bloco para uma descrição do esquema de nomeação de dispositivo de bloco.\n\nAgora, você deve gerar o arquivo de configuração principal.\n\nSe você usa LVM para seu /boot, você pode instalar o GRUB em vários discos físicos.\n\nVeja grub-install(8) e o manual do GRUB para mais detalhes no comando grub-install.\n\n"
    },
    {
      "title": "Configuração",
      "level": 2,
      "content": "Em um sistema instalado, o GRUB carrega o arquivo de configuração /boot/grub/grub.cfg em cada inicialização. Você pode seguir #grub.cfg gerado para usar uma ferramenta ou #grub.cfg personalizado para uma criação manual.\n\n"
    },
    {
      "title": "grub.cfg gerado",
      "level": 3,
      "content": "Esta seção cobre apenas a edição do arquivo de configuração /etc/default/grub. Veja GRUB/Tips and tricks para mais informações.\n\n"
    },
    {
      "title": "Gerar o arquivo de configuração principal",
      "level": 4,
      "content": "Após a instalação, o arquivo de configuração principal /boot/grub/grub.cfg precisa ser gerado. O processo de geração pode ser influenciado por uma variedade de opções em /etc/default/grub e scripts em /etc/grub.d/.\n\nSe você não tiver feito configurações adicionais, a geração automática determinará o sistema de arquivos raiz do sistema para inicializar o arquivo de configuração. Para que isso seja bem sucedido, é importante que o sistema seja inicializado ou \"chrooted\".\n\n- O caminho do arquivo padrão é /boot/grub/grub.cfg, não /boot/grub/i386-pc/grub.cfg.\n- Se você está tentando executar o grub-mkconfig em um chroot ou em um contêiner systemd-nspawn, você pode notar que ele não funciona: grub-probe: failed to get canonical path of /dev/sdaX. Neste caso, tente usar arch-chroot como descrito nesta publicação no BBS.\n\nUse a ferramenta grub-mkconfig para gerar /boot/grub/grub.cfg:\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\nPor padrão, os scripts de geração adicionam automaticamente entradas de menu para todos os kernels do Arch Linux instalados na configuração gerada.\n\n- Depois de instalar ou remover um kernel, você só precisa executar novamente o comando acima, o grub-mkconfig.\n- Para obter dicas sobre o gerenciamento de várias entradas do GRUB, por exemplo, ao usar os kernels linux e linux-lts, consulte GRUB/Tips and tricks#Multiple entries.\n\nPara adicionar automaticamente entradas para outros sistemas operacionais instalados, consulte #Detectando outros sistemas operacionais.\n\nVocê pode adicionar entradas adicionais ao menu editando /etc/grub.d/40_custom e regerando /boot/grub/grub.cfg. Ou você pode criar /boot/grub/custom.cfg e adicioná-las lá. Alterações no /boot/grub/custom.cfg não requerem reexecução do grub-mkconfig, já que /etc/grub.d/41_custom adiciona a declaração source para o arquivo de configuração gerado.\n\nVeja #Exemplos de entrada de menu de boot para mais exemplos de entradas de menu personalizadas.\n\n"
    },
    {
      "title": "Detectando outros sistemas operacionais",
      "level": 4,
      "content": "Para fazer com que o grub-mkconfig procure por outros sistemas instalados e adicioná-los automaticamente ao menu, instale o pacote os-prober e monte as partições das quais outros outros sistemas inicializam. Então, execute novamente o grub-mkconfig. Se você receber a seguinte saída: Warning: os-prober will not be executed to detect other bootable partitions então edite /etc/default/grub e adicione/descomente:\n\n```\nGRUB_DISABLE_OS_PROBER=false\n```\n\nE tente novamente.\n\n- O ponto de montagem exato não importa, pois os-prover lê o mtab para identificar lugares para pesquisar por entradas inicializáveis.\n- Lembre-se de montar as partições toda vez que você executar grub-mkconfig para incluir os outros sistemas operacionais.\n\nPara o Windows instalado no modo UEFI, certifique-se de que a partição de sistema EFI contendo o Windows Boot Manager (bootmgfw.efi) esteja montada. Execute os-prober como root para detectar e gerar uma entrada para ele.\n\nPara Windows instalado no modo BIOS, monte a partição de sistema do Windows (seu rótulo do sistema de arquivos deve ser System Reserved ou SYSTEM). Execute os-prober como root para detectar e gerar uma entrada para ele.\n\n- As partições NTFS nem sempre podem ser detectadas quando montadas com os drivers padrão do Linux. Se o GRUB não estiver detectando, tente instalar o NTFS-3G e remontá-las.\n- Partições encriptadas do Windows podem precisar ser descriptografadas antes da montagem. Para o BitLocker, isso pode ser feito com cryptsetup (Português) ou dislockerAUR. Isso deve ser suficiente para o os-prober adicionar a entrada correta.\n\n"
    },
    {
      "title": "Argumentos adicionais",
      "level": 4,
      "content": "Para passar argumentos adicionais personalizados para a imagem do Linux, você pode definir as variáveis GRUB_CMDLINE_LINUX e GRUB_CMDLINE_LINUX_DEFAULT em /etc/default/grub. As duas são anexadas uma à outra e passadas ao kernel ao gerar entradas de inicialização comuns. Para a entrada de inicialização de recuperação, apenas GRUB_CMDLINE_LINUX é usado na geração.\n\nNão é necessário usar ambos, mas pode ser útil. Por exemplo, você poderia usar GRUB_CMDLINE_LINUX_DEFAULT=\"resume=UUID=uuid-da-partição-swap quiet\", sendo uuid-da-partição-swap o UUID da sua partição swap para permitir a continuação após hibernação. Isso geraria uma entrada de inicialização de recuperação sem o resumo e sem quiet para suprimir mensagens do kernel durante uma inicialização a partir dessa entrada de menu. Porém, as outras entradas de menu (comuns) os teriam como opções.\n\nPor padrão, o grub-mkconfig determina o UUID do sistema de arquivos raiz para a configuração. Para desabilitar isso, descomente GRUB_DISABLE_LINUX_UUID=true.\n\nPara gerar a entrada de recuperação do GRUB, você precisa garantir que GRUB_DISABLE_RECOVERY não esteja definido como true em /etc/default/grub.\n\nVeja Parâmetros do kernel para mais informações.\n\n"
    },
    {
      "title": "LVM",
      "level": 4,
      "content": "Se você usa LVM para sua partição /boot ou /, certifique-se de que o módulo lvm esteja pré-carregado:\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_PRELOAD_MODULES=\"... lvm\"\n```\n\n"
    },
    {
      "title": "RAID",
      "level": 4,
      "content": "O GRUB fornece um manuseio conveniente de volumes RAID. Você precisa carregar os módulos GRUB mdraid09 ou mdraid1x para permitir que você aborde o volume nativamente:\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_PRELOAD_MODULES=\"... mdraid09 mdraid1x\"\n```\n\nPor exemplo, /dev/md0 se torna:\n\n```\nset root=(md/0)\n```\n\nsendo que um volume RAID particionado (p.ex., /dev/md0p1) se torna:\n\n```\nset root=(md/0,1)\n```\n\nPara instalar o grub ao usar o RAID1 como partição /boot (ou usando /boot alojado em uma partição raiz RAID1), nos sistemas BIOS, simplesmente execute o grub-install em ambas as unidades, como:\n\n```\n# grub-install --target=i386-pc --debug /dev/sda\n# grub-install --target=i386-pc --debug /dev/sdb\n```\n\nsendo que o vetor RAID 1 contendo /boot está contido em ambos /dev/sda e /dev/sdb.\n\n"
    },
    {
      "title": "/boot criptografado",
      "level": 4,
      "content": "O GRUB também tem suporte especial para inicializar com um /boot criptografado. Isto é feito desbloqueando um dispositivo de bloco LUKS para ler sua configuração e carregar qualquer initramfs e kernel dele. Esta opção tenta resolver o problema de ter uma partição de inicialização não criptografada.\n\nNote: **não** \n\nPara ativar este recurso, criptografe a partição com /boot que reside nela usando LUKS normalmente. Em seguida, adicione a seguinte opção para /etc/default/grub:\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_ENABLE_CRYPTODISK=y\n```\n\nEsta opção é usada pelo grub-install para gerar o grub core.img.\n\nCertifique-se de instalar o grub depois de modificar esta opção ou criptografar a partição.\n\nSem mais alterações, você será solicitado duas vezes a informar uma senha: o primeiro para o GRUB desbloquear o ponto de montagem /boot na inicialização, o segundo para desbloquear o sistema de arquivos raiz como implementado pelo initramfs. Você pode usar um initramfs para evitar isso.\n\n- Se você quiser gerar o arquivo de configuração principal, certifique-se de que /boot esteja montado.\n- Para realizar atualizações do sistema envolvendo o ponto de montagem /boot, certifique-se de que o /boot criptografado esteja desbloqueado e montado antes de executar uma atualização. Com uma partição /boot separada, isso pode ser feito automaticamente na inicialização usando o crypttab com uma keyfile.\n\n- Se você usar um mapa de teclado especial, uma instalação padrão do GRUB não o saberá. Isso é relevante para saber como inserir a frase secreta para desbloquear o dispositivo de bloco LUKS. Consulte GRUB/Tips and tricks#Manual configuration of core image for early boot.\n- Se você tiver problemas para obter a solicitação de uma senha (erros relacionados a cryptouuid, cryptodisk ou \"dispositivo não encontrado\"), tente reinstalar o GRUB e acrescentar --modules=\"part_gpt part_msdos\" ao final do seu comando grub-install.\n\nGRUB 2.06 tem suporte limitado ao LUKS2. Veja GRUB bug #55093.\n\n- Argon2id (padrão do cryptsetup) e Argon2i PBKDFs não são suportados (GRUB bug #59409), somente PBKDF2 é.\n- grub-install não oferece suporte a criar uma imagem core que pudesse ser usada para desbloquear LUKS2. Veja os comentários abaixo ou em grub-gitAUR para uma solução de contorno.\n\nUse grub-install conforme descrito na seção #Instalação. Porém, o binário EFI gerado não oferece suporte a LUKS2 e precisa ser substituído.\n\nCrie /boot/grub/grub-pre.cfg. Substitua UUID pela saída de lsblk -dno UUID /dev/nvme0n1p2 | tr -d -. Use lvm/NomeDoGrupoDoVolume-NomeDoVolumeLógico em vez de crypto0 se sua unidade raiz estiver em um volume lógico LVM dentro do volume LUKS.\n\n```\n/boot/grub/grub-pre.cfg\n```\n\n```\nset crypto_uuid=UUID\ncryptomount -u $crypto_uuid\nset root=crypto0\nset prefix=($root)/boot/grub\ninsmod normal\nnormal\n```\n\nAdicione lvm se você usa LVM. Substitua ext2 por btrfs ou outro módulo de sistema de arquivos, se necessário. Substitua gcry_sha256 por gcry_sha512 ou gcry_whirlpool se for necessário:\n\n```\n$ grub-mkimage -p /boot/grub -O x86_64-efi -c grub-pre.cfg -o /tmp/grubx64.efi luks2 part_gpt cryptodisk gcry_rijndael pbkdf2 gcry_sha256 ext2\n```\n\nCopie à ESP:\n\n```\n# install -v /tmp/grubx64.efi esp/EFI/GRUB/grubx64.efi\n```\n\nSe você inserir uma senha inválida durante a inicialização e terminar no shell de recuperação do GRUB, tente cryptomount -a para montar todas (espera-se que apenas uma) partições criptografadas ou use cryptomount -u $crypto_uuid para montar uma específica. Em seguida, prossiga com insmod normal e normal como de costume.\n\nSe você inserir uma senha correta, mas um erro Invalid passphrase for retornado imediatamente, certifique-se de que os módulos criptográficos corretos sejam especificados. Use cryptsetup luksDump /dev/nvme0n1p2 e verifique se a função hash (SHA-256, SHA-512) corresponde aos módulos (gcry_sha256, gcry_sha512) instalados e o algoritmo PBKDF seja pbkdf2. O hash e o algoritmos de PBDKDF podem ser alterados para chaves existentes usando cryptsetup luksConvertKey --hash sha256 --pbkdf pbkdf2 /dev/nvme0n1p2. Em circunstâncias normais, deve levar alguns segundos antes que a senha seja processada.\n\n"
    },
    {
      "title": "grub.cfg personalizado",
      "level": 3,
      "content": "Esta seção descreve a criação manual de entradas de inicialização do GRUB em /boot/grub/grub.cfg em vez de confiar em grub-mkconfig.\n\nUm arquivo de configuração básico do GRUB usa as seguintes opções:\n\n- (hdX,Y) é a partição Y no disco X, números de partição iniciando em 1, números de disco iniciando em 0\n- set default=N é a entrada de inicialização padrão que é escolhida após atingido um tempo limite para ação do usuário\n- set timeout=M é o tempo M para aguardar em segundos para uma seleção de usuário antes da padrão ser inicializada\n- menuentry \"título\" {opções desta entrada} é uma entrada padrão chamada título\n- set root=(hdX,Y) define a partição de inicialização, onde os módulos de kernel e GRUB estão armazenados (o boot não precisa estar em uma partição separada e pode simplesmente ser um diretório sob a partição \"root\" (/)\n\n"
    },
    {
      "title": "Exemplos de entrada de menu de boot",
      "level": 4,
      "content": "Para obter dicas sobre o gerenciamento de várias entradas do GRUB, por exemplo, ao usar os kernels linux e linux-lts, consulte GRUB/Tips and tricks#Multiple entries.\n\nPara entradas de menu de inicialização de Archiso e Archboot, veja Multiboot USB drive#Boot entries.\n\n```\nmenuentry \"Desligamento do sistema\" {\n\techo \"Desligando o sistema...\"\n\thalt\n}\n```\n\n```\nmenuentry \"Reinicialização do sistema\" {\n\techo \"Reinicializando o sistema...\"\n\treboot\n}\n```\n\n```\nif [ ${grub_platform} == \"efi\" ]; then\n    menuentry 'Configuração do firmware UEFI' --id 'uefi-firmware' {\n\t\tfwsetup\n\t}\nfi\n```\n\nAo iniciar o modo UEFI, o GRUB pode carregar outros binários EFI.\n\n```\nif [ ${grub_platform} == \"efi\" ]; then\n\tcoloque apenas entradas de menu UEFI aqui\nfi\n```\n\nVocê pode iniciar o UEFI Shell colocando-a na raiz da partição de sistema EFI e adicionando esta entrada de menu:\n\n```\nmenuentry \"UEFI Shell\" {\n\tinsmod fat\n\tinsmod chain\n\tsearch --no-floppy --set=root --file /shellx64.efi\n\tchainloader /shellx64.efi\n}\n```\n\nBaixe o aplicativo EFI gdisk e copie gdisk_x64.efi para esp/EFI/tools/.\n\n```\nmenuentry \"gdisk\" {\n\tinsmod fat\n\tinsmod chain\n\tsearch --no-floppy --set=root --file /EFI/tools/gdisk_x64.efi\n\tchainloader /EFI/tools/gdisk_x64.efi\n}\n```\n\nSe você tiver uma imagem de kernel unificada gerada a partir de Secure Boot ou outro meio, você pode adicioná-lo ao menu de inicialização. Por exemplo:\n\n```\nmenuentry \"Arch Linux\" {\n\tinsmod fat\n\tinsmod chain\n\tsearch --no-floppy --set=root --fs-uuid UUID_DO_SISTEMA_DE_ARQUIVOS\n\tchainloader /EFI/Linux/Arch-linux.efi\n}\n```\n\nPresumindo que outra distribuição esteja na partição sda2:\n\n```\nmenuentry \"Outro Linux\" {\n\tset root=(hd0,2)\n\tlinux /boot/vmlinuz (adicione outras opções aqui conforme necessário)\n\tinitrd /boot/initrd.img (se outro kernel usa/precisa de um)\n}\n```\n\nAlternativamente, permita o GRUB pesquisar a partição correta pelo UUID ou label do sistema de arquivos:\n\n```\nmenuentry \"Outro Linux\" {\n        # presumindo que o UUID seja 763A-9CB6\n\tsearch --no-floppy --set=root --fs-uuid 763A-9CB6\n\n        # pesquise pelo rótulo OUTRO_LINUX (certifique-se que o rótulo da partição não seja ambígua)\n        #search --no-floppy --set=root --label OUTRO_LINUX\n\n\tlinux /boot/vmlinuz (adicione aqui outras opções necessárias, por exemplo: root=UUID=763A-9CB6)\n\tinitrd /boot/initrd.img (se outro kernel usa/precisa de um)\n}\n```\n\nSe a outra distribuição já tiver uma pasta /boot válida com o GRUB instalado, grub.cfg, kernel e initramfs, o GRUB poderá ser instruído a carregar esses outros arquivos de grub.cfg dinamicamente durante a inicialização. Por exemplo, para hd0 e a quarta partição GPT:\n\n```\nmenuentry \"configfile hd0,gpt4\"  {\n        insmod part_gpt\n        insmod btrfs\n        insmod ext2\n        set root='hd0,gpt4'\n        configfile /boot/grub/grub.cfg\n}\n```\n\nAo escolher esta entrada, o GRUB carrega o arquivo grub.cfg do outro volume e exibe esse menu. Quaisquer alterações na variável de ambiente feitas pelos comandos no arquivo não serão preservadas após o retorno do configfile. Pressione Esc para retornar ao primeiro menu do GRUB.\n\nEste modo determina onde o carregador de boot do Windows reside e carrega-o após o GRUB quando a entrada do menu é selecionada. A principal tarefa aqui é encontrar a partição do sistema EFI e executar o carregador de boot a partir dela.\n\n```\nif [ \"${grub_platform}\" == \"efi\" ]; then\n\tmenuentry \"Microsoft Windows Vista/7/8/8.1 UEFI/GPT\" {\n\t\tinsmod part_gpt\n\t\tinsmod fat\n\t\tinsmod chain\n\t\tsearch --no-floppy --fs-uuid --set=root $hints_string $fs_uuid\n\t\tchainloader /EFI/Microsoft/Boot/bootmgfw.efi\n\t}\nfi\n```\n\nsendo que $hints_string e $fs_uuid são obtidas com os dois comandos abaixo.\n\nO comando $fs_uuid determina o UUID da partição de sistema EFI:\n\n```\n# grub-probe --target=fs_uuid esp/EFI/Microsoft/Boot/bootmgfw.efi\n```\n\n```\n1ce5-7f28\n```\n\nComo alternativa, é possível executar lsblk --fs e ler o UUID da partição do sistema EFI a partir dele.\n\nO comando $hints_string determinará a localização da partição do sistema EFI, neste caso o disco rígido 0:\n\n```\n# grub-probe --target=hints_string esp/EFI/Microsoft/Boot/bootmgfw.efi\n```\n\n```\n--hint-bios=hd0,gpt1 --hint-efi=hd0,gpt1 --hint-baremetal=ahci0,gpt1\n```\n\nEstes dois comandos presumem o uso da ESP do Windows montada em esp. Pode haver diferenças entre maiúsculas e minúsculas no caminho para o arquivo EFI do Windows, com o Windows e tudo mais.\n\nNote: **partição do sistema** \n\nAo longo desta seção, presume-se que sua partição do Windows é /dev/sda1. Uma partição diferente mudará todas as instâncias de hd0,msdos1.\n\nEm ambos exemplos XXXXXXXXXXXXXXXX é o UUID do sistema de arquivos que pode ser encontrado com o comando lsblk --fs.\n\nPara Windows Vista/7/8/8.1/10:\n\n```\nif [ \"${grub_platform}\" == \"pc\" ]; then\n\tmenuentry \"Microsoft Windows Vista/7/8/8.1/10 BIOS/MBR\" {\n\t\tinsmod part_msdos\n\t\tinsmod ntfs\n\t\tinsmod ntldr\n\t\tsearch --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 XXXXXXXXXXXXXXXX\n\t\tntldr /bootmgr\n\t}\nfi\n```\n\nPara Windows XP:\n\n```\nif [ \"${grub_platform}\" == \"pc\" ]; then\n\tmenuentry \"Microsoft Windows XP\" {\n\t\tinsmod part_msdos\n\t\tinsmod ntfs\n\t\tinsmod ntldr     \n\t\tsearch --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 XXXXXXXXXXXXXXXX\n\t\tntldr /ntldr\n\t}\nfi\n```\n\nNote: **Não** Não use bootrec.exe /Fixmbr porque ele apagará o GRUB. Ou você pode usar a função \"Reparo de inicialização\" no menu \"Solução de problemas\" - isso não eliminará o GRUB, mas consertará a maioria dos erros. Além disso, é melhor você ficar conectado tanto no disco rígido de destino quanto no dispositivo inicializável SOMENTE. O Windows geralmente não conserta as informações de inicialização se algum outro dispositivo estiver conectado.\n\n```\nX:\\> bootrec.exe /fixboot\nX:\\> bootrec.exe /RebuildBcd\n```\n\nNão use bootrec.exe /Fixmbr porque ele apagará o GRUB. Ou você pode usar a função \"Reparo de inicialização\" no menu \"Solução de problemas\" - isso não eliminará o GRUB, mas consertará a maioria dos erros. Além disso, é melhor você ficar conectado tanto no disco rígido de destino quanto no dispositivo inicializável SOMENTE. O Windows geralmente não conserta as informações de inicialização se algum outro dispositivo estiver conectado.\n\nÉ possível usar rótulos do sistema de arquivos, nomes legíveis anexados ao sistemas de arquivos, ao usar a opção --label no search. Primeiramente, tenha certeza de que seu sistema de arquivos tem um rótulo.\n\nEntão, adicione uma entrada usando rótulos. Um exemplo disso:\n\n```\nmenuentry \"Arch Linux, sessão texto\" {\n  search --label --set=root archroot\n  linux /boot/vmlinuz-linux root=/dev/disk/by-label/archroot ro\n  initrd /boot/initramfs-linux.img\n}\n```\n\n"
    },
    {
      "title": "Usando o shell de comandos",
      "level": 2,
      "content": "Como o MBR é muito pequeno para armazenar todos os módulos do GRUB, apenas o menu e alguns comandos básicos residem nele. A maior parte da funcionalidade do GRUB permanece nos módulos em /boot/grub/, que são inseridos conforme necessário. Em condições de erro (por exemplo, se o layout da partição for alterado), o GRUB poderá falhar na inicialização. Quando isso acontece, um shell de comando pode aparecer.\n\nO GRUB oferece vários shells/prompts. Se houver um problema ao ler o menu, mas o gerenciador de inicialização conseguir localizar o disco, você provavelmente será descartado no shell \"normal\":\n\n```\ngrub>\n```\n\nSe houver um problema mais sério (por exemplo, o GRUB não conseguir localizar os arquivos necessários), você poderá ser direcionado para o shell \"rescue\":\n\n```\ngrub rescue>\n```\n\nO shell de recuperação é um subconjunto restrito do shell normal, oferecendo muito menos funcionalidade. Se for jogado no shell de recuperação, primeiro tente inserir o módulo \"normal\" e, em seguida, inicie o shell \"normal\":\n\n```\ngrub rescue> set prefix=(hdX,Y)/boot/grub\ngrub rescue> insmod (hdX,Y)/boot/grub/i386-pc/normal.mod\nrescue:grub> normal\n```\n\n"
    },
    {
      "title": "Suporte a paginador",
      "level": 3,
      "content": "O GRUB possui suporte a paginador para ler comandos que fornecem saída longa (como o comando help). Isso funciona apenas no modo shell normal e não no modo de recuperação. Para digitar o paginador, digite no shell de comando do GRUB:\n\n```\nsh:grub> set pager=1\n```\n\n"
    },
    {
      "title": "Usando o ambiente shell de comandos para iniciar sistemas operacionais",
      "level": 3,
      "content": "```\ngrub>\n```\n\nO ambiente de shell de comando do GRUB pode ser usado para inicializar sistemas operacionais. Um cenário comum pode ser inicializar o Windows/Linux armazenado em uma unidade/partição via carregamento em cadeia (chainloading).\n\nChainloading significa carregar outro carregador de boot a partir do atual, isto é, carregamento em cadeia.\n\nO outro gerenciador de boot pode ser incorporado no início de um disco particionado (MBR), no início de uma partição ou em um disco sem partição (VBR) ou como um binário EFI no caso de UEFI.\n\n"
    },
    {
      "title": "Carregando o VBR de uma partição",
      "level": 4,
      "content": "```\nset root=(hdX,Y)\nchainloader +1\nboot\n```\n\nX=0,1,2... Y=1,2,3...\n\nPor exemplo, para carregar o Windows armazenado na primeira partição do primeiro disco rígido,\n\n```\nset root=(hd0,1)\nchainloader +1\nboot\n```\n\nDa mesma forma, o GRUB instalado em uma partição pode ser carregado em cadeia.\n\n"
    },
    {
      "title": "Carregando o MBR de um disco ou o VBR de um disco sem partição",
      "level": 4,
      "content": "```\nset root=hdX\nchainloader +1\nboot\n```\n\n"
    },
    {
      "title": "Carregando Windows/Linux instalado em modo UEFI",
      "level": 4,
      "content": "```\ninsmod fat\nset root=(hd0,gpt4)\nchainloader (${root})/EFI/Microsoft/Boot/bootmgfw.efi\nboot\n```\n\ninsmod fat é usado para carregar o módulo do sistema de arquivos FAT para acessar o gerenciador de boot do Windows na partição do sistema EFI. (hd0,gpt4) ou /dev/sda4 é a partição do sistema EFI neste exemplo. A entrada na linha chainloader especifica o caminho do arquivo .efi a ser carregado em cadeia.\n\n"
    },
    {
      "title": "Carregamento normal",
      "level": 4,
      "content": "Veja os exemplos em #Usando o console de recuperação\n\n"
    },
    {
      "title": "Usando o console de recuperação",
      "level": 3,
      "content": "Veja #Usando o shell de comandos primeiro. Se não for possível ativar o shell padrão, uma solução possível é inicializar usando um live CD ou algum outro disco de recuperação para corrigir erros de configuração e reinstalar o GRUB. No entanto, esse disco de inicialização nem sempre está disponível (nem necessário); o console de recuperação é surpreendentemente robusto.\n\nOs comandos disponíveis na recuperação do GRUB incluem insmod, ls, set e unset. Este exemplo usa set e insmod. set modifica variáveis e insmod insere novos módulos para adicionar funcionalidade.\n\nAntes de iniciar, o usuário deve saber a localização de sua partição /boot (seja uma partição separada ou um subdiretório sob sua raiz):\n\n```\ngrub rescue> set prefix=(hdX,Y)/boot/grub\n```\n\nsendo X o número da unidade física e Y o número da partição.\n\nPara expandir as capacidades do console, insira o módulo linux:\n\n```\ngrub rescue> insmod i386-pc/linux.mod\n```\n\nou simplesmente\n\n```\ngrub rescue> insmod linux\n```\n\nIsso introduz os comandos linux e initrd, que devem ser familiares.\n\nUm exemplo, inicializando o Arch Linux:\n\n```\nset root=(hd0,5)\nlinux /boot/vmlinuz-linux root=/dev/sda5\ninitrd /boot/initramfs-linux.img\nboot\n```\n\nCom uma partição de inicialização separada (por exemplo, ao usar UEFI), altere as linhas novamente:\n\n```\nset root=(hd0,5)\nlinux (hdX,Y)/vmlinuz-linux root=/dev/sda6\ninitrd (hdX,Y)/initramfs-linux.img\nboot\n```\n\nApós inicializar com êxito a instalação do Arch Linux, os usuários podem corrigir o grub.cfg conforme necessário e reinstalar o GRUB.\n\nPara reinstalar o GRUB e corrigir o problema completamente, altere /dev/sda, se necessário. Veja #Instalação para detalhes.\n\n"
    },
    {
      "title": "Remoção do GRUB",
      "level": 2,
      "content": "Em geral, para remover o grub, deve-se fazer as etapas de instalação na ordem inversa. Talvez limpando qualquer sobra no final. No entanto, antes de fazer qualquer coisa, é preciso decidir se e como a máquina inicializará após a remoção. Supondo que alguém remova o grub porque gostaria de usar outro carregador de inicialização, um método seguro, embora um pouco difícil, é certificar-se de que o outro gerenciador de boot está funcionando antes de remover o grub.\n\nDe qualquer forma, mesmo ao remover o grub antes de instalar outro gerenciador de boot, para o caso UEFI, execute:\n\n```\n$ efibootmgr\n```\n\nE verifique se o outro gerenciador de boot está listado na linha BootOrder. Se o grub não foi removido, o outro gerenciador de boot deve ser listado antes de grub. Se grub já foi removido, grub não deve ser mencionado nessa linha. Mas observe que esta é apenas uma condição necessária, mas não suficiente, para que a máquina inicialize com o outro gerenciador de boot. Nem é uma condição suficiente para a remoção completa do grub.\n\nPara máquinas UEFI e não UEFI, grub-install foi executado manualmente como parte da instalação do grub. Um de seus trabalhos para o caso UEFI foi executar o equivalente a efibootmgr --create. Como parte da remoção do grub, deve-se remover os produtos de grub-install. O oposto de efibootmgr --create é efibootmgr --delete-bootnum, ou um programa equivalente. Uma maneira de obter o número da entrada de inicialização para o comando efibootmgr --delete-bootnum é a partir da saída de efibootmgr (sem argumentos).\n\ngrub-install cria o diretório /boot/grub que precisa ser removido manualmente. Embora alguns usuários queiram mantê-lo, caso queiram instalar o grub novamente.\n\nApós migrar para o GPT/UEFI, pode-se querer remover o código de inicialização do MBR usando dd:\n\n```\n# dd if=/dev/zero of=/dev/sdX bs=440 count=1\n```\n\n"
    },
    {
      "title": "Sistemas de arquivos sem suporte",
      "level": 3,
      "content": "No caso do GRUB não possuir suporte ao sistema de arquivos raiz, uma partição /boot alternativa com um sistema de arquivos compatível deve ser criada. Em alguns casos, a versão de desenvolvimento do GRUB grub-gitAUR pode ter suporte nativo para o sistema de arquivos.\n\nSe o GRUB é usado com um sistema de arquivos incompatível, ele não é capaz de extrair o UUID da sua unidade, então ele usa nomes clássicos não-persistentes /dev/sdXx. Nesse caso, você pode ter que editar manualmente /boot/grub/grub.cfg e substituir root=/dev/sdXx com root=UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX. Você pode usar o comando blkid para obter o UUID do seu dispositivo, consulte Nomeação persistente de dispositivo de bloco.\n\nEmbora o GRUB ofereça suporte a F2FS desde a versão 2.0.4, ele não pode ler corretamente seus arquivos de inicialização de uma partição F2FS que foi criada com o sinalizador extra_attr ativado.\n\n"
    },
    {
      "title": "Habilitar mensagens de depuração",
      "level": 3,
      "content": "Adicionar:\n\n```\nset pager=1\nset debug=all\n```\n\npara grub.cfg.\n\n"
    },
    {
      "title": "Mensagem de erro sobre estilo msdos",
      "level": 3,
      "content": "```\ngrub-setup: warn: Este rótulo de partição estilo msdos não tem espaço vago pós-MBR; não será possível embuti-lo!\ngrub-setup: warn: Incorporação não permitida. O GRUB só pode ser instalado neste setup usando blocklists.\n            Porém. blocklists são INSTÁVEIS e seu uso não é aconselhado.\ngrub-setup: error: If you really want blocklists, use --force.\n```\n\nEste erro pode ocorrer quando você tenta instalar o GRUB em um contêiner VMware. Leia mais sobre isso aqui. Isso acontece quando a primeira partição começa logo após o MBR (bloco 63), sem o espaço usual de 1 MiB (2048 blocos) antes da primeira partição. Leia #Instruções específicas de Master Boot Record (MBR).\n\n"
    },
    {
      "title": "Erros comuns de instalação",
      "level": 4,
      "content": "- Se você tiver um problema ao executar o grub-install com sysfs ou procfs e ele disser que você deve executar modprobe efivarfs, tente Unified Extensible Firmware Interface#Mount efivarfs.\n- Sem a opção --target ou --directory, o grub-install não pode determinar qual firmware deve ser instalado. Em tais casos, grub-install irá imprimir source_dir não existe. Por favor, especifique --target ou --diretório.\n- Se, depois de executar o grub-install, for informado que sua partição não se parece com uma partição EFI, a partição provavelmente não é Fat32.\n\n"
    },
    {
      "title": "Criar uma entrada do GRUB no gerenciador de boot do firmware",
      "level": 4,
      "content": "grub-install automaticamente tenta criar uma entrada no gerenciador de boot. Se não conseguir, então veja UEFI#efibootmgr para instruções de como usar o efibootmgr para criar uma entrada. No entanto, o problema possivelmente é devido a não ter inicializado o seu CD/USB no modo UEFI, como descrito em Installation guide (Português)#Verificar o modo de inicialização.\n\nComo outro exemplo de criação de uma entrada GRUB no gerenciador de boot do firmware, considere efibootmgr -c. Isso pressupõe que /dev/sda1 é a partição de sistema EFI e está montada em /boot/efi. Quais são o comportamento padrão de efibootmgr. Ele cria uma nova opção de inicialização chamada \"Linux\" e a coloca no topo da lista de ordem de inicialização. Opções podem ser passadas para modificar o comportamento padrão. O carregador de sistema operacional padrão é \\EFI\\arch\\grub.efi.\n\n"
    },
    {
      "title": "Descartar o shell de recuperação",
      "level": 4,
      "content": "Se o GRUB for carregado, mas cair no shell de recuperação sem erros, pode ser devido a um destes dois motivos:\n\n- Pode ser por causa de um grub.cfg ausente ou extraviado. Isso acontecerá se o UEFI do GRUB tiver sido instalado com --boot-directory e grub.cfg estiver faltando,\n- Isso também acontece se a partição de inicialização, que é codificada no arquivo grubx64.efi, for alterada.\n\n"
    },
    {
      "title": "UEFI do GRUB não carregado",
      "level": 4,
      "content": "Um exemplo de um UEFI funcional:\n\n```\n# efibootmgr -v\n```\n\n```\nBootCurrent: 0000\nTimeout: 3 seconds\nBootOrder: 0000,0001,0002\nBoot0000* GRUB HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\\EFI\\GRUB\\grubx64.efi)\nBoot0001* Shell HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\\shellx64.efi)\nBoot0002* Festplatte BIOS(2,0,00)P0: SAMSUNG HD204UI\n```\n\nSe a tela ficar preta por um segundo e a próxima opção de inicialização for tentada posteriormente, de acordo com esta publicação, mova o GRUB para a raiz da partição pode ajudar. A opção de inicialização deve ser excluída e recriada posteriormente. A entrada para o GRUB deve ficar assim:\n\n```\nBoot0000* GRUB HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\\grubx64.efi)\n```\n\n"
    },
    {
      "title": "Caminho de inicialização padrão/reserva",
      "level": 4,
      "content": "Alguns firmwares UEFI exigem um arquivo inicializável em um local conhecido antes de mostrar as entradas de inicialização da UEFI NVRAM. Se este for o caso, grub-install irá reivindicar que efibootmgr adicionou uma entrada para inicializar o GRUB, no entanto a entrada não será mostrada no seletor de ordem de inicialização do VisualBIOS. A solução é instalar o GRUB no caminho de inicialização padrão/reserva:\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --removable\n```\n\nAlternativamente, você pode mover um executável do GRUB EFI já instalado para o caminho padrão/reserva:\n\n```\n# mv esp/EFI/grub esp/EFI/BOOT\n# mv esp/EFI/BOOT/grubx64.efi esp/EFI/BOOT/BOOTX64.EFI\n```\n\n"
    },
    {
      "title": "Assinatura inválida",
      "level": 3,
      "content": "Se tentar inicializar o Windows, resulta em um erro de \"assinatura inválida\", por exemplo, depois de reconfigurar partições ou adicionar discos rígidos adicionais, (re)mova a configuração do dispositivo do GRUB e reconfigure:\n\n```\n# mv /boot/grub/device.map /boot/grub/device.map-old\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\ngrub-mkconfig agora deve mencionar todas as opções de inicialização encontradas, incluindo o Windows. Se funcionar, remova /boot/grub/device.map-old.\n\n"
    },
    {
      "title": "Inicialização congelando",
      "level": 3,
      "content": "Se a inicialização for travada sem nenhuma mensagem de erro após o GRUB carregar o kernel e o disco em memória inicial, tente remover o parâmetro do kernel add_efi_memmap.\n\n"
    },
    {
      "title": "Arch não encontrado por outros sistemas operacionais",
      "level": 3,
      "content": "Algumas pessoas relataram que outras distribuições podem ter problemas para encontrar o Arch Linux automaticamente com os-prober. Se esse problema ocorrer, foi relatado que a detecção pode ser melhorada com a presença de /etc/lsb-release. Esta ferramenta de arquivo e atualização está disponível com o pacote lsb-release.\n\n"
    },
    {
      "title": "Aviso ao instalar em chroot",
      "level": 3,
      "content": "Ao instalar o GRUB em um sistema LVM em um ambiente chroot (por exemplo, durante a instalação do sistema), você pode receber avisos como\n\n```\n/run/lvm/lvmetad.socket: connect failed: No such file or directory\n```\n\nou\n\n```\nWARNING: failed to connect to lvmetad: No such file or directory. Falling back to internal scanning.\n```\n\nIsto é porque /run não está disponível dentro do chroot. Esses avisos não impedem o sistema de inicializar, desde que tudo tenha sido feito corretamente, assim você pode continuar com a instalação.\n\n"
    },
    {
      "title": "GRUB carrega lentamente",
      "level": 3,
      "content": "O GRUB pode levar muito tempo para carregar quando o espaço em disco está baixo. Verifique se você tem espaço livre em disco suficiente em sua partição /boot ou / quando tiver problemas.\n\n"
    },
    {
      "title": "erro: sistema de arquivos desconhecido",
      "level": 3,
      "content": "O GRUB pode emitir erro: sistema de arquivos desconhecido e se recusar a inicializar por alguns motivos. Se você tem certeza de que todos os UUIDs estão corretos e todos os sistemas de arquivos são válidos e compatíveis, pode ser que sua partição de inicialização de BIOS esteja localizada fora dos primeiros 2 TiB da unidade [1]. Use uma ferramenta de particionamento de sua escolha para garantir que essa partição esteja totalmente localizada nos primeiros 2 TiB, depois reinstale e reconfigure o GRUB.\n\nEsse erro também pode ser causado por um sistema de arquivos ext4 tem um conjuto de recursos sem suporte:\n\n- large_dir -- sem suporte.\n- metadata_csum_seed -- terá suporte no GRUB 2.11 (commit).\n\n"
    },
    {
      "title": "grub-reboot não está redefinido",
      "level": 3,
      "content": "O GRUB parece não conseguir gravar em partições BTRFS de raiz [2]. Se você usar o grub-reboot para inicializar em outra entrada, será incapaz de atualizar seu ambiente em disco. Execute o grub-reboot a partir da outra entrada (por exemplo, ao alternar entre várias distribuições) ou considere um sistema de arquivos diferente. Você pode redefinir uma entrada \"sticky\" executando grub-editenv create e configurando GRUB_DEFAULT=0 no /etc/default/grub (não esqueça grub-mkconfig -o /boot/grub/grub.cfg).\n\n"
    },
    {
      "title": "BTRFS antigo impede a instalação",
      "level": 3,
      "content": "Se uma unidade estiver formatada com o BTRFS sem criar uma tabela de partição (por exemplo, /dev/sdx), mais tarde será gravada a tabela de partições, existindo partes do formato BTRFS que persistem. A maioria dos utilitários e sistemas operacionais não vê isso, mas o GRUB se recusará a instalar, mesmo com --force.\n\n```\n# grub-install: warning: Attempting to install GRUB to a disk with multiple partition labels. This is not supported yet.\n# grub-install: error: filesystem `btrfs' does not support blocklists.\n```\n\nVocê pode zerar a unidade, mas a solução fácil que deixa seus dados sozinhos é apagar o superbloco BTRFS com wipefs -o 0x10040 /dev/sdx.\n\n"
    },
    {
      "title": "Windows 8/10 não encontrado",
      "level": 3,
      "content": "Uma configuração no Windows 8/10 chamada \"Hiberboot\", \"Hybrid Boot\" or \"Fast Boot\" (inicialização rápida pode impedir que a partição do Windows seja montada, portanto, o grub-mkconfig não localizará uma instalação do Windows. Desativar o Hiberboot no Windows permitirá que ele seja adicionado ao menu GRUB.\n\n"
    },
    {
      "title": "Recuperação do GRUB e /boot criptografado",
      "level": 3,
      "content": "Ao usar um /boot criptografado e você não conseguir inserir uma senha correta, você será jogado no prompt de recuperação do GRUB.\n\nEste prompt de recuperação do grub tem capacidades limitadas. Use os seguintes comandos para completar a inicialização:\n\n```\ngrub rescue> cryptomount <partição>\ngrub rescue> insmod normal\ngrub rescue> normal\n```\n\nVeja esta publicação de blog[link inativo 2023-04-23 ⓘ] para uma descrição melhor.\n\n"
    },
    {
      "title": "GRUB está instalado, mas o menu não é mostrado na inicialização",
      "level": 3,
      "content": "Verifique /etc/default/grub se GRUB_TIMEOUT está definido como 0 e, caso esteja, defina-o com um número positivo: ele define o número de segundos antes da entrada padrão do GRUB ser carregada. Verifique também se GRUB_TIMEOUT_STYLE está definido como hidden e defina como menu, para que o menu seja exibido por padrão. Então gere novamente o arquivo principal e reinicie para verificar se funcionou.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- Wikipedia:GNU GRUB\n- Manual oficial do GRUB\n- Página wiki do Ubuntu sobre GRUB\n- Página wiki sobre GRUB descrevendo passos para compilar para sistemas UEFI\n- Wikipedia:BIOS Boot partition\n- Como configurar o GRUB\n\n"
    }
  ]
}