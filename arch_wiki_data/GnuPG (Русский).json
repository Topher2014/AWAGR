{
  "title": "GnuPG (Русский)",
  "url": "https://wiki.archlinux.org/title/GnuPG_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- pacman/Подпись пакета\n- Data-at-rest encryption (Русский)\n- Список приложений/Безопасность#Шифрование, подписи и стеганография\n\nВ соответствии с официальной веб-страницей:\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Установите пакет gnupg.\n\nПри этом будет установлен pinentry — набор простых диалоговых окон для ввода PIN-кода или парольной фразы, который использует GnuPG. Скрипт /usr/bin/pinentry определяет, какая конкретно реализация pinentry будет использоваться; смотрите раздел #pinentry.\n\nСписок программ, взаимодействующих с GnuPG, и графических фронтендов доступен в статье Список приложений/Безопасность#Шифрование, подписи и стеганография.\n\n"
    },
    {
      "title": "Домашний каталог",
      "level": 3,
      "content": "Домашний каталог GnuPG — это место, где GnuPG хранит связки ключей, закрытые ключи и конфигурационные файлы. По умолчанию используется ~/.gnupg. Есть два способа задать свой путь:\n\n- с помощью переменной окружения $GNUPGHOME;\n- с помощью аргумента --homedir, например $ gpg --homedir путь/к/каталогу [1].\n\nПо умолчанию домашний каталог имеет права доступа 700, а содержащиеся в нём файлы — права доступа 600. Только владелец каталога имеет доступ к файлам. Это сделано в целях безопасности и не должно изменяться. Если каталог или какой-либо файл в нём не соблюдает эту меру безопасности, вы получите предупреждение о небезопасных правах доступа файлов и домашнего каталога.\n\n"
    },
    {
      "title": "Файлы конфигурации",
      "level": 3,
      "content": "Всё поведение GnuPG можно настроить через аргументы командной строки. Аргументы, которые вы хотите использовать по умолчанию, можно добавить в соответствующий конфигурационный файл:\n\n- gpg проверяет файлы gnupg_home/gpg.conf (пользовательский) и /etc/gnupg/gpg.conf (глобальный) [2]. Поскольку команда gpg является основной точкой входа в GnuPG, большинство настроек будет находиться здесь. Доступные опции описаны в GPG Options.\n- dirmngr проверяет файлы gnupg_home/dirmngr.conf и /etc/gnupg/dirmngr.conf. dirmngr — это внутренняя программа, которую gpg использует для доступа к серверам ключей PGP [3]. Доступные опции описаны в Dirmngr Options.\n\nЭти два файла охватывают самые частые сценарии использования, но в GnuPG есть и другие вспомогательные программы со своими собственными опциями. Полный их перечень есть в GnuPG manual.\n\nСоздайте нужные файлы и задайте им права доступа 600, как обсуждалось в разделе #Домашний каталог.\n\nДобавьте в эти файлы все необходимые длинные опции. Не пишите перед ними два дефиса, просто имя опции и требуемые аргументы. Например, чтобы GnuPG всегда использовал связку ключей по определённому пути, как если бы он был вызван с опцией gpg --no-default-keyring --keyring keyring-path ...:\n\n```\ngnupg_home/gpg.conf (или /etc/gnupg/gpg.conf)\n```\n\n```\nno-default-keyring\nkeyring keyring-path\n```\n\nДругие примеры можно найти в разделе #Смотрите также.\n\nВ дополнение, pacman использует отдельный набор конфигурационных файлов для проверки подписи пакетов. Подробнее в статье pacman/Подпись пакета.\n\n"
    },
    {
      "title": "Стандартные настройки для новых пользователей",
      "level": 3,
      "content": "Если вы хотите задать какие-нибудь опции по умолчанию для новых пользователей, поместите соответствующие файлы в /etc/skel/.gnupg/. Когда новый пользователь будет добавлен в систему, файлы отсюда будут скопированы в его домашний каталог GnuPG. Также имеется простой скрипт addgnupghome, с помощью которого вы можете создать новые домашние каталоги GnuPG для существующих пользователей:\n\n```\n# addgnupghome user1 user2\n```\n\nКоманда добавит /home/user1/.gnupg/ и /home/user2/.gnupg/ соответственно и скопирует туда файлы из каталога шаблонов (skeleton directory). Пользователи с существующими домашними каталогами GnuPG просто будут пропущены.\n\n"
    },
    {
      "title": "Использование",
      "level": 2,
      "content": "- Всякий раз, когда команде требуется user-id, вы можете указать ваш key ID, отпечаток ключа (fingerprint), часть вашего имени, адреса электронной почты и т. д. GnuPG гибок в этом плане.\n- Когда требуется key-id, его можно найти добавлением опции --keyid-format=long к команде. Например, для просмотра закрытого мастер-ключа выполните gpg --list-secret-keys --keyid-format=long user-id, и key-id будет шестнадцатеричным значением, находящимся в строке sec.\n\n"
    },
    {
      "title": "Создание пары ключей",
      "level": 3,
      "content": "Создайте пару ключей, введя в терминал:\n\n```\n$ gpg --full-gen-key\n```\n\nИспользуйте опцию --expert, чтобы выбрать другие шифры, в частности эллиптическую криптографию (ECC).\n\nКоманда задаст несколько вопросов. Для общего использования большинству людей подойдут такие параметры:\n\n- RSA (только для подписи) и RSA (только для шифрования) ключ.\n- размер ключа по умолчанию (3072). Размер ключа 4096 «дорого обходится, но почти ничего не даёт» (смотрите why doesn’t GnuPG default to using RSA-4096).\n- срок действия. Период в один год обычно достаточно хорош. В этом случае, даже если доступ к ключу будет потерян, он позволит другим узнать, что больше недействителен. Позже, при необходимости, срок действия может быть расширен без повторного выпуска нового ключа.\n- ваше имя и адрес электронной почты. Вы можете добавить несколько идентификаторов к одному и тому же ключу позже (например, если у вас есть несколько адресов электронной почты, которые вы хотите связать с этим ключом).\n- пустой необязательный комментарий. Поскольку семантика поля комментария не определена, она имеет ограниченное значение для идентификации.\n- безопасная парольная фраза.\n\n"
    },
    {
      "title": "Просмотр списка ключей",
      "level": 3,
      "content": "Вывести список открытых ключей:\n\n```\n$ gpg --list-keys\n```\n\nВывести список закрытых ключей:\n\n```\n$ gpg --list-secret-keys\n```\n\n"
    },
    {
      "title": "Экспорт открытого ключа",
      "level": 3,
      "content": "Основное назначение GnuPG — обеспечение конфиденциальности обмена сообщениями с помощью криптографии с открытым ключом. С его помощью каждый пользователь распространяет открытый ключ своей связки ключей, который может быть использован другими пользователями для шифрования сообщений пользователю. Закрытый ключ всегда должен оставаться в тайне, иначе конфиденциальность будет нарушена. Подробнее о том, как это всё работает, можно почитать в статье на Википедии.\n\nТаким образом, чтобы другие могли отправлять вам зашифрованные сообщения, им нужен ваш открытый ключ.\n\nЧтобы сгенерировать ASCII-версию открытого ключа пользователя в файл public-key.asc (например, для отправки по электронной почте):\n\n```\n$ gpg --export --armor --output public-key.asc user-id\n```\n\nЕщё один вариант распространения открытого ключа — #Использование сервера ключей.\n\n- Добавьте --no-emit-version, чтобы не выводить номер версии, или добавьте соответствующий параметр в ваш файл настроек.\n- Вы можете опустить user-id, чтобы экспортировать все открытые ключи в вашей связке ключей. Это полезно, если вы хотите поделиться несколькими идентификаторами одновременно или для импорта в другое приложение, например, Thunderbird.\n\n"
    },
    {
      "title": "Импорт открытого ключа",
      "level": 3,
      "content": "Чтобы зашифровать сообщения другим людям, а также проверить их подписи, вам нужен их открытый ключ. Чтобы импортировать открытый ключ из файла public-key.asc в свой список открытых ключей, выполните команду:\n\n```\n$ gpg --import public-key.asc\n```\n\nДругой вариант для поиска открытого ключа — #Использование сервера ключей.\n\nЕсли вы хотите импортировать ключ для установки определённого пакета Arch Linux, смотрите pacman/Подпись пакета#Управление связкой ключей и makepkg (Русский)#Проверка цифровых подписей.\n\n"
    },
    {
      "title": "Отправка ключей",
      "level": 4,
      "content": "Вы можете зарегистрировать свой ключ на публичном сервере ключей PGP, чтобы другие могли получить его без необходимости обращаться к вам напрямую:\n\n```\n$ gpg --send-keys key-id\n```\n\n"
    },
    {
      "title": "Поиск и получение ключей",
      "level": 4,
      "content": "Чтобы посмотреть информацию о ключе на сервере ключей, не импортируя его, выполните:\n\n```\n$ gpg --search-keys user-id\n```\n\nИмпортирование ключа с сервера ключей:\n\n```\n$ gpg --receive-keys key-id\n```\n\nЧтобы обновить связку ключей последней версией с сервера ключей:\n\n```\n$ gpg --refresh-keys\n```\n\n- Обязательно проверьте подлинность полученного открытого ключа, сравнив его отпечаток с тем, который владелец опубликовал в независимом источнике (например, связавшись с ним напрямую). Смотрите также статью на Википедии.\n- Для получения ключа рекомендуется использовать длинный ID ключа или полный отпечаток. С короткими ID могут случаться коллизии. Если несколько разных ключей имеют один и тот же короткий ID — будут импортированы все. Уже встречались поддельные ключи, у которых короткие ID совпадали с короткими ID ключей Линуса Торвальдса и Грега Кроа-Хартмана.\n\nNote: **нарушение конфиденциальности** \n\n"
    },
    {
      "title": "Серверы ключей",
      "level": 4,
      "content": "Самые популярные серверы ключей:\n\n- Ubuntu Keyserver: федеративный, без проверки, ключи не могут быть удалены.\n- Mailvelope Keyserver: централизованный, проверка идентификаторов электронной почты, ключи могут быть удалены.\n- keys.openpgp.org: централизованный, проверка идентификаторов электронной почты, ключи могут быть удалены, нет подписей третьих лиц (т.е. нет поддержки Web of Trust).\n\nТакже можно посмотреть список серверов в Википедии.\n\nМожно указать произвольный keyserver в настройках, например:\n\n```\n~/.gnupg/dirmngr.conf\n```\n\n```\nkeyserver hkp://keyserver.ubuntu.com\n```\n\nВременное использование другого сервера удобно, когда обычный сервер работает не так, как нужно. Например:\n\n```\n$ gpg --keyserver hkps://keys.openpgp.org/ --search-keys user-id\n```\n\n- Если при получении ключа появляется ошибка gpg: keyserver receive failed: General error и вы используете пул серверов hkps по умолчанию, убедитесь, что установлен сертификат проверки пула HKPS с помощью hkp-cacert /usr/share/gnupg/sks-keyservers.netCA.pem в вашем dirmngr.conf, и завершите старый процесс dirmngr.\n- Если при получении ключа появляется ошибка gpg: keyserver receive failed: Connection refused, попробуйте использовать другой DNS-сервер.\n- Можно подключиться к серверу ключей через Tor с помощью torsocks. Или можно использовать опцию --use-tor. Смотрите [4] для более подробной информации.\n- Можно подключиться к серверу ключей через прокси, указав переменную окружения http_proxy и прописав honor-http-proxy в dirmngr.conf. Также можно задать http-proxy хост[:порт] в файле настроек, чтобы переопределить параметры из переменной окружения. Перезапустите пользовательскую службу dirmngr.service для применения изменений.\n- Если при подключении к серверу ключей возникает ошибка gpg: keyserver receive failed: Server indicated a failure, возможно, необходимо настроить gpg на использование альтернативного порта. Например, чтобы использовать порт 80 для Ubuntu Keyserver, используйте keyserver hkp://keyserver.ubuntu.com:80.\n\n"
    },
    {
      "title": "Web Key Directory",
      "level": 3,
      "content": "Протокол Web Key Service (WKS) — это новый стандарт доставки ключей, в котором домен электронной почты предоставляет свой собственный сервер ключей, называемый Web Key Directory (WKD). При шифровании для адреса электронной почты (например, user@example.com) GnuPG (>=2.1.16) обратится к домену (example.com) через HTTPS для получения открытого ключа OpenPGP, если его ещё нет в локальном списке ключей. Опция auto-key-locate найдёт ключ по протоколу WKD, если в локальном списке ключей нет ключа для данного адреса электронной почты.\n\n```\n# gpg --recipient user@example.org --auto-key-locate --encrypt doc\n```\n\nВ GnuPG Wiki есть список email-провайдеров, поддерживающих WKD. Если у вас есть контроль над доменом, вы можете включить для него WKD, как описано в этом руководстве. Для проверки, что ваш ключ доступен через WKD, можно использовать этот веб-интерфейс.\n\n"
    },
    {
      "title": "Асимметричное",
      "level": 4,
      "content": "Перед шифрованием (опция -e/--encrypt) файла для указанного получателя (опция -r/--recipient) выполните #Импорт открытого ключа. Также выполните #Создание пары ключей, если её у вас ещё нет.\n\nШифрование файла с именем doc:\n\n```\n$ gpg --recipient user-id --encrypt doc\n```\n\nЧтобы расшифровать (опция -d/--decrypt) файл с именем doc.gpg, зашифрованный вашим открытым ключом:\n\n```\n$ gpg --output doc --decrypt doc.gpg\n```\n\ngpg спросит ваш пароль и затем расшифрует данные из файла doc.gpg в файл doc. Если опцию -o/--output не указывать, данные будут записаны в стандартный вывод (stdout).\n\n- Опция --armor запишет вывод в ASCII-совместимом формате, пригодном для передачи в текстовых сообщениях.\n- Используйте -R user-id или --hidden-recipient user-id вместо -r, чтобы не помещать ID ключей получателей в зашифрованное сообщение. Это помогает скрыть получателей сообщения и является ограниченной контрмерой против анализа трафика.\n- Добавьте --no-emit-version, чтобы не выводить номер версии, или добавьте соответствующий параметр в ваш файл настроек.\n- Можно использовать GnuPG для шифрования конфиденциальных документов, используя свой собственный user-id в качестве получателя или используя флаг --default-recipient-self, однако вы можете делать это только с одним файлом за раз. Впрочем, можно собрать несколько файлов в один tar-архив и зашифровать уже его. Смотрите также Data-at-rest encryption (Русский)#Доступные методы, если вы хотите зашифровать каталоги или целую файловую систему.\n\n"
    },
    {
      "title": "Симметричное",
      "level": 4,
      "content": "Симметричное шифрование не требует генерации пары ключей и может использоваться для простого шифрования данных с помощью пароля. Просто используйте -c/--symmetric для выполнения симметричного шифрования:\n\n```\n$ gpg -c doc\n```\n\nСледующий пример:\n\n- Шифрует файл doc симметричным шифрованием с использованием пароля\n- Использует алгоритм шифрования AES-256 для шифрования данных\n- Использует алгоритм хэширования SHA-512 для генерации ключа шифрования из пароля\n- Выполняет 65536 итераций в процессе генерации ключа из пароля\n\n```\n$ gpg -c --s2k-cipher-algo AES256 --s2k-digest-algo SHA512 --s2k-count 65536 doc\n```\n\nРасшифровка симметрично зашифрованного doc.gpg с помощью пароля и вывод расшифрованного содержимого в тот же каталог, что и doc:\n\n```\n$ gpg --output doc --decrypt doc.gpg\n```\n\n"
    },
    {
      "title": "Каталог",
      "level": 4,
      "content": "Можно зашифровать/расшифровать целый каталог с помощью gpgtar(1).\n\nШифрование:\n\n```\n$ gpgtar -c -o dir.gpg dir\n```\n\nДешифрование:\n\n```\n$ gpgtar -d dir.gpg\n```\n\n"
    },
    {
      "title": "Резервное копирование закрытого ключа",
      "level": 3,
      "content": "Чтобы создать резервную копию вашего закрытого ключа, выполните:\n\n```\n$ gpg --export-secret-keys --armor --output private-key.asc user-id\n```\n\nОбратите внимание, что вышеуказанная команда требует ввода пароля от ключа. В противном случае любой, кто получит доступ к экспортированному файлу, сможет шифровать и подписывать документы, как если бы он был вами, без необходимости знать пароль.\n\n- Пароль — обычно самое слабое звено в защите закрытого ключа. Поместите закрытый ключ в безопасное место на другой системе или на другом устройстве, например, в заблокированный контейнер или на зашифрованный диск. Это единственное средство защиты, которое поможет вам восстановить контроль над списком ваших ключей в случае, например, поломки диска, кражи или ещё чего-нибудь похуже.\n- Этот способ резервного копирования ключей имеет некоторые ограничения по безопасности. Более безопасный способ резервного копирования и импорта ключей с помощью gpg описан здесь.\n\nИмпорт закрытого ключа из резервной копии:\n\n```\n$ gpg --import private-key.asc\n```\n\n"
    },
    {
      "title": "Резервное копирование сертификата отзыва",
      "level": 3,
      "content": "Сертификаты отзыва автоматически генерируются для вновь создаваемых ключей. По умолчанию они находятся в ~/.gnupg/openpgp-revocs.d/. Имя файла сертификата — это отпечаток ключа, который он отзывает. Сертификаты отзыва также можно сгенерированы вручную с помощью следующей команды:\n\n```\n$ gpg --gen-revoke --armor --output revcert.asc user-id\n```\n\nЭтот сертификат используется, чтобы выполнить #Отзыв ключа в случае, если он оказался потерян или скомпрометирован. Резервная копия будет полезна, если у вас больше нет доступа к закрытому ключу, из-за чего вы не можете сгенерировать новый сертификат отзыва с помощью приведённой выше команды. Он достаточно короткий, чтобы его можно было распечатать и набрать от руки при необходимости.\n\n"
    },
    {
      "title": "Редактирование ключа",
      "level": 3,
      "content": "Команда gpg --edit-key user-id откроет меню, которое позволит вам выполнить большинство задач, связанных с управлением ключами.\n\nВведите help в подменю редактирования ключа, чтобы увидеть полный список команд. Некоторые полезные команды:\n\n```\n> passwd      сменить фразу-пароль\n> clean       сжать непригодные идентификаторы пользователей и удалить непригодные подписи из ключа\n> revkey      отозвать ключ или выбранные подключи\n> addkey      добавить подключ\n> expire      сменить срок действия ключа или выбранных подключей\n> adduid      добавить идентификатор пользователя\n> addphoto    добавить фотоидентификатор\n```\n\n"
    },
    {
      "title": "Экспорт подключей",
      "level": 3,
      "content": "Если вы планируете использовать один и тот же ключ на разных устройствах, вы можете убрать мастер-ключ и оставить только минимально необходимый подключ для использования на менее защищённых системах.\n\nПрежде всего, определите, какой подключ вы хотите экспортировать.\n\n```\n$ gpg --list-secret-keys --with-subkey-fingerprint\n```\n\nУкажите, что экспортировать нужно только конкретный подключ.\n\n```\n$ gpg -a --export-secret-subkeys [subkey id]! > /tmp/subkey.gpg\n```\n\nНа этом этапе вы можете закончить, но хорошей идеей будет изменить пароль. Импортируйте ключ во временный каталог.\n\n```\n$ gpg --homedir /tmp/gpg --import /tmp/subkey.gpg\n$ gpg --homedir /tmp/gpg --edit-key user-id\n> passwd\n> save\n$ gpg --homedir /tmp/gpg -a --export-secret-subkeys [subkey id]! > /tmp/subkey.altpass.gpg\n```\n\nТеперь вы уже можете использовать /tmp/subkey.altpass.gpg на других ваших устройствах.\n\n"
    },
    {
      "title": "Продление срока действия",
      "level": 3,
      "content": "Note: **Никогда** \n\nХорошей практикой является установка срока действия подключей, чтобы в случае потери доступа к ключу (например, если вы забудете пароль) он не мог использоваться другими пользователями неограниченное время. Когда срок действия ключа истекает, продлить дату истечения срока действия относительно просто:\n\n```\n$ gpg --edit-key user-id\n> expire\n```\n\nВам будет предложено ввести новую дату истечения срока действия, а также пароль для закрытого ключа, который используется для подписания новой даты истечения срока действия.\n\nПовторите это для всех остальных подключей, срок действия которых истекает:\n\n```\n> key 1\n> expire\n```\n\nНаконец, сохраните изменения и выйдите из программы:\n\n```\n> save\n```\n\nЗагрузите изменения на сервер ключей.\n\n```\n$ gpg --keyserver keyserver.ubuntu.com --send-keys key-id\n```\n\nЕсли вы используете этот ключ на нескольких компьютерах, можно экспортировать открытый ключ (с новыми подписанными датами истечения срока действия) и импортировать его на других компьютерах:\n\n```\n$ gpg --export --output pubkey.gpg user-id\n$ gpg --import pubkey.gpg\n```\n\nНет необходимости повторно экспортировать закрытый ключ или обновлять резервные копии: сам главный закрытый ключ никогда не истекает, а подпись даты истечения срока действия, оставленная на открытом ключе и подключах, — это всё что нужно.\n\n"
    },
    {
      "title": "Ротация подключей",
      "level": 3,
      "content": "Note: **Никогда** \n\nЕсли вы предпочитаете полностью прекратить использование подключей по истечении срока их действия, вы можете создать новые. Сделайте это за несколько недель до истечения срока действия, чтобы у других пользователей была возможность вовремя обновить свой список ключей.\n\nСоздайте новый подключ (запустите дважды для создания отдельных ключей для подписывания и шифрования)\n\n```\n$ gpg --edit-key user-id\n> addkey\n```\n\nПри этом вам будет задано несколько вопросов (рекомендуемые настройки смотрите в разделе #Создание пары ключей).\n\nСохраните изменения\n\n```\n> save\n```\n\nЗагрузите изменения на сервер ключей.\n\n```\n$ gpg --keyserver pgp.mit.edu --send-keys user-id\n```\n\nТакже нужно сделать новую резервную копию; смотрите раздел #Резервное копирование закрытого ключа.\n\n"
    },
    {
      "title": "Отзыв ключа",
      "level": 3,
      "content": "Если ключ скомпрометирован, заменён, больше не используется или вы забыли пароль, необходимо отозвать ключ. Это делается путём слияния ключа с сертификатом отзыва ключа.\n\nЕсли у вас больше нет доступа к вашей паре ключей, сначала выполните импорт собственного ключа (смотрите раздел #Импорт открытого ключа). Затем, чтобы отозвать ключ, импортируйте сертификат отзыва (нужно заранее создать его, как описано в разделе #Резервное копирование сертификата отзыва):\n\n```\n$ gpg --import revcert.asc\n```\n\nТеперь нужно опубликовать информацию об отзыве ключа. Если вы ранее использовали публичный сервер PGP, отправьте на него отозванный ключ, как описано в разделе #Использование сервера ключей. В противном случае экспортируйте отозванный ключ в файл и распространите его среди ваших собеседников.\n\n"
    },
    {
      "title": "Подпись",
      "level": 2,
      "content": "Подписи позволяют проверить подлинность документов и ставят временные метки. Если документ будет изменён, проверка подписи будет неудачной. В отличие от шифрования, которое использует открытые ключи, подписи создаются с помощью закрытого ключа. Получатель подписанного документа затем проверяет подпись с помощью открытого ключа отправителя.\n\n"
    },
    {
      "title": "Подпись файла",
      "level": 4,
      "content": "Для подписи файла используйте флаг -s/--sign:\n\n```\n$ gpg --output doc.sig --sign doc\n```\n\nФайл doc.sig будет содержать сжатое содержимое оригинального файла doc и подпись в бинарном формате. По умолчанию файл не будет зашифрован, но можно совместить подпись с шифрованием.\n\n"
    },
    {
      "title": "Подпись файла в текстовом формате",
      "level": 4,
      "content": "Для создания подписи в текстовом, а не в бинарном формате используйте флаг --clearsign:\n\n```\n$ gpg --output doc.sig --clearsign doc\n```\n\nФайл doc.sig будет содержать данные оригинального файла doc как есть и подпись в человекочитаемом формате.\n\n"
    },
    {
      "title": "Создание отделённой подписи",
      "level": 4,
      "content": "С помощью флага --detach-sig можно создать отдельный файл с подписью, который не будет содержать в себе данные оригинального файла:\n\n```\n$ gpg --output doc.sig --detach-sig doc\n```\n\nВ файл doc.sig будет записана только подпись без содержимого файла doc. Этот метод часто используется при распространении программ, чтобы пользователи могли убедиться, что программа не была изменена третьей стороной.\n\n"
    },
    {
      "title": "Проверка подписи",
      "level": 3,
      "content": "Для проверки подписи используйте флаг --verify:\n\n```\n$ gpg --verify doc.sig\n```\n\nгде doc.sig — это файл, содержащий подпись, которую вы хотите проверить.\n\nЕсли это отделённая подпись, то для проверки должен присутствовать оригинальный файл. Например, для проверки iso-образа Arch Linux используйте:\n\n```\n$ gpg --verify archlinux-версия.iso.sig\n```\n\nгде archlinux-версия.iso — проверяемый файл, который должен находиться в том же каталоге.\n\nТакже можно явно указать путь к проверяемому файлу:\n\n```\n$ gpg --verify archlinux-версия.iso.sig /путь/к/archlinux-версия.iso\n```\n\nЕсли файл был не только подписан, но ещё и зашифрован, просто расшифруйте файл, и его подпись будет автоматически проверена в процессе дешифрования.\n\n"
    },
    {
      "title": "gpg-agent",
      "level": 2,
      "content": "gpg-agent чаще всего используется как посредник для временного хранения пароля (пароль не будет запрашиваться каждый раз, когда нужен). Он полезен, если GnuPG используется внешней программой — например, почтовым клиентом. Пакет gnupg предоставляет пользовательские сокеты systemd, которые включены по умолчанию: gpg-agent.socket, gpg-agent-extra.socket, gpg-agent-browser.socket, gpg-agent-ssh.socket и dirmngr.socket.\n\n- Основной сокет gpg-agent.socket используется gpg для подключения к демону gpg-agent.\n- Предполагаемое использование gpg-agent-extra.socket на локальной системе — настройка переадресации Unix-сокета с удалённой системы. Это позволяет использовать gpg на удалённой системе без передачи на неё закрытых ключей. Смотрите gpg-agent(1) для более подробной информации.\n- gpg-agent-browser.socket позволяет веб-браузерам обращаться к демону gpg-agent.\n- gpg-agent-ssh.socket может использоваться SSH для кэширования ключей SSH, добавленных программой ssh-add. Настройка описана в разделе #Агент SSH.\n- dirmngr.socket запускает демон GnuPG, обрабатывающий соединения с серверами ключей.\n\n"
    },
    {
      "title": "Настройка",
      "level": 3,
      "content": "gpg-agent можно настроить в файле ~/.gnupg/gpg-agent.conf. Все опции для настройки перечислены на странице gpg-agent(1). Например, так вы можете задать время жизни для ключей в кэше с момента последнего использования:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\ndefault-cache-ttl 3600\n```\n\nNote: где XXXXX это keygrip. Вы можете получить это значение, запустив gpg --with-keygrip -K. Пароль будет храниться до перезапуска gpg-agent. Если установлено значение default-cache-ttl, оно более приоритетно.\n\n```\n$ /usr/lib/gnupg/gpg-preset-passphrase --preset XXXXX\n```\n\nгде XXXXX это keygrip. Вы можете получить это значение, запустив gpg --with-keygrip -K. Пароль будет храниться до перезапуска gpg-agent. Если установлено значение default-cache-ttl, оно более приоритетно.\n\nЧтобы это работало, нужно разрешить такое кеширование путём запуска gpg-agent с опцией --allow-preset-passphrase или добавлением allow-preset-passphrase в файле ~/.gnupg/gpg-agent.conf.\n\n"
    },
    {
      "title": "Перезапуск агента",
      "level": 3,
      "content": "После обновления настроек перезапустите агент с помощью gpg-connect-agent:\n\n```\n$ gpg-connect-agent reloadagent /bye\n```\n\nБудет выведено сообщение OK.\n\nОднако в некоторых случаях только перезапуска может быть недостаточно, например, когда в конфигурацию агента был добавлен keep-screen. В этом случае необходимо сначала завершить текущий процесс gpg-agent, а затем перезапустить его, как описано выше.\n\n"
    },
    {
      "title": "pinentry",
      "level": 3,
      "content": "gpg-agent позволяет выбрать реализацию pinentry, которая используется в качестве интерфейса для ввода пароля, через опцию pinentry-program. Например:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\npinentry-program /usr/bin/pinentry-curses\n```\n\nПосмотреть реализации pinentry, доступные в репозиториях, можно с помощью команды pacman -Ql pinentry | grep /usr/bin/. Может понадобиться установить опциональные зависимости для выбранной вами реализации.\n\n- Чтобы использовать /usr/bin/pinentry-kwallet потребуется установить пакет kwalletcliAUR.\n- Программы /usr/bin/pinentry-gnome3 (для GNOME) и /usr/bin/pinentry-gtk-2 (универсальная) [6] поддерживают DBus Secret Service API, который позволяет запоминать пароли в совместимом менеджере, таком как GNOME Keyring или KeePassXC.\n\nНе забудьте выполнить #Перезапуск агента после внесения изменений.\n\n"
    },
    {
      "title": "Кэширование паролей",
      "level": 3,
      "content": "max-cache-ttl и default-cache-ttl определяют, сколько секунд gpg-agent должен кэшировать пароли. Чтобы вводить пароль всего один раз за сеанс, установите их на очень высокое значение, например:\n\n```\ngpg-agent.conf\n```\n\n```\nmax-cache-ttl 60480000\ndefault-cache-ttl 60480000\n```\n\nДля кэширования паролей в режиме эмуляции SSH установите default-cache-ttl-ssh и max-cache-ttl-ssh, например:\n\n```\ngpg-agent.conf\n```\n\n```\ndefault-cache-ttl-ssh 60480000\nmax-cache-ttl-ssh 60480000\n```\n\n"
    },
    {
      "title": "Автоматический ввод пароля",
      "level": 3,
      "content": "Начиная с GnuPG 2.1.0, использование gpg-agent и pinentry стало обязательным; это нарушает обратную совместимость для парольных фраз, которые вводились через входной поток (STDIN) с помощью опции --passphrase-fd 0. Чтобы восстановить эту возможность, требуется выполнить несколько шагов.\n\nПервым делом, отредактируйте настройки gpg-agent, разрешив режим петли (loopback) для pinentry:\n\n```\n~/.gnupg/gpg-agent.conf\n```\n\n```\nallow-loopback-pinentry\n```\n\nВыполните #Перезапуск агента, чтобы изменения вступили в силу.\n\nТеперь либо запускайте GnuPG с опцией --pinentry-mode loopback\n\n```\n$ gpg --pinentry-mode loopback ...\n```\n\nлибо, если использовать опцию в командной строке невозможно, добавьте её в файл настроек GnuPG:\n\n```\n~/.gnupg/gpg.conf\n```\n\n```\npinentry-mode loopback\n```\n\n"
    },
    {
      "title": "Агент SSH",
      "level": 3,
      "content": "gpg-agent имеет эмуляцию агента OpenSSH. Если вы уже используете пакет GnuPG, вы можете рассмотреть возможность использования его агента для кэширования ваших ключей SSH. Кроме того, некоторые пользователи могут предпочесть диалог ввода PIN-кода, который GnuPG agent предоставляет как часть управления парольной фразой.\n\n"
    },
    {
      "title": "Установка SSH_AUTH_SOCK",
      "level": 4,
      "content": "Чтобы связываться с gpg-agent и заменить стандартный ssh-agent, установите переменные окружения:\n\n```\nSSH_AGENT_PID=\"\"\nSSH_AUTH_SOCK=\"${XDG_RUNTIME_DIR}/gnupg/S.gpg-agent.ssh\"\n```\n\n- Если вы используете скрипт для установки переменных окружения, вы можете просто удалить переменную SSH_AGENT_PID вместо установки пустой строки: unset SSH_AGENT_PID.\n- Если вы устанавливаете SSH_AUTH_SOCK вручную, имейте в виду, что расположение сокета может отличаться, если вы используете нестандартный GNUPGHOME. Вы можете использовать приведённый ниже пример bash-скрипта или изменить SSH_AUTH_SOCK на значение gpgconf --list-dirs agent-ssh-socket.\n- Если установлен GNOME Keyring, необходимо деактивировать его ssh-компонент, иначе он перезапишет SSH_AUTH_SOCK.\n\nВариант с bash-скриптом, который поддерживает нестандартное расположение сокета:\n\n```\n~/.bashrc\n```\n\n```\nunset SSH_AGENT_PID\nif [ \"${gnupg_SSH_AUTH_SOCK_by:-0}\" -ne $$ ]; then\n  export SSH_AUTH_SOCK=\"$(gpgconf --list-dirs agent-ssh-socket)\"\nfi\n```\n\n"
    },
    {
      "title": "Настройка pinentry для использования правильного TTY",
      "level": 4,
      "content": "Также укажите GPG_TTY и обновите TTY в случае, если пользователь перешёл в X-сессию, как указано в gpg-agent(1). Например:\n\n```\n~/.bashrc\n```\n\n```\nexport GPG_TTY=$(tty)\ngpg-connect-agent updatestartuptty /bye >/dev/null\n```\n\nЕсли вы используете несколько терминалов одновременно и хотите, чтобы gpg-agent спрашивал пароль через pinentry-curses в том же терминале, в котором была запущена команда ssh, добавьте следующее в файл конфигурации SSH. Это заставит TTY обновляться каждый раз, когда выполняется команда ssh [9]:\n\n```\n~/.ssh/config\n```\n\n```\nMatch host * exec \"gpg-connect-agent UPDATESTARTUPTTY /bye\"\n```\n\nДля корректной работы должна быть указана переменная GPG_TTY.\n\n"
    },
    {
      "title": "Добавление ключей SSH",
      "level": 4,
      "content": "После запуска gpg-agent вы можете использовать ssh-add для одобрения ключей, выполнив действия, описанные в статье SSH keys#ssh-agent. Список одобренных ключей хранится в файле ~/.gnupg/sshcontrol.\n\nКогда ваш ключ будет одобрен, вы будете получать диалог pinentry каждый раз, когда потребуется пароль. Для кэширования смотрите раздел #Кэширование паролей.\n\n"
    },
    {
      "title": "Использование ключа PGP для аутентификации SSH",
      "level": 4,
      "content": "Можно использовать ключ PGP в качестве ключа SSH. Для этого требуется ключ с возможностью Authentication (смотрите раздел #Настройка возможностей). Это даёт некоторые преимущества:\n\n- Меньше работы по управлению ключами, поскольку вам больше не нужно будет поддерживать отдельный ключ SSH.\n- Возможность хранить ключ аутентификации на смарт-карте. GnuPG автоматически обнаружит ключ, когда карта будет доступна, и добавит его в агент (проверьте с помощью ssh-add -l или ssh-add -L). Комментарий к ключу должен быть примерно таким: openpgp:key-id или cardno:card-id.\n\nЧтобы получить часть открытого ключа вашего ключа GPG/SSH, выполните gpg --export-ssh-key gpg-key. Если для ключа включена возможность аутентификации, но эта команда всё равно не работает с сообщением \"Unusable public key\", добавьте суффикс ! ([10]).\n\nЕсли ваш ключ GPG не хранится на ключ-карте, вам нужно добавить ключ в $GNUPGHOME/sshcontrol, чтобы он был распознан как ключ SSH. Если ваш ключ находится на ключ-карте, его keygrip будет добавлен в sshcontrol неявно. Если нет, получите keygrip ключа таким образом:\n\n```\n$ gpg --list-keys --with-keygrip\n```\n\n```\nsub   rsa4096 2018-07-25 [A]\n      Keygrip = 1531C8084D16DC4C36911F1585AF0ACE7AAFD7E7\n```\n\nЗатем отредактируйте sshcontrol следующим образом. Добавление keygrip — это однократное действие; вам не нужно будет редактировать файл снова, если вы не будете добавлять дополнительные ключи.\n\n```\n$GNUPGHOME/sshcontrol\n```\n\n```\n1531C8084D16DC4C36911F1585AF0ACE7AAFD7E7\n```\n\n"
    },
    {
      "title": "Доступ к gpg-agent и ssh-agent на удалённом устройстве",
      "level": 3,
      "content": "Как описано в GnuPG wiki, можно получить доступ к своему gpg-agent с удалённой машины, перенаправив на неё сокеты gpg с помощью SSH.\n\nСначала добавьте следующую строку в /etc/ssh/sshd_config на удалённой машине, чтобы включить автоматическое удаление старых сокетов при подключении. Без этого сокеты на удалённой машине придётся удалять вручную перед подключением с включенным перенаправлением, чтобы оно работало:\n\n```\n/etc/ssh/sshd_config\n```\n\n```\n...\nStreamLocalBindUnlink yes\n...\n```\n\nНа клиенте используйте директиву SSH RemoteForward для перенаправления трафика с удалённого порта на локальный. Как описано в ssh_config(5) § RemoteForward, параметрами этой директивы являются путь к слушающему сокету на удалённой стороне (той, на которую нужно пробросить агент), а затем путь к сокету назначения на локальном хосте (том, из которого пробрасывается агент). Конфигурация должна выглядеть примерно так:\n\n```\n~/.ssh/config\n```\n\n```\nHost remote_name\n    ...\n    RemoteForward remote_agent_socket local_agent_extra_socket\n    RemoteForward remote_agent_ssh_socket local_agent_ssh_socket\n```\n\nПервая строка настраивает переадресацию gpg-agent:\n\n- remote_agent_socket — вывод команды gpgconf --list-dir agent-socket на удалённом хосте.\n- local_agent_extra_socket — вывод команды gpgconf --list-dir agent-extra-socket на локальном хосте.\n\nВторая строка является необязательной. Она настраивает переадресацию ssh-agent:\n\n- local_agent_ssh_socket — вывод команды gpgconf --list-dir agent-ssh-socket на удалённом хосте.\n- remote_agent_ssh_socket — вывод команды gpgconf --list-dir agent-ssh-socket на локальном хосте.\n\nТаким образом, с путями по умолчанию это будет выглядеть так:\n\n```\nRemoteForward /run/user/1000/gnupg/S.gpg-agent /run/user/1000/gnupg/S.gpg-agent.extra\n    RemoteForward /run/user/1000/gnupg/S.gpg-agent.ssh /run/user/1000/gnupg/S.gpg-agent.ssh\n```\n\nПри такой конфигурации вызов ssh remote_name должен автоматически пробросить gpg-agent с вашего локального устройства на сервер, к которому вы подключаетесь, и позволить использовать там ваши gpg-ключи для расшифровки/подписи (и, если вы добавили вторую строку RemoteForward, то использовать ssh-agent тоже).\n\n"
    },
    {
      "title": "Смарт-карты",
      "level": 2,
      "content": "GnuPG использует scdaemon в качестве интерфейса к устройству для чтения смарт-карт. Для получения дополнительной информации обратитесь к man-странице scdaemon(1).\n\n"
    },
    {
      "title": "Настройка только для GnuPG",
      "level": 3,
      "content": "Если вы не планируете использовать другие карты, кроме тех, что работают на основе GnuPG, необходимо проверить параметр reader-port в файле ~/.gnupg/scdaemon.conf. Значение '0' относится к первому доступному считывателю последовательного порта, а значение '32768' (по умолчанию) — к первому считывателю USB.\n\n"
    },
    {
      "title": "GnuPG вместе с pcscd (PCSC Lite)",
      "level": 3,
      "content": "pcscd(8) — это демон, который обрабатывает доступ к смарт-карте (SCard API). Если scdaemon не может подключиться к смарт-карте напрямую (например, используя встроенную поддержку CCID), он пытается найти смарт-карту с помощью драйвера PCSC Lite.\n\nДля использования pscsd установите пакеты pcsclite и ccid. Затем запустите и/или включите службу pcscd.service. Вместо запуска демона напрямую можно запустить и/или включить pcscd.socket, тогда демон будет запускаться только по необходимости.\n\n"
    },
    {
      "title": "Всегда использовать pcscd",
      "level": 4,
      "content": "Если вы используете смарт-карту с драйвером opensc (например, ID-карты, распространённые в некоторых странах), необходимо уделить чуть большее время настройке GnuPG. Используя стандартную конфигурацию, при запросе gpg --card-status вы можете получать сообщения вроде этого:\n\n```\ngpg: selecting openpgp failed: ec=6.108\n```\n\nПо умолчанию scdaemon пытается подключиться к устройству напрямую. Эта попытка провалится, если считыватель карт используется другим процессом. Например, если демон pcscd используется OpenSC. Чтобы справиться с этой ситуацией, необходимо использовать тот же самый драйвер, который использует opensc — тогда они смогут работать вместе. Чтобы заставить scdaemon использовать pcscd, необходимо удалить reader-port из файла ~/.gnupg/scdaemon.conf, указать путь к библиотеке libpcsclite.so и отключить ccid, чтобы удостовериться, что используется именно pcscd:\n\n```\n~/scdaemon.conf\n```\n\n```\npcsc-driver /usr/lib/libpcsclite.so\ncard-timeout 5\ndisable-ccid\n```\n\nОбратитесь к man-странице scdaemon(1), если вы не используете OpenSC.\n\n"
    },
    {
      "title": "Общий доступ с pcscd",
      "level": 4,
      "content": "GnuPG scdaemon — единственный популярный клиент pcscd, который использует флаг PCSC_SHARE_EXCLUSIVE при подключении к pcscd. Другие клиенты, такие как OpenSC PKCS#11, которые используются браузерами и программами, перечисленными в статье Electronic identification, используют PCSC_SHARE_SHARED, который даёт общий доступ к одной смарт-карте. pcscd не будет предоставлять эксклюзивный доступ к смарт-карте, пока подключены другие клиенты. Это означает, что для использования возможностей смарт-карты GnuPG вам придётся предварительно закрыть все открытые окна браузера или выполнить другие неудобные действия. Начиная с версии 2.2.28 LTS и 2.3.0, вы можете включить общий доступ, изменив файл scdaemon.conf и добавив pcsc-shared в конце.\n\nПри использовании YubiKey или других USB-ключей с несколькими апплетами с OpenSC PKCS#11 могут возникнуть проблемы, когда OpenSC переключает ваш Yubikey с апплета OpenPGP на апплет PIV, нарушая работу scdaemon.\n\nВы можете обойти эту проблему, заставив OpenSC также использовать апплет OpenPGP. Откройте файл /etc/opensc.conf, найдите Yubikey и измените строку driver = \"PIV-II\"; на driver = \"openpgp\";. Если такой записи нет, используйте pcsc_scan. Найдите Answer to Reset ATR: 12 34 56 78 90 AB CD .... Затем создайте новую запись.\n\n```\n/etc/opensc.conf\n```\n\n```\n...\ncard_atr 12:23:34:45:67:89:ab:cd:... {\n    name = \"YubiKey Neo\";\n    driver = \"openpgp\"\n}\n...\n```\n\nПосле этого вы можете проверить с помощью pkcs11-tool -O --login, что апплет OpenPGP выбран по умолчанию. Другие клиенты PKCS#11, такие как браузеры, может понадобиться перезапустить для применения этого изменения.\n\nЕсли вы входите в машину по SSH и пытаетесь использовать подключенное устройство через pcscd, то можете обнаружить ошибки типа:\n\n```\ngpg: selecting card failed: No such device\ngpg: OpenPGP card not available: No such device\n```\n\nЭто связано с тем, что Polkit предоставляет доступ только локальным клиентам. Чтобы решить эту проблему, можно добавить правило, разрешающее доступ определённым пользователям во всех случаях. Приведённое ниже правило разрешает всем пользователям из группы wheel доступ к устройствам через pcscd:\n\n```\n/etc/polkit-1/rules.d/99-pcscd.rules\n```\n\n```\npolkit.addRule(function(action, subject) {\n    if (action.id == \"org.debian.pcsc-lite.access_card\" &&\n        subject.isInGroup(\"wheel\")) {\n        return polkit.Result.YES;\n    }\n});\npolkit.addRule(function(action, subject) {\n    if (action.id == \"org.debian.pcsc-lite.access_pcsc\" &&\n        subject.isInGroup(\"wheel\")) {\n        return polkit.Result.YES;\n    }\n});\n```\n\nПосле создания файла перезапустите службу polkit.service.\n\n"
    },
    {
      "title": "Другой алгоритм",
      "level": 3,
      "content": "Возможно, вы захотите использовать более сильные алгоритмы:\n\n```\n~/.gnupg/gpg.conf\n```\n\n```\n...\n\npersonal-digest-preferences SHA512\ncert-digest-algo SHA512\ndefault-preference-list SHA512 SHA384 SHA256 SHA224 AES256 AES192 AES CAST5 ZLIB BZIP2 ZIP Uncompressed\npersonal-cipher-preferences TWOFISH CAMELLIA256 AES 3DES\n```\n\nВ последней версии GnuPG по умолчанию используются алгоритмы SHA256 и AES, которые достаточно безопасны для большинства пользователей. Однако если вы используете версию GnuPG старше 2.1 или если вы хотите получить ещё более высокий уровень безопасности, то вам стоит выполнить описанные выше действия.\n\n"
    },
    {
      "title": "Шифрование пароля",
      "level": 3,
      "content": "Может быть полезно зашифровать какой-нибудь пароль, чтобы он не хранился в чистом виде в файле настроек. Например, пароль от вашей учётной записи электронной почты.\n\nПервым делом создайте файл пароля, содержащий только ваш пароль и пустую строку. Обратите внимание: файл должен содержать одну пустую строку в конце, иначе gpg выведет сообщение об ошибке.\n\nТеперь выполните:\n\n```\n$ gpg -e -a -r user-id файл_пароля\n```\n\nОпция -e обозначает режим шифрования, -a — для вывода в ASCII-совместимом формате, -r — идентификатор ключа.\n\nПосле выполнения команды в текущем каталоге будет создан новый файл файл_пароля.asc.\n\n"
    },
    {
      "title": "Изменение модели доверия",
      "level": 3,
      "content": "По умолчанию GnuPG использует модель доверия Web of Trust. Можно изменить эту модель на Trust on first use, добавив --trust-model=tofu при добавлении ключа или добавив эту опцию в файл настроек GnuPG. Более подробная информация содержится в этом письме GnuPG.\n\n"
    },
    {
      "title": "Скрытие всех идентификаторов получателей",
      "level": 3,
      "content": "По умолчанию в зашифрованном сообщении содержится идентификатор ключа получателя. Его можно удалить во время шифрования для получателя с помощью hidden-recipient user-id. Чтобы удалить его для всех получателей, добавьте throw-keyids в файл настроек. Это помогает скрыть получателей сообщения и является ограниченной контрмерой против анализа трафика (то есть, используя немного социальной инженерии, любой, кто способен расшифровать сообщение, может проверить, является ли один из других получателей тем, кого он подозревает). На стороне получателя это может замедлить процесс расшифровки, поскольку необходимо попробовать все доступные закрытые ключи (например, с помощью --try-secret-key user-id).\n\n"
    },
    {
      "title": "Использование caff на встречах для подписи ключей",
      "level": 3,
      "content": "Чтобы дать возможность пользователям проверить ключи в хранилищах ключей и в собственных списках (то есть убедиться, что владелец ключа на самом деле тот, за кого себя выдаёт), PGP/GnuPG использует так называемую «сеть доверия» (Web of Trust). Для поддержания и развития сети периодически организуются очные встречи, на которых люди, использующие систему PGP, обмениваются своими публичными ключами. Протокол Циммермана–Сассамана призван сделать этот процесс наиболее эффективным. Здесь вы можете найти инструкцию по проведению встреч.\n\nДля упрощения процедуры подписи ключей и отправки этих подписей владельцам ключей вы можете воспользоваться утилитой caff. Установить её можно из AUR с пакетом caff-gitAUR.\n\nДля отправки подписей владельцам вам нужен работающий агент MTA. Если у вас его ещё нет, установите msmtp.\n\n"
    },
    {
      "title": "Отображение длинных идентификаторов и отпечатков",
      "level": 3,
      "content": "Чтобы всегда показывать длинные идентификаторы ключей, добавьте keyid-format 0xlong в файл настроек. Чтобы всегда показывать полные отпечатки, добавьте with-fingerprint.\n\n"
    },
    {
      "title": "Настройка возможностей",
      "level": 3,
      "content": "Можно установить пользовательские возможности (capabilities) для ваших ключей. Доступны следующие возможности:\n\n- Сертификация (Certify, только для мастер-ключей) — позволяет ключу создавать подключи, обязательна для мастер-ключей.\n- Подпись (Sign) — позволяет ключу создавать криптографические подписи, которые другие могут проверить с помощью открытого ключа.\n- Шифрование (Encrypt) — позволяет любому человеку шифровать данные с помощью открытого ключа, расшифровать которые может только закрытый ключ.\n- Аутентификация (Authenticate) — позволяет использовать ключ для аутентификации в различных программах, не относящихся к GnuPG. Ключ можно использовать, например, в качестве ключа SSH.\n\nМожно указать возможности мастер-ключа, выполнив команду:\n\n```\n$ gpg --full-generate-key --expert\n```\n\nИ выбрав опцию, позволяющую задать собственные возможности.\n\nАналогично, чтобы задать возможности для подключей, добавьте флаг --expert в команду gpg --edit-key; смотрите раздел #Редактирование ключа.\n\n"
    },
    {
      "title": "su",
      "level": 3,
      "content": "При использовании pinentry у вас должны быть корректные настройки прав доступа к устройству терминала (например /dev/tty1). Однако при использовании su (или sudo) права доступа остаются у изначального пользователя. Из-за этого будут возникать проблемы с pinentry, даже при запуске от имени суперпользователя. При попытке использовать ssh будет возникать ошибка sign_and_send_pubkey: signing failed: agent refused operation. Чтобы исправить эту проблему, назначьте нового владельца к устройству терминала до использования pinentry (например, перед запуском gpg-agent). При использовании gpg от имени суперпользователя просто измените владельца на root перед использованием gpg:\n\n```\n# chown root /dev/ttyN  # где N — текущий tty\n```\n\nЗатем верните прежнего владельца после первого запуска gpg. Аналогично должно работать и для /dev/pts/.\n\nNote: **не** \n\n```\n# script -q -c \"gpg --gen-key\" /dev/null\n```\n\n"
    },
    {
      "title": "Agent выводит ошибку end of file",
      "level": 3,
      "content": "Если используется /usr/bin/pinentry-gnome3, для его правильной работы требуется запущенный DBus. Для получения дополнительной информации смотрите раздел Устранение часто встречающихся неполадок#Разрешения сессии.\n\nТакже можно использовать другую реализацию pinentry. Как это сделать, смотрите в разделе #pinentry.\n\n"
    },
    {
      "title": "Настройка прав доступа для KGpg",
      "level": 3,
      "content": "Некоторые пользователи сталкивались с проблемой, когда kgpg не может получить доступ к настройкам в ~/.gnupg/. Одна из причин может быть в устаревшем файле options. Подробности смотрите в отчёте об ошибке.\n\n"
    },
    {
      "title": "GNOME на Wayland переопределяет сокет агента SSH",
      "level": 3,
      "content": "В сеансах Wayland gnome-session устанавливает SSH_AUTH_SOCK на стандартный сокет gnome-keyring, $XDG_RUNTIME_DIR/keyring/ssh. Это переопределяет любое значение, установленное в другом месте.\n\nОтключение такого поведения описано в статье GNOME/Keyring#Disabling.\n\n"
    },
    {
      "title": "mutt",
      "level": 3,
      "content": "Mutt может неправильно использовать gpg-agent, вам нужно установить переменную окружения GPG_AGENT_INFO (содержимое не имеет значения) при запуске mutt. Также убедитесь, что включено #Кэширование паролей.\n\nСмотрите эту ветку форума.\n\n"
    },
    {
      "title": "\"Потерявшиеся\" ключи после обновления до GnuPG 2.1",
      "level": 3,
      "content": "Если команда gpg --list-keys перестала отображать какие-то ключи, а приложения ругаются на отсутствующие/повреждённые ключи, вероятно, какие-то ключи не были сконвертированы в новый формат.\n\nПрочтите исправление ошибки Invalid packet. Здесь говорится, что существует баг с ключами в старых файлах pubring.gpg и secring.gpg, которые были заменены файлом pubring.kbx и подкаталогом private-keys-v1.d/. Потерянные ключи можно восстановить следующими командами:\n\n```\n$ cd\n$ cp -r .gnupg gnupgOLD\n$ gpg --export-ownertrust > otrust.txt\n$ gpg --import .gnupg/pubring.gpg\n$ gpg --import-ownertrust otrust.txt\n$ gpg --list-keys\n```\n\n"
    },
    {
      "title": "gpg зависает на всех серверах ключей (при попытке получения ключей)",
      "level": 3,
      "content": "Если gpg зависает на определённом сервере ключей, когда пытается получить ключи, вам придётся убить dirmngr для того, чтобы получить доступ к другим действительно рабочим серверам, в противном случае gpg останется зависшим для всех них.\n\n"
    },
    {
      "title": "Смарт-карта не обнаружена",
      "level": 3,
      "content": "Возможно, пользователь, из-под которого вы работаете, не имеет права доступа к смарт-карте, вследствие чего и возникает card error, даже если карта корректно настроена и установлена.\n\nОдно из возможных решений — добавить новую группу scard с включением в неё пользователей, которым нужен доступ к смарт-карте.\n\nДальше используйте подобное правило udev:\n\n```\n/etc/udev/rules.d/71-gnupg-ccid.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"usb\", ENV{ID_VENDOR_ID}==\"1050\", ENV{ID_MODEL_ID}==\"0116|0111\", MODE=\"660\", GROUP=\"scard\"\n```\n\nТолько нужно адаптировать VENDOR и MODEL в соответствии с выводом lsusb. Выше приведён пример для YubikeyNEO.\n\n"
    },
    {
      "title": "server 'gpg-agent' is older than us (x < y)",
      "level": 3,
      "content": "Это предупреждение появляется, если gnupg был обновлён, а старый gpg-agent всё ещё запущен. Перезапустите пользовательский gpg-agent.socket (т.е. используйте флаг --user при перезапуске).\n\n"
    },
    {
      "title": "IPC connect call failed",
      "level": 3,
      "content": "Убедитесь, что gpg-agent и dirmngr не запущены, с помощью команды killall gpg-agent dirmngr, и проверьте права доступа к каталогу $GNUPGHOME/crls.d/, которые должны быть 700.\n\nПо умолчанию пакет gnupg использует для сокетов каталог /run/user/$UID/gnupg/. В документации GnuPG указано, что это предпочтительный каталог (не все файловые системы поддерживают сокеты). Убедитесь, что в конфигурации agent-socket указан путь к поддерживающей сокеты файловой системе. Настройки пути для agent-socket можно узнать, выполнив команду gpgconf --list-dirs agent-socket.\n\nПроверьте, что gpg-agent успешно запускается, с помощью команды gpg-agent --daemon.\n\n"
    },
    {
      "title": "Защита от отравленных PGP-сертификатов",
      "level": 3,
      "content": "В июне 2019 года неизвестный злоумышленник заспамил PGP-сертификаты некоторых высокопоставленных участников сообщества десятками тысяч (или сотнями тысяч) подписей (CVE-2019-13050) и загрузил эти подписи на серверы ключей SKS. Существование этих отравленных сертификатов в списке ключей приводит к зависанию gpg со следующим сообщением:\n\n```\ngpg: removing stale lockfile (created by 7055)\n```\n\nВозможное решение проблемы заключается в удалении отравленного сертификата, как описано в этой статье.\n\n"
    },
    {
      "title": "Invalid IPC response и Inappropriate ioctl for device",
      "level": 3,
      "content": "По умолчанию программой pinentry является /usr/bin/pinentry-gtk-2. Если gtk2 недоступен, pinentry пытается использовать /usr/bin/pinentry-curses, что приводит к сбою подписания:\n\n```\ngpg: signing failed: Inappropriate ioctl for device\ngpg: [stdin]: clear-sign failed: Inappropriate ioctl for device\n```\n\nУстановите переменную окружения GPG_TTY для программ /usr/bin/pinentry-tty и /usr/bin/pinentry-curses.\n\n```\n$ export GPG_TTY=$(tty)\n```\n\n"
    },
    {
      "title": "Keyblock resource не существует",
      "level": 3,
      "content": "Если при попытке импортировать ключи вы получаете ошибку:\n\n```\ngpg: keyblock resource 'gnupg_home/pubring.kbx': No such file or directory\n```\n\nэто потому что GnuPG не создаст свой домашний каталог, если его ещё нет. Просто создайте его вручную:\n\n```\n$ mkdir -m 700 gnupg_home\n```\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Домашняя страница GNU Privacy Guard\n- Alan Eliasen's GPG Tutorial\n- RFC 4880 — \"OpenPGP Message Format\"\n- gpg.conf recommendations and best practices\n- Fedora:Creating GPG Keys\n- Debian:Subkeys\n- Protecting code integrity with PGP\n- A more comprehensive gpg Tutorial\n- /r/GPGpractice - сабреддит для тренировки использования GnuPG.\n\n"
    }
  ]
}