{
  "title": "Файловые системы",
  "url": "https://wiki.archlinux.org/title/%D0%A4%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%8B%D0%B5_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D1%8B",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Разметка дисков\n- Файл устройства#lsblk\n- Разрешения и атрибуты файлов\n- fsck (Русский)\n- fstab (Русский)\n- List of applications/Utilities#Mount tools\n- QEMU#Mounting a partition from a raw image\n- udev (Русский)\n- udisks (Русский)\n- umask (Русский)\n- USB-накопители\n\nИз Википедии:\n\nОтдельные разделы дисков можно настроить с использованием одной из множества доступных файловых систем. У каждой есть свои преимущества, недостатки и уникальные особенности. Ниже приведён краткий обзор поддерживаемых файловых систем; также и ссылки на страницы Википедии, которые предоставляют гораздо больше информации.\n\n"
    },
    {
      "title": "Типы файловых систем",
      "level": 2,
      "content": "Смотрите filesystems(5) для общего обзора и сравнение файловых систем в Википедии для подробного сравнения функций. Файловые системы, поддержка которых встроена в ядро или для которых загружены модули, перечислены в /proc/filesystems. Список доступных модулей, предоставляющих поддержку для различных файловых систем, можно посмотреть с помощью команды ls /lib/modules/$(uname -r)/kernel/fs.\n\nTable content:\nФайловая система | Команда создания | Утилиты пользовательского пространства | Archiso [1] | Документация ядра [2] | Примечания\nBcachefs | bcachefs(8) | bcachefs-tools | Да |  | Доступна в Linux 6.7+, экспериментальная\nBtrfs | mkfs.btrfs(8) | btrfs-progs | Да | btrfs.html | Статус стабильности\nVFAT | mkfs.fat(8) | dosfstools | Да | vfat.html | Файловая система Windows 9x\nexFAT | mkfs.exfat(8) | exfatprogs | Да |  | Поддержка встроена в Linux с версии 5.4 [3]\nmkexfatfs(8) | exfat-utils | Нет | н/д (на основе FUSE) | \nF2FS | mkfs.f2fs(8) | f2fs-tools | Да | f2fs.html | Ориентирована на использование с флеш-памятью\next3 | mkfs.ext3(8) | e2fsprogs | Да | ext3.html | \next4 | mkfs.ext4(8) | e2fsprogs | Да | ext4.html | \nHFS | mkfs.hfsplus(8) | hfsprogsAUR | Нет | hfs.html | Файловая система классической Mac OS\nHFS+ | mkfs.hfsplus(8) | hfsprogsAUR | Нет | hfsplus.html | Файловая система macOS (8–10.12)\nJFS | mkfs.jfs(8) | jfsutils | Да | jfs.html | \nNILFS2 | mkfs.nilfs2(8) | nilfs-utils | Да | nilfs2.html | Для использования с raw-доступом к флеш-памяти, например для SD-карт\nNTFS |  |  | Да | ntfs3.html | Файловая система Windows NT. Новый драйвер, встроенный в Linux с версии 5.15.\n | ntfs-3g[4] | Нет | ntfs.html[устаревшая ссылка 2024-07-30 ⓘ] | Старый драйвер. Имеет очень ограниченную поддержку записи. Официальные ядра собираются без CONFIG_NTFS_FS, поэтому этот драйвер недоступен.\nmkfs.ntfs(8) | Да | н/д (на основе FUSE) | FUSE-драйвер с дополнительными возможностями.\nReiserFS | mkfs.reiserfs(8) | reiserfsprogsAUR | Да |  | ReiserFS объявлена устаревшей в Linux 5.18 и будет удалена в 2025 году.\nUDF | mkfs.udf(8) | udftools | Да | udf.html | \nXFS | mkfs.xfs(8) | xfsprogs | Да | xfs.html xfs-delayed-logging-design.html[устаревшая ссылка 2024-03-03 ⓘ] xfs-self-describing-metadata.html[устаревшая ссылка 2024-03-03 ⓘ] | Нельзя уменьшить размер\n\nxfs.html xfs-delayed-logging-design.html[устаревшая ссылка 2024-03-03 ⓘ] xfs-self-describing-metadata.html[устаревшая ссылка 2024-03-03 ⓘ]\n\nTable content:\nФайловая система | Команда создания | Патчи для ядра | Утилиты пользовательского пространства | Примечания\nAPFS | mkapfs(8) | linux-apfs-rw-dkms-gitAUR | apfsprogs-gitAUR | Файловая система macOS (10.13 и новее). Поддержка экспериментальная, только для чтения. Смотрите также apfs-fuse-gitAUR — FUSE-версия.\nReiser4 | mkfs.reiser4(8) |  | reiser4progsAUR | \nZFS |  | zfs-linuxAUR, zfs-dkmsAUR | zfs-utilsAUR | Порт OpenZFS\n\n"
    },
    {
      "title": "Журналирование",
      "level": 3,
      "content": "Все вышеупомянутые файловые системы, за исключением ext2, FAT16/32, Reiser4 (опционально), Bcachefs, Btrfs и ZFS, используют ведение журнала. Журналирование обеспечивает отказоустойчивость путём записывания изменений в журнал перед фактическим изменением файловой системы. В случае сбоя системы или сбоя питания такие файловые системы быстрее возвращаются в работу и реже оказываются повреждёнными. Ведение журнала происходит в отдельной области файловой системы.\n\nНе все методы ведения журнала одинаковы. Ext3 и ext4 предлагают журналирование в режиме данных, при котором в журнал записываются как данные, так и метаданные, а также возможность вести журнал только изменений метаданных. Журналирование в режиме данных снижает скорость и не включено по умолчанию. В том же ключе Reiser4 предлагает так называемые «модели транзакций», которые меняют не только предоставляемые возможности, но и режим журналирования. В ней используются различные методы журналирования: специальная модель «блуждающих журналов» («wandering logs»), избавляющая от необходимости записывать данные на диск дважды, «запись везде» («write-anywhere») — чистое копирование при записи (в основном эквивалентное используемому по умолчанию Btrfs, но с принципиально иной конструкцией «дерева») и комбинированный подход, который эвристически чередует два первых.\n\nNote: **node41** \n\nДругие файловые системы обеспечивают упорядоченное ведение журнала (ordered-mode), при котором записываются только метаданные. Хотя любое журналирование позволяет восстановить файловую систему после сбоя, журналирование в режиме данных обеспечивает максимальную защиту от повреждений и потери данных. Однако это влияет на производительность системы, поскольку журналирование в режиме данных выполняет две операции записи: сначала в журнал, а затем на диск (Reiser4 избегает это с помощью «блуждающих журналов»). При выборе типа файловой системы следует учитывать компромисс между скоростью системы и безопасностью данных. Reiser4 — единственная файловая система, которая реализует полную атомарность, а также контрольные суммы как для метаданных, так и для встроенных данных (операции либо полностью выполняются, либо полностью не выполняются, не повреждая данные наполовину выполненной операцией) и поэтому гораздо менее подвержена потере данных, чем другие файловые системы, например Btrfs.\n\nФайловые системы, основанные на механизме копирования при записи (copy-on-write или write-anywhere), такие как Reiser4, Bcachefs, Btrfs и ZFS, не нуждаются в использовании традиционного журнала для защиты метаданных, потому что они никогда не обновляют данные в том же месте. Хотя Btrfs всё ещё имеет дерево, подобное журналу, оно используется только для ускорения работы fdatasync/fsync.\n\n"
    },
    {
      "title": "Файловые системы на основе FUSE",
      "level": 3,
      "content": "Смотрите статью FUSE (Русский).\n\n"
    },
    {
      "title": "Штабелируемые файловые системы",
      "level": 3,
      "content": "- eCryptfs — корпоративная криптографическая файловая система представляет собой пакет программного обеспечения для шифрования диска Linux. Он реализует шифрование на уровне файловой системы, совместимый с POSIX, с целью предложить функциональность, аналогичную функции GnuPG на уровне операционной системы.\n\n- mergerfs — объединенная файловая система на основе FUSE.\n\n- mhddfs — файловая система Multi-HDD FUSE, объединенная на основе FUSE.\n\n- overlayfs — это служба файловой системы для Linux, которая реализует объединение для монтирования других файловых систем.\n\n- unionfs-fuse — реализация пользовательского пространства Unionfs.\n\n"
    },
    {
      "title": "Файловые системы только для чтения",
      "level": 3,
      "content": "- EROFS — Enhanced Read-Only File System — легковесная файловая система только для чтения, направленная на улучшение производительности и сжатия.\n\n- SquashFS — Файловая система, хранящая данные в сжатом виде только для чтения. SquashFS сжимает файлы, индексные дескрипторы и каталоги, а также поддерживает блоки размером до 1 МиБ для лучшего сжатия.\n\n"
    },
    {
      "title": "Кластерные файловые системы",
      "level": 3,
      "content": "- BeeGFS — Параллельная файловая система, разработанная и оптимизированная для высокопроизводительных вычислений.\n\n- Ceph — Унифицированная распределённая система хранения, разработанная для отличной производительности, надёжности и масштабируемости.\n\n- Glusterfs — Кластерная файловая система, способная масштабироваться до нескольких петабайт.\n\n- IPFS — Одноранговый протокол гипермедиа, чтобы сделать Интернет более быстрым, безопасным и открытым. IPFS нацелена на замену HTTP и создание лучшей сети для всех нас. Использует блоки для хранения частей файла, каждый сетевой узел хранит только интересующий контент, обеспечивает дедупликацию, распространение, масштабируемую систему, ограниченную только пользователями. (В настоящее время в alpha)\n\n- MinIO — Высокопроизводительное объектное хранилище, совместимое с S3.\n\n- MooseFS — Отказоустойчивая, высокодоступная и высокопроизводительная сетевая распределённая файловая система.\n\n- OpenAFS — Открытая реализация распределённой файловой системы AFS\n\n- OrangeFS — Масштабируемая сетевая файловая система, предназначенная для прозрачного доступа к дисковой памяти на нескольких серверах параллельно. Имеет оптимизированную поддержку MPI-IO для параллельных и распределённых приложений. Упрощает использование параллельного хранения не только для клиентов Linux, но и для Windows, Hadoop и WebDAV. POSIX-совместимая. Часть ядра Linux, начиная с версии 4.6.\n\n- Sheepdog — Распределённая объектная система хранения данных для сервисов томов и контейнеров, интеллектуально управляющая дисками и узлами.\n\n- Tahoe-LAFS — Tahoe Least-Authority File Store — это бесплатное и открытое, безопасное, децентрализованное, отказоустойчивое, одноранговое распределённое хранилище данных и распределённая файловая система.\n\n"
    },
    {
      "title": "Файловые системы с общим доступом к диску",
      "level": 3,
      "content": "- GFS2 — GFS2 позволяет всем участникам кластера иметь прямой параллельный доступ к одному и тому же общему блочному хранилищу.\n\n- OCFS2 — The Oracle Cluster File System (версия 2) — файловая система с общим дисковым пространством, разработанная корпорацией Oracle и выпущенная под лицензией GNU GPL.\n\n- VMware VMFS — Virtual Machine File System — используется во vSphere — флагманском пакете компании для виртуализации серверов.\n\n"
    },
    {
      "title": "Определение существующих файловых систем",
      "level": 2,
      "content": "Чтобы определить существующие файловые системы, вы можете использовать lsblk:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE LABEL     UUID                                 MOUNTPOINT\nsdb\n└─sdb1 vfat   Transcend 4A3C-A9E9\n```\n\nСуществующая файловая система, если она есть, будет показана в столбце FSTYPE. Если она смонтирована, то она появится в столбце MOUNTPOINT.\n\n"
    },
    {
      "title": "Создание файловой системы",
      "level": 2,
      "content": "Файловые системы обычно создаются на разделе, внутри логических контейнеров, таких как LVM, RAID и dm-crypt, или в обычном файле (смотрите Wikipedia:Loop device). В этом разделе описывается создание файловой системы на разделе.\n\nNote: **Создайте резервную копию любых данных, которые вы хотите сохранить** \n\n- После создания новой файловой системы данные, ранее сохраненные на этом разделе, вряд ли можно будет восстановить. Создайте резервную копию любых данных, которые вы хотите сохранить.\n- Цель использования раздела может ограничить выбор файловой системы. Например, системный раздел EFI должен содержать файловую систему FAT32, а файловая система, содержащая каталог /boot, должна поддерживаться используемым вами загрузчиком.\n\nПрежде чем продолжить, определите устройство, в котором будет создана файловая система, и проверьте, не примонтировано ли оно. Например:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE   LABEL       UUID                                 MOUNTPOINT\nsda\n├─sda1                      C4DA-2C4D\n├─sda2 ext4                 5b1564b2-2e2c-452c-bcfa-d1f572ae99f2 /mnt\n└─sda3                      56adc99b-a61e-46af-aab7-a6d07e504652\n```\n\nПеред продолжением необходимо размонтировать файловую систему. В приведённом выше примере существующая файловая система находится на /dev/sda2 и монтируется в /mnt. Размонтировать можно командой:\n\n```\n# umount /dev/sda2\n```\n\nЧтобы найти только смонтированные файловые системы, смотрите #Список смонтированных файловых систем.\n\nЧтобы создать новую файловую систему, используйте mkfs(8). Смотрите #Типы файловых систем для точного типа, а также утилиты пользовательского пространства, которые вы, возможно, захотите установить для конкретной файловой системы.\n\nНапример, чтобы создать новую файловую систему типа ext4 (обычно для разделов данных Linux) на /dev/sda1, запустите:\n\n```\n# mkfs.ext4 /dev/sda1\n```\n\n- Используйте флаг -L mkfs.ext4, чтобы указать метку файловой системы. e2label можно использовать для изменения метки в существующей файловой системе.\n- Размер файловых систем можно изменить после создания, но с определёнными ограничениями. Например, размер файловой системы XFS можно только увеличить, но не уменьшить. Для получения дополнительной информации смотрите Возможности изменения размера и документацию интересующей вас файловой системы.\n\nНовая файловая система теперь может быть смонтирована в желаемый каталог.\n\n"
    },
    {
      "title": "Монтирование файловой системы",
      "level": 2,
      "content": "Чтобы вручную смонтировать файловую систему, расположенную на устройстве (например, раздел) к каталогу, используйте mount(8). В этом примере монтируется /dev/sda1 в /mnt.\n\n```\n# mount /dev/sda1 /mnt\n```\n\nЭто прикрепляет файловую систему раздела /dev/sda1 в каталог /mnt, делая содержимое файловой системы видимым. Любые данные, существовавшие в /mnt перед этим действием, становятся невидимыми до тех пор, пока устройство не будет размонтировано.\n\nfstab содержит информацию о том, как устройства должны автоматически монтироваться, если они присутствуют. Для получения дополнительной информации о том, как изменить это поведение, смотрите статью fstab.\n\nЕсли устройство указано в /etc/fstab и в команду mount передаётся только устройство или точка монтирования, то остальные параметры монтирования будут взяты из этого файла. Например, если /etc/fstab содержит строку, указывающую, что /dev/sda1 должен быть смонтирован в /mnt, тогда такие команды mount будут автоматически монтировать это устройство в этот каталог:\n\n```\n# mount /dev/sda1\n```\n\nИли\n\n```\n# mount /mnt\n```\n\nmount содержит несколько параметров, многие из которых зависят от указанной файловой системы. Параметры могут быть изменены через:\n\n- использование флагов в командной строке с mount\n- редактирование fstab\n- создание правил udev\n- самостоятельное компилирование ядра\n- или скрипты монтирования, специфичные файловой системы (расположенные в /usr/bin/mount.*).\n\nБолее подробную информацию смотрите в связанных статьях и статье интересующей файловой системы.\n\n- Файловые системы также можно монтировать с помощью команды systemd-mount вместо mount. Если точка монтирования не указана, то файловая система будет смонтирована в /run/media/system/идентификатор_устройства/. Это позволяет легко смонтировать файловую систему без необходимости решать, куда её монтировать. Использование и подробности описаны в systemd-mount(1).\n- Для монтирования файловых систем от имени обычного пользователя можно использовать udisks. Он также позволяет выполнять монтирование без прав суперпользователя и может использоваться через графический интерфейс, например, в файловых менеджерах, использующих udisks.\n\n"
    },
    {
      "title": "Список смонтированных файловых систем",
      "level": 3,
      "content": "Чтобы увидеть все смонтированные файловые системы, используйте findmnt(8):\n\n```\n$ findmnt\n```\n\nfindmnt принимает множество аргументов, которые могут фильтровать вывод и отображать дополнительную информацию. Например, в качестве аргумента может принимать устройство или точку монтирования для отображения только информации о том, что указывается:\n\n```\n$ findmnt /dev/sda1\n```\n\nfindmnt собирает информацию из /etc/fstab, /etc/mtab и /proc/self/mounts.\n\n"
    },
    {
      "title": "Размонтирование файловой системы",
      "level": 3,
      "content": "Чтобы размонтировать файловую систему, используйте umount(8). Можно указать либо устройство, содержащее файловую систему (например, /dev/sda1), либо точку монтирования (например, /mnt):\n\n```\n# umount /dev/sda1\n```\n\nили\n\n```\n# umount /mnt\n```\n\n"
    },
    {
      "title": "\"linux Structure needs cleaning\"",
      "level": 3,
      "content": "Размонтируйте файловую систему и выполните fsck для проблемного тома.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- filesystems(5)\n- systemd-mount(1)\n- Документация файловых систем, поддерживаемых в Linux\n- Википедия:Файловая система\n- Википедия:mount\n\n"
    }
  ]
}