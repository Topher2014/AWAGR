{
  "title": "VCS PKGBUILD Guidelines (日本語)",
  "url": "https://wiki.archlinux.org/title/VCS_PKGBUILD_Guidelines_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32ビット – CLR – クロス – Eclipse – Electron – Free Pascal – GNOME – Go – Haskell – Java – KDE – カーネル – Lisp – MinGW – Node.js – ノンフリー – OCaml – Perl – PHP – Python – R – Ruby – Rust – VCS – ウェブ – Wine\n\nバージョン管理システムは通常の安定版のパッケージと最新の (trunk) 開発版のブランチ、どちらのソースコードの取得にも使うことができます。この記事では両方のケースを説明しています。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 プロトタイプ\n- 2 ガイドライン 2.1 パッケージの命名 2.2 バージョン管理 2.3 競合と依存関係 2.4 認証とセキュリティ 2.5 VCS ソース 2.6 関数 pkgver() 2.6.1 Git 2.6.2 Subversion 2.6.3 Mercurial 2.6.4 Bazaar 2.6.5 Fallback\n- 3 ヒントとテクニック 3.1 Git サブモジュール\n\n- 2.1 パッケージの命名\n- 2.2 バージョン管理\n- 2.3 競合と依存関係\n- 2.4 認証とセキュリティ\n- 2.5 VCS ソース\n- 2.6 関数 pkgver() 2.6.1 Git 2.6.2 Subversion 2.6.3 Mercurial 2.6.4 Bazaar 2.6.5 Fallback\n\n- 2.6.1 Git\n- 2.6.2 Subversion\n- 2.6.3 Mercurial\n- 2.6.4 Bazaar\n- 2.6.5 Fallback\n\n- 3.1 Git サブモジュール\n\n"
    },
    {
      "title": "プロトタイプ",
      "level": 2,
      "content": "pacman パッケージで提供されている PKGBUILD プロトタイプ (/usr/share/pacman にある PKGBUILD-split.proto, PKGBUILD-vcs.proto, PKGBUILD.proto) だけを使ってください。\n\n"
    },
    {
      "title": "パッケージの命名",
      "level": 3,
      "content": "pkgname の末尾に -cvs, -svn, -hg, -darcs, -bzr, -git などを付けて下さい。パッケージが特定のリリースを取得する場合は別です。\n\n"
    },
    {
      "title": "バージョン管理",
      "level": 3,
      "content": "- 依存関係, URL, ソースなどの変更を行なったことで作られるパッケージが異なるようになった時は pkgrel の値を増やして下さい。pkgver を変える必要はありません。\n\n- --holdver を使うことで makepkg が pkgver を更新するのを止めることができます (参照: makepkg(8))\n\n"
    },
    {
      "title": "競合と依存関係",
      "level": 3,
      "content": "- * パッケージが競合するものと提供するものを含めます (例: fluxbox-gitAUR: conflicts=('fluxbox') および provides=('fluxbox'))\n- replaces=() は通常、不要な問題を引き起こすため、回避する必要があります。\n- 適切な VCS ツールを makedepends=() (cvs、subversion、git、...) に含めます。\n\n"
    },
    {
      "title": "認証とセキュリティ",
      "level": 3,
      "content": "- cvsroot を使用する場合は、空のパスワードまたは anonymous:password@ (必要な場合) を入力する手間を避けるために、anonymous@ ではなく anonymous:@ を使用してください。\n- ソースは静的ではないため、'SKIP' を追加して、sha256sums=() のチェックサムをスキップします。\n\n"
    },
    {
      "title": "VCS ソース",
      "level": 3,
      "content": "pacman 4.1 から、VCS ソースは source=() に指定することになり他のソースと同じように扱われるようになりました。makepkg はリポジトリを $SRCDEST (makepkg.conf(5) の設定がない場合は $startdir と同じ) に複製・チェックアウト・ブランチして $srcdir にコピーします (それぞれの VCS に合わせた方法を使います)。ローカルリポジトリは変更がされないので、-build ディレクトリを作る必要はありません。\n\nVCS の source=() の一般的なフォーマットは:\n\n```\nsource=('[folder::][vcs+]url[#fragment]')\n```\n\n- folder (任意) はデフォルトのリポジトリ名を (trunk など) 無関係な名前から他の名前に変更するため、もしくは以前のソースを維持するために使われます。\n- vcs+ は VCS のタイプを表さない URL で必要です (例: git+http://some_repo)。\n- url はリモートやローカルのリポジトリの URL です。\n- #fragment (任意) は特定のブランチやコミットを pull するのに必要です。各 VCS で使えるフラグメントの詳細は man PKGBUILD を見て下さい。\n\nGit の source の例:\n\n```\nsource=('project_name::git+http://project_url#branch=project_branch')\n```\n\n"
    },
    {
      "title": "関数 pkgver()",
      "level": 3,
      "content": "pkgver() 関数を使うことで pkgver を自動で更新することが可能です。これによって pkgver をより良くコントロールすることができるようになります。メンテナは pkgver を意味あるものに扱うべきです。\n\n次のバージョンフォーマットが推奨されています: RELEASE.rREVISION。REVISION はソースツリーの変更毎に増える番号です (VCS のリビジョンと同じ)。最新の VCS タグは RELEASE に使うことができます。公開リリースやリポジトリのタグがない場合、ゼロをリリース番号に使ったり RELEASE を完全に省いて rREVISION のようにバージョンを使って下さい。公開リリースが存在してリポジトリにタグがないときは開発者はプロジェクトファイルのパースなどによってリリースバージョンを取得します。\n\nリビジョン番号の区分け (REVISION の前の \"r\") は重要です。開発元が初めてリリースを行うことを決めたり、別のバージョン方式によるバージョンを付けるようになった場合に問題を避けることができます。例えばリビジョン \"455\" で、上流がバージョン 0.1 をリリースした場合、リビジョンの区分けをしていれば問題なくバージョンアップが認識されます (0.1.r456 > r454)。区分けがないとバージョンアップと認識されません (0.1.456 < 454)。\n\n以下は意図した出力を行うサンプルです:\n\n"
    },
    {
      "title": "Git",
      "level": 4,
      "content": "最後のコミットの注釈付きタグを使う:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  git describe --long | sed 's/\\([^-]*-g\\)/r\\1/;s/-/./g'\n}\n```\n\n```\n2.0.r6.ga17a017\n```\n\n最後のコミットの注釈が付かないタグを使う:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  git describe --long --tags | sed 's/\\([^-]*-g\\)/r\\1/;s/-/./g'\n}\n```\n\n```\n0.71.r115.gd95ee07\n```\n\ngit タグにダッシュが含まれていない場合、sed はもっとシンプルにできます: sed 's/-/.r/;s/-/./'。\n\nタグに v やプロジェクト名などが付いている場合、取り除きます:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  # cutting off 'foo-' prefix that presents in the git tag\n  git describe --long | sed 's/^foo-//;s/\\([^-]*-g\\)/r\\1/;s/-/./g'\n}\n```\n\n```\n6.1.r3.gd77e105\n```\n\nタグが存在しない場合、最初から数えたリビジョンの数を使ってください:\n\n```\npkgver() {\n  cd \"$pkgname\"\n  printf \"r%s.%s\" \"$(git rev-list --count HEAD)\" \"$(git rev-parse --short HEAD)\"\n}\n```\n\n```\nr1142.a17a017\n```\n\nバージョンとコミット/リビジョン番号のみ (SHA1 は省かれます。ただし、バージョンを忘れると実際のリビジョンがわからなくなります):\n\n```\ngit describe --long | sed -r 's/-([0-9,a-g,A-G]{7}.*)//' | sed 's/-/./'\n```\n\n両方を組み合わせて、タグが最初に付かないリポジトリに対応することもできます (bashism を使用):\n\n```\npkgver() {\n  cd \"$pkgname\"\n  ( set -o pipefail\n    git describe --long 2>/dev/null | sed 's/\\([^-]*-g\\)/r\\1/;s/-/./g' ||\n    printf \"r%s.%s\" \"$(git rev-list --count HEAD)\" \"$(git rev-parse --short HEAD)\"\n  )\n}\n```\n\n```\n0.9.9.r27.g2b039da  # if tags exist\nr1581.2b039da       # else fallback\n```\n\n"
    },
    {
      "title": "Subversion",
      "level": 4,
      "content": "```\npkgver() {\n  cd \"$pkgname\"\n  local ver=\"$(svnversion)\"\n  printf \"r%s\" \"${ver//[[:alpha:]]}\"\n}\n```\n\n```\nr8546\n```\n\n"
    },
    {
      "title": "Mercurial",
      "level": 4,
      "content": "```\npkgver() {\n  cd \"$pkgname\"\n  printf \"r%s.%s\" \"$(hg identify -n)\" \"$(hg identify -i)\"\n}\n```\n\n```\nr2813.75881cc5391e\n```\n\n"
    },
    {
      "title": "Bazaar",
      "level": 4,
      "content": "```\npkgver() {\n  cd \"$pkgname\"\n  printf \"r%s\" \"$(bzr revno)\"\n}\n```\n\n```\nr830\n```\n\n"
    },
    {
      "title": "Fallback",
      "level": 4,
      "content": "リポジトリから pkgver が全く得られない場合は、現在の日付を使うことができます:\n\n```\npkgver() {\n  date +%Y%m%d\n}\n```\n\n```\n20130408\n```\n\nソースツリーの状態を一意に示しているのではないので、できるる限り使わないで下さい。\n\n"
    },
    {
      "title": "Git サブモジュール",
      "level": 3,
      "content": "Git のサブモジュールは、注意が必要です。サブモジュール自身の URL を直接 sources 配列に追加し、prepare() の中でそれらを参照するというものです\n\n下流プロジェクトの開発者は、上流モジュールのリポジトリと同じ名前のサブモジュールを作成することはできません。git サブモジュールの名前を確認するには、プロジェクトのリポジトリにある .gitmodules ファイルを開いてプレビューしてください。例えば、上流の開発者が lib-dependency という名前のリポジトリを、下流の libs/libdep という名前のサブモジュールとして .gitmodules に登録することができます。\n\n```\nsource=(\"git+https://example.org/main-project/main-project.git\"\n        \"git+https://example.org/lib-dependency/lib-dependency.git\")\n\nprepare() {\n  cd main-project\n  git submodule init\n  git config submodule.libs/libdep.url \"$srcdir/lib-dependency\"\n  git -c protocol.file.allow=always submodule update\n}\n```\n\n"
    }
  ]
}