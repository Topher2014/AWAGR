{
  "title": "Diretrizes de pacotes de aplicativos não livres",
  "url": "https://wiki.archlinux.org/title/Diretrizes_de_pacotes_de_aplicativos_n%C3%A3o_livres",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Fonte – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust – Shell – VCS – Web – Wine\n\nPara muitos aplicativos (a maioria dos quais são do Windows), não há fontes nem tarballs disponíveis. Muitos desses aplicativos não podem ser distribuídos livremente devido a restrições de licença e/ou falta de meios legais para obter o instalador sem cobrança de taxa. Tal software obviamente não pode ser incluído nos repositórios oficiais mas devido à natureza do AUR ainda é possível privadamente compilar pacotes para ele, gerenciável com pacman.\n\n"
    },
    {
      "title": "Motivo",
      "level": 2,
      "content": "Existem vários motivos para empacotar softwares não empacotáveis:\n\n- Simplificação de processo de instalação/remoção\n\n```\n$ chmod +x nome-de-arquivo\n```\n\n```\n$ chown root:root nome-de-arquivo\n```\n\n```\n# cp filename /usr/bin/\n```\n\n```\n$ makepkg -i\n```\n\n- Usando capacidades do pacman\n\n- Compartilhamento de código e conhecimento\n\n"
    },
    {
      "title": "Evite software não livre quando possível",
      "level": 3,
      "content": "Sim, é melhor deixar este guia e passar algum tempo procurando (ou talvez até criando) alternativas para um aplicativo que você queria empacotar porque:\n\n1. É melhor oferecer suporte a um software que pertence a todos nós do que um software que pertence a uma empresa\n1. É melhor oferecer suporte a um software que é mantido ativamente\n1. É melhor oferecer suporte a um software que pode ser consertado se apenas uma pessoa, em milhões, se importar o suficiente\n\n"
    },
    {
      "title": "Use variantes de código aberto quando possível",
      "level": 3,
      "content": "Muitos jogos comerciais (alguns estão listados neste Wiki) possuem mecanismos de código aberto e muitos jogos antigos podem ser reproduzidos com emuladores como ScummVM. O uso de mecanismos de software livre junto com os recursos originais do jogo oferece aos usuários acesso a correções de erros e elimina vários problemas causados por pacotes binários.\n\n"
    },
    {
      "title": "Mantenha simples",
      "level": 3,
      "content": "Se o empacotamento de algum programa exigir mais esforço e hacks do que comprar e usar a versão original - faça a coisa mais simples, isso é Arch!\n\n"
    },
    {
      "title": "Nomenclatura de pacotes",
      "level": 2,
      "content": "Antes de escolher um nome, pesquise no AUR as versões existentes do software que você deseja empacotar. Tente usar uma convenções de nomenclatura estabelecida (por exemplo, não crie algo como gish-hb quando já houverem pacotes para aquaria-hib, crayonphysicsdeluxe-hib e uplink-hib). Sempre use o sufixo -bin, a menos que você tenha certeza de que nunca haverá um pacote baseado em código-fonte – o criador do pacote teria que pedir a você (ou, no pior caso, um TUs) que tornasse órfão (isto é, abandonasse) o pacote existente para que ele e vocês dois acabarão com PKGBUILDs cheios de replaces e conflicts adicionais.\n\n"
    },
    {
      "title": "Colocação de arquivos",
      "level": 2,
      "content": "Novamente, analise os pacotes existentes (se houver) e decida se deseja ou não entrar em conflito com eles. Não coloque coisas em /opt, a menos que você queira usar alguns hacks feios como dar a propriedade root:games ao diretório do pacote (para que os usuários do grupo games o jogo pode gravar arquivos na própria pasta do jogo).\n\n"
    },
    {
      "title": "Arquivos em falta",
      "level": 2,
      "content": "Para a maioria dos jogos comerciais, não há como (legalmente) baixar arquivos de jogos, o que é a maneira preferida de obtê-los para pacotes normais. Mesmo quando é possível baixar arquivos após fornecer uma senha (como com todos os jogos do Humble Indie Bundle) solicitando ao usuário essa senha e fazendo o download em alguma parte da função build, não é recomendado por várias razões (por exemplo, o usuário pode não ter acesso à Internet, mas ter todos os arquivos baixados e armazenados localmente).\n\nAs subseções abaixo fornecem recomendações para algumas situações que você pode encontrar.\n\n"
    },
    {
      "title": "Os arquivos só podem ser obtidos em um pacote/instalador distribuído",
      "level": 3,
      "content": "O software só está disponível através desse arquivo de pacote/instalador, que deve ser obtido para obter os arquivos em falta.\n\nAdicione o pacote/instalador necessário a um vetor source, renomeando o nome do arquivo de origem para que o link da origem na interface web do AUR seja diferente dos nomes dos arquivos incluídos no tarball de origem:\n\n```\nsource=(... \"nomeoriginal::local://nomeoriginal\")\n```\n\nAdicione também um comentário fixado como o abaixo na página do pacote no AUR e explique os detalhes no PKGBUILD:\n\n```\nNeed archive/installer to work.\n```\n\n"
    },
    {
      "title": "Esquema a escolher",
      "level": 4,
      "content": "Caso você use o esquema local:// em um array de fontes, o makepkg se comporta como se nenhum esquema fosse especificado, e o arquivo deve ser colocado manualmente no mesmo diretório que o PKGBUILD.\n\nCaso você use o esquema file://, você pode adicionalmente especificar DLAGENTS para o protocolo file, de forma que ele pode ser obtido em uma forma especial. Veja os exemplos abaixo.\n\nPorém, ainda não há regras claras sobre quais esquemas você deve usar.\n\n"
    },
    {
      "title": "Os arquivos só podem ser obtidos em um CD distribuído ou outro tipo de mídia de disco ótico",
      "level": 3,
      "content": "O software só está disponível através de uma mídia de disco óptico (por exemplo, CD, DVD, Bluray, etc.), que deve ser inserido na unidade de disco ótico para obter os arquivos em falta.\n\nAdicione um script instalador e um arquivo .install ao conteúdo do pacote, como em tsukihime-enAUR[link quebrado: package not found].\n\n"
    },
    {
      "title": "Os arquivos podem ser obtidos de várias maneiras",
      "level": 3,
      "content": "Copiar arquivos do disco, fazer o download da internet ou sair do arquivo durante a fase build pode parecer uma boa ideia, mas não é recomendado porque limita as possibilidades do usuário e torna a instalação do pacote interativa (o que geralmente é desencorajado e irritante). Novamente, um bom script de instalação e um arquivo .install podem funcionar.\n\nAlguns exemplos de várias estratégias para obter arquivos necessários para o pacote:\n\n- worldofgooAUR – dependência em arquivo fornecido por usuário\n- umineko-enAUR[link quebrado: package not found] – combinando arquivos de patch livremente disponível e disco compacto fornecido por usuário\n- worldofgoo-demoAUR[link quebrado: package not found] – obtenção automática de instalação durante a fase de compilação\n- ut2004-anthologyAUR[link quebrado: package not found] – pesquisando por disco via pontos de montagem\n\n"
    },
    {
      "title": "DLAGENTS personalizados",
      "level": 3,
      "content": "Alguns autores de software protegem agressivamente seu software contra downloads automáticos: proíbem certas strings \"User-Agent\", criam links temporários para arquivos, etc. Você ainda pode convenientemente baixar estes arquivos usando a variável DLAGENTS no PKGBUILD (veja makepkg.conf(5)). Isto é usado por alguns pacotes em repositórios oficiais, por exemplo, em versões anteriores do ttf-baekmuk.\n\nPor favor, preste atenção, se você quiser ter uma string user-agent personalizada, se esta contiver espaços, parênteses ou barras (ou, na verdade, qualquer coisa que possa interromper a análise), isso não funcionará. Não há solução alternativa, essa é a natureza de vetores no bash e a maneira como o DLAGENTS foi projetado para ser usado no makepkg. O exemplo a seguir, portanto, não funciona:\n\n```\nDLAGENTS=(\"http::/usr/bin/curl -A 'Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)' -fLC - --retry 3 --retry-delay 3 -o %o %u\")\n```\n\nEncurte para o seguinte que está funcionando:\n\n```\nDLAGENTS=(\"http::/usr/bin/curl -A 'Mozilla' -fLC - --retry 3 --retry-delay 3 -o %o %u\")\n```\n\nE, a seguir, permita extrair link temporário para o arquivo da página de download:\n\n```\nDLAGENTS=(\"http::/usr/bin/wget -r -np -nd -H %u\")\n```\n\nPara baixar links temporários para arquivos ou passar por um download interativo, é possível analisar a solicitação HTTP usada para criar o link de download final e, em seguida, criar um DLAGENTS que emule isso usando o curl. Veja por exemplo blackmagic-decklink-sdkAUR[link quebrado: package not found] ou jlink-software-and-documentationAUR.\n\nAlternativamente, o DLAGENTS pode ser usado para fornecer uma mensagem de erro mais informativa ao usuário quando um arquivo está faltando. Veja, por exemplo, ttf-ms-win10AUR.\n\n"
    },
    {
      "title": "Desempacotamento",
      "level": 3,
      "content": "Muitos programas proprietários são publicados em instaladores desagradáveis que às vezes nem funcionam no Wine. As seguintes ferramentas podem ajudar:\n\n- unzip e unrar descompactam arquivos SFX executáveis, baseados nesses formatos\n- cabextract pode descompactar a maioria dos arquivos .cab (incluindo aqueles com extensão .exe)\n- unshield pode extrair arquivos CAB de instaladores do InstallShield\n- 7zip descompacta não apenas muitos formatos de arquivo, mas também NSIS - instaladores .exe ele pode até mesmo extrair seções únicas de arquivos comuns de PE (.exe e .dll)!\n- upx às vezes é usado para compactar os executáveis listados acima e também pode ser usado para descompactá-los\n- innoextract pode descompactar instaladores .exe criados com Inno Setup (usado, por exemplo, por jogos GOG.com)\n- libarchive contém bsdtar, que pode extrair imagens .iso e arquivos .AppImage (que na verdade são iso9660 híbridos autoexecutáveis)\n\n- ele pode até mesmo extrair seções únicas de arquivos comuns de PE (.exe e .dll)!\n\nPara determinar o tipo exato de arquivo, execute file arquivo_de_tipo_desconhecido.\n\n"
    },
    {
      "title": "Obtendo ícones para arquivos .desktop",
      "level": 3,
      "content": "O software proprietário geralmente não possui arquivos de ícone separados, portanto, não há nada para usar na criação de arquivos .desktop. Felizmente, .ico arquivos podem ser facilmente extraídos de executáveis com programas do pacote icoutils. Você pode até fazer isso durante a fase build, por exemplo:\n\n```\n$ wrestool -x --output=icon.ico -t14 executable.exe\n```\n\n"
    }
  ]
}