{
  "title": "Отредактируйте",
  "url": "https://wiki.archlinux.org/title/%D0%9E%D1%82%D1%80%D0%B5%D0%B4%D0%B0%D0%BA%D1%82%D0%B8%D1%80%D1%83%D0%B9%D1%82%D0%B5",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Systemd/Пользователь\n- Systemd/Таймеры\n- Systemd/Журнал\n- systemd/FAQ\n- init\n- Демоны\n- udev (Русский)\n- Improving performance/Boot process\n- Разрешить пользователям выключение системы\n\nЦитата с веб-страницы проекта:\n\n"
    },
    {
      "title": "Основы использования systemctl",
      "level": 2,
      "content": "Главная команда для работы с systemd — systemctl. Она позволяет (среди прочего) отлеживать состояние системы и управлять системой и службами. Подробнее см. systemctl(1).\n\n- Для управления systemd на удалённой машине команды необходимо выполнять с ключом -H пользователь@хост. Соединение с удалённым процессом systemd будет установлено через SSH.\n- В Plasma для systemctl разработан графический интерфейс systemd-kcmAUR[ссылка недействительна: package not found]. После установки соответствующий модуль появится в разделе System administration.\n\n"
    },
    {
      "title": "Использование юнитов",
      "level": 3,
      "content": "Юнитами могут быть, например, службы (.service), точки монтирования (.mount), устройства (.device) или сокеты (.socket).\n\nПри работе с systemctl обычно необходимо указывать полное имя юнита с суффиксом, например, sshd.socket. Существует несколько возможных сокращений:\n\n- Если суффикс не указан, systemctl предполагает, что это .service. Например, netctl равнозначно netctl.service.\n- Точки монтирования автоматически преобразуются в юнит .mount. Например, /home равнозначно home.mount.\n- Аналогично точкам монтрования, имена устройств автоматически преобразуются в юнит .device. Например, /dev/sda2 равнозначно dev-sda2.device.\n\nПодробнее см. systemd.unit(5).\n\nNote: Если говорить точнее, systemd сначала попытается найти юнит, название которого полностью совпадёт с название@строка.суффикс, и лишь в случае неудачи создаст экземпляр шаблона название@.суффикс. Тем не менее, такие \"конфликты\" довольно редки, так как по соглашению символ @ должен использоваться только в названиях юнитов-шаблонов. Также помните, что вызвать юнит-шаблон без идентификатора экземпляра не получится, поскольку в этом случае нечего будет подставить вместо спецификатора %i.\n\nЕсли говорить точнее, systemd сначала попытается найти юнит, название которого полностью совпадёт с название@строка.суффикс, и лишь в случае неудачи создаст экземпляр шаблона название@.суффикс. Тем не менее, такие \"конфликты\" довольно редки, так как по соглашению символ @ должен использоваться только в названиях юнитов-шаблонов. Также помните, что вызвать юнит-шаблон без идентификатора экземпляра не получится, поскольку в этом случае нечего будет подставить вместо спецификатора %i.\n\n- Большинство команд ниже также будут работать, если указать несколько юнитов; подробнее см. systemctl(1).\n- Опция --now в командах enable, disable и mask соответственно запускает, останавливает или маскировует указанный юнит сразу при выполнении команды, а не после перезагрузки.\n- Пакеты могут содержать собственные юниты для различных целей. Если вы только что установили пакет, выполните pacman -Qql название_пакета | grep -Fe .service -e .socket, чтобы их найти.\n\nTable content:\nДействие | Команда | Примечание\nАнализ состояния системы\nСостояние системы | $ systemctl status | \nСписок запущенных юнитов | $ systemctl или$ systemctl list-units | \nСписок юнитов, запустить которые не удалось | $ systemctl --failed | \nСписок установленных файлов юнитов1 | $ systemctl list-unit-files | \nИнформация о процессе по его PID | $ systemctl status pid | cgroup slice, занимаемая память и родительский процесс\nСостояние юнита\nСтраница руководства юнита | $ systemctl help юнит | если юнит её предоставляет\nСостояние юнита | $ systemctl status юнит | в т. ч. работает ли он в данный момент\nПроверить, добавлен ли юнит в автозапуск | $ systemctl is-enabled юнит | \nЗапуск, перезапуск, перезагрузка юнита\nНезамедлительно запустить юнит | # systemctl start юнит | \nНезамедлительно остановить юнит | # systemctl stop юнит | \nПерезапустить юнит | # systemctl restart юнит | \nПерезагрузить юнит с новыми настройками | # systemctl reload юнит | \nПерезагрузить настройки systemd2 | # systemctl daemon-reload | сканировать систему на наличие новых или изменённых юнитов\nВключение юнита (автозапуск)\nВключить юнит, добавив его в автозапуск | # systemctl enable юнит | \nВключить юнит и сразу запустить | # systemctl enable --now юнит | \nОтключить запуск юнита при загрузке | # systemctl disable юнит | \nВключить юнит заново3 | # systemctl reenable юнит | т.е. отключить и снова включить\nМаскировка юнита\nЗамаскировать юнит, сделав невозможным его запуск4 | # systemctl mask юнит | \nСнять маскировку юнита | # systemctl unmask юнит | \n\n1. В руководстве systemd.unit(5) § UNIT FILE LOAD PATH приведён перечень каталогов, в которых могут храниться файлы юнитов.\n1. Перезагружаются только настройки systemd, но не юнитов. Для юнитов необходимо использовать команду reload.\n1. Например, если раздел [Install] изменился с момента последнего включения.\n1. Как вручную, так и по зависимости, что делает маскировку несколько опасной.\n\n"
    },
    {
      "title": "Управление питанием",
      "level": 3,
      "content": "Для управления питанием от имени непривилегированного пользователя необходим polkit. Если вы находитесь в локальном пользовательском сеансе systemd-logind и нет других активных сеансов, приведенные ниже команды сработают, даже если будут выполнены не от root. В противном случае (например, другой пользователь вошел в систему через tty) systemd автоматически запросит у вас пароль суперпользователя.\n\nTable content:\nДействие | Команда\nЗавершить работу и перезагрузить систему | $ systemctl reboot\nЗавершить работу и выключить компьютер | $ systemctl poweroff\nПеревести систему в ждущий режим | $ systemctl suspend\nПеревести систему в спящий режим | $ systemctl hibernate\nПеревести систему в режим гибридного сна (suspend-to-both) | $ systemctl hybrid-sleep\n\n"
    },
    {
      "title": "Написание файлов юнитов",
      "level": 2,
      "content": "Синтаксис файлов юнитов systemd (см. systemd.unit(5)) вдохновлён desktop-файлами XDG Desktop Entry Specification, а они, в свою очередь, основаны на синтаксисе файлов .ini Microsoft Windows. Файлы юнитов загружаются из целого ряда мест (команда systemctl show --property=UnitPath выведет полный список), ключевыми из которых являются следующие (в порядке увеличения приоритета):\n\n- /usr/lib/systemd/system/: юниты, добавленные пакетами при установке;\n- /etc/systemd/system/: юниты, созданные системным администратором.\n\n- При запуске systemd в пользовательском режиме пути загрузки будут отличаться.\n- Названия юнитов могут содержать только буквы и цифры ASCII-набора, подчёркивания и точки. Другие символы должны быть экранированы в C-стиле (\"\\x2d\") или использоваться исключительно в рамках определённой семантики ('@', '-'). Подробнее см. systemd.unit(5) и systemd-escape(1).\n\nПри создании собственных юнитов за образец можно взять юниты установленных пакетов или примеры из systemd.service(5) § EXAMPLES.\n\n"
    },
    {
      "title": "Обработка зависимостей",
      "level": 3,
      "content": "В systemd зависимости определяются правильным построением файлов юнитов. Простой пример — юниту A требуется, чтобы юнит B был запущен перед запуском самого юнита A. Для этого добавьте строки Requires=B и After=B в раздел [Unit] юнит-файла A. Если зависимость является необязательной, укажите Wants=B и After=B соответственно. Обратите внимание, что Wants= и Requires= не подразумевают After=. Если After= не указать, то юниты будут запущены параллельно.\n\nЗависимости обычно указываются для служб, но не для целей. Так, цель network.target будет \"подтянута\" ещё на этапе настройки сетевых интерфейсов одной из соответствующих служб, и можно спокойно указывать эту цель как зависимость в пользовательской службе, поскольку network.target будет запущена в любом случае.\n\n"
    },
    {
      "title": "Типы служб",
      "level": 3,
      "content": "Службы различаются по типу запуска, и это следует учитывать при написании юнитов. Тип определяется параметром Type= в разделе [Service]:\n\n- Type=simple (по умолчанию): systemd запустит эту службу незамедлительно. Процесс при этом не должен разветвляться (fork). Если после данной службы должны запускаться другие, то этот тип использовать не стоит (исключение — служба использует сокетную активацию).\n- Type=forking: systemd считает службу запущенной после того, как процесс разветвляется с завершением родительского процесса. Используется для запуска классических демонов за исключением тех случаев, когда в таком поведении процесса нет необходимости. Укажите параметр PIDFile=, чтобы systemd мог отслеживать основной процесс.\n- Type=oneshot: удобен для сценариев, которые выполняют одно задание и завершаются. Если задать параметр RemainAfterExit=yes, то systemd будет считать процесс активным даже после его завершения.\n- Type=notify: идентичен параметру Type=simple, но с уточнением, что демон пошлет systemd сигнал готовности. Реализация уведомления находится в библиотеке libsystemd-daemon.so.\n- Type=dbus: служба считается находящейся в состоянии готовности после появления указанного BusName в системной шине DBus.\n- Type=idle: systemd отложит выполнение двоичного файла службы до окончания запуска остальных (\"более срочных\") задач. В остальном поведение аналогично Type=simple.\n\nПодробнее о параметре Type см. systemd.service(5) § OPTIONS.\n\n"
    },
    {
      "title": "Редактирование файлов юнитов",
      "level": 3,
      "content": "Не стоит редактировать юнит-файлы пакетов напрямую, так как это приведёт к конфликтам с pacman. Есть два безопасных способа редактирования: создать новый файл, который полностью заменит оригинальный, или создать drop-in файл, который будет применяться поверх оригинального юнита. В обоих случаях после редактирования необходимо перезагрузить юнит, чтобы изменения вступили в силу. Это выполняется либо путем редактирования блока с помощью команды systemctl edit, которая автоматически перезагружает юнит, либо перезагрузкой всех юнитов командой:\n\n```\n# systemctl daemon-reload\n```\n\n- С помощью systemd-delta можно узнать, какие файлы юнитов были переопределены и что конкретно было изменено.\n- Команда systemctl cat юнит позволит просмотреть содержимое файла юнита и связанных с ним drop-in сниппетов.\n\n"
    },
    {
      "title": "Замещение файла юнита",
      "level": 4,
      "content": "Чтобы полностью заместить файл юнита /usr/lib/systemd/system/юнит, создайте файл с таким же именем /etc/systemd/system/юнит и включите заново юнит для обновления символических ссылок.\n\nАльтернативный способ:\n\n```\n# systemctl edit --full юнит\n```\n\nЭта команда откроет файл /etc/systemd/system/юнит в текстовом редакторе (если файл ещё не существует, будет скопирован оригинал) и автоматически перезагрузит юнит после завершения редактирования.\n\n"
    },
    {
      "title": "Drop-in файлы",
      "level": 4,
      "content": "Чтобы создать drop-in файл для /usr/lib/systemd/system/юнит, создайте каталог /etc/systemd/system/юнит.d/ и поместите в него файлы .conf с добавленными или изменёнными опциями. systemd будет анализировать эти файлы и применять их поверх оригинального юнита.\n\nСамый простой способ — использовать команду:\n\n```\n# systemctl edit юнит\n```\n\nКоманда откроет /etc/systemd/system/юнит.d/override.conf в текстовом редакторе (файл будет создан, если его ещё нет) и автоматически перезапустит юнит после завершения редактирования.\n\n"
    },
    {
      "title": "Откат изменений",
      "level": 4,
      "content": "Отменить все изменения, сделанные с помощью systemctl edit, можно командой:\n\n```\n# systemctl revert юнит\n```\n\n"
    },
    {
      "title": "Примеры",
      "level": 4,
      "content": "Например, если вы просто хотите добавить дополнительную зависимость к юниту, можно создать следующий файл:\n\n```\n/etc/systemd/system/юнит.d/customdependency.conf\n```\n\n```\n[Unit]\nRequires=новая зависимость\nAfter=новая зависимость\n```\n\nДругой пример: для замены ExecStart в юните (кроме типа oneshot) создайте следующий файл:\n\n```\n/etc/systemd/system/юнит.d/customexec.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=новая команда\n```\n\nОбратите внимание, что ExecStart необходимо очистить перед присвоением нового значения [1]. Это относится ко всем параметрам, которые позволяют прописать несколько значений, вроде OnCalendar в таймерах.\n\nПример настройки автоматического перезапуска службы:\n\n```\n/etc/systemd/system/юнит.d/restart.conf\n```\n\n```\n[Service]\nRestart=always\nRestartSec=30\n```\n\n"
    },
    {
      "title": "Цели",
      "level": 2,
      "content": "Systemd использует юнит типа цель (target) для группировки юнитов по зависимостям и в качестве стандартизированных точек синхронизации. Они выполняют ту же задачу, что и уровни запуска, но действуют немного по-другому. Каждая цель имеет имя, а не номер, и предназначена для конкретных задач; несколько целей могут быть активны одновременно. Некоторые цели реализованы путём наследования служб из других целей с добавлением собственных. В systemd также имеются цели, имитирующие общие уровни запуска SystemVinit, поэтому вы можете переключаться между целями, используя привычную команду telinit RUNLEVEL.\n\n"
    },
    {
      "title": "Получение информации о текущих целях",
      "level": 3,
      "content": "В systemd для этого предназначена следующая команда (заменяющая runlevel):\n\n```\n$ systemctl list-units --type=target\n```\n\n"
    },
    {
      "title": "Создание пользовательской цели",
      "level": 3,
      "content": "Уровни запуска, имеющие определённое значение в sysvinit (0, 1, 3, 5 и 6), один в один соответствуют конкретным целям systemd. К сожалению, не существует хорошего способа сделать то же самое для пользовательских уровней 2 и 4. Их использование предполагает, что вы создаёте новый юнит-цель с названием /etc/systemd/system/цель, который берет за основу один из существующих уровней запуска (взгляните, например, на /usr/lib/systemd/system/graphical.target), создаёте каталог /etc/systemd/system/цель.wants, а после этого — символические ссылки на те службы из каталога /usr/lib/systemd/system/, которые вы хотите включить при загрузке.\n\n"
    },
    {
      "title": "Соответствие уровней SysV целям systemd",
      "level": 3,
      "content": "Table content:\nУровнень запуска SysV | Цель systemd | Примечания\n0 | runlevel0.target, poweroff.target | Выключение системы\n1, s, single | runlevel1.target, rescue.target | Однопользовательский уровень запуска\n2, 4 | runlevel2.target, runlevel4.target, multi-user.target | Уровни запуска, определенные пользователем/специфичные для узла. По умолчанию соответствует уровню запуска 3\n3 | runlevel3.target, multi-user.target | Многопользовательский режим без графики. Пользователи, как правило, входят в систему при помощи множества консолей или через сеть\n5 | runlevel5.target, graphical.target | Многопользовательский режим с графикой. Обычно эквивалентен запуску всех служб на уровне 3 и графического менеджера входа в систему\n6 | runlevel6.target, reboot.target | Перезагрузка\nemergency | emergency.target | Аварийная оболочка\n\n"
    },
    {
      "title": "Изменение текущей цели",
      "level": 3,
      "content": "В systemd цели доступны посредством целевых юнитов. Вы можете переключать их такой командой:\n\n```\n# systemctl isolate graphical.target\n```\n\nДанная команда только изменит текущую цель и не повлияет на следующую загрузку системы. Она соответствует командам Sysvinit вида telinit 3 и telinit 5.\n\n"
    },
    {
      "title": "Изменение цели загрузки по умолчанию",
      "level": 3,
      "content": "Стандартная цель — default.target, которая по умолчанию ссылается на graphical.target (примерно соответствующего прежнему уровню запуска 5).\n\nУзнать текущую цель можно так:\n\n```\n$ systemctl get-default\n```\n\nДля установки новой цели загрузки по умолчанию измените ссылку default.target. С помощью команды systemctl это делается так:\n\n```\n# systemctl set-default multi-user.target\n```\n\n```\nRemoved /etc/systemd/system/default.target.\nCreated symlink /etc/systemd/system/default.target -> /usr/lib/systemd/system/multi-user.target.\n```\n\nАльтернативный способ — добавить один из следующих параметров ядра в загрузчик:\n\n- systemd.unit=multi-user.target (что примерно соответствует прежнему уровню запуска 3).\n- systemd.unit=rescue.target (что примерно соответствует прежнему уровню запуска 1).\n\n"
    },
    {
      "title": "Порядок выбора цели по умолчанию",
      "level": 3,
      "content": "systemd выбирает default.target в следующем порядке :\n\n1. Параметр ядра, описанный выше.\n1. Символическая ссылка /etc/systemd/system/default.target.\n1. Символическая ссылка /usr/lib/systemd/system/default.target.\n\n"
    },
    {
      "title": "Компоненты systemd",
      "level": 2,
      "content": "Некоторые (не все) составные части systemd:\n\n- systemd-boot — простой менеджер загрузки для UEFI;\n- systemd-firstboot — инициализация системных настроек при первой загрузке;\n- systemd-homed — переносимые аккаунты пользователей;\n- systemd-logind — управление сеансами;\n- systemd-networkd — управление сетевыми настройками;\n- systemd-nspawn — приложение для контейнеризации процессов;\n- systemd-resolved — разрешение сетевых имён;\n- systemd-sysusers(8) — создание системных пользователей/групп и добавление пользователей в группы при установке пакетов и загрузке системы;\n- systemd-timesyncd — синхронизация системных часов по сети;\n- systemd/Журнал — системные логи;\n- systemd/Таймеры — таймеры для управления событиями и службами, альтернатива cron.\n\n"
    },
    {
      "title": "systemd.mount — монтирование",
      "level": 3,
      "content": "systemd полностью отвечает за монтирование разделов и файловых систем, описанных в файле /etc/fstab. systemd-fstab-generator(8) преобразует записи из /etc/fstab в юниты systemd; это выполняется при каждой загрузке системы, а также при перезагрузке конфигурации системного менеджера.\n\nsystemd расширяет возможности fstab и предлагает дополнительные опции монтирования. Они могут влиять на зависимости юнита монтирования: например, могут гарантировать, что монтирование выполняется только после подключения к сети или после монтирования другого раздела. Полный список опций монтирования systemd (обычно они имеют префикс x-systemd) описан в systemd.mount(5) § FSTAB.\n\nПримером этих опций может быть т.н. автомонтирование (здесь имеется в виду не автоматическое монтирование во время загрузки, а монтирование при появлении запроса от устройства). Подробнее смотрите fstab#Автоматическое монтирование с systemd.\n\n"
    },
    {
      "title": "Автомонтирование GPT-раздела",
      "level": 4,
      "content": "На UEFI-системах systemd-gpt-auto-generator(8) автоматически монтирует GPT-разделы в соответствии с Discoverable Partitions Specification, поэтому их можно не указывать в файле fstab.\n\nТребования:\n\n- Загрузчик должен установить EFI-переменную LoaderDevicePartUUID, по которой можно будет определить системный раздел EFI. Эта возможность поддерживается в systemd-boot, а также в rEFInd (по умолчанию отключена). Это проверяется наличием строки Boot loader sets ESP partition information в выводе команды bootctl.\n- Корневой раздел должен быть на одном физическом диске с системным разделом EFI. Автомонтируемые разделы должны быть на одном физическом диске с корневым разделом. Очевидно, монтируемые разделы должны оказаться на одном диске и с ESP.\n\nДля автомонтирования раздела /var его PARTUUID должен совпадать с хэш-суммой SHA256 HMAC, вычисленной на основании UUID типа раздела. В качестве ключа хэша используется machine ID. Необходимый PARTUUID можно получить командой:\n\n```\n$ systemd-id128 -u --app-specific=4d21b016-b534-45c2-a9fb-5c16e091fd2d machine-id\n```\n\n"
    },
    {
      "title": "systemd-sysvcompat",
      "level": 3,
      "content": "Пакет systemd-sysvcompat (зависимость пакета base) содержит традиционный бинарный файл init. В системах под управлением systemd init — символическая ссылка на исполняемый файл systemd.\n\nКроме того, в этом пакете находятся 4 команды SysVinit — halt(8), poweroff(8), reboot(8) и shutdown(8). Это символические ссылки на systemctl, и их работа обусловлена логикой systemd. Подробнее см. #Управление питанием.\n\nВ systemd-системах отказаться от совместимости с System V можно либо задав параметр загрузки init= (см. BBS#233387), либо с помощью собственных аргументов команды systemctl.\n\n"
    },
    {
      "title": "systemd-tmpfiles — временные файлы",
      "level": 3,
      "content": "Утилита systemd-tmpfiles создает, удаляет и очищает непостоянные и временные файлы и каталоги. Она читает конфигурационные файлы из /etc/tmpfiles.d/ и /usr/lib/tmpfiles.d/, чтобы понять, что необходимо делать. Конфигурационные файлы в первом каталоге имеют приоритет над теми, что расположены во втором.\n\nКонфигурационные файлы обычно предоставляются вместе с файлами служб и имеют названия вида /usr/lib/tmpfiles.d/программа.conf. Например, демон Samba предполагает, что существует каталог /run/samba с корректными правами доступа. Поэтому пакет samba поставляется в следующей конфигурации:\n\n```\n/usr/lib/tmpfiles.d/samba.conf\n```\n\n```\nD /run/samba 0755 root root\n```\n\nКонфигурационные файлы также могут использоваться для записи значений при старте системы. Например, если вы используете /etc/rc.local для отключения пробуждения от устройств USB при помощи echo USBE > /proc/acpi/wakeup, вместо этого вы можете использовать следующий tmpfile:\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Path                  Mode UID  GID  Age Argument\nw    /proc/acpi/wakeup     -    -    -    -   USBE\n```\n\nПодробнее смотрите systemd-tmpfiles(8) и tmpfiles.d(5).\n\n"
    },
    {
      "title": "Программы настройки с графическим интерфейсом",
      "level": 3,
      "content": "- systemadm — Графический поисковик юнитов systemd. Выводит список юнитов, возможна фильтрация по типу.\n\n- SystemdGenie — Утилита управления systemd на основе инструментов KDE.\n\n"
    },
    {
      "title": "Запуск сервисов после подключения к сети",
      "level": 3,
      "content": "Чтобы запустить сервис только после подключения к сети, добавьте такие зависимости в .service файле:\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target\n...\n```\n\nТакже должна быть включена служба ожидания сети того приложения, которое управляет сетью; только тогда network-online.target будет соответствовать состоянию сети.\n\n- В NetworkManager служба NetworkManager-wait-online.service включается вместе с NetworkManager.service. Проверить состояние службы можно командой systemctl is-enabled NetworkManager-wait-online.service. Если служба не включена, то включите заново NetworkManager.service ещё раз.\n- В случае netctl включите службу netctl-wait-online.service.\n- Для пользователей systemd-networkd юнит systemd-networkd-wait-online.service включается вместе со службой systemd-networkd.service; проверьте это командой systemctl is-enabled systemd-networkd-wait-online.service. Если нет, то включите заново systemd-networkd.service.\n\nПодробнее можно почитать: Network configuration synchronization points.\n\nЕсли служба отправляет DNS-запросы, она должна запускаться также после nss-lookup.target:\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target nss-lookup.target\n...\n```\n\nПодробнее см. systemd.special(7).\n\nЧтобы цель nss-lookup.target работала как положено, должна быть служба, которая запускает её параметром Wants=nss-lookup.target и размещает себя перед ней (Before=nss-lookup.target). Обычно это выполняет локальный DNS-распознаватель.\n\nЧтобы узнать, какие службы зависят от nss-lookup.target, выполните:\n\n```\n$ systemctl list-dependencies --reverse nss-lookup.target\n```\n\n"
    },
    {
      "title": "Включение установленных юнитов по умолчанию",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nArch Linux поставляется с файлом /usr/lib/systemd/system-preset/99-default.preset, в котором указан параметр disable *. Это означает, что systemctl preset отключает по умолчанию юниты и пользователь должен сам их включать после установки пакетов.\n\nЕсли такое поведение не устраивает, создайте символическую ссылку /etc/systemd/system-preset/99-default.preset на /dev/null для переопределения файла конфигурации. Это заставит systemctl preset включать юниты новых пакетов — вне зависимости от типа — кроме указанных в других файлах из каталога настроек systemctl preset. Пользовательских юнитов это не касается. Подробнее смотрите systemd.preset(5).\n\n"
    },
    {
      "title": "Песочница для приложений",
      "level": 3,
      "content": "Юнит может быть использован в качестве песочницы для изоляции приложений и их процессов в виртуальном окружении. Systemd использует механизм namespaces, белые и чёрные списки capabilities, а также control groups для контейнеризации процессов при помощи настраиваемых окружений — см. systemd.exec(5).\n\nДобавление к существующему юниту systemd функциональности песочницы обычно происходит методом проб и ошибок вкупе с использованием различных инструментов логирования — strace, stderr и journalctl(1). В таких случаях имеет смысл предварительно поискать соответствующую документацию от разработчиков. В качестве отправной точки для поиска путей повышения безопасности изучите вывод команды:\n\n```\n$ systemd-analyze security юнит\n```\n\nРекомендации по созданию песочницы с помощью systemd:\n\n- Параметр CapabilityBoundingSet определяет список разрешённых capabilities, но с его помощью можно также и запрещать некоторые capabilities для определённого юнита. Например, можно задать capability CAP_SYS_ADM, необходимую для создания безопасной песочницы: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n- Например, можно задать capability CAP_SYS_ADM, необходимую для создания безопасной песочницы: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n"
    },
    {
      "title": "Уведомление о неработающих службах",
      "level": 3,
      "content": "Для уведомления о неудачном запуске службы используется директива OnFailure= в соответствующем файле службы или drop-in файле. Чтобы эта директива возымела эффект для всех служб одновременно, её необходимо добавть в drop-in файл верхнего уровня, см. systemd.unit(5).\n\nСоздайте drop-in верхнего уровня:\n\n```\n/etc/systemd/system/service.d/toplevel-override.conf\n```\n\n```\n[Unit]\nOnFailure=failure-notification@%n\n```\n\nЭто добавит строку OnFailure=failure-notification@%n в файл каждой службы. Если какой-то_юнит завершится с ошибкой, запустится экземпляр службы failure-notification@какой-то_юнит для создания уведомления (или любой другой задачи, которая была назначена).\n\nСоздайте юнит-шаблон failure-notification@:\n\n```\n/etc/systemd/system/failure-notification@.service\n```\n\n```\n[Unit]\nDescription=Send a notification about a failed systemd unit\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=/путь/к/failure-notification.sh %i\n```\n\nПосле этого создайте сценарий failure-notification.sh, в котором определите, каким именно способом будет создаваться уведомление (mail, gotify, xmpp). Параметр %i будет заменён на название неудачно завершившегося юнита и будет передан сценарию в качестве аргумента.\n\nЧтобы предотвратить регрессию экземпляров failure-notification@.service, создайте пустой файл drop-in настроек с именем, совпадающим с названием drop-in файла верхнего уровня (пустой файл \"уровня служб\" будет иметь приоритет над файлом \"верхнего уровня\"):\n\n```\n# mkdir -p /etc/systemd/system/failure-notification@.service.d\n# touch /etc/systemd/system/failure-notification@.service.d/toplevel-override.conf\n```\n\n"
    },
    {
      "title": "Неудачно запущенные службы",
      "level": 3,
      "content": "Следующая команда найдёт все службы, которые не смогли выполнить запуск:\n\n```\n$ systemctl --state=failed\n```\n\nЧтобы определить причину, по которой служба не запустилась, необходимо изучить записи её логов. Подробнее см. systemd/Журнал#Фильтрация вывода.\n\n"
    },
    {
      "title": "Диагностика загрузки системы",
      "level": 3,
      "content": "В systemd есть несколько опций для диагностики проблем процесса загрузки. В статье об отладке загрузки описано, как получить доступ к сообщениям, выданным процессом загрузки до того, как systemd перехватил управление. Также смотрите документацию по отладке systemd.\n\n"
    },
    {
      "title": "Диагностика службы",
      "level": 3,
      "content": "Если какая-либо служба systemd ведет себя не так, как ожидается, и вы хотите получить дополнительную информацию о том, что происходит, присвойте переменной окружения SYSTEMD_LOG_LEVEL значение debug. Например, чтобы запустить демон systemd-networkd в режиме отладки:\n\nДобавьте drop-in файл для службы:\n\n```\n[Service]\nEnvironment=SYSTEMD_LOG_LEVEL=debug\n```\n\nИли, как вариант, пропишите переменную окружения вручную:\n\n```\n# SYSTEMD_LOG_LEVEL=debug /lib/systemd/systemd-networkd\n```\n\nПосле этого перезапустите systemd-networkd и следите за журналом службы с помощью опции -f/--follow.\n\n"
    },
    {
      "title": "Выключение/перезагрузка происходят ужасно долго",
      "level": 3,
      "content": "Если процесс выключения занимает очень долгое время (или выглядит зависшим), то, вероятно, виновата служба, которая не может завершить свою работу. Systemd ожидает некоторое время, пока каждая служба прекратит работу самостоятельно, и только потом пробует завершить её принудительно. Если вы столкнулись с такой проблемой, обратитесь к Shutdown completes eventually в systemd-вики.\n\n"
    },
    {
      "title": "По-видимому, процессы с кратким сроком жизни не оставляют записей в логах",
      "level": 3,
      "content": "Если команда journalctl -u foounit не даёт вывода для службы с коротким сроком жизни, вместо названия службы используйте её PID. Например, если загрузка службы systemd-modules-load.service завершилась неудачно и команда systemctl status systemd-modules-load показывает, что она была запущена с PID 123, то вы сможете посмотреть вывод процесса в журнале под данным PID, то есть командой journalctl -b _PID=123. Поля метаданных для журнала вроде _SYSTEMD_UNIT и _COMM собираются асинхронно и полагаются на каталог /proc в случае с действующими процессами. Для решения проблемы требуется внести исправления в ядро, чтобы эти данные можно было собирать через сокет, наподобие SCM_CREDENTIALS. В общем, это баг. Имейте в виду, что быстро падающие службы могут не успеть оставить сообщения в журнале из-за особенностей systemd.\n\n"
    },
    {
      "title": "Время загрузки системы увеличивается с течением времени",
      "level": 3,
      "content": "После использования systemd-analyze некоторые пользователи заметили, что время загрузки системы значительно увеличилось. После использования systemd-analyze blame NetworkManager запускался необычно долго.\n\nПроблема связана с тем, что файл /var/log/journal стал слишком большим. При этом также может уменьшаться скорость работы других команд, например, systemctl status или journalctl. Для решения проблемы можно удалить все файлы из каталога журнала (в идеале — сделав где-нибудь резервные копии, хотя бы временно), а затем ограничить размер журнала.\n\n"
    },
    {
      "title": "systemd-tmpfiles-setup.service не запускается во время загрузки",
      "level": 3,
      "content": "Начиная с версии Systemd 219, /usr/lib/tmpfiles.d/systemd.conf определяет ACL-атрибуты для каталогов в /var/log/journal и, следовательно, требует включённой поддержки ACL для той файловой системы, в которой находится журнал.\n\n"
    },
    {
      "title": "Отключение emergency mode на удалённой машине",
      "level": 3,
      "content": "Вам может понадобиться отключить emergency mode на удалённой машине, например на виртуальных машинах Azure или Google Cloud. Это связано с тем, что в случае ухода системы в emergency mode она отключится от сети и лишит вас возможности подключения к ней.\n\nДля отключения этого режима замаскируйте emergency.service и emergency.target.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Wikipedia:ru:systemd\n- Официальный веб-сайт (англ.) Оптимизации systemd systemd FAQ systemd Советы и трюки\n- systemd(1)\n- Другие дистрибутивы Gentoo:Systemd Fedora:Systemd Fedora:How to debug Systemd problems — отладка systemd. Fedora:SysVinit to Systemd Cheatsheet — памятка по переходу с SysVinit на systemd. Debian:systemd\n- Блог Lennart'а (англ.), update 1, update 2, update 3, Why systemd?\n- Debug Systemd Services — отладка юнитов systemd.\n- systemd для администраторов (PDF) - перевод цикла статей Леннарта Поттеринга (Lennart Poettering)\n- How To Use Systemctl to Manage Systemd Services and Units\n- Session management with systemd-logind\n- Emacs Syntax highlighting for Systemd files (англ.)\n- часть 1 и часть 2 вводной статьи в журнале The H Open (англ.)\n\n- Оптимизации systemd\n- systemd FAQ\n- systemd Советы и трюки\n\n- Gentoo:Systemd\n- Fedora:Systemd\n- Fedora:How to debug Systemd problems — отладка systemd.\n- Fedora:SysVinit to Systemd Cheatsheet — памятка по переходу с SysVinit на systemd.\n- Debian:systemd\n\n"
    }
  ]
}