{
  "title": "Systemd/Timers (日本語)",
  "url": "https://wiki.archlinux.org/title/Systemd/Timers_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- systemd\n- systemd/ユーザー\n- systemd FAQ\n- cron\n\nタイマーは名前が .timer で終わる systemd のユニットファイルであり、.service ファイルやイベントを制御します。cron の代わりとしてタイマーを使うことができます (#cron を置き換える を読んで下さい)。タイマーにはカレンダー時刻のイベントとモノトニック時刻のイベントのサポートが入っており、さらに非同期に実行することも可能です。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 タイマーユニット\n- 2 サービスユニット\n- 3 管理\n- 4 サンプル 4.1 モノトニックタイマー 4.2 リアルタイムタイマー\n- 5 一時的な .timer ユニット\n- 6 cron を置き換える 6.1 メリット 6.2 注意事項 6.3 MAILTO 6.4 crontab を使用する 6.5 手動で行う\n- 7 \"有効期間\" の処理\n- 8 参照\n\n- 4.1 モノトニックタイマー\n- 4.2 リアルタイムタイマー\n\n- 6.1 メリット\n- 6.2 注意事項\n- 6.3 MAILTO\n- 6.4 crontab を使用する\n- 6.5 手動で行う\n\n"
    },
    {
      "title": "タイマーユニット",
      "level": 2,
      "content": "タイマーは拡張子が .timer の systemd のユニットファイルです。他の ユニット設定ファイル と似ていますが特別に [Timer] セクションが存在します。[Timer] セクションにはタイマーが作動する時間と処理を定義します。タイマーには2つのタイプがあり、どちらか一つを使って定義されます:\n\n- モノトニックタイマー は刻々と変わる開始点と相応したタイムスパンの後に作動します。様々なモノトニックタイマーが存在しますがどれも次のような形式です: OnTypeSec= OnBootSec と OnActiveSec は全てのモノトニックタイマーで共通です。\n- リアルタイムタイマー (別名ウォールクロックタイマー) は (cron のジョブと同じように) カレンダーイベントにあわせて作動します。OnCalendar= オプションを使って定義を行います。\n\nタイマーのオプションについては systemd.timer(5) の man ページ で説明されています。カレンダーイベントやタイムスパンの引数構文については systemd.time(7) の man ページ で説明されています。\n\n"
    },
    {
      "title": "サービスユニット",
      "level": 2,
      "content": "それぞれの .timer ファイルには、対応する .service ファイルが存在します (例: foo.timer と foo.service)。.timer ファイルは .service ファイルを作動・制御します。.service に [Install] セクションは必要ありません。有効にするのは timer ユニットだからです。必要ならば、タイマーの [Timer] セクションで Unit= オプションを使うことで別の名前のユニットを制御することもできます。\n\n"
    },
    {
      "title": "管理",
      "level": 2,
      "content": "timer ユニットを使用するには、他のユニットと同じように有効化・起動します。起動しているタイマーを全て表示するには、次を実行:\n\n```\n$ systemctl list-timers\n```\n\n```\nNEXT                          LEFT        LAST                          PASSED     UNIT                         ACTIVATES\nThu 2014-07-10 19:37:03 CEST  11h left    Wed 2014-07-09 19:37:03 CEST  12h ago    systemd-tmpfiles-clean.timer systemd-tmpfiles-clean.service\nFri 2014-07-11 00:00:00 CEST  15h left    Thu 2014-07-10 00:00:13 CEST  8h ago     logrotate.timer              logrotate.service\n```\n\n- (有効でないタイマーも含めて) 全てのタイマーを確認したい場合、systemctl list-timers --all を使って下さい。\n- タイマーによって実行するサービスの状態は、今現在作動しているのでない限り、inactive になります。\n- タイマーがズレる場合は、/var/lib/systemd/timers もしくは ~/.local/share/systemd/ にある stamp-* ファイルを削除してみてください。stamp ファイルはタイマーが実行された最後の時刻を記録しており、ファイルを削除することでタイマーの次の作動時に systemd が再構成を行います。\n\n"
    },
    {
      "title": "サンプル",
      "level": 2,
      "content": "タイマーを使用してサービスを実行するのにあたって、service ユニットファイルに変更を加える必要はありません。以下の例では foo.timer という名前のタイマーを使って foo.service を定期的に実行します。\n\n"
    },
    {
      "title": "モノトニックタイマー",
      "level": 3,
      "content": "起動15分後に実行され、システムが起動している間、一週間ごとに再度実行されるタイマー:\n\n```\n/etc/systemd/system/foo.timer\n```\n\n```\n[Unit]\nDescription=Run foo weekly and on boot\n\n[Timer]\nOnBootSec=15min\nOnUnitActiveSec=1w \n\n[Install]\nWantedBy=timers.target\n```\n\n"
    },
    {
      "title": "リアルタイムタイマー",
      "level": 3,
      "content": "一週間ごとに起動するタイマー (月曜日の午前12:00に実行)。システムの電源が切られていたなどの理由で、最後の起動時間を過ぎていた場合、すぐに実行されます (Persistent=true オプション):\n\n```\n/etc/systemd/system/foo.timer\n```\n\n```\n[Unit]\nDescription=Run foo weekly\n\n[Timer]\nOnCalendar=weekly\nPersistent=true     \n \n[Install]\nWantedBy=timers.target\n```\n\nもっと細かく日時を指定する必要がある場合、次の形式で OnCalendar イベントを制御できます: DayOfWeek Year-Month-Day Hour:Minute:Second。アスタリスクをワイルドカードとして使うことができ、カンマで複数の日時を指定することができます。値を .. で区切ることで連続的に日程を指定することも可能です。\n\n例えば、以下の場合、毎月の1日から4日まで、月曜日か火曜日の場合にのみ、午後0時にサービスを実行します:\n\n```\nOnCalendar=Mon,Tue *-*-01..04 12:00:00\n```\n\n毎月第1土曜日にサービスを実行したい場合は以下のようになります:\n\n```\nOnCalendar=Sat *-*-1..7 18:00:00\n```\n\n毎朝4時に実行したい場合は以下のようになります:\n\n```\nOnCalendar=*-*-* 4:00:00\n```\n\nOnCalendar は複数指定でき、複数の異なるタイミングでサービスを実行できます。次の例では、平日の22:30および土日の20:00に実行されます:\n\n```\nOnCalendar=Mon..Fri 22:30\nOnCalendar=Sat,Sun 20:00\n```\n\nディレクティブの最後にタイムゾーンを指定することもできます (受け入れられる値をリストするには、timedatectl list-timezones を使用します。)\n\n```\nOnCalendar=*-*-* 02:00:00 Europe/Paris\n```\n\n詳しくは systemd.time(7) を見てください。\n\n- OnCalendar の日時の指定方法は systemd-analyze ユーティリティの calendar オプションを使用することでテストすることができます。タイマーユニットで使用したときに次に実行される日時も確認できます。例えば、systemd-analyze calendar weekly や systemd-analyze calendar \"Mon,Tue *-*-01..04 12:00:00\" のようにコマンドを実行することでテストできます。\n- libfaketime でインストールできる faketime コマンドを使うと、これらのコマンドを使ったいろいろなシナリオをテストするのに便利です。\n- daily や weekly などの特殊なイベントの表現は特定の起動時間を示しているため、同じカレンダーイベントが設定されているタイマーがあった場合、同時に起動します。そのようなことが発生すると、タイマーのサービスがシステムリソースを取り合って、システムパフォーマンスが落ち込む可能性があります。このような問題は RandomizedDelaySec オプションを使用してタイマーの起動時間を散らすことで解決できます。systemd.timer(5) を参照してください。\n- AccuracySec のデフォルト値 1m の不正確さを避けるために、オプション AccuracySec=1us を [Timer] セクションに追加します。systemd.timer(5) も参照してください。\n- 一部のオプション (WakeSystem) は、特定のシステム機能を必要とし、タイマーの開始を妨げる場合があり、その結果、次のエラーメッセージが表示されます: \"Failed to enter waiting state: Operation not supported\" そして \"Failed with result 'resources'.\"\n\n"
    },
    {
      "title": "一時的な .timer ユニット",
      "level": 2,
      "content": "systemd-run を使うことで一時的な .timer ユニットを作ることができます。サービスファイルを作成しなくても、特定時刻にコマンドが実行されるように設定することが可能です。例えば、以下のコマンドは30秒後にファイルを作成します:\n\n```\n# systemd-run --on-active=30 /bin/touch /tmp/foo\n```\n\nタイマーファイルが存在しない既存のサービスファイルを指定することもできます。例えば、以下のコマンドは12.5時間後に someunit.service という名前の systemd ユニットを起動します:\n\n```\n# systemd-run --on-active=\"12h 30m\" --unit someunit.service\n```\n\n詳しくは systemd-run(1) を見てください。\n\n"
    },
    {
      "title": "cron を置き換える",
      "level": 2,
      "content": "おそらく一番有名なジョブスケジューラは cron ですが、systemd のタイマーはその代替手段になりえます。\n\n"
    },
    {
      "title": "メリット",
      "level": 3,
      "content": "タイマーを使う主要なメリットは、それぞれのジョブが固有の systemd サービスを使うというところに根ざします。そのメリットには以下のようなものがあります:\n\n- タイマーとは別個にジョブを実行することが簡単にできます。これによってデバッグが楽になります。\n- 特定の環境で動作するようにジョブを設定することができます (systemd.exec(5) man ページを参照)。\n- ジョブを cgroups の支配下に置けます。\n- 他の systemd ユニットに依存するようにジョブを設定できます。\n- systemd の journal でジョブが記録されるのでデバッグが簡単です。\n\n"
    },
    {
      "title": "注意事項",
      "level": 3,
      "content": "cron では簡単にできることが、タイマーユニットを使用する場合、難しかったり不可能であったりすることがいくつか存在します。\n\n- 冗長性: systemd を使って定期的なジョブを設定するには2つのファイルを作成して2回 systemctl コマンドを実行します。それに対して crontab には一行を追加するだけです。\n- メール: ジョブが失敗した時にメールを送信する cron の MAILTO と同等なものは存在しません。ただし各サービスに OnFailure= オプションを使うことで同じような機能を設定することはできます。\n\n"
    },
    {
      "title": "MAILTO",
      "level": 3,
      "content": "Cron の MAILTO のように、systemd で、ユニットが失敗したときにメールを送信するように設定できます。それにはまず2つのファイルが必要です: メールを送信するための実行可能ファイルと、実行可能ファイルを起動するための .service。以下の例では、sendmail (smtp-forwarder を含むパッケージにはすべて含まれています) を使用するシェルスクリプトが実行可能ファイルになっています:\n\n```\n/usr/local/bin/systemd-email\n```\n\n```\n#!/bin/bash\n\n/usr/bin/sendmail -t <<ERRMAIL\nTo: $1\nFrom: systemd <root@$HOSTNAME>\nSubject: $2\nContent-Transfer-Encoding: 8bit\nContent-Type: text/plain; charset=UTF-8\n\n$(systemctl status --full \"$2\")\nERRMAIL\n```\n\nどんな実行可能ファイルを使うのであれ、上記のシェルスクリプトのように、最低でも2つの引数が必要になります: 送信先のアドレスと状態を取得するユニットファイルです。以下の .service はそれらの引数を渡します:\n\n```\n/etc/systemd/system/status-email-user@.service\n```\n\n```\n[Unit]\nDescription=status email for %i to user\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/systemd-email address %i\nUser=nobody\nGroup=systemd-journal\n```\n\nuser はメールを送信するユーザーに、address はユーザーのメールアドレスに置き換えてください。受信者はハードコードされますが、インスタンスパラメータとしてユニットファイルを渡すことで、上記のサービスだけで他のユニットのメールも送ることができます。status-email-user@dbus.service を起動して、メールが受け取れることを確認してください。\n\n問題ないようでしたら、メールを送って欲しいユニットの [Unit] セクションに OnFailure=status-email-user@%n.service を追加してください。%n はユニットの名前をテンプレートに指定します。\n\n- SSMTP#セキュリティ にしたがって SSMTP を設定した場合、ユーザー nobody は /etc/ssmtp/ssmtp.conf にアクセスすることができず、systemctl start status-email-user@dbus.service コマンドは失敗します。status-email-user@.service モジュールの User に root を使うことでこれを回避できます。\n- メールスクリプトで mail -s somelogs address を使用すると、mail はフォークして、systemd はスクリプトの終了を確認したときに mail プロセスを終了します。mail -Ssendwait -s somelogs address として mail がフォークしないようにしてください。\n\n"
    },
    {
      "title": "crontab を使用する",
      "level": 3,
      "content": "crontab を使って定期的なサービスを管理するツールとして systemd-cron-nextAUR と systemd-cronAUR があります。どちらも AUR からインストールすることができます。これらのツールには systemd に存在しない MAILTO 機能が実装されています。\n\nもし、スケジュールされたジョブをまとめて見れるから crontab が好きだという場合は、systemctl でそれと同じことが可能です。#管理 を見て下さい。\n\n"
    },
    {
      "title": "手動で行う",
      "level": 3,
      "content": "既存の crontab から移行する以外に、cron と同じ周期を使用することが望ましい場合があります。定期的に開始する各サービスのタイマーを作成するという面倒な作業を回避するには、テンプレートユニット を使用します。例:\n\n```\n/etc/systemd/system/monthly@.timer\n```\n\n```\n[Unit]\nDescription=Monthly Timer for %i service\n\n[Timer]\nOnCalendar=*-*-1 02:00:00\nAccuracySec=6h\nRandomizedDelaySec=1h\nPersistent=true\nUnit=%i.service\n\n[Install]\nWantedBy=default.target\n```\n\nその後、monthly@unit_name.timer を 起動/有効化 行うだけで済みます。\n\n"
    },
    {
      "title": "\"有効期間\" の処理",
      "level": 2,
      "content": "一部のソフトウェアは、最後に実行されてからの経過時間を追跡します。たとえば、最後のダウンロードが 24 時間以内に終了した場合はデータベースの更新をブロックします。\n\nデフォルトでは、タイマーは起動したタスクがいつ終了したかを追跡しません。これを回避するには、OnUnitInactiveSeconds を使用できます:\n\n```\n/etc/systemd/system/daily-inactive@.timer\n```\n\n```\n[Unit]\nDescription=Launch %i service 24hours after it deactivated\n\n[Timer]\nOnUnitInactiveSec=1day1sec\nUnit=%i.service\nPersistent=true\n\n[Install]\nWantedBy=default.target\n```\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- systemd.timer(5)\n- Fedora Project wiki の systemd カレンダータイマーのページ\n- Gentoo wiki の systemd タイマーサービスのセクション\n- systemd-cron-next — crontab と anacrontab ファイルからタイマーとサービスを生成するツール\n\n- systemd-cron — cron スクリプトを実行する systemd ユニットが入っています。systemd-crontab-generator を使って crontab を変換。\n\n"
    }
  ]
}