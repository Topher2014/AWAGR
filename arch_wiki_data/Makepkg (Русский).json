{
  "title": "Makepkg (Русский)",
  "url": "https://wiki.archlinux.org/title/Makepkg_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Создание пакетов\n- PKGBUILD (Русский)\n- .SRCINFO (Русский)\n- Пользовательский репозиторий Arch\n- pacman (Русский)\n- Официальные репозитории\n- Система сборки Arch\n- GnuPG (Русский)\n- OpenPGP (Русский)\n\nmakepkg — скрипт для автоматизации сборки пакетов. Требования для работы — Unix-платформа с системой сборки и файл PKGBUILD.\n\nmakepkg входит в состав пакета pacman.\n\n"
    },
    {
      "title": "Настройка",
      "level": 2,
      "content": "Параметры настройки makepkg подробно описаны в руководстве makepkg.conf(5).\n\nОбщесистемные настройки хранятся в файле /etc/makepkg.conf, пользовательские — в $XDG_CONFIG_HOME/pacman/makepkg.conf или ~/.makepkg.conf. Рекомендуется проверять настройки перед сборкой пакетов.\n\n"
    },
    {
      "title": "Информация о создателе пакета",
      "level": 3,
      "content": "Каждый пакет содержит метаданные, в том числе информацию о создателе пакета (packager). По умолчанию скомпилированный пакет создаётся с пометкой Unknown Packager. Однако если на одной системе компиляцией занимаются несколько пользователей или вы планируете распространять пакет среди других пользователей, то имеет смысл указать настоящие контактные данные, задав переменную PACKAGER в файле makepkg.conf.\n\nСоздателя установленного пакета можно узнать командой:\n\n```\n$ pacman -Qi пакет\n```\n\n```\n...\nPackager       : John Doe <john@doe.com>\n...\n```\n\nКроме того, если указать цифровую подпись создателя в параметре GPGKEY, то для пакетов будут автоматически создаваться подписи.\n\n"
    },
    {
      "title": "Расположение файлов пакета",
      "level": 3,
      "content": "По умолчанию makepkg создаёт tar-архивы пакетов в рабочем каталоге, а исходный код загружает в подкаталог src/. Целевые каталоги можно переназначить, например, чтобы все собранные пакеты хранились в ~/build/packages/, а все исходные файлы — в ~/build/sources/.\n\nМожно задать следующие значения в makepkg.conf:\n\n- PKGDEST — каталог для собранных пакетов;\n- SRCDEST — каталог для исходных файлов (в каталог src/ будут помещаться символические ссылки на новое местоположение);\n- SRCPKGDEST — каталог для пакетов исходных файлов, используемых для сборки пакетов (создаются командой makepkg -S).\n\n"
    },
    {
      "title": "Проверка цифровых подписей",
      "level": 3,
      "content": "Файлы цифровых подписей имеют расширение .sig или .asc и указываются в параметре source файла PKGBUILD. Если makepkg встречает такой файл, то автоматически пытается проверить подпись. Если пользовательская связка ключей не содержит нужный открытый ключ, то makepkg выведет сообщение о невозможности осуществить проверку PGP-ключа и прервёт установку.\n\nЕсли нужный открытый ключ отсутствует, то файл PKGBUILD, скорее всего, содержит пункт validpgpkeys с идентификаторами ключей. Ключи можно импортировать вручную или же найти их на сервере ключей и импортировать оттуда. Чтобы временно отключить проверку цифровых подписей, можно запустить makepkg с опцией --skippgpcheck.\n\n"
    },
    {
      "title": "Использование",
      "level": 2,
      "content": "Для корректной работы makepkg нужно установить мета-пакет base-devel. Зависимости этого пакета не нужно указывать в качестве зависимостей для сборки (makedepends) в файле PKGBUILD.\n\n- Убедитесь, что утилита sudo настроена должным образом для команд, передаваемых pacman.\n- Запуск makepkg от root-пользователя запрещён. [2] Помимо того, что PKGBUILD может содержать произвольные команды, сборка пакетов под root-аккаунтом в целом считается небезопасной [3]. Если у пользователя нет доступа к аккаунту обычного пользователя, то следует запускать makepkg от имени пользователя nobody.\n\nЧтобы собрать пакет, первым делом необходимо создать файл PKGBUILD, который представляет собой скрипт сборки. Написание скрипта описано в статье Создание пакетов. Скрипты для существующих пакетов можно найти в дереве каталогов системы сборки Arch, а также в AUR. После того, как PKGBUILD получен, перейдите в каталог с ним и выполните команду сборки пакета:\n\n```\n$ makepkg\n```\n\nЕсли в системе не установлены необходимые зависимости, makepkg предупредит вас об этом и отменит сборку. Если задать флаг -s/--syncdeps, то makepkg самостоятельно установит недостающие зависимости и соберёт пакет.\n\n```\n$ makepkg --syncdeps\n```\n\nС флагом -r/--rmdeps makepkg после сборки удалит те зависимости, которые будут больше не нужны. Если вы постоянно занимаетесь сборкой пакетов и не хотите загрязнять систему пакетами-сиротами, то стоит также ознакомиться с разделом pacman/Советы и приёмы#Удаление неиспользуемых пакетов.\n\n- Пакеты-зависимости должны быть доступны для установки из подключённых репозиториев; в статье pacman (Русский)#Репозитории и зеркала описана настройка репозиториев. Кроме того, зависимости можно установить вручную командой pacman -S --asdeps зависимость1 зависимость2.\n- При установке зависимостей используются только глобальные значения переменных, то есть переопределить значения, например, внутри функции упаковки разделённого пакета (split package) не получится.\n\nКогда все зависимости установлены и сборка пакета завершилась успешно, в рабочем каталоге появится файл пакета (имя-пакета-версия-пакета.pkg.tar.zst). Чтобы установить его в систему, используйте флаг -i/--install (работает аналогично команде pacman -U имя-пакета-версия-пакета.pkg.tar.zst):\n\n```\n$ makepkg --install\n```\n\nС флагом -c/--clean makepkg удалит оставшиеся после сборки промежуточные файлы и каталоги (например, распакованные в $srcdir файлы). Это полезно при многократных сборках одного и того же пакета или его обновления в одном рабочем каталоге. Это предотвратит добавление устаревших файлов в новые сборки:\n\n```\n$ makepkg --clean\n```\n\nПодробнее см. makepkg(8).\n\n"
    },
    {
      "title": "Расположение исходных файлов",
      "level": 4,
      "content": "При многократной пересборке одного и того же пакета, особенно в случае VCS, используйте SRCDEST, чтобы сэкономить время на скачивание и распаковку файлов с исходным кодом.\n\n"
    },
    {
      "title": "Переопределение флагов git",
      "level": 4,
      "content": "Значительно снизить время загрузки может частичное клонирование. Флаг --filter=tree:0 позволяет обновлять дерево исходных текстов только по требованию. Передать его в makepkg можно с помощью переменной GITFLAGS.\n\nПример:\n\n```\n$ GITFLAGS=\"--filter=tree:0\" makepkg\n```\n\nЧтобы применить для каждой сборки:\n\n```\n/etc/makepkg.conf\n```\n\n```\nGITFLAGS=\"--filter=tree:0\"\n```\n\nТакже --single-branch в общем случае должен работать без проблем, но экономит не так много времени. Подробнее смотрите git-clone(1).\n\nNote: **любое** \n\n"
    },
    {
      "title": "Оптимизация двоичных пакетов",
      "level": 3,
      "content": "Повысить производительность программ можно на этапе сборки пакета с помощью возможностей компилятора по оптимизации кода. Однако нужно иметь в виду, что двоичные файлы, скомпилированные под специфическую архитектуру процессора, не будут правильно работать на других машинах. Если говорить об архитектуре x86_64, то редко когда достигнутый эффект повышения производительности стоит затраченного на пересборку официальных пакетов времени.\n\nС другой стороны, снизить производительность, задав \"нестандартные\" флаги компилятора — проще простого. Чаще всего тонкая настройка компилятора приносит пользу лишь в определённой ситуации и не стоит применять её ко всем пакетам без разбора. Если вы не можете доказать повышение производительности путём тестов, то скорее всего его просто нет! Статьи из Gentoo-wiki Оптимизации GCC и Safe CFLAGS содержат больше информации по оптимизации компилятора.\n\nОпции, передаваемые компилятору C/C++ (например, gcc или clang), задаются в переменных окружения CFLAGS, CXXFLAGS и CPPFLAGS. В системе сборки Arch makepkg извлекает их значения из опций в файле настроек makepkg.conf. Значения по умолчанию выбраны таким образом, чтобы создаваемые двоичные программы работали на широком диапазоне машин.\n\n- Следует помнить, что не все системы сборки используют переменные, указанные в файле makepkg.conf. Например, cmake игнорирует переменную CPPFLAGS. Как следствие, часто в файлах PKGBUILD можно увидеть различные обходные решения для систем сборки, используемых в собираемых программах.\n- Настройки в файле Makefile и аргументы в командах компиляции имеют приоритет над значениями в makepkg.conf, что может привести к их переопределению.\n\nКомпилятор GCC может автоматически обнаруживать и включать безопасные оптимизации, доступные для текущей архитектуры. Чтобы использовать эту возможность, сначала удалите любые флаги -march и -mtune, а затем добавьте опцию -march=native. Например:\n\n```\n/etc/makepkg.conf\n```\n\n```\nCFLAGS=\"-march=native -O2 -pipe ...\"\nCXXFLAGS=\"${CFLAGS} ...\"\n```\n\nЧтобы узнать, какие флаги разблокирует эта команда, выполните:\n\n```\n$ gcc -march=native -v -Q --help=target\n```\n\nНачиная с pacman версии 5.2.2 файл makepkg.conf также содержит переменную окружения RUSTFLAGS, в которой можно указать флаги, передаваемые компилятору языка Rust. Если указать в переменной RUSTFLAGS значение -C target-cpu=native, компилятор включит доступные для текущей архитектуры алгоритмы оптимизации.\n\n```\n/etc/makepkg.conf\n```\n\n```\nRUSTFLAGS=\"-C opt-level=2 -C target-cpu=native\"\n```\n\nЧтобы узнать, какие возможности процессора можно включить этой настройкой, выполните:\n\n```\n$ rustc -C target-cpu=native --print cfg\n```\n\nЕсли в команде выше указать --print cfg без -C target-cpu=native, то будет выведена стандартная конфигурация. Можно также изменить значение параметра opt-level на 3, s или z, подробнее см. документацию компилятора Rust.\n\n"
    },
    {
      "title": "Параллельная компиляция",
      "level": 4,
      "content": "Для сборки пакетов с помощью make используется переменная окружения MAKEFLAGS, которая определяет дополнительные опции для утилиты make. Установить значение этой переменной можно также в файле makepkg.conf.\n\nПользователи с многоядерными/многопроцессорными системами могут указать количество одновременно запускаемых задач. Можно использовать утилиту nproc для определения количества доступных ядер, например MAKEFLAGS=\"-j$(nproc)\". Некоторые файлы PKGBUILD переопределяют это значение на -j1, чтобы избежать состояний гонки или просто потому что многопоточная работа не поддерживается изначально. Если сборка пакета завершилась неудачно из-за описанных выше изменений в MAKEFLAGS, то нужно создать отчёт об ошибке или, в случае пакета из AUR, сообщить сопроводителю пакета.\n\nДругие возможные опции можно найти в руководстве make(1).\n\n"
    },
    {
      "title": "Сборка из файлов в памяти",
      "level": 4,
      "content": "Если компиляция требует много операций ввода-вывода и обработки маленьких файлов, перемещение рабочего каталога в tmpfs может сократить время компиляции.\n\nЧтобы временно использовать другой рабочий каталог makepkg, можно экспортировать переменную окружения BUILDDIR. Пример использования стандартной точки монтирования tmpfs:\n\n```\n$ BUILDDIR=/tmp/makepkg makepkg\n```\n\nЧтобы сделать эту настройку постоянной, нужно раскомментировать опцию BUILDDIR файла настроек /etc/makepkg.conf. Если, к примеру, установить это значение BUILDDIR=/tmp/makepkg, то будет использоваться обычная временная файловая система Arch /tmp.\n\n- Старайтесь не компилировать большие пакеты в tmpfs, чтобы не произошло исчерпания памяти.\n- Каталог tmpfs должен быть смонтирован без опции noexec, потому что иначе собранный двоичный пакет будет невозможно исполнить.\n- Также помните, что собранные в tmpfs пакеты будут удалены при перезагрузке. Задайте параметр PKGDEST, чтобы собранный пакет автоматически перемещался в \"постоянный\" каталог.\n\n"
    },
    {
      "title": "Использование кэша компиляции",
      "level": 4,
      "content": "Применение ccache сокращает время сборки за счёт многократного использования кэша компиляции.\n\n"
    },
    {
      "title": "Использование компоновщика mold",
      "level": 4,
      "content": "mold — это прозрачная замена компоновщикам ld/lld, работающая значительно быстрее.\n\nЧтобы использовать mold, добавьте -fuse-ld=mold в LDFLAGS. Например:\n\n```\n/etc/makepkg.conf\n```\n\n```\nLDFLAGS=\"... -fuse-ld=mold\"\n```\n\nЧтобы использовать mold для Rust-программ, добавьте -C link-arg=-fuse-ld=mold в RUSTFLAGS. Например:\n\n```\n/etc/makepkg.conf\n```\n\n```\nRUSTFLAGS=\"... -C link-arg=-fuse-ld=mold\"\n```\n\n"
    },
    {
      "title": "Вычисление новых контрольных сумм",
      "level": 3,
      "content": "Установите пакет pacman-contrib и выполните следующую команду в каталоге с файлом PKGBUILD, чтобы сгенерировать новые контрольные суммы:\n\n```\n$ updpkgsums\n```\n\nupdpkgsums использует makepkg --geninteg для вычисления контрольных сумм. Подробнее см. обсуждение на форуме.\n\nКонтрольные суммы также можно получить посредством команды sha256sum, после чего полученные значения следует вручную добавить к массиву sha256sums в файле PKGBUILD.\n\n"
    },
    {
      "title": "Применение других алгоритмов сжатия",
      "level": 3,
      "content": "Создание и установку пакета можно ускорить, заплатив за это увеличением размера. Для этого нужно изменить переменную PKGEXT.\n\nНапример, следующая команда создаст пакет в виде несжатого архива, благодаря чему не нужно будет выполнять его декомпрессию при установке:\n\n```\n$ PKGEXT='.pkg.tar' makepkg\n```\n\nДругой пример с использованием алгоритма сжатия LZ4:\n\n```\n$ PKGEXT='.pkg.tar.lz4' makepkg\n```\n\nЧтобы сделать одну из этих настроек постоянной, нужно установить соответствующее значение PKGEXT в /etc/makepkg.conf.\n\n"
    },
    {
      "title": "Использование нескольких ядер при сжатии",
      "level": 3,
      "content": "zstd поддерживает симметричную многопроцессорность (SMP) посредством флага --threads для ускорения сжатия. Например, чтобы разрешить makepkg использовать все имеющиеся в наличии ядра для сжатия пакетов, отредактируйте массив COMPRESSZST в /etc/makepkg.conf:\n\n```\nCOMPRESSZST=(zstd -c -z -q --threads=0 -)\n```\n\nxz поддерживает симметричную многопроцессорность (SMP) посредством флага --threads для ускорения сжатия. Например, чтобы разрешить makepkg использовать все имеющиеся в наличии ядра для сжатия пакетов, отредактируйте массив COMPRESSXZ в /etc/makepkg.conf:\n\n```\nCOMPRESSXZ=(xz -c -z --threads=0 -)\n```\n\npigz — параллельная реализация gzip, по умолчанию использует все доступные ядра процессора. Если необходимо задействовать меньшее количество ядер, то используется флаг -p/--processes:\n\n```\nCOMPRESSGZ=(pigz -c -f -n)\n```\n\npbzip2 — параллельная реализация bzip2, также использует максимально возможное количество ядер по умолчанию. Флаг -p# используется для выбора меньшего количества ядер (примечание: между -p и числом ядер не должно быть пробелов):\n\n```\nCOMPRESSBZ2=(pbzip2 -c -f)\n```\n\nlbzip2 — ещё одна параллельная реализация bzip2, также использует максимально возможное количество ядер по умолчанию. Флаг -n используется для выбора меньшего количества ядер.\n\n```\nCOMPRESSBZ2=(lbzip2 -c -f)\n```\n\nplzipAUR — многопоточная реализация lzip, также использует максимально возможное количество ядер по умолчанию. Флаг -n/--threads используется для выбора меньшего количества ядер.\n\n```\nCOMPRESSLZ=(plzip -c -f)\n```\n\n"
    },
    {
      "title": "Вывод списка пакетов по имени создателя",
      "level": 3,
      "content": "expac — программа для работы с базой данных pacman. Чтобы вывести список всех установленных пакетов, создателем которых является создатель-пакета, выполните:\n\n```\n$ expac \"%n %p\" | grep \"создатель-пакета\" | column -t\n```\n\nКоманда для вывода списка пакетов, создатель которых указан в переменной PACKAGER файла /etc/makepkg.conf (покажет только пакеты из репозиториев, определённых в /etc/pacman.conf):\n\n```\n$ . /etc/makepkg.conf; grep -xvFf <(pacman -Qqm) <(expac \"%n\\t%p\" | grep \"$PACKAGER$\" | cut -f1)\n```\n\n"
    },
    {
      "title": "Сборка 32-битных пакетов в 64-битной системе",
      "level": 3,
      "content": "Смотрите 32-bit package guidelines.\n\n"
    },
    {
      "title": "Magnet-ссылки",
      "level": 3,
      "content": "Можно добавить поддержку magnet-ссылок (протокол magnet://) в массиве source с помощью transmission-dlagentAUR.\n\n"
    },
    {
      "title": "Запуск makepkg в контрольной группе systemd",
      "level": 3,
      "content": "Если собираемый пакет требует слишком много ресурсов для сборки при использовании стандартных флагов make, которые в остальном работают нормально для большинства пакетов, можно попробовать запустить сборку в отдельной контрольной группе (control group). makepkg-cgAUR — обёртка для makepkg, которая позволяет реализовать это через systemd control groups (смотрите systemd.resource-control(5)).\n\n"
    },
    {
      "title": "Запуск с политикой планировщика idle",
      "level": 3,
      "content": "Процесс сборки пакетов может сильно нагружать процессор, особенно если включена #Параллельная компиляция. При этом работа остальной системы может сильно замедлиться даже с самым высоким значением nice(1) — вплоть до зависания пользовательского интерфейса.\n\nЧтобы до такого не доходило, можно перед запуском makepkg установить политику SCHED_IDLE (крайне низкий приоритет, ниже чем даже nice +19). Такой процесс не будет мешать выполнению обычных задач и будет использовать только свободное процессорное время.\n\nИзменить политику на SCHED_IDLE можно с помощью команды chrt(1), указав флаг -i, приоритет 0 (единственный допустимый приоритет для политики SCHED_IDLE) и PID текущей командной оболочки.\n\nВ большинстве командных оболочек команда будет выглядеть так:\n\n```\n$ chrt -iap 0 $$\n```\n\nВ fish:\n\n```\n$ chrt -iap 0 %self\n```\n\n"
    },
    {
      "title": "Выбор каталога установки при сборке в QMake",
      "level": 3,
      "content": "QMake генерирует файл makefile, в котором для указания каталога установки используется переменная окружения INSTALL_ROOT. Например, вот как будет выглядеть функция package:\n\n```\nPKGBUILD\n```\n\n```\n...\npackage() {\n\tcd \"$srcdir/${pkgname%-git}\"\n\tmake INSTALL_ROOT=\"$pkgdir\" install\n}\n...\n```\n\nОбратите внимание, что qmake тоже должен быть настроен соответственно. К примеру, добавьте следующие строки в соответствующий .pro-файл.\n\n```\nYourProject.pro\n```\n\n```\n...\ntarget.path = /usr/local/bin\nINSTALLS += target\n...\n```\n\n"
    },
    {
      "title": "WARNING: Package contains reference to $srcdir",
      "level": 3,
      "content": "Подобное предупреждение означает, что строковый литерал, указанный в переменных $srcdir или $pkgdir, каким-то образом оказался в одном или нескольких файлах пакета [5].\n\nЧтобы определить, в каких именно файлах, выполните следующую команду в рабочем каталоге сборки:\n\n```\n$ grep -R \"$PWD/src\" pkg/\n```\n\nОдной из причин появления этого предупреждения может быть использование в коде C/C++ макроса __FILE__, который содержит полный путь к каталогу $srcdir.\n\n"
    },
    {
      "title": "makepkg не может загрузить зависимости через прокси",
      "level": 3,
      "content": "Когда makepkg проверяет зависимости, он вызывает pacman для установки недостающих пакетов, при этом запрашивая права администратора посредством sudo. Однако команда sudo не передаёт никакие переменные окружения в привилегированное окружение, в том числе и относящиеся к настройкам прокси переменные ftp_proxy, http_proxy, https_proxy и no_proxy.\n\nЧтобы makepkg мог работать через прокси, воспользуйтесь одним из советов ниже.\n\n"
    },
    {
      "title": "Параметр XferCommand в файле /etc/pacman.conf",
      "level": 4,
      "content": "Параметр XferCommand в файле /etc/pacman.conf позволяет настроить использование прокси. В этом параметре нужно указать URL прокси-сервера. Добавьте или раскомментируйте следующую строку:\n\n```\n/etc/pacman.conf\n```\n\n```\n...\nXferCommand = /usr/bin/curl --proxy http://username:password@proxy.proxyhost.com:80 --location --continue-at - --fail --output %o %u\n...\n```\n\n"
    },
    {
      "title": "Параметр env_keep в файле /etc/sudoers",
      "level": 4,
      "content": "Опция env_keep в файле /etc/sudoers позволяет использовать упомянутые выше прокси-переменные в привилегированном окружении. Подробнее смотрите pacman (Русский)#pacman игнорирует настройки прокси.\n\n"
    },
    {
      "title": "makepkg не работает, но make завершается успешно",
      "level": 3,
      "content": "Если удаётся скомпилировать пакет командой make, но не получается командой makepkg, причиной могут быть несовместимые переменные компиляции в файле /etc/makepkg.conf. Попробуйте добавить следующие флаги к параметру options файла PKGBUILD:\n\n!buildflags — для отключения значений по умолчанию CPPFLAGS, CFLAGS, CXXFLAGS и LDFLAGS.\n\n!makeflags — для отключения MAKEFLAGS.\n\n!debug — для отключения DEBUG_CFLAGS и DEBUG_CXXFLAGS, если вы собрали пакет для отладки.\n\nЕсли что-то из перечисленного выше решило проблему, выясните, какой именно флаг создавал проблему, и сообщите о баге разработчикам программы.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- makepkg(8)\n- makepkg.conf(5)\n- Краткое описание работы makepkg\n- Исходный код makepkg\n\n"
    }
  ]
}