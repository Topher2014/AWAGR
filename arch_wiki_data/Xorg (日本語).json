{
  "title": "Xorg (日本語)",
  "url": "https://wiki.archlinux.org/title/Xorg_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- 自動起動\n- カーソルテーマ\n- デスクトップ環境\n- ディスプレイマネージャ\n- フォント設定\n- ウィンドウマネージャ\n- XDMCP\n- xinit\n- xrandr\n\nX.Org Server (一般的には単に X と呼ばれる)は、X Window System (X11) ディスプレイサーバーの X.Org Foundation 実装であり、Linux ユーザーの間で最も人気のあるディスプレイサーバーです。その普遍性により、GUI アプリケーションにとって Xorg は欠かせない存在となり、ほとんどのディストリビューションで広く採用されています。\n\nXorg の代替かつ後継については Wayland を参照してください。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール 1.1 ドライバーのインストール 1.1.1 AMD\n- 2 起動\n- 3 設定 3.1 .conf ファイルを使う 3.2 xorg.conf を使う\n- 4 入力デバイス 4.1 入力の識別 4.2 マウスのアクセラレーション 4.3 特殊なマウスボタン 4.4 タッチパッド 4.5 タッチスクリーン 4.6 キーボードの設定\n- 5 モニターの設定 5.1 手動設定 5.2 マルチモニター 5.2.1 複数のグラフィックカード 5.3 画面サイズと DPI 5.3.1 手動で DPI を設定する 5.3.1.1 プロプライエタリの NVIDIA ドライバー 5.3.1.2 Manual DPI Setting Caveat 5.4 Display Power Management\n- 6 コンポジット 6.1 コンポジットマネージャ一覧\n- 7 ヒントとテクニック 7.1 自動化 7.2 ネストした X セッション 7.3 ウィンドウマネージャ無しでアプリケーションを起動する 7.4 リモートで GUI プログラムを実行する 7.5 必要に応じて入力ソースを有効化・無効化 7.6 入力ソースを永続的に無効化する 7.7 ホットキーでアプリケーションを終了 7.8 TTY へのアクセスをブロック 7.9 ユーザーが X を終了できないようにする 7.10 視覚的にアプリケーションを kill する 7.11 Rootless Xorg 7.11.1 xinitrc の使用 7.11.2 GDM の使用 7.11.3 セッションログのリダイレクト 7.12 root として Xorg を実行\n- 8 トラブルシューティング 8.1 一般 8.2 一部またはすべてのユーザで黒画面、No protocol specified、Resource temporarily unavailable 8.3 Matrox カードで DRI が停止する 8.4 フレームバッファモード問題 8.5 プログラムが \"font '(null)'\" を要求する 8.6 リカバリ: GUI ログインの前に Xorg を無効化 8.7 \"su\" で X クライアントの起動が失敗する 8.8 X が起動できない: Keyboard initialization failed 8.9 動画を視聴しようとすると緑色の画面が表示される 8.10 SocketCreateListener エラー 8.11 プログラムを root として実行しようとした際に Invalid MIT-MAGIC-COOKIE-1 key 8.12 Xorg-server Fatal server error: (EE) AddScreen/ScreenInit\n- 9 参照\n\n- 1.1 ドライバーのインストール 1.1.1 AMD\n\n- 1.1.1 AMD\n\n- 3.1 .conf ファイルを使う\n- 3.2 xorg.conf を使う\n\n- 4.1 入力の識別\n- 4.2 マウスのアクセラレーション\n- 4.3 特殊なマウスボタン\n- 4.4 タッチパッド\n- 4.5 タッチスクリーン\n- 4.6 キーボードの設定\n\n- 5.1 手動設定\n- 5.2 マルチモニター 5.2.1 複数のグラフィックカード\n- 5.3 画面サイズと DPI 5.3.1 手動で DPI を設定する 5.3.1.1 プロプライエタリの NVIDIA ドライバー 5.3.1.2 Manual DPI Setting Caveat\n- 5.4 Display Power Management\n\n- 5.2.1 複数のグラフィックカード\n\n- 5.3.1 手動で DPI を設定する 5.3.1.1 プロプライエタリの NVIDIA ドライバー 5.3.1.2 Manual DPI Setting Caveat\n\n- 5.3.1.1 プロプライエタリの NVIDIA ドライバー\n- 5.3.1.2 Manual DPI Setting Caveat\n\n- 6.1 コンポジットマネージャ一覧\n\n- 7.1 自動化\n- 7.2 ネストした X セッション\n- 7.3 ウィンドウマネージャ無しでアプリケーションを起動する\n- 7.4 リモートで GUI プログラムを実行する\n- 7.5 必要に応じて入力ソースを有効化・無効化\n- 7.6 入力ソースを永続的に無効化する\n- 7.7 ホットキーでアプリケーションを終了\n- 7.8 TTY へのアクセスをブロック\n- 7.9 ユーザーが X を終了できないようにする\n- 7.10 視覚的にアプリケーションを kill する\n- 7.11 Rootless Xorg 7.11.1 xinitrc の使用 7.11.2 GDM の使用 7.11.3 セッションログのリダイレクト\n- 7.12 root として Xorg を実行\n\n- 7.11.1 xinitrc の使用\n- 7.11.2 GDM の使用\n- 7.11.3 セッションログのリダイレクト\n\n- 8.1 一般\n- 8.2 一部またはすべてのユーザで黒画面、No protocol specified、Resource temporarily unavailable\n- 8.3 Matrox カードで DRI が停止する\n- 8.4 フレームバッファモード問題\n- 8.5 プログラムが \"font '(null)'\" を要求する\n- 8.6 リカバリ: GUI ログインの前に Xorg を無効化\n- 8.7 \"su\" で X クライアントの起動が失敗する\n- 8.8 X が起動できない: Keyboard initialization failed\n- 8.9 動画を視聴しようとすると緑色の画面が表示される\n- 8.10 SocketCreateListener エラー\n- 8.11 プログラムを root として実行しようとした際に Invalid MIT-MAGIC-COOKIE-1 key\n- 8.12 Xorg-server Fatal server error: (EE) AddScreen/ScreenInit\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "Xorg は xorg-server パッケージでインストールできます。\n\nまた、設定作業などに必要なパッケージのいくつかが xorg-apps グループに入っており、それぞれ関連するセクションで説明しています。\n\nxorg グループも利用できます。このグループには Xorg サーバのパッケージや xorg-apps のパッケージ、フォントが含まれています。\n\n"
    },
    {
      "title": "ドライバーのインストール",
      "level": 3,
      "content": "Linux カーネルにはオープンソースのビデオドライバーが含まれておりハードウェアでアクセラレートされたフレームバッファをサポートしています。しかし、OpenGL や X11 における 2D アクセラレーションを使うにはユーザーランドのサポートが必要です。\n\nまず、あなたのグラフィックスカードを特定してください (Subsystem の行に特定のモデルが表示されます):\n\n```\n$ lspci -v -nn -d ::03xx\n```\n\nそれから適切なドライバーをインストールしてください。パッケージデータベースを検索してオープンソースビデオドライバーの一覧を表示することができます:\n\n```\n$ pacman -Ss xf86-video\n```\n\nXorg はインストールされているドライバーを自動的に検索します:\n\n- 使用しているハードウェアに合うドライバー（以下に記載）がインストールされていない場合、Xorg はまず最初に fbdev (xf86-video-fbdev) を検索します。\n- fbdev が存在しなかった場合、次に汎用ドライバーである vesa (xf86-video-vesa) を検索します。vesa はほとんどのチップセットで動作しますが 2D や 3D のアクセラレーションは含まれていません。\n- vesa も見つからない場合、Xorg はカーネルモードセッティングにフォールバックします。カーネルモードセッティングでは GLAMOR アクセラレーションが利用できます (modesetting(4) を参照)。\n\nビデオアクセラレーション機能を動かしたり、GPU が設定できる全てのモードを表示するには、適切なビデオドライバが必要です:\n\nTable content:\nブランド | 種類 | ドキュメント | ドライバ | OpenGL | OpenGL (multilib) | Vulkan | Vulkan (multilib)\nAMD (旧 ATI) | オープンソース | AMDGPU | xf86-video-amdgpu | mesa | lib32-mesa | vulkan-radeon / amdvlk4 | lib32-vulkan-radeon / lib32-amdvlk4\nATI | xf86-video-ati | 無し\nプロプライエタリ | AMDGPU PRO | xf86-video-amdgpu | amdgpu-pro-oglpAUR | lib32-amdgpu-pro-oglpAUR | vulkan-amdgpu-proAUR | lib32-vulkan-amdgpu-proAUR\nIntel | オープンソース | Intel graphics | xf86-video-intel2 | mesa または mesa-amber3 | lib32-mesa | vulkan-intel | lib32-vulkan-intel\nNVIDIA | オープンソース | Nouveau1 | xf86-video-nouveau | mesa | lib32-mesa | vulkan-nouveau | lib32-vulkan-nouveau\nプロプライエタリ | NVIDIA1 | nvidia または nvidia-open5 | nvidia-utils | lib32-nvidia-utils | nvidia-utils | lib32-nvidia-utils\nnvidia-470xx-dkmsAUR | nvidia-470xx-utilsAUR | lib32-nvidia-470xx-utilsAUR | nvidia-470xx-utilsAUR | lib32-nvidia-470xx-utilsAUR\nnvidia-390xx-dkmsAUR | nvidia-390xx-utilsAUR | lib32-nvidia-390xx-utilsAUR | nvidia-390xx-utilsAUR | lib32-nvidia-390xx-utilsAUR\n\n1. 統合 GPU と専用 GPU を組み合わせて使用する NVIDIA Optimus 対応のノート PC に関しては NVIDIA Optimus を参照してください。\n1. 第4世代及びそれ以降の Intel グラフィックスに関しては、Intel graphics#インストール で利用可能なドライバを確認してください。\n1. 古いハードウェア用のクラシック OpenGL (Gallium3D でない) ドライバです (Mesa 22.0 及びそれ以降では、i915 クラシックドライバのサポートが落とされています)。\n1. vulkan-radeon / lib32-vulkan-radeon は amdvlk / lib32-amdvlk よりも推奨されます (AMDGPU#インストール を参照)。\n1. nvidia と nvidia-open の違いについては NVIDIA#インストール を見てください。\n\n他のビデオドライバーは xorg-drivers グループで見つけることができます。\n\nXorg はクローズドソースのドライバーがなくとも問題なく動作するはずです。基本的に、ゲームのための 3D 支援レンダリングや、デュアルスクリーン、TV 出力など高度な機能を使う場合にのみプロプライエタリのドライバが必要になります。オープンソースのドライバーでサポートされない最近の GPU (特に NVIDIA GPU)は例外です。\n\n"
    },
    {
      "title": "AMD",
      "level": 4,
      "content": "モデル名 (例: Radeon RX 6800) から GPU アーキテクチャ (例: RDNA 2) への変換は、Wikipedia:List of AMD graphics processing units#Features overview を見てください。\n\nTable content:\nGPU アーキテクチャ | オープンソースドライバ | プロプライエタリドライバ\nRDNA 及びそれ以降 | AMDGPU | AMDGPU PRO\nGCN 3 及びそれ以降\nGCN 1 と 2 | AMDGPU1 / ATI | 利用不可\nTeraScale及びそれ以前 | ATI | 利用不可\n\n1. 試験的。\n\n"
    },
    {
      "title": "起動",
      "level": 2,
      "content": "Xorg(1) コマンドを直接実行することは通常ありません。代わりに、ディスプレイマネージャ か xinit を用いて X サーバを起動します。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "Xorg は初期設定に xorg.conf という名前の設定ファイルと .conf が末尾につくファイルを使います: これらのファイルが検索されるフォルダの完全なリストは xorg.conf(5) で見られます(利用可能なすべてのオプションの詳細な説明付き)。\n\n"
    },
    {
      "title": ".conf ファイルを使う",
      "level": 3,
      "content": "/etc/X11/xorg.conf.d/ ディレクトリにはホスト固有の設定を保存します。あなたは自由に設定ファイルをそのディレクトリに追加することができますが、ファイル名には .conf 拡張子がなければなりません。さらに、これらのファイルは ASCII 順で読み込まれます。これらのファイル名は XX- (2桁の整数とハイフン)で始めるのが慣例です(例えば 10 は 20 よりも早く読み込まれます)。これらのファイルは X サーバーの起動時にパースされオリジナルの xorg.conf 設定ファイルの一部として扱われます。設定が競合した場合は、一番最後のファイルが処理されることに注意してください。これにより、最も一般的な設定ファイルは名前順で一番最初にあるべきです。xorg.conf ファイル内の設定エントリは一番最後に処理されます。\n\n設定オプションの例は Fedora:Input device configuration#xorg.conf.d を見てください。\n\n"
    },
    {
      "title": "xorg.conf を使う",
      "level": 3,
      "content": "/etc/X11/xorg.conf や /etc/xorg.conf で Xorg を設定することもできます。xorg.conf のスケルトンを生成するには\n\n```\n# Xorg :0 -configure\n```\n\n上のコマンドで /root/ に xorg.conf.new ファイルが作られるはずです。これを /etc/X11/xorg.conf にコピーして上書きすることができます。\n\nもしくは、あなたのビデオカードドライバに自動で Xorg を設定するツールが含まれているかもしれません。詳しくは NVIDIA や AMDGPU PRO などあなたの使っているビデオカードの記事を見て下さい。\n\n"
    },
    {
      "title": "入力デバイス",
      "level": 2,
      "content": "入力デバイスのドライバーについては、X サーバーはデフォルトで libinput ドライバー (xf86-input-libinput) を使用しますが、xf86-input-evdev と関連するドライバーも使用できます [1]。\n\nUdev があなたのハードウェアを検知し、/usr/share/X11/xorg.conf.d/ ディレクトリに入っているデフォルト設定ファイル 10-evdev.conf と 40-libinput.conf によって、evdev と libinput がほとんど全てのデバイスのホットプラグ・インプットドライバーとして動作します。Udev は systemd によって提供されています。\n\nX サーバーの起動後、ログファイルを確認することで、どちらのドライバーがデバイスによってホットプラグされているか確認できます (ログファイルの名前は違っているかもしれません):\n\n```\n$ grep -e \"Using input driver \" Xorg.0.log\n```\n\nevdev や libinput があなたの持っているデバイスをサポートしていないときは、必要なドライバーを xorg-drivers グループからインストールしてください。\n\nホットプラグの動作については#設定を見てください。\n\nより詳細な手順については、libinput の記事や以下に述べる記事、より多くの例は Fedora:Input device configuration を見てください。\n\n"
    },
    {
      "title": "入力の識別",
      "level": 3,
      "content": "キーボード入力#Xorg でキーコードを確認する を見てください。\n\n"
    },
    {
      "title": "マウスのアクセラレーション",
      "level": 3,
      "content": "マウスのアクセラレーション を見てください。\n\n"
    },
    {
      "title": "特殊なマウスボタン",
      "level": 3,
      "content": "全てのマウスボタンを動作させる を見てください。\n\n"
    },
    {
      "title": "タッチパッド",
      "level": 3,
      "content": "libinput または Synaptics タッチパッド を見てください。\n\n"
    },
    {
      "title": "タッチスクリーン",
      "level": 3,
      "content": "タッチスクリーン を見てください。\n\n"
    },
    {
      "title": "キーボードの設定",
      "level": 3,
      "content": "Xorg でのキーボード設定 を見てください。\n\n"
    },
    {
      "title": "手動設定",
      "level": 3,
      "content": "- Xorg の新しいバージョンは自動設定されます。なので、手動設定は必要ないはずです。\n- Xorg がモニタを検出できない場合や自動設定をしたくない場合、設定ファイルを使用することができます。これが必要になる一般的なケースとしては、モニタ無しで起動し、Xorg が自動的に起動するヘッドレスなシステムに仮想コンソールやディスプレイマネージャを使用してログインする場合です。\n\nヘッドレスな環境においては、xf86-video-dummy ドライバが必須です; それをインストールし、例えば以下のような設定ファイルを作成してください:\n\n```\n/etc/X11/xorg.conf.d/10-headless.conf\n```\n\n```\nSection \"Monitor\"\n        Identifier \"dummy_monitor\"\n        HorizSync 28.0-80.0\n        VertRefresh 48.0-75.0\n        Modeline \"1920x1080\" 172.80 1920 2040 2248 2576 1080 1081 1084 1118\nEndSection\n\nSection \"Device\"\n        Identifier \"dummy_card\"\n        VideoRam 256000\n        Driver \"dummy\"\nEndSection\n\nSection \"Screen\"\n        Identifier \"dummy_screen\"\n        Device \"dummy_card\"\n        Monitor \"dummy_monitor\"\n        SubSection \"Display\"\n        EndSubSection\nEndSection\n```\n\n"
    },
    {
      "title": "マルチモニター",
      "level": 3,
      "content": "一般的な情報はマルチディスプレイを見て下さい。\n\n"
    },
    {
      "title": "複数のグラフィックカード",
      "level": 4,
      "content": "利用するドライバを正しく定めてグラフィックカードのバス ID を(10進数表記で)入力する必要があります。\n\n```\nSection \"Device\"\n    Identifier             \"Screen0\"\n    Driver                 \"intel\"\n    BusID                  \"PCI:0:2:0\"\nEndSection\n\nSection \"Device\"\n    Identifier             \"Screen1\"\n    Driver                 \"nouveau\"\n    BusID                  \"PCI:1:0:0\"\nEndSection\n```\n\n(16進数の) バス ID を取得するには:\n\n```\n$ lspci -d ::03xx\n```\n\n```\n00:02.0 VGA compatible controller: Intel Corporation HD Graphics 630 (rev 04)\n01:00.0 3D controller: NVIDIA Corporation GP107M [GeForce GTX 1050 Mobile] (rev a1)\n```\n\nこの場合、バス ID は 0:2:0 と 1:0:0 となります。\n\n"
    },
    {
      "title": "画面サイズと DPI",
      "level": 3,
      "content": "2009-01-30 以降、Xorg はデフォルトで常に DPI を 96 に設定します。適切な DPI の自動検出を行うためにバージョン 21.1 で変更が加えられましたが、後に元に戻されました。\n\nX サーバの DPI は -dpi コマンドラインオプションで設定できます。\n\n細かなディーテールが要求される場面(フォントレンダリングなど)では、正しい DPI を設定すると役に立つことがあります。以前は、メーカーは 96 DPI を標準として作成していました (10.3\" モニターなら 800x600、13.2\" モニターなら 1024x768)。最近では、画面の DPI は様々であり、縦横で等しくないこともあります。例えば、19\" ワイドスクリーン LCD が 1440x900 なら DPI が 89x87 になります。\n\nディスプレイのサイズと DPI が正しく検出・計算されているか確認するには:\n\n```\n$ xdpyinfo | grep -B2 resolution\n```\n\n寸法がディスプレイサイズと一致しているかチェックしてください。\n\nスクリーンの物理的な大きさがわかっているときは、Xorg の設定ファイルに入力することで正しい DPI が計算されます(実際の xrandr の出力に合わせて Identifier を調整してください):\n\n```\nSection \"Monitor\"\n    Identifier             \"DVI-D-0\"\n    DisplaySize             286 179    # ミリメートル単位\nEndSection\n```\n\nフルの xorg.conf を作成しないでモニタの仕様の入力だけを行いたい場合は新しい設定ファイルを作成してください。例えば (/etc/X11/xorg.conf.d/90-monitor.conf):\n\n```\nSection \"Monitor\"\n    Identifier             \"<default monitor>\"\n    DisplaySize            286 179    # In millimeters\nEndSection\n```\n\nスクリーンの横と縦の物理的な長さがわからないときは（最近は対角線の長さ（インチ数）しかわからないことも多い）、モニターの最大解像度（またはアスペクト比）と対角線の長さを使って縦と横の長さを計算できます。ピタゴラスの定理を使って最大解像度1280x800（もしくはアスペクト比16:10）、13.3インチのスクリーンの場合:\n\n```\n$ echo 'scale=5;sqrt(1280^2+800^2)' | bc  # 1509.43698\n```\n\nこのコマンドでピクセルの対角線の長さがわかり、この値を使うことで物理的な縦と横の長さを知ることができます (そしてそれをミリメートルに変換できます):\n\n```\n$ echo 'scale=5;(13.3/1509)*1280*25.4' | bc  # 286.43072\n$ echo 'scale=5;(13.3/1509)*800*25.4'  | bc  # 179.01920\n```\n\n"
    },
    {
      "title": "手動で DPI を設定する",
      "level": 4,
      "content": "RandR に対応しているドライバ (例えばオープンソースの ATI ドライバ) なら、次のコマンドで設定できます:\n\n```\n$ xrandr --dpi 144\n```\n\n設定を永続的にするには 自動起動#Xorg のスタートアップ を見て下さい。\n\nDevice か Screen セクション下にオプションを追加することで DPI を手動で設定できます:\n\n```\nOption              \"DPI\" \"96 x 96\"\n```\n\nGTK はしばしば、オプションの X resource Xft.dpi を通して Xorg サーバの DIP を上書きします。これがあなたの環境で起こっているかどうかを確認するには:\n\n```\n$ xrdb -query | grep dpi\n```\n\nGTK ライブラリのバージョン 3.16 以降、この変数が明示的に設定されていない場合、GTK はこの変数の値を 96 に設定します。GTK アプリがサーバの DPI に従うようにするには、Xft.dpi の値をサーバのもとと同じに明示的に設定する必要があります。Xft.dpi リソースは、一部のデスクトップ環境の個人設定で DIP を特定の値に強制的に設定する手段です。KDE と TDE がその例です。\n\n"
    },
    {
      "title": "Display Power Management",
      "level": 3,
      "content": "DPMS はコンピュータが使われていない時にモニターを省電力モードに移行させる技術です。一定時間後にモニタを自動で待機状態にすることができます。\n\n"
    },
    {
      "title": "コンポジット",
      "level": 2,
      "content": "X の Composite 拡張によってウィンドウ階層のサブツリー全体がオフスクリーンバッファにレンダリングされます。アプリケーションはバッファの内容を取得できるようになります。オフスクリーンバッファは親のウィンドウに自動的にマージされるか、コンポジットマネージャと呼ばれる外部のプログラムによってマージされます。詳しくは次のページを見て下さい: Wikipedia:ja:コンポジット型ウィンドウマネージャ。\n\nウィンドウマネージャによっては、コンポジットマネージャをインストールしなくてもコンポジットが行われます (例: Compiz, Enlightenment, KWin, Marco, Metacity, Muffin, Mutter, Xfwm)。そうでないウィンドウマネージャの場合、スタンドアロンのコンポジットマネージャを使用します。\n\n"
    },
    {
      "title": "コンポジットマネージャ一覧",
      "level": 3,
      "content": "- Picom — 影、高度なぼかし、フェード機能を搭載した軽量なコンポジタ。Compton からフォークされました。\n\n- Xcompmgr — X.org 向けのウィンドウ効果ができるコンポジットマネージャ。\n\n- Gamescope — Valve のマイクロコンポジタ。FSR アップスケーリングなどのゲーム志向の機能が搭載されています。steamos-compositor からフォークされました。\n\n- steamos-compositor-plus — Valve のコンポジタ。いくつかの調整と修正が加えられています。\n\n"
    },
    {
      "title": "自動化",
      "level": 3,
      "content": "このセクションでは、キーボード/マウスの入力やウィンドウ操作(移動、リサイズ、レイズなど)の自動化のためのユーティリティを挙げています。\n\nTable content:\nツール | パッケージ | マニュアル | Keysymインプット | ウィンドウ操作 | 備考\nxautomation | xautomation | xte(1) | Yes | No | スクリーンスクレイピングツールも同梱。F13 などのシミュレート不可。\nxdo | xdo | xdo(1) | No | Yes | ウィンドウの基本的なアクションを行う小さな X ユーティリティ。\nxdotool | xdotool | xdotool(1) | Yes | Yes | バグが多く、活発に開発されていない。例: CLI パースが壊れている[2][3]\nxvkbd | xvkbdAUR | xvkbd(1) | Yes | No | Xorg のための仮想キーボード。文字を送るための -text オプションもあり。\nAutoKey | autokey-qtAUR autokey-gtkAUR | ドキュメント | Yes | Yes | 高レベルで強力なマクロとスクリプトユーティリティ。Qt と Gtk の両方のフロントエンドあり。\n\nクリップボード#ツール と X 自動化ツールの概要 も参照してください。\n\n"
    },
    {
      "title": "ネストした X セッション",
      "level": 3,
      "content": "他のデスクトップ環境に入れ子になったセッションを起動するには:\n\n```\n$ /usr/bin/Xnest :1 -geometry 1024x768+0+0 -ac -name Windowmaker & wmaker -display :1\n```\n\n上記で現在の X セッションの中に 1024x768 のウィンドウの Window Maker セッションが起動します。\n\nこのためには xorg-server-xnest パッケージをインストールする必要があります。\n\nX セッションをネストする、よりモダンな方法は Xephyr です。\n\n"
    },
    {
      "title": "ウィンドウマネージャ無しでアプリケーションを起動する",
      "level": 3,
      "content": "xinit#ウィンドウマネージャを使わずにアプリケーションを起動 を見てください。\n\n"
    },
    {
      "title": "リモートで GUI プログラムを実行する",
      "level": 3,
      "content": "次の記事を参照してください: OpenSSH#X11 フォワーディング\n\n"
    },
    {
      "title": "必要に応じて入力ソースを有効化・無効化",
      "level": 3,
      "content": "xinput を使えば一時的に入力ソースを有効化・無効化することができるようになります。ThinkPad のように複数のマウスがあって、どちらか片方だけ使いたい時などに役立ちます。\n\nxorg-xinput パッケージをインストールしてください。\n\n無効化したいデバイスの ID を調べて下さい:\n\n```\n$ xinput\n```\n\n例えば Lenovo ThinkPad T500 では、出力は以下のようになります:\n\n```\n$ xinput\n```\n\n```\n⎡ Virtual core pointer                          id=2    [master pointer  (3)]\n⎜   ↳ Virtual core XTEST pointer                id=4    [slave  pointer  (2)]\n⎜   ↳ TPPS/2 IBM TrackPoint                     id=11   [slave  pointer  (2)]\n⎜   ↳ SynPS/2 Synaptics TouchPad                id=10   [slave  pointer  (2)]\n⎣ Virtual core keyboard                         id=3    [master keyboard (2)]\n    ↳ Virtual core XTEST keyboard               id=5    [slave  keyboard (3)]\n    ↳ Power Button                              id=6    [slave  keyboard (3)]\n    ↳ Video Bus                                 id=7    [slave  keyboard (3)]\n    ↳ Sleep Button                              id=8    [slave  keyboard (3)]\n    ↳ AT Translated Set 2 keyboard              id=9    [slave  keyboard (3)]\n    ↳ ThinkPad Extra Buttons                    id=12   [slave  keyboard (3)]\n```\n\nxinput --disable device_id (device_id は無効化したいデバイスの ID) でデバイスを無効にします。次の例では Synaptics Touchpad の ID 10 を無効にします:\n\n```\n$ xinput --disable 10\n```\n\nデバイスを有効にするには、次のコマンドを実行してください:\n\n```\n$ xinput --enable 10\n```\n\nもしくはデバイス名を使うこともできます。タッチパッドを無効化するコマンドは:\n\n```\n$ xinput --disable \"SynPS/2 Synaptics TouchPad\"\n```\n\n"
    },
    {
      "title": "入力ソースを永続的に無効化する",
      "level": 3,
      "content": "以下の設定スニペットを使用することで、特定の入力ソースを無効化できます:\n\n```\n/etc/X11/xorg.conf.d/30-disable-device.conf\n```\n\n```\nSection \"InputClass\"\n       Identifier   \"disable-device\"\n       Driver       \"driver_name\"\n       MatchProduct \"device_name\"\n       Option       \"Ignore\" \"True\"\nEndSection\n```\n\ndevice は任意の名前です。driver_name は入力ドライバの名前です (例: libinput)。device_name は、適切なデバイスとマッチするように使用されるものです。正しいデバイスを指定する他の方法 (libinput の MatchIsTouchscreen など) は、使用している入力ドライバのドキュメントを調べてください。この例では libinput を使用していますが、これはドライバに依存しない方法であり、対象のデバイスがドライバに伝達されないようにします。\n\n"
    },
    {
      "title": "ホットキーでアプリケーションを終了",
      "level": 3,
      "content": "ホットキーでスクリプトを実行:\n\n```\n#!/bin/sh\nwindowFocus=$(xdotool getwindowfocus)\npid=$(xprop -id \"$windowFocus\" | grep PID)\nkill -9 \"$pid\"\n```\n\n依存パッケージ: xorg-xprop, xdotool\n\n#視覚的にアプリケーションを kill する も参照。\n\n"
    },
    {
      "title": "TTY へのアクセスをブロック",
      "level": 3,
      "content": "X から tty へのアクセスをブロックしたい場合、以下を xorg.conf に追加してください:\n\n```\nSection \"ServerFlags\"\n    Option \"DontVTSwitch\" \"True\"\nEndSection\n```\n\nこれは、信頼できないユーザによる、システムのコマンドラインへのアクセスを制限するのに役立ちます。\n\n"
    },
    {
      "title": "ユーザーが X を終了できないようにする",
      "level": 3,
      "content": "X が動作しているときにユーザーから kill されないようにしたい場合、以下を xorg.conf に追加してください:\n\n```\nSection \"ServerFlags\"\n    Option \"DontZap\"      \"True\"\nEndSection\n```\n\n"
    },
    {
      "title": "視覚的にアプリケーションを kill する",
      "level": 3,
      "content": "アプリケーションが誤動作したり固まったりした場合、ターミナルから kill や killall を使うためにプロセス ID や名前を見つける代わりに、xorg-xkill を使えばアプリケーションをクリックして X サーバとの接続を閉じることができます。多くの既存のアプリケーションは、X サーバとの接続が閉じるとアボートしますが、一部のアプリケーションは実行し続ける可能性があります。\n\n"
    },
    {
      "title": "Rootless Xorg",
      "level": 3,
      "content": "Xorg は root の代わりに標準的なユーザー権限で実行することができます (いわゆる \"rootless\" Xorg)。これは root で実行するよりもセキュリティ上重要な改善です。一部の人気なディスプレイマネージャ (例: LightDM や XDM) はルートレス Xorg をサポートしていないことに注意してください。\n\nXorg がどのユーザーとして実行されているかは ps -o user= -C Xorg で確認できます。\n\nXorg.wrap(1), systemd-logind(8), systemd のユーザーサービスとしての Xorg, Fedora:Changes/XorgWithoutRootRights , FS#41257 も参照して下さい。\n\n"
    },
    {
      "title": "xinitrc の使用",
      "level": 4,
      "content": "xinitrc を使ってルートレス Xorg を設定するには:\n\n- startx を直接実行し、exec startx を使用しないでください。\n- .xserverrc を介して $XDG_VTNR で logind から渡されたパーミッションの仮想コンソールを Xorg が使用することを確認してください。\n- 特定のプロプライエタリなディスプレイドライバを使用している場合、カーネルモードセッティングの自動検出は失敗します。その場合は、/etc/X11/Xwrapper.config で needs_root_rights = no を設定する必要があります。\n\n"
    },
    {
      "title": "GDM の使用",
      "level": 4,
      "content": "カーネルモード設定を使用する場合、GDM はデフォルトで root 権限なしに Xorg を実行します。\n\n"
    },
    {
      "title": "セッションログのリダイレクト",
      "level": 4,
      "content": "Xorg をルートレスモードで実行すると、Xorg のログは、~/.local/share/xorg/Xorg.log に保存されます。しかし、Xorg セッションからの stdout と stderr の出力はこのログにリダイレクトされません。リダイレクトを再度有効にするには、Xorg を -keeptty フラグで起動し、stdout と stderr の出力をファイルにリダイレクトします。\n\n```\nstartx -- -keeptty >~/.xorg.log 2>&1\n```\n\nもしくは、/etc/X11/xinit/xserverrc を ~/.xserverrc にコピーして、-keeptty を追加します。[4] を参照してください。\n\n"
    },
    {
      "title": "root として Xorg を実行",
      "level": 3,
      "content": "上記の通り、rootless Xorg がデフォルトであるような状況が存在します。rootless Xorg がデフォルトである環境で Xorg を root として実行する必要がある場合、Xorg.wrap(1) を設定して root を要求するようにできます。\n\n```\n/etc/X11/Xwrapper.config\n```\n\n```\nneeds_root_rights = yes\n```\n\n"
    },
    {
      "title": "一般",
      "level": 3,
      "content": "何か問題が発生したらログを確認してください。ログは /var/log/ または (v1.16 からデフォルトのルートレス X の場合) ~/.local/share/xorg/ の中に保存されています。GDM を使っている場合は systemd のジャーナルをチェックしてください [5]。\n\nログファイルの名前は Xorg.n.log という形式を取ります: n はディスプレイ番号です。デフォルト設定のシングルユーザーマシンの場合は Xorg.0.log を確認すれば良いですが、他の構成の場合は見るべきログは違うかもしれません。X サーバーのセッションが起動したときのタイムスタンプと X が起動するのに使われたコンソールを確認することで適切なログファイルを見分けられます。例:\n\n```\n$ grep -e Log -e tty Xorg.0.log\n```\n\n```\n[    40.623] (==) Log file: \"/home/archuser/.local/share/xorg/Xorg.0.log\", Time: Thu Aug 28 12:36:44 2014\n[    40.704] (--) controlling tty is VT number 1, auto-enabling KeepTty\n```\n\n```\n$ tail -f ~/.local/share/xorg/Xorg.0.log | ts\n```\n\n- ログファイルの中に (EE) で始まる行が存在しないか確認してください。(EE) はエラーです。また、(WW) は警告です。\n- $HOME に存在する .xinitrc ファイルが空の場合、X を起動するにはファイルを削除するか正しく編集する必要があります。空の場合、X は画面を表示せず Xorg.0.log にエラーも出力されません。ファイルを削除するとデフォルトの X 環境が起動します。\n- 画面がブラックアウト場合、異なる仮想コンソールに切り替えて(例: Ctrl+Alt+F6)、スクリーンの出力無しで root としてログインできます。そうするには、root と入力し(その後 Enter を押して)、root のパスワードを入力してください(その後、再び Enter を押してください)。\n\n```\n# pkill -x X\n```\n\n```\n# reboot\n```\n\n- キーボード・マウス・タッチパッドなどに問題がおこる場合は カテゴリ:入力デバイス 内のそれぞれのページを見て下さい。\n- AMDGPU、Intel Graphics、NVIDIA の記事に問題の解決方法が載ってないか調べてください。\n\n"
    },
    {
      "title": "一部またはすべてのユーザで黒画面、No protocol specified、Resource temporarily unavailable",
      "level": 3,
      "content": "X は設定ファイルと一時ファイルをユーザーのホームディレクトリに作成します。あなたのホームディレクトリが入っているパーティションに十分な空き容量があることを確認してください。悪いことに、ディスク容量が不足していることを X サーバーは何も知らせません。\n\n"
    },
    {
      "title": "Matrox カードで DRI が停止する",
      "level": 3,
      "content": "Matrox カードを使っていて Xorg をアップグレードすると DRI が停止する場合、次の行を xorg.conf のビデオカードの Device セクションに追加してください:\n\n```\nOption \"OldDmaInit\" \"On\"\n```\n\n"
    },
    {
      "title": "フレームバッファモード問題",
      "level": 3,
      "content": "以下のログメッセージを残して X の起動が失敗する場合:\n\n```\n(WW) Falling back to old probe method for fbdev\n(II) Loading sub module \"fbdevhw\"\n(II) LoadModule: \"fbdevhw\"\n(II) Loading /usr/lib/xorg/modules/linux//libfbdevhw.so\n(II) Module fbdevhw: vendor=\"X.Org Foundation\"\n       compiled for 1.6.1, module version=0.0.2\n       ABI class: X.Org Video Driver, version 5.0\n(II) FBDEV(1): using default device\n\nFatal server error:\nCannot run in framebuffer mode. Please specify busIDs for all framebuffer devices\n```\n\nxf86-video-fbdev パッケージをアンインストールしてください。\n\n"
    },
    {
      "title": "プログラムが \"font '(null)'\" を要求する",
      "level": 3,
      "content": "エラーメッセージ: unable to load font `(null)'\n\nいくつかのプログラムはビットマップフォントでだけ動作します。２つの主要なビットマップフォントのパッケージがあります、xorg-fonts-75dpi と xorg-fonts-100dpi です。両方は必要ありません、片方だけで十分です。どちらがあなたに適しているか調べるには、xorg-xdpyinfo の xdpyinfo を試してください:\n\n```\n$ xdpyinfo | grep resolution\n```\n\nそして、出力された値に最も近い方のフォントを使用してください。\n\n"
    },
    {
      "title": "リカバリ: GUI ログインの前に Xorg を無効化",
      "level": 3,
      "content": "Xorg を自動的に起動するように設定していて、なんらかの理由でログイン・ディスプレイマネージャが表示される前に Xorg が起動するのを防ぎたい場合（例えば、システムを間違って設定したせいで Xorg がマウスやキーボード入力を受け付けない場合）、以下の2つの方法でこれを達成できます。\n\n- デフォルトのターゲットを rescue.target に変更してください。systemd#起動時のデフォルトターゲットを変更する を参照。\n- 誤ってシステムを設定して Xorg を使えなくしただけでなく、GRUB メニューの待ち時間をゼロに設定、または起動時から Xorg を無効にするのに GRUB を使えない場合、Arch Linux のライブ CD を使って下さい。インストールガイドに従ってインストールした Arch Linux をマウントして chroot します。もしくは、Ctrl+Alt + function キー (通常は X によって使用されていない F1 から F7) を使って tty を切り替えてから root でログインして以下を行います。\n\n設定に応じて、以下の作業のどれか、または複数を行う必要があります:\n\n- ディスプレイマネージャを無効化。\n- X の自動起動を無効化。\n- ~/.xinitrc の名前を変更するか exec 行をコメントアウト。\n\n"
    },
    {
      "title": "\"su\" で X クライアントの起動が失敗する",
      "level": 3,
      "content": "\"Client is not authorized to connect to server\" と表示される場合、次の行を /etc/pam.d/su と /etc/pam.d/su-l に追加して下さい:\n\n```\nsession        optional        pam_xauth.so\n```\n\npam_xauth が正しく環境変数を設定し xauth キーを管理します。\n\n"
    },
    {
      "title": "X が起動できない: Keyboard initialization failed",
      "level": 3,
      "content": "ファイルシステム(特に /tmp)が満杯の場合、startx は失敗します。ログファイルには以下のように出力されます:\n\n```\n(EE) Error compiling keymap (server-0)\n(EE) XKB: Could not compile keymap\n(EE) XKB: Failed to load keymap. Loading default keymap instead.\n(EE) Error compiling keymap (server-0)\n(EE) XKB: Could not compile keymap\nXKB: Failed to compile keymap\nKeyboard initialization failed. This could be a missing or incorrect setup of xkeyboard-config.\nFatal server error:\nFailed to activate core devices.\n...\n```\n\n関連するファイルシステムにいくらかの空き領域を作れば X は起動するでしょう。\n\n"
    },
    {
      "title": "動画を視聴しようとすると緑色の画面が表示される",
      "level": 3,
      "content": "色深度の設定が間違っています。例えば、16ではなく24に設定する必要があります。\n\n"
    },
    {
      "title": "SocketCreateListener エラー",
      "level": 3,
      "content": "SocketCreateListener() failed というエラーメッセージを吐いて X が落ちてしまう場合、/tmp/.X11-unix 内のソケットファイルを削除する必要があります。この問題は、(例えば xorg.conf を生成するために)前回に Xorg を root として実行した場合に発生することがあります。\n\n"
    },
    {
      "title": "プログラムを root として実行しようとした際に Invalid MIT-MAGIC-COOKIE-1 key",
      "level": 3,
      "content": "このエラーは、現在のユーザのみが X サーバへのアクセス権を持っていることを意味しています。解決策は root にアクセス権を与えることです:\n\n```\n$ xhost +si:localuser:root\n```\n\nこのコマンドは、root 以外のユーザに X へのアクセス権を与える際にも使用できます。\n\n"
    },
    {
      "title": "Xorg-server Fatal server error: (EE) AddScreen/ScreenInit",
      "level": 3,
      "content": "Xorg サーバがランダムに動作しなくなり、Xorg のログに以下が出力される場合:\n\n```\nsystemd-logind: failed to take device /dev/dri/card0: Operation not permitted\n...\nAddScreen/ScreenInit failed for driver 0\n```\n\nこの問題は systemd issue 13943 により発生する場合があります。KMS の早期起動をセットアップしてください。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Xplain - X Window System の詳しい解説\n- Xorg(1)\n- Prepare for LPIC-1 exam 2 - topic 106.1: X11 - アーキテクチャ、#設定、デスクトップ環境、リモートでの使用、Wayland に関して簡単に説明しています。\n- xorg.conf(5)\n- Gentoo:Xorg/Guide/ja#設定\n\n"
    }
  ]
}