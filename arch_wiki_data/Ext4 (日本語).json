{
  "title": "Ext4 (日本語)",
  "url": "https://wiki.archlinux.org/title/Ext4_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- ファイルシステム\n- Ext3\n\nExt4 は Linux で一番よく使われているファイルシステム、Ext3 の発展版です。多くの点で、Ext3 から Ext4 になって Ext2 から Ext3 に進んだときよりも大きな改善がされています。Ext3 では Ext2 にジャーナリングを追加したのがほとんどでしたが、Ext4 ではファイルデータを保存するファイルシステムの重要なデータ構造にメスが入っています。その結果、改良された設計、優れたパフォーマンス、信頼性、機能性を備えたファイルシステムが誕生しました (ソース: Ext4 - Linux Kernel Newbies)\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 新しく ext4 ファイルシステムを作成 1.1 Bytes-per-inode 比率 1.2 予約ブロック\n- 2 ext2/ext3 から ext4 に移行 2.1 ext2/ext3 パーティションを変換せずに ext4 としてマウント 2.1.1 理由 2.1.2 方法 2.2 ext2/ext3 パーティションを ext4 に変換 2.2.1 理由 2.2.2 方法\n- 3 パフォーマンスの向上 3.1 アクセス時間の更新を無効にする 3.2 コミット間隔の増加 3.3 バリアとパフォーマンス 3.4 ジャーナリングの無効化 3.5 外部ジャーナルを使用してパフォーマンスを最適化する\n- 4 ヒントとテクニック 4.1 ファイルベースの暗号化を使用する 4.2 メタデータチェックサムを有効化する 4.3 LVM を使用する場合のメンテナンス 4.4 fast_commit を有効化 4.5 大文字と小文字を区別しないモードを有効にする\n- 5 参照\n\n- 1.1 Bytes-per-inode 比率\n- 1.2 予約ブロック\n\n- 2.1 ext2/ext3 パーティションを変換せずに ext4 としてマウント 2.1.1 理由 2.1.2 方法\n- 2.2 ext2/ext3 パーティションを ext4 に変換 2.2.1 理由 2.2.2 方法\n\n- 2.1.1 理由\n- 2.1.2 方法\n\n- 2.2.1 理由\n- 2.2.2 方法\n\n- 3.1 アクセス時間の更新を無効にする\n- 3.2 コミット間隔の増加\n- 3.3 バリアとパフォーマンス\n- 3.4 ジャーナリングの無効化\n- 3.5 外部ジャーナルを使用してパフォーマンスを最適化する\n\n- 4.1 ファイルベースの暗号化を使用する\n- 4.2 メタデータチェックサムを有効化する\n- 4.3 LVM を使用する場合のメンテナンス\n- 4.4 fast_commit を有効化\n- 4.5 大文字と小文字を区別しないモードを有効にする\n\n"
    },
    {
      "title": "新しく ext4 ファイルシステムを作成",
      "level": 2,
      "content": "e2fsprogs を インストール します。\n\nパーティションをフォーマットするには次を実行:\n\n```\n# mkfs.ext4 /dev/partition\n```\n\n- オプションについては mke2fs(8) の man ページを見て下さい。/etc/mke2fs.conf を編集すればデフォルトのオプションを見たり設定できます。\n- サポートされている場合は、メタデータチェックサム を有効にすることをお勧めします。\n\n"
    },
    {
      "title": "Bytes-per-inode 比率",
      "level": 3,
      "content": "mke2fs はひとつの inode に対してディスク上に bytes-per-inode バイト分の領域を作成します。bytes-per-inode 比率を大きくすることで、作成される inode は少なくなります。詳しくは mke2fs(8) を参照。\n\n新しいファイルやディレクトリ、シンボリックリンクなどを作成するとき inode が最低でもひとつは必要です。inode の数が少なすぎると、たとえディスクに空き容量があったとしてもファイルシステムにファイルを作成できなくなります。\n\nファイルシステムを作成した後に bytes-per-inode 比率や inode の数を変更することはできないため、ファイルが作成できなくなってしまわないように mkfs.ext4 はデフォルトでは比率を低くして inode に対して16384バイト (16Kb) を割り当てます。\n\nしかしながら、1GB 以上のファイルが多数存在してファイルの平均容量がメガバイト級になるような使い方をしているパーティションの場合、inode の数が多すぎてファイルの作成では inode の限界に絶対に達しないということになります。\n\n未使用の inode にも256バイト取られるのでディスク領域の無駄使いです (256バイトという数字は /etc/mke2fs.conf で設定されていますが変更してはいけません) 256バイトでも数百万の inode に換算するとギガバイト単位で容量を無駄にしていることになります。\n\ndf と df -i を実行したときの {I}Use% の値を比較することでどれくらい無駄になっているのか確認できます:\n\n```\n$ df -h /home\n```\n\n```\nFilesystem              Size    Used   Avail  Use%   Mounted on\n/dev/mapper/lvm-home    115G    56G    59G    49%    /home\n```\n\n```\n$ df -hi /home\n```\n\n```\nFilesystem              Inodes  IUsed  IFree  IUse%  Mounted on\n/dev/mapper/lvm-home    1.8M    1.1K   1.8M   1%     /home\n```\n\nbytes-per-inode 比率を変更するには、-T usage-type オプションを使用します。/etc/mke2fs.conf で定義されたタイプを使用してファイルシステムの利用方法を指定できます。largefile や largefile4 タイプは inode に対してそれぞれ 1 MiB と 4 MiB という大きな容量を割り当てます。以下のように使うことができます:\n\n```\n# mkfs.ext4 -T largefile /dev/device\n```\n\n-i オプションを使って bytes-per-inode 比率を直接設定することもできます。例えば -i 2097152 なら 2 MiB、-i 6291456 なら 6 MiB になります。\n\n"
    },
    {
      "title": "予約ブロック",
      "level": 3,
      "content": "デフォルトでは、ファイルシステムの 5% はフラグメントが起こらないように root ユーザー用に予約されます。非特権のプロセスがファイルシステムに書き込めなくなってからも root が使用しているデーモンは正しく動作し続けることができます (詳しくは mke2fs(8) を参照)。\n\n最近の大容量ディスクでは、パーティションを長期アーカイブとして使用したり、システム運用に重要でない場合(/homeなど)必要以上に大きな値を設定します。予約ブロックに関する ext4 開発者の Ted Ts'o の意見は このメール を、このトピックに関する一般的な背景は このスーパーユーザの回答 を参照してください。\n\nパーティションが以下の条件を満たしているならば、ディスク容量を増やすために予約ブロックの割合を減らしても大抵は問題ありません:\n\n- パーティションがとても大きい (例えば 50GB 以上)\n- 長期保存用のアーカイブとして使っている、頻繁にファイルを作成したり削除することがない。\n\next4 関連のユーティリティを使うときに -m オプションで予約ブロックの割合を指定できます。\n\nファイルシステムの作成時に予約ブロックを全く作成しないようにするには:\n\n```\n# mkfs.ext4 -m 0 /dev/device\n```\n\nパーティションの予約ブロックの割合を 1% に設定するには:\n\n```\n# tune2fs -m 1 /dev/device\n```\n\n予約ブロック数をギガバイト単位の絶対サイズに設定する場合は、-r を使用します。\n\n```\n# tune2fs -r $((ngigs * 1024**3 / blocksize)) /dev/device\n```\n\nblocksize はファイルシステムのブロックサイズをバイト単位で指定します。これはほとんどの場合 4096 ですが、念のため確認することができます。\n\n```\n# tune2fs -l /dev/device | egrep '^Block size:'\n```\n\n```\nBlock size:               4096\n```\n\n$(()) 構文は、数式展開のための構文です。この構文は bash と zsh では動作しますが、fish では動作しません。fish では、このような構文になります。\n\n```\n# tune2fs -r (math 'ngigs * 1024^3 / blocksize') /dev/device\n```\n\nこれらのコマンドは、現在マウントされているファイルシステムに適用することができ、変更は即座に反映されます。デバイス名は findmnt(8) で調べることができます。\n\n```\n# tune2fs -m 1 \"$(findmnt -no SOURCE /the/mount/point)\"\n```\n\n現在の予約ブロック数を問い合わせる場合。\n\n```\n# tune2fs -l /dev/mapper/proxima-root | egrep '^Reserved block count:'\n```\n\n```\nReserved block count:     2975334\n```\n\nこれはブロック数なので、これにファイルシステムのブロックサイズを掛けて、バイト数やギガバイト数を得る必要があります。2975334 * 4096 / 1024**3 = 11.34 GiB です。\n\n"
    },
    {
      "title": "理由",
      "level": 4,
      "content": "ext4 を完全に変換する案と ext2/ext3 をそのまま使用する案の折衷案として、既存の ext2/ext3 パーティションを ext4 としてマウントする方法があります。\n\n利点:\n\n- 互換性 (ext2/ext3 としてファイルシステムをマウントできます) – ext4 のサポートがないオペレーティングシステムからもファイルシステムを読み込むことが可能です (例: Windows の ext2/ext3 ドライバー)\n- パフォーマンスが向上 (ext4 パーティションに完全に変換するのよりは劣ります) – 詳しくは [1] や [2] を見てください。\n\n欠点:\n\n- ext4 の機能を全て活用することはできません (マルチブロックアロケーションや遅延アロケーションなどのディスクフォーマットに変更を与える機能は使えません)\n\n"
    },
    {
      "title": "方法",
      "level": 4,
      "content": "1. /etc/fstab を編集して ext4 としてマウントしたいパーティションの 'type' を ext2/ext3 から ext4 に変更してください。\n1. 変更したパーティションを再マウントします。\n\n"
    },
    {
      "title": "理由",
      "level": 4,
      "content": "ext4 の能力を活かすには、非可逆の変換をする必要があります。\n\n利点:\n\n- パフォーマンスの向上と新機能 – 詳しくは [3] や [4] を見てください。\n\n欠点:\n\n- /boot パーティションなど、静的なファイルしか存在しない場合、新機能を使うメリットはありません。さらに、ジャーナリングによって性能がむしろ落ちる可能性もあります。\n- 一方通行 (ext4 パーティションを ext2/ext3 に'ダウングレード'することはできません) ただしエクステントなどのオプションを有効にしなければ後方互換性を確保できます。\n\n"
    },
    {
      "title": "方法",
      "level": 4,
      "content": "以下の手順は カーネルドキュメント と フォーラムスレッド から引用しています。\n\n- システムのルートパーティションを変換する場合、再起動時にフォールバックの initramfs が使えるようになっていることを確認してください。また、変換する前に /etc/mkinitcpio.conf の MODULES 行に ext4 を追加して mkinitcpio -p linux でデフォルトの initramfs を再作成してください。\n- 分割している /boot パーティションを変換する場合、ブートローダーが ext4 からの起動に対応していることを確認してください。\n\n1. バックアップを行なって下さい。ext4 に変換する ext3 パーティションに存在するデータを全てバックアップします。特に / (root) パーティションをバックアップする場合は、Clonezilla が役に立ちます。\n1. /etc/fstab を編集して ext4 に変換するパーティションの 'type' を ext3 から ext4 に変換してください。\n1. (必要であれば) ライブメディアを起動します。e2fsprogs で変換を行う際はドライブがマウントされていない状態になっている必要があります。ドライブの root (/) パーティションを変換するときは、他のライブメディアから起動して変換するのが一番簡単です。\n1. パーティションがマウントされていないことを確認してください\n1. ext2 パーティションを変換する場合、まずは tune2fs -j /dev/sdxX を root で実行してジャーナルを追加して ext3 パーティションに変換してください。\n1. tune2fs -O extent,uninit_bg,dir_index /dev/sdxX を root で実行 (/dev/sdxX は変換するパーティションのパスに置き換えて下さい、例: /dev/sda1)。ext4 に変換されます (不可逆です)\n1. root で fsck -f /dev/sdxX を実行。 ファイルシステムのチェックを実行しないとファイルシステムを読み込めなくなります。fsck の実行は必須です。グループ記述子のチェックサムエラーが発見されます。これは仕様通りの動作です。-f オプションはファイルシステムに問題がない場合でも強制的にチェックを実行します。-p オプションを使用して自動修復させることもできます (オプションを使用しない場合、エラーに対して入力を求められます)\n1. 推奨: パーティションをマウントして e4defrag -c -v /dev/sdxX を実行。 ファイルシステムが ext4 に変換されても、変換前に書き込まれたファイルは ext4 のエクステントオプションを利用することができません。エクステントオプションは巨大なファイルの操作を高速化しフラグメンテーションを減らしてファイルシステムのチェック時間を短縮します。ext4 を活用するには、全てのファイルをディスクに再書き込みする必要があります。e4defrag を使うことで問題を解決できます。\n1. Arch Linux を再起動してください。\n\n- ファイルシステムのチェックを実行しないとファイルシステムを読み込めなくなります。fsck の実行は必須です。グループ記述子のチェックサムエラーが発見されます。これは仕様通りの動作です。-f オプションはファイルシステムに問題がない場合でも強制的にチェックを実行します。-p オプションを使用して自動修復させることもできます (オプションを使用しない場合、エラーに対して入力を求められます)\n\n- ファイルシステムが ext4 に変換されても、変換前に書き込まれたファイルは ext4 のエクステントオプションを利用することができません。エクステントオプションは巨大なファイルの操作を高速化しフラグメンテーションを減らしてファイルシステムのチェック時間を短縮します。ext4 を活用するには、全てのファイルをディスクに再書き込みする必要があります。e4defrag を使うことで問題を解決できます。\n\n"
    },
    {
      "title": "アクセス時間の更新を無効にする",
      "level": 3,
      "content": "ext4ファイルシステムは、ファイルが最後にアクセスされた時刻に関する情報を記録しますが、これには記録に伴うコストがあります。noatime や関連するオプションについては、fstab#atime オプション を参照してください。\n\n"
    },
    {
      "title": "コミット間隔の増加",
      "level": 3,
      "content": "commit オプションで長い時間遅延を提供することにより、データとメタデータの同期間隔を増やすことができます。\n\nデフォルトの5秒は、電源が失われた場合、最新の5秒の作業が失われることを意味します。 5秒ごとにすべてのデータ/ジャーナルを物理メディアに完全に同期します。 ただし、ジャーナリングのおかげで、ファイルシステムが損傷することはありません。 次の fstab は、 commit の使用法を示しています。\n\n```\n/etc/fstab\n```\n\n```\n/dev/sda5    /    ext4    defaults,commit=60    0    1\n```\n\n"
    },
    {
      "title": "バリアとパフォーマンス",
      "level": 3,
      "content": "Ext4 はデフォルトで書き込みバリアを有効にします。これにより、書き込みキャッシュの電源が失われた場合でも、ファイルシステムのメタデータがディスク上に正しく書き込まれ、順序付けされることが保証されます。これには、特に fsync を頻繁に使用するアプリケーションや、小さなファイルを多数作成および削除するアプリケーションの場合、パフォーマンスにコストが伴います。何らかの方法でバッテリーバックアップが行われている書き込みキャッシュを持つディスクの場合、バリアを無効にするとパフォーマンスが安全に向上する可能性があります。\n\nバリアをオフにしたいときは /etc/fstab の変更したいファイルシステムに barrier=0 オプションを追加してください。例:\n\n```\n/etc/fstab\n```\n\n```\n/dev/sda5    /    ext4    defaults,barrier=0    0    1\n```\n\n"
    },
    {
      "title": "ジャーナリングの無効化",
      "level": 3,
      "content": "ext4 を使用してジャーナルを無効にするには、マウントされていないディスクで次のコマンドを使用します。\n\n```\n# tune2fs -O \"^has_journal\" /dev/sdXN\n```\n\n"
    },
    {
      "title": "外部ジャーナルを使用してパフォーマンスを最適化する",
      "level": 3,
      "content": "Fast commits for ext4 の記事のイントロダクションは、マウントオプション data=journal や data=writeback が、デフォルトの data=ordered 動作モードと比較して、どのように全体的な ext4 のパフォーマンスを高速化するかを簡潔にまとめています。さらに、ジャーナリング自体は、journal_async_commit マウントオプションを追加することで高速化できます。\n\nさらに別のオプションとして、新しいジャーナルフォーマットを使用する方法があります。詳細は #fast_commit を有効化 を参照してください。\n\n非デフォルトの data= オプションを使用する場合、ジャーナル専用のデバイスを使用することで、場合によってはファイル操作を高速化できることがあります。例えば、データ自体に比較的遅いデバイスを使用し、別の(より高速だが小さい)デバイスをジャーナル用に使用する場合です。別のジャーナルデバイスを設定するには:\n\n```\n# mke2fs -O journal_dev /dev/journal_device\n```\n\njournal_device を ext4_device のジャーナルとして割り当てるには、次を使用します。\n\n```\n# tune2fs -J device=/dev/journal_device /dev/ext4_device\n```\n\nもし ext4_device に新しいファイルシステムを作成したい場合は、tune2fs の代わりに mkfs.ext4 を使用できます。\n\n"
    },
    {
      "title": "ファイルベースの暗号化を使用する",
      "level": 3,
      "content": "Linux 4.1 以降、ext4 はファイル暗号化をネイティブにサポートしています。 fscrypt の記事を参照してください。 暗号化はディレクトリレベルで適用され、ディレクトリごとに異なる暗号化キーを使用できます。 これは、ブロックデバイスレベルの暗号化である dm-crypt と、スタック暗号化ファイルシステムである eCryptfs の両方とは異なります。\n\n"
    },
    {
      "title": "メタデータチェックサムを有効化する",
      "level": 3,
      "content": "ファイルシステムが e2fsprogs で作成されている場合。1.43 (2016) 以降では、メタデータチェックサムがデフォルトで有効になっています。既存のファイルシステムを変換して、メタデータチェックサムのサポートを有効にすることができます。\n\nCPU が SSE 4.2 をサポートしている場合、crc32c_intel が有効であることを確認してください。ハードウェアアクセラレーションによる CRC32C アルゴリズム [5] を有効にするために カーネルモジュール がロードされています。もしそうでなければ、代わりに crc32c_generic モジュールをロードしてください。\n\nメタデータチェックサムの詳細については、ext4 wiki を参照してください。\n\n```\n# dumpe2fs -h /dev/path/to/disk\n```\n\nまず、e2fsck を使用してパーティションをチェックし、最適化する必要があります。\n\n```\n# e2fsck -Df /dev/path/to/disk\n```\n\nファイルシステムを64ビットに変換します。\n\n```\n# resize2fs -b /dev/path/to/disk\n```\n\n最後に、チェックサムサポートを有効にします。\n\n```\n# tune2fs -O metadata_csum /dev/path/to/disk\n```\n\n検証します:\n\n```\n# dumpe2fs -h /dev/path/to/disk | grep features:\n```\n\n```\nFilesystem features:      has_journal ext_attr resize_inode dir_index filetype extent 64bit flex_bg sparse_super large_file huge_file dir_nlink extra_isize metadata_csum\n```\n\n"
    },
    {
      "title": "LVM を使用する場合のメンテナンス",
      "level": 3,
      "content": "e2scrub ツールは、ext4ファイルシステムのメタデータをチェックするためのツールで、特に LVM (Logical Volume Manager) の論理ボリュームで使用されている場合に適用されます。このチェックを行うには、ボリュームグループに256MiBの未割り当てスペースが必要です。これは、ツールがチェック用にスナップショットを作成するためです。\n\ne2scrub(8) マニュアルによると、このツールはエラーを修復するものではなく、エラーを報告し、次回のマウント前に e2fsck(e2fsck(8) を参照)の実行が必要であることをファイルシステムにマークします。\n\nこのチェックは自動化可能で、例えば、パッケージに含まれる e2scrub_all.timer ユニットを有効化することで設定できます。\n\nなお、必要な256MiBの未割り当てスペースが不足している場合は、LVM#論理ボリュームとファイルシステムのサイズを一度に変更する を参照してください。\n\n"
    },
    {
      "title": "fast_commit を有効化",
      "level": 3,
      "content": "ext4の \"fast commits\" 機能は、新しい軽量なジャーナリング方式を導入します。この機能は、ext4 ファイルシステムのパフォーマンスを大幅に向上させることが期待されています。[6]\n\n新しいファイルシステムでこの機能を有効にするには、fast_commit を -O ファイルシステムオプション引数に含めます。\n\n既存のファイルシステムでこの機能を有効にするには、次のコマンドを実行します:\n\n```\n# tune2fs -O fast_commit /dev/drivepartition\n```\n\n現在の構成または変更を確認するには:\n\n```\n# tune2fs -l /dev/drivepartition | grep features\n```\n\n既存のファイルシステムでこの機能を無効にするには、次のコマンドを実行します:\n\n```\n# tune2fs -O '^fast_commit' /dev/drivepartition\n```\n\n"
    },
    {
      "title": "大文字と小文字を区別しないモードを有効にする",
      "level": 3,
      "content": "- casefold 機能が有効にされている場合、それは確実に無効化することができません(tune2fs の潜在的なバグのため)有効化する前に、以下の制限に注意してください\n- GRUB は現在、ext4 の casefold 機能をサポートしていません。GRUB バグ#56897 を参照してください。この機能を GRUB が読み取る必要があるファイルシステムで有効にすると、システムは起動不可能になり、unknown filesystem という無意味なエラーが表示されます。たとえ実際にディレクトリがその機能を使用していなくてもです。\n- casefold 機能は overlayfs と互換性がないため、Docker や Podman などのコンテナソフトウェアがそのファイルシステムで動作しなくなる可能性があります。また、systemd-sysext(8) 拡張イメージなどの高度な systemd 機能も使用できなくなる場合があります。\n\nExt4 は大文字と小文字を区別しないモードで使用でき、Wine で実行されるアプリケーションやゲームのパフォーマンスを向上させることができます。この機能はファイルシステム全体には影響しません。大文字と小文字を区別しない属性が有効になっているディレクトリにのみ影響します。\n\nまず、ファイルシステムでこの機能を有効にします:\n\n```\n# tune2fs -O casefold /dev/path/to/disk\n```\n\nこれで、任意のディレクトリで大文字と小文字を区別しない属性を有効にできるようになります:\n\n```\n$ chattr +F /mnt/partition/case-insensitive-directory\n```\n\nディレクトリは空である必要があり、他の場所からサブディレクトリを移動させても、その属性は継承されないことに注意してください。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- 公式 Ext4 wiki\n- Ext4 wiki の Ext4 ディスクレイアウト\n- LWN の Ext4 暗号化 記事\n- ext4 暗号化のカーネルコミット [7] [8]\n- e2fsprogs 変更履歴\n- Ext4 メタデータチェックサム\n\n"
    }
  ]
}