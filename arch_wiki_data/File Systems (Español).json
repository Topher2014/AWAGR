{
  "title": "File Systems (Español)",
  "url": "https://wiki.archlinux.org/title/File_Systems_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2020-12-12** \n\nArtículos relacionados\n\n- Particionado\n- lsblk\n- Permisos y atributos de archivo\n- fsck\n- lsblk\n- List of applications/Utilities#Mount tools\n- Montaje de una partición dentro de una imagen de disco raw\n- udev\n- udisks\n- umask\n- Dispositivos de almacenamiento USB\n\nDe Wikipedia:\n\nLas particiones individuales de la unidad se pueden configurar utilizando uno de los muchos y diferentes sistemas de archivos disponibles. Cada uno tiene sus propias ventajas, desventajas e idiosincrasias únicas. A continuación se ofrece una breve descripción de los sistemas de archivos compatibles; los enlaces son a páginas de Wikipedia que proporcionan mucha más información.\n\n"
    },
    {
      "title": "Tipos de sistemas de archivos",
      "level": 2,
      "content": "Véase filesystems(5) para una visión general y Wikipedia:es:Anexo:Comparación de sistemas de archivos para una comparación detallada de características. Los sistemas de archivos soportados por el kernel están listados en /proc/filesystems.\n\nTable content:\nSistema de archivos | Orden para crearlo | Utilidades de usuario | Archiso [1] | Documentación del kernel [2] | Notas\nBtrfs | mkfs.btrfs(8) | btrfs-progs | Sí | btrfs.html | estado de su estabilidad\nVFAT | mkfs.fat(8) | dosfstools | Sí | vfat.html | Sistema de archivos de Windows 9x\nexFAT | mkfs.exfat(8) | exfatprogs | Sí |  | Sistema de archivos nativo desde linux 5.4. [3]\nmkexfatfs(8) | exfat-utils | No | N/D (basado en FUSE) | \nF2FS | mkfs.f2fs(8) | f2fs-tools | Sí | f2fs.html | dispositivos basados ​​en flash\next3 | mke2fs(8) | e2fsprogs | Sí | ext3.html | \next4 | mke2fs(8) | e2fsprogs | Sí | ext4.html | \nHFS | mkfs.hfsplus(8) | hfsprogsAUR | No | hfs.html | sistema de archivos Mac OS clásico\nHFS+ | mkfs.hfsplus(8) | hfsprogsAUR | No | hfsplus.html | sistema de archivos de macOS (8-10.12)\nJFS | mkfs.jfs(8) | jfsutils | Sí | jfs.html | \nNILFS2 | mkfs.nilfs2(8) | nilfs-utils | Sí | nilfs2.html | \nNTFS | mkfs.ntfs(8) | ntfs-3g | Sí | N/D (basado en FUSE) | sistema de archivos de Windows NT\nReiserFS | mkfs.reiserfs(8) | reiserfsprogsAUR | Sí |  | \nUDF | mkfs.udf(8) | udftools | Sí | udf.html | \nXFS | mkfs.xfs(8) | xfsprogs | Sí | xfs.html xfs-delayed-logging-design.html[enlace roto 2024-03-03] xfs-self-describing-metadata.html[enlace roto 2024-03-03] | \n\nxfs.html xfs-delayed-logging-design.html[enlace roto 2024-03-03] xfs-self-describing-metadata.html[enlace roto 2024-03-03]\n\nTable content:\nSistema de archivos | Orden para crearlo | Parche del kernel | Utilidades de usuario | Notas\nAPFS | mkapfs(8) | linux-apfs-dkms-gitAUR[enlace roto: package not found] | apfsprogs-gitAUR | sistema de archivos macOS (10.13 y posterior). Solo lectura, experimental.\nBcachefs | bcachefs(8) | linux-bcachefs-gitAUR | bcachefs-tools-gitAUR | \nReiser4 | mkfs.reiser4(8) |  | reiser4progsAUR | \nZFS |  | zfs-linuxAUR | No | N/D (adaptación OpenZFS) | \n\n"
    },
    {
      "title": "Journaling",
      "level": 3,
      "content": "Todos los sistemas de archivos anteriores con la excepción de exFAT, ext2, FAT16/32, Reiser4 (opcional), Btrfs y ZFS, utilizan journaling. Journaling proporciona tolerancia a fallos al registrar los cambios antes de que se confirmen en el sistema de archivos. En el caso de un fallo del sistema o de alimentación, estos sistemas de archivos son más rápidos para volver a estar en línea y es menos probable que se corrompan. El registro se realiza en un área dedicada del sistema de archivos.\n\nNo todas las técnicas Journaling son iguales. Ext3 y ext4 ofrecen data-mode journaling, que registra datos y metadatos, así como posibilidad de registrar solo los cambios de metadatos. Data-mode journaling viene con una penalización de velocidad y no está activada de forma predeterminada. Del mismo modo, Reiser4 ofrece el llamado \"modelos de transacción\" que no solo cambian las características que proporciona, sino también en su modo de registro en diario. Utiliza diferentes técnicas Journaling: un modelo especial llamado registros errantes que elimina la necesidad de escribir en el disco dos veces, escritura en cualquier lugar: un enfoque puro de copia en escritura (en su mayoría equivalente al valor predeterminado de btrfs pero con un diseño en \"árbol\" fundamentalmente diferente) y un enfoque combinado llamado híbrido que alterna heurísticamente entre los dos anteriores.\n\nNote: **node41** \n\nLos otros sistemas de archivos proporcionan ordered-mode journaling, que solo registra metadatos. Si bien todo journaling devolverá un sistema de archivos a un estado válido después de una caída, data-mode journaling ofrece la mayor protección contra la corrupción y la pérdida de datos. Sin embargo, existe un compromiso en el rendimiento del sistema, ya que data-mode journaling realiza dos operaciones de escritura: primero en el journal y luego en el disco (que Reiser4 evita con su función de \"registros errantes\"). Al elegir el tipo de sistema de archivos, se debe considerar el equilibrio entre la velocidad del sistema y la seguridad de los datos. Reiser4 es el único sistema de archivos que, por diseño, funciona con una atomicidad completa y también proporciona sumas de verificación tanto para meta datos como para datos en línea (las operaciones ocurren por completo, o no lo hacen y no corrompen ni destruyen datos debido a operaciones que ocurren a medias) y el diseño es mucho menos propenso a la pérdida de datos con respecto a otros sistemas de archivos como Btrfs.\n\nLos sistemas de archivos basados ​​en copy-on-write (también conocido como escritura en cualquier lugar), como Reiser4, Btrfs y ZFS, no tienen necesidad de usar el journal tradicional para proteger los metadatos, porque nunca se actualizan en el lugar. Aunque Btrfs todavía tiene un árbol de registro similar a journal, solo se utiliza para acelerar fdatasync/fsync.\n\n"
    },
    {
      "title": "Sistemas de archivos basados ​​en FUSE",
      "level": 3,
      "content": "Véase FUSE.\n\n"
    },
    {
      "title": "Sistemas de archivos apilables",
      "level": 3,
      "content": "- eCryptfs — El sistema de archivos de cifrado empresarial es un paquete de software de cifrado de disco para Linux. Se implementa como una capa de cifrado a nivel de sistema de archivos compatible con POSIX, con el objetivo de ofrecer una funcionalidad similar a la de GnuPG a nivel de sistema operativo.\n\n- mergerfs — Un sistema de archivos de unión basado en FUSE.\n\n- mhddfs — Sistema de archivos FUSE Multi-HDD, un sistema de archivos de unión basado en FUSE.\n\n- overlayfs — OverlayFS es un servicio de sistema de archivos para Linux que implementa un montaje de unión para otros sistemas de archivos.\n\n- Unionfs — Unionfs es un servicio de sistema de archivos para Linux, FreeBSD y NetBSD que implementa un montaje de unión para otros sistemas de archivos.\n\n- unionfs-fuse — Una implementación de Unionfs en el espacio de usuario.\n\n"
    },
    {
      "title": "Sistemas de archivos de solo lectura",
      "level": 3,
      "content": "- EROFS — El sistema de archivos de solo lectura mejorado es un sistema de archivos de solo lectura ligero, su objetivo es mejorar el rendimiento y comprimir la capacidad de almacenamiento.\n\n- SquashFS — SquashFS es un sistema de archivos comprimido de solo lectura. SquashFS comprime archivos, inodos y directorios, y admite tamaños de bloque de hasta 1 MB para una mayor compresión.\n\n"
    },
    {
      "title": "Sistemas de archivos agrupados (cluster)",
      "level": 3,
      "content": "- Ceph — Unificado, sistema de almacenamiento distribuido diseñado para un excelente rendimiento, fiabilidad y escalabilidad.\n\n- Glusterfs — Sistema de archivos agrupado capaz de escalar a varios peta-bytes.\n\n- IPFS — Un protocolo de hipermedia de igual a igual (peer-to-peer) para que la web sea más rápida, segura y abierta. IPFS trata de reemplazar a HTTP y construir una mejor web para todos nosotros. Utiliza bloques para almacenar partes de un archivo, cada nodo de red almacena solo el contenido que le interesa, proporciona deduplicación, distribución, sistema escalable limitado solo por los usuarios. (actualmente en alfa)\n\n- MooseFS — MooseFS es un sistema de archivos distribuido en red de escalamiento horizontal tolerante a fallos, de alta disponibilidad y de alto rendimiento.\n\n- OpenAFS — Implementación de código abierto del sistema de archivos distribuido AFS.\n\n- OrangeFS — OrangeFS es un sistema de archivos de red de escalado horizontal diseñado para acceder de forma transparente al almacenamiento en disco multiservidor en paralelo. Ha optimizado el soporte de MPI-IO para aplicaciones paralelas y distribuidas. Simplifica el uso del almacenamiento paralelo no solo para clientes Linux, sino también para Windows, Hadoop y WebDAV. Compatible con POSIX. Parte del kernel de Linux desde la versión 4.6.\n\n- Sheepdog — El sistema de almacenamiento de objetos distribuidos para servicios de volumen y contenedor. Gestiona los discos y nodos de forma inteligente.\n\n- Tahoe-LAFS — Tahoe Least-Authority Filesystem es un sistema de archivos libre y abierto, seguro, descentralizado, tolerante a fallos y distribuido de igual a igual.\n\n"
    },
    {
      "title": "Sistema de archivos de disco compartido",
      "level": 3,
      "content": "- GFS2 — GFS2 permite que todos los miembros de un clúster tengan acceso simultáneo directo al mismo almacenamiento de bloques compartido\n\n- OCFS2 — Oracle Cluster File System (versión 2) es un sistema de archivos de disco compartido desarrollado por Oracle Corporation y publicado bajo la Licencia Pública General GNU\n\n- VMware VMFS — VMFS (Virtual Machine File System) de VMware es utilizado por la suite de virtualización de servidores insignia de la compañía, vSphere.\n\n"
    },
    {
      "title": "Identificar los sistemas de archivos existentes",
      "level": 2,
      "content": "Para identificar los sistemas de archivos existentes, puede utilizar lsblk:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE LABEL     UUID                                 MOUNTPOINT\nsdb\n└─sdb1 vfat   Transcend 4A3C-A9E9\n```\n\nUn sistema de archivos existente, si está presente, se mostrará en la columna FSTYPE. Si está montado, aparecerá en la columna MOUNTPOINT.\n\n"
    },
    {
      "title": "Crear un sistema de archivos",
      "level": 2,
      "content": "Los sistemas de archivos generalmente se crean en una partición, dentro de contenedores lógicos como LVM, RAID y dm-crypt, o en un archivo normal (véase Wikipedia:es:Loop device). Esta sección describe el caso de la partición.\n\nNote: **Haga una copia de seguridad de los datos que desee conservar** \n\n- Después de crear un nuevo sistema de archivos, es improbable que se recuperen los datos almacenados previamente en esta partición. Haga una copia de seguridad de los datos que desee conservar.\n- El propósito de una partición dada puede restringir la elección del sistema de archivos. Por ejemplo, una partición del sistema EFI debe contener un sistema de archivos FAT32, y el sistema de archivos que contiene el directorio /boot debe estar soportado por el cargador de arranque.\n\nAntes de continuar, identifique el dispositivo donde se creará el sistema de archivos y si está montado o no. Por ejemplo:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE   LABEL       UUID                                 MOUNTPOINT\nsda\n├─sda1                      C4DA-2C4D\n├─sda2 ext4                 5b1564b2-2e2c-452c-bcfa-d1f572ae99f2 /mnt\n└─sda3                      56adc99b-a61e-46af-aab7-a6d07e504652\n```\n\nLos sistemas de archivos montados deben ser desmontados antes de continuar. En el ejemplo anterior, existe un sistema de archivos que está en /dev/sda2 y se monta en /mnt. Se desmontaría con:\n\n```\n# umount /dev/sda2\n```\n\nPara encontrar los sistemas de archivos que estén montados, véase #Listar los sistemas de archivos montados.\n\nPara crear un nuevo sistema de archivos, utilice mkfs(8). Véase #Tipos de sistemas de archivos para conocer el tipo exacto, así como las utilidades de espacio de usuario que desee instalar para un sistema de archivos en particular.\n\nPor ejemplo, para crear un nuevo sistema de archivos de tipo ext4 (común para particiones de datos de Linux) en /dev/sda1, ejecute:\n\n```\n# mkfs.ext4 /dev/sda1\n```\n\n- Utilice la opción -L de mkfs.ext4 para especificar una etiqueta de sistema de archivos. e2label se puede utilizar para cambiar la etiqueta en un sistema de archivos existente.\n- Los sistemas de archivos pueden ser redimensionados tras su creación, con ciertas limitaciones. Por ejemplo, el tamaño del sistema de archivos XFS se puede aumentar, pero no se puede reducir. Véase Capacidades de redimensionar y la documentación del sistema de archivos correspondiente para obtener más información.\n\nEl nuevo sistema de archivos ahora se puede montar en el directorio de su elección.\n\n"
    },
    {
      "title": "Montar un sistema de archivos",
      "level": 2,
      "content": "Para montar manualmente el sistema de archivos ubicado en un dispositivo (por ejemplo, una partición) en un directorio, utilice mount(8). Este ejemplo monta /dev/sda1 en /mnt.\n\n```\n# mount /dev/sda1 /mnt\n```\n\nEsto vincula el sistema de archivos en /dev/sda1 en el directorio /mnt, haciendo visible el contenido del sistema de archivos. Todos los datos que existían en /mnt antes de esta acción se vuelven invisibles hasta que se desmonte el dispositivo.\n\nfstab contiene información sobre cómo se deben montar automáticamente los dispositivos, si están presentes. Véase el artículo fstab para obtener más información sobre cómo modificar este comportamiento.\n\nSi se especifica un dispositivo en /etc/fstab y solo se proporciona el dispositivo o el punto de montaje en la línea de órdenes, esa información se utilizará en el montaje. Por ejemplo, si /etc/fstab contiene una línea que indica que /dev/sda1 debe montarse en /mnt, entonces lo siguiente montará automáticamente el dispositivo en esa ubicación:\n\n```\n# mount /dev/sda1\n```\n\no\n\n```\n# mount /mnt\n```\n\nmount contiene varias opciones, muchas de las cuales dependen del sistema de archivos especificado. Las opciones se pueden cambiar, ya sea:\n\n- utilizando opciones en la línea de órdenes con mount\n- editando fstab\n- creando reglas udev\n- compilando el kernel usted mismo\n- o utilizando scripts de montaje específicos del sistema de archivos (situados en /usr/bin/mount.*).\n\nVéase estos artículos relacionados y el artículo del sistema de archivos de interés para obtener más información.\n\n"
    },
    {
      "title": "Listar los sistemas de archivos montados",
      "level": 3,
      "content": "Para listar todos los sistemas de archivos montados utilice findmnt(8):\n\n```\n$ findmnt\n```\n\nfindmnt toma una variedad de argumentos que pueden filtrar la salida y mostrar información adicional. Por ejemplo, puede tomar un dispositivo o punto de montaje como argumento para mostrar solo información sobre lo que se especifica:\n\n```\n$ findmnt /dev/sda1\n```\n\nfindmnt reúne información de /etc/fstab, /etc/mtab, y /proc/self/mounts.\n\n"
    },
    {
      "title": "Desmontar un sistema de archivos",
      "level": 3,
      "content": "Para desmontar un sistema de archivos utilice umount(8). Se puede especificar el dispositivo que contiene el sistema de archivos (por ejemplo, /dev/sda1) o el punto de montaje (por ejemplo, /mnt):\n\n```\n# umount /dev/sda1\n```\n\no\n\n```\n# umount /mnt\n```\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- filesystems(5)\n- systemd-mount(1)\n- Documentación de sistemas de archivos soportados por Linux\n- Wikipedia:es:Sistema de archivos\n- Wikipedia:es:Mount\n\n"
    }
  ]
}