{
  "title": "Bash (Українська)",
  "url": "https://wiki.archlinux.org/title/Bash_(%D0%A3%D0%BA%D1%80%D0%B0%D1%97%D0%BD%D1%81%D1%8C%D0%BA%D0%B0)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Повʼязані статті\n\n- Bash/Функції\n- Bash/Налаштування запрошення\n- Command-line shell (Українська)\n- Змінні середовища\n- Fortune\n- Pkgfile\n- Readline\n\nBash (Bourne-Again SHell) — це командна оболонка та мова програмування від GNU Project. Її назва натякає на попередника — давно застарілу Bourne shell. Bash можна запускати на більшості Unix-подібних операційних систем, зокрема на GNU/Linux.\n\nBash є типовою командною оболонкою в Arch Linux.\n\n"
    },
    {
      "title": "Виклик",
      "level": 2,
      "content": "Робота Bash може змінюватися залежно від способу її виклику. Далі наведено опис різних режимів.\n\nЯкщо Bash запускається через login у TTY, через демон SSH або подібним чином, вона вважається оболонкою входу. Цей режим також можна увімкнути за допомогою параметра командного рядка -l/--login.\n\nBash вважається інтерактивною оболонкою, якщо її стандартний вхід, вихід та помилки підключені до терміналу (наприклад, коли вона запущена у термінальному емуляторі) і якщо вона не була запущена з параметром -c або без аргументів (наприклад, bash скрипт). Усі інтерактивні оболонки виконують /etc/bash.bashrc та ~/.bashrc, тоді як інтерактивні оболонки входу також виконують /etc/profile і ~/.bash_profile.\n\n"
    },
    {
      "title": "Конфігураційні файли",
      "level": 3,
      "content": "Bash намагатиметься виконати набір стартових файлів залежно від способу виклику. Див. розділ Bash Startup Files у керівництві GNU Bash для повного опису.\n\nTable content:\nФайл | Опис | Оболонки входу (див. примітку) | Інтерактивні не-оболонки входу\n/etc/profile | Source застосовує налаштування з /etc/profile.d/*.sh та /etc/bash.bashrc. | Yes | No\n~/.bash_profile | Персональний, виконується після /etc/profile. Якщо цей файл відсутній, перевіряються ~/.bash_login і ~/.profile у такому порядку. Файл-скелет /etc/skel/.bash_profile також застосовує ~/.bashrc. | Yes | No\n~/.bash_logout | Персональний, виконується після виходу з оболонки входу. | Yes | No\n/etc/bash.bash_logout | Залежить від прапорця компіляції -DSYS_BASH_LOGOUT=\"/etc/bash.bash_logout\". Виконується після виходу з оболонки входу. | Yes | No\n/etc/bash.bashrc | Залежить від прапорця компіляції -DSYS_BASHRC=\"/etc/bash.bashrc\". Виконує /usr/share/bash-completion/bash_completion. | No | Yes\n~/.bashrc | Персональний, виконується після /etc/bash.bashrc. | No | Yes\n\n- Оболонки входу можуть бути неінтерактивними, якщо їх викликати з аргументом --login.\n- Хоча інтерактивні не-оболонки входу не виконують ~/.bash_profile, вони все одно успадковують середовище від батьківського процесу (який може бути оболонкою входу). Див. GregsWiki:ProcessManagement#On processes, environments and inheritance для деталей.\n\n"
    },
    {
      "title": "Змінні оболонки та середовища",
      "level": 3,
      "content": "Робота Bash та програм, які в ній виконуються, може бути змінена низкою змінних середовища. Змінні середовища використовуються для зберігання корисних значень, таких як каталоги пошуку команд або браузер, який слід використовувати. Коли запускається нова оболонка чи скрипт, вони успадковують змінні від батьківського процесу, починаючи з внутрішнього набору змінних оболонки[1].\n\nЦі змінні оболонки в Bash можна експортувати, щоб вони стали змінними середовища:\n\n```\nVARIABLE=content\nexport VARIABLE\n```\n\nабо за допомогою скороченого запису:\n\n```\nexport VARIABLE=content\n```\n\nЗмінні середовища зазвичай розміщуються в ~/.profile або /etc/profile, щоб їх могли використовувати інші оболонки, сумісні з Bourne.\n\nДив. Змінні середовища для загальної інформації.\n\n"
    },
    {
      "title": "Командний рядок",
      "level": 2,
      "content": "Командний рядок Bash працює під керуванням бібліотеки Readline. Readline дозволяє використовувати комбінації клавіш в стилі emacs та vi для взаємодії з командним рядком, наприклад для переміщення вперед та назад по словах, видаленні слів і тд.До того ж Readline відповідає за зберігання виконаних команд, та створювати макроси.\n\n"
    },
    {
      "title": "Автодоповнення команд",
      "level": 3,
      "content": "Автодоповнення (tab completion) — завершення введених команд натисканням клавіші Tab (є усталеним налаштуванням).\n\n"
    },
    {
      "title": "Одинарне натискання",
      "level": 4,
      "content": "Вивести список можливих закінчень для частково введеної команди можна декількома повторними натисканням клавіші Tab - іноді двома та трьома. В статті Readline #Швидке завершення описано, як зменшити кількість натискань до одного.\n\n"
    },
    {
      "title": "Додаткові програми та опції",
      "level": 4,
      "content": "Усталено Bash дозволяє виконувати команди, імена файлів та змінні.Пакет bash-completion додає автодоповнення для найпоширеніших команд та їхніх опцій, які можна ввімкнути, зчитавши і виконавши файл /usr/share/bash-completion/bash_completion (зазвичай зчитується автоматично в /etc/bash.bashrc). З пакетом bash-completion звичайні завершення (на кшталт $ ls file.*<tab><tab>) поводитимуться дещо інакше, повернути стару поведінку можна командою $ compopt -o bashdefault програма (докладніше див. [2] і [3]).\n\n"
    },
    {
      "title": "Налаштування для команд",
      "level": 4,
      "content": "Типово Bash допомагає завершувати тільки імена файлів, які слідують за командою. Це можна переналаштувати командою complete -c, щоб доповнювалися і певні команди:\n\n```\n~/.bashrc\n```\n\n```\ncomplete -c man which\n```\n\nЗ прапорами -cf завершуватися будуть і команди, і імена файлів після них:\n\n```\ncomplete -cf sudo\n```\n\nІнші опції та автодоповнення можна знайти в посібнику Bash.\n\n"
    },
    {
      "title": "Автодоповнення на основі історії команд",
      "level": 4,
      "content": "Клавіші стрілок \"вверх\" та \"вниз\" можна призначити для пошуку команд в історії (див. Readline #Історія команд та Синтаксис init-файлів Readline):\n\n```\n~/.bashrc\n```\n\n```\nbind '\"\\e[A\": history-search-backward'\nbind '\"\\e[B\": history-search-forward'\n```\n\nАбо, щоб це працювало у всіх програмах Readline:\n\n```\n~/.inputrc\n```\n\n```\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n```\n\n"
    },
    {
      "title": "Стиснення історії команд",
      "level": 4,
      "content": "Змінна HISTCONTROL дозволяє запобігти логуванню деяких команд. Наприклад, щоб однакові команди не потрапляли в історію, надайте змінній таке значення:\n\n```\n~/.bashrc\n```\n\n```\nexport HISTCONTROL=ignoredups\n```\n\nЯкщо ж задати значення erasedups, то додатково з історії будуть видалені вже наявні дублікати команд. Докладніше див. посібник Bash.\n\n"
    },
    {
      "title": "Вимкнення історії",
      "level": 4,
      "content": "Щоб тимчасово вимкнути історію, виконайте:\n\n```\n$ set +o history\n```\n\nТепер можна виконувати «чутливі» в плані безпеки дії, на кшталт обчислення хеш-суми пароля (printf secret | sha256sum) або роботи з GPG (gpg -eaF secret-pubkey.asc), не побоюючись, що секретний ключ буде збережено на диск.\n\nУвімкнути історію назад можна командою\n\n```\n$ set -o history\n```\n\nЩоб вимкнути всю історію Bash:\n\n```\n~/.bashrc або /etc/profile\n```\n\n```\nexport HISTSIZE=0\n```\n\nПісля цього команди, що вводяться, не будуть зберігатися в $HISTFILE.\n\nПісля необхідно видалити старий файл історії (майте на увазі - команди нижче видалять його безповоротно):\n\n```\n$ wipe -i -l2 -x4 -p4 \"$HISTFILE\"\n$ ln -sv /dev/null \"$HISTFILE\"\n```\n\n"
    },
    {
      "title": "run-help из Zsh",
      "level": 3,
      "content": "В Zsh є можливість викликати довідку для команди перед курсором за допомогою комбінації клавіш Alt+h. В Bash те ж можна зробити з допомогою прив'язки клавіш в Readline:\n\n```\n~/.bashrc\n```\n\n```\nrun-help() { help \"$READLINE_LINE\" 2>/dev/null || man \"$READLINE_LINE\"; }\nbind -m vi-insert -x '\"\\eh\": run-help'\nbind -m emacs -x     '\"\\eh\": run-help'\n```\n\nПередбачається, що ви використовуєте (стандартний) режим редагування Emacs.\n\n"
    },
    {
      "title": "Псевдоніми",
      "level": 2,
      "content": "alias (англ. псевдонім) - команда для заміни одного рядка на інший. Часто використовується для скорочення системних команд до абревіатур або для додавання стандартних аргументів до часто використовуваних команд.\n\nКористувацькі псевдоніми зберігаються у файлі ~/.bashrc, а системні (для всіх користувачів) - у /etc/bash.bashrc. Приклади можна подивитися в [4].\n\nФункції Bash докладно описані в Bash/Функції.\n\n"
    },
    {
      "title": "Налаштування запрошення",
      "level": 3,
      "content": "Див. Bash/Налаштування запрошення.\n\n"
    },
    {
      "title": "Підсвітка синтаксису та підказки",
      "level": 3,
      "content": "blesh-gitAUR - редактор командного рядка, який написаний на чистому Bash і призначений замінити Readline. Пропонує безліч додаткових можливостей на кшталт підсвітки синтаксису, підказок, завершення команд з меню, що випадає, абревіатур, режиму редагування Vim, хук-функцій тощо.\n\nПісля встановлення необхідно зчитати і виконати його в інтерактивному сеансі. Налаштування докладно пояснюються у файлі ~/.blerc і wiki. Доступна також стабільна збірка bleshAUR.\n\n"
    },
    {
      "title": "Command not found",
      "level": 3,
      "content": "У pkgfile є хук «command not found», який при введенні невідомої команди автоматично шукає відповідний виконуваний файл у пакетах в офіційних репозиторіях.\n\nЩоб хук запрацював, його необхідно зчитати і виконати:\n\n```\n~/.bashrc\n```\n\n```\nsource /usr/share/doc/pkgfile/command-not-found.bash\n```\n\nПісля цього при спробі запустити недоступну команду буде виведено таку інформацію:\n\n```\n$ abiword\n```\n\n```\nabiword may be found in the following packages:\n  extra/abiword 3.0.1-2 /usr/bin/abiword\n```\n\n"
    },
    {
      "title": "Вимкнення комбінації Ctrl+z",
      "level": 3,
      "content": "Натискання Ctrl+z в терміналі ставить додаток на паузу або закриває його. Вимкнути цю комбінацію клавіш можна таким чином:\n\n```\n#!/bin/bash\ntrap «» 20\nadom\n```\n\nЯкщо після цього під час роботи adomAUR ви помилково замість Shift+z натиснете комбінацію Ctrl+z, то її буде проігноровано і нічого не станеться.\n\n"
    },
    {
      "title": "Очищення екрана після виходу",
      "level": 3,
      "content": "Очищення екрана віртуального терміналу після виходу:\n\n```\n~/.bash_logout\n```\n\n```\nclear\nreset\n```\n\n"
    },
    {
      "title": "Зміна каталогу при введенні шляху",
      "level": 3,
      "content": "Bash може автоматично додавати команду cd , якщо введено тільки шлях до каталогу. Стандартна поведінка:\n\n```\n$ /etc\n```\n\n```\nbash: /etc: Is a directory\n```\n\nЯкщо ж додати в .bashrc рядок\n\n```\n~/.bashrc\n```\n\n```\n...\nshopt -s autocd\n...\n```\n\nто станеться наступне:\n\n```\n[user@host ~]$ /etc\ncd /etc\n[user@host etc]$\n```\n\n"
    },
    {
      "title": "Autojump",
      "level": 3,
      "content": "autojump-gitAUR дозволяє переміщатися по файловій системі за допомогою пошуку рядків у базі даних з часто відвідуваними шляхами. Щоб додаток запрацював, після встановлення необхідно зчитати і виконати файл /etc/profile.d/autojump.bash.\n\n"
    },
    {
      "title": "Заборона на перезапис файлів",
      "level": 3,
      "content": "Вимкнення перезапису файлів за допомогою перенаправлення виведення на час поточного сеансу:\n\n```\n$ set -o noclobber\n```\n\nКоманда set -C зробить те ж саме.\n\nЗробити зміни постійними можна таким чином:\n\n```\n~/.bashrc\n```\n\n```\nset -o noclobber\n```\n\nПримусово перезаписати файл при встановленому noclobber:\n\n```\n$ echo \"output\" >| file.txt\n```\n\n"
    },
    {
      "title": "Перенесення рядків при зміні розміру вікна",
      "level": 3,
      "content": "При зміні розміру вікна емулятора терміналу Bash може не отримати відповідний сигнал. У результаті виведений текст буде переноситися некоректно і перекриє запрошення командного рядка. Опція оболонки checkwinsize перевіряє розмір вікна після кожної команди і за необхідності оновлює значення змінних LINES і COLUMNS.\n\n```\n~/.bashrc\n```\n\n```\nshopt -s checkwinsize\n```\n\n"
    },
    {
      "title": "Оболонка завершується навіть з опцією ignoreeof",
      "level": 3,
      "content": "Після завдання опції ignoreeof ви можете виявити, що багаторазове натискання Ctrl-d все одно призводить до завершення процесу оболонки. Річ у тім, що за замовчуванням ця опція дозволяє ігнорувати тільки 10 натискань цієї комбінації клавіш (якщо бути точним - 10 станів EOF) перед виходом з оболонки.\n\nЗадати більше значення можна змінною IGNOREEOF. Наприклад:\n\n```\nexport IGNOREEOF=100\n```\n\n"
    },
    {
      "title": "Аналіз сценарію та пошук помилок",
      "level": 3,
      "content": "Програма shellcheck перевіряє сценарії Bash (та інших командних оболонок) на предмет помилок і пропонує можливі поліпшення коду.\n\nІснує також веб-сайт shellcheck.net, розроблений на основі однойменної програми і призначений для тієї ж мети.\n\n"
    },
    {
      "title": "Дивіться також",
      "level": 2,
      "content": "- Wikipedia:uk:Bash\n- Довідковий посібник Bash, також локально у файлі /usr/share/doc/bash/bashref.html\n- Синтаксис init-файлів Readline\n- The Bourne-Again Shell - Третій розділ книги The Architecture of Open Source Applications\n- PS1 generator - Наочне створення запрошення Bash за допомогою миші\n- Корисні команди для .bashrc\n\n"
    },
    {
      "title": "Навчання",
      "level": 3,
      "content": "- Greg's Wiki\n- GregsWiki:BashGuide\n- GregsWiki:BashFAQ\n- Quote Tutorial\n\n"
    },
    {
      "title": "Спільнота",
      "level": 3,
      "content": "- Активний і доброзичливий IRC-канал Bash\n\n"
    },
    {
      "title": "Приклади",
      "level": 3,
      "content": "- Як змінити назву вікна xterm\n\n"
    }
  ]
}