{
  "title": "Btrfs (Português)",
  "url": "https://wiki.archlinux.org/title/Btrfs_(Portugu%C3%AAs)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- Sistemas de arquivos\n- Snapper\n- dm-crypt/Criptografando todo um sistema#Subvolumes do Btrfs com swap\n\nDa Wiki do Btrfs (traduzido):\n\n"
    },
    {
      "title": "Preparação",
      "level": 2,
      "content": "Para utilitários do userspace instale o pacote btrfs-progs necessário para as operações básicas.\n\nSe você precisar inicializar a partir de um sistema de arquivos Btrfs (ou seja, seu kernel e initramfs residem em uma partição Btrfs), verifique se o seu gerenciador de boot suporta Btrfs.\n\n"
    },
    {
      "title": "Criação do sistema de arquivos",
      "level": 2,
      "content": "Veja, a seguir como criar um novo sistema de arquivos Btrfs. Para converter uma partição ext3/4 em Btrfs, veja #Conversão de Ext3/4 para Btrfs. Para usar uma configuração sem partição, Veja #Disco Btrfs sem partições.\n\nVeja mkfs.btrfs(8) para mais informações.\n\n"
    },
    {
      "title": "Sistema de arquivos em um único dispositivo",
      "level": 3,
      "content": "Para criar um sistema de arquivos Btrfs na partição /dev/partição:\n\n```\n# mkfs.btrfs -L minhaEtiqueta /dev/partição\n```\n\nO tamanho de nó (nodesize) padrão do Btrfs para metadados é 16 KB, enquanto o tamanho de setor padrão para dados é igual ao tamanho da página e detectado automaticamente. Para usar um tamanho de nó maior para metadados (deve ser um múltiplo do tamanho do setor, até 64 KB é permitido), especifique um valor para o nodesize por meio da opção -n conforme mostrado neste exemplo usando blocos de 32 KB:\n\n```\n# mkfs.btrfs -L minhaEtiqueta -n 32k /dev/partição\n```\n\n"
    },
    {
      "title": "Sistema de arquivos com vários dispositivos",
      "level": 3,
      "content": "Vários dispositivos podem ser usados para criar um RAID. Os níveis de RAID suportados incluem RAID 0, RAID 1, RAID 10, RAID 5 e RAID 6. A partir do kernel 5.5 RAID1c3 e RAID1c4 para 3 e 4 cópias do nível RAID 1. Os níveis de RAID podem ser configurados separadamente para dados e metadados usando as opções -d e -m, respectivamente. Por padrão, os dados têm uma cópia (single) e os metadados são espelhados (raid1). Isso é semelhante à criação de uma configuração JBOD, onde os discos são vistos como um sistema de arquivos, mas os arquivos não são duplicados. Consulte Usando Btrfs com vários dispositivos para obter mais informações sobre como criar um volume RAID Btrfs.\n\n```\n# mkfs.btrfs -d single -m raid1 /dev/partição1 /dev/partição2 ...\n```\n\nVocê deve incluir o hook udev ou o hook btrfs em /etc/mkinitcpio.conf para usar vários dispositivos Btrfs em uma pool. Veja o artigo Mkinitcpio#Hooks comuns para mais informações.\n\n- É possível adicionar dispositivos a um sistema de arquivos com vários dispositivos posteriormente. Veja o Artigo da Wiki do Btrfs para mais informações.\n- Os dispositivos podem ter tamanhos diferentes. No entanto, só se uma unidade em uma configuração RAID for maior que as outras, esse espaço extra não será usado.\n- Alguns gerenciadores de boot como Syslinux não suportam sistemas de arquivos com vários dispositivos.\n- O Btrfs não lê automaticamente do dispositivo mais rápido, portanto, misturar diferentes tipos de discos resulta em desempenho inconsistente. Consulte [1] para obter detalhes.\n\nVeja #RAID para obter conselhos sobre manutenção específica para sistemas de arquivos Btrfs de vários dispositivos.\n\n"
    },
    {
      "title": "Copy-on-Write (CoW)",
      "level": 3,
      "content": "Por padrão, o Btrfs usa copy-on-write para todos os arquivos o tempo todo. As gravações não substituem os dados no local; em vez disso, uma cópia modificada do bloco é gravada em um novo local e os metadados são atualizados para apontar para o novo local. Veja a seção Guia Sysadmin do Btrfs para detalhes de implementação, bem como vantagens e desvantagens.\n\n"
    },
    {
      "title": "Desativando CoW",
      "level": 4,
      "content": "Para desativar copy-on-write de arquivos recém-criados em um subvolume montado, use a opção de montagem nodatacow. Isso afetará apenas os arquivos recém-criados. A cópia na gravação ainda acontecerá para arquivos existentes. A opção nodatacow também desativa a compactação. Veja btrfs(5) para detalhes.\n\nPara desativar copy-on-write de arquivos/diretórios únicos,:\n\n```\n$ chattr +C /diretório/arquivo\n```\n\nIsso desabilitará copy-on-write para aquelas operações nas quais há apenas uma referência ao arquivo. Se houver mais de uma referência, por exemplo devido a clones de arquivo (leves ou não) ou snapshots do sistema de arquivos, o copy-on-write ainda ocorre. Observe que a partir do coreutils 9.0, cp tenta realizar cópias leves por padrão — veja cp(1) para mais detalhes.\n\n```\n$ mv /caminho/para/diretório /caminho/para/diretório_antigo\n$ mkdir /caminho/para/diretório\n$ chattr +C /caminho/para/diretório\n$ cp -a --reflink=never /caminho/para/diretório_antigo/. /caminho/para/diretório\n$ rm -rf /caminho/para/diretório_antigo\n```\n\n"
    },
    {
      "title": "Compressão",
      "level": 3,
      "content": "Btrfs suporta compressão transparente e automática. Isso reduz o tamanho dos arquivos e aumenta significativamente a vida útil da mídia baseada em flash, reduzindo a amplificação de gravação. Veja Fedora:Changes/BtrfsByDefault#Compression, [2] e [3]. Ela também pode melhorar o desempenho, em alguns casos (por exemplo, thread único com E/S de arquivo pesado), enquanto obviamente prejudica o desempenho em outros casos (por exemplo, tarefas multi-threaded e/ou com uso intensivo de CPU com E/S de arquivo grande). O melhor desempenho geralmente é alcançado com os algoritmos de compactação mais rápidos, zstd e lzo, e alguns benchmarks fornecem comparações detalhadas.\n\ncompress=alg é uma opção de montagem ativada automaticamente considerando todos os arquivos para compactação, onde alg e também zlib, lzo, zstd, ou no (sem compressão). Usando esta opção, o btrfs verificará se a compactação da primeira parte dos dados a reduz. Se isso acontecer, toda a gravação nesse arquivo será compactada. Caso contrário, nada será compactado. Com esta opção, se a primeira parte da gravação não diminuir, nenhuma compactação será aplicada à gravação, mesmo que o restante dos dados diminua tremendamente. [4] Isso é feito para evitar que o disco aguarde para começar a gravar até que todos os dados a serem gravados sejam totalmente fornecidos ao btrfs e compactados.\n\nA opção de montagem compress=alg permite considerar automaticamente cada arquivo para compactação, onde alg é zlib, lzo, zstd ou no (para nenhuma compactação). Usando esta opção, o btrfs verificará se a compactação da primeira parte dos dados os reduz. Se isso acontecer, toda a gravação nesse arquivo será compactada. Se isso não acontecer, nada disso é compactado. Com essa opção, se a primeira parte da gravação não diminuir, nenhuma compactação será aplicada à gravação, mesmo que o restante dos dados reduza tremendamente [5]. Isso é feito para evitar que o disco espere para iniciar a gravação até que todos os dados a serem gravados sejam totalmente fornecidos ao btrfs e compactados.\n\nA opção de montagem compress-force=alg pode ser usada em vez disso, o que faz com que o btrfs ignore a verificação se a compactação reduz a primeira parte e habilita a tentativa de compactação automática para cada arquivo. Na pior das hipóteses, isso pode causar (um pouco) mais uso da CPU sem nenhum propósito. No entanto, testes empíricos em vários sistemas de uso misto mostraram uma melhoria significativa de cerca de 10% de compactação de disco ao usar compress-force=zstd em vez de apenas compress=zstd, que também tinha 10% de compactação de disco.\n\nSomente os arquivos criados ou modificados após a adição da opção de montagem serão compactados.\n\nPara aplicar compactação a arquivos existentes, use o comando btrfs filesystem defragment -calg, onde alg é zlib, lzo ou zstd. Por exemplo, para recompactar todo o sistema de arquivos com zstd, execute o seguinte comando:\n\n```\n# btrfs filesystem defragment -r -v -czstd /\n```\n\nPara habilitar a compactação ao instalar o Arch em uma partição Btrfs vazia, use a opção compress quando montar o sistema de arquivos: mount -o compress=zstd /dev/sdxY /mnt/. Durante a configuração, adicione compress=zstd para as opções de montagem do sistema de arquivos raiz no fstab.\n\n- Sistemas usando kernels mais antigos ou btrfs-progs sem suporte azstd podem não conseguir ler ou reparar seu sistema de arquivos se você usar esta opção.\n- GRUB introduziu suporte a zstd na versão 2.04. Certifique-se de atualizar o gerenciador de boot instalado em seu MBR/ESP desde então, executando grub-install com as opções apropriadas para a configuração de BIOS/UEFI, pois isso não é feito automaticamente. Veja FS#63235.\n\n"
    },
    {
      "title": "Visualizar tipos e proporções de compactação",
      "level": 4,
      "content": "compsize obtém uma lista de arquivos (ou um sistema de arquivos btrfs inteiro) e mede os tipos de compactação usados e as taxas de compactação efetivas. O tamanho descompactado pode não corresponder ao número fornecido por outros programas, como du(1), porque cada extensão é contada uma vez, mesmo que seja revinculada várias vezes, e mesmo que parte dela não seja mais usada em nenhum lugar, mas não tenha sido coletada como lixo. A opção -x o mantém em um único sistema de arquivos, o que é útil em situações como compsize -x / para evitar que ele tente procurar em subdiretórios não-btrfs e falhe em toda a execução.\n\n"
    },
    {
      "title": "Subvolumes",
      "level": 3,
      "content": "\"Um subvolume btrfs não é um dispositivo de bloco (e não pode ser tratado como um), em vez disso, um subvolume btrfs pode ser pensado como um espaço para nome do arquivo POSIX. Este espaço para nome pode ser acessado através do subvolume de nível superior do sistema de arquivos, ou pode ser montado por si próprio.\" [6]\n\nCada sistema de arquivos Btrfs possui um subvolume de nível superior com o ID 5. Ele pode ser montado como / (por padrão), ou outro subvolume pode ser mountado. Os subvolumes podem ser movimentados no sistema de arquivos e são mais identificados pelo ID do que pelo caminho.\n\nConsulte os seguintes links para obter mais detalhes:\n\n- Btrfs Wiki SysadminGuide#Subvolumes\n- Btrfs Wiki Getting started#Basic Filesystem Commands\n- Btrfs Wiki Trees\n\n"
    },
    {
      "title": "Criando um subvolume",
      "level": 4,
      "content": "Para criar um subvolume:\n\n```\n# btrfs subvolume create /caminho/para/subvolume\n```\n\n"
    },
    {
      "title": "Listando subvolumes",
      "level": 4,
      "content": "Para ver uma lista dos subvolumes atuais e seus IDs em caminho:\n\n```\n# btrfs subvolume list -p caminho\n```\n\n"
    },
    {
      "title": "Excluindo um subvolume",
      "level": 4,
      "content": "Para excluir um subvolume:\n\n```\n# btrfs subvolume delete /caminho/para/subvolume\n```\n\nDesde o Linux 4.18, também é possível excluir um subvolume como um diretório regular (rm -r, rmdir).\n\n"
    },
    {
      "title": "Montando subvolumes",
      "level": 4,
      "content": "Os subvolumes podem ser montados como partições do sistema de arquivos usando a opção de montagem subvol=/caminho/para/subvolume ou subvolid=id-do-objeto. Por exemplo, você pode ter um subvolume chamado subvol_root e montá-lo como /. Pode-se imitar partições tradicionais do sistema de arquivos criando vários subvolumes no nível superior do sistema de arquivos e, em seguida, montando-os nos pontos de montagem apropriados. É preferível montar usando subvol=/caminho/para/subvolume, em vez do subvolid, pois o subvolid pode mudar ao restaurar #Snapshots, exigindo uma mudança de configuração de montagem.\n\nNote: **sistema de arquivos inteiro** Veja o FAQ da Wiki do Btrfs para quais opções de montagem podem ser usadas por subvolume.\n\nVeja o FAQ da Wiki do Btrfs para quais opções de montagem podem ser usadas por subvolume.\n\nVeja Snapper#Layout do sistema de arquivos sugerido, Btrfs SysadminGuide#Managing Snapshots e Btrfs SysadminGuide#Layout para obter exemplos de layouts de sistema de arquivos usando subvolumes.\n\nVeja btrfs(5) para obter uma lista completa das opções de montagem específicas do btrfs.\n\n"
    },
    {
      "title": "Montando o subvolume como root",
      "level": 4,
      "content": "Para usar um subvolume como o ponto de montagem raiz, especifique o subvolume por meio de um parâmetro do kernel usando rootflags=subvol=/caminho/para/subvolume. Edite o ponto de montagem raiz em /etc/fstab e especifique a opção de montagem subvol=. Alternativamente, o subvolume pode ser especificado com seu ID, rootflags=subvolid=id-do-objeto como parâmetro do kernel e subvolid=id-do-objeto como opção de montagem em /etc/fstab. É preferível montar usando subvol=/caminho/para/subvolume, em vez do subvolid, pois o subvolid pode mudar ao restaurar #Snapshots, exigindo uma mudança na configuração de montagem, ou então o sistema não inicializará.\n\n"
    },
    {
      "title": "Alterando o subvolume padrão",
      "level": 4,
      "content": "O subvolume padrão é montado se não houver subvol= opção de montagem é fornecida. Para alterar o subvolume padrão, faça:\n\n```\n# btrfs subvolume set-default id-do-subvolume /\n```\n\nonde id-do-subvolume pode ser encontrado por listando.\n\nAlterando o subvolume padrão com btrfs subvolume set-default tornará o nível superior do sistema de arquivos inacessível, exceto pelo uso das opções de montagem subvol=/ ou subvolid=5 [7].\n\n"
    },
    {
      "title": "Quota",
      "level": 3,
      "content": "O suporte a quota no Btrfs é implementado em um nível de subvolume pelo uso de grupos de quota ou qgroup: a cada subvolume é atribuído um grupo de quota na forma de 0 / subvolume_id por padrão. No entanto, é possível criar um grupo de cotas usando qualquer número, se desejado.\n\nPara usar qgroups, você precisa habilitar o quota primeiro usando\n\n```\n# btrfs quota enable caminho\n```\n\nA partir deste ponto, os subvolumes recém-criados serão controlados por esses grupos. Para habilitá-los retrospectivamente para subvolumes já existentes, ative o quota normalmente, crie um qgroup (grupo de quota) para cada um desses subvolumes usando seu subvolume_id e redigitalize-os:\n\n```\n# btrfs subvolume list caminho | cut -d' ' -f2 | xargs -I{} -n1 btrfs qgroup create 0/{} caminho\n# btrfs quota rescan caminho\n```\n\nGrupos de quota no Btrfs formam uma hierarquia de árvore, na qual qgroups são anexados a subvolumes. Os limites de tamanho são definidos por qgroup e se aplicam quando qualquer limite é atingido na árvore que contém um determinado subvolume.\n\nOs limites dos grupos de quota podem ser aplicados ao uso total de dados, uso não compartilhado de dados, uso de dados compactados ou ambos. A cópia e a exclusão de arquivos podem afetar os limites, pois o limite não compartilhado de outro qgroup pode mudar se os arquivos do volume original forem excluídos e apenas uma cópia restar. Por exemplo, um snapshot novo compartilha quase todos os blocos com o subvolume original; as novas gravações em um subvolume aumentam em direção ao limite exclusivo; as exclusões de dados comuns em um volume aumentam em direção ao limite exclusivo no outro.\n\nPara aplicar um limite a um qgroup, use o comando btrfs qgroup limit. Dependendo do seu uso, use um limite total, um limite não compartilhado (-e) ou limite compactadot (-c). Para mostrar o uso e os limites de um determinado caminho em um sistema de arquivos, use\n\n```\n# btrfs qgroup show -reF caminho\n```\n\n"
    },
    {
      "title": "Intervalo de confirmação",
      "level": 3,
      "content": "A resolução na qual os dados são gravados no sistema de arquivos é ditada pelo próprio Btrfs e pelas configurações de todo o sistema. O padrão do Btrfs é um intervalo de ponto de verificação de 30 segundos no qual novos dados são confirmados no sistema de arquivos. Isso pode ser alterado anexando a opção de montagem commit em /etc/fstab para a partição btrfs.\n\n```\nLABEL=arch64 / btrfs defaults,noatime,compress=zstd,commit=120 0 0\n```\n\nAs configurações de todo o sistema também afetam os intervalos de confirmação. Eles incluem os arquivos em /proc/sys/vm/* e estão fora do escopo deste artigo da wiki. A documentação do kernel para eles está disponível em https://docs.kernel.org/admin-guide/sysctl/vm.html.\n\n"
    },
    {
      "title": "TRIM do SSD",
      "level": 3,
      "content": "Um sistema de arquivos Btrfs pode liberar blocos não utilizados de uma unidade SSD que suporta o comando TRIM. A partir da versão 5.6 do kernel, há suporte a descarte assíncrono, ativado com a opção mount discard=async. As extensões liberadas não são descartadas imediatamente, mas agrupadas e aparadas posteriormente por um thread de trabalho separado, melhorando a latência de consolidação.\n\nMais informações sobre como ativar e usar o TRIM podem ser encontradas em Solid State Drives#TRIM.\n\n"
    },
    {
      "title": "Arquivo swap",
      "level": 3,
      "content": "Arquivos swap no Btrfs são suportados desde o kernel Linux 5.0 [8]. A maneira correta de inicializar um swap file é primeiro criar um subvolume do qual não se tenha snapshots para hospedar o arquivo e, em seguida, denifir o atributo No_COW em todo o diretório com chattr.\n\n```\n# chattr +C /caminho/para/subvolume_do_swap\n```\n\nA partir de agora qualquer novo arquivo criado dentro do subvolume do swap terá o atributo No_COW definido.\n\nContinue com as etapas em Arquivo swap#Criação de arquivo swap. A configuração da hibernação para um arquivo swap é descrita em Hibernação.\n\n- O arquivo swap não pode estar em um subvolume de snapshot. O procedimento adequado é criar um novo subvolume para colocar o arquivo swap.\n- Ele não suporta arquivos swap em sistemas de arquivos que abrangem vários dispositivos. Veja btrfs(5) § SWAPFILE SUPPORT e discussão nos fóruns do Arch.\n\n"
    },
    {
      "title": "Exibindo espaço usado/livre",
      "level": 3,
      "content": "Ferramentas gerais de espaço de usuário linux, como df(1) relatam imprecisamente o espaço livre em uma partição Btrfs. É recomendado usar btrfs filesystem usage para consultar partições Btrfs. Por exemplo, para um detalhamento completo da alocação de dispositivos e estatísticas de uso:\n\n```\n# btrfs filesystem usage /\n```\n\nAlternativamente, btrfs filesystem df permite uma verificação rápida do uso do espaço alocado sem a necessidade de executar como root:\n\n```\n$ btrfs filesystem df /\n```\n\nVeja [9] para mais informações.\n\nAs mesmas limitações se aplicam a ferramentas que analisam o uso de espaço para algum subconjunto do sistema de arquivos, como du(1) ou ncdu(1), pois não levam em consideração reflinks, snapshots e compressão. Em vez disso, veja btduAUR e compsize para alternativas compatíveis com Btrfs.\n\n"
    },
    {
      "title": "Desfragmentação",
      "level": 3,
      "content": "O Btrfs suporta a desfragmentação online através da opção de montagem autodefrag, veja btrfs(5) § MOUNT OPTIONS. Para desfragmentar manualmente sua raiz, use:\n\n```\n# btrfs filesystem defragment -r /\n```\n\nUsar o comando acima sem a opção -r resultará na desfragmentação apenas dos metadados mantidos pelo subvolume que contém o diretório. Isso permite a desfragmentação de um único arquivo simplesmente especificando o caminho.\n\nDesfragmentar um arquivo que tenha uma cópia COW (uma cópia de snapshot ou uma feita com cp ou bcp) e usar a opção -c com um algoritmo de compactação pode resultar em dois arquivos não relacionados, aumentando efetivamente o uso do disco.\n\n"
    },
    {
      "title": "RAID",
      "level": 3,
      "content": "O Btrfs oferece \"RAID\" nativo para #Sistema de arquivos com vários dispositivos. Os recursos notáveis que diferenciam o btrfs RAID do mdadm são arrays redundantes de autorrecuperação e balanceamento online. Veja a página wiki do Btrfs para obter mais informações. A página sysadmin do Btrfs também tem uma seção com um pouco mais de conhecimento técnico.\n\n"
    },
    {
      "title": "Scrub",
      "level": 3,
      "content": "O Glossário da Wiki do Btrfs afirma que o Btrfs scrub é \"[uma] ferramenta de verificação de sistema de arquivos online. Lê todos os dados e metadados no sistema de arquivos e usa checksums e cópias duplicadas do armazenamento RAID para identificar e reparar quaisquer dados corrompidos\".\n\n"
    },
    {
      "title": "Iniciar manualmente",
      "level": 4,
      "content": "Para iniciar uma limpeza (em segundo plano) no sistema de arquivos que contém /:\n\n```\n# btrfs scrub start /\n```\n\nPara verificar o status de uma limpeza em execução:\n\n```\n# btrfs scrub status /\n```\n\n"
    },
    {
      "title": "Comece com um serviço ou timer",
      "level": 4,
      "content": "O pacote btrfs-progs traz o unit btrfs-scrub@.timer para executar o scrub mensalmente no ponto de montagem especificado. Habilite o temporizador com um caminho de escape, por exemplo btrfs-scrub@-.timer para / e btrfs-scrub@home.timer para /home. Você pode usar systemd-escape -p /caminho/para/ponto_de_montagem para escapar do caminho (path), veja systemd-escape(1) para detalhes.\n\nVocê também pode executar o scrub iniciando btrfs-scrub@.service (com o mesmo caminho codificado). A vantagem disso sobre btrfs scrub (como usuário root) é que os resultados do scrub serão registrados no journal do systemd.\n\nEm unidades NVMe grandes com resfriamento insuficiente (por exemplo, em um laptop), a execução do scrub pode ler a unidade com rapidez e tempo suficientes para deixá-la muito quente. Se estiver executando scrubs com systemd, você pode facilmente limitar a taxa de scrubbing com a opção IOReadBandwidthMax descrita em systemd.resource-control(5) usando um arquivo drop-in.\n\n"
    },
    {
      "title": "Balance",
      "level": 3,
      "content": "\"O balance passa todos os dados no sistema de arquivos pelo alocador novamente. Destina-se principalmente a reequilibrar os dados no sistema de arquivos entre os dispositivos quando um dispositivo é adicionado ou removido. O balance regenerará cópias ausentes dos níveis redundantes de RAID, se um dispositivo falhou.\"[12] Veja a página FAQ.\n\nEm um sistema de arquivos de dispositivo único, o balance também pode ser útil para (temporariamente) reduzir a quantidade de blocos de dados alocados, mas não utilizados (meta). Às vezes, isso é necessário para corrigir problemas \"filesystem full\".\n\n```\n# btrfs balance start --bg /\n# btrfs balance status /\n```\n\n"
    },
    {
      "title": "Snapshots",
      "level": 3,
      "content": "\"Um snapshot é simplesmente um subvolume que compartilha seus dados (e metadados) com outros subvolumes, usando os recursos btrfs COW \". Veja o SysadminGuide#Snapshots da Wiki do Btrfs para detalhes.\n\nPara criar um snapshot:\n\n```\n# btrfs subvolume snapshot fonte [destino/]nome\n```\n\nPara criar um snapshot somente leitura, adicione a opção -r. Para criar uma versão modificável de um snapshot somente leitura, basta criar um snapshot dele.\n\n- É possível que um snapshot seja convertido no local de somente leitura (read-only) para gravável (writable). No entanto, isso não é recomendado porque causa problemas com qualquer envio/recebimento incremental futuro. Criar um novo instantâneo gravável evita esses problemas.\n- Os snapshots não são recursivos. Cada subvolume aninhado será um diretório vazio dentro do snapshot.\n\n"
    },
    {
      "title": "Enviar/receber",
      "level": 3,
      "content": "Um subvolume pode ser enviado para stdout ou um arquivo usando o comando send. Isso geralmente é mais útil quando direcionado para o comando do Btrfs receive. Por exemplo, para enviar um snapshot chamado /backup_da_raiz (talvez de um snapshot que você fez do / mais cedo) para /backup, você faria o seguinte:\n\n```\n# btrfs send /backup_da_raiz | btrfs receive /backup\n```\n\nO snapshot enviado deve ser somente leitura. O comando acima é útil para copiar um subvolume para um dispositivo externo (por exemplo, um dispositivo USB montado em /backup).\n\nVocê também pode enviar apenas a diferença entre dois snapshots. Por exemplo, se você já enviou uma cópia do backup_da_raiz acima e fez um novo snapshot somente leitura em seu sistema chamado novo_backup_da_raiz, então, para enviar apenas a diferença incremental para /backup, faça:\n\n```\n# btrfs send -p /backup_da_raiz /novo_backup_da_raiz | btrfs receive /backup\n```\n\nAgora, um novo subvolume chamado novo_backup_da_raiz estará presente em /backup.\n\nVeja a página da Wiki do Btrfs sobre backup incremental e #Backup incremental para unidade externa para saber como usá-lo e para ferramentas que automatizam o processo.\n\n"
    },
    {
      "title": "Desduplicação",
      "level": 3,
      "content": "Usando copy-on-write, O Btrfs pode copiar arquivos ou subvolumes inteiros sem copiar os dados. No entanto, sempre que um arquivo é alterado, uma nova cópia adequada é criada. A desduplicação leva isso um passo adiante, identificando ativamente blocos de dados que compartilham seqüências comuns e combinando-os em uma extensão com a mesma semântica copy-on-write.\n\nAs ferramentas dedicadas para desduplicar uma partição formatada em Btrfs incluem duperemove e bees. Pode-se também querer apenas desduplicar dados em um nível baseado em arquivo, em vez de usar, por exemplo, rmlint-gitAUR, jdupesAUR ou dduper-gitAUR. Para uma visão geral dos recursos disponíveis desses programas e informações adicionais, consulte essa página da Wiki.\n\nAlém disso, os desenvolvedores do Btrfs estão trabalhando na desduplicação inband (também conhecida como síncrona ou inline), o que significa que a desduplicação é feita ao gravar novos dados no sistema de arquivos. Atualmente, ainda é um experimento desenvolvido fora da árvore. Usuários dispostos a testar o novo recurso devem ler a página apropriada da wiki do kernel.\n\n"
    },
    {
      "title": "Redimensionando",
      "level": 3,
      "content": "Você pode aumentar um sistema de arquivos até o espaço máximo disponível no dispositivo ou especificar um tamanho exato. Certifique-se de aumentar o tamanho do dispositivo ou volume lógico antes de tentar aumentar o tamanho do sistema de arquivos. Ao especificar um tamanho exato para o sistema de arquivos, tanto aumentando-o quanto diminuindo-o, certifique-se de que o novo tamanho atenda às seguintes condições:\n\n- O novo tamanho deve ser maior que o tamanho dos dados existentes; caso contrário, ocorrerá perda de dados.\n- O novo tamanho deve ser igual ou menor que o tamanho do dispositivo atual porque o tamanho do sistema de arquivos não pode se estender além do espaço disponível.\n\nPara estender o tamanho do sistema de arquivos para o tamanho máximo disponível do dispositivo:\n\n```\n# btrfs filesystem resize max /\n```\n\nPara estender o sistema de arquivos para um tamanho específico:\n\n```\n# btrfs filesystem resize tamanho /\n```\n\nSubstitua tamanho pelo tamanho desejado em bytes. Você também pode especificar unidades no valor, como K (kibibytes), M (mebibytes) ou G (gibibytes). Alternativamente, você pode especificar um aumento ou diminuição do tamanho atual prefixando o valor com um sinal de mais (+) ou menos (-), respectivamente:\n\n"
    },
    {
      "title": "Problemas conhecidos",
      "level": 2,
      "content": "Algumas limitações devem ser conhecidas antes de tentar.\n\n"
    },
    {
      "title": "Criptografia",
      "level": 3,
      "content": "O Btrfs não tem suporte nativo à criptografia, mas pode ter no futuro. Os usuários podem criptografar a partição antes de executar mkfs.btrfs. Veja dm-crypt/Criptografando todo um sistema#Subvolumes do Btrfs com swap.\n\nOs sistemas de arquivos Btrfs existentes podem usar algo como EncFS ou TrueCrypt, embora talvez sem alguns dos recursos do Btrfs.\n\n"
    },
    {
      "title": "Problemas de verificação do btrfs",
      "level": 3,
      "content": "A ferramenta btrfs check possui problemas conhecidos e não deve ser executada sem leitura adicional, consulte a seção #btrfs check.\n\n"
    },
    {
      "title": "Disco Btrfs sem partições",
      "level": 3,
      "content": "O Btrfs pode ocupar um dispositivo de armazenamento de dados inteiro, substituindo os esquemas de particionamento MBR ou GPT, usando subvolumes para simular partições. No entanto, não é necessário usar uma configuração sem partição para simplesmente criar um sistema de arquivos Btrfs em uma partição existente que foi criada usando outro método. Existem algumas limitações nas configurações de disco único sem partição:\n\n- Não é possível colocar outros sistemas de arquivos em outra partição no mesmo disco.\n- Devido ao ponto anterior, não é possível ter uma ESP neste disco. Outro dispositivo é necessário para a inicialização do UEFI.\n- Se estiver usando uma versão do kernel Linux anterior a 5.0, você não pode usar espaço swap porque o Btrfs não suportava arquivos swap pré-5.0 e não há lugar para criar partição swap\n\nPara substituir a tabela de partição existente com Btrfs, execute o seguinte comando:\n\n```\n# mkfs.btrfs /dev/sdX\n```\n\nPor exemplo, use /dev/sda ao invés de /dev/sda1. O último formata uma partição existente em vez de substituir todo o esquema de particões. Como a partição raiz está em Btrfs, verifique se btrfs é compilado no kernel, ou coloque btrfs dentro do arranjo MODULES do mkinitcpio e gere novamente o initramfs.\n\nInstale o gerenciador de boot como você faria para um dispositivo de armazenamento de dados com Master Boot Record. Veja Syslinux#Manually ou GRUB/Tips and tricks#Install to partition or partitionless disk. Se o seu kernel não inicializar devido a Failed to mount /sysroot., por favor adicione GRUB_PRELOAD_MODULES=\"btrfs\" em /etc/default/grub e gere a configuração do grub (GRUB#Gerar o arquivo de configuração principal).\n\n"
    },
    {
      "title": "Conversão de Ext3/4 para Btrfs",
      "level": 3,
      "content": "Inicialize a partir de um CD de instalação e converta fazendo:\n\n```\n# btrfs-convert /dev/partição\n```\n\nMonte a partição e teste a conversão verificando os arquivos. Certifique-se de alterar o /etc/fstab para refletir a alteração (em type altere para btrfs e empass [o último campo] altere para 0, pois o Btrfs não faz uma verificação do sistema de arquivos na inicialização). Observe também que o UUID da partição será alterado, portanto, atualize o fstab de acordo ao usar UUIDs. Entre no sistema atráves do chroot e reconstrua sua lista de menus de bootloaders (veja Instalar a partir de um Linux existente). Se estiver convertendo um sistema de arquivos raiz, enquanto ainda estiver em chroot, execute mkinitcpio -p linux para regenerar o initramfs ou o sistema não inicializará com sucesso.\n\nDepois de confirmar que não há problemas, conclua a conversão excluindo o subvolume de backup ext2_saved. Observe que você não pode reverter para ext3/4 sem ele.\n\n```\n# btrfs subvolume delete /ext2_saved\n```\n\nFinalmente equilibre o sistema de arquivos para recuperar o espaço.\n\nLembre-se que alguns aplicativos que foram instalados anteriormente precisam ser adaptados ao Btrfs.\n\n"
    },
    {
      "title": "Aceleração do hardware do checksum",
      "level": 3,
      "content": "O CRC32 é uma nova instrução no Intel SSE4.2. Para verificar se a soma de verificação (checksum) do Btrfs é acelerada por hardware:\n\n```\n# dmesg | grep crc32c\n```\n\n```\nBtrfs loaded, crc32c=crc32c-intel\n```\n\nSe você ver crc32c=crc32c-generic, provavelmente é porque sua partição raiz é Btrfs, e você terá que compilar crc32c-intel no kernel para fazê-lo funcionar. Colocar crc32c-intel em mkinitcpio.conf não funciona.\n\n"
    },
    {
      "title": "Recuperação de corrupção",
      "level": 3,
      "content": "btrfs-check não pode ser usado em um sistema de arquivos montado. Para poder usar o btrfs-check sem inicializar a partir de um USB ativo, adicione-o ao ramdisk inicial:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nBINARIES=(btrfs)\n```\n\nGere novamente o initramfs.\n\nEntão, se houver um problema na inicialização, o utilitário estará disponível para reparo.\n\nVeja a página da Wiki do Btrfs para mais informações.\n\n"
    },
    {
      "title": "Inicializando em snapshots",
      "level": 3,
      "content": "Para inicializar em um snapshot, o mesmo procedimento se aplica para montar um subvolume como sua partição raiz, conforme fornecido na seção [[#Montando o subvolume como root|]], porque os snapshots podem ser montados como subvolumes.\n\n- Se estiver usando o GRUB, você poderá preencher automaticamente seu menu de inicialização com os snapshots do Btrfs ao regenerar o arquivo de configuração com a ajuda do grub-btrfs ou grub-btrfs-gitAUR.\n- Se estiver usando rEFInd você pode preencher automaticamente seu menu de inicialização com snapshots do Btrfs com a ajuda de refind-btrfsAUR, depois de habilitar refind-btrfs.service.\n\n"
    },
    {
      "title": "Use subvolumes Btrfs com systemd-nspawn",
      "level": 3,
      "content": "Consulte os artigos Systemd-nspawn#Use Btrfs subvolume as container root e Systemd-nspawn#Use temporary Btrfs snapshot of container.\n\n"
    },
    {
      "title": "Reduzindo atualizações de metadados de tempo de acesso",
      "level": 3,
      "content": "Devido à natureza copy-on-write do Btrfs, simplesmente acessar arquivos pode acionar a cópia e gravação de metadados. Reduzir a frequência das atualizações de tempo de acesso pode eliminar esse uso inesperado do disco e aumentar o desempenho. Veja fstab#Opções atime para as opções disponíveis.\n\n"
    },
    {
      "title": "Backup incremental para unidade externa",
      "level": 3,
      "content": "Os pacotes a seguir usam btrfs send e btrfs receive para enviar backups incrementalmente para uma unidade externa. Consulte a documentação para ver as diferenças na implementação, recursos e requisitos.\n\n- btrbk — Ferramenta para criar snapshots e backups remotos de subvolumes Btrfs.\n\n- snap-sync — Usa snapshots do Snapper para fazer backup em uma unidade externa ou máquina remota.\n\n- snapsync — Uma ferramenta de sincronização para o Snapper.\n\nO pacote a seguir permite fazer backup de snapshots do snapper para sistemas de arquivos não Btrfs.\n\n- snapborg — Ferramenta semelhante ao borgmatic que integra snapshots do snapper com backups do borg.\n\n"
    },
    {
      "title": "Solução de problemas",
      "level": 2,
      "content": "Veja o FAQ de problemas do Btrfs para solução de problemas gerais.\n\n"
    },
    {
      "title": "Deslocamento da partição",
      "level": 4,
      "content": "O problema de deslocamento pode ocorrer quando você tenta incorporar core.img em um disco particionado. Isso significa que está tudo bem para incorporar o core.img do GRUB em um pool Btrfs em um disco sem partição (por exemplo /dev/sdX) diretamente.\n\nGRUB pode inicializar partições Btrfs, porém o módulo pode ser maior que outros sistemas de arquivos. E o arquivo core.img feito pelo grub-install pode não caber nos primeiros 63 setores (31,5 KiB) da unidade entre o MBR e a primeira partição. Ferramentas de particionamento atualizadas, como fdisk e gdisk evitam esse problema compensando a primeira partição em aproximadamente 1MiB ou 2MiB.\n\n"
    },
    {
      "title": "Raiz ausente",
      "level": 4,
      "content": "Note: **The factual accuracy of this article or section is disputed.** The factual accuracy of this article or section is disputed.\n\nThe factual accuracy of this article or section is disputed.\n\nSe experenciando o seguinte erro error no such device: root ao inicializar a partir de uma configuração de estilo RAID, edite /usr/share/grub/grub-mkconfig_lib e remova as duas aspas da linha echo \" search --no-floppy --fs-uuid --set=root ${hints} ${fs_uuid}\". Gere novamente a configuração do GRUB e o sistema deve inicializar sem erros.\n\n"
    },
    {
      "title": "Tempo limite de montagem esgotado",
      "level": 3,
      "content": "Às vezes, especialmente com grandes arrays RAID 1, a montagem pode atingir o tempo limite durante a inicialização com uma mensagem do journal como:\n\n```\nJan 25 18:05:12 host systemd[1]: storage.mount: Mounting timed out. Terminating.\nJan 25 18:05:46 host systemd[1]: storage.mount: Mount process exited, code=killed, status=15/TERM\nJan 25 18:05:46 host systemd[1]: storage.mount: Failed with result 'timeout'.\nJan 25 18:05:46 host systemd[1]: Failed to mount /storage.\nJan 25 18:05:46 host systemd[1]: Startup finished in 32.943s (firmware) + 3.097s (loader) + 7.247s (kernel)>\nJan 25 18:05:46 host kernel: BTRFS error (device sda): open_ctree failed\n```\n\nIsso pode ser facilmente contornado fornecendo um tempo limite mais longo por meio da opção de montagem específica do systemd x-systemd.mount-timeout em fstab. Por exemplo:\n\n```\n/dev/sda                /storage    btrfs       rw,relatime,x-systemd.mount-timeout=5min  0 0\n```\n\n"
    },
    {
      "title": "BTRFS: open_ctree falhou",
      "level": 3,
      "content": "Em novembro de 2014, pareceu haver um bug no systemd ou no mkinitcpio causando o seguinte erro em sistemas que usam Btrfs em vários dispositivos usando o hook btrfs em mkinitcpio.conf:\n\n```\nBTRFS: open_ctree failed\nmount: wrong fs type, bad option, bad superblock on /dev/sdb2, missing codepage or helper program, or other error\n\nIn some cases useful info is found in syslog - try dmesg|tail or so.\n\nYou are now being dropped into an emergency shell.\n```\n\nUma solução é remover btrfs do array HOOKS em /etc/mkinitcpio.conf e, em vez disso, adicionar btrfs ao array MODULES. Em seguida, gere novamente o initramfs e reinicie.\n\nVocê receberá o mesmo erro se tentar montar um arranjo raid sem um dos dispositivos. Nesse caso, você deve adicionar a opção de montagem degraded para /etc/fstab. Se sua raiz reside no array, você também deve adicionar rootflags=degraded para os parâmetros do kernel.\n\nDesde agosto de 2016, uma possível solução alternativa para esse bug é montar o array por uma única unidade apenas em /etc/fstab, e permitir que o Btrfs descubra e anexe as outras unidades automaticamente. Identificadores baseados em grupo, como UUID e LABEL, parecem contribuir para a falha. Por exemplo, uma array RAID1 de dois dispositivos que consiste em 'disco1' e 'disco2' terá um UUID alocado para ele, mas em vez de usar o UUID, use apenas /dev/mapper/disco1 no /etc/fstab. Para obter uma explicação mais detalhada, consulte a seguinte postagem no blog.\n\nOutra solução possível é remover o hook udev no mkinitcpio.conf e substituir ele pelo hook systemd. Nesse caso, btrfs não deve estar nos vetores HOOKS ou MODULES.\n\nVeja a discussão no fórum e FS#42884 para mais informações e discussão.\n\n"
    },
    {
      "title": "btrfs check",
      "level": 3,
      "content": "O comando btrfs-check(8) pode ser usado para verificar ou reparar um sistema de arquivos Btrfs não montado. No entanto, essa ferramenta de reparo ainda é imatura e não é capaz de reparar certos erros do sistema de arquivos, mesmo aqueles que não tornam o sistema de arquivos desmontável.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- Site oficial Btrfs Wiki Btrfs Documentation\n- Relacionado a desempenho Btrfs on raw disks? Varying leafsize and nodesize in Btrfs Btrfs support for efficient SSD operation (data blocks alignment) Is Btrfs optimized for SSDs? Benchmark de opções de montagem do Phoronix Linux 5.8 Linux 5.0 Linux 4.9 Linux 3.14 Linux 3.11 Linux 3.9 Linux 3.7 Linux 3.2 Lzo vs. zLib\n- Diversos Funtoo:BTRFS Fun Avi Miller presenting Btrfs at SCALE 10x, January 2012. Summary of Chris Mason's talk from LFCS 2012 Btrfs: stop providing a bmap operation to avoid swapfile corruptions 2009-01-21 Doing Fast Incremental Backups With Btrfs Send and Receive\n\n- Btrfs Wiki\n- Btrfs Documentation\n\n- Btrfs on raw disks?\n- Varying leafsize and nodesize in Btrfs\n- Btrfs support for efficient SSD operation (data blocks alignment)\n- Is Btrfs optimized for SSDs?\n- Benchmark de opções de montagem do Phoronix Linux 5.8 Linux 5.0 Linux 4.9 Linux 3.14 Linux 3.11 Linux 3.9 Linux 3.7 Linux 3.2\n- Lzo vs. zLib\n\n- Linux 5.8\n- Linux 5.0\n- Linux 4.9\n- Linux 3.14\n- Linux 3.11\n- Linux 3.9\n- Linux 3.7\n- Linux 3.2\n\n- Funtoo:BTRFS Fun\n- Avi Miller presenting Btrfs at SCALE 10x, January 2012.\n- Summary of Chris Mason's talk from LFCS 2012\n- Btrfs: stop providing a bmap operation to avoid swapfile corruptions 2009-01-21\n- Doing Fast Incremental Backups With Btrfs Send and Receive\n\n"
    }
  ]
}