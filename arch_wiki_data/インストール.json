{
  "title": "インストール",
  "url": "https://wiki.archlinux.org/title/%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- pacman/パッケージの署名\n- pacman/Pacnew と Pacsave\n- pacman/ローカルデータベースの復元\n- pacman/比較表\n- pacman/ヒントとテクニック\n- Arch User Repository\n- パッケージの作成\n- パッケージのダウングレード\n- namcap\n- FAQ#パッケージ管理\n- システムメンテナンス\n\npacman パッケージマネージャは Arch Linux の主要な機能のひとつです。pacman はシンプルなバイナリのパッケージ形式と簡単に利用できる Arch build system から成っています。pacman のゴールはパッケージ管理を楽にすることであり、公式リポジトリにあるパッケージや、ユーザー自身が作成したパッケージを容易に管理することができます。\n\nPacman はマスターサーバーと同期してシステムを最新に保ちます。このサーバー・クライアントモデルによって、シンプルなコマンドだけで必要な依存性を解決してパッケージのダウンロード・インストールをすることができます。\n\nPacman は C 言語で書かれており、パッケージングに bsdtar(1) tar フォーマットを使用します。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 使い方 1.1 パッケージのインストール 1.1.1 特定のパッケージのインストール 1.1.1.1 仮想パッケージ 1.1.2 パッケージグループのインストール 1.2 パッケージの削除 1.3 パッケージのアップグレード 1.4 パッケージ・データベースに問い合わせる 1.4.1 Pactree 1.4.2 データベースの構造 1.5 パッケージキャッシュの削除 1.6 その他のコマンド 1.6.1 ドライラン 1.7 インストール理由 1.8 特定のファイルが含まれているパッケージを検索 1.9 パッケージのインストール/アップグレード/アンインストール時に起こること\n- 2 設定 2.1 全般設定 2.1.1 アップデートする前にバージョンを比較 2.1.2 並列ダウンロードを有効にする 2.1.3 アップグレードさせないパッケージを設定 2.1.4 アップグレードさせないパッケージグループを設定 2.1.5 アップグレードさせないファイルを設定 2.1.6 インストールさせないファイルを設定 2.1.7 複数の設定ファイルを使用 2.1.8 フック 2.2 リポジトリとミラー 2.2.1 パッケージのキャッシュディレクトリ 2.2.2 パッケージのセキュリティ\n- 3 トラブルシューティング 3.1 \"Failed to commit transaction (conflicting files)\" エラー 3.2 \"Failed to commit transaction (invalid or corrupted package)\" エラー 3.3 \"Failed to init transaction (unable to lock database)\" エラー 3.4 インストール時にパッケージを取得できない 3.5 アップグレードの中断によって起動できなくなったシステムを修復する 3.6 アップグレード中に pacman がクラッシュしてしまった 3.6.1 pacman: command not found 3.7 Pacman の手動再インストール 3.7.1 pacman-static を使う 3.7.2 外部の pacman を使う 3.7.3 手動で抽出する 3.8 再起動後に \"Unable to find root device\" エラー 3.9 \"Warning: current locale is invalid; using default \"C\" locale\" エラー 3.10 Pacman がプロキシの設定に従わない 3.11 パッケージが明示的にインストールされたか依存関係としてインストールされたかの情報を保持しつつ、全パッケージを再インストールするには? 3.12 \"Cannot open shared object file\" エラー 3.13 パッケージのダウンロード時にフリーズする 3.14 Failed retrieving file 'core.db' from mirror 3.15 error: 'local-package.pkg.tar': permission denied 3.16 error: could not determine cachedir mount point /var/cache/pacman/pkg 3.17 error: GPGME error: No data 3.18 壊れている、または同期されていないパッケージを再インストールする\n- 4 参照\n\n- 1.1 パッケージのインストール 1.1.1 特定のパッケージのインストール 1.1.1.1 仮想パッケージ 1.1.2 パッケージグループのインストール\n- 1.2 パッケージの削除\n- 1.3 パッケージのアップグレード\n- 1.4 パッケージ・データベースに問い合わせる 1.4.1 Pactree 1.4.2 データベースの構造\n- 1.5 パッケージキャッシュの削除\n- 1.6 その他のコマンド 1.6.1 ドライラン\n- 1.7 インストール理由\n- 1.8 特定のファイルが含まれているパッケージを検索\n- 1.9 パッケージのインストール/アップグレード/アンインストール時に起こること\n\n- 1.1.1 特定のパッケージのインストール 1.1.1.1 仮想パッケージ\n- 1.1.2 パッケージグループのインストール\n\n- 1.1.1.1 仮想パッケージ\n\n- 1.4.1 Pactree\n- 1.4.2 データベースの構造\n\n- 1.6.1 ドライラン\n\n- 2.1 全般設定 2.1.1 アップデートする前にバージョンを比較 2.1.2 並列ダウンロードを有効にする 2.1.3 アップグレードさせないパッケージを設定 2.1.4 アップグレードさせないパッケージグループを設定 2.1.5 アップグレードさせないファイルを設定 2.1.6 インストールさせないファイルを設定 2.1.7 複数の設定ファイルを使用 2.1.8 フック\n- 2.2 リポジトリとミラー 2.2.1 パッケージのキャッシュディレクトリ 2.2.2 パッケージのセキュリティ\n\n- 2.1.1 アップデートする前にバージョンを比較\n- 2.1.2 並列ダウンロードを有効にする\n- 2.1.3 アップグレードさせないパッケージを設定\n- 2.1.4 アップグレードさせないパッケージグループを設定\n- 2.1.5 アップグレードさせないファイルを設定\n- 2.1.6 インストールさせないファイルを設定\n- 2.1.7 複数の設定ファイルを使用\n- 2.1.8 フック\n\n- 2.2.1 パッケージのキャッシュディレクトリ\n- 2.2.2 パッケージのセキュリティ\n\n- 3.1 \"Failed to commit transaction (conflicting files)\" エラー\n- 3.2 \"Failed to commit transaction (invalid or corrupted package)\" エラー\n- 3.3 \"Failed to init transaction (unable to lock database)\" エラー\n- 3.4 インストール時にパッケージを取得できない\n- 3.5 アップグレードの中断によって起動できなくなったシステムを修復する\n- 3.6 アップグレード中に pacman がクラッシュしてしまった 3.6.1 pacman: command not found\n- 3.7 Pacman の手動再インストール 3.7.1 pacman-static を使う 3.7.2 外部の pacman を使う 3.7.3 手動で抽出する\n- 3.8 再起動後に \"Unable to find root device\" エラー\n- 3.9 \"Warning: current locale is invalid; using default \"C\" locale\" エラー\n- 3.10 Pacman がプロキシの設定に従わない\n- 3.11 パッケージが明示的にインストールされたか依存関係としてインストールされたかの情報を保持しつつ、全パッケージを再インストールするには?\n- 3.12 \"Cannot open shared object file\" エラー\n- 3.13 パッケージのダウンロード時にフリーズする\n- 3.14 Failed retrieving file 'core.db' from mirror\n- 3.15 error: 'local-package.pkg.tar': permission denied\n- 3.16 error: could not determine cachedir mount point /var/cache/pacman/pkg\n- 3.17 error: GPGME error: No data\n- 3.18 壊れている、または同期されていないパッケージを再インストールする\n\n- 3.6.1 pacman: command not found\n\n- 3.7.1 pacman-static を使う\n- 3.7.2 外部の pacman を使う\n- 3.7.3 手動で抽出する\n\n"
    },
    {
      "title": "使い方",
      "level": 2,
      "content": "pacman で何ができるかをちゃんと学びたい場合、pacman(8) を参照してください。以下にあるのは pacman でできることのほんの一例です。\n\n"
    },
    {
      "title": "パッケージのインストール",
      "level": 3,
      "content": "パッケージとは、以下を含むアーカイブです:\n\n- アプリケーションの (コンパイルされた) 全ファイル\n- アプリケーションのメタデータ (アプリケーション名、バージョン、依存関係など)\n- pacman によって使用されるインストールファイル及びディレクティブ\n\nArch のパッケージマネージャである pacman は、このようなパッケージをインストール、アップデート、そして削除することができます。プログラムを自分でコンパイルしてインストールする代わりにパッケージを使用することには、様々な利点があります:\n\n- 簡単なアップデート: pacman は、アップデートが利用可能になるとすぐに既存のパッケージを更新します。\n- 依存関係のチェック: pacman は依存関係を処理してくれます。あなたがすべきことは、インストールしたいプログラムを指定することだけです。pacman はそのプログラムと一緒に他の必要なプログラムもインストールします。\n- 綺麗にアンインストール: pacman は、パッケージに含まれる全ファイルのリストを保持します。これにより、パッケージを削除する際に意図せずファイルが残留することはありません。\n\n- パッケージには、任意の依存パッケージが設定されていることがあります。必ずインストールする必要はありませんが、インストールすることで機能が追加されます。pacman は、パッケージのインストール時に任意の依存パッケージのリストを表示しますが、そのリストは pacman.log に残りません。#パッケージ・データベースに問い合わせる コマンドを使うことで、パッケージの任意の依存パッケージを見ることができます。\n- 他のパッケージの (任意の) 依存パッケージとしてパッケージをインストールする場合 (つまり、そのパッケージ自体は必要としていない場合)、--asdeps オプションを使用することを推奨します。詳しくは #インストール理由 セクションを参照。\n\n"
    },
    {
      "title": "特定のパッケージのインストール",
      "level": 4,
      "content": "ひとつ、あるいは複数のパッケージを、依存パッケージも含めてインストールするには、以下のコマンドを実行してください:\n\n```\n# pacman -S パッケージ名1 パッケージ名2 ...\n```\n\n正規表現を使ってパッケージをインストールするには (このフォーラムスレッド を参照):\n\n```\n# pacman -S $(pacman -Ssq パッケージのパターン)\n```\n\n別々のリポジトリ (例: extra と testing) 内に同一のパッケージの複数のバージョンが存在していることがあります。この場合、パッケージ名の前にリポジトリ名を明示する必要があります。例えば extra リポジトリ内のバージョンをインストールするには:\n\n```\n# pacman -S extra/パッケージ名\n```\n\n名前に類似パターンが存在するパッケージをインストールしたい場合、波括弧を使ってパッケージ名を展開することができます。例えば:\n\n```\n# pacman -S plasma-{desktop,mediacenter,nm}\n```\n\n必要に応じて更に複雑なパターンを指定することもできます:\n\n```\n# pacman -S plasma-{workspace{,-wallpapers},pa}\n```\n\n仮想パッケージとは、それ自体は存在していないが、1つ以上のパッケージによって provides (提供) 指定されている特殊なパッケージです。仮想パッケージが存在していることにより、あるパッケージの依存関係として複数の候補が存在している場合に、パッケージは特定のパッケージを依存関係として指定する必要がなくなります。仮想パッケージはその名前を使ってインストールすることはできません。仮想パッケージを provide (提供) するパッケージをインストールすると、その仮想パッケージがシステムにインストールされたことになります。例としては dbus-units パッケージがあります。\n\n"
    },
    {
      "title": "パッケージグループのインストール",
      "level": 4,
      "content": "パッケージグループに属しているパッケージをすべて同時にインストールすることができます。例えば:\n\n```\n# pacman -S gnome\n```\n\nを実行すると gnome グループからインストールしたいパッケージを選択するように表示されます。\n\nパッケージグループには大量のパッケージが含まれており、しばしばインストールしたいパッケージはそのうちの少しだけということがあるかもしれません。インストールするパッケージの番号を全て入力するという方法でもよいですが、以下のような構文を使うことで簡単にパッケージを選択することが可能です:\n\n```\nEnter a selection (default=all): 1-10 15\n```\n\n以上で1番から10番までと15番のパッケージがインストールされます。\n\n```\nEnter a selection (default=all): ^5-8 ^2\n```\n\n以上で5番から8番までと2番のパッケージ以外の全てのパッケージをインストールします。\n\nどのパッケージが gnome グループに属しているか見るには:\n\n```\n$ pacman -Sg gnome\n```\n\nどのようなパッケージグループがあるかは https://www.archlinux.jp/groups/ を見て下さい。\n\n"
    },
    {
      "title": "パッケージの削除",
      "level": 3,
      "content": "依存パッケージをすべて残したままパッケージを削除するには:\n\n```\n# pacman -R パッケージ名\n```\n\n削除したいパッケージと、そのパッケージだけが必要としている依存パッケージを一緒に削除するには:\n\n```\n# pacman -Rs パッケージ名\n```\n\n上記のコマンドは、必要とされているパッケージを含んでいるグループを削除する際に、実行を拒否する場合があります。そのような場合は、以下を試してください:\n\n```\n# pacman -Rsu パッケージ名\n```\n\n削除したいパッケージと、そのパッケージの依存パッケージ、さらに削除したいパッケージに依存しているパッケージを削除するには:\n\n```\n# pacman -Rsc パッケージ名\n```\n\n他のパッケージによって必要とされているパッケージを、必要としているパッケージを削除せずに削除するには:\n\n```\n# pacman -Rdd パッケージ名\n```\n\nPacman は、特定のアプリケーションを削除する際に、重要な設定ファイルを削除せずに .pacsave 拡張子を付けてバックアップします。これらのバックアップファイルの作成を行わないようにするには、-n オプションを付けてください:\n\n```\n# pacman -Rn パッケージ名\n```\n\n"
    },
    {
      "title": "パッケージのアップグレード",
      "level": 3,
      "content": "- Arch ユーザーは、システムメンテナンス#システムのアップグレード セクションのガイダンスに従ってシステムを定期的にアップグレードすることが期待されます。以下のコマンドを闇雲に実行するべきではありません。\n- Arch Linux は完全なシステムアップグレードのみをサポートしています。詳細は システムメンテナンス#部分的なアップグレードはサポートされていません と #パッケージのインストール を参照してください。\n\nPacman はコマンド一つでシステム上の全パッケージをアップデートできます。この処理に掛かる時間は、システムがどれだけ新しいかによります。以下のコマンドは、リポジトリデータベースを同期し、かつ、システム内のパッケージをアップデートします (ただし、リポジトリに無い\"ローカル\"のパッケージを除く):\n\n```\n# pacman -Syu\n```\n\n"
    },
    {
      "title": "パッケージ・データベースに問い合わせる",
      "level": 3,
      "content": "Pacman からローカルデータベースに問い合わせるときは -Q フラグを、同期データベースに問い合わせるときは -S フラグを、ファイルデータベースに問い合わせるときは -F フラグを使います。それぞれのフラグのサブオプションについては pacman -Q --help、pacman -S --help、pacman -F --help を見てください。\n\nPacman はデータベースからパッケージを検索することができます。パッケージ名と説明の両方を検索するには:\n\n```\n$ pacman -Ss 検索ワード1 検索ワード2 ...\n```\n\n場合によっては、-s の組み込みの ERE (拡張正規表現) によって、余計な検索結果が大量に出てきてしまうことがあるでしょう。そのようなときは検索対象をパッケージ名だけに絞ってみてください:\n\n```\n$ pacman -Ss '^vim-'\n```\n\n既にインストール済みのパッケージから検索するには:\n\n```\n$ pacman -Qs 検索ワード1 検索ワード2 ...\n```\n\nリモートパッケージからパッケージファイルの名前で検索するには:\n\n```\n$ pacman -F 検索ワード1 検索ワード2 ...\n```\n\nパッケージ名を指定して詳細な情報を得るには:\n\n```\n$ pacman -Si パッケージ名\n```\n\nローカルにインストールされているパッケージの詳細な情報を得るには:\n\n```\n$ pacman -Qi パッケージ名\n```\n\n-i フラグを2つ付けることで、バックファイルのリストとバックアップファイルの変更状態も同時に表示できます:\n\n```\n$ pacman -Qii パッケージ名\n```\n\nあるパッケージによってインストールされたファイルの一覧を得るには:\n\n```\n$ pacman -Ql パッケージ名\n```\n\nリモートパッケージによってインストールされるファイルのリストを得るには:\n\n```\n$ pacman -Fl パッケージ名\n```\n\nあるパッケージによってインストールされたファイルが存在しているか確認するには:\n\n```\n$ pacman -Qk パッケージ名\n```\n\nk フラグを2つ付けると、より徹底したチェックが行われます。\n\nデータベースを検索して、あるファイルがどのパッケージに属しているかを調べるには:\n\n```\n$ pacman -Qo /パス/ファイル名\n```\n\nあるファイルがどのリモートパッケージに属しているかデータベースに問い合わせるには:\n\n```\n$ pacman -F /パス/ファイル名\n```\n\n他のパッケージに必要とされていないパッケージ (孤児) の一覧を得るには:\n\n```\n$ pacman -Qdt\n```\n\n明示的にインストールしたパッケージで、依存関係として必要とされていないパッケージを全て表示するには:\n\n```\n$ pacman -Qet\n```\n\nその他の例については pacman/ヒントとテクニック を参照してください。\n\n"
    },
    {
      "title": "Pactree",
      "level": 4,
      "content": "あるパッケージの依存関係ツリー (dependency tree、つまり、そのパッケージが必要としているパッケージの木) を表示するには:\n\n```\n$ pactree パッケージ名\n```\n\nあるパッケージの被依存ツリー (dependant tree、つまり、そのパッケージを必要としているパッケージの木) を表示するには、逆フラグ -r を pactree に渡てください。\n\n"
    },
    {
      "title": "データベースの構造",
      "level": 4,
      "content": "pacman データベースは通常、/var/lib/pacman/sync にあります。/etc/pacman.conf で指定された各リポジトリに対して、対応するデータベースファイルがこのディレクトリ内に存在します。データベースファイルは、パッケージごとに 1 つのディレクトリを含む gzip 圧縮された tar アーカイブです。たとえば、which パッケージの場合は次のようになります:\n\n```\n$ tree which-2.21-5\n```\n\n```\nwhich-2.21-5\n|-- desc\n```\n\ndesc ファイルには、パッケージの説明、依存関係、ファイルサイズ、MD5 ハッシュなどのメタデータが含まれています。\n\n"
    },
    {
      "title": "パッケージキャッシュの削除",
      "level": 3,
      "content": "Pacman は、ダウンロードしたファイルを /var/cache/pacman/pkg/ に保存しますが、これらは古くなってもアンインストールされても自動的に削除されません。これにはいくつかの利点があります:\n\n1. パッケージをダウングレードする際に、他の方法 (Arch Linux Archive など) によって以前のバージョンを入手する必要がない。\n1. アンインストールされたパッケージをキャッシュディレクトリから簡単に直接再インストールでき、リポジトリから新しくダウンロードする必要がない。\n\nしかし、ディレクトリのサイズが大きくなりすぎないようにするために、定期的にキャッシュを手動でクリーンアップする必要があります。\n\npacman-contrib パッケージで提供されている paccache(8) スクリプトは、インストール済みパッケージとアンインストール済みパッケージのキャッシュ済みバージョンを、最も新しい3つを残して全て削除します (オプションを何も指定しなかった場合):\n\n```\n# paccache -r\n```\n\npaccache.timer を有効化し起動すれば、週に1度、未使用のパッケージキャッシュを削除してくれます。\n\n何個の新しいバージョンのキャッシュを保持するかを指定することも可能です。最も新しいバージョン1つだけを保持するには:\n\n```\n# paccache -rk1\n```\n\n-u/--uninstalled スイッチを加えれば、アンインストールされたパッケージに対象を絞ることもできます。例えば、アンインストールされたパッケージのキャッシュを全て削除するには:\n\n```\n# paccache -ruk0\n```\n\nその他のオプションは paccache -h を見てください。\n\nまた、Pacman にも、パッケージキャッシュと、/etc/pacman.conf 設定ファイルにもはや存在しないリポジトリの残留データベースファイルをクリーンアップする組み込みコマンドが存在します。しかし、pacman では、パッケージキャッシュのバージョンをいくつ残すか指定することができないため、paccache のデフォルトオプションよりも強引です。\n\n現在インストールされていないパッケージのキャッシュと、未使用の同期データベースをを全て削除するには:\n\n```\n# pacman -Sc\n```\n\n全てのキャッシュファイルを削除するには、c スイッチを2度使用してください。これは最も強引なアプローチであり、キャッシュディレクトリには何も残りません:\n\n```\n# pacman -Scc\n```\n\nさらに、キャッシュをクリーンアップするツールとして pkgcachecleanAUR と pacleanerAUR もあります。\n\n"
    },
    {
      "title": "その他のコマンド",
      "level": 3,
      "content": "パッケージをダウンロードするが、インストールはしない:\n\n```\n# pacman -Sw パッケージ名\n```\n\nリモートリポジトリ以外の'ローカル'のパッケージをインストールする (例えば、AUR のパッケージ):\n\n```\n# pacman -U /path/to/package/package_name-version.pkg.tar.zst\n```\n\nローカルパッケージのコピーを pacman のキャッシュに保持するには:\n\n```\n# pacman -U file:///path/to/package/package_name-version.pkg.tar.zst\n```\n\n(pacman の設定ファイルに記述されているリポジトリ以外の) 'リモート'パッケージをインストールする:\n\n```\n# pacman -U http://www.example.com/repo/example.pkg.tar.zst\n```\n\n"
    },
    {
      "title": "ドライラン",
      "level": 4,
      "content": "Pacman は常に、インストールされるパッケージと削除されるパッケージを一覧表示して、操作を行う前にユーザに許可を求めます。\n\n--print (短いバージョンは -p) を使用することで、-S、-U、-R のアクションを行わずに、パッケージの一覧を処理可能な形式で表示できます。\n\n--print-format を追加すれば、このリストを様々な形にフォーマットできます。例えば、--print-format %n は、パッケージのバージョン無しでパッケージの一覧を表示します。\n\n"
    },
    {
      "title": "インストール理由",
      "level": 3,
      "content": "pacman データベースでは、インストールしたパッケージはインストール理由によって2つのグループに分別されます:\n\n- 明示的にインストール: pacman の -S や -U コマンドによって文字通り指定されたパッケージ。\n- 依存パッケージ: pacman のインストールコマンドにパッケージの名前は指定されず、明示的にインストールした他のパッケージから必要とされたためにインストールされたパッケージ。\n\nパッケージのインストール時、以下のようにすることでインストール理由を依存パッケージに強制的に変えることができます:\n\n```\n# pacman -S --asdeps パッケージ名\n```\n\n明示的にインストールしたパッケージが、必須でない機能のための任意の依存パッケージを提供している場合があります。大抵、このコマンドはそのようなパッケージをインストールするために使用されます。\n\nパッケージの再インストールを行っても、デフォルトではインストール理由は変更されません。\n\n明示的にインストールしたパッケージのリストは pacman -Qe で表示でき、依存パッケージのリストは pacman -Qd で表示できます。\n\n既にインストールしたパッケージのインストール理由を変更したい場合、以下のコマンドを実行してください:\n\n```\n# pacman -D --asdeps パッケージ名\n```\n\nUse --asexplicit to do the opposite operation.\n\n"
    },
    {
      "title": "特定のファイルが含まれているパッケージを検索",
      "level": 3,
      "content": "ファイルデータベースを同期してください:\n\n```\n# pacman -Fy\n```\n\nファイルが含まれているパッケージを検索するには:\n\n```\n$ pacman -F pacman\n```\n\n```\ncore/pacman 5.2.1-1 (base base-devel) [installed]\n    usr/bin/pacman\n    usr/share/bash-completion/completions/pacman\nextra/xscreensaver 5.43-1\n    usr/lib/xscreensaver/pacman\n```\n\n高度な使い方をしたい場合、全てのファイルと関連するパッケージのデータベースを使用する pkgfile をインストールしてください。\n\n"
    },
    {
      "title": "パッケージのインストール/アップグレード/アンインストール時に起こること",
      "level": 3,
      "content": "成功時のトランザクションは、5つのステップと、トランザクション前と後のフックで構成されます:\n\n1. データベースがロックされていない場合、トランザクションを初期化する。\n1. トランザクション中に追加/削除すべきパッケージを選択する。\n1. 同期データベース、パッケージ、及びパッケージ間の依存関係のサニティチェックを行い、コマンドラインフラグに基づいてトランザクションの準備をする。\n1. トランザクションを実行する: 必要に応じてパッケージをダウンロードする (_alpm_sync_load)。 pacman の既存の PreTransaction フックが適用される場合、それらのフックを実行する。 最終的に置き換えられるパッケージ、衝突するパッケージ、明示的に削除するように指定されたパッケージを削除する。 追加するべきパッケージが存在する場合、各パッケージに対して以下を実行する: パッケージにインストールスクリプトが存在する場合、そのスクリプトの pre_install 関数を実行する (アップグレードする場合は pre_upgrade が、削除される場合は pre_remove が代わりに実行されます)。 以前のバージョンのパッケージのファイルを全て削除する (パッケージをアップグレードまたは削除する場合)。ただし、パッケージによって設定ファイルであると指定されたファイルに関しては、削除しない (pacman/Pacnew と Pacsave を参照)。 パッケージを解凍し、含まれているファイルをファイルシステムに保存する (パッケージをインストールまたはアップグレードする場合)。新しいパッケージのファイルが、ファイルシステム上の手動で変更された設定ファイル (前のステップを参照) を上書きしてしまう場合、パッケージ側のファイルに別の名前 (.pacnew) を付けて保存する。 パッケージにインストールスクリプトが存在する場合、post_install 関数を実行する (アップグレードする場合は post_upgrade が、削除される場合は post_remove が代わりに実行されます)。 トランザクションの終わりの時点で存在している PostTransaction フックが適用される場合、それらのフックを実行する。\n1. トランザクション及びトランザクションリソース (つまり、データベースロック) を解放する。\n\n1. 必要に応じてパッケージをダウンロードする (_alpm_sync_load)。\n1. pacman の既存の PreTransaction フックが適用される場合、それらのフックを実行する。\n1. 最終的に置き換えられるパッケージ、衝突するパッケージ、明示的に削除するように指定されたパッケージを削除する。\n1. 追加するべきパッケージが存在する場合、各パッケージに対して以下を実行する: パッケージにインストールスクリプトが存在する場合、そのスクリプトの pre_install 関数を実行する (アップグレードする場合は pre_upgrade が、削除される場合は pre_remove が代わりに実行されます)。 以前のバージョンのパッケージのファイルを全て削除する (パッケージをアップグレードまたは削除する場合)。ただし、パッケージによって設定ファイルであると指定されたファイルに関しては、削除しない (pacman/Pacnew と Pacsave を参照)。 パッケージを解凍し、含まれているファイルをファイルシステムに保存する (パッケージをインストールまたはアップグレードする場合)。新しいパッケージのファイルが、ファイルシステム上の手動で変更された設定ファイル (前のステップを参照) を上書きしてしまう場合、パッケージ側のファイルに別の名前 (.pacnew) を付けて保存する。 パッケージにインストールスクリプトが存在する場合、post_install 関数を実行する (アップグレードする場合は post_upgrade が、削除される場合は post_remove が代わりに実行されます)。\n1. トランザクションの終わりの時点で存在している PostTransaction フックが適用される場合、それらのフックを実行する。\n\n1. パッケージにインストールスクリプトが存在する場合、そのスクリプトの pre_install 関数を実行する (アップグレードする場合は pre_upgrade が、削除される場合は pre_remove が代わりに実行されます)。\n1. 以前のバージョンのパッケージのファイルを全て削除する (パッケージをアップグレードまたは削除する場合)。ただし、パッケージによって設定ファイルであると指定されたファイルに関しては、削除しない (pacman/Pacnew と Pacsave を参照)。\n1. パッケージを解凍し、含まれているファイルをファイルシステムに保存する (パッケージをインストールまたはアップグレードする場合)。新しいパッケージのファイルが、ファイルシステム上の手動で変更された設定ファイル (前のステップを参照) を上書きしてしまう場合、パッケージ側のファイルに別の名前 (.pacnew) を付けて保存する。\n1. パッケージにインストールスクリプトが存在する場合、post_install 関数を実行する (アップグレードする場合は post_upgrade が、削除される場合は post_remove が代わりに実行されます)。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "Pacman の設定は /etc/pacman.conf に記述します。ここで、pacman がどのように動作するかを設定することができます。この設定ファイルに関するより詳しい情報は pacman.conf(5) にあります。\n\n"
    },
    {
      "title": "全般設定",
      "level": 3,
      "content": "全般的な設定は [options] セクションにあります。ここで設定できる項目については pacman.conf(5) を読むか、デフォルトの pacman.conf ファイルを見てください。\n\n"
    },
    {
      "title": "アップデートする前にバージョンを比較",
      "level": 4,
      "content": "利用可能なパッケージの新旧のバージョンを確認したい場合、/etc/pacman.conf の \"VerbosePkgLists\" という行をアンコメントしてください。pacman -Syu の出力が以下のようになります:\n\n```\nパッケージ (6)          古いバージョン  新しいバージョン  最終的な変化 ダウンロード容量\n\nextra/libmariadbclient  10.1.9-4        10.1.10-1             0.03 MiB         4.35 MiB\nextra/libpng            1.6.19-1        1.6.20-1              0.00 MiB         0.23 MiB\nextra/mariadb           10.1.9-4        10.1.10-1             0.26 MiB        13.80 MiB\n```\n\n"
    },
    {
      "title": "並列ダウンロードを有効にする",
      "level": 4,
      "content": "並列にダウンロードするパッケージの数は、/etc/pacman.conf の [options] セクション内の ParallelDownloads オプションで設定できます。このオプションが設定されていない場合、パッケージは1つずつダウンロードされます。\n\n"
    },
    {
      "title": "アップグレードさせないパッケージを設定",
      "level": 4,
      "content": "システムをアップグレードする際に特定のパッケージをアップグレードシないようにするには、[options] セクションに以下の行を追加してください:\n\n```\nIgnorePkg=linux\n```\n\n複数のパッケージを指定する場合は、スペースで区切るか、IgnorePkg 行を追加してください。また、グロブパターンも使用できます。一度に限ってパッケージをアップグレードしないようにするには、コマンドラインで --ignore オプションを使用してください (複数のパッケージを指定する場合は、コンマで区切ってください)。\n\npacman -S を使えば、依然として対象のパッケージをアップグレードすることが可能です。この場合、pacman はパッケージが IgnorePkg 文に含まれていることを知らせてくれます。\n\n"
    },
    {
      "title": "アップグレードさせないパッケージグループを設定",
      "level": 4,
      "content": "パッケージの場合と同様に、アップグレードさせないパッケージグループを指定することもできます:\n\n```\nIgnoreGroup=gnome\n```\n\n"
    },
    {
      "title": "アップグレードさせないファイルを設定",
      "level": 4,
      "content": "NoUpgrade ディレクティブで指定されたファイルは、パッケージのインストール/アップグレードの際に変更を加えられなくなり、代わりに新しいファイルは .pacnew 拡張子が付けられてインストールされます。\n\n```\nNoUpgrade=path/to/file\n```\n\n以下のようにして複数のファイルを指定することができます:\n\n```\nNoUpgrade=path/to/file1 path/to/file2\n```\n\n"
    },
    {
      "title": "インストールさせないファイルを設定",
      "level": 4,
      "content": "特定のディレクトリまたはファイルをインストールさせないようにするには、NoExtract リストにそのディレクトリを加えてください。例えば、systemd ユニットをインストールさせないようにするには:\n\n```\nNoExtract=usr/lib/systemd/system/*\n```\n\n後ろのルールは前のルールを上書きします。また、! を前に付けることでルールを無効化できます。\n\n"
    },
    {
      "title": "複数の設定ファイルを使用",
      "level": 4,
      "content": "設定ファイルが複数あって (メインの設定と testing リポジトリを有効にした設定がある場合など)、設定ファイルのオプションを共有したい場合、設定ファイルで Include オプションを宣言することができます。例:\n\n```\nInclude = /path/to/common/settings\n```\n\n/path/to/common/settings は共有したいオプションが存在するファイルに置き換えてください。\n\n"
    },
    {
      "title": "フック",
      "level": 4,
      "content": "Pacman は /usr/share/libalpm/hooks/ ディレクトリ内に存在するフックをトランザクションの前後に実行することができます。その他のフックディレクトリを指定したい場合は、pacman.conf 内で HookDir オプションを使ってください (デフォルトは /etc/pacman.d/hooks です)。フックファイルの名前には必ず .hook を後ろに付ける必要があります。Pacman フックはインタラクティブではありません。\n\nPacman フックは様々なことに使われています。例えば、systemd-sysusers と systemd-tmpfiles を組み合わせてパッケージのインストール時に自動的にシステムユーザーを作成します。例として tomcat8 パッケージでは tomcat8 という名前のシステムユーザーが必要だと指定されており、特定のディレクトリの所有者がこのユーザーになるように設定されています。pacman フックの systemd-sysusers.hook と systemd-tmpfiles.hook は、tomcat8 にユーザが指定されているファイルと一時ファイルが存在していることを認識し、systemd-sysusers と systemd-tmpfiles を実行します。\n\nalpm のフックに関する詳細は alpm-hooks(5) を参照してください。\n\n"
    },
    {
      "title": "リポジトリとミラー",
      "level": 3,
      "content": "特殊な [options] セクションを除いて、pacman.conf 内の他の [セクション] には、使用するパッケージリポジトリを定義します。リポジトリとはパッケージの論理的な集合であり、それらのパッケージは1つ以上のサーバに物理的に保存されています。このような理由から、各サーバはリポジトリのミラーと呼ばれます。\n\nリポジトリは公式と非公式に分けられています。設定ファイル内でのリポジトリの順番は重要です。2つのリポジトリに同じ名前のパッケージが存在する場合、それらのバージョン番号に関わらず、設定ファイル内で最初に来るリポジトリが、その後に来るリポジトリよりも優先されます。リポジトリを使用するには、そのリポジトリを追加した後に、まずシステム全体をアップグレードする必要があります。\n\n各リポジトリセクションではミラーのリストを定義します: ミラーのリストを直接記述することもできますし、Include ディレクティブを使って外部の専用のファイルを使うこともできます。例えば、公式リポジトリのミラーは /etc/pacman.d/mirrorlist からインクルードされます。ミラーの設定については記事 ミラー を参照してください。\n\n"
    },
    {
      "title": "パッケージのキャッシュディレクトリ",
      "level": 4,
      "content": "Pacman は、ダウンロードしたパッケージファイルをキャッシュに保存します。キャッシュは、pacman.conf の [options] セクション内の CacheDir で示されるディレクトリ内です (設定されていない場合、/var/cache/pacman/pkg/ がデフォルトで使用されます)。\n\nキャッシュディレクトリは、(たとえ、インストールされているパッケージの最新のバージョンのみを保持しているとしても) 時間とともに肥大化する場合があります。\n\nキャッシュディレクトリを他のより好都合な場所に移動したい場合は、以下のどれかを行ってください:\n\n- pacman.conf 内の CacheDir オプションで新しいディレクトリを設定する。末尾のスラッシュを残しておくことを忘れないでください。これが推奨される方法です。\n- /var/cache/pacman/pkg/ に専用のパーティションや Btrfs サブボリュームをマウントする。\n- 選択したディレクトリを /var/cache/pacman/pkg/ でバインドマウントする。\n\n"
    },
    {
      "title": "パッケージのセキュリティ",
      "level": 4,
      "content": "Pacman はパッケージの署名をサポートしていて、パッケージにセキュリティレイヤーを加えています。デフォルトの設定では SigLevel = Required DatabaseOptional によって全てのリポジトリで全てのパッケージの署名検証が有効にされています。リポジトリ毎に SigLevel を使うことでこの設定を上書きすることができます。パッケージに署名する方法や署名の検証について詳しくは、pacman-key を見てください。\n\n"
    },
    {
      "title": "\"Failed to commit transaction (conflicting files)\" エラー",
      "level": 3,
      "content": "次のエラーが表示される場合: [1]\n\n```\nエラー: 処理を完了できませんでした (衝突しているファイル)\npackage: /path/to/file がファイルシステムに存在しています\nエラーが発生したため、パッケージは更新されませんでした。\n```\n\nこれは、pacman がファイルの衝突を検出し、仕様によりファイルを上書きしないために発生します。これは仕様によるものであり、欠陥ではありません。\n\n通常、この問題の解決法は自明です (とはいえ、なぜこれらのファイルがそこに存在しているのかを念の為に調べてみるべきでしょう)。まず、他のパッケージがそのファイルを所有していないか調べるのが安全です (pacman -Qo /path/to/file)。そのファイルが他のパッケージによって所有されている場合、バグレポートを提出してください。そのファイルが他のパッケージのよって所有されていない場合、\"ファイルシステムに存在している\"方のファイルの名称を変更し、アップデートのコマンドを再度実行してください。問題がなければ、そのファイルは削除しても良いです。\n\n何らかのプログラムを pacman を使用せずに (例えば make install などで) 手動でインストールしている場合、プログラム自体とそのプログラムに属するファイルを全て削除しなければなりません。pacman/ヒントとテクニック#どのパッケージにも所有されていないファイルを特定する も参照してください。\n\nインストールされたパッケージは、そのパッケージに関するメタデータを含む /var/lib/pacman/local/package-version/files ファイルを提供します。このファイルが破損している、空である、または存在しない場合、パッケージの更新時に file exists in filesystem エラーが発生します。そのようなエラーは通常、1つのパッケージだけが原因です。原因のパッケージに属するファイルの名前を変えて後で削除する代わりに、pacman -S --overwrite glob package を実行して glob にマッチするファイルを上書きすることもできます。\n\n"
    },
    {
      "title": "\"Failed to commit transaction (invalid or corrupted package)\" エラー",
      "level": 3,
      "content": "/var/cache/pacman/pkg/ から .part ファイル (部分的にダウンロードされたパッケージ) を探し、そのファイルを削除してください (これは、pacman.conf でカスタムの XferCommand を使用した場合に起こりやすいです):\n\n```\n# find /var/cache/pacman/pkg/ -iname \"*.part\" -delete\n```\n\nまた、archlinux-keyring が古く、pacman が署名を検証できない場合にも、このエラーが発生することがあります。この問題を解決方法と防止方法は pacman/パッケージの署名#システムの定期的な更新 を参照してください。\n\n"
    },
    {
      "title": "\"Failed to init transaction (unable to lock database)\" エラー",
      "level": 3,
      "content": "pacman がパッケージデータベースを変更する際に (パッケージのインストール時など)、pacman はロックファイル /var/lib/pacman/db.lck を作成します。これにより、複数の pacman インスタンスが同時にパッケージデータベースを変更してしまうことを防ぎます。\n\npacman がデータベースの変更中に中断されてしまった場合、古いロックファイルが残ってしまう可能性があります。pacman インスタンスが実行中でないことが確実である場合は、ロックファイルを削除してください:\n\n```\n# rm /var/lib/pacman/db.lck\n```\n\n"
    },
    {
      "title": "インストール時にパッケージを取得できない",
      "level": 3,
      "content": "具体的には次のようなエラーです: Not found in sync db、対象が見つかりませんでした、ファイルの取得に失敗しました。\n\nまず、パッケージが実際に存在することを確認してください。パッケージが存在することが確実であるならば、パッケージデータベースが古いのかもしれません。pacman -Syu を実行して、パッケージデータベースを更新してシステムをアップグレードしてみてください。また、ミラーが最新であり、リポジトリが正しく設定されていることも確認してください。\n\nまた、インストールしたいパッケージが含まれているリポジトリがシステムで有効化されていない可能性もあります。例えば、パッケージが multilib リポジトリにあるが、pacman.conf で multilib が有効化されていない場合、このエラーが発生します。\n\nFAQ#公式リポジトリにある共用ライブラリはそれぞれどうして一つのバージョンしか用意されてないんですか？ も参照してください。\n\n"
    },
    {
      "title": "アップグレードの中断によって起動できなくなったシステムを修復する",
      "level": 3,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: これには複数の潜在的な問題があります。en:Talk:pacman#More details in pacman crashes during an update を参照。 (議論: トーク:Pacman#)\n\n電源断やカーネルパニック、ハードウェア障害によって、アップデートが中断されてしまうことがあります。ほとんどの場合、システムが大きなダメージを負うことはありませんが、起動できなくなってしまうことはあります。\n\n1. USB インストールメディア を用意して、それを起動してください。\n1. ルートファイルシステムをマウントしてください。\n1. マウントしたルートファイルシステムに arch-chroot してください。\n1. 次に、アップデートを完全にやり直します。/var/log/pacman.log を確認し、中断されたトランザクション中にアップグレードされていたパッケージ全てのリストを pacman -S に渡して、再インストールを許可してください。例:\n\n```\n# pacman -S linux linux-headers systemd systemd-libs systemd-sysvcompat firefox texlive-basic texlive-fontsextra texlive-latex texlive-latexextra texlive-latexrecommended texlive-pictures\n```\n\nアップグレードを完全にやり直すのは、適切なスクリプトレットとフックが実行されるようにするために必要だからです。\n\n"
    },
    {
      "title": "アップグレード中に pacman がクラッシュしてしまった",
      "level": 3,
      "content": "pacman が \"database write\" (データベース書き込み) エラーが発生してクラッシュし、その後、パッケージのアンインストール/再インストール/アップグレードができなくなってしまった場合、以下を行ってください:\n\n1. Arch Linux の USB インストールメディアを起動してください。システム上の pacman と同じバージョンかより新しいものを使うために、最近のメディアを使うことが望ましいです。\n1. システムのルートファイルシステムをマウントしてください (例えば、mount /dev/sdaX /mnt を root として実行してください)。そして、df -h を実行してファイルシステムに十分な空き領域が存在することを確認してください。\n1. ファイルシステム proc、sys、dev もマウントしてください: mount -t proc proc /mnt/proc; mount --rbind /sys /mnt/sys; mount --rbind /dev /mnt/dev\n1. システムにおいてデータベースの場所とディレクトリの場所がデフォルトである場合、pacman --root=/mnt --cachedir=/mnt/var/cache/pacman/pkg -Syu を root として実行すればシステムの pacman データベースを更新してシステムをアップグレードすることができます。 アップデート/アップグレードができない場合、pacman/ヒントとテクニック#全てのパッケージの再インストール を参照してください。\n1. アップグレードしたら、アップグレードされていない壊れているパッケージがないかチェックしてください: find /mnt/usr/lib -size 0\n1. そのようなパッケージが依然として存在する場合は、そのパッケージを再インストールしてください: pacman --root /mnt --cachedir=/mnt/var/cache/pacman/pkg -S package。\n\n- アップデート/アップグレードができない場合、pacman/ヒントとテクニック#全てのパッケージの再インストール を参照してください。\n\n"
    },
    {
      "title": "pacman: command not found",
      "level": 4,
      "content": "/var/cache/pacman/pkg がシンボリックリンクである場合、pacman は自己アップデート時に同じディレクトリを作成しようとするため、このシンボリックリンクは削除されます。これにより、アップデートが失敗します。その結果、/usr/bin/pacman と pacman パッケージに含まれる他のコンテンツが消えてしまいます (訳注: #パッケージのインストール/アップグレード/アンインストール時に起こること の 4.2 を参照)。\n\n/var/cache/pacman/pkg は pacman によって管理されているため、シンボリックリンクにしないでください。代わりに CacheDir オプションを使うか、このディレクトリをバインドマウントしてください (#パッケージのキャッシュディレクトリ を参照)。\n\nこの問題が既に発生していて、システムが壊れてしまっている場合、pacman パッケージに含まれる /usr 内のコンテンツを手動で展開して pacman を復元し、その後、適切に pacman を再インストールしてください。詳細は FS#73306 や関連するフォーラムのスレッドを参照してください。\n\n"
    },
    {
      "title": "pacman-static を使う",
      "level": 4,
      "content": "pacman-staticAUR は pacman を静的にコンパイルしたものなので、システム上のライブラリが機能していなくても実行できます。これは、部分的なアップグレードによって pacman が実行できなくなってしまった場合にも便利です。\n\npacman-staticAUR パッケージのページにある固定コメントと PKGBUILD には、バイナリを直接ダウンロードする方法が記されています。pacman を再インストールしたり、部分的なアップグレードが起こった際にシステム全体をアップグレードしたりする際にこの方法が使えます。\n\n"
    },
    {
      "title": "外部の pacman を使う",
      "level": 4,
      "content": "pacman-static でさえも動作しない場合は、外部の pacman を使用してリカバリできます。最も簡単な方法の一つは、archiso を使い、--sysroot か --root で、操作を行うシステム上のマウントポイントを指定することです。--sysroot に必要なファイルシステムをマウントする方法については、Chroot#chroot を使う を参照してください。\n\n"
    },
    {
      "title": "手動で抽出する",
      "level": 4,
      "content": "pacman がどうしようもなく破壊されたとしても、最新のパッケージを手動でダウンロードして適切な場所に展開することで修復が可能です。以下のような手順で行います:\n\n1. インストールすべき pacman の依存関係を調べる。\n1. それぞれの依存パッケージをミラーからダウンロードする。\n1. 各パッケージをルートディレクトリに展開する。\n1. pacman -S --overwrite を実行してパッケージデータベースを更新することで、パッケージを再インストールする。\n1. システムの完全なアップグレードを行う。\n\n正常に動作している Arch システムがあれば、以下のコマンドで pacman の依存関係リストを見ることができます:\n\n```\n$ pacman -Q $(pactree -u pacman)\n```\n\nしかし、発生している問題によっては、それらの依存パッケージのうち数個だけをアップデートすれば良い場合もあります。パッケージは以下のようにして展開します:\n\n```\n# tar -xvpwf package.tar.zst -C / --exclude .PKGINFO --exclude .INSTALL --exclude .MTREE --exclude .BUILDINFO\n```\n\n注意点として、w フラグを使用してインタラクティブモードにしてください。非インタラクティブモードでは、重要なファイルが問答無用で上書きされてしまうかもしれないので、非常に危険です。また、パッケージを展開する順番には注意を払ってください (つまり、依存パッケージを先に展開してください)。このフォーラムの投稿には、pacman のいくつかの依存関係だけが壊れてしまった場合のこの手順の例が書かれてあります。\n\n"
    },
    {
      "title": "再起動後に \"Unable to find root device\" エラー",
      "level": 3,
      "content": "カーネルの更新中に initramfs が破損してしまった可能性が高いです (pacman の --overwrite オプションを不適切に使用すると、起こることがあります)。この状況から抜け出す方法は2つあります。1つ目は、fallback エントリです。\n\nシステムが起動したら、コンソールかターミナルから以下のコマンドを実行して initramfs イメージを再ビルドしてください (以下のコマンドは標準の linux カーネルの場合です):\n\n```\n# mkinitcpio -p linux\n```\n\nこれでうまく行かなかった場合、最新の Arch リリース (CD/DVD あるいは USB スティック) を起動し、ルートパーティションとブートパーティションをそれぞれ /mnt と /mnt/boot にマウントしてください。そして、arch-chroot を使ってルートパーティションに chroot してください:\n\n```\n# arch-chroot /mnt\n# pacman -Syu mkinitcpio systemd linux\n```\n\n- 最新の Arch リリースを持っていない場合や、Arch 以外の \"ライブ\" Linux ディストリビューションしかない場合、昔ながらの方法で chroot することができます。当然、arch-chroot スクリプトを実行する場合よりも、たくさん入力しなければなりません。\n- pacman が Could not resolve host というエラーで失敗してしまう場合、インターネット接続を確認してください。\n- パッケージを再インストールする必要があるが、arch-chroot や chroot の環境に入れない場合、コマンド pacman --sysroot /mnt -Syu foo bar を使えば、別のルートパーティションから pacman を使うことができます。\n\nカーネル (linux パッケージ) を再インストールすれば、mkinitcpio -p linux が実行されて initramfs イメージが再生成されます。イメージの再生成を別途行う必要はありません。\n\nその後、exit、umount /mnt/{boot,} 、そして reboot を実行することが推奨されます。\n\n"
    },
    {
      "title": "\"Warning: current locale is invalid; using default \"C\" locale\" エラー",
      "level": 3,
      "content": "このエラーメッセージが言っている通り、ロケールが正しく設定されていません。ロケールの記事を参照してください。\n\n"
    },
    {
      "title": "Pacman がプロキシの設定に従わない",
      "level": 3,
      "content": "関連する環境変数 ($http_proxy、$ftp_proxy など) が設定されていることを確認してください。pacman を sudo で実行する場合、環境変数を pacman に渡すように sudo を設定する必要があります。また、dirmngr の設定ファイル /etc/pacman.d/gnupg/dirmngr.conf で、鍵をリフレッシュする際にプロキシの設定に従うようにする honor-http-proxy オプションが存在していることも確認してください。\n\n"
    },
    {
      "title": "パッケージが明示的にインストールされたか依存関係としてインストールされたかの情報を保持しつつ、全パッケージを再インストールするには?",
      "level": 3,
      "content": "ネイティブなパッケージ (つまり、同期データベース内に存在するパッケージ) を全て再インストールするには、pacman -Qnq | pacman -S - か pacman -S $(pacman -Qnq) を実行してください (-S オプションはデフォルトでインストール理由を維持します)。\n\n次に、外部のパッケージを全て再インストールする必要があります。これらのパッケージの一覧は pacman -Qmq で得られます。\n\n"
    },
    {
      "title": "\"Cannot open shared object file\" エラー",
      "level": 3,
      "content": "どうやら、以前の pacman トランザクションで、pacman 自体が必要とする共有ライブラリが削除されたか破損したようです。\n\nこの問題を解決するには、必要なライブラリをファイルシステム上に手動で展開する必要があります。まず、必要なライブラリを含むパッケージを調べ、pacman キャッシュ (/var/cache/pacman/pkg/) からそのパッケージを見つけてください。そして、その共有ライブラリをファイルシステム上へ展開してください。これで pacman が実行できるようになりました。\n\nその後、壊れたパッケージを再インストールする必要があります。注意点として、システムファイルがファイルシステム上に展開されたことを pacman は知らないため、--overwrite フラグを使用する必要があります。Pacman は、先程の共有ライブラリファイルをパッケージのものに適切に置き換えてくれます。\n\nやるべきことは以上です。あとはシステムの残りも更新してください。\n\n"
    },
    {
      "title": "パッケージのダウンロード時にフリーズする",
      "level": 3,
      "content": "pacman がリポジトリのアップデートや同期をできないというネットワークの問題がいくつか報告されています [2] [3]。Arch Linux のインストール時にこの問題が発生する場合、pacman のデフォルトのファイルダウンローダを置き換えることで解決します (詳しくは pacman のパフォーマンスの向上を参照)。VirtualBox で Arch Linux をゲスト OS としてインストールする時にこの問題が起こる場合、マシンのプロパティで NAT の代わりに Host interface を使うことで解決します。\n\n"
    },
    {
      "title": "Failed retrieving file 'core.db' from mirror",
      "level": 3,
      "content": "ミラーを正しく設定しているにも関わらずこのエラーが発生する場合、別のネームサーバーを設定してみてください。\n\n"
    },
    {
      "title": "error: 'local-package.pkg.tar': permission denied",
      "level": 3,
      "content": "pacman -U を使用して sshfs のマウントポイント上にパッケージをインストールしようとしてこのエラーが発生する場合、インストールしたいパッケージをローカルのディレクトリに移動し、もう一度インストールしてみてください。\n\n"
    },
    {
      "title": "error: could not determine cachedir mount point /var/cache/pacman/pkg",
      "level": 3,
      "content": "Chroot 環境内で pacman -Syu などを実行した際に以下のエラーが発生する場合:\n\n```\nエラー: キャッシュディレクトリ /var/cache/pacman/pkg のマウントポイントを決定できませんでした\nエラー: 処理を完了できませんでした (空き容量が足りません)\n```\n\nこのエラーのよくある原因は、chroot したディレクトリがマウントポイントでないことです。解決策は、既存の Linux からインストール#基本ツールをダウンロード に書かれてあるノートを見てください。また、arch-chroot(8) には、バインとマウントを使って chroot ディレクトリをマウントポイント化する方法について例と共に説明されています。\n\n"
    },
    {
      "title": "error: GPGME error: No data",
      "level": 3,
      "content": "パッケージを更新できず、このエラーが発生する場合は、更新する前に rm -r /var/lib/pacman/sync/ を実行してみてください。\n\nSync ファイルを削除しても問題が解決しない場合は、更新する前に file /var/lib/pacman/sync/* を実行して sync ファイルが gzip compressed data であることを確認してください。ルーターかプロキシが、ダウンロードしたデータを破損させているのかもしれません。\n\nSync ファイルが正しい種類であった場合、ミラーサーバー側に問題があるのかもしれません。pacman-conf -r core と pacman-conf -r extra でミラーサーバーを確認してください。表示された URL の一番最初のものをブラうさの URL 欄にペーストし、ファイルの一覧が表示されるか確かめてください。ミラーがエラーを返した場合、/etc/pacman.d/mirrorlist 内のそのミラーをコメントアウトしてください。\n\n"
    },
    {
      "title": "壊れている、または同期されていないパッケージを再インストールする",
      "level": 3,
      "content": "pacman -Qk $pkg コマンドを使えば、$pkg パッケージのインストールされたファイルがデータベースのバージョンに含まれているファイルと一致するかどうかを確認することができます。複数のパッケージに対しては、以下のようなループを使うことで、存在しないファイルがあるパッケージを再インストールすることができます:\n\n```\n$ LC_ALL=C.UTF-8 pacman -Qk 2>/dev/null | grep -v ' 0 missing files' | cut -d: -f1 |\n    while read -r package; do\n        pacman -S \"$package\" --noconfirm\n    done\n```\n\n(部分的なダウングレードなどにより) /var/lib/pacman のローカルデータベースが / ファイルシステムにインストールされているパッケージよりも新しい場合、これはルートファイルシステムをローカルデータベースと再同期させる最適な方法です。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- libalpm(3)\n- pacman(8)\n- pacman.conf(5)\n- repo-add(8)\n\n"
    }
  ]
}