{
  "title": "GRUB2 (Русский)",
  "url": "https://wiki.archlinux.org/title/GRUB2_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Процесс загрузки Arch\n- Главная загрузочная запись\n- Таблица разделов GUID\n- Unified Extensible Firmware Interface (Русский)\n- GRUB Legacy (Русский)\n- GRUB/EFI examples\n\nGRUB (GRand Unified Bootloader) — мультисистемный модульный программируемый кроссплатформенный загрузчик с поддержкой сети, множества файловых систем, таблиц разделов, логических томов, образов и архивов.\n\nТекущая версия GRUB — GRUB 2 — не использует код старой ветки GRUB 0.9x (GRUB Legacy) и создана на основе проекта PUPA.\n\n"
    },
    {
      "title": "Предисловие",
      "level": 2,
      "content": "Релиз GRUB-2.00 уже вышел, но разработка продолжается. В репозиториях Arch Linux появляюся самые свежие, в том числе и бета-версии GRUB, поэтому переустанавливать загрузчик (командой grub-install) и особенно обновлять файл конфигурации (командой grub-mkconfig) следует с осторожностью.\n\nЕсли вы хотите стабильности - не переустанавливайте без необходимости загрузчик и не запускайте генератор конфига. Пакет grub сам по себе содержит лишь утилиты и файлы, необходимые для установки и настройки загрузчика, и обновления пакета не затрагивают загрузчик. Однако, существует некоторый риск в отношении файла grub.cfg, см. Защита конфигурации.\n\nЕсли вы не хотите использовать GRUB2, можно установить GRUB Legacy из AUR.\n\n"
    },
    {
      "title": "Замечание для текущих и бывших пользователей GRUB Legacy",
      "level": 3,
      "content": "- Для пользователей, непривычных к шелл-коду, в GRUB2 существует утилита grub-mkconfig уровня ОС, для автоматического создания файла конфигурации загрузчика с типовым меню.\n- Однако и без автоматического конфигуратора настройка GRUB2 не сложнее, чем GRUB Legacy.\n\n- Обозначения устройств в GRUB2 отличаются от таковых в GRUB Legacy. Разделы теперь нумеруются с 1 (как в Linux), а диски по-прежнему с 0. Например, первый раздел первого диска в GRUB2 обозначается как hd0,1.\n\n- Существуют различия между командами GRUB Legacy и GRUB2. Подробнее о командах можно прочесть в этой статье и в официальном руководстве по GRUB2.\n\n- GRUB2 теперь модульный, и не имеет постоянных образов stage1_5 и stage2. Роль stage1_5 в GRUB2 играет образ core.img/core.efi, при каждой установке загручика собираемый из ядра GRUB2 и модулей, необходимых для доступа к файловой системе. Остальные модули загружаются из ФС по мере надобности, расширяя функциональность загрузчика.\n\n"
    },
    {
      "title": "Загрузчик в BIOS",
      "level": 3,
      "content": "Сама по себе BIOS, как правило, не требует наличия на диске каких-либо таблиц разделов.\n\nУчастие BIOS в процессе загрузки сводится к считыванию с диска его начального сектора размером в 512 байт, проверке наличия в конце сектора сигнатуры 55AA, и запуску содержимого как исполняемого кода. Так как в 512 байт невозможно уместить сколь-нибудь сложную программу, единственное, что может сделать код начального сектора – загружать с диска другие сектора, на чтение файлов он не способен.\n\nПоэтому, для успешной загрузки в режиме BIOS, используемый способ разметки диска должен предусматривать: 1) встраивание кода загрузчика в начальный сектор; 2) выделение на диске специальной, не занятой файловыми системами области (группы секторов), из которой будет загружаться стартовый образ загрузчика, умеющий читать хотя бы одну файловую систему.\n\nПрограмма установки GRUB2 умеет встраивать код BIOS-версии загрузчика на диски с таблицами разделов MBR и GPT, которые удовлетворяют обоим требованиям.\n\nВ обоих случаях, для встраивания используются два образа:\n\n- boot.img, код которого встраивается в начальный сектор диска,\n- core.img, собираемый программой установки из ядра GRUB и модулей доступа к используемой на диске таблице разделов и файловой системе.\n\n"
    },
    {
      "title": "Требования GRUB2-BIOS к MBR",
      "level": 4,
      "content": "Сама по себе таблица разделов на диске с разметкой MBR занимает 68 байт в конце начального сектора диска, последние два байта занимает \"загрузочная\" сигнатура 55AA. Оставшиеся 442 байта с начала сектора – и есть то место, в которое встраивается код загрузчика из образа boot.img.\n\nДля встраивания образа загрузчика core.img на диск с MBR, используется промежуток между начальным сектором с MBR и самым первым (по расположению) разделом. Если ближайший к началу диска раздел начинается с сектора 63 или больше,\n\n```\n# fdisk -l /dev/sda\n...\nDevice    Boot     Start       End    Blocks  Id System\n/dev/sda1             63   2120579   1060258+ 82 Linux swap / Solaris\n...\n```\n\nто в большинстве случаев этого места (31КБ) вполне достаточно для встраивания GRUB2. Размер образа core.img зависит от размера модулей для чтения используемых таблицы разделов и ФС. В частности, для комбинации MBR+ext4 он составляет всего 25КБ.\n\nОднако, в некоторых более сложных случаях, размер образа может оказаться больше 31КБ, и тогда отступа в 63 сектора уже не хватит. Поэтому современные версии fdisk по-умолчанию предлагают создавать первый раздел с гораздо большим отступом (1МБ), начиная с 2048 сектора.\n\n"
    },
    {
      "title": "Требования GRUB2-BIOS к GPT",
      "level": 4,
      "content": "Начальный сектор диска с разметкой GPT зарезервирован, как ни странно, для MBR, которая обычно используется для совместимости, но точно так же оставляет в секторе те же 442 байта, достаточные для встраивания кода загрузчика из boot.img. Сама GPT располагается на следующих секторах.\n\nВ отличии от MBR, GPT предусматривает возможность создания на диске специального раздела для встраивания BIOS-загрузчика. Раздел BIOS boot partition имеет GUID=21686148-6449-6e6f-744e656564454649, и может быть создан в fdisk как раздел типа 4, или в gdisk как раздел типа EF02. Этот раздел не должен содержать никакой файловой системы, иначе она будет затёрта при установке загрузчика. Номер раздела может быть любым, расположение также практически любым. На больших дисках рекомендуется располагать BIOS boot partition в пределах первых 2ТБ, поскольку средства BIOS, скорей всего, не позволят прочесть более дальние сектора.\n\nЕсли такой раздел на диске с GPT создан, программа установки GRUB2 автоматически найдёт его и использует для встраивания стартового образа BIOS-версии загрузчика. Минимальные требования к размеру раздела те же, что и для просвета перед первым разделом в случае MBR – на это место должен поместиться образ core.img. Так как расположение BIOS boot partition не привязано к началу диска, создать его с размером порядка 1МБ будет несложно, и более чем достаточно в любом случае.\n\n"
    },
    {
      "title": "Загрузчик в UEFI",
      "level": 3,
      "content": "В отличии от BIOS, UEFI загружает образ загрузчика из файла, и поэтому предъявляет определённые требования к таблице разделов, разделу, файловой системе, и к содержимому загружаемого файла.\n\n- В GPT он должен иметь тип EF00 (GUID=C12A7328-F81F-11D2-BA4B-00A0C93EC93B), и может располагаться в любом месте диска под любым номером.\n- К загрузочному разделу в MBR требования более жесткие: он должен одновременно иметь тип EF, флаг \"bootable\", и быть первым.\n\n- видимый в пользовательском интерфейсе UEFI заголовок,\n- тип таблицы разделов,\n- ID таблицы разделов,\n- расположение и размер загрузочного раздела,\n- путь к исполняемому файлу EFI-приложения.\n\n"
    },
    {
      "title": "Выбор раздела",
      "level": 3,
      "content": "Проще всего установить GRUB2 в корневой раздел. По-умолчанию для этого используется каталог с загрузочными образами ядра /boot, но можно установить каталог grub/ в корень /, или в другое место в пределах раздела. GRUB2 обладает средствами для чтения нескольких типов таблиц разделов, логических томов, образов дисков, множества файловых систем и архивов. В большинстве случаев он может читать свои файлы и загружать ОС практически с любого раздела и диска.\n\n- Только в тех случаях, когда Arch Linux установлен на диск, недоступный для чтения средствами BIOS или UEFI, которыми пользуется загрузчик, либо если для корневого раздела использована слишком новая, экзотическая, или зашифрованная файловая система, не читаемая GRUB2, может потребоваться вынос каталога /boot на отдельный диск либо раздел, и установка загрузчика на него.\n- Если загрузчик в состоянии прочесть корневой раздел, создание отдельного раздела для /boot не нужно и не рекомендуется.\n\nЕсли на компьютере установлено несколько операционных систем или диструбутивов, может оказаться удобным сделать один системонезависимый загрузчик, и установить его на отдельный диск или раздел. В этом случае стоит учесть следующее:\n\n- Не требуется монтировать этот раздел в /boot или переносить в него образы ядра – GRUB2 и так может загрузить их практически из любого раздела.\n- Не следует переустанавливать загрузчик без особой необходимости – от него зависит загрузка всех ОС на машине.\n- Не рекомендуется использовать для общесистемного загрузчика генератор конфигурации – даже если забыть о его \"сырости\" и ненадёжности, скорей всего, конфигуратор будет работать только в одной системе, а в остальных всё равно придётся редактировать конфиг загрузчика. Вносить правки гораздо легче в простой и понятный конфиг, чем в громоздкий продукт деятельности конфгуратора.\n\n"
    },
    {
      "title": "Выбор таблицы разделов",
      "level": 3,
      "content": "- Если на диске уже есть таблица разделов, и её возможностей для ваших целей достаточно, то нет никакого смысла её менять.\n\n- Если вы устанавливаете систему на чистый диск, и выбираете таблицу разделов, то с точки зрения установки GRUB2 предпочтительнее GPT, которая позволяет выделить для встраивания загрузчика раздел в любом месте диска. Это общая рекомендация, она действительна как для BIOS, так и для UEFI.\n\n- Если на этот диск планируется установка ОС, не поддерживающих GPT, но поддерживающих MBR, вам придётся выбрать MBR, или в крайнем случае, гибридную разметку диска MBR+GPT.\n\nNote: **не поддерживает** \n\n- Если на диске уже имеется MBR, но в ней недостаточно места перед первым разделом для встраивания GRUB2, и освобождение этого места проблематично, одним из выходов может стать преобразование MBR в GPT, например, с помощью программы gdisk. После этого на диске можно в любом доступном месте создать BIOS boot partition, и использовать её для встраивания загрузчика.\n\n- Если UEFI вашей машины поддерживает загрузку только с GPT, выбор очевиден.\n\n- Если вы устанавливаете Arch Linux на переносной носитель (флешку или USB-диск), то для универсальности вы можете использовать на ней GPT, и установить в неё сразу две сборки GRUB2 – i386-pc и x86_64-efi. В этом случае на носителе понадобится создать два загрузочных раздела – EFISYS для UEFI, и BIOS boot partition для BIOS. Файлы со сборками для каждой из архитектур установятся в отдельные каталоги внутри grub/, и не помешают друг другу. Файл конфигурации тоже можно использовать общий, но тогда для некоторых специфических настроек и действий понадобятся дополнительные проверки, описанные ниже.\n\n- Если требуется сохранить возможность использования переносного носителя в Windows, включая XP, после создания на нём GPT и установки UEFI-загрузчика, можно использовать для этого гибридную разметку GPT+MBR, с описанием в последней только FAT-раздела с данными, и обязательно под номером 1. Остальное место на носителе в MBR должно быть покрыто \"защитными\" разделами с кодом 0xEE. Сделать всё это можно программой gdisk. GRUB2 в этом случае будет устанавливаться всегда только на GPT.\n\n"
    },
    {
      "title": "Установка GRUB2 в процессе установки Arch Linux",
      "level": 3,
      "content": "Чтобы установить GRUB2 в процессе установки, предварительно требуется смонтировать корневой раздел устанавливаемого Arch, (а в него boot-раздел, если требуется), и выполнить команду arch-chroot.\n\n"
    },
    {
      "title": "Установка пакета",
      "level": 3,
      "content": "Файлы и утилиты для установки GRUB2 содержатся в пакете grub, и устанавливаются командой\n\n```\npacman -S grub\n```\n\n"
    },
    {
      "title": "Установка BIOS-версии загрузчика",
      "level": 4,
      "content": "- Для установки GRUB2 нужно выполнить команду от root:\n\n```\ngrub-install /dev/sda\n```\n\nгде /dev/sda это устройство (не раздел!) для установки загрузочных образов GRUB. Файлы загрузчика будут установлены в каталог /boot. Код GRUB (boot.img) будет встроен в начальный сектор, а загрузочный образ core.img – в просвет перед первым разделом MBR, или BIOS boot partition для GPT.\n\n- Если при выполнении команды происходит ошибка, попробуйте добавить --recheck в аргументы как показано ниже:\n\n```\ngrub-install --recheck /dev/sda\n```\n\n- Если требуется установить файлы загрузчика в другой каталог, его можно указать в опции --boot-directory . С этой опцией можно легко установить GRUB2 на диск с другой системой (устанавливаемой или исправляемой) без чрута, достаточно правильно указать текущий путь к смонтированному каталогу для установки и текущее имя устройства, примерно так:\n\n```\ngrub-install --boot-directory=/mnt/boot /dev/sdb\n```\n\n- Если нужно установить BIOS-версию загрузчика из-под системы, загруженной в режиме UEFI, требуется принудительно задать программе установки нужную сборку GRUB:\n\n```\ngrub-install --target=i386-pc /dev/sda\n```\n\nНовые версии GRUB2 генерируют загрузочный образ core.img, который может быть загружен не только кодом бут-сектора, но и другими загрузчиками (GRUB2, GRUB Legacy, syslinux), в качестве ядра, совместимого со стандартом Multiboot. Например, другой экземпляр GRUB2 может запустить его командой multiboot, а GRUB Legacy командой kernel.\n\nЧтобы заставить программу установки GRUB2 сгенерировать готовый образ grub/i386-pc/core.img, но не устанавливать его в таблицу разделов, можно применить вот такой хак:\n\n```\ngrub-install --grub-setup=/bin/true /dev/sda\n```\n\nОбычно программа установки вызывает сначала grub-mkimage (передавая ему множество параметров, что неудобно делать вручную), чтобы сгенерировать образ, а потом запускает grub-bios-setup, чтобы установить boot.img и core.img в таблицу разделов. С помощью ключа --grub-setup можно подсунуть программе установки вместо grub-bios-setup заглушку (команду true), которая всегда возвращает код успешного завершения.\n\n"
    },
    {
      "title": "Установка UEFI-версии загрузчика",
      "level": 4,
      "content": "Если Arch x86_64 уже загружен в режиме UEFI, системный загрузочный раздел EFI уже создан и смонтирован в /boot/efi, а efibootmgr уже установлен и работает, для установки загрузчика остаётся выполнить команду\n\n```\ngrub-install\n```\n\nПрограмма установки сгенерирует стартовый образ GRUB2, оформленный в виде EFI-приложения, скопирует его в файл /boot/efi/EFI/arch/grubx64.efi, файлы загрузчика будут записаны в каталог /boot/grub/, в том числе модули в /boot/grub/x86_64-efi/, после чего будет сделана попытка с помощью efibootmgr создать в переменных UEFI загрузочную запись \"arch\" со ссылкой на файл \\EFI\\arch\\grubx64.efi, которую можно будет выбрать при следующей загрузке и установить её по-умолчанию.\n\n- Опция --boot-directory задаёт путь, по которому будет установлен каталог grub/, и где grub-install будет искать каталог efi/ с загрузочным разделом EFI. По-умолчанию этот путь равен /boot. Если вы хотите установить каталог с файлами загрузчика в другое место, например в корень, используйте команду вида\n\n```\ngrub-install --boot-directory=/\n```\n\n- Опция --efi-directory принудительно задаёт каталог, в который смонтирован загрузочный раздел EFI. С её помощью можно указать точку монтирования этого раздела, не привязанную жестко к расположению каталога grub/.\n\n- Опция --bootloader-id задаёт \"ID загрузчика\" – имя, под которым будет создаваться загрузочная запись GRUB, видимая при выборе варианта загрузки в интерфейсе UEFI. Под этим же именем в загрузочном разделе будет создан каталог с образом GRUB2. По-умолчанию это имя arch .\n\nИспользуя эти опции вместе, при желании можно установить файлы загрузчика непосредственно в загрузочный раздел EFI, например так:\n\n```\ngrub-install --efi-directory=/boot/efi --boot-directory=/boot/efi/EFI --bootloader-id=grub\n```\n\nВ этом примере загрузочный раздел EFI с каталогом EFI/ заранее смонтирован в /boot/efi, а ID загрузчика полностью совпадает с именем каталога \"grub\". Поэтому и образ, и файлы загрузчика будут установлены в один и тот же каталог EFI/grub/ на загрузочном разделе. Соответственно, в этом случае стартовый образ будет установлен в /boot/efi/EFI/grub/grubx64.efi, конфиг загрузчика должен быть в /boot/efi/EFI/grub/grub.cfg, а модули в каталоге /boot/efi/EFI/grub/x86_64-efi/.\n\n- Если нужно установить EFI-версию GRUB2, действуя из системы, загруженной в режиме BIOS, либо в режиме UEFI для другой архитектуры, либо на сменный носитель (флешку или переносной диск), требуется принудительно задать программе установки нужную сборку загрузчика с помощью опции --target .\n- Кроме того, в этом случае не будет работать efibootmgr, и создать загрузочную запись со ссылкой на стартовый образ загрузчика из этой системы не удастся. В такой ситуации можно использовать дефолтный загрузочный путь \\EFI\\BOOT\\BOOTX64.EFI, по которому UEFI самостоятельно найдёт стартовый образ, с помощью опции --removable :\n\n```\ngrub-install --target=x86_64-efi --removable\n```\n\n- Аналогично можно установить GRUB2 на флешку для загрузки в режиме UEFI:\n\n```\ngrub-install --boot-directory=/mnt/sdb2/boot --efi-directory=/mnt/sdb1 --target=x86_64-efi --removable\n```\n\n- Если вы не хотите или не можете использовать для GRUB дефолтный путь на загрузочном разделе, можно использовать опцию --no-nvram , чтобы программа установки поместила загрузочный образ в отдельный (не дефолтный) каталог, но не пыталась вызывать efibootmgr:\n\n```\ngrub-install --target=x86_64-efi --no-nvram\n```\n\nЕсли на машине есть UEFI, но установленный Arch Linux имеет архитектуру i686, установить UEFI-версию GRUB можно, но есть дополнительное затруднение – сборка загрузчика x86_64-efi отсутствует в пакете \"grub\" для архитектуры i686. В пакете же для архитектуры x86_64 присутствуют все три сборки:\n\n- i386-pc для BIOS,\n- i386-efi для 32-битных прошивок UEFI (встречается редко, в основном это старые машины фирмы Apple, некоторые HDMI-стики),\n- x86_64-efi для 64-битных UEFI.\n\nПеред тем, как устанавливать UEFI-версию GRUB из системы i686, придётся сначала скачать пакет grub для x86_64, и распаковать из него (под рутом) недостающую сборку загрузчика:\n\n```\ntar xvf /путь/grub-версия-x86_64.pkg.tar.xz -C / usr/lib/grub/x86_64-efi\n```\n\nПосле этого можно устанавливать загрузчик, как описано в предыдущей главе \"Без доступа к UEFI\".\n\n"
    },
    {
      "title": "Установка в LVM",
      "level": 4,
      "content": "Установка GRUB2 на диск с LVM происходит в целом так же, как и на диск без LVM.\n\nGRUB2 читает файловые системы из логических томов LVM, как и из обычных разделов, поэтому никакого отдельного раздела /boot вне LVM для файлов GRUB2 и загружаемых им образов ядра не требуется. Однако, для встраивания стартовых образов GRUB2 по-прежнему нужна таблица разделов.\n\nДля загрузки в режиме BIOS, в MBR никаких дополнительных разделов создавать не нужно, достаточно единственного раздела на весь диск, полностью отданного под LVM, и оставленного свободного места перед разделом для встраивания загрузчика.\n\nДля загрузки в режиме UEFI, или загрузки с GPT в любом режиме, требуется как минимум один загрузочный раздел вне LVM для стартового образа GRUB2, но не для файлов загрузчика, и не для образов ядра (не /boot ).\n\nПодробнее см. Требования к диску.\n\n"
    },
    {
      "title": "Установка на образ диска",
      "level": 4,
      "content": "В некоторых случаях может понадобиться установить GRUB2 на образ диска, например, для загрузки в виртуальной машине. К сожалению, в нынешних версиях (на конец 2015г) программа установки загрузчика grub-install по-умолчанию считает loop-устройство, через которое подключается образ, не имеющим разделов, а потому не ищет на нём таблицу разделов, и не включает в начальную загрузку модуль чтения таблицы разделов.\n\nВозможно, в будущем это будет исправлено, а пока для обхода проблемы требуется явно потребовать добавить соответствующий модуль: опцией --modules=part_msdos для MBR, или --modules=part_gpt для GPT.\n\nПример установки GRUB2 на образ диска с MBR, и размещением файлов загрузчика в каталоге /grub на первом разделе:\n\n```\n[root@host ~]# losetup --show -P -f /home/user/VM/disk.img\n/dev/loop0\n[root@host ~]# ls -1 /dev/loop0*\n/dev/loop0\n/dev/loop0p1\n/dev/loop0p2\n[root@host ~]# mkdir -p /mnt/part1\n[root@host ~]# mount /dev/loop0p1 /mnt/part1\n[root@host ~]# grub-install --modules=part_msdos --boot-directory=/mnt/part1 /dev/loop0\n```\n\n"
    },
    {
      "title": "Переустановка загрузчика",
      "level": 3,
      "content": "Переустановка пакета не переустанавливает загрузчик.\n\nПереустановка GRUB2 выполняется командой grub-install, и ничем не отличается от установки.\n\nПереустановка GRUB2 может потребоваться в следующих случаях:\n\n- Если установка другой ОС или другого дистрибутива затёрла стартовый код GRUB2.\n- После преобразования таблицы разделов.\n- После изменения нумерации раздела, на котором установлены файлы загрузчика.\n- После переноса загрузчика на другой раздел или в другую файловую систему.\n- Если вас не устраивает текущая версия загрузчика, и вы хотите её обновить.\n\nПереустановка GRUB2 не требуется:\n\n- При изменении файла конфигурации загрузчика.\n- При обновлении ядра, установке другого ядра, или пересборке initramfs.\n- При смене архитектуры установленного Arch с i686 на x86_64 без смены раздела и без форматирования корневой ФС.\n- При обновлении пакета \"grub\".\n\n"
    },
    {
      "title": "Перенос загрузчика",
      "level": 3,
      "content": "Загрузчик GRUB состоит из двух частей: (внефайлового) загрузочного кода в таблице разделов и файлов в каталоге /grub (/boot/grub).\n\nВне зависимости от того, какие из этих частей переносятся, при переносе обязательно нужно переустановить загрузчик с помощью grub-install .\n\nЕсли загрузчик переносится на другой диск, также может потребоваться изменение настроек BIOS/UEFI, чтобы загрузка начиналась с этого диска.\n\nЗагрузчик GRUB не читает fstab и игнорирует флаг bootable в MBR, поэтому любые манипуляции с ними не имеют никакого отношения к установке, переустановке или переносу GRUB.\n\n"
    },
    {
      "title": "После установки",
      "level": 3,
      "content": "В настоящее время GRUB2, сразу после установки, готов к работе только в режиме консоли. (Это будет продолжаться до тех пор, пока мейнтейнеры пакета \"grub\" не заменят бессмысленный дефолтный файл конфигурации загрузчика на рабочую статическую или автоматически генерируемую версию.)\n\nЧтобы получить при загрузке действующее меню GRUB2, требуется заменить файл grub.cfg самостоятельно. Речь об этом идёт в следующей части \"Настройка\".\n\n"
    },
    {
      "title": "Главный файл конфигурации загрузчика",
      "level": 3,
      "content": "Главный файл конфигурации по-умолчанию находится в /boot/grub/grub.cfg.\n\n- Если вы пользуетесь автоматическим генератором конфигурации grub-mkconfig, не редактируйте главный файл конфигурации вручную – сгенерированный код пригоден для загрузки, но громоздок и неудобен для редактирования, а все изменения будут стёрты при запуске конфигуратора.\n- Соответственно, если вы собираетесь редактировать конфиг загрузчика сами – создайте его либо полностью заново, либо на основе примеров, и не пытайтесь запустить grub-mkconfig или использовать сгенерированный им код.\n\n"
    },
    {
      "title": "Генерация конфига",
      "level": 4,
      "content": "Команда grub-mkconfig может быть использована для генерации файла grub.cfg.\n\nДля автоматического обнаружения ОС отличных от Linux установите пакет os-prober. Если после установки пакета os-prober автоматическое обнаружение не работает должным образом, то может потребоваться установка пакета hwinfo.\n\nДля отключения автоматического обнаружения других операционных систем следует добавить в файл /etc/default/grub строку GRUB_DISABLE_OS_PROBER=\"true\".\n\nДля настройки конфигуратора используйте файл /etc/default/grub и файлы в каталоге /etc/grub.d/.\n\nЕсли Вы хотите добавить свои пункты в меню GRUB, настроить их можно в файле /etc/grub.d/40_custom, либо в /boot/grub/custom.cfg.\n\nЧтобы применить изменения, запустите команду:\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\nОна не только создаст файл /boot/grub/grub.cfg, но и проверит конфигурацию на наличие ошибок.\n\nNote: **не** \n\n"
    },
    {
      "title": "Параметры конфигуратора",
      "level": 4,
      "content": "Дефолтный файл /etc/default/grub содержит параметры конфигуратора с настройками по-умолчанию, снабженные комментариями на английском языке. Ниже перечислены некоторые наиболее общие из них:\n\n- GRUB_DEFAULT Номер или заголовок пункта меню, выбранного по-умолчанию\n- GRUB_TIMEOUT Время, после которого будет автоматически загружаться пункт по-умолчанию\n- GRUB_CMDLINE_LINUX Параметры ядра Linux, добавляемые во все пункты меню.\n- GRUB_CMDLINE_LINUX_DEFAULT Параметры ядра Linux, добавляемые только в пункты меню, сгенерированные без \"recovery\". В Arch Linux настройки автоконфигуратора по-умолчанию содержат GRUB_DISABLE_RECOVERY=true, поэтому фактически в каждый пункт меню добавляются параметры из обех упомянутых строк.\n\nДругие параметры конфигуратора вы можете найти ниже, в соответсвующих тематических главах.\n\n"
    },
    {
      "title": "Прямая конфигурация",
      "level": 3,
      "content": "GRUB2 – программируемый загрузчик, и файл его конфигурации – это не файл настроек, а программа, выполняемая загрузчиком, скрипт. Как всякий скрипт, он может быть как очень простым, не сложнее menu.lst в GRUB Legacy, так и очень сложным, поскольку сложность скриптов практически ничем не ограничена.\n\nКод скрипта конфигурации, генерируемый grub-mkconfig, обычно пригоден для загрузки в типовых случаях, но слишком громоздок, избыточен, непригоден для изучения, ограничен в возможностях, и создаёт ложное впечатление о \"сложном конфиге GRUB2\".\n\nЕщё одно распространённое заблуждение происходит от надписи \"DO NOT EDIT ...\" в начале кода, генерируемого конфигуратором. Надпись правильная, но её смысл состоит лишь в том, что именно этот, автоматически сгенерированный код, действительно нет смысла редактировать. Надпись стандартна для автоматических конфигураторов, и относится не к grub.cfg вообще, а только к продукту деятельности конфигуратора, безотносительно имени файла, в который его сохранили.\n\nПри запуске автоматического конфигуратора, выполняется набор скриптов, работающих на уровне ОС, которые генерируют скрипт конфигурации загрузчика. Уже этот, сгенерированный скрипт, выполняется на уровне загрузчика, и в свою очередь, генерирует меню GRUB. Такая схема предполагает некоторое упрощение типовой настройки GRUB, но ценой загромождения кода, снижения надёжности и гибкости.\n\nПрямое написание скрипта даёт непосредственный доступ ко всем возможностям GRUB2, значительно большую гибкость, надёжность и стабильность, просто за счёт упрощения кода и устранения лишних звеньев в цепочке.\n\nЯзык конфигурации GRUB2 – сильно упрощённый UNIX-шелл, из которого убраны возможности перенаправления ввода-вывода, и добавлены команды, специфичные для загрузчика.\n\nАвтоматический генератор конфигурации изначально создавался для дистрибутивов Debian и Ubuntu, в которых используются версионные имена образов ядра, что заставило разработчиков этих дистрибутовов создавать автоматические генераторы конфигов вообще для всех используемых там загрузчиков.\n\nВ Arch Linux не используется версионное обновление ядер – имена образов ядра и initramfs для каждого пакета с ядром не меняются при обновлении, и файл конфигурации загрузчика не обновляется при обновлении ядра.\n\nБолее того, возможности скриптов GRUB2 позволяют средствами самого загрузчика, прямо перед загрузкой ОС, генерировать меню с переменным количеством строк, для поиска и загрузки всех установленных ядер Arch Linux, без изменения каких-либо файлов конфигурации. То же самое возможно и для версионных ядер Debian и Ubuntu.\n\nПримеры кода конфигурации даны ниже, подробный справочник имеется на сайте GRUB.\n\nПрежде чем приступать к написанию конфига, крайне желательно защитить его от возможной перезаписи при обновлении/переустановке пакета grub.\n\n"
    },
    {
      "title": "Защита конфигурации",
      "level": 3,
      "content": "К сожалению, мейнтейнеры пакета grub отказываются убирать из него бессмысленный, по определению неработающий и никому не нужный \"дефолтный\" вариант файла grub.cfg, создающий небольшую, но постоянную угрозу перезаписи настоящего рабочего конфига GRUB, особенно в случае ошибок со стороны мейнтейнеров. Эта опасность не зависит от используемого метода конфигурации GRUB – и ручной, и автогенерированный конфиг может быть однажды случайно перезаписан или переименован при очередном обновлении пакета, и выяснится это с большой вероятностью только после перезагрузки.\n\n"
    },
    {
      "title": "Вынос конфигурации в другой файл",
      "level": 4,
      "content": "Так как GRUB поддерживает модульность конфигурации, можно оставить в файле grub.cfg только одну строку со ссылкой на другой файл, например menu.cfg\n\n```\n/boot/grub/grub.cfg\n```\n\n```\n. $prefix/menu.cfg\n```\n\nи в дальнейшем вместо grub.cfg править только menu.cfg\n\nДля автоконфигурации в этом случае можно использовать команду\n\n```\ngrub-mkconfig -o /boot/grub/menu.cfg\n```\n\n"
    },
    {
      "title": "Прямая блокировка grub.cfg",
      "level": 4,
      "content": "Чтобы защитить файл от любых изменений, присвойте ему атрибут immutable\n\n```\nchattr +i /boot/grub/grub.cfg\n```\n\nБлокировка снимается командой\n\n```\nchattr -i /boot/grub/grub.cfg\n```\n\nЕсли основная конфигурация уже вынесена в другой файл, блокировку grub.cfg достаточно установить однажды и больше не снимать.\n\nБлокировка защитит файл от перезаписи скриптами установки пакетов. Чтобы избежать конфликта с файлом из пакета, добавьте его имя в строку NoUpgrade в /etc/pacman.conf:\n\n```\n/etc/pacman.conf\n```\n\n```\nNoUpgrade = boot/grub/grub.cfg\n```\n\n"
    },
    {
      "title": "Перенос каталога grub",
      "level": 4,
      "content": "Если каталог grub/ со всеми файлами загрузчика расположен в корневом разделе, для защиты конфигурации можно переместить его из /boot в другое место в пределах раздела, проще всего прямо в корень :\n\n```\nmv /boot/grub /\ngrub-install --boot-directory=/ /dev/sda\n```\n\nВместо /dev/sda используйте текущее имя диска для установки (при установке для UEFI указывать его не нужно). Все файлы загрузчика после этого будут находиться в каталоге /grub , в том числе файл конфигурации /grub/grub.cfg . Образы ядра и initramfs останутся по-прежнему в /boot , и будут загружаться как обычно, правки путей не потребуется.\n\nВ модульных и многофайловых (шрифты, темы) конфигурациях вместо /boot/grub можно использовать в путях к файлам переменную $prefix, в этом случае конфиги будут работать правильно вне зависимости от текущего расположения файлов загрузчика.\n\nЕсли вы используете автоконфигуратор, не забудьте после переноса заменить возможные упоминания /boot/grub на /grub в файлах /etc/default/grub и /etc/grub.d/*\n\nДля генерации конфига после переноса можно пользоваться командой\n\n```\ngrub-mkconfig -o /grub/grub.cfg\n```\n\n"
    },
    {
      "title": "Пример минимальной работающей конфигурации",
      "level": 4,
      "content": "Здесь только один пункт меню, загрузчик в корневом разделе, который передаётся ядру меткой Arch_root\n\n```\n/boot/grub/grub.cfg\n```\n\n```\nset timeout=5\nmenuentry \"Arch Linux\" {\n linux /boot/vmlinuz-linux root=LABEL=Arch_root rw\n initrd /boot/initramfs-linux.img\n}\n```\n\n"
    },
    {
      "title": "Основные команды и переменные",
      "level": 4,
      "content": "Файл конфигурации состоит из команд, выполняемых по порядку, как в обычном шелл-скрипте.\n\n- Строки или продолжения строк, начинающиеся с символа # , считаются комментариями.\n\n- В GRUB2 используются обозначения дисков вида hdX и разделов вида hdX,Y , где X номер диска, Y номер раздела на нём. Нумерация разделов начинается с единицы (как в ядре Linux), нумерация дисков – с нуля. Если обозначение диска или раздела используется само по себе, например в переменной root, оно пишется без скобок.\n- Пути к файлам могут начинаться с обозначения диска или раздела в скобках, например (hd0,1)/boot/vmlinuz соответствует файлу vmlinuz в каталоге /boot на разделе /dev/sda1\n\n- Если в пути к файлу не указан диск или раздел, подразумевается текущий диск или раздел из переменной root . При запуске GRUB2 эта переменная уже указывает на раздел, где хранятся все файлы загрузчика, и как правило, образы ядра и initramfs. Задавать переменную root в конфиге имеет смысл ТОЛЬКО для загрузки с ДРУГОГО раздела. Пример:\n\n```\nset root=hd0,1 # задаём раздел с другой ОС или другим загрузчиком\nchainloader +1 # загружаем его бут-сектор\n```\n\n- Кроме файлов, GRUB2 позволяет обращаться напрямую к цепочкам секторов на диске или разделе, в формате X+Y , где X номер начального сектора цепочки, а Y количество секторов. Если цепочка начинается с первого (номер 0) сектора, её обозначение сокращается до +Y. Наиболее употребительная цепочка в конфигах GRUB – бут-сектор раздела или диска, обозначается как +1\n\n- В обозначении раздела перед его номером может стоять слово, обозначающее его принадлежность к таблице разделов определённого типа, например hd0,msdos3 означает третий раздел в MBR на нулевом диске, а hd1,gpt2 означает второй раздел в GPT на следующем диске. GRUB2 всегда добавляет тип таблицы при выводе разделов командой ls и при записи $prefix в процессе установки, однако писать тип таблицы вручную не требуется – он определяется автоматически. Исключение может составлять только особо тяжелый случай двух разных таблиц разделов с разной нумерацией на одном диске, причём гибрид GPT+MBR таким случаем не является – GRUB2 игнорирует MBR, если на диске обнаружена GPT.\n\n- Команда menuentry генерирует один пункт меню. Она задаёт видимый заголовок и список команд, которые выполнятся после выбора этого пункта меню:\n\n```\nmenuentry \"Заголовок\" {\n# команды\n}\n```\n\n- Переменная default задаёт номер или заголовок пункта меню, выбранного по-умолчанию. Например, set default=1 выбирает второй пункт. Пункты меню нумеруются с нуля.\n\n- Переменная timeout определяет время в секундах, по истечении которого будет загружен пункт меню по-умолчанию, например, set timeout=5.\n\n- Команда linux загружает образ ядра и параметры для него.\n\n- Команда initrd загружает образ начальной корневой ФС. Если образов указано несколько, они будут загружены по очереди. Например, образ для обновления микрокода процессоров Intel загружается перед основным образом:\n\n```\ninitrd /boot/intel-ucode.img /boot/initramfs-linux.img\n```\n\n- Команда chainloader предназначена для загрузки \"по цепочке\" образа другого загрузчика. В режиме BIOS это, как правило, boot-сектор или его копия в файле, в режиме UEFI это может быть любое EFI-приложение, даже не обязательно находящееся в доступном для UEFI разделе – главное, чтобы файл мог быть прочитан средствами GRUB, а переменная root при вызове команды указывала на доступный UEFI раздел.\n\n"
    },
    {
      "title": "Стандартный пример конфигурации",
      "level": 4,
      "content": "В этом примере так или иначе фигурируют три раздела:\n\n- hd0,1 – раздел Windows, указан явно в последнем пункте меню.\n\n- hd0,2 – boot-раздел , монтируется в /boot , поэтому /boot отсутствует в путях к файлам. При старте раздел уже находится в переменной root, поэтому отдельно никак не задаётся, только подразумевается.\n\n- hd0,3 – корневой раздел Arch Linux , в Linux отображается как /dev/sda3 , как и прописан в параметрах ядра.\n\n```\n/boot/grub/grub.cfg\n```\n\n```\n# по-умолчанию выбран пункт меню 0\nset default=0\n\n# при бездействии пользователя он загрузится через 5 секунд\nset timeout=5\n\n# пункт меню номер 0\nmenuentry \"Arch Linux\" {\n linux /vmlinuz-linux root=/dev/sda3 rw\n initrd /initramfs-linux.img\n}\n\n# пункт меню номер 1\nmenuentry \"Windows XP\" {\n chainloader (hd0,1)+1\n}\n```\n\n```\nmenuentry \"Arch Linux\" {\n linux /boot/vmlinuz-linux root=/dev/sda3 rw\n initrd /boot/initramfs-linux.img\n}\n```\n\n"
    },
    {
      "title": "Вторичные конфиги, вложенные меню и смена контекста",
      "level": 4,
      "content": "Как и UNUX-шелл, GRUB2 поддерживает три вида переменных: обычные, позиционные параметры и переменные окружения.\n\n- Обычные переменные доступны командам конфига, также внутри вызываемых из него функций и пунктов меню, но не наследуются при смене контекста.\n- Переменные окружения недоступны непосредственно, но наследуются и автоматически импортируются в обычные при смене контекста.\n- Позиционные параметры, они же \"параметры командной строки\". Передаются при вызове функции или пункта меню как аргументы команды, внутри функции или пункта меню обозначаются цифрами по порядку, начиная с $1\n\nОбычные переменные создаются в момент первого присвоения, командой set переменная=значение При этом само слово set можно не писать:\n\n```\nhead=\"Arch linux\"\n```\n\nNote: **set** \n\nДля уничтожения обычной переменной может быть использована команда unset\n\n```\nunset timeout\n```\n\nОбычные переменные могут быть экспортированы \"в окружение\" командой export\n\n```\nexport a b c\n```\n\nNote: **root** \n\nТак же как в шелл-скриптах, из одного конфига GRUB2 может вызван другой файл конфига.\n\n- Команда source (часто обозначается просто точкой .) выполняет другой конфиг без смены контекста, после чего продолжает выполняться текущий. Пример:\n\n```\n. $prefix/custom.cfg\n```\n\n- Команда configfile запускает новый конфиг в новом контексте:\n\n```\nconfigfile /boot/grub/new.cfg\n```\n\nNote: **prefix** \n\n- Команда submenu создаёт новый пункт меню, так же как и menuentry, и может иметь точно такой же набор параметров. Единственное отличие submenu состоит в том, что команды внутри него выполняются в новом контексте, так же как при вызове конфига через configfile. Соответственно, все новые пункты меню, создаваемые в новом контексте, добавляются в новое меню, отсюда и название команды.\n- Возврат в старое меню (и старый контекст, со старыми переменными) из вложенного, может быть выполнен нажатием клавиши ESC.\n\nNote: **submenu** \n\n"
    },
    {
      "title": "UUID",
      "level": 4,
      "content": "При загруженном Linux, узнать UUID имеющихся разделов можно с помощью команды lsblk -f\n\nПолученный UUID корневого раздела можно вручную вставить в параметры ядра, примерно так: root=UUID=355ccb5c-99e1-400d-b612-451f9247e35e, но делать это имеет смысл, только если у вас есть отдельный boot-раздел.\n\nЧаще всего и GRUB, и ядро находятся в одном том же корневом разделе, который уже и так находится в $root, остаётся получить его UUID в переменную для подстановки в параметры ядра:\n\n```\nprobe --set=UUID --fs-uuid $root\n```\n\nПример загрузки ядра с автоматической подстановкой UUID:\n\n```\nmenuentry \"Arch Linux\" {\n probe -s UUID -u $root\n linux /boot/vmlinuz-linux root=UUID=$UUID rw\n initrd /boot/initramfs-linux.img\n}\n```\n\nПараметры команды probe здесь те же самые, просто в сокращённой форме.\n\nИ только если образ ядра находится не в том разделе, что GRUB, то есть не в корневом, и не в boot-разделе, требуется отдельно указать его загрузчику. Чтобы сделать это, используйте команду search. Так мы устанавливаем корневой раздел в переменную загрузчика $root через поиск по UUID, и этот же UUID подставляем в параметры ядра, если отдельного boot-раздела нет:\n\n```\nmenuentry \"Arch Linux\" {\n UUID=355ccb5c-99e1-400d-b612-451f9247e35e\n search --fs-uuid $UUID --set root\n linux /boot/vmlinuz-linux root=UUID=$UUID rw\n initrd /boot/initramfs-linux.img\n}\n```\n\n"
    },
    {
      "title": "Метки",
      "level": 4,
      "content": "Метки - легко читаемые заголовки, присваиваемые файловым системам и не только:\n\n```\ne2label /dev/sda3 Arch_root      # ставим метку на ext2/3/4\nswaplabel -L Arch_swap /dev/sda2 # ставим метку свап-разделу\nmkswap -L Arch_swap /dev/sda2    # если свап \"старый\", пересоздаём с меткой\nntfslabel /dev/sda1 WindowsXP    # ставим метку на NTFS\nfatlabel /dev/sda5 OTHERDATA     # ставим метку на FAT\n```\n\nМетку можно подставить в параметры ядра. Пример:\n\n```\nmenuentry \"Arch Linux\" {\n linux /boot/vmlinuz-linux root=LABEL=Arch_root rw\n initrd /boot/initramfs-linux.img\n}\n```\n\nЕсли загрузчик находится в отдельном от ядра и корня разделе, корневой раздел можно указать через метку и загрузчику:\n\n```\nmenuentry \"Arch Linux\" {\n search --label Arch_root --set root\n linux /boot/vmlinuz-linux root=LABEL=Arch_root rw\n initrd /boot/initramfs-linux.img\n}\n```\n\n"
    },
    {
      "title": "LVM",
      "level": 4,
      "content": "- При использовании GRUB2 на LVM, как правило, никаких дополнительных команд в конфиге GRUB не требуется, достаточно просто передать ядру в параметре root= обозначение группы и тома LVM, принятое в Linux, то есть /dev/mapper/Group-Name:\n\n```\nmenuentry \"Arch Linux\" {\n linux /vmlinuz-linux root=/dev/mapper/Arch-Root rw\n initrd /initramfs-linux.img\n}\n```\n\nили /dev/Group/Name:\n\n```\nmenuentry \"Arch Linux\" {\n linux /vmlinuz-linux root=/dev/Arch/Root rw resume=/dev/Arch/Swap\n initrd /initramfs-linux.img\n}\n```\n\n- Только если GRUB находится на разделе, отдельном от раздела с ядрами, то есть не на корневом, и не на boot-разделе, может потребоваться указать ему нужный раздел с образами ядра и imitramfs. Группа и том LVM в формате GRUB2 задаются так:\n\n```\nset root=lvm/Group-Name\n```\n\n- И только если GRUB2 установлен не на LVM, а образы ядра он должен прочесть с тома LVM, может также потребоваться предварительно загрузить его модуль командой insmod :\n\n```\nmenuentry \"Arch Linux\" {\n insmod lvm\n set root=lvm/Arch-Root\n linux /vmlinuz-linux root=/dev/mapper/Arch-Root rw\n initrd /initramfs-linux.img\n}\n```\n\n"
    },
    {
      "title": "Загрузка других операционных систем",
      "level": 3,
      "content": "GRUB можно использовать для загрузки и других установленных на той же машине дистрибутивов и операционных систем. Для добавления каждого нового пункта загрузочного меню GRUB, в его конфиг добавляется своя секция menuentry. Примеры конфигурации дополнительных пунктов для запуска Linux и Windows приведены ниже.\n\nЕсли вы используете автоконфигурацию GRUB, но хотите, чтобы в генерируемый конфиг добавлялись ваши пункты меню, написанные вручную, отредактируйте файл /etc/grub.d/40_custom и допишите их в конец этого файла. Всё его содержимое будет добавлено в конфиг загрузчика при запуске grub-mkconfig\n\n"
    },
    {
      "title": "GNU/Linux",
      "level": 4,
      "content": "В этом примере другой дистрибутив Linux загружается с раздела sda2:\n\n```\nsubmenu \"Other Linux\" {\n set root=hd0,2\n linux /boot/vmlinuz # добавьте сюда все нужные опции ядра\n initrd /boot/initrd.img # файл initrd, если он используется\n}\n```\n\n"
    },
    {
      "title": "Windows",
      "level": 4,
      "content": "Операционные системы Windows не поддерживают протокол Multiboot, и GRUB не может загружать Windows непосредственно. Чтобы загрузить Windows, нужно запустить её собственный загрузчик, который, в свою очередь, загружает ядро Windows и набор необходимых для старта драйверов, по списку, который он читает из реестра Windows.\n\nДля BIOS и для UEFI в одной и той же версии Windows используются две различных версии загрузчика, каждая со своими особенностями. Windows, установленная в режиме BIOS, не имеет UEFI-загрузчика и не стартует в режиме UEFI, и наоборот – будучи установленной в режиме UEFI, Windows не стартует режиме BIOS.\n\nЗагрузчик Windows для режима BIOS поддерживает только одну таблицу разделов – MBR, и не поддерживает GPT, независимо от версии Windows. Кроме того, 32-битная версия Windows XP может быть запущена только в режиме BIOS.\n\nЗагрузчик Windows может быть запущен через бут-сектор раздела, на который он установлен:\n\n```\nmenuentry \"Windows\" {\n chainloader (hd0,2)+1\n}\n```\n\nлибо напрямую из его файла, специальной командой ntldr\n\n```\nsubmenu \"Windows XP\" {\n set root=hd0,2\n ntldr /ntldr\n}\n```\n\nВ Windows Vista и выше файл загрузчика называется иначе, но может быть загружен той же командой:\n\n```\nsubmenu \"Windows 7\" {\n set root=hd0,3\n ntldr /bootmgr\n}\n```\n\nЗагрузчик Windows, установленной в режиме UEFI, поддерживает только одну таблицу разделов – GPT, и не поддерживает MBR.\n\nЕсли GRUB2 установлен в режиме UEFI, его стартовый образ лежит в том же ESP/EFISYS разделе, что загрузчик Windows. Полный путь к стартовому образу GRUB2 режима UEFI указывает переменная $cmdpath с содержимым вида (диск,раздел)/EFI/каталог/grubx64.efi. Чтобы из этого пути получить диск и раздел, можно регулярным выражением обрезать скобки и путь, и записать результат в переменную $root. После этого загрузчик Windows запускается командой chainloader, как обычное EFI-приложение:\n\n```\nsubmenu \"Windows 8\" {\n regexp -s root '\\((.+)\\)' \"$cmdpath\"\n chainloader /EFI/Microsoft/Boot/bootmgfw.efi\n}\n```\n\n"
    },
    {
      "title": "Запуск FreeDOS",
      "level": 4,
      "content": "Аналогично командам linux и ntldr, в GRUB предусмотрена возможность прямой загрузки ядра FreeDOS, командой freedos, без использования оригинального загрузочного кода в MBR и бут-секторе:\n\n```\nmenuentry \"FreeDOS\" {\n freedos /KERNEL.SYS\n}\n```\n\nЭто может быть удобно, когда требуется скопировать уже установленную, к примеру, на флешку, FreeDOS, используемую для запуска MHDD и подобных инструментов. Такой способ загрузки позволяет под Linux копировать файлы и каталоги однажды установленной FreeDOS на другие носители, в том числе \"мультизагрузочные\". (Установка FreeDOS штатным способом, с записью её загрузочного кода в MBR и бут-сектор, требует каждый раз загружать саму FreeDOS, хотя бы в виртуальной машине.)\n\n"
    },
    {
      "title": "Запуск программ, работающих без ОС",
      "level": 4,
      "content": "Тест памяти memtest86+ (версия для BIOS):\n\n```\nmenuentry \"Memtest86+\" {\n linux16 /boot/memtest86+/memtest.bin\n}\n```\n\nОн же, но для UEFI (пакет memtest86+-efi):\n\n```\nmenuentry \"Memtest86+\" {\n linux /boot/memtest86+/memtest.efi\n}\n```\n\nEFI-приложения можно запускать не только из интерфейса UEFI, но и из других EFI-приложений, в том числе из UEFI-версии GRUB2, с помощью команды chainloader. На примере загрузчика Windows это уже показано выше.\n\nЧтобы запустить EFI-приложение, вовсе не обязательно класть его на раздел EFISYS, особенно если приложение большое, а на спецразделе очень мало места. Достаточно, чтобы файл приложения читался средствами GRUB, а переменная root указывала на EFISYS. В этом примере UEFI Shell запускается прямо из /boot:\n\n```\nsubmenu \"UEFI Shell\" {\n archroot=$root\n regexp -s root '\\((.+)\\)' \"$cmdpath\"\n chainloader ($archroot)/boot/Shell.efi\n}\n```\n\nПри выходе из UEFI Shell вы снова увидите меню GRUB.\n\n"
    },
    {
      "title": "Debian, Ubuntu и другие дистрибутивы с версионным обновлением ядра",
      "level": 4,
      "content": "В дистрибутивах с версионными ядрами, при каждом обновлении ядра автоматически вызывается генератор конфигурации загрузчика, поскольку имена загрузочных образов vmlinuz и initrd меняются при каждом обновлении. Это обстоятельство вынудило разработчиков Debian и Ubuntu сделать автоконфигуратор даже для первой версии GRUB, в которой обычно использовались только статические конфиги.\n\nЕсли другой дистрибутив установлен на отдельный диск (в режиме BIOS), и имеет собственную установку GRUB2, для его загрузки достаточно запустить другой загрузчик:\n\n```\nmenuentry \"Ubuntu\" {\n chainloader (hd1)+1\n}\n```\n\nВ режиме UEFI несколько загрузчиков могут быть установлены и на один диск, и запускаться один из другого как EFI-приложения:\n\n```\nsubmenu \"Ubuntu\" {\n regexp -s root '\\((.+)\\)' \"$cmdpath\"\n chainloader /EFI/ubuntu/grubx64.efi\n}\n```\n\nВ некоторых случаях (не всегда) другую установку GRUB2 можно запустить в режиме BIOS с помощью команды multiboot, минуя встраивание образа в таблицу разделов:\n\n```\nsunmenu \"Other Linux\" {\n set root=hd0,6\n multiboot /boot/grub/i386-pc/core.img\n}\n```\n\nК сожалению, часто встречается ситуация, когда другой дистрибутив установлен в режиме BIOS на тот же самый диск, в таблицу разделов которого можно установить только один загрузчик, и запустить второй проблематично. В этом случае остаётся либо использовать GRUB из состава того дистрибутива, либо учить штатный загрузчик Arch Linux работать с версионными ядрами.\n\nСамый простой способ это сделать – подсунуть \"своему\" GRUB конфиг от чужого, в котором всё уже предусмотрено, не забыв перед этим сбросить некоторые переменные, которые могут вызвать проблемы:\n\n```\nsubmenu \"Ubuntu\" {\n unset lang\n unset gfxmode\n set root=hd0,2\n configfile /boot/grub/grub.cfg\n}\n```\n\nОднако, есть возможность обойтись без чужих конфигов и загрузчиков, если использовать динамическую генерацию меню загрузчиком. В конфиг GRUB2 включается скрипт, генерирующий меню для Ubuntu:\n\n```\n. $prefix/ubuntu.cfg\n```\n\nПараметры для загрузки чужих ядер здесь вынесены в отдельный файл настроек:\n\n```\nusettings.cfg\n```\n\n```\nuroot=hd0,2\nboot=/boot\nopts=\"root=LABEL=Ubuntu_root ro resume=LABEL=SwapU\"\nhpref=\"Ubuntu\"\n```\n\nСам скрипт:\n\n```\nubuntu.cfg\n```\n\n```\nfunction usave {\n if [ \"$1\" != \"$usel\" ] ; then\n  usel=\"$1\"\n  save_env usel\n fi\n}\n\nfunction umenu {\n . $prefix/usettings.cfg\n\n kpref=$boot/vmlinuz-\n ipref=$boot/initrd.img-\n\n load_env\n default=\"$hpref $usel\"\n if [ -n \"$2\" ] ; then default=\"$default $2\" ; fi\n\n kernels=\n for kfile in \"$uroot$kpref\"* ; do\n  k=\n  regexp -s k \"$kpref\"'(.+)' \"$kfile\"\n  kernels=\"$k $kernels\"\n done\n\n for k in $kernels ; do\n  ifile=\"$uroot$ipref$k\"\n  if [ -f \"$ifile\" ] ; then\n   head=\"$hpref $k\"\n   if [ -n \"$2\" ] ; then head=\"$head $2\" ; fi\n   menuentry \"$head\" --source=\"usave $k\nlinux $uroot$kpref$k $opts $1\ninitrd $ifile\"\n  fi\n done\n}\n\nsubmenu \"Ubuntu\" --hotkey=u {\n insmod regexp\n\n submenu \"Recovery mode\" --hotkey=r {\n  umenu \"recovery nomodeset\" \"recovery mode\"\n }\n\n umenu\n}\n```\n\nЭтот скрипт в конфиге GRUB динамически генерирует отдельное подменю со всеми имеющимися ядрами Ubuntu, и отдельно (для Ubuntu) запоминает последнее выбранное ядро.\n\n"
    },
    {
      "title": "Прямая загрузка из образа диска",
      "level": 4,
      "content": "GRUB2 может загружать образы ядер ОС в том числе из файлов-образов, отображаемых в псевдоустройство командой loopback. Однако следует иметь в виду, что псевдоустройство действует только в пределах загрузчика. В общем случае загрузка из образа выглядит примерно так:\n\n```\nloopback loop файл-образа\nlinux (loop)/путь/к/vmlinuz параметры\ninitrd (loop)/путь/к/initrd\n```\n\nПосле отображения образа в loop-устройство (имя может быть любым, не только loop), можно средствами GRUB2 обращаться с ним так же, как и с физическими дисками – не только загружать файлы ядра и initrd, что происходит перед загрузкой, а к примеру, прочитать метку ФС образа (требуется для образа Arch):\n\n```\nprobe -s isolabel -l loop\n```\n\nТак как средства загрузки с loopback-устройства в разных дистрибутивах различаются, для каждого из них требуется передавать при загрузке параметры, специфичные для данного дистрибутива.\n\n- Установочный образ Arch требует метку ФС образа в параметре ядра archisolabel=, и линуксовое устройство раздела, на котором он лежит, в параметре img_dev= (универсальнее всего прочесть и передать его UUID, но можно использовать и метку, если она есть).\n- Образ Ubuntu довольствуется лишь путём к образу на диске, а остальное находит сам.\n\nВ некоторых дистрибутивах средства загрузки из образа могут и вовсе отсутствовать, поэтому не все существующие загрузочные образы могут быть использованы подобным образом.\n\nВо всех приведённых ниже примерах предполагается, что GRUB2 установлен на тот же раздел диска или флешки, где лежат образы (в противном случае см. ниже). Такой способ установки позволяет записать на одну флешку или внешний диск один или несколько образов, при этом сохранив возможность использования оставшегося места на носителе по прямому назначению, с сохранением предпочтительной файловой системы.\n\nВ этом примере GRUB2 загружает официальный установочный образ Arch Linux.\n\n```\ngrub.cfg\n```\n\n```\ndir=\narch=x86_64\ninsmod regexp               # для шаблонов * в именах файлов\nprobe -s root_uuid -u $root # получаем UUID для подстановки в img_dev=\n\nfor iso in $dir/archlinux-*-$arch.iso ; do      # ищем образ(ы) Arch по шаблону\n if [ ! -f \"$iso\" ] ; then continue; fi        # только если образ существует\n regexp -s build 'archlinux-(.+)-'$arch \"$iso\"  # получаем из имени образа дату сборки\n\n  menuentry \"Arch Linux ISO $build $arch\" --source=\"\\\nloopback loop $iso\nprobe -s isolabel -l loop\nlinux (loop)/arch/boot/$arch/vmlinuz archisolabel=\\$isolabel img_dev=/dev/disk/by-uuid/$root_uuid img_loop=$iso earlymodules=loop\ninitrd (loop)/arch/boot/$arch/archiso.img\"\n\ndone\n```\n\nФайл образа с именем вида archlinux-YYYY.MM.DD-x86_64.iso должен лежать в корне раздела. В этом случае текст файла конфигурации можно использовать \"как есть\", без каких-либо правок – загрузчик сам определит конкретное имя образа (или образов), сам прочитает UUID раздела, метку образа, и при загрузке передаст всё это дистрибутиву через параметры ядра.\n\nЕсли же вы хотите использовать для образа (образов) особый каталог, впишите путь к нему (относительно корня раздела) в строку dir=, например\n\n```\ndir=/images\n```\n\nВ этом примере GRUB2 загружает любые ISO-образы Ubuntu, кроме серверных. В сгенерированном меню будут варианты загрузки для всех найденных образов Ubuntu.\n\n```\ngrub.cfg\n```\n\n```\ndir=\ninsmod regexp\n\nfor iso in $dir/*ubuntu-*.iso ; do         # ищем образ(ы) Ubuntu\n if [ ! -f \"$iso\" ] ; then continue; fi    # только если образ существует\n regexp -s name '.*/(.+)\\.iso' \"$iso\"                # выделяем только имя\n if regexp server \"$name\" ; then continue ; fi              # Ubuntu Server не трогаем, там всё иначе\n if regexp amd64 \"$name\" ; then efi='.efi' ; else efi= ; fi # для x86_64 образ ядра vmlinuz.efi\n\n  menuentry \"$name\" --source=\"\\\nloopback loop $iso\nlinux (loop)/casper/vmlinuz$efi boot=casper iso-scan/filename=$iso noeject --\ninitrd (loop)/casper/initrd.lz\"\n\ndone\n```\n\nКак и в предыдущем примере, код не требует никаких правок, если файлы образов лежат в корне раздела, но можно вписать отдельный каталог для них в строку dir=\n\nЕсли образы требуется загружать с некорневого раздела встроенного жесткого диска (например, /home ), можно использовать тот же код, создав для него подменю:\n\n```\nsubmenu \"ISO boot\" {\n dir=\n set root=hd0,5 # здесь нужно вписать настоящий номер раздела\n # или найти его по метке, например Arch_home:\n # search -s root -l Arch_home\n insmod regexp\n probe -s root_uuid -u $root\n arch=x86_64\n \n # вместо этой строки вставляем основной код, начиная с for\n}\n```\n\nЕсли раздел требуется задать по UUID, можно сделать так:\n\n```\nsubmenu \"ISO boot\" {\n dir=\n root_uuid=ef6daeca-9278-40df-8c3b-55cf093ab215\n search -s root -u $root_uuid\n insmod regexp\n arch=x86_64\n \n # вместо этой строки вставляем основной код, начиная с for\n}\n```\n\n"
    },
    {
      "title": "Управление ходом загрузки",
      "level": 3,
      "content": "Так же, как и из Linux, из GRUB можно выполнить перезагрузку командой reboot и выключение командой halt\n\nКроме того, в режиме UEFI есть некоторые специфические действия.\n\n"
    },
    {
      "title": "Переход в интерфейс настроек UEFI",
      "level": 4,
      "content": "Не секрет, что на некоторых прошивках UEFI, особенно это относится к ноутбукам, может быть очень сложно попасть в интерфейс настроек UEFI путём нажатия при включении F2 или других клавиш, особенно если режим совместимости с BIOS (Legacy mode) полностью отключён или вообще отсутствует, а UEFI \"видит\" доступный загрузчик. Конечно, перезагрузиться в настройки UEFI можно и после загрузки Linux, например, консольной командой\n\n```\nsystemctl reboot --firmware-setup\n```\n\nНо есть более быстрый способ: перейти в интерфейс UEFI прямо из загрузчика, для этого в GRUB есть специальная команда fwsetup\n\nДругими словами, вы можете добавить в меню GRUB дополнительный пункт:\n\n```\nmenuentry \"UEFI Settings\" {\n fwsetup\n}\n```\n\nи выбрав его, сразу открыть настройки UEFI, без загрузки и перезагрузки ОС.\n\n"
    },
    {
      "title": "О защите загрузчика",
      "level": 4,
      "content": "По-умолчанию GRUB2 предоставляет любому пользователю полный доступ ко всем своим возможностям, включающим в себя не только выполнение любых пунктов меню, но и изменение их кода перед выполнением, а также терминал, позволяющий вручную выполнить любые команды загрузчика.\n\nВсё это может помочь при настройке и восстановлении системы, однако те же самые инструменты существенно облегчают любому посетителю взлом системы. Изменение параметров ядра может быть использовано для получения полномочий root без ввода пароля, а загрузка с внешнего носителя – для получения полного доступа ко всем незашифрованным данным.\n\nGRUB2 включает в себя средства ограничения доступа к загрузчику. С их помощью, в сочетании с ограничением доступа к BIOS, и запретом в BIOS на загрузку с любых внешних носителей, можно сильно затруднить несанкционированный доступ к системе, кроме случая вскрытия корпуса для извлечения дисков или сброса настроек BIOS.\n\n"
    },
    {
      "title": "Реализация паролей в GRUB2",
      "level": 4,
      "content": "Пользователи в GRUB2 делятся на три категории:\n\n- Гости, они же неавторизованные пользователи. Могут выполнять только не защищённые паролем пункты меню.\n- Авторизованные пользователи. Могут выполнять разрешенные для них пункты меню.\n- Администраторы. Имеют полный доступ – могут выполнять любые пункты меню, редактировать их перед выполнением, и открывать командный терминал.\n\nДля управления доступом к пунктам меню, команды menuentry и submenu поддерживают следующие опции: --users= позволяет задать список пользователей, которым разрешено выполнять этот пункт меню --unrestricted разрешает выполнять этот пункт меню без авторизации.\n\nСписок администраторов задаётся в переменной superusers, например так:\n\n```\nset superusers=root\n```\n\nПароль для каждого пользователя отдельно может быть задан в открытом виде командой\n\n```\npassword пользователь пароль\n```\n\nлибо в зашифрованном (хешированном) виде, командой\n\n```\npassword_pbkdf2 пользователь хеш\n```\n\nДля хеширования пароля используется утилита grub-mkpasswd-pbkdf2. Запустив её и введя (дважды) пароль, можно получить его хеш, пригодный для вставки в конфиг GRUB2.\n\nЧтобы защитить пароли и хеши от просмотра, можно задать права на файл с конфигом GRUB в виде root:root 600, либо вынести команды с паролями в отдельный файл\n\n```\n. $prefix/secret.cfg\n```\n\nи ограничить доступ только к нему.\n\n"
    },
    {
      "title": "Внедрение паролей в генерируемый конфиг",
      "level": 4,
      "content": "Конфигуратор grub-mkconfig сам не умеет ограничивать доступ к загрузчику, хотя и устанавливает права доступа к конфигу в -rw------- root root, что имеет смысл только для сохранения паролей.\n\nЕсть возможность вставить вручную написанный фрагмент конфига с паролями, добавив в конец файла /etc/grub.d/00_header примерно такие строки:\n\n```\ncat << EOF\n\nset superusers=root\npassword_pbkdf2 root grub.pbkdf2.sha512.10000.C2DDC47FC5C7341CE73DBD6728E8D29A.AA5A1DEA93E23358E908301439DEC488\n\nEOF\n```\n\nБолее гибкая настройка доступа к загрузчику, например разрешение штатной загрузки системы без ввода пароля, возможна либо путём добавления своих пунктов меню с опцией --unrestricted в конец файла /etc/grub.d/40_custom, либо при самостоятельном написании всего конфига GRUB.\n\n"
    },
    {
      "title": "Пример конфига с паролями",
      "level": 4,
      "content": "Здесь \"Arch Linux\" разрешено загружать без авторизации, \"Windows\" разрешено загружать пользователю second с паролем dnjhjq, а активировать \"Boot next disk\", позволяющий загрузиться с подключённой флешки, может только администратор по имени root, который никому не сказал свой пароль.\n\n```\nset default=0\nset timeout=5\nset superusers=root\n\npassword second dnjhjq\npassword_pbkdf2 root grub.pbkdf2.sha512.10000.C2DDC47FC5C7341CE73DBD6728E8D29A.AA5A1DEA93E23358E908301439DEC488\n\nmenuentry \"Arch Linux\" --unrestricted {\n linux /boot/vmlinuz-linux root=LABEL=Arch_root rw resume=LABEL=Arch_swap\n initrd /boot/initramfs-linux.img\n}\n\nsubmenu \"Windows\" --users=second {\n set root=hd0,1\n chainloader +1\n}\n\nsubmenu \"Boot next disk\" {\n set root=hd1\n chainloader +1\n}\n```\n\n"
    },
    {
      "title": "Визуальная настройка",
      "level": 3,
      "content": "GRUB2 предоставляет возможность менять способы отображения и внешний вид меню.\n\n"
    },
    {
      "title": "Цвета меню",
      "level": 4,
      "content": "Цвета меню GRUB2 задаются в переменных menu_color_normal (общие цвета текста/фона) и menu_color_highlight (цвета текста/фона выделенной строки). Например, цвета по умолчанию для Arch задаются в конфиге GRUB (grub.cfg) так:\n\n```\nset menu_color_normal=light-blue/black\nset menu_color_highlight=light-cyan/blue\n```\n\nили в настройках /etc/default/grub конфигуратора grub-mkconfig так:\n\n```\nGRUB_COLOR_NORMAL=\"light-blue/black\"\nGRUB_COLOR_HIGHLIGHT=\"light-cyan/blue\"\n```\n\nСписок доступных в GRUB2 цветов можно найти на сайте.\n\n"
    },
    {
      "title": "Скрытое меню",
      "level": 4,
      "content": "grub-mkconfig умеет \"скрывать\" меню так, что оно появляется на экране только при нажатии клавиши ESC до истечения таймаута. Чтобы использовать эту его возможность, нужно раскомментировать в /etc/default/grub строки\n\n```\nGRUB_HIDDEN_TIMEOUT=5\nGRUB_HIDDEN_TIMEOUT_QUIET=true\n```\n\nВ конфиг GRUB (grub.cfg) для получения аналогичного результата можно добавить такой код:\n\n```\nset timeout=5\n\necho -n \"Press ESC to see the menu... \"\nif sleep --verbose --interruptible $timeout\nthen set timeout=0\nelse unset timeout\nfi\n```\n\nЗдесь не задаётся отдельный таймаут для скрытого и видимого меню, а используется общий из переменной timeout. После вывода надписи запускается ожидание sleep с в выводом обратного отсчёта --verbose и прерыванием по ESC --interruptible . Если отсчёт не был прерван, таймаут уменьшается до нуля set timeout=0, и меню проскакивает без вывода на экран. В противном случае таймаут отключается вообще unset timeout, чтобы отсчёт не начался повторно после показа меню.\n\nЕсли вы используете в загрузчике графический режим с обоями и шрифтами, следует решить, нужно ли их инициализировать до начала отсчёта, или только если отсчёт прерван пользователем.\n\n"
    },
    {
      "title": "Настройка параметров режима экрана",
      "level": 4,
      "content": "GRUB2 может работать в текстовом и графических режимах экрана. Актуальный список режимов доступных средствами BIOS или UEFI на конкретной машине, можно получить, выполнив команду videoinfo в консоли загрузчика. На разных машинах, с разными графическими адаптерами, прошивками и мониторами, этот список может существенно отличаться.\n\nВыбрав нужный режим желательно предварительно его проверить с помощью команды videotest режим в той же консоли, примерно так:\n\n```\nvideotest 1280x1024x32\n```\n\nТестовая картинка должна отображаться на экране до нажатия на любую клавишу. Если вы видите её, значит тест пройден.\n\nNote: **только** \n\nGRUB2 стартует в текстовом режиме. Если нужно вернуться в текстовый режим из графического, можно использовать в скрипте конфигурации, или прямо в консоли GRUB, следующие команды:\n\n```\nunset lang\nterminal_output console\n```\n\nЕсли вы используете автоматический конфигуратор, в настройках которого стоит auto по-умолчанию, загрузчик после старта будет переходить в графический режим. Чтобы изменить это поведение, можно задать для загрузчика текстовый режим:\n\n```\nGRUB_GFXMODE=console\n```\n\nили же задать текстовый режим только для загрузки ядра:\n\n```\nGRUB_GFXPAYLOAD_LINUX=text\n```\n\nGRUB2 позволяет задать режим экрана для самого загрузчика в переменной gfxmode , и отдельно режим, который будет использоваться ядром Linux при загрузке, через переменную gfxpayload\n\nЭти режимы могут быть разными:\n\n```\ngrub.cfg\n```\n\n```\nset gfxmode=1024x768x32\nset gfxpayload=1280x1024x16\n```\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_GFXMODE=1024x768x32\nGRUB_GFXPAYLOAD_LINUX=1280x1024x16\n```\n\nили одинаковыми:\n\n```\ngrub.cfg\n```\n\n```\nset gfxmode=1280x1024x32\nset gfxpayload=$gfxmode\n```\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_GFXMODE=1280x1024x32\nGRUB_GFXPAYLOAD_LINUX=keep\n```\n\nТакже можно задать только один из них, не задавая другой.\n\nРежим экрана для ядра Linux будет установлен в начале загрузки ядра, никаких модулей GRUB для этого специально загружать не требуется.\n\nВместо жесткого указания конкретного режима, можно присвоить переменной слово auto , и в этом случае режим будет выбран автоматически, исходя из предпочтений BIOS видеокарты и предпочтительного режима монитора. Обычно auto соответствует максимальному из штатных режимов монитора, но в некоторых случаях нужный режим приходится выставлять вручную.\n\nСуществует также старый, специфический для BIOS, способ задать VESA-режим – через параметр ядра Linux vga, например vga=790\n\nВозможные значения для параметра vga, в зависимости от количества цветов и пикселей на экране, можно найти в этой таблице\n\n```\n+-----+--------------------------------------------+\n|     |  640x480    800x600   1024x768   1280x1024 |\n+-----+--------------------------------------------+\n| 256 | 0x301=769  0x303=771  0x305=773  0x307=775 |\n| 32K | 0x310=784  0x313=787  0x316=790  0x319=793 |\n| 64K | 0x311=785  0x314=788  0x317=791  0x31A=794 |\n| 16M | 0x312=786  0x315=789  0x318=792  0x31B=795 |\n+-----+--------------------------------------------+\n```\n\nОднако в некоторых версиях BIOS могут использоваться и другие коды режимов. Актуальные значения можно получить из вывода команды videoinfo в консоли GRUB или же выполнить в терминале запущенной ОС GNU/Linux команду\n\n```\nsudo hwinfo --framebuffer\n```\n\nКоманда hwinfo доступна в репозитории community.\n\n"
    },
    {
      "title": "Графический режим, шрифт и обои",
      "level": 4,
      "content": "Установка переменной gfxmode сама по себе НЕ переключает GRUB в графический режим. Чтобы перейти в графику, требуется:\n\n- задать режим в переменной gfxmode\n- загрузить командой loadfont хотя бы один шрифт\n- загрузить модуль поддержки графического режима (vbe для BIOS, либо efi_gop и efi_uga для UEFI)\n- и модуль графического терминала gfxterm\n- после всего этого запустить графический терминал командой terminal_output gfxterm\n\nGRUB2 поддерживает растровые шрифты в собственном формате pf2. Шрифт Unifont включен в пакет grub под именем unicode.pf2, и при установке загрузчика командой grub-install автоматически копируется в каталог /boot/grub/fonts\n\nВ графическом режиме GRUB2 также позволяет установить обои командой background_image . Поддерживаются изображения в форматах tga, png и jpeg, для каждого из них требуется предварительно загрузить соответствующий модуль. Максимальный поддерживаемый размер изображения зависит от вашего оборудования.\n\nВ настройках конфигуратора /etc/default/grub обои можно задать так:\n\n```\nGRUB_BACKGROUND=/boot/grub/themes/starfield/starfield.png\n```\n\nПример графического режима с установкой дефолтного шрифта и обоев из дефолтной темы оформления. Нужные модули графического режима выбираются автоматически.\n\n```\nif [ \"$grub_platform\" = \"pc\" ] ; then\n insmod vbe                        # загружаем модуль для BIOS\nelse\n insmod efi_gop                    # или для EFI\n insmod efi_uga\nfi\nloadfont $prefix/fonts/unicode.pf2  # загружаем шрифт\nset gfxmode=auto\ninsmod gfxterm                      # загружаем модуль графического терминала\nterminal_output gfxterm             # эта команда запускает графику\ninsmod png                          # для этих обой требуется модуль png\nbackground_image $prefix/themes/starfield/starfield.png\n```\n\nПосле установки юникодного шрифта можно использовать в меню GRUB кириллицу, и даже перевести на русский язык встроенные сообщения загрузчика, присвоив переменной lang значение ru .\n\nNote: **terminal_output console** \n\nЧтобы использовать в GRUB свои шрифты, нужно предварительно конвертировать их в формат pf2. Для этого в состав пакета grub входит утилита grub-mkfont . Лучше всего она работает с растровыми шрифтами в формате BDF\n\n```\ngrub-mkfont шрифт.bdf -o шрифт.pf2\n```\n\nи векторными в формате TTF\n\n```\ngrub-mkfont шрифт.ttf -s размер -o шрифт.pf2\n```\n\nПакет terminus-font для GRUB не подходит, требуется скачать с официального сайта его исходники, они как раз в формате BDF. Далее остаётся распаковать архив, конвертировать файл со шрифтом нужного размера, и скопировать в каталог, доступный для GRUB:\n\n```\n$ tar xf terminus-font-4.38.tar.gz\n $ cd terminus-font-4.38/\n $ ls *.bdf\nter-u12b.bdf  ter-u14v.bdf  ter-u18b.bdf  ter-u22b.bdf  ter-u28b.bdf\nter-u12n.bdf  ter-u16b.bdf  ter-u18n.bdf  ter-u22n.bdf  ter-u28n.bdf\nter-u14b.bdf  ter-u16n.bdf  ter-u20b.bdf  ter-u24b.bdf  ter-u32b.bdf\nter-u14n.bdf  ter-u16v.bdf  ter-u20n.bdf  ter-u24n.bdf  ter-u32n.bdf\n $ grub-mkfont -v ter-u16b.bdf -o ter-u16b.pf2\nFont name: Terminus Bold 16\nMax width: 8\nMax height: 16\nFont ascent: 12\nFont descent: 4\nNumber of glyph: 879\n $ sudo cp ter-u16b.pf2 /boot/grub/fonts/\n```\n\nПример фрагмента конфига GRUB со шрифтом Terminus и русским языком:\n\n```\nloadfont $prefix/fonts/ter-u16b.pf2\nset gfxmode=auto\nset lang=ru      # включаем русский язык\ninsmod vbe\ninsmod gfxterm\nterminal_output gfxterm\n```\n\nЕсли шрифты должны были быть загружены, но на экране выглядят неправильно, проверить это можно в консоли GRUB, с помощью команды lsfonts, которая выводит список успешно загруженных шрифтов.\n\nНекоторые файлы шрифтов могут быть устаревшими, и несовместимыми с установленной версией GRUB. Чтобы отдельно проверить загрузку каждого шрифта, можно попробовать вручную загружать их в консоли GRUB командами вида\n\n```\nloadfont $prefix/themes/тема/шрифт.pf2\n```\n\nПри попытке загрузить несовместимый шрифт будут выдаваться сообщения об ошибках.\n\n"
    },
    {
      "title": "Графическая тема оформления",
      "level": 4,
      "content": "Даже после переключения в графический режим, меню GRUB отображается с помощью символов псевдографики. Альтернативный вариант отображения GRUB – графические темы оформления\n\nТема включает в себя файл описания theme.txt, а также может содержать элементы картинок для \"рисования\" меню, шрифты и обои.\n\nВ пакет grub входит дефолтная тема оформления, при установке командой grub-install она копируется в каталог /boot/grub/themes/starfield/ . Тему для GRUB требуется прописывать в виде полного пути к файлу описания темы. В настройках конфигуратора /etc/default/grub это делается так:\n\n```\nGRUB_THEME=\"/boot/grub/themes/starfield/theme.txt\"\n```\n\nВ файлах конфигурации GRUB путь к файлу описания темы требуется записать в переменную theme ДО переключения в графический режим. Чтобы тема могла использовать указанные в ней элементы, до перехода в графику также нужно загрузить модули для использованных в ней форматов картинок (чаще всего png) и загрузить все имеющиеся в ней шрифты.\n\nПример загрузки темы оформления, входящей в пакет grub:\n\n```\ndir=$prefix/themes/starfield # каталог с темой\nset theme=$dir/theme.txt     # задаём файл описания\ninsmod regexp                # этот модуль позволяет использовать шаблоны в именах файлов\nloadfont $dir/*.pf2          # загружаем по шаблону сразу все шрифты из темы\ninsmod png                   # модуль поддержки картинок\nset gfxmode=auto\nset lang=ru\ninsmod gfxterm\ninsmod vbe\nterminal_output gfxterm      # включаем графику\n```\n\nНекоторые темы оформления GRUB можно найти в AUR.\n\n"
    },
    {
      "title": "Запоминание выбранного пункта меню",
      "level": 4,
      "content": "В настройках конфигуратора запоминание включается так:\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_DEFAULT=\"saved\"\nGRUB_SAVEDEFAULT=\"true\"\n```\n\nПример реализации запоминания в конфиге GRUB2 приведён ниже.\n\n"
    },
    {
      "title": "Однократная загрузка заданного без смены дефолта",
      "level": 4,
      "content": "Существует утилита grub-reboot, с её помощью можно из-под ОС запланировать однократную загрузку другого пункта меню, например так:\n\n```\ngrub-reboot \"Windows XP\"\n```\n\nВ генерированном меню это работает, если перед запуском grub-mkconfig в /etc/default/grub была строка\n\n```\nGRUB_DEFAULT=\"saved\"\n```\n\nПример реализации однократного выбора в конфиге GRUB2 приведён ниже.\n\n"
    },
    {
      "title": "Пример конфига GRUB с реализацией запоминания",
      "level": 4,
      "content": "```\nset timeout=5\nset default=0\nload_env # восстанавливаем переменные из файла\n\nif [ -n \"$next_entry\" ] ; then   # если задан временный выбор\n set default=\"$next_entry\"       # временно подменяем дефолт\n unset next_entry                # и очищаем временный выбор\n save_env next_entry\nfi                               # временный дефолт не сохраняем\n\nexport default    # на случай использования savedef внутри submenu\n\nfunction savedef {     # Создаём функцию по имени savedef\n if [ -n \"$1\" ]               # выбор берём либо\n  then def=\"$1\"               # из первого параметра\n  else def=\"$chosen\"          # либо из $chosen, переменной GRUB\n fi                           # с заголовком выбранного пункта меню\n if [ \"$def\" != \"$default\" ] ; then   # Если выбор отличается\n  set default=\"$def\"                  # от текущего дефолта -\n  save_env default                    # сохраняем его\n fi\n unset def\n}                    # конец функции\n\nmenuentry \"Arch Linux\" {\n savedef\n linux /boot/vmlinuz-linux root=LABEL=Arch_root rw\n initrd /boot/initramfs-linux.img\n}\n\nmenuentry \"Arch Linux fallback\" {\n savedef \"Arch Linux\" # в следующий раз выберется \"Arch Linux\"\n linux /boot/vmlinuz-linux root=LABEL=Arch_root rw\n initrd /boot/initramfs-linux-fallback.img\n}\n\nsubmenu \"Windows XP\" {\n savedef\n set root=hd0,1\n ntldr /ntldr\n}\n```\n\nВ данном примере используется предоставляемая GRUB2 возможность сохранения переменных между сеансами.\n\nКоманда load_env загружает из файла все сохранённые в нём переменные.\n\nКоманда save_env сохраняет указанные переменные в файл.\n\nВ переменную chosen после выбора пункта меню помещается его заголовок. При выборе пунктов вложенных меню, в переменную записывается весь \"путь\", состоящий из последовательно выбранных заголовков, разделённых знаком \">\". Например, если в подменю \"Fallback\" выбран пункт \"Arch linux-lts\", в переменной будет \"Fallback>Arch linux-lts\".\n\nТакже здесь используется объявление функции. Функция вызывается так же, как другие команды GRUB. При каждом вызове эта функция будет сравнивать свой параметр или заголовок выбранного пункта меню с переменной default, и если выбор отличается - записывать его в default и сохранять.\n\nПеременные сохраняются в файле /boot/grub/grubenv . Так как GRUB не умеет корректно модифицировать файловые системы, файл должен быть заранее создан, а длина его при перезаписи не должна меняться, поэтому конец файла до нужной длины в 1024 байта всегда заполнен символами ### . Для просмотра и изменения при загруженной ОС сохранённых в этом файле переменных, настоятельно рекомендуется использовать утилиту grub-editenv, либо grub-reboot и grub-set-default.\n\n"
    },
    {
      "title": "Динамическое меню",
      "level": 3,
      "content": "Конфиг GRUB2 это скрипт, выполняемый загрузчиком. Он действительно генерирует, а не статически описывает меню загрузчика.\n\nВ этом примере загрузчик сам, \"на лету\", находит в /boot/ все установленные ядра Arch Linux и образы initramfs, правильно группирует их и формирует меню для их загрузки, а после выбора пункта меню запоминает его. При загрузке в параметры ядра подставляется автоматически найденный загрузчиком UUID корневого раздела.\n\nВ grub.cfg пишем только ссылку. (причину см. выше.)\n\n```\n/boot/grub/grub.cfg\n```\n\n```\n. $prefix/main.cfg\n```\n\nПользовательские настройки подключаются из отдельного файла settings.cfg\n\n```\n/boot/grub/settings.cfg\n```\n\n```\nset menu_color_normal=white/blue\nset menu_color_highlight=white/black\nset timeout=5\nset default=0\n\nboot=/boot\nprobe -s UUID -u $root    # автоматически определяем UUID корня\nopts=\"root=UUID=$UUID rw\" # и подставляем его в параметры ядра\naddimg=$boot/intel-ucode.img # включаем обновление микрокода CPU intel\n\nload_env\n```\n\nЦентральный файл, здесь реализована функция запоминания выбранного пункта меню, сюда же подключены остальные части конфига:\n\n```\n/boot/grub/main.cfg\n```\n\n```\n# Подключаем файл настроек\n. $prefix/settings.cfg\n\n# Поддержка однократного выбора\nif [ -n \"$next_entry\" ] ; then\n set default=\"$next_entry\"\n unset next_entry\n save_env next_entry\nfi\n\nexport default\n\n# Описываем функцию запоминания\nfunction savedef {\n if [ -n \"$1\" ]\n then def=\"$1\"\n else def=\"$chosen\"\n fi\n if [ \"$def\" != \"$default\" ] ; then\n  set default=\"$def\"\n  save_env default\n fi\n unset def\n}\n\n# Подключаем динамическое меню\n. $prefix/dynamic.cfg\n\n# Подключаем файл для дополнительных пунктов меню, если он есть\nc=\"$prefix/custom.cfg\"\nif [ -f \"$c\" ] ; then\n . \"$c\"\nfi\n```\n\nСкрипт поиска ядер и генерации меню:\n\n```\n/boot/grub/dynamic.cfg\n```\n\n```\ninsmod regexp\n\ninitrd=initrd\nif [ -n \"$addimg\" -a -f \"$addimg\" ] ; then\n initrd=\"$initrd $addimg\"\nfi\n\nkpref=\"$boot/vmlinuz-\"\nipref=\"$boot/initramfs-\"\n\nkernels=\nfor kfile in \"$kpref\"* ; do\n k=\n regexp -s k \"$kpref\"'(.+)' \"$kfile\"\n kernels=\"$kernels $k\"\ndone\n\nfor ifile in \"$ipref\"* ; do\n\n kname=\n for k in $kernels; do\n  if regexp \"$k\" \"$ifile\" ; then\n   if ! regexp \"$kname\" \"$k\" ; then continue; fi\n   head=\"Arch $k\"\n   if regexp -s s \"$k\"'-(.+).img' \"$ifile\"\n   then head=\"$head $s\"; fi\n   kname=\"$k\"\n  fi\n done\n\n if [ -n \"$kname\" ] ; then\n  menuentry \"$head\" --source=\"savedef\nlinux $kpref$kname $opts\n$initrd $ifile\"\n fi\n\ndone\n```\n\n"
    },
    {
      "title": "Консоль GRUB2",
      "level": 2,
      "content": "Загрузчик GRUB2 выполняет свой файл конфигурации как шелл-подобный скрипт, состоящий из команд. Все те же команды он позволяет выполнять и в интерактивном режиме, с помощью консоли.\n\n"
    },
    {
      "title": "Запуск консоли",
      "level": 4,
      "content": "Если вы видите в терминале GRUB2 приглашение вида grub> , значит вы попали в его нормальную консоль.\n\nGRUB2 открывает нормальную консоль, если:\n\n- при загрузке не найден файл конфигурации grub.cfg;\n- файл конфигурации найден и выполнен, но в ходе его выполнения так и не было создано меню, и не была выполнена команда boot (см. ниже), либо её выполнение завершилось неудачно;\n- в меню загрузчика нажата клавиша \"c\".\n\n"
    },
    {
      "title": "Команды, полезные в консоли GRUB2",
      "level": 4,
      "content": "Кроме уже описанных в части \"Настройка\", в консоли GRUB2 могут пригодиться:\n\n- Переменная pager . Присвоение ей единицы командой pager=1 поможет вам полностью читать вывод следующих команд, если он не помещается на экран.\n- Команда help . Без параметров выводит список всех поддерживаемых в текущей конфигурации команд загрузчика. При вызове вида help слово выводит справку по командам, в которых присутствует заданное слово. Например, команда help normal покажет справку по командам normal и normal_exit.\n- Команда ls без параметров выводит список дисков и разделов, доступных в данный момент загрузчику. С ключом -l показывает подробные сведения о каждом из них – размер, метку, UUID и тип файловой системы. С ключами -lh выводит размеры в \"человекочитаемом\" виде. С параметром в виде диска или раздела выводит сведения только о нём, например ls (hd0,1) выведет сведения о первом разделе на нулевом диске.\n- Команда ls с параметром в виде полного пути к каталогу выводит содержимое каталога. С ключом -l показывает подробные ведения о каждом файле и каталоге, с ключами -lh выводит размеры и даты в \"человекочитаемом\" фромате. К примеру, команда ls -lh /boot подробно выведет содержимое каталога /boot на текущем (в переменной root) разделе, а ls (hd0,1)/ покажет список файлов и каталогов в корневом каталоге раздела hd0,1.\n- Команда set без параметров. Выводит список всех переменных со значениями.\n- Команда echo аналогична такой же команде обычного шелла, и выводит всё, что в ней написано. Может использоваться для вывода переменных, например echo $cmdpath $prefix $root покажет значения трёх самых важных переменных загрузчика.\n- Команда cat аналогична одноимённой команде шелла, и выводит содержимое заданного файла в консоль. Так как перенаправления ввода-вывода GRUB2 не поддерживает, использовать её можно только для просмотра текстовых файлов, например, конфига самого загрузчика, fstab, и т.д.\n- Команда boot запускает образ ядра, другого загрузчика, или EFI-приложения, загруженный перед этим командами linux, initrd, ntldr, chainloader и некоторыми другими. В отличии от меню GRUB, где запуск загруженных образов происходит автоматически после завершения кода пункта меню, в консоли выполнение этой команды обязательно – без неё загруженный образ сам не запустится.\n\nВ нормальной консоли GRUB2 поддерживает возврат к предыдущим командам и автодополнение команд, каталогов и файлов по нажатию клавиши TAB, как в консоли Linux.\n\n"
    },
    {
      "title": "Пример загрузки Arch Linux из консоли загрузчика",
      "level": 4,
      "content": "Если вы успешно установили загрузчик в корневой раздел, но забыли создать конфиг загрузчика, вы увидите меню из дефолтного конфига, но оно не будет работать. Чтобы продолжить загрузку, вы можете войти в консоль, нажав клавишу \"c\", и выполнить команды:\n\n```\nprobe -s UUID -u $root\nlinux /boot/vmlinuz-linux rw root=UUID=$UUID\ninitrd /boot/initramfs-linux.img\nboot\n```\n\n"
    },
    {
      "title": "Пример загрузки с внешнего диска из консоли",
      "level": 4,
      "content": "Во многих версиях BIOS нет специального интерфейса для однократной загрузки с флешки. Для этого можно создать отдельный пункт меню, но на один раз проще обойтись консолью GRUB:\n\n```\nroot=hd1\nchainloader +1\nboot\n```\n\n"
    },
    {
      "title": "Пример конфига с загрузкой без меню",
      "level": 4,
      "content": "```\ngrub.cfg\n```\n\n```\nset timeout=3\n\nprobe -s UUID -u $root\nlinux /boot/vmlinuz-linux rw root=UUID=$UUID\ninitrd /boot/initramfs-linux.img\n\nif sleep -vi $timeout\nthen boot\nfi\n```\n\nВ этом примере GRUB2 загружает с диска образы ядра и initramfs, ждёт 3 секунды, и запускает ядро.\n\nЕсли же в течении этих секунд пользователь нажмёт ESC, он попадёт в консоль загрузчика. Так как ядро уже загружено, для продолжения загрузки достаточно набрать команду boot в консоли.\n\n"
    },
    {
      "title": "Аварийная консоль",
      "level": 3,
      "content": "Если вместо меню или \"шапки\" нормальной консоли вы видите при старте загрузчика сообщение об ошибке и приглашение вида grub rescue>, значит вы попали в аварийную консоль.\n\nАварийная консоль GRUB2 встроена в стартовый образ загрузчика, и запускается в случаях, когда GRUB2 не может самостоятельно перейти в \"нормальный\" режим. Такое может случиться, если ядро GRUB2 при загрузке не нашло каталог со своими файлами и модулями по пути, указанному в переменной prefix.\n\nЗначение этой переменной обычно имеет вид (диск,раздел)/путь, например (hd0,msdos6)/boot/grub. Обозначение диска подставляется при старте загрузчика, а остальная часть (начиная с запятой) \"зашивается\" в стартовый образ ещё на этапе установки. Это значит, что после изменения любого из содержащихся в $prefix параметров (таблицы разделов, номера раздела, пути к файлам grub), загрузчик требуется переустанавливать, в противном случае он \"вывалится\" в аварийную консоль.\n\nВ режиме аварийной консоли GRUB2 понимает всего 4 команды: set , unset , ls , и insmod . Повтор и автодополнение не поддерживаются, команда ls поддерживается в урезанном виде – без ключей и с выводом в сведениях о разделах только типа файловой системы, если она опознана. По-умолчанию в стартовый образ загрузчика включается модуль для поддержки таблицы разделов и файловой системы только для того раздела, на который устанавливается GRUB2. Остальные модули должны загружаться уже из файлов, если загрузчику удастся их найти.\n\nВ некоторых случаях, когда встроенных в стартовый образ модулей достаточно для продолжения загрузки в изменившихся условиях, загрузку можно продолжить, изменив в аварийной консоли переменную $prefix.\n\nЕсли вы попали в аварийную консоль, наберите для начала команду set. Вы увидите значения трёх главных переменных GRUB2. В переменной cmdpath будет обозначение диска, либо полный путь к EFI-файлу, из которого стартовал образ загрузчика. В переменной prefix будет тот путь, по которому должен был быть каталог с остальными файлами загрузчика. В переменной root будет текущий диск или раздел, скорей всего совпадающий с тем, что в $prefix. Попробуйте команды\n\n```\nls\nls $root\nls $prefix\n```\n\nЕсли вы знаете, что делалось с диском перед тем, как GRUB показал ошибку, то возможно, вы уже догадываетесь, в чём ошибка и удастся ли её исправить.\n\nЕсли в переменной $root оказался не тот или несуществующий раздел, можно проверять командами вида ls (диск,раздел)/ каждый раздел из тех, что вывела первая команда, пока не найдётся нужный. Если он нашелся – к примеру, оказался hd0,msdos5 вместо hd0,msdos6, и читается – запишите его в переменные:\n\n```\nroot=hd0,5\nprefix=($root)/boot/grub\n```\n\nЕсли раздел правильный, а неправильный каталог (команда ls $prefix выдаёт ошибку или не то, что нужно), запишите в переменную правильный путь, допустим такой:\n\n```\nprefix=($root)/grub\n```\n\nЕсли у вас получилось найти правильный диск, раздел и каталог, и вы успешно прописали из в переменные, остаётся загрузить модуль \"normal\" и выполнить одноимённую команду (она станет доступна после загрузки модуля), чтобы перейти в \"нормальный\" режим загрузчика:\n\n```\ninsmod normal\nnormal\n```\n\nЕсли же из аварийной консоли не удаётся получить доступ к нужному каталогу с файлами загрузчика – увы, но больше она ничем не сможет помочь, и вам придётся обратиться к другим способам загрузки, например с внешних носителей.\n\n"
    },
    {
      "title": "Запуск GRUB2 из других загрузчиков",
      "level": 2,
      "content": "- Загрузочный EFI-образ GRUB2 в режиме UEFI может быть запущен так же, как любое EFI-приложение.\n- Загрузочный образ BIOS-сборки GRUB2 новых версий может быть запущен по стандарту Multiboot из других загрузчиков. См. также главу \"Генерация загрузочного образа для BIOS без установки\".\n\n"
    },
    {
      "title": "Загрузка из старых версий GRUB",
      "level": 3,
      "content": "Код конфига для GRUB Legacy, с загрузкой GRUB2:\n\n```\nmenu.lst\n```\n\n```\ndefault 0\ntimeout 1\n\ntitle       Chainload into GRUB v2\nroot        (hd0,7)\nkernel      /boot/grub/i386-pc/core.img\n```\n\n"
    },
    {
      "title": "Загрузка из syslinux",
      "level": 3,
      "content": "Пример загрузки GRUB2 из syslinux приведён в статье о нём.\n\n"
    },
    {
      "title": "Сообщение о невозможности встраивания в MBR",
      "level": 3,
      "content": "```\ngrub-setup: warn: This msdos-style partition label has no post-MBR gap; embedding won't be possible!\ngrub-setup: warn: Embedding is not possible. GRUB can only be installed in this setup by using blocklists.\n            However, blocklists are UNRELIABLE and its use is discouraged.\ngrub-setup: error: If you really want blocklists, use --force.\n```\n\nЭта ошибка может возникнуть, когда вы попытаетесь установить в виртуальную машину VMware. Читайте больше об этом здесь.\n\nЭто также может случится, если первый раздел начинается сразу после MBR, без необходимого места в 60 блоков перед первым разделом.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Статья о GNU GRUB на Википедии\n- Официальное руководство пользователя GRUB (англ.)\n- Статья о GRUB на Ubuntu Wiki (англ.)\n- Загрузка на UEFI-системах (англ.)\n- Загрузочный раздел BIOS (англ.)\n- Настройка GRUB (англ.)\n- Загрузка с помощью GRUB (англ.)\n\n"
    }
  ]
}