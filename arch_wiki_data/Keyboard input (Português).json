{
  "title": "Keyboard input (Português)",
  "url": "https://wiki.archlinux.org/title/Keyboard_input_(Portugu%C3%AAs)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.** This article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nThis article or section needs language, wiki syntax or style improvements. See Help:Style for reference.\n\nRelated articles\n\n- Extra keyboard keys\n- Input remap utilities\n- Linux console (Português)/Keyboard configuration (Português)\n- Keyboard shortcuts (Português)\n\nPara modificar o mapeamento de teclas, é essencial saber como uma tecla pressionada resulta em um símbolo:\n\n1. O teclado envia um scancode ao computador.\n1. O kernel Linux mapeia o scancode para um código-chave, veja Mapear scancodes a códigos-chave (Inglês).\n1. O leiaute de teclado mapeia o código-chave para um símbolo ou para um keysym, dependendo de quais teclas modificadoras (Inglês) forem pressionadas. Para o console Linux, veja Linux console Para Xorg e Wayland, veja Configuração Xorg/Teclado (Inglês)\n\n- Para o console Linux, veja Linux console\n- Para Xorg e Wayland, veja Configuração Xorg/Teclado (Inglês)\n\nA maioria de suas teclas já deve ter um código-chave, ou pelo menos um scancode. Teclas sem um scancode não são reconhecidas pelo kernel; como exemplo, teclas adicionais de teclados e mouses específicos para jogos.\n\nNo Xorg, alguns keysyms (por exemplo, XF86AudioPlay, XF86AudioRaiseVolume) podem ser ser mapeados para ações — lançar uma aplicação externa, i.e. Veja Keyboard shortcuts (Português)#Xorg para maiores detalhes.\n\nNo console Linux, alguns keysyms (e.g. F1 to F246) podem ser mapeados para certas ações, como, por exemplo, alternar para um console diferente ou imprimir alguma sequência de caracteres na tela. Veja Linux console (Português)/Keyboard configuration (Português)#Criando um mapa de teclado personalizado para maiores detalhes.\n\n"
    },
    {
      "title": "Usando showkey",
      "level": 3,
      "content": "A maneira tradicional de se captar um scancode é por meio do utilitário showkey(1). showkey espera uma tecla ser pressionada ou, alternativamente, cancela a execução automaticamente caso nenhuma tecla seja pressionada em 10 segundos. Para que showkey funcione corretamente, há a necessidade de se estar em um console virtual (Inglês) e não em um ambiente gráfico ou logado por meio de uma conexão de rede. Dito isso, execute o seguinte comando:\n\n```\n# showkey --scancodes\n```\n\ne tente pressionar teclas no teclado; você deve ver scancodes sendo impressos no output.\n\n"
    },
    {
      "title": "Usando evtest",
      "level": 3,
      "content": "Para teclados USB, aparentemente é necessário usar o comando evtest(1) contido no pacote evtest em vez do comando showkey [1], vejamos:\n\n```\n# evtest /dev/input/event12\n```\n\n```\n...\nEvent: time 1434666536.001123, type 4 (EV_MSC), code 4 (MSC_SCAN), value 70053\nEvent: time 1434666536.001123, type 1 (EV_KEY), code 69 (KEY_NUMLOCK), value 0\nEvent: time 1434666536.001123, -------------- EV_SYN ------------\n```\n\nUse o campo \"value\" de MSC_SCAN. Esse exemplo demonstra que Numlock possui scancode 70053 e código-chave 69.\n\n"
    },
    {
      "title": "Usando dmesg",
      "level": 3,
      "content": "Você pode capturar o scancode de uma tecla ao pressionar a tecla desejada e observar a saída de dmesg. Por exemplo, se resultar em:\n\n```\nUnknown key pressed (translated set 2, code 0xa0 on isa0060/serio0\n```\n\nentão o scancode necessário é 0xa0.\n\n"
    },
    {
      "title": "Identificando códigos-chave",
      "level": 2,
      "content": "Os códigos-chave do Linux são definidos em /usr/include/linux/input-event-codes.h (veja as variáveis KEY_)\n\n"
    },
    {
      "title": "Identificando códigos-chave no console",
      "level": 3,
      "content": "Similarmente ao método de captação de scancode, os código-chaves para console virtual (Inglês) são indicados pelo utilitário showkey(1). showkey espera uma tecla ser pressionada ou, alternativamente, cancela a execução automaticamente caso nenhuma tecla seja pressionada em 10 segundos. Tal qual [[Mapeamento de Teclas (Português)#Usando showkey]], também há a necessidade de se estar num console virtual e não em um ambiente gráfico. Dito isso, execute o seguinte comando:\n\n```\n# showkey --keycodes\n```\n\ne tente pressionar teclas no teclado; você deve ver scancodes sendo impressos no output.\n\n"
    },
    {
      "title": "Identificando códigos-chave no Xorg",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nOs códigos-chave utilizados pelo Xorg são reportados pelo utilitário xev(1), incluído no pacote xorg-xev. Dito isso, para executar xev, há a necessidade de se estar em um ambiente gráfico e não no console virtual.\n\nCom o seguinte comando você pode iniciar xev e demonstrar apenas as partes relevantes:\n\n```\n$ xev | awk -F'[ )]+' '/^KeyPress/ { a[NR+2] } NR in a { printf \"%-3s %s\\n\", $5, $8 }'\n```\n\nAqui seria um exemplo de saída:\n\n```\n38  a\n55  v\n54  c\n50  Shift_L\n133 Super_L\n135 Menu\n```\n\nXbindkeys (Inglês) é outro wrapper para xev que reporta códigos-chave.\n\nSe, ao pressionar uma tecla e nada aparecer no terminal, significa que ou a tecla pressionada não possui um scancode, o scancode não está mapeado a um código-chave, ou que algum outro processo está capturando o pressionar da tecla. Se você suspeita que um processo escutando o servidor X está capturando o pressionar da tela, você pode tentar executar xev em uma sessão X limpa:\n\n```\n$ xinit /usr/bin/xterm -- :1\n```\n\n"
    },
    {
      "title": "Configuração de teclados compatíveis com VIA",
      "level": 2,
      "content": "VIA (Inglês) é um programa para remapear teclas diretamente em teclados compatíveis. Se o seu dispositivo for um desses, para que o teclado seja detectado pelo navegador e possibilite a configuração online, será necessário uma regra udev (Inglês) customizada, alterando a permissão dos dispositivos acessados por meio do driver hidraw.\n\nEscreva esse texto em /etc/udev/rules.d/99-viia.rules em seu editor de texto de preferência:\n\n```\nKERNEL==\"hidraw*\", SUBSYSTEM==\"hidraw\", MODE=\"0666\", TAG+=\"uaccess\", TAG+=\"udev-acl\"\n```\n\nE, finalmente, para que surja efeito com a mudança, é necessário recarregar udev com o seguinte comando:\n\n```\n# udevadm control --reload\n```\n\n"
    },
    {
      "title": "Ver também",
      "level": 2,
      "content": "- kbd-project - Website oficial do utilitário showkeys (Inglês)\n- wev - Visualizador de eventos para Wayland, similar ao xev para Xorg (Inglês)\n- interception-tools - conjunto de utilitários para controlar e customizar o comportamento de entrada dos mapeamentos de tecla (Inglês)\n- kmonad - um daemon de remapeamento e revinculação avançada de teclas (Inglês)\n- Hawck - outro daemon revinculador de teclas (Inglês)\n- keyd - daemon simplista de revinculação de teclas (Inglês)\n- Vial - programa independente para configuração de teclados com suporte a VIA (Inglês)\n\n"
    }
  ]
}