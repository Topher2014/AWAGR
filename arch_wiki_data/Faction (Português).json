{
  "title": "Faction (Português)",
  "url": "https://wiki.archlinux.org/title/Faction_(Portugu%C3%AAs)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Faction é uma biblioteca para desenvolvimento de software movido a testes.\n\n"
    },
    {
      "title": "Instalação",
      "level": 2,
      "content": "Instale o pacote libfactionAUR.\n\n"
    },
    {
      "title": "Uso",
      "level": 2,
      "content": "A biblioteca fornece várias macros C para acelerar os testes de gravação.\n\n- FI representa \"Faction Initialization\"\n- FT indica um \"Faction Test\"\n- FC representa \"Faction Close\"\n\nUsando a macro FT, três campos são obrigatórios.\n\n- AUTHORS() pega uma lista separada por vírgula de nomes de autores entre aspas duplas\n- SPEC() recebe uma única descrição de especificação de teste entre aspas duplas\n- Uma expressão booleana C (como ao usar macros de declaração C)\n\nA convenção determina que os testes de Faction devem ser escritos na parte inferior do arquivo fonte que contém o código que será testado. Os testes devem ser cercados por uma proteção macro FACTION (veja o exemplo abaixo) para que possam ser ativados/desativados no tempo de compilação. Compiladores C, como o GNU C Compiler (GCC), oferecem uma maneira de ativar macros na linha de comando (ou seja, o sinalizador -D)\n\n"
    },
    {
      "title": "Exemplo",
      "level": 2,
      "content": "```\n/* Essa é a função a ser testada */\nint\nincrement(int input)\n{\n   return (input + 1);\n}\n\n#ifdef FACTION\n#include <faction.h>\n#include <limits.h>\nFI\n\n  FT(\n    AUTHORS( \"timetoplatypus\" ),\n    SPEC( \"increment() returns 1 when given 0\" ),\n    increment(0) == 1\n  );\n\n  FT(\n    AUTHORS( \"timetoplatypus\" ),\n    SPEC( \"increment() returns 0 when given the largest integer value\" ),\n    increment(INT_MAX) == 0\n  );\n\nFC\n#endif\n```\n\nIsso pode ser compilado usando gcc nome-de-arquivo.c -D FACTION\n\n"
    },
    {
      "title": "Modos",
      "level": 2,
      "content": "Existem dois modos nos quais o Faction pode compilar: o modo minimal e o modo extended.\n\nO exemplo acima compila Faction no modo mínimo. Uma compilação mínima possui exatamente três dependências de biblioteca: stdlib, stdio e getopt. Uma compilação estendida possui dependências adicionais, incluindo algumas funções que estão disponíveis apenas através da macro de teste do recurso GNU.\n\nPortanto, para compilar no modo estendido, basta definir a macro de teste do recurso GNU na parte superior do arquivo. Por exemplo, o exemplo anterior modificado para ser compilado no modo estendido ficaria assim:\n\n```\n#ifdef FACTION\n#define _GNU_SOURCE\n#endif\n```\n\n```\n/* Essa é a saída a ser testada */\nincrement(int input)\n{\n  return (input + 1);\n}\n\n#ifdef FACTION\n#include <faction.h>\n#include <limits.h>\nFI\n\n  FT(\n    AUTHORS( \"timetoplatypus\" ),\n    SPEC( \"increment() returns 1 when given 0\" ),\n    increment(0) == 1\n  );\n\n  FT(\n    AUTHORS( \"timetoplatypus\" ),\n    SPEC( \"increment() returns 0 when given the largest integer value\" ),\n    increment(INT_MAX) == 0\n  );\n\nFC\n#endif\n```\n\n"
    },
    {
      "title": "Recursos de modo estendido",
      "level": 3,
      "content": "No modo estendido,\n\n- a saída pode ser opcionalmente espelhada para um arquivo de log especificado pelo usuário usando o sinalizador -l no tempo de execução.\n- a tabela de resultados será redimensionada dinamicamente para a largura do terminal que está sendo usado. Caso contrário, o padrão será uma largura de 78 caracteres.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- Site do Faction\n\n"
    }
  ]
}