{
  "title": "Dm-crypt (Português)/Device encryption (Português)",
  "url": "https://wiki.archlinux.org/title/Dm-crypt_(Portugu%C3%AAs)/Device_encryption_(Portugu%C3%AAs)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Esta página mostra como utilizar dm-crypt pela linha de comando para criptografar um sistema.\n\n"
    },
    {
      "title": "Preparação",
      "level": 2,
      "content": "Antes de usar cryptsetup, tenha certeza que o módulo de kernel dm_crypt está carregado.\n\n"
    },
    {
      "title": "Utilização do cryptsetup",
      "level": 2,
      "content": "cryptsetup(8) é uma ferramenta da linha de comando para o dm-crypt criar, acessar e gerenciar dispositivos criptografados. Ela foi expandida para suportar diferentes tipos de encriptação que dependem do mapeador de dispositivos e módulos criptografados (device-mapper and the cryptographic modules). A expansão mais notável foi o LUKS (Linux Unified Key Setup), que guarda todas as informações necessárias para o dm-crypt no próprio disco e abstrai a partição e gerenciamento de chaves com o objetivo de facilitar o uso. Dispositivos acessados via o mapeador de dispositivos são chamados de dispositivos de bloco, do inglês block devices. Para mais informações veja Criptografia de dados em repouso#Encriptação de dispositivo de bloco.\n\nA ferramenta é usada da seguinte forma:\n\n```\n# cryptsetup ação opções dispositivo nome_do_dm\n```\n\nExistem opções e modo de encriptação por padrão, que serão usados se nenhuma outra opção for especificada. Veja com:\n\n```\n$ cryptsetup --help\n```\n\nTodos os parâmetros, opções e ações por padrão serão listados. A lista completa das opções pode ser encontrada na página do manual. Dependendo do modo de encriptação escolhido e a ação selecionada, os parâmetros podem ser de uso obrigatório ou algo opcional. O resto das seções abaixo apontam os diferenciais com mais detalhes.\n\nA encriptação do dispositivo de bloco é rápida, porém a velocidade de desencriptação é também algo a se considerar; é importante escolher com cuidado o algoritmo que será utilizado, mudar a cifra criptográfica de um dispositivo de bloco já criptografado é trabalhoso, portanto verifique a performance do dm-crypt com diferentes parâmetros antes de instalar o sistema:\n\n```\n$ cryptsetup benchmark\n```\n\nFazer um teste antecipado lhe ajudará a decidir qual algoritmo e tamanho de chave você quer usar. Se algumas cifras AES se destacarem com uma grande diferença, estas provavelmente devem ter suporte de hardware na CPU.\n\n"
    },
    {
      "title": "Senhas e chaves do cryptsetup",
      "level": 3,
      "content": "Um dispositivo de bloco criptografado é protegido por uma chave, da qual pode ser:\n\n- uma frase secreta (passphrase), veja Segurança#Senhas.\n- um segredo em um arquivo-chave (keyfile), veja #Arquivos-chave/keyfiles.\n\nAmbos os tipos de chave possuem tamanhos padrões máximos: senhas podem ser até 512 caracteres e arquivos-chave até 8192 KiB.\n\nUma importante distinção do LUKS a se notar é que a chave é usada para desbloquear a chave mestre do dispositivo criptografado com LUKS, e a mesma pode mudar com acesso pelo root. Outros modos de encriptação não suportam mudança na chave depois de definida, pois não há a utilização de uma chave mestre na encriptação por estes modos. Veja Criptografia de dados em repouso#Encriptação de dispositivo de bloco para detalhes.\n\n"
    },
    {
      "title": "Opções de encriptação",
      "level": 2,
      "content": "Cryptsetup suporta diferentes modos de operações de encriptação com o uso pelo dm-crypt:\n\n- --type luks para usar a versão padrão do LUKS (LUKS1 com cryptsetup < 2.1.0, LUKS2 com cryptsetup ≥ 2.1.0),\n- --type luks1 para usar LUKS1, a versão anterior do LUKS,\n- --type luks2 para usar LUKS2, a atual versão do LUKS que introduz extensões adicionais,\n- --hw-opal-only para encriptação baseada em hardware em dispositivos com suporte ao padrão TCG OPAL. Veja sobre na página em inglês: Dispositivos de encriptação própria#Usando cryptsetup e cryptsetup(8) § SED (SELF ENCRYPTING DRIVE) OPAL EXTENSION.\n- --hw-opal para encriptação de hardware OPAL com uma camada de criptografia em software com dm-crypt.\n- --type plain para usar o modo plain do dm-crypt,\n- --type loopaes para o modo legado loopaes,\n- --type tcrypt para o modo de compatibilidade com TrueCrypt.\n- --type bitlk para modo de compatibilidade com BitLocker. Veja cryptsetup(8) § BITLK (WINDOWS BITLOCKER COMPATIBLE) EXTENSION.\n\nAs opções básicas de criptografia para as cifras e hashes disponíveis podem ser usadas em todos os modos e dependem das funcionalidades de encriptação na infraestrutura do kernel. Todas as que foram carregadas e estão disponíveis para uso como opções no tempo de execução do kernel podem ser vistas com:\n\n```\n$ less /proc/crypto\n```\n\nOs tópicos a seguir introduzem as opções de encriptação para os modos luks, luks1, luks2 e plain. Note que o conteúdo disposto lista as opções utilizadas em seus respectivos artigos e não todas as disponíveis.\n\n"
    },
    {
      "title": "Opções de encriptação para o modo LUKS",
      "level": 3,
      "content": "A ação do cryptsetup para configurar um novo dispositivo do dm-crypt no modo de encriptação LUKS é luksFormat. Diferente do que o nome implica, não formata o dispositivo, mas configura o cabeçalho do dispositivo LUKS e criptografa a chave mestre com as opções criptografadas desejadas.\n\nAo fim de criar um novo container do LUKS, juntamente com o conjunto de parâmetros padrões listados pelo cryptsetup --help, simplesmente execute:\n\n```\n# cryptsetup luksFormat dispositivo\n```\n\nDesde a versão 2.4.0 de cryptsetup o comando acima é o equivalente a:\n\n```\n# cryptsetup luksFormat --type luks2 --cipher aes-xts-plain64 --hash sha256 --iter-time 2000 --key-size 256 --pbkdf argon2id --use-urandom --verify-passphrase luksFormat dispositivo\n```\n\nUm comparativo das opções padrões com as especificações criptográficas mais bem discriminadas, acompanhado de comentários, foi feito nos exemplos da tabela abaixo:\n\nTable content:\nOpções | Padrão do cryptsetup 2.1.0 | Exemplo | Comentários\n--cipher -c | aes-xts-plain64 | aes-xts-plain64 | A versão 1.6.0 mudou o padrão para uma cifra do AES no modo XTS (veja o item 5.16 do FAQ). Não é recomendado o uso da cifra padrão anterior --cipher aes-cbc-essiv devido a seus conhecidos problemas e ataques práticos contra eles.\n--key-size -s | 256 (512 for XTS) | 512 | Por padrão uma chave com tamanho de 512 bit é usada para cifras XTS. Note no entanto que XTS divide a chave no meio, resultando no uso do AES-256.\n--hash -h | sha256 | sha512 | O algoritmo de Hash usado para derivação de chave. A versão 1.7.0 mudou o padrão de sha1 para sha256 \"não por segurança [mas] principalmente para previnir problemas de compabilidade em sistemas onde SHA1 já estava [em] desuso \"[1]. O antigo padrão do sha1 pode ainda ser usado por compatibilidade com versões mais velhas do cryptsetup desde que é considerada segura (veja o item 5.20).\n--iter-time -i | 2000 | 5000 | Número de milisegundos a serem esperados com o processamento da senha PBKDF. A versão 1.7.0 mudou o padrão de 1000 para 2000 com o objetivo de \"tentar manter a contagem da interação do PBKDF2 alta o bastante e também ainda aceitável pelos usuários.\"[2]. Esta opção é somente relevante para operações do LUKS que definem ou mudam senhas, tais como luksFormat ou luksAddKey. Especificando 0 como parâmetro seleciona o padrão compilado.\n--use-urandom | --use-urandom | --use-random | Seleciona qual gerador de números randômicos vai ser utilizado. Note que a blocking pool, ou seja, o bloqueio para gerar mais entropia com /dev/random, foi removido. Portanto a flag --use-random é agora equivalente ao --use-urandom.\n--verify-passphrase | Yes | - | Habilitado por padrão no Arch Linux para luksFormat e luksAddKey.\n--sector-size | 512 ou 4096 (dependente do dispositivo) | 4096 | Configura o tamanho do setor em bytes para o uso com encriptação de disco. O padrão é 4096 para dispositivos de bloco que anunciam a si mesmos como 4Kn ou 512e e 512 é para aqueles que anunciam a si próprios como 512n. Aumentar o tamanho do setor de 512 bytes para 4096 bytes pode melhorar desempenho na maioria dos dispositivos de armazenamentos modernos. Veja em Advanced Format#dm-crypt. | \n\n-c\n\n-s\n\n-h\n\n-i\n\nAs propriedades das funcionalidades e opções do LUKS são descritas nas especificações do LUKS1 (pdf) e LUKS2 (pdf).\n\n"
    },
    {
      "title": "Tempo de iteração",
      "level": 4,
      "content": "Retirado de cryptsetup FAQ§2.1 e §3.4:\n\nLevando isso em consideração, é então sempre melhor criar um container na máquina que será acessada com mais frequência.\n\nAcesse os links e veja o resto das seções mencionadas acima para dicas de como ajustar corretamente o tempo de iteração, em caso de surgir a necessidade para tal.\n\n"
    },
    {
      "title": "Opções de encriptação para o modo plain",
      "level": 3,
      "content": "No modo plain do dm-crypt, não existe chave mestre no dispositivo, consequentemente não é necessário defini-lá. As opções de encriptação são empregadas diretamente para criar a mapeação entre o disco criptografado e um dispositivo nomeado. O mapeamento pode ser criado na partição ou no dispositivo todo. Nesse último caso não é necessário uma tabela de partição.\n\nO mapeamento do modo plain com os parâmetros padrão do cryptsetup pode ser feito com:\n\n```\n# cryptsetup open --type plain opções  dispositivo dmnome\n```\n\nAo executar o comando será solicitada a senha, que deve possuir uma entropia muito alta, e a opção --verify-passphrase pode ser usada, mas não é um padrão. Em geral é recomendável anotar as opções de encriptação usadas durante a criação, pois tais opções não são derivadas do dispositivo criptografado, ou de um arquivo-chave (keyfile) opcional, além disso o código que define as opções padrões pode mudar.\n\nLogo abaixo há uma comparação dos parâmetros definidos como padrão com o exemplo em dm-crypt/Criptografando todo um sistema#dm-crypt plain:\n\nTable content:\nOpção | Padrão do cryptsetup 2.7.0 | Exemplo | Comentário\n--hash -h | sha256 | - | O hash é usado para criar a chave com a senha; não é usado em uma keyfile.\n--cipher -c | aes-xts-plain64 | aes-xts-plain64 | As cifras consistem de três pares: geradores cifra-modo_de_opeação-IV. Veja Criptografia de dados em repouso#Cifras e modos de operação para uma explicação dessas configurações, e a documentação do DMCrypt para os modos disponíveis.\n--key-size -s | 256 | 512 | O tamanho da chave (em bits). O tamanho dependerá da cifra utilizada e do chainmode em uso. O modo XTS requer o dobro de tamanho de chave do CBC.\n--size -b | Tamanho real do disco alvo | - (utilizado o padrão) | Limita o tamanho máximo do dispositivo (em setores de 512-byte).\n--offset -o | 0 | 0 | O quanto pular do inicio do disco alvo (setores de 512-byte) antes de começar o mapeamento\n--skip -p | 0 | 2048 (512B×2048=1MiB serão pulados) | O número de setores de 512-byte de dados criptografados a pular para o cálculo de vetor de inicialização (IV).\n--key-file -d | A senha será usada por padrão | /dev/sdZ (ou, por exemplo, /boot/keyfile.enc) | O dispositivo ou arquivo a ser usado como chave. Veja #Arquivos-chave/keyfiles para mais detalhes.\n--keyfile-offset | 0 | 0 | Distância do início do arquivo onde a chave começa (em bytes). Esta opção é suportada a partir da versão 1.6.7 do cryptsetup.\n--keyfile-size -l | 8192kB | - (utilizado o padrão) | Limita os bytes lidos da keyfile. Esta opção é suportada a partir da versão 1.6.7 do cryptsetup.\n--sector-size | 512 | 4096 | Configura o tamanho do setor em bytes com o uso de encriptação no disco. O padrão é 512 para tudo exceto em dispositivos de bloco 4kn. AUmentar o tamanho do setor de 512 bytes para 4096 bytes pode proporcionar melhor desempenho na maior parte dos dispositivos de armazenamento modernos. Veja a página em inglẽs em Advanced Format#dm-crypt.\n\n-h\n\n-c\n\n-s\n\n-b\n\n-o\n\n-p\n\n-d\n\n-l\n\nAo usar o dispositivo /dev/sdX, o exemplo da coluna acima da direita resulta em:\n\n```\n# cryptsetup open --type plain --cipher=aes-xts-plain64 --offset=0 --skip=2048 --key-file=/dev/sdZ --key-size=512 --sector-size 4096 /dev/sdX enc\n```\n\nNós podemos checar se o mapeamento foi feito com:\n\n```\n# fdisk -l\n```\n\nO dispositivo mapeado deve aparecer como /dev/mapper/enc.\n\n"
    },
    {
      "title": "Criptografando dispositivos com cryptsetup",
      "level": 2,
      "content": "Esta seção mostra como empregar as opções para criar novos dispositivos de bloco criptografados e acessá-los manualmente.\n\n"
    },
    {
      "title": "Formatando partições LUKS",
      "level": 4,
      "content": "Para configurar uma partição criptografada LUKS, execute:\n\n```\n# cryptsetup luksFormat dispositivo\n```\n\nLhe será solicitado uma senha e também a verificação desta.\n\nVeja #Opções de encriptação para o modo LUKS para opções da linha de comando.\n\nVocê pode checar os resultados com:\n\n```\n# cryptsetup luksDump dispositivo\n```\n\nNote que a saída vai mostrar a informação do cabeçalho da cifra criptográfica, como também as chaves em uso da partição LUKS.\n\nO seguinte exemplo criará uma partição raiz criptografada no /dev/sda1 usando a cifra AES padrão no modo XTS com uma efetiva encriptação de 256-bit\n\n```\n# cryptsetup luksFormat -s 512 /dev/sda1\n```\n\nNa criação de uma partição criptografada LUKS, uma keyfile pode ser associada usando:\n\n```\n# cryptsetup luksFormat dispositivo /caminho/para/keyfile\n```\n\nVeja #Arquivos-chave/keyfiles para instruções de como gerar e gerenciar keyfiles.\n\n"
    },
    {
      "title": "Abrindo/Mapeando partições LUKS com o mapeador de dispositivos",
      "level": 4,
      "content": "Uma vez que os containers LUKS foram criados, eles podem ser abertos.\n\nPara abrir um container LUKS voce precisa definir o nome do novo dispositivo mapeado. Isto alerta o kernel que dispositivo está criptografado e deve ser acessado através do LUKS usando o /dev/mapper/dm_nome para nao sobrescrever os dados criptografados. Para se proteger deste tipo de acidente, leia sobre como fazer backup do cabeçalho criptografado depois de terminar a configuração.\n\nPara abrir um container LUKS criptografado execute:\n\n```\n# cryptsetup open dispositivo dm_nome\n```\n\nSerá solicitada a senha para abrir o container. Normalmente o nome do dispositivo mapeado é uma breve descrição da função do container mapeado. Por exemplo, o comando a seguir abre uma partição root /dev/sda1 com LUKS, mapeia com o mapeador de dispositivos (device mapper) e nomeia-a como root:\n\n```\n# cryptsetup open /dev/sda1 root\n```\n\nUma vez aberto, a nomeação da partição root é definida como /dev/mapper/root, ao invés de ser o nome da partição (como por exemplo /dev/sda1).\n\nPara configurar um LVM em cima da camada de criptografia, o arquivo do dispositivo definido para o grupo de volume descriptografado será algo semelhante a /dev/mapper/root, ao invés de /dev/sda1. O LVM então fornecerá nomes adicionais para todos os volumes lógicos criados, como por exemplo /dev/lvmpool/root e /dev/lvmpool/swap.\n\nPara escrever dados criptografados dentro da partição a mesma deve ser acessada pelo nome do dispositivo mapeado. O primeiro passo para o acesso tipicamente será ao criar um sistema de arquivos. Por exemplo:\n\n```\n# mkfs.ext4 /dev/mapper/root\n```\n\nO dispositivo /dev/mapper/root então pode ser montado como qualquer partição.\n\nPara fechar o container do LUKS, desmonte a partição e execute:\n\n```\n# cryptsetup close root\n```\n\n"
    },
    {
      "title": "Usando TPM para armazenar chaves",
      "level": 4,
      "content": "Veja a página em inglês: Trusted Platform Module#LUKS encryption.\n\n"
    },
    {
      "title": "Criptografando dispositivos com o modo plain",
      "level": 3,
      "content": "Ambas as operações de criação e do acesso subsequente ao dm-crypt criptografado no modo plain não precisam mais do que o uso da ação cryptsetup open com os parâmetros corretos. A seguir é mostrado dois exemplos de dispositivos que não são root, mas com a adição de um truque para empilhar ambos (ou seja, o segundo é criado dentro do primeiro). Obviamente, colocar mais camadas de criptografia dobra o uso de recursos. O caso de uso ilustrado abaixo é somente um outro exemplo da utilização das opções de cifra.\n\nO primeiro mapeamento é criado com as opções padrões do modo plain do cryptsetup, como descrito na coluna esquerda da tabela acima.\n\n```\n# cryptsetup --type plain -v open /dev/sdxY plain1\n```\n\n```\nWARNING: Using default options for cipher (aes-xts-plain64, key size 256 bits) that could be incompatible with older versions.\nWARNING: Using default options for hash (sha256) that could be incompatible with older versions.\nFor plain mode, always use options --cipher, --key-size and if no keyfile is used, then also --hash.\nEnter passphrase for /dev/sdxY:\nCommand successful.\n```\n\nA mensagem de forma traduzida:\n\n```\nAVISO: Usando opções padrões para a cifra (aes-xts-plain64, chave com tamanho 256 bits) que podem ser incompatíveis com versões mais antigas.\nAVISO: Usando opções padrões para o hash (sha256) que podem ser incompatíveis com versões mais antigas.\nPara o modo plain, sempre use as opções --cipher, --key-size e se nenhum arquivo-chave for usado, então inclua também --hash.\nDigite a senha para /dev/sdxY:\nComando bem sucedido.\n```\n\nAgora por dentro do bloco nós podemos adicionar um segundo dispositivo de bloco, do qual usará parâmetros diferentes de criptografia e (opcionalmente) um offset. Crie um sistema de arquivos e monte-o.\n\n```\n# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10  open /dev/mapper/plain1 plain2\n```\n\n```\nEnter passphrase for /dev/mapper/plain1:\n```\n\n```\n# lsblk -p\n```\n\n```\nNAME\n /dev/sda\n ├─/dev/sdxY\n │ └─/dev/mapper/plain1\n │   └─/dev/mapper/plain2\n ...\n```\n\n```\n# mkfs -t ext2 /dev/mapper/plain2\n# mount -t ext2 /dev/mapper/plain2 /mnt\n# echo \"Dispositivo empilhado. Uma senha para cada macaco no seu galho\" > /mnt/empilhado.txt\n```\n\nFeche o dispositivo para checar se o acesso funciona:\n\n```\n# cryptsetup close plain2\n# cryptsetup close plain1\n```\n\nPrimeiro, vamos tentar abrir o sistema de arquivos diretamente:\n\n```\n# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/sdxY plain2\n```\n\n```\n# mount -t ext2 /dev/mapper/plain2 /mnt\n```\n\n```\nmount: /mnt: wrong fs type, bad option, bad superblock on /dev/mapper/plain2, missing codepage or helper program, or other error.\n       dmesg(1) may have more information after failed mount system call.\n```\n\nA mensagem de forma traduzida:\n\n```\nmontagem: /mnt/: tipo errado de fs (sistema de arquivos), opção ruim, superbloco ruim em /dev/mappper/plain2, codepage ou programa ajudante em falta, ou outro erro.\n       dmesg(1) talvez tenha mais informações após a falha da chamada de sistema da montagem.\n```\n\nPor que não deu certo? O ponto de início de \"plain2\" (10) ainda está criptografado com a cifra do \"plain1\". Ele só pode ser acessado através do mapeamento de dispositivos empilhados. O erro, no entanto, é arbitrário, então tentar acessar com uma senha incorreta ou com opções erradas, irá resultar no mesmo. Para o modo plain do dm-crypt, a ação open não apresentará erros por si só.\n\nTentando novamente, mas agora na ordem correta:\n\n```\n# cryptsetup close plain2    # dispositivo mapeado disfuncional da tentativa anterior\n```\n\n```\n# cryptsetup --type plain open /dev/sdxY plain1\n```\n\n```\nWARNING: Using default options for cipher (aes-xts-plain64, key size 256 bits) that could be incompatible with older versions.\nWARNING: Using default options for hash (sha256) that could be incompatible with older versions.\nFor plain mode, always use options --cipher, --key-size and if no keyfile is used, then also --hash.\nEnter passphrase for /dev/mapper/sdxY:\n```\n\n```\n# cryptsetup --type plain --cipher=serpent-xts-plain64 --hash=sha256 --key-size=256 --offset=10 open /dev/mapper/plain1 plain2\n```\n\n```\nEnter passphrase for /dev/mapper/plain1:\n```\n\n```\n# mount /dev/mapper/plain2 /mnt && cat /mnt/empilhado.txt\n```\n\n```\nDispositivo empilhado. Uma senha para cada macaco no seu galho.\n```\n\ndm-crypt irá cuidar da criptografia empilhada com alguns modos misturados também. Por exemplo o modo LUKS poderia ser empilhado no dispositivo mapeado \"plain1\". Seu cabeçalho deve estar criptografado dentro do \"plain1\".\n\nA opção --shared está somente disponível para o modo plain. Com esta um dispositivo pode ser segmentado em diferentes dispositivos mapeados sem sobreposição. Isto será exemplificado a seguir, usando um modo de cifra compatível com loopaes para o \"plain2\":\n\n```\n# cryptsetup --type plain --offset 0 --size 1000 open /dev/sdxY plain1\n```\n\n```\nWARNING: Using default options for cipher (aes-xts-plain64, key size 256 bits) that could be incompatible with older versions.\nWARNING: Using default options for hash (sha256) that could be incompatible with older versions.\nFor plain mode, always use options --cipher, --key-size and if no keyfile is used, then also --hash.\nEnter passphrase for /dev/sdxY:\n```\n\n```\n# cryptsetup --type plain --offset 1000 --size 1000 --shared --cipher=aes-cbc-lmk --hash=sha256 open /dev/sdxY plain2\n```\n\n```\nWARNING: Using default options for cipher (aes-xts-plain64, key size 256 bits) that could be incompatible with older versions.\nWARNING: Using default options for hash (sha256) that could be incompatible with older versions.\nFor plain mode, always use options --cipher, --key-size and if no keyfile is used, then also --hash.\nEnter passphrase for /dev/sdxY:\n```\n\n```\n# lsblk -p\n```\n\n```\nNAME\ndev/sdxY\n├─/dev/sdxY\n│ ├─/dev/mapper/plain1\n│ └─/dev/mapper/plain2\n...\n```\n\nComo a árvore de dispositivos mostra, ambos residem no mesmo nível, elas não estão empilhadas e \"plain2\" pode ser aberto individualmente.\n\n"
    },
    {
      "title": "Gerenciamento de chaves",
      "level": 3,
      "content": "É possível definir chaves adicionais para um container LUKS. Permitindo a criação do acesso a chaves para backup de dados seguro: Na prática conhecida como key escrow, uma chave é usada para utilização diária, outra guardada para ganhar acesso ao container caso a senha seja esquecida ou a keyfile foi perdida/danificada. Um diferente espaço de chave também pode ser usado para garantir acesso de um container para um usuário ao adicionar uma segunda chave e mais tarde removê-la.\n\nUma vez que o container criptografado foi criado, o espaço de chave (key slot) 0 é criado (se nenhum outro foi definido manualmente). Espaços de chave adicionais são numerados de 1 a 7. Os espaços de chave utilizados podem ser vistos com:\n\n```\n# cryptsetup luksDump /dev/dispositivo\n```\n\nOnde dispositivo é o dispositivo de bloco que contém o cabeçalho do LUKS. Este e todos os seguintes comandos nesta seção funcionam em backups de cabeçalho também.\n\n"
    },
    {
      "title": "Adicionando chaves do LUKS",
      "level": 4,
      "content": "Para adicionar novos slots de chave use a ação luksAddKey. Por segurança, será sempre solicitada, mesmo que o dispositivo já esteja destrancado, uma chave preexistente válida (\"any existing passphrase\") antes que a nova senha seja solicitada:\n\n```\n# cryptsetup luksAddKey /dev/dispositivo [/caminho/para/keyfile_adicional]\n```\n\n```\nEnter any existing passphrase:\nEnter new passphrase for key slot:\nVerify passphrase:\n```\n\nSe /caminho/para/keyfile_adicional for dado, cryptsetup adicionará a keyfile_adicional. Se não, o comando pedirá uma nova senha. Para autorizar a ação com uma keyfile existente, a opção --key-file ou -d seguida pela \"antiga\" keyfile irá tentar destrancar o dispositivo passando por todos os espaços de chave (keyslots) com arquivo-chaves (keyfile) registrados:\n\n```\n# cryptsetup luksAddKey /dev/dispositivo [/caminho/para/keyfile_adicional] -d /caminho/para/keyfile\n```\n\nSe é desejado usar múltiplas chaves e mudar ou remover elas, a opção --key-slot ou -S pode ser usada para especificar o slot:\n\n```\n# cryptsetup luksAddKey /dev/dispositivo -S 6\n```\n\n```\nAVISO: O parâmetro --key-slot é usado para um novo número de keyslot.\nEnter any existing passphrase:\nEnter new passphrase for key slot: \nVerify passphrase:\n```\n\n```\n# cryptsetup luksDump /dev/device\n```\n\n```\n...\nKeyslots: \n...\n6: luks2\n      Key: \t     512 bits\n      Priority:  normal\n...\n```\n\nPara mostrar uma ação associada neste exemplo, nós decidimos aproveitar para mudar a chave:\n\n```\n# cryptsetup luksChangeKey /dev/dispositivo -S 6\n```\n\n```\nEnter passphrase to be changed: \nEnter new passphrase:\nVerify passphrase:\n```\n\nAntes de removê-la.\n\n"
    },
    {
      "title": "Removendo chaves do LUKS",
      "level": 4,
      "content": "Existem três diferentes ações para remover chaves do cabeçalho:\n\n- luksRemoveKey é usado para remover uma chave por especificar sua senha/kefile.\n- luksKillSlot pode ser usado para remover uma chave específica (usando outra chave). Isto é extremamente útil se você esqueceu uma senha, perdeu uma keyfile ou não tem acesso a ela.\n- luksErase é usado para rapidamente remover todas as chaves ativas.\n\nNote: **não irá** \n\n- Todas as ações acima podem ser usadas para apagar irrevogavelmente a última chave ativa de um dispositivo criptografado!\n- O comando erase não irá solicitar por uma senha válida! Isto não irá apagar o cabeçalho do LUKS, mas sim todos os espaços de chave (keyslots) de uma vez só, então você não conseguirá mais acessar a menos que você tenha um backup válido do cabeçalho do LUKS.\n- Ao usar o comando erase em uma partição criptografada por hardware OPAL, o cabeçalho do LUKS será apagado juntamente com todo o conjunto de travamento criptografado pelo OPAL. Diferentemente de criptografia por software, esta ação torna o dispositivo irrecuperável, mesmo que seja usado um backup de um cabeçalho LUKS válido.\n\nConsiderando os avisos acima, é essencial que a chave que desejamos manter seja válida. Uma forma fácil de checar é abrir o dispositivo com a opção -v, do qual irá especificar o espaço que a chave ocupa:\n\n```\n# cryptsetup --test-passphrase -v open /dev/dispositivo\n```\n\n```\nNo usable token is available.\nEnter passphrase for /dev/dispositivo: \nKey slot 1 unlocked.\nCommand successful.\n```\n\nAgora sim podemos remover a chave adicionada na subseção anterior ao usar a devida senha:\n\n```\n# cryptsetup luksRemoveKey /dev/dispositivo\n```\n\n```\nEnter LUKS passphrase to be deleted:\n```\n\nSe for usada a mesma senha para dois espaços, a primeira ocorrência de espaço que tiver a senha vai ser apagado. Somente executando novamente a segunda vai ser apagada.\n\nAlternativamente, é possível especificar o espaço de chave:\n\n```\n# cryptsetup luksKillSlot /dev/dispositivo 6\n```\n\n```\nEnter any remaining LUKS passphrase:\n```\n\nNote que em ambos os casos nenhuma confirmação é necessária.\n\nReiterando o que foi falado acima: Se a mesma senha foi usada para o espaço 1 e 6, ambos os espaços com a senha devem ter sido apagados agora.\n\n"
    },
    {
      "title": "Backup e restauração",
      "level": 3,
      "content": "Se o cabeçalho de um container criptografado com LUKS é destruído, você não vai conseguir descriptografar seus dados. Tão problemático quanto esquecer a senha ou modificar/perder a keyfile. Danos podem acontecer por sua própria responsabilidade ao particionar novamente o disco depois ou por programas de terceiros que interpretam errado a tabela de partições. Então, ter um backup do cabeçalho e guardá-lo em outro lugar pode ser uma boa ideia.\n\n"
    },
    {
      "title": "Backup usando o cryptsetup",
      "level": 4,
      "content": "A ação luksHeaderBackup do cryptsetup faz o backup do cabeçalho LUKS e os espaços de chave:\n\n```\n# cryptsetup luksHeaderBackup /dev/dispositivo --header-backup-file /mnt/backup/arquivo.img\n```\n\nOnde dispositivo é a partição que contém o volume LUKS.\n\nVocê poderá também criar um backup do cabeçalho em texto puro dentro de um tmpfs e criptografá-lo, com por exemplo: GPG, antes de escrevê-lo em um armazenamento persistente:\n\n```\n# mount --mkdir -t tmpfs -o noswap tmpfs /root/tmp/\n# cryptsetup luksHeaderBackup /dev/dispositivo --header-backup-file /root/tmp/arquivo.img\n# gpg --recipient User ID --encrypt /root/tmp/arquivo.img \n# cp /root/tmp/arquivo.img.gpg /mnt/backup/\n# umount /root/tmp\n```\n\n"
    },
    {
      "title": "Restauração usando o cryptsetup",
      "level": 4,
      "content": "Para evitar a restauração de um cabeçalho errado, você pode antecipadamente verificar se funciona ao usá-lo como um cabeçalho remoto, ou seja, com a opção --header:\n\n```\n# cryptsetup -v --header /mnt/backup/arquivo.img open /dev/dispositivo test\n```\n\n```\nNo usable token is available.\nEnter passphrase for /dev/dispositivo:\nKey slot 0 unlocked.\nCommand successful.\n```\n\n```\n# mount /dev/mapper/test /mnt/test && ls /mnt/test \n# umount /mnt/test \n# cryptsetup close test\n```\n\nAgora que a verificação foi bem sucedida, a restauração pode ser feita:\n\n```\n# cryptsetup luksHeaderRestore /dev/dispositivo --header-backup-file ./mnt/backup/arquivo.img\n```\n\nTodos os espaços de chave (keyslots) foram sobrescrevidos; agora, logo após terminada a ação do comando, somente os espaços de chave ativos do arquivo de backup devem estar disponíveis.\n\n"
    },
    {
      "title": "Re-criptografando dispositivos",
      "level": 3,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nA ação reencrypt do cryptsetup permite re-criptografar dispositivos LUKS. Para dispositivos em LUKS2, a re-criptografia talvez possa ser feita online, isto é, com o dispositivo montado. O mesmo possui suporte para múltiplos processos de re-criptografia em paralelo e é resiliente a falhas de sistema. Uma re-criptografia de dispositivos em LUKS1 só pode ser feita offline (dispositivo desmontado), com apenas um único processo e é menos resiliente.\n\nVeja cryptsetup-reencrypt(8) para conhecer os modos de operação e as opções.\n\nÉ possível mudar #Opções de encriptação para o modo LUKS. Isto também pode ser usado para converter um sistema de arquivos não encriptado preexistente para um criptografado com LUKS, ou para permanentemente remover a criptografia de um dispositivo (usando a opção --decrypt); veja a página em inglês Removendo a criptografia do sistema para mais informações. Uma re-criptografia também é viável para cabeçalhos LUKS desanexados, mas tenha em mente o aviso anterior sobre a opção --header. Uma re-criptografia para outros modos sem ser o LUKS (por exemplo, modo plain) não é suportado.\n\nCriptografar novamente pode ser usado com a função de preservar a segurança dos dados, logo após que uma senha ou uma keyfile foi comprometida e não há como ter certeza se alguma cópia do cabeçalho foi adquirida. Por exemplo, se houve somente o conhecimento de alguma senha por alguém sem autorização (shoulder-surfed), mas nenhum acesso físico/lógico ocorreu, então alterar a respectiva senha/chave deverá ser o bastante (#Gerenciamento de chaves).\n\nNote: **backup adequado e de confiança** \n\nAs demonstrações a seguir são exemplos de como criptografar uma partição com um sistema de arquivos não encriptado anteriormente, como também sobre como re-criptografar um dispositivo LUKS já existente.\n\n"
    },
    {
      "title": "Criptografando um sistema de arquivos preexistente não encriptado",
      "level": 4,
      "content": "Note: Em resumo, crie uma partição com um tamanho de pelo menos 260MiB, se necessário. Veja como em Particionamento#/boot.\n\n- Se /boot estiver localizado dentro de uma partição root criptografada, o sistema pedirá a senha duas vezes quando a máquina for ligada. A primeira vez acontecerá quando o gerenciador de boot tentar ler os arquivos dentro da partição criptografada /boot. A segunda vez é quando o kernel tentar montar a partição criptografada [4]. Provavelmente este não é o comportamento que você deseja e o mesmo pode ser evitado ao separar a partição boot e não criptografá-la.\n- Alguns aplicativos de restauração de sistema (por exemplo, timeshift) não irão funcionar se /boot estiver dentro de uma partição criptografada [5].\n\nEm resumo, crie uma partição com um tamanho de pelo menos 260MiB, se necessário. Veja como em Particionamento#/boot.\n\nUm cabeçalho do LUKS sempre é armazenado no início do dispositivo. Já que usualmente um sistema de arquivos preexistente usa todos os setores da partição, o primeiro passo é diminuir o espaço alocado para o cabeçalho do LUKS.\n\nO cabeçalho padrão do LUKS2 precisa de 16MiB. Se o sistema de arquivos atual ocupa todo o espaço disponível, nós teremos que diminuí-lo para ao menos este tamanho. Para diminuir um sistema de arquivos ext4 preexistente em /dev/sdaxY para o atual menor espaço possível:\n\n```\n# umount /mnt\n```\n\n```\n# e2fsck -f /dev/sdxY\n```\n\n```\ne2fsck 1.46.5 (30-Dec-2021)\nPass 1: Checking inodes, blocks, and sizes\n...\n/dev/sda6: 12/166320 files (0.0% non-contiguous), 28783/665062 blocks\n```\n\n```\n# resize2fs -p -M /dev/sdxY\n```\n\n```\nresize2fs 1.46.5 (30-Dec-2021)\nResizing the filesystem on /dev/sdaxY to 26347 (4k) blocks.\nThe filesystem on /dev/sdaX is now 26347 (4k) blocks long.\n```\n\nAgora vamos criptografá-la. Ao usar a cifra padrão não há necessidade de especificá-la:\n\n```\n# cryptsetup reencrypt --encrypt --reduce-device-size 32M /dev/sdxY\n```\n\n```\nWARNING!\n========\nThis will overwrite data on LUKS2-temp-12345678-9012-3456-7890-123456789012.new irrevocably.\n\nAre you sure? (Type 'yes' in capital letters): YES\nEnter passphrase for LUKS2-temp-12345678-9012-3456-7890-123456789012.new:\nVerify passphrase:\n```\n\nO aviso traduzido seria:\n\n```\nATENÇÃO!\n========\nIsto irá sobrescrever os dados em LUKS2-temp-12345678-9012-3456-7890-123456789012.new irrevogavelmente.\n\nTem certeza? (Digite 'yes' em letras maiúsculas): YES\nDigite a passphrase para LUKS2-temp-12345678-9012-3456-7890-123456789012.new:\nVerifique a passphrase:\n```\n\nDepois que acabar, toda a partição /dev/sdxY estará criptografada, não somente o espaço que o sistema de arquivos foi diminuído. Para finalizar, estenda o sistema de arquivos original ext4 para ocupar todo o espaço disponível novamente, do qual agora reside a partição criptografa:\n\n```\n# cryptsetup open /dev/sdxY recrypt\n```\n\n```\nEnter passphrase for /dev/sdxY:\n...\n```\n\n```\n# resize2fs /dev/mapper/recrypt\n```\n\n```\nresize2fs 1.43-WIP (18-May-2015)\nResizing the filesystem on /dev/mapper/recrypt to 664807 (4k) blocks.\nThe filesystem on /dev/mapper/recrypt is now 664807 (4k) blocks long.\n```\n\n```\n# mount /dev/mapper/recrypt /mnt\n```\n\nO sistema de arquivos agora está pronto para uso. Você talvez possa querer agora adicioná-lo no seu crypttab.\n\n1. Configure mkinitcpio e os parâmetros de kernel. Veja na página em inglês dm-crypt/System configuration#Unlocking in early userspace.\n1. Atualizar a entrada de / em fstab para o uso do especificador de volume do dispositivo destravado (por exemplo, UUID).\n\n"
    },
    {
      "title": "Re-criptografando uma partição LUKS preexistente",
      "level": 4,
      "content": "Neste exemplo um dispositivo LUKS que já existe é criptografado novamente.\n\nPara encriptar novamente um dispositivo juntamente com as opções de encriptação utilizadas atualmente, tais opções não precisam ser especificadas:\n\n```\n# cryptsetup reencrypt /dev/sdxY\n```\n\nChaves existentes permanecem ao re-criptografar um dispositivo com uma outra cifra e/ou hash diferente.\n\nOutro caso de uso para a re-criptografia seria para aqueles dispositivos LUKS que não possuem as atuais opções de encriptação. Nestes casos, você deve especificar as novas opções desejadas. Note que um cabeçalho LUKS2 permite encriptação por espaço de chave individual, portanto a re-criptografia será aplicada apenas para o segmento do dado.\n\nA habilidade de mudar o cabeçalho do LUKS talvez seja limitada pelo tamanho. Por exemplo, se o dispositivo era inicialmente criptografado com LUKS1 usando o modo CBC de cifra e 128 bit de tamanho de chave, o cabeçalho do LUKS será metade do tamanho dos já mencionados 4096 setores:\n\n```\n# cryptsetup luksDump /dev/sdxY | grep -e \"mode\" -e \"Payload\" -e \"MK bits\"\n```\n\n```\nCipher mode:   \tcbc-essiv:sha256\nPayload offset:\t2048\nMK bits:       \t128\n```\n\nPara atualizar as opções de encriptação de tal dispositivo, considere primeiramente converter o cabeçalho para LUKS2 e só assim re-criptografar. Se a conversão falhar por conta de um tamanho de cabeçalho inadequado, você provavelmente precisará criptografar novamente com a opção --reduce-device-size, da qual disponibilizará mais espaço para o cabeçalho maior. Porém, este processo deve ser feito antes de re-criptografar com as novas opções de encriptação almejadas. Da mesma forma, mantenha em mente que ambos os métodos possuem riscos, que são inerentes de seus processos: tanto para o cabeçalho durante a conversão, quanto para os dados do sistema de arquivos se os mesmos estiverem em uso e você precisar liberar espaço.\n\n"
    },
    {
      "title": "Convertendo de LUKS1 para LUKS2 e revertendo",
      "level": 3,
      "content": "A ferramenta do cryptsetup possui a ação convert para conversão de cabeçalhos no formato LUKS1 e LUKS2. É aconselhável criar um backup do cabeçalho antes de fazer a conversão. Neste processo o argumento --type é um requerimento.\n\nMigração do LUKS1 para LUKS2:\n\n```\n# crytpsetup convert --type luks2 /dev/sdxY\n```\n\nPara retroceder ao LUKS1 (por exemplo, para inicializar o sistema pelo GRUB com criptografia em /boot):\n\n```\n# cryptsetup convert --type luks1  /dev/sdxY\n```\n\nNote: **não é** De forma traduzida:\n\n```\nCannot convert to LUKS1 format - keyslot 0 is not LUKS1 compatible.\n```\n\nDe forma traduzida:\n\n```\nNão é possível converter para o formato LUKS1 - espaço de chave 0 não é compatível com LUKS1.\n```\n\nSe o container estiver usando Argon2, então é preciso converter para PBKDF2, de forma que seja compatível com LUKS1.\n\n```\n# cryptsetup luksConvertKey --pbkdf2 /dev/sdxY\n```\n\n"
    },
    {
      "title": "Redimensionando os dispositivos criptografados",
      "level": 2,
      "content": "Note: **This article or section needs expansion.** This article or section needs expansion.\n\nThis article or section needs expansion.\n\nSe um dispositivo de armazenamento criptografado com dm-crypt está sendo clonado (com uma ferramenta como o dd) para outro dispositivo maior, ou se a partição estiver sendo expandida ou encolhida, o sistema de arquivos subjacente precisará ser redimensionado. Para dispositivos baseados em LUKS, este é o único passao necessário, pois LUKS não armazena nenhuma informação sobre o tamanho da partição e usa o tamanho total como padrão, ou seja, quando nenhum parâmetro --size é passado. Para este fim, siga os passos habituais necessários na página em inglês: resize a partition. Um exemplo para o dispositivo LUKS criptografado /dev/sdX2 que contém um sistema de arquivos ext4 que precisa ser expandido seria:\n\nPrimeiramente, redimensione a partição subjacente com Parted ou fdisk. Um detalhe importante: ao encolher uma partição, isto precisa ser feito por último. Agora, abra o seu dispositivo e redimensione o sistema de arquivos:\n\n```\n# cryptsetup luksOpen /dev/sdX2 sdX2\n# e2fsck /dev/mapper/sdX2\n# resize2fs /dev/mapper/sdX2  # Usa todo o espaço disponível da partição LUKS alargada.\n```\n\nDepois de montar o dispositivo LUKS mapeado que aumentou de tamanho, ele pode ser usado da mesma forma como antes.\n\n```\n# mount /dev/mapper/sdX2 /mnt/sdX2_expandido\n```\n\n"
    },
    {
      "title": "LVM em LUKS",
      "level": 3,
      "content": "Veja a página em inglês: Resizing LVM on LUKS.\n\n"
    },
    {
      "title": "Sistema de arquivos de loopback",
      "level": 3,
      "content": "Assuma que um sistema de arquivos de loopback criptografado está no arquivo grande_segredo, ligado ao /dev/loop0, mapeado como segredo e montado em /mnt/segredo, como no exemplo presente em dm-crypt/Criptografando um sistema de arquivos não raiz#Dispositivo de loop.\n\nSe o container está mapeado e/ou montado, o desmonte e/ou feche:\n\n```\n# umount /mnt/segredo\n# cryptsetup close segredo\n# losetup -d /dev/loop0\n```\n\nDepois, expanda o arquivo do container com o tamanho dos dados que você deseja adicionar. Neste exemplo, o arquivo será expandido em 1MiB × 1024, que é 1GiB.\n\n```\n# dd if=/dev/urandom of=/grande_segredo bs=1M count=1024 iflag=fullblock oflag=append conv=notrunc status=progress\n```\n\nAgora mapeie o container para o dispositivo de loop:\n\n```\n# losetup /dev/loop0 grande_segredo\n# cryptsetup open /dev/loop0 segredo\n```\n\nDepois disso, redimensione a parte criptografada do container para o novo tamanho máximo do arquivo container:\n\n```\n# cryptsetup resize segredo\n```\n\nFinalmente, cheque o sistema de arquivos e, se está ok, o redimensione (exemplo para ext2/3/4):\n\n```\n# e2fsck -f /dev/mapper/segredo\n# resize2fs /dev/mapper/segredo\n```\n\nÉ possível, então, montar o container novamente:\n\n```\n# mount /dev/mapper/segredo /mnt/segredo\n```\n\n"
    },
    {
      "title": "Dispositivo com integridade protegida",
      "level": 3,
      "content": "Se o dispositivo foi formatado com suporte a integridade (por exemplo, --integrity hmac-sha256) e o dispositivo de bloco não volátil foi encolhido, então ele não poderá ser aberto. O resultado é o seguinte erro: device-mapper: reload ioctl on failed: Invalid argument, ou de forma traduzida: mapeador-dispositivos: recarregar ioctl falhou: Argumento inválido.\n\nPara consertar esse problema sem ter que limpar os dados do dispositivo novamente, ele pode ser formatado com a chave mestre criada anteriormente (mantendo assim as tags por setor válidas).\n\n```\n# cryptsetup luksDump /dev/sdX2 --dump-master-key --master-key-file=/tmp/chave-mestre-em-tmpfs.key\n# cryptsetup luksFormat /dev/sdX2 --type luks2 --integrity hmac-sha256 --master-key-file=/tmp/chave-mestre-em-tmpfs.key --integrity-no-wipe\n# rm /tmp/chave-mestre-em-tmpfs.key\n```\n\n"
    },
    {
      "title": "Arquivos-chave/keyfiles",
      "level": 2,
      "content": "O que é um arquivo-chave/keyfile?\n\nUm arquivo-chave, também denominado como \"keyfile\", é um arquivo cujo os dados são usados como senha para abrir um volume criptografado. Significa que se tal arquivo é perdido ou modificado, destrancar e abrir o volume pode não ser mais possível.\n\nPor que usar um arquivo-chave/keyfile?\n\nExistem muitos tipos de keyfiles. Cada tipo possui suas vantagens e desvantagens, dos quais estão resumidos abaixo:\n\n"
    },
    {
      "title": "Texto simples (passphrase)",
      "level": 4,
      "content": "Este é um arquivo-chave que contém uma senha em texto simples, também denominado como \"passphrase\". O benefício deste tipo de arquivo-chave é que se caso o arquivo for perdido, o dado contido nele é conhecido e foi facilmente memorizado pelo proprietário do volume criptografado. Todavia, isto não trás nenhuma segurança extra ao digitar e confirmar a senha durante o começo da inicialização do sistema.\n\nExemplo:\n\ncorrect horse battery staple\n\nTambém poderia ser:\n\ncorreto cavalo bateria grampo\n\nNote: Se o arquivo contém caracteres especiais, como aspas ou barras invertidas, ao invés de espaçar estes caracteres, é recomendado simplesmente editar o arquivo-chave, digitando diretamente ou copiando e colando a senha, e então remover a quebra de linha com um comando útil em perl de uma linha:\n\n```\n# printf '%s' 'sua_senha' | install -m 0600 /dev/stdin /etc/cryptsetup-keys.d/arquivo-chave.key\n```\n\nSe o arquivo contém caracteres especiais, como aspas ou barras invertidas, ao invés de espaçar estes caracteres, é recomendado simplesmente editar o arquivo-chave, digitando diretamente ou copiando e colando a senha, e então remover a quebra de linha com um comando útil em perl de uma linha:\n\n```\n# perl -pi -e 'chomp if eof' /etc/cryptsetup-keys.d/arquivo-chave.key\n```\n\n"
    },
    {
      "title": "Caracteres aleatórios",
      "level": 4,
      "content": "Este tipo de keyfile contém um bloco de texto randômico. O benefício deste tipo de arquivo-chave é que é muito mais resistente a ataques de dicionário do que uma senha em texto simples. Um ponto forte a considerar em situações em que há a possibilidade de usá-la, é o comprimento de dado criado. Por não ser uma string feita para ser memorizada por uma pessoa como senha, é algo trivial criar arquivos contendo milhares de caractetes aleatórios como uma chave. A desvantagem é que se este arquivo é perdido ou modificado, muito provavelmente o acesso ao volume criptografado será igualmente perdido, se caso também não houver uma senha de backup.\n\nUm arquivo-chave com texto randômico pode usar qualquer tipo de conjunto de caracteres, porém manter a portabilidade para letras em ASCII e em números pode facilitar as coisas; como em ocasiões que o layout do teclado ou o suporte para Unicode é precário, como ao digitar uma senha de emergência no estágio de destravamento na inicialização do LUKS, ou ao mensurar arquivos-chaves com utilitários de POSIX antigos com Unicode primitivo. Nestes casos, você pode gerar uma string desta forma:\n\n```\n$ tr -dc [:alnum:]' </dev/urandom | head -c64\n```\n\nExemplo: rTCBW6j1dI2aYC5KcD6Ar38rBGN2DkWyang3RT7pdMGpdf1kRuMXi8EBHKu0BJ8X\n\nAlternativamente, um arquivo-chave de caracteres aleatórios em Unicode (UTF-8) pode se aparentar de tal maneira:\n\nExemplo: W[�5ODó?Oéµ»9��� ¬hjT}­�DÐ§íŽ�uLÝæ�Ýœ�§aþ�óx±)Ñ)l­éeð��ú=èe\n\n"
    },
    {
      "title": "Binário",
      "level": 4,
      "content": "É um arquivo binário que foi definido como keyfile. Quando identificar candidatos para uma keyfile, é recomendado que escolha fotos relativamente estáticas como fotos, músicas, vídeos. A vantagem, esses arquivos tem outras funções que dificultam a sua identificação como keyfile. Ao invês de ter um arquivo de texto com uma grande quantidade de texto randômico, a keyfile vai ser considerada como um arquivo de mídia normal. A desvantagem, se o arquivo for perdido ou mudado, provavelmente não será mais possível acessar o volume criptografado sem outra chave. Adicionalmente, existe teoricamente uma perda de aleatoriedade se comparado com um arquivo de texto randômico. Isto é devido ao fato que imagens, vídeos e músicas tem uma relação intríseca entre bits de dados vizinhos que não existe num texto randômico. No entanto isto é controverso e nunca foi publicamente explorado.\n\nExemplo: imagens, texto, video ...\n\n"
    },
    {
      "title": "Armazenando o arquivo-chave em um sistema de arquivos",
      "level": 4,
      "content": "Um arquivo-chave pode ser de conteúdo e tamanho arbitrários.\n\nAqui é utilizado o dd para gerar um arquivo-chave de 2048 bytes aleatórios, e então armazenando no arquivo /etc/cryptsetup-keys.d/minhakeyfile.key:\n\n```\n# dd bs=512 count=4 if=/dev/random iflag=fullblock | install -m 0600 /dev/stdin /etc/cryptsetup-keys.d/minha_keyfile.key\n```\n\nSe você planeja guardar a keyfile em um dispositivo externo, você pode simplesmente mudar o arquivo de saída para o diretório correspondente:\n\n```\n# dd bs=512 count=4 if=/dev/random of=/run/media/usuário/pendrive/minha_keyfile.key iflag=fullblock\n```\n\nSe você guardou a sua keyfile temporária em uma unidade de armazenamento e quer deletá-la, use algo parecido com isso:\n\n```\n# shred --remove --zero minha_keyfile\n```\n\nPara sobrescrever com segurança, em sistemas de arquivos arcaicos, como FAT ou ext2, isto deve bastar, considerando que são sistemas de arquivos com journaling (ou seja, sistemas de arquivos que rastreiam e registram os eventos antes mesmo de serem efetivados na parte principal de gravação). Ao usar hardware de memória em flash e em outros casos é recomendado apagar o dispositivo inteiro.\n\n"
    },
    {
      "title": "Armazenando o arquivo-chave no tmpfs (com swapping desativado)",
      "level": 4,
      "content": "Alternativamente, você pode montar um tmpfs com a função de swapping desativada para guardar a keyfile temporariamente:\n\n```\n# mount --mkdir -t tmpfs -o noswap tmpfs /root/meu_tmpfs\n# cd /root/meu_tmpfs\n```\n\nA vantagem é que ela reside na RAM e não em um disco físico, portanto o arquivo-chave não pode ser recuperado depois de desmontar o tmpfs. Depois de copiar a keyfile para outro sistema de arquivos seguro e persistente, desmonte o tmpfs novamente com:\n\n```\n# umount /root/meu_tmpfs\n```\n\n"
    },
    {
      "title": "Configurando o LUKS para utilizar o arquivo-chave",
      "level": 3,
      "content": "Adicione um espaço de chave (keyslot) para a keyfile no cabeçalho do LUKS:\n\n```\n# cryptsetup luksAddKey /dev/sda2 /etc/cryptsetup-keys.d/minha_keyfile.key\n```\n\n```\nEnter any existing passphrase:\n```\n\n"
    },
    {
      "title": "Manualmente abrindo uma partição com um arquivo-chave",
      "level": 3,
      "content": "Use a opção --key-file quando for abrir um dispositivo LUKS:\n\n```\n# cryptsetup open /dev/sda2 dm_nome --key-file /etc/cryptsetup-keys.d/minha_keyfile.key\n```\n\n"
    },
    {
      "title": "Com um aquivo-chave em um dispositivo externo",
      "level": 4,
      "content": "Você deve adicionar o módulo de kernel usado pelo sistema de arquivos junto com o conjunto de módulos em /etc/mkinitcpio.conf. Por exemplo, adicione ext4 se o sistema de arquivos for Ext4 ou vfat no caso de um em FAT:\n\n```\nMODULES=(vfat)\n```\n\nSe houver menssagens sobre um \"bad superblock\" e \"bad codepage\" na inicialização, é necessário então que o sistema carregue um módulo de codepage extra. Você talvez precise do módulo nls_iso8859-1 para a codepage iso8859-1.\n\nGere novamente o initramfs.\n\n- Para um initramfs baseado em busybox que usa o hook encrypt, veja dm-crypt/Configuração de Sistema#cryptkey.\n- Para um initramfs baseado em systemd que usa o hook sd-encrypt, veja dm-crypt/Configuração de Sistema#rd.luks.key.\n\n"
    },
    {
      "title": "Com um arquivo-chave embutido em initramfs",
      "level": 4,
      "content": "Note: **somente** \n\n- Alguma forma de autenticação prévia no processo de inicialização. De outro modo, o dispositivo vai ser aberto automaticamente, e com isso destruir totalmente o propósito da criptografia.\n- /boot é criptografado. De outro modo, a raiz de outra instalação (incluindo o ambiente live) pode extrair sua chave do initramfs, e descriptografar o dispositivo sem qualquer outro meio de autenticação.\n\nEste método permite o uso de um arquivo-chave escolhido especialmente para ser incorporado ao initramfs e pego pelo hook encrypt para abrir o sistema de arquivos raiz (cryptdevice) automaticamente. Pode ser útil ao usar o recurso de encriptação cryptodisk na inicialização do GRUB, e com isso evitar a digitação e confirmação de duas senhas durante a inicialização.\n\nGere um arquivo-chave, defina permissões apropriadas e a adicione como uma chave do LUKS:\n\n```\n# dd bs=512 count=4 if=/dev/random iflag=fullblock | install -m 0600 /dev/stdin /etc/cryptsetup-keys.d/root.key\n# cryptsetup luksAddKey /dev/sdX# /etc/cryptsetup-keys.d/root.key\n```\n\nInclua a chave no arranjo de arquivos do mkinitcpio:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nFILES=(/etc/cryptsetup-keys.d/root.key)\n```\n\nGere novamente o initramfs.\n\nPara o hook encrypt, o arquivo-chave é especificado com o parâmetro de kernel cryptkey=: no caso do initramfs, a sintaxe é rootfs:caminho/para/arquivo-chave. O nome padrão e caminho definido é: /crypto_keyfile.bin. É possível omitir cryptkey se o initramfs conter uma chave válida neste caminho. Veja dm-crypt/Configuração de Sistema#cryptkey.\n\nPara o exemplo acima, configure o seguinte parâmetro de kernel ao usar um initramfs baseado em busybox com o hook encrypt:\n\n```\n# cryptkey=rootfs:/etc/cryptsetup-keys.d/root.key\n```\n\nSe, caso o contrário, for usado o hook sd-encrypt, o arquivo-chave é especificado com o parâmetro de kernel rd.luks.key=: no caso do initramfs, a sintaxe é /caminho/para/arquivo-chave. O nome padrão e caminho definido é: /etc/cryptsetup-keys.d/nome.key (o nome é o mesmo que dm_nome, ou seja, o nome do dispositivo mapeado para descriptografar em #Criptografando dispositivos com o modo LUKS). É possível omitir rd.luks.key se o initramfs conter uma chave válida neste caminho. Veja dm-crypt/Configuração do sistema#rd.luks.key.\n\nNa próxima inicialização, você deverá somente precisar entrar com a senha de desencriptação do container uma vez.\n\n(fonte)\n\n"
    }
  ]
}