{
  "title": "Desktop entries (Español)",
  "url": "https://wiki.archlinux.org/title/Desktop_entries_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "La Especificación de entradas de escritorio de XDG define un estandar a las aplicaciones para integrarse en los menús de aplicaciones de los Entornos de escritorio que implementan la especificación de menús de escritorio de XDG.\n\n"
    },
    {
      "title": "Visión general",
      "level": 2,
      "content": "Cada entrada de escritorio debe tener las claves Type y Name Además de opcionalmente definir su apariencia en el menú de aplicaciones.\n\nHay 3 tipos de entradas de escritorio:\n\nLas siguientes secciones explicarán cómo las entradas de escritorio se suelen crear y validar.\n\n"
    },
    {
      "title": "Uso",
      "level": 2,
      "content": "Hay programas que soportan el manejo de archivos .desktop, por ejemplo dex:\n\n```\n$ dex /usr/share/applications/firefox.desktop\n```\n\nTable content:\nEntorno de escritorio | Lanzador(Paquete) | Autoarranque | Aplicación | Enlace\nCinnamon | gio(glib2) | No | Sí | No\nGNOME\nGNOME Flashback\nMATE\nDeepin | dde-open1(deepin-api) | Sí | Parcial | \nEnlightenment | enlightenment_open(enlightenment) |  |  | \nKDE Plasma | kde-open2(kde-cli-tools) | Sí | Sí | Sí\nLXDE | pcmanfm(pcmanfm) |  |  | \nLXQt | – |  |  | \nXfce | exo-open3(exo) |  |  | \nIndependiente | gtk-launch4(gtk3) | No | Parcial | No\ndex(dex) | Sí | Sí | No\nxdg-open(xdg-utils) | No | Inestable | No\n\n1. Los archivos .desktop de tipo Application necesitan tener declarado el bit ejecutable para poder se lanzador por dde-open\n1. Si KDE_SESSION_VERSION no está definido, entonces kfmclient de konqueror Se usará como reemplazo. (KDE Plasma deberíá definir esta variable de entorno en cualquier condición normal)\n1. Tambien se intentará usar gio (de glib2)\n1. Solo si las aplicaciones están en /usr/share/applications\n\n"
    },
    {
      "title": "Entradas de aplicación",
      "level": 2,
      "content": "Las entradas de escritorio para aplicaciones, o archivos .desktop, suelen ser una combinación de recursos de metainformación y un acceso directo a una aplicación. Estos archivos usualmente se encuentran en /usr/share/applications/ o /usr/local/share/applications/ para aplicaciones instaladas para todo el sistema, o ~/.local/share/applications/ para aplicaciones instaladas para un solo usuario. Las entradas del usuario toman prioridad por encima de las del sistema.\n\n"
    },
    {
      "title": "Ejemplo de un archivo",
      "level": 3,
      "content": "A continuación se mostrará un ejemplo de la estructura de una entrada de escritorio común con comentarios adicionales. Este ejemplo solo está destinado a dar una impresión rapida y no muestra como utilizar todas las claves disponibles. Una lista completa se puedew encontrar en la especificación de Freedesktop.\n\n```\n[Desktop Entry]\n\n# El tipo de archivo\nType=Application\n\n# La versión de la especificación de entradas de escritorio que este archivo utiliza\nVersion=1.0\n\n# El nombre de la aplicación\nName=jMemorize\n\n# Un comentario que puede/va a ser usado como descripción emergente\nComment=Flash card based learning tool\n\n# La ruta al directorio en el que la aplicación se ejecutará\nPath=/opt/jmemorise\n\n# El ejecutable de la aplicación con sus posibles argumentos\nExec=jmemorize\n\n# El nombre o ruta del icono que se va a mostrar\nIcon=jmemorize\n\n# Determina si la aplicación debe ser lanzada en un terminal\nTerminal=false\n\n# Determina las categorias en la que la aplicación debería mostrarse\nCategories=Education;Languages;Java;\n```\n\n"
    },
    {
      "title": "Definir claves",
      "level": 3,
      "content": "Todas las claves reconocidas se pueden encontrar en el sitio web de freedesktop. Por ejemplo, la clave Type determina tres tipos de entradas de escritorio: Application (type 1), Link (type 2) y Directory (type 3).\n\n- La clave Version no define la versión de la aplicación, si no que define la versión de la especificación de entradas de escritorio que sigue la entrada.\n\n- Name, GenericName y Comment suelen contener valores redundantes en forma de combinaciones de si mismos, por ejemplo:\n\n```\nName=Pidgin Internet Messenger\nGenericName=Internet Messenger\n```\n\no\n\n```\nName=NoteCase notes manager\nComment=Notes Manager\n```\n\nEsto debería evitarse, ya que solo puede ser confuso para los usuarios. la clave Name solo debería contener el nombre, o tal vez alguna abreviación/acronimo si es posible.\n\n- GenericName debería indicar el como se llamaría a una aplicación en base a lo que hace esta misma (por ejemplo, Firefox es un \"Navegador web\").\n\n- Comment pretende contener cualquier información adicional útil.\n\n"
    },
    {
      "title": "Validación",
      "level": 3,
      "content": "Debido a que algunas claves pueden volverse obsoletas con el tiempo, tal vez se deseé validar una entrada de escritorio usando desktop-file-validate(1), que es parte del paquete desktop-file-utils. Para validar, ejecute:\n\n```\n$ desktop-file-validate <ruta a su entrada de escritorio>\n```\n\nEste comando mostrará advertencias y errores de utilidad relacionados con el formato de la entrada.\n\n"
    },
    {
      "title": "Instalación",
      "level": 3,
      "content": "Se puede usar desktop-file-install(1) para instalar una entrada de escritorio en una ruta especifica. Por ejemplo:\n\n```\n$ desktop-file-install --dir=$HOME/.local/share/applications ~/app.desktop\n```\n\nEsto también es util para personalizar entradas de escritorio ya existentes (por ejemplo de /usr/share/applications) usando las opciones de edición.\n\n"
    },
    {
      "title": "Actualizar la base de datos de entradas de escritorio",
      "level": 3,
      "content": "Normalmente, los cambios de las entradas de escritorios son detectados automaticamente por los entornos de escritorio.\n\nSi no es ese el caso y por ejemplo, se desea forzar la base de datos de ~/.local/share/applications, ejecute el siguiente comando.\n\nIf this is not the case, and you want to forcefully update the desktop entries defined in ~/.local/share/applications, run the following command:\n\n```\n$ update-desktop-database ~/.local/share/applications\n```\n\n"
    },
    {
      "title": "iconos",
      "level": 2,
      "content": "Mire también la Especificación de temas de iconos.\n\n"
    },
    {
      "title": "Formatos de imágenes comunes",
      "level": 3,
      "content": "A continuación se muestra una breve ddescripción general de los formatos de imagenes comúnmente utilizados para los iconos.\n\nTable content:\nExtensión | Nombre completo y/o descripción | Tipo de gráficos | Formato del contenedor | Soporte\n.png | Gráficos de Red Portátiles | Ráster | No | Yes\n.svg(z) | Gráficos vectoriales escalables | Vector | No | Yes (optional)\n.xpm | PixMap de X | Ráster | No | Yes (deprecated)\n.gif | Formato de Intercambio de Gráficos | Ráster | No | No\n.ico | Formato de iconos de Microsoft Windows | Ráster | Yes | No\n.icns | Formato de iconos de Apple | Ráster | Yes | No\n\n"
    },
    {
      "title": "Convertir iconos",
      "level": 3,
      "content": "Si te encuentras con un icono que está en un formato que no es soportado por el estandar de freedesktop.org (como gif o ico), puedes usar la herramienta convert (que es parte del paquete imagemagick) para convertirla a un formato soportado/recomendado, por ejemplo:\n\n```\n$ convert <icon name>.gif <icon name>.png\n```\n\nsi conviertes una imágenes de un formato de contenedor como ico, conseguirás todas las imágenes encapsuladas dentro del archivo ico con el formato de nombre <nombre del icono>-<numero>.png. Si quieres conocer el tamaño de la imagen, o el numero de imágenes que tiene un contenedor como ico, Puedes usar la herramienta identify (también parte del paquete imagemagick):\n\n```\n$ identify /usr/share/vlc/vlc48x48.ico\n```\n\n```\n/usr/share/vlc/vlc48x48.ico[0] ICO 32x32 32x32+0+0 8-bit DirectClass 84.3kb\n/usr/share/vlc/vlc48x48.ico[1] ICO 16x16 16x16+0+0 8-bit DirectClass 84.3kb\n/usr/share/vlc/vlc48x48.ico[2] ICO 128x128 128x128+0+0 8-bit DirectClass 84.3kb\n/usr/share/vlc/vlc48x48.ico[3] ICO 48x48 48x48+0+0 8-bit DirectClass 84.3kb\n/usr/share/vlc/vlc48x48.ico[4] ICO 32x32 32x32+0+0 8-bit DirectClass 84.3kb\n/usr/share/vlc/vlc48x48.ico[5] ICO 16x16 16x16+0+0 8-bit DirectClass 84.3kb\n```\n\nComo se puede ver, el archivo ico de ejemplo, aunque su nombre puede sugerir una sola imagen de tamaño 48x48, esta contiene 6 imágenes en distintos tamaños, donde incluso una es incluso mas grande que 48x48 (siendo de 128x128).\n\nAlternativamente, es posible usaricotool (del paquete icoutils) para extraer imágenes png desde un contenedor ico:\n\n```\n$ icotool -x <icon name>.ico\n```\n\nPara extraer imagenes desde un contenedor .icns, es posible usar icns2png (del paquete libicns):\n\n```\n$ icns2png -x <icon name>.icns\n```\n\n"
    },
    {
      "title": "Obtener iconos",
      "level": 3,
      "content": "Aunque los paquetes que ya proveen un archivo .desktop también proveen un icono o un conjunto de iconos, hay algunas excepciones donde algún desarrollador no ha creado un archivo .desktop, sin embargo, puede tener algunos iconos. Un buen punto de partida es buscar iconos en el paquete fuente.\n\nPor ejemplo, es posible buscar archivos por extensión con el comando find, y después usar el comando grep para filtrar con alguna palabra, como el nombre del paquete, \"icon\", \"logo\", etc. esto en caso de que haya demasiadas imagenes en el paquete fuente.\n\n```\n$ find /path/to/source/package -regex \".*\\.\\(svg\\|png\\|xpm\\|gif\\|ico\\)$\"\n```\n\nSi los desarrolladores de una aplicación no incluyen iconos en sus paquetes fuente, el siguiente paso sería buscar en sus sitios web.\n\nAlgunos proyectos, por ejemplo tvbrowserAUR, tienen una pagina de arte/logotipos, donde se suelen encontrar iconos adicionales, Si el proyecto es multiplataforma, existe la posibilidad de que incluso si el paquete para Linux/Unix no contenga un icono, el paquete para Windows si contenga uno, Si el proyecto usa un Sistema de control de versiones como CVS/SVN/etc. y se tiene experiencia con ese sistema, se puede considerar buscar algún icono por ese medio.\n\nSi todas las acciones anteriores fallan, es probable que el proyecto simplemente no tenga algún logo/icono aún.\n\n"
    },
    {
      "title": "Ruta de los iconos",
      "level": 3,
      "content": "El estándar de freedesktop.org especifica en que orden y directorios los programas deberían buscar los iconos:\n\n1. $HOME/.icons (Por compatibilidad con versiones anteriores)\n1. $XDG_DATA_DIRS/icons\n1. /usr/share/pixmaps\n\n"
    },
    {
      "title": "Arronax",
      "level": 3,
      "content": "Arronax es un programa gráfico para crear y modificar entradas de escritorio para aplicaciones y ubicaciones. Instale el paquete arronaxAUR para usarlo.\n\n"
    },
    {
      "title": "Alacarte",
      "level": 3,
      "content": "alacarte es un editor gráfico de menú para GNOME usando la especificación de menú de freedesktop.org. También permite anular las entradas de escritorio.\n\n"
    },
    {
      "title": "jdDesktopEntryEdit",
      "level": 3,
      "content": "jddesktopentryeditAUR es un programa gráfico que usa Qt y permite editar entradas de escritorio.\n\n"
    },
    {
      "title": "MenuLibre",
      "level": 3,
      "content": "menulibreAUR Es un programa gráfico que usa GTK y ofrece características modernas en una interfaz limpia y fácil de usar.\n\n"
    },
    {
      "title": "gendesk",
      "level": 3,
      "content": "gendesk comenzó como una herramienta específica de Arch Linux para generar archivos .desktop obteniendo la información necesaria directamente de los archivos PKGBUILD. Ahora es una herramienta general que acepta argumentos de línea de comandos.\n\nLos iconos se pueden descargar automaticamente desde openiconlibrary, en caso de que estén disponibles. (La fuente de los iconos es configurable).\n\n"
    },
    {
      "title": "Como usarlo",
      "level": 4,
      "content": "- Añada gendesk a makedepends\n\n- Inicie la función prepare() con:\n\n```\ngendesk --pkgname \"$pkgname\" --pkgdesc \"$pkgdesc\"\n```\n\n- Alternativamente, si un icono ya está disponible ($pkgname.png, por ejemplo). El argumento -n sirve para no descargar ningún icono o usar un icono por defecto. Por ejemplo:\n\n```\ngendesk -n --pkgname \"$pkgname\" --pkgdesc \"$pkgdesc\"\n```\n\n- $srcdir/$pkgname.desktop será creado y puede ser instalado en la función package() con:\n\n```\ninstall -Dm644 \"$pkgname.desktop\" \"$pkgdir/usr/share/applications/$pkgname.desktop\"\n```\n\n- El icono puede ser instalado con:\n\n```\ninstall -Dm644 \"$pkgname.png\" \"$pkgdir/usr/share/pixmaps/$pkgname.png\"\n```\n\n- Use --name='Program Name' para elegir un nombre para la entrada del menú.\n\n- Use --exec='/opt/some_app/elf --some-arg --other-arg' para configurar el campo exec.\n\n- Revise la pagina del proyecto gendesk para mas información.\n\n"
    },
    {
      "title": "lsdesktopf",
      "level": 3,
      "content": "lsdesktopfAUR puede listar los archivos \".desktop\" disponibles o buscar su contenido.\n\n```\n$ lsdesktopf\n$ lsdesktopf --list\n$ lsdesktopf --list gtk zh_TW,zh_CN,en_GB\n```\n\nTambién puede realizar buscas relacionadas con los tipos MIME. Revise XDG MIME Applications#lsdesktopf\n\n"
    },
    {
      "title": "fbrokendesktop",
      "level": 3,
      "content": "El script fbrokendesktopAUR detecta claves Exec rotas, con valores que apuntan a rutas que no existen, si se ejecuta sin argumentos este utiliza directorios preestablecidos en la matriz DskPath. Solo muestra archivos .desktop rotos con la ruta completa y el nombre del archivo que falta.\n\nEjemplos:\n\n```\n$ fbrokendesktop\n$ fbrokendesktop /usr\n$ fbrokendesktop /usr/share/xsessions/icewm.desktop\n```\n\n"
    },
    {
      "title": "Modificar archivos de escritorio",
      "level": 3,
      "content": "Para archivos .desktop de todo el sistema (por ejemplo, los instalados desde un paquete), primero copie el archivo .desktop relevante (por ejemplo, de /usr/share/applications/) a $XDG_DATA_HOME/applications/ (por ejemplo, ~/.local/share/applications/). Esto evita que sus cambios se sobrescriban cuando el paquete se actualiza durante el actualizaciones del sistema.\n\nLos archivos locales .desktop específicos del usuario deberían tener prioridad automáticamente sobre los archivos de todo el sistema. Ahora puede modificar el archivo .desktop específico del usuario local según sea necesario.\n\nNote: Ahora, el archivo en su lanzador de aplicaciones permanecerá igual que el archivo que está en el autoarranque.\n\n- Mover el archivo de $XDG_CONFIG_HOME/autostart/ a $XDG_DATA_HOME/applications.\n- Usando ls -l, asegúrese de que esta entrada del escritorio sea un archivo normal que pueda editar y no un enlace a la ubicación del sistema. Si es un enlace, reemplácelo con una copia del original como se describe arriba.\n- Haga un enlace simbólico al directorio de la aplicación del usuario (los directorios XDG predeterminados se sustituyen por conveniencia):\n\n```\nln -s ~/.local/share/applications/desktop_entry ~/.config/autostart/\n```\n\nAhora, el archivo en su lanzador de aplicaciones permanecerá igual que el archivo que está en el autoarranque.\n\n"
    },
    {
      "title": "Modificar variables de entorno",
      "level": 4,
      "content": "para declarar una variable de entorno, en el archivo .desktop, edite la clave {ic|1=Exec=}} para usar el comando env(1) antes de ejecutar el comando objetivo. Por ejemplo, con la linea original comentada:\n\n```\n~/.local/share/applications/abiword.desktop\n```\n\n```\n...\n# Exec=abiword %U\nExec=env LANG=he_IL.UTF-8 abiword %U\n...\n```\n\nTambien remueva DBusActivatable=true (o declarelo como false), si está presente la clave Exec será ignorada.[1]\n\n"
    },
    {
      "title": "Modificar los argumentos de la linea de comandos",
      "level": 4,
      "content": "Para cambiar o agregar argumentos a la linea de comandos, edite la clave Exec= para agregar los argumentos deseados. Por ejemplo, con la linea original comentada:\n\n```\n~/.local/share/applications/steam.desktop\n```\n\n```\n...\n# Exec=/usr/bin/steam-runtime %U\nExec=/usr/bin/steam-runtime -no-browser %U\n...\n```\n\nTambien remueva DBusActivatable=true (o declarelo como false), si está presente la clave Exec será ignorada.[2]\n\n"
    },
    {
      "title": "Esconder entradas de escritorio",
      "level": 4,
      "content": "La visibilidad de la entrada de escritorio puede ser controlada de múltiples maneras. Revise la Especificación de entradas de escritorio para mas información.\n\nAñada una de las siguientes lineas a su archivo .desktop:\n\n- Todos los entornos de escritorio, escoja una (o ambas) de las siguientes formas: Añada la linea NoDisplay=true para las aplicaciones que no quiera que sean vistas en los menús de aplicaciones. Add the line Hidden=true para aplicaciones que considere borradas y no quiera mostrar en los menús de aplicaciones.\n\n- Añada la linea NoDisplay=true para las aplicaciones que no quiera que sean vistas en los menús de aplicaciones.\n- Add the line Hidden=true para aplicaciones que considere borradas y no quiera mostrar en los menús de aplicaciones.\n\n- Entorno de escritorio Especificado, escoja una de las siguientes opciones, donde desktop_names es una lista de entornos de escritorios delimitados por punto y coma (Por ejemplo. GNOME, GNOME;Xfce;KDE;): Añada la linea NotShowIn=desktop_names para esconder la entrada solo en los entornos de escritorio especificados. Añada la linea OnlyShowIn=desktop_names para mostrar la entrada solo en los entornos de escritorio especificados.\n\n- Añada la linea NotShowIn=desktop_names para esconder la entrada solo en los entornos de escritorio especificados.\n- Añada la linea OnlyShowIn=desktop_names para mostrar la entrada solo en los entornos de escritorio especificados.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- Wikipedia:es:Acceso directo#UNIX\n- Información para desarrolladores\n\n"
    }
  ]
}