{
  "title": "Zsh (Português)",
  "url": "https://wiki.archlinux.org/title/Zsh_(Portugu%C3%AAs)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Zsh é um shell poderoso que opera tanto como um shell interativo quanto como um interpretador de linguagem de script. Embora seja compatível com o POSIX sh (não por padrão, apenas se emitir emulate sh), ele oferece vantagens como a conclusão de comando (preenchimento por tabulação) e globbing aprimorados.\n\nO Zsh FAQ oferece mais motivos para usar o Zsh.\n\n"
    },
    {
      "title": "Instalação",
      "level": 2,
      "content": "Antes de começar, os usuários podem querer ver qual shell está sendo usado no momento:\n\n```\n$ echo $SHELL\n```\n\nInstale o pacote zsh. Para complementar com definições de preenchimento automático de comandos, instale também o pacote zsh-completions.\n\n"
    },
    {
      "title": "Configuração inicial",
      "level": 3,
      "content": "Certifique-se de que o Zsh foi instalado corretamente executando o comando a seguir em um terminal:\n\n```\n$ zsh\n```\n\nAgora você deverá ver o zsh-newuser-install, que o guiará por algumas configurações básicas. Se quiser pular isso, pressione q. Se você não o viu, então você pode invocá-lo manualmente com:\n\n```\n$ autoload -Uz zsh-newuser-install\n$ zsh-newuser-install -f\n```\n\n"
    },
    {
      "title": "Tornando o Zsh seu shell padrão",
      "level": 3,
      "content": "Mude seu shell para /usr/bin/zsh. Veja Shell - linha de comando#Alterando seu shell padrão.\n\n"
    },
    {
      "title": "Arquivos de inicialização/desligamento",
      "level": 2,
      "content": "- Se $ZDOTDIR não estiver definida, $HOME será usada.\n- Se a opção RCS não estiver definida em nenhum dos arquivos, nenhum arquivo de configuração será lido depois desse arquivo.\n- Se a opção GLOBAL_RCS não estiver definida em nenhum dos arquivos, nenhum arquivo de configuração global (/etc/zsh/*) será lido depois desse arquivo.\n\nAo iniciar, o Zsh lerá os comandos dos seguintes arquivos respectivamente nesta ordem por padrão, considerando que os mesmos existam.\n\n- /etc/zsh/zshenv Usado para definir variáveis de ambiente para todos os usuários. Não deve conter comandos que produzem saídas ou assumem que o shell está anexado a um TTY; quando esse arquivo existir, ele sempre será lido, isto não pode ser modificado ou anulado.\n\n- $ZDOTDIR/.zshenv Usado para definir variáveis ​​de ambiente do usuário. Não deve conter comandos que produzam saída ou assumam que o shell está anexado a um TTY; quando esse arquivo existir, ele sempre será lido.\n\n- /etc/zsh/zprofile Usado para executar comandos na inicialização para todos os usuários, será lido ao iniciar como um shell de login. Observe que no Arch Linux, por padrão, ele contém uma linha da qual condiciona (pelo comando source) o funcionamento do shell a partir do arquivo /etc/profile. Veja o aviso abaixo antes de querer remover isso!\n\n- /etc/profile Este arquivo deverá fornecer as condições (como uma fonte direta das definições, ou seja, pelo source) e as mesmas serão incluídas por todos os shells compatíveis com POSIX shell desde o login: em outras palavras, ele define o $PATH, as outras variáveis de ambiente e as configurações de aplicação específica (/etc/profile.d/*.sh) desde o login.\n\n- /etc/profile Este arquivo deverá fornecer as condições (como uma fonte direta das definições, ou seja, pelo source) e as mesmas serão incluídas por todos os shells compatíveis com POSIX shell desde o login: em outras palavras, ele define o $PATH, as outras variáveis de ambiente e as configurações de aplicação específica (/etc/profile.d/*.sh) desde o login.\n\n- $ZDOTDIR/.zprofile Usado para executar comandos do usuário na inicialização, será lido ao iniciar como um shell de login. Normalmente usado para iniciar automaticamente sessões gráficas e para definir variáveis de ambiente para toda a sessão.\n\n- /etc/zsh/zshrc Usado para definir a configuração do shell interativo do usuário e executar comandos, será lido ao iniciar como um shell interativo.\n\n- $ZDOTDIR/.zshrc Usado para definir a configuração do shell interativo do usuário e executar comandos, será lido ao iniciar como um shell interativo.\n\n- /etc/zsh/zlogin Usado para executar comandos para todos os usuários ao final do progresso inicial, será lido ao iniciar como um shell de login.\n- $ZDOTDIR/.zlogin Usado para executar comandos do usuário no final do progresso inicial, será lido ao iniciar como um shell de login. Normalmente usado para iniciar automaticamente utilitários de linha de comando. Não deve ser usado para iniciar automaticamente sessões gráficas, pois neste ponto a sessão pode conter configuração destinada apenas a um shell interativo.\n\n- $ZDOTDIR/.zlogout Usado para executar comandos quando um shell de login sai.\n\n- /etc/zsh/zlogout Usado para executar comandos para todos os usuários quando um shell de login sai.\n\nVeja a representação gráfica.\n\nNote: **não é originado** \n\n"
    },
    {
      "title": "Configurar Zsh",
      "level": 2,
      "content": "Embora que o Zsh seja plenamente usável desde a instalação, ou como se diria em inglês, out of the box, é quase certo que ele não é pré-configurado da maneira que a maioria dos usuários gostaria de usá-lo; porém, devido à grande quantidade de personalização disponível no Zsh, configurá-lo pode ser uma experiência intimidadora e demorada. Para uma configuração automática, veja sobre as #Extensões de terceiros.\n\n"
    },
    {
      "title": "Simples .zshrc",
      "level": 3,
      "content": "Abaixo está incluído um arquivo de configuração de exemplo. Ele fornece um conjunto decente de opções padrão, bem como dá exemplos de muitas maneiras pelas quais o Zsh pode ser personalizado. Para usar esta configuração, salve-a como um arquivo chamado .zshrc.\n\nAqui está um simples .zshrc:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz compinit promptinit\ncompinit\npromptinit\n\n# Isso definirá o prompt padrão para o tema \nwalters prompt walters\n```\n\nVeja #Temas de prompt para mais detalhes sobre o sistema de temas de prompt.\n\n"
    },
    {
      "title": "Configurando $PATH",
      "level": 3,
      "content": "O Zsh vincula a variável PATH ao vetor path. Isso permite que você manipule PATH simplesmente modificando o vetor path. Veja A User's Guide to the Z-Shell para detalhes.\n\nAdicione ~/.local/bin/ ao PATH:\n\n```\n~/.zshenv\n```\n\n```\ntypeset -U path PATH\npath=(~/.local/bin $path)\nexport PATH\n```\n\n"
    },
    {
      "title": "Conclusão de comando",
      "level": 3,
      "content": "Talvez o recurso mais atraente do Zsh sejam suas habilidades avançadas de autocompletar. No mínimo, habilite o autocompletar em .zshrc. Para habilitar o autocompletar, adicione o seguinte ao seu ~/.zshrc:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz compinit\ncompinit\n```\n\nA configuração acima inclui a conclusão de nomes de host ssh/scp/sftp, mas para que esse recurso funcione, os usuários não devem habilitar o hash de nome de host do ssh (por exemplo, a opção HashKnownHosts na configuração do cliente ssh).\n\nPara preenchimento automático com uma interface acionada por teclas de seta, adicione o seguinte a:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion:*' menu select\n```\n\nPara ativar o menu, pressione Tab Tab duas vezes.\n\nPara habilitar o preenchimento automático de ambientes privilegiados em comandos privilegiados (por exemplo, se você concluir um comando começando com sudo, os scripts de conclusão também tentarão determinar suas conclusões com sudo), inclua:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion::complete:*' gain-privileges 1\n```\n\n"
    },
    {
      "title": "Conclusão personalizada",
      "level": 4,
      "content": "Você pode escrever complementações personalizadas por conta própria. Se fizer isso, você pode consultar a página man zshcompsys(1).\n\nNote que a documentação oficial pode ser difícil de ler. Você pode considerar tentar o tutorial mais simples zsh-completion-howto para um começo fácil.\n\n"
    },
    {
      "title": "Atalhos de teclado",
      "level": 3,
      "content": "O Zsh não usa readline, em vez disso, ele usa seu próprio e mais poderoso Zsh Line Editor (ZLE). Ele não lê /etc/inputrc ou ~/.inputrc. Leia A closer look at the zsh line editor and creating custom widgets para uma introdução à configuração do ZLE.\n\nO ZLE tem um modo Emacs e um modo vi. Se uma das variáveis de ambiente VISUAL ou EDITOR então o modo vi será usado; caso contrário, ele será o modo Emacs por padrão. Defina o modo explicitamente com bindkey -e ou bindkey -v respectivamente para o modo Emacs ou modo vi. O atraso de pressionar a tecla Esc no modo vi é de 0,4s por padrão, e você pode torná-lo mais curto (0,05s) com export KEYTIMEOUT=5.\n\nAs associações de teclas são atribuídas mapeando uma sequência de escape que corresponde a um pressionamento de tecla para um widget ZLE. Os widgets disponíveis, com descrições de suas ações e suas associações de teclas padrão, estão listados em zshzle(1) § STANDARD WIDGETS e zshcontrib(1) § ZLE FUNCTIONS.\n\nA maneira recomendada de definir associações de teclas no Zsh é usando recursos de string do terminfo(5). Por exemplo [1][2]:\n\n```\n~/.zshrc\n```\n\n```\n# create a zkbd compatible hash;\n# to add other keys to this hash, see: man 5 terminfo\ntypeset -g -A key\n\nkey[Home]=\"${terminfo[khome]}\"\nkey[End]=\"${terminfo[kend]}\"\nkey[Insert]=\"${terminfo[kich1]}\"\nkey[Backspace]=\"${terminfo[kbs]}\"\nkey[Delete]=\"${terminfo[kdch1]}\"\nkey[Up]=\"${terminfo[kcuu1]}\"\nkey[Down]=\"${terminfo[kcud1]}\"\nkey[Left]=\"${terminfo[kcub1]}\"\nkey[Right]=\"${terminfo[kcuf1]}\"\nkey[PageUp]=\"${terminfo[kpp]}\"\nkey[PageDown]=\"${terminfo[knp]}\"\nkey[Shift-Tab]=\"${terminfo[kcbt]}\"\n\n# setup key accordingly\n[[ -n \"${key[Home]}\"      ]] && bindkey -- \"${key[Home]}\"       beginning-of-line\n[[ -n \"${key[End]}\"       ]] && bindkey -- \"${key[End]}\"        end-of-line\n[[ -n \"${key[Insert]}\"    ]] && bindkey -- \"${key[Insert]}\"     overwrite-mode\n[[ -n \"${key[Backspace]}\" ]] && bindkey -- \"${key[Backspace]}\"  backward-delete-char\n[[ -n \"${key[Delete]}\"    ]] && bindkey -- \"${key[Delete]}\"     delete-char\n[[ -n \"${key[Up]}\"        ]] && bindkey -- \"${key[Up]}\"         up-line-or-history\n[[ -n \"${key[Down]}\"      ]] && bindkey -- \"${key[Down]}\"       down-line-or-history\n[[ -n \"${key[Left]}\"      ]] && bindkey -- \"${key[Left]}\"       backward-char\n[[ -n \"${key[Right]}\"     ]] && bindkey -- \"${key[Right]}\"      forward-char\n[[ -n \"${key[PageUp]}\"    ]] && bindkey -- \"${key[PageUp]}\"     beginning-of-buffer-or-history\n[[ -n \"${key[PageDown]}\"  ]] && bindkey -- \"${key[PageDown]}\"   end-of-buffer-or-history\n[[ -n \"${key[Shift-Tab]}\" ]] && bindkey -- \"${key[Shift-Tab]}\"  reverse-menu-complete\n\n# Finally, make sure the terminal is in application mode, when zle is\n# active. Only then are the values from $terminfo valid.\nif (( ${+terminfo[smkx]} && ${+terminfo[rmkx]} )); then\n\tautoload -Uz add-zle-hook-widget\n\tfunction zle_application_mode_start { echoti smkx }\n\tfunction zle_application_mode_stop { echoti rmkx }\n\tadd-zle-hook-widget -Uz zle-line-init zle_application_mode_start\n\tadd-zle-hook-widget -Uz zle-line-finish zle_application_mode_stop\nfi\n```\n\n"
    },
    {
      "title": "Pesquisa de histórico",
      "level": 4,
      "content": "Você precisa configurar o conjunto de key e certificar-se de que o ZLE entre no modo de aplicativo para usar as seguintes instruções; veja #Atalhos de teclado.\n\nPara habilitar a pesquisa de histórico, adicione estas linhas ao arquivo .zshrc :\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz up-line-or-beginning-search down-line-or-beginning-search\nzle -N up-line-or-beginning-search\nzle -N down-line-or-beginning-search\n\n[[ -n \"${key[Up]}\"   ]] && bindkey -- \"${key[Up]}\"   up-line-or-beginning-search\n[[ -n \"${key[Down]}\" ]] && bindkey -- \"${key[Down]}\" down-line-or-beginning-search\n```\n\nAo fazer isso, somente os comandos anteriores que correspondem à linha atual até a posição atual do cursor serão exibidos quando as teclas Up ou Down forem pressionadas.\n\n"
    },
    {
      "title": "Modificadores Shift, Alt, Ctrl and Meta",
      "level": 4,
      "content": "Terminais compatíveis com xterm podem usar definições de teclas estendidas de user_caps(5). Essas são combinações de Shift, Alt, Ctrl e Meta junto com Up, Down, Left, Right, PageUp, PageDown, Home, End ou Del. Consulte zkbd source para obter uma lista de nomes recomendados para as teclas modificadoras e combinações de teclas.\n\nPor exemplo, Ctrl+Left para mover para o início da palavra anterior e Ctrl+Right para mover para o início da próxima palavra:\n\n```\n~/.zshrc\n```\n\n```\nkey[Control-Left]=\"${terminfo[kLFT5]}\"\nkey[Control-Right]=\"${terminfo[kRIT5]}\"\n\n[[ -n \"${key[Control-Left]}\"  ]] && bindkey -- \"${key[Control-Left]}\"  backward-word\n[[ -n \"${key[Control-Right]}\" ]] && bindkey -- \"${key[Control-Right]}\" forward-word\n```\n\n"
    },
    {
      "title": "Prompts",
      "level": 3,
      "content": "O Zsh oferece a opção de usar um tema de prompt ou, para usuários que não estão satisfeitos com os temas (ou querem expandir sua utilidade), a possibilidade de criar um prompt personalizado.\n\n"
    },
    {
      "title": "Temas de prompt",
      "level": 4,
      "content": "Os temas de prompt são uma maneira rápida e fácil de configurar um prompt colorido no Zsh. Veja zshcontrib(1) § PROMPT THEMES para obter informações sobre temas de prompt e como escrever seu próprio tema.\n\nPara usar um tema, certifique-se de que o prompt theme system esteja definido para autoload em .zshrc. Isso pode ser feito adicionando estas linhas a:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz promptinit\npromptinit\n```\n\nOs temas de prompt disponíveis são listados executando o comando:\n\n```\n$ prompt -l\n```\n\nPor exemplo, para usar o tema walters, digite:\n\n```\n$ prompt walters\n```\n\nPara visualizar todos os temas disponíveis, use este comando:\n\n```\n$ prompt -p\n```\n\nÉ possível instalar temas manualmente, sem ferramentas de gerenciador de configuração externas. Para uma instalação local, primeiro crie uma pasta e adicione-a ao array fpath, por exemplo:\n\n```\n$ mkdir ~/.zprompts\n$ fpath=(\"$HOME/.zprompts\" \"$fpath[@]\")\n```\n\nAgora crie um link simbólico do seu arquivo de tema nesta pasta:\n\n```\n$ ln -s mytheme.zsh ~/.zprompts/prompt_mytheme_setup\n```\n\nSe, em vez disso, você deseja instalar um tema globalmente, faça:\n\n```\n# ln -s mytheme.zsh /usr/share/zsh/functions/Prompts/prompt_mytheme_setup\n```\n\nAgora você deve conseguir ativá-lo usando:\n\n```\n$ prompt mytheme\n```\n\nSe tudo funcionar, você pode editar seu .zshrc adequadamente.\n\nAlém de adicionar um tema de prompt por meio de seu próprio arquivo, é possível adicionar temas de dentro de outro arquivo (como seu .zshrc), por exemplo:\n\n```\n~/.zshrc\n```\n\n```\n# Load promptinit\nautoload -Uz promptinit && promptinit\n\n# Define the theme\nprompt_mytheme_setup() {\n  PS1=\"%~%# \"\n}\n\n# Add the theme to promptsys\nprompt_themes+=( mytheme )\n\n# Load the theme\nprompt mytheme\n```\n\n"
    },
    {
      "title": "Prompt personalizado",
      "level": 4,
      "content": "Além de um prompt primário do lado esquerdo PS1 (PROMPT, prompt) que é comum a todos os shells, o Zsh também suporta um prompt do lado direito RPS1 (RPROMPT). Essas duas variáveis são as que você vai querer definir para um valor personalizado.\n\nOutros prompts de propósito especial, como PS2 (PROMPT2), PS3 (PROMPT3), PS4 (PROMPT4), RPS1 (RPROMPT), RPS2 (RPROMPT2) e SPROMPT, são explicados em zshparam(1) § PARAMETERS USED BY THE SHELL.\n\nTodos os prompts podem ser personalizados com escapes de prompt. Os escapes de prompt disponíveis estão listados em zshmisc(1) § EXPANSION OF PROMPT SEQUENCES.\n\nO Zsh define as cores de forma diferente do Bash; Você não precisa usar sequências de escape ANSI profusas ou recursos de terminal do terminfo(5). O Zsh fornece escapes de prompt convenientes para definir a cor de primeiro plano, cor de fundo e outros efeitos visuais; veja zshmisc(1) § Visual effects para uma lista deles e suas descrições.\n\nAs cores podem ser especificadas usando um inteiro decimal, o nome de uma das oito cores mais amplamente suportadas ou como um # seguido por um trio RGB em formato hexadecimal. Veja a descrição de fg=colour em zshzle(1) § CHARACTER HIGHLIGHTING para mais detalhes.\n\nA maioria dos terminais suporta as seguintes cores por nome:\n\nTable content:\nName | Number\npreta | 0\nvermelha | 1\nverde | 2\namarela | 3\nazul | 4\nmagenta | 5\nciano | 6\nbranca | 7\n\nOs números de cores 0–255 para emuladores de terminal compatíveis com xterm 256 cores podem ser encontrados no xterm-256color chart.\n\nCom uma variável de ambiente TERM definida corretamente, o número máximo de cores suportado pelo terminal pode ser encontrado no banco de dados terminfo(5) usando echoti colors. No caso de cores de 24-bit, verifique também a variável de ambiente COLORTERM com print $COLORTERM. Se retornar 24bit ou truecolor seu terminal suporta 16777216 (224) cores, mesmo que terminfo mostre um número menor.\n\n- As cores 0-15 podem diferir entre emuladores de terminal e seus esquemas de cores usados.\n- Muitos emuladores de terminal exibem negrito com uma cor mais brilhante.\n\n- Escapes de prompt podem ser testados com o comando print -P \"prompt escapes\", por exemplo: $ print -P '%B%F{red}co%F{green}lo%F{blue}rs%f%b'\n- Se você usar cores de 24 bits, talvez queira carregar o módulo zsh/nearcolor em terminais que não as suportam. Por exemplo: [[ \"$COLORTERM\" == (24bit|truecolor) || \"${terminfo[colors]}\" -eq '16777216' ]] || zmodload zsh/nearcolor Veja zshmodules(1) § THE ZSH/NEARCOLOR MODULE para detalhes sobreo módulo zsh/nearcolor.\n\n```\n$ print -P '%B%F{red}co%F{green}lo%F{blue}rs%f%b'\n```\n\n```\n[[ \"$COLORTERM\" == (24bit|truecolor) || \"${terminfo[colors]}\" -eq '16777216' ]] || zmodload zsh/nearcolor\n```\n\nUm exemplo de um prompt simples e incolor:\n\n```\nPROMPT='%n@%m %~ %# '\n```\n\nComo será exibido:\n\nEste é um exemplo de um prompt de dois lados com cor:\n\n```\nPROMPT='%F{green}%n%f@%F{magenta}%m%f %F{blue}%B%~%b%f %# '\nRPROMPT='[%F{yellow}%?%f]'\n```\n\nE aqui está como será exibido:\n\nPara usar cores da faixa de 16 a 255 e cores verdadeiras de 24 bits, você pode usar o número de 0 a 255 atribuído à cor desejada e seu código de cor hexadecimal, respectivamente:\n\n```\nPROMPT='%F{2}%n%f@%F{5}%m%f %F{4}%B%~%b%f %# '\nRPROMPT='[%F{3}%?%f]'\n```\n\n```\nPROMPT='%F{#c0c0c0}%n%f@%F{#008000}%m%f %F{#800080}%B%~%b%f %# '\nRPROMPT='[%F{#0000ff}%?%f]'\n```\n\n"
    },
    {
      "title": "Arquivos de exemplo .zshrc",
      "level": 3,
      "content": "- Para obter a mesma configuração dos lançamentos mensais de ISO (que usam Zsh por padrão), instale grml-zsh-config. Ele inclui muitos ajustes e otimizações avançadas do grml.\n- https://github.com/MrElendig/dotfiles-alice/blob/master/.zshrc - configuração básica, com prompt dinâmico e título da janela/hardinfo.\n- https://github.com/slashbeast/conf-mgmt/blob/master/roles/home_files/files/DOTzshrc - zshrc com vários recursos, certifique-se de verificar os comentários nele. Recursos notáveis: função de confirmação para garantir que o usuário deseja executar poweroff, reboot ou hibernate, suporte para GIT em prompt (feito sem vcsinfo), conclusão de tabulação com menu, impressão do comando executado atualmente na barra de título da janela e mais.\n\nVeja dotfiles (Português)#Repositórios de usuários para mais informações.\n\n"
    },
    {
      "title": "Inicialização automática do X no login",
      "level": 3,
      "content": "Veja xinit#Inicializar automaticamente o X no login.\n\n"
    },
    {
      "title": "Restaurar as configurações do terminal após um programa sair de forma anormal",
      "level": 3,
      "content": "Muitos programas alteram o estado do terminal e, muitas vezes, não restauram as configurações do terminal ao sair de forma anormal (por exemplo, ao travar ou encontrar SIGINT).\n\nIsso normalmente pode ser resolvido executando reset(1):\n\n```\n$ reset\n```\n\nAs seções a seguir descrevem maneiras de evitar a necessidade de redefinir manualmente o terminal.\n\n"
    },
    {
      "title": "O comando ttyctl",
      "level": 4,
      "content": "O comando ttyctl pode ser usado para \"congelar/descongelar\" o terminal. Para congelar o shell interativo na inicialização, use o seguinte:\n\n```\n~/.zshrc\n```\n\n```\nttyctl -f\n```\n\n"
    },
    {
      "title": "Redefinindo o terminal com sequências de escape",
      "level": 4,
      "content": "Alternate linedrawing character set pode bagunçar o terminal de uma forma que o ttyctl não consegue evitar.\n\nUma solução simples é emitir as sequências de escape que reiniciam o terminal da função hook precmd, para que sejam executadas sempre antes que o prompt seja desenhado. Por exemplo, usando a sequência de escape \\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[0;0r\\e8:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nfunction reset_broken_terminal () {\n\tprintf '%b' '\\e[0m\\e(B\\e)0\\017\\e[?5l\\e7\\e[0;0r\\e8'\n}\n\nadd-zsh-hook -Uz precmd reset_broken_terminal\n```\n\n27 / 5.000 Para testar se funciona, execute:\n\n```\n$ print '\\e(0\\e)B'\n```\n\n"
    },
    {
      "title": "Dirstack",
      "level": 4,
      "content": "O Zsh pode ser configurado para lembrar os últimos diretórios visitados do DIRSTACKSIZE. Isso pode ser usado para cd eles muito rapidamente. Você precisa adicionar algumas linhas ao seu arquivo de configuração:\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nDIRSTACKFILE=\"${XDG_CACHE_HOME:-$HOME/.cache}/zsh/dirs\"\nif [[ -f \"$DIRSTACKFILE\" ]] && (( ${#dirstack} == 0 )); then\n\tdirstack=(\"${(@f)\"$(< \"$DIRSTACKFILE\")\"}\")\n\t[[ -d \"${dirstack[1]}\" ]] && cd -- \"${dirstack[1]}\"\nfi\nchpwd_dirstack() {\n\tprint -l -- \"$PWD\" \"${(u)dirstack[@]}\" > \"$DIRSTACKFILE\"\n}\nadd-zsh-hook -Uz chpwd chpwd_dirstack\n\nDIRSTACKSIZE='20'\n\nsetopt AUTO_PUSHD PUSHD_SILENT PUSHD_TO_HOME\n\n## Remove duplicate entries\nsetopt PUSHD_IGNORE_DUPS\n\n## This reverts the +/- operators.\nsetopt PUSHD_MINUS\n```\n\nAgora use\n\n```\n$ dirs -v\n```\n\npara imprimir o dirstack. Use cd -<NUM> para voltar para uma pasta visitada. Use autocompletar depois do hífen. Isso é muito útil se estiver usando o menu de autocompletar.\n\n"
    },
    {
      "title": "cdr",
      "level": 4,
      "content": "cdr permite que você altere o diretório de trabalho para um diretório de trabalho anterior de uma lista mantida automaticamente. Ele armazena todas as entradas em arquivos que são mantidos entre sessões e (por padrão) entre emuladores de terminal na sessão atual.\n\nVeja zshcontrib(1) § REMEMBERING RECENT DIRECTORIES para instruções de configuração.\n\n"
    },
    {
      "title": "zoxide",
      "level": 4,
      "content": "zoxide é um comando cd mais inteligente que permite que você navegue em qualquer lugar com apenas algumas teclas. Ele lembra seus diretórios usados com frequência e usa um mecanismo de pontuação para adivinhar onde você quer ir.\n\n"
    },
    {
      "title": "Comando Help",
      "level": 3,
      "content": "Ao contrário do Bash, o Zsh não habilita um comando help embutido, em vez disso, ele fornece run-help. Por padrão run-help é um alias para man, ele pode ser executado manualmente adicionando-o a um comando ou pode ser invocado para o comando digitado atualmente com os atalhos de teclado Alt+h ou Esc h.\n\nComo por padrão é apenas um alias para man, ele só funcionará em comandos externos. Para melhorar sua funcionalidade, para que funcione em builtins de shell e outros recursos de shell, você precisa usar a função run-help. Veja zshcontrib(1) para mais informações sobre o run-help e suas funções de assistente.\n\nPrimeiro carregue a função run-help e então remova o alias run-help existente. Por conveniência, help pode ser aliasado \"apelidado\" para run-help. Por exemplo, adicione o seguinte ao seu zshrc:\n\n```\nautoload -Uz run-help\n(( ${+aliases[run-help]} )) && unalias run-help\nalias help=run-help\n```\n\nAs funções do assistente devem ser habilitadas separadamente:\n\n```\nautoload -Uz run-help-git run-help-ip run-help-openssl run-help-p4 run-help-sudo run-help-svk run-help-svn\n```\n\nPor exemplo, o comando run-help git commit agora abrirá a página de manual git-commit(1) em vez de git(1).\n\n"
    },
    {
      "title": "Rehash persistente",
      "level": 3,
      "content": "Normalmente, o compinit não encontrará automaticamente novos executáveis ​​no $PATH. Por exemplo, após instalar um novo pacote, os arquivos em /usr/bin/ não seriam incluídos imediatamente ou automaticamente na conclusão. Assim, para ter esses novos executáveis ​​incluídos, executaria:\n\n```\n$ rehash\n```\n\nThis 'rehash' can be set to happen automatically.[3] Simply include the following in your zshrc:\n\n```\n~/.zshrc\n```\n\n```\nzstyle ':completion:*' rehash true\n```\n\n"
    },
    {
      "title": "Rehash sob demanda",
      "level": 4,
      "content": "Como acima, no entanto, o pacman pode ser configurado com hooks para solicitar automaticamente um rehash, o que não incorre na penalidade de desempenho do rehashing constante como acima. Para habilitar isso, crie o diretório /etc/pacman.d/hooks e um diretório /var/cache/zsh, então crie um arquivo de hook:\n\n```\n/etc/pacman.d/hooks/zsh.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nOperation = Remove\nType = Path\nTarget = usr/bin/*\n[Action]\nDepends = zsh\nWhen = PostTransaction\nExec = /usr/bin/install -Dm644 /dev/null /var/cache/zsh/pacman\n```\n\nIsso mantém a data de modificação do arquivo /var/cache/zsh/pacman consistente com a última vez que um pacote foi instalado, atualizado ou removido. Então, zsh deve ser persuadido a refazer o hash de seu próprio cache de comando quando ele ficar desatualizado, adicionando ao seu ~/.zshrc:\n\n```\n~/.zshrc\n```\n\n```\nzshcache_time=\"$(date +%s%N)\"\n\nautoload -Uz add-zsh-hook\n\nrehash_precmd() {\n  if [[ -a /var/cache/zsh/pacman ]]; then\n    local paccache_time=\"$(date -r /var/cache/zsh/pacman +%s%N)\"\n    if (( zshcache_time < paccache_time )); then\n      rehash\n      zshcache_time=\"$paccache_time\"\n    fi\n  fi\n}\n\nadd-zsh-hook -Uz precmd rehash_precmd\n```\n\nSe o hook precmd for acionado antes de /var/cache/zsh/pacman ser atualizado, a conclusão pode não funcionar até que um novo prompt seja iniciado. Executar um comando vazio, por exemplo, pressionar enter, deve ser suficiente.\n\n"
    },
    {
      "title": "Rehash alternativo sob demanda usando SIGUSR1",
      "level": 4,
      "content": "Como acima, porém o arquivo hook se parece com isto:\n\n```\n/etc/pacman.d/hooks/zsh-rehash.hook\n```\n\n```\n[Trigger]\nOperation = Install\nOperation = Upgrade\nOperation = Remove\nType = Path\nTarget = usr/bin/*\n\n[Action]\nDepends = zsh\nDepends = procps-ng\nWhen = PostTransaction\nExec = /usr/bin/pkill zsh --signal=USR1\n```\n\n```\n~/.zshrc\n```\n\n```\nTRAPUSR1() { rehash }\n```\n\nA função trap acima pode ser substituída por uma lista trap trap 'rehash' USR1. Veja zshmisc(1) § Funções Trap para diferenças entre tipos de traps.\n\nEste método irá instantaneamente rehash todas as instâncias zsh, eliminando a necessidade de pressionar enter para acionar precmd.\n\n"
    },
    {
      "title": "Vincular tecla ao aplicativo ncurses",
      "level": 3,
      "content": "Vincule um aplicativo ncurses a um pressionamento de tecla, mas ele não aceitará interação. Use a variável BUFFER para fazê-lo funcionar. O exemplo a seguir permite que os usuários abram ncmpcpp usando Alt+\\:\n\n```\n~/.zshrc\n```\n\n```\nncmpcppShow() {\n  BUFFER=\"ncmpcpp\"\n  zle accept-line\n}\nzle -N ncmpcppShow\nbindkey '^[\\' ncmpcppShow\n```\n\nUm método alternativo, que manterá tudo o que você inseriu na linha antes de chamar o aplicativo:\n\n```\n~/.zshrc\n```\n\n```\nncmpcppShow() {\n  ncmpcpp <$TTY\n  zle redisplay\n}\nzle -N ncmpcppShow\nbindkey '^[\\' ncmpcppShow\n```\n\n"
    },
    {
      "title": "Atalhos de teclado do gerenciador de arquivos",
      "level": 3,
      "content": "Atalhos de teclado como os usados ​​em gerenciadores de arquivos gráficos podem ser úteis. O primeiro retorna ao histórico do diretório (Alt+Left), o segundo permite que o usuário vá para o diretório pai (Alt+Up). Eles também exibem o conteúdo do diretório.\n\n```\n~/.zshrc\n```\n\n```\ncdUndoKey() {\n  popd\n  zle       reset-prompt\n  print\n  ls\n  zle       reset-prompt\n}\n\ncdParentKey() {\n  pushd ..\n  zle      reset-prompt\n  print\n  ls\n  zle       reset-prompt\n}\n\nzle -N                 cdParentKey\nzle -N                 cdUndoKey\nbindkey '^[[1;3A'      cdParentKey\nbindkey '^[[1;3D'      cdUndoKey\n```\n\n"
    },
    {
      "title": "Título do xterm",
      "level": 3,
      "content": "Se o seu emulador de terminal suportar, você pode definir seu título a partir do Zsh. Isso permite alterar dinamicamente o título para exibir informações relevantes sobre o estado do shell, por exemplo, mostrando o nome do usuário e o diretório atual ou o comando em execução no momento.\n\nO título xterm é definido com o xterm control sequence operating system command \\e]2;\\a ou \\e]2;\\e\\\\. Por exemplo:\n\n```\n$ print -n '\\e]2;Meu título xterm\\a'\n```\n\nirá definir o título para\n\n```\nMeu título xterm\n```\n\nUma maneira simples de ter um título dinâmico é definir o título nas funções hook precmd e preexec. Veja zshmisc(1) § Hook Functions para uma lista de funções hook disponíveis e suas descrições.\n\nAo usar print -P, você também pode aproveitar os escapes de prompt do Zsh.\n\n- A impressão de títulos pode ser dividida em vários comandos, desde que sejam sequenciais.\n- GNU Screen envia o título xterm para o hardstatus (%h). Se você quiser usar os escapes de string do Screen (por exemplo, para cores), você deve definir o hardstatus com a sequência de escape \\e_\\e\\\\. Caso contrário, se escapes de string forem usados ​​em \\e]2;\\a, o emulador de terminal obterá um título ilegível devido à incapacidade de interpretar os escapes de string do Screen.\n\n- Não use a opção -P de print ao imprimir variáveis ​​para evitar que elas sejam analisadas como escapes de prompt.\n- Use o q parameter expansion flag ao imprimir variáveis para evitar que elas sejam analisadas como sequências de escape.\n\n```\n~/.zshrc\n```\n\n```\nautoload -Uz add-zsh-hook\n\nfunction xterm_title_precmd () {\n\tprint -Pn -- '\\e]2;%n@%m %~\\a'\n\t[[ \"$TERM\" == 'screen'* ]] && print -Pn -- '\\e_\\005{2}%n\\005{-}@\\005{5}%m\\005{-} \\005{+b 4}%~\\005{-}\\e\\\\'\n}\n\nfunction xterm_title_preexec () {\n\tprint -Pn -- '\\e]2;%n@%m %~ %# ' && print -n -- \"${(q)1}\\a\"\n\t[[ \"$TERM\" == 'screen'* ]] && { print -Pn -- '\\e_\\005{2}%n\\005{-}@\\005{5}%m\\005{-} \\005{+b 4}%~\\005{-} %# ' && print -n -- \"${(q)1}\\e\\\\\"; }\n}\n\nif [[ \"$TERM\" == (Eterm*|alacritty*|aterm*|foot*|gnome*|konsole*|kterm*|putty*|rxvt*|screen*|wezterm*|tmux*|xterm*) ]]; then\n\tadd-zsh-hook -Uz precmd xterm_title_precmd\n\tadd-zsh-hook -Uz preexec xterm_title_preexec\nfi\n```\n\n"
    },
    {
      "title": "Título da aba do emulador de terminal",
      "level": 4,
      "content": "Alguns emuladores de terminal e multiplexadores suportam a configuração do título da aba. As sequências de escape dependem do terminal:\n\nTable content:\nTerminal | Escape sequences | Description\nGNU Screen | \\ek\\e\\\\ | Título da janela do Screen (%t).\nKonsole | \\e]30;\\a | Título da aba do Konsole.\n\n"
    },
    {
      "title": "Detecção de ambiente de shell",
      "level": 3,
      "content": "Veja a repository about shell environment detection para testes para detectar o ambiente shell. Isso inclui login/shell interativo, sessão Xorg, sessão TTY e SSH.\n\n"
    },
    {
      "title": "/dev/tcp equivalente: ztcp",
      "level": 3,
      "content": "Use o módulo zsh/net/tcp:\n\n```\n$ zmodload zsh/net/tcp\n```\n\nAgora você pode estabelecer conexões TCP:\n\n```\n$ ztcp example.com 80\n```\n\nMais detalhes estão disponíveis em zshmodules(1) § THE_ZSH/NET/TCP_MODULE e zshtcpsys(1).\n\n"
    },
    {
      "title": "Atalho para sair do shell na linha de comando parcial",
      "level": 3,
      "content": "Por padrão, Ctrl+d não fechará seu shell se a linha de comando estiver preenchida. Isso corrige o problema:\n\n```\n.zshrc\n```\n\n```\nexit_zsh() { exit }\nzle -N exit_zsh\nbindkey '^D' exit_zsh\n```\n\n"
    },
    {
      "title": "Manipulador pacman -F \"command not found\"",
      "level": 3,
      "content": "pacman inclui funcionalidade para procurar por pacotes contendo um arquivo. O seguinte manipulador command-not-found usará pacman diretamente para procurar por pacotes correspondentes quando um comando desconhecido for executado.\n\n```\n~/.zshrc\n```\n\n```\n...\nfunction command_not_found_handler {\n    local purple='\\e[1;35m' bright='\\e[0;1m' green='\\e[1;32m' reset='\\e[0m'\n    printf 'zsh: command not found: %s\\n' \"$1\"\n    local entries=(\n        ${(f)\"$(/usr/bin/pacman -F --machinereadable -- \"/usr/bin/$1\")\"}\n    )\n    if (( ${#entries[@]} ))\n    then\n        printf \"${bright}$1${reset} may be found in the following packages:\\n\"\n        local pkg\n        for entry in \"${entries[@]}\"\n        do\n            # (repo package version file)\n            local fields=(\n                ${(0)entry}\n            )\n            if [[ \"$pkg\" != \"${fields[2]}\" ]]\n            then\n                printf \"${purple}%s/${bright}%s ${green}%s${reset}\\n\" \"${fields[1]}\" \"${fields[2]}\" \"${fields[3]}\"\n            fi\n            printf '    /%s\\n' \"${fields[4]}\"\n            pkg=\"${fields[2]}\"\n        done\n    fi\n    return 127\n}\n...\n```\n\nPara uma alternativa usando pkgfile, veja #Manipulador pacman -F \"command not found\".\n\n"
    },
    {
      "title": "Limpe o backbuffer usando uma combinação de teclas",
      "level": 3,
      "content": "Por padrão, a tecla de atalho clear screen não limpará o backbuffer (a parte que você precisa rolar para cima para vê-lo) na maioria dos emuladores de terminal. Uma possível solução para esse problema é a seguinte.\n\n```\n~/.zshrc\n```\n\n```\n...\nfunction clear-screen-and-scrollback() {\n    printf '\\x1Bc'\n    zle clear-screen\n}\n\nzle -N clear-screen-and-scrollback\nbindkey '^L' clear-screen-and-scrollback\n...\n```\n\n"
    },
    {
      "title": "Frameworks de configuração",
      "level": 3,
      "content": "- oh-my-posh — Oh My Posh é um mecanismo de prompt personalizado para qualquer shell que tenha a capacidade de ajustar a sequência de prompts com uma função ou variável.\n\n- oh-my-zsh — Um framework popular, conduzido pela comunidade, para gerenciar sua configuração Zsh. Ele vem com uma tonelada de funções úteis, auxiliares, plugins, temas.\n\n- Prezto — Um framework de configuração para Zsh. Ela vem com módulos, enriquecendo o ambiente de interface de linha de comando com padrões sensatos, aliases, funções, preenchimento automático e temas de prompt.\n\n- ZIM — Um framework de configuração com velocidade incrível e extensões modulares. O Zim é muito fácil de personalizar e vem com um rico conjunto de módulos e recursos sem comprometer a velocidade ou a funcionalidade.\n\n"
    },
    {
      "title": "Gerenciadores de plugins",
      "level": 3,
      "content": "- Antidote — Um recurso de implementação completa do Zsh do gerenciador de plugins Antibody legado.\n\n- zinit (previously \"zplugin\") — Gerenciador de plugins Zsh flexível com fpath limpo, relatórios, gerenciamento de conclusão, modo turbo REVIVED\n\n- zi (previously \"zplugin\") — Fork alternativo do zplugin com o objetivo de expandir o projeto original, em vez de preservação e manutenção do projeto original como o zinit.\n\n- sheldon — Gerenciador de plugins de shell rápido e configurável, escrito em Rust [4]\n\n- Antigen — Um gerenciador de plugins para Zsh, inspirado em oh-my-zsh e vundle. ABANDONED\n\n- zgen — Um gerenciador de plugins leve e simples para Zsh. ABANDONED\n\n- zplug — Um gerenciador de plugins de última geração para Zsh. ABANDONED\n\n"
    },
    {
      "title": "Realce de sintaxe e sugestões automáticas semelhantes às do Fish",
      "level": 3,
      "content": "Fish fornece realce de sintaxe de shell e autosuggestions muito poderosos. Para usar ambos no Zsh, você pode instalar zsh-syntax-highlighting, zsh-autosuggestions e, finalmente, source um ou ambos os scripts fornecidos do seu zshrc:\n\n```\n~/.zshrc\n```\n\n```\nsource /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\nsource /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh\n```\n\n"
    },
    {
      "title": "Manipulador pkgfile \"command not found\"",
      "level": 3,
      "content": "pkgfile inclui um arquivo de script Zsh que fornece uma função command_not_found_handler que pesquisará automaticamente o banco de dados pkgfile ao inserir um comando não reconhecido.\n\nVocê precisa source o script para habilitá-lo. Por exemplo:\n\n```\n~/.zshrc\n```\n\n```\nsource /usr/share/doc/pkgfile/command-not-found.zsh\n```\n\nPara uma alternativa usando a funcionalidade nativa do pacman, veja #Manipulador pacman -F \"command not found\".\n\n"
    },
    {
      "title": "See also",
      "level": 2,
      "content": "- Wikipedia:Zsh\n- Uma introdução ao Z Shell\n- Um guia do usuário para ZSH\n- Manual do Z Shell (formato diferente disponível aqui)\n- Zsh FAQ\n- zsh-lovers(1) (disponível como pacote zsh-lovers)\n- Gentoo: Zsh/Guide\n- Cartão de referência Bash2Zsh\n\n"
    }
  ]
}