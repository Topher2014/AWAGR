{
  "title": "Custom local repository (日本語)",
  "url": "https://wiki.archlinux.org/title/Custom_local_repository_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- ミラー\n- パッケージの作成\n\n以下のヒントや pacman 自体の柔軟性を広げる汎用的な手法については、Core Utilities や Bash を見てください。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 メンテナンス 1.1 パッケージをリストアップ 1.1.1 未使用のリポジトリで 1.1.2 バージョンも表示 1.1.3 サイズも表示 1.1.3.1 個々のパッケージ 1.1.3.2 パッケージと依存パッケージ 1.1.4 日付でソート 1.1.5 指定したグループ、リポジトリ、メタパッケージに含まれないパッケージ 1.1.6 開発版パッケージ 1.1.7 パッケージの依存パッケージ 1.1.8 任意の依存パッケージも表示 1.2 パッケージの閲覧 1.3 パッケージが所有しているファイルとそのサイズを一覧表示 1.4 どのパッケージにも所有されていないファイルを特定する 1.5 パッケージによって作成された未所有のファイルを追跡する 1.6 使用していないパッケージ (孤立したパッケージ) の削除 1.7 より多くの不要なパッケージを検出する 1.8 必須パッケージ以外の全てのパッケージを削除する 1.9 複数のパッケージの依存パッケージリストを取得 1.10 変更されたバックアップファイルをリストアップ 1.11 pacman データベースをバックアップ 1.12 変更履歴を簡単に確認\n- 2 インストールとリカバリ 2.1 パッケージを CD/DVD や USB スティックからインストールする 2.2 カスタムローカルリポジトリ 2.3 pacman のキャッシュをネットワークで共有する 2.3.1 読み取り専用キャッシュ 2.3.2 読み取り専用キャッシュのオーバーレイマウント 2.3.3 読み取り専用の分散キャッシュ 2.3.4 読み書き可能キャッシュ 2.3.5 rsync や FTP で双方向同期 2.3.6 nginx で動的リバースプロキシキャッシュ 2.3.7 Pacoloco プロキシキャッシュサーバー 2.3.8 Flexo プロキシキャッシュサーバー 2.3.9 同期プログラムを使用して pacman パッケージキャッシュを同期する 2.3.10 望まないキャッシュ削除を防ぐ 2.4 ファイルシステムからパッケージを再構成する 2.5 インストール済みパッケージのリスト 2.6 リストからパッケージをインストールする 2.7 パッケージの元の状態から変更された全てのファイルをリストアップ 2.8 全てのパッケージの再インストール 2.9 Pacman のローカルデータベースを復元する 2.10 既存のインストールから USB キーを復元する 2.11 .pkg ファイル内の特定のファイルの内容を見る 2.12 古いパッケージのライブラリを使っているアプリケーションを探す 2.13 必要な言語のコンテンツのみをインストールする 2.14 接続状況が悪い場合でもパッケージをインストールする\n- 3 パフォーマンス 3.1 ダウンロード速度 3.1.1 Powerpill 3.1.2 wget 3.1.3 aria2 3.1.4 他のアプリケーション\n- 4 ユーティリティ 4.1 グラフィカル\n\n- 1.1 パッケージをリストアップ 1.1.1 未使用のリポジトリで 1.1.2 バージョンも表示 1.1.3 サイズも表示 1.1.3.1 個々のパッケージ 1.1.3.2 パッケージと依存パッケージ 1.1.4 日付でソート 1.1.5 指定したグループ、リポジトリ、メタパッケージに含まれないパッケージ 1.1.6 開発版パッケージ 1.1.7 パッケージの依存パッケージ 1.1.8 任意の依存パッケージも表示\n- 1.2 パッケージの閲覧\n- 1.3 パッケージが所有しているファイルとそのサイズを一覧表示\n- 1.4 どのパッケージにも所有されていないファイルを特定する\n- 1.5 パッケージによって作成された未所有のファイルを追跡する\n- 1.6 使用していないパッケージ (孤立したパッケージ) の削除\n- 1.7 より多くの不要なパッケージを検出する\n- 1.8 必須パッケージ以外の全てのパッケージを削除する\n- 1.9 複数のパッケージの依存パッケージリストを取得\n- 1.10 変更されたバックアップファイルをリストアップ\n- 1.11 pacman データベースをバックアップ\n- 1.12 変更履歴を簡単に確認\n\n- 1.1.1 未使用のリポジトリで\n- 1.1.2 バージョンも表示\n- 1.1.3 サイズも表示 1.1.3.1 個々のパッケージ 1.1.3.2 パッケージと依存パッケージ\n- 1.1.4 日付でソート\n- 1.1.5 指定したグループ、リポジトリ、メタパッケージに含まれないパッケージ\n- 1.1.6 開発版パッケージ\n- 1.1.7 パッケージの依存パッケージ\n- 1.1.8 任意の依存パッケージも表示\n\n- 1.1.3.1 個々のパッケージ\n- 1.1.3.2 パッケージと依存パッケージ\n\n- 2.1 パッケージを CD/DVD や USB スティックからインストールする\n- 2.2 カスタムローカルリポジトリ\n- 2.3 pacman のキャッシュをネットワークで共有する 2.3.1 読み取り専用キャッシュ 2.3.2 読み取り専用キャッシュのオーバーレイマウント 2.3.3 読み取り専用の分散キャッシュ 2.3.4 読み書き可能キャッシュ 2.3.5 rsync や FTP で双方向同期 2.3.6 nginx で動的リバースプロキシキャッシュ 2.3.7 Pacoloco プロキシキャッシュサーバー 2.3.8 Flexo プロキシキャッシュサーバー 2.3.9 同期プログラムを使用して pacman パッケージキャッシュを同期する 2.3.10 望まないキャッシュ削除を防ぐ\n- 2.4 ファイルシステムからパッケージを再構成する\n- 2.5 インストール済みパッケージのリスト\n- 2.6 リストからパッケージをインストールする\n- 2.7 パッケージの元の状態から変更された全てのファイルをリストアップ\n- 2.8 全てのパッケージの再インストール\n- 2.9 Pacman のローカルデータベースを復元する\n- 2.10 既存のインストールから USB キーを復元する\n- 2.11 .pkg ファイル内の特定のファイルの内容を見る\n- 2.12 古いパッケージのライブラリを使っているアプリケーションを探す\n- 2.13 必要な言語のコンテンツのみをインストールする\n- 2.14 接続状況が悪い場合でもパッケージをインストールする\n\n- 2.3.1 読み取り専用キャッシュ\n- 2.3.2 読み取り専用キャッシュのオーバーレイマウント\n- 2.3.3 読み取り専用の分散キャッシュ\n- 2.3.4 読み書き可能キャッシュ\n- 2.3.5 rsync や FTP で双方向同期\n- 2.3.6 nginx で動的リバースプロキシキャッシュ\n- 2.3.7 Pacoloco プロキシキャッシュサーバー\n- 2.3.8 Flexo プロキシキャッシュサーバー\n- 2.3.9 同期プログラムを使用して pacman パッケージキャッシュを同期する\n- 2.3.10 望まないキャッシュ削除を防ぐ\n\n- 3.1 ダウンロード速度 3.1.1 Powerpill 3.1.2 wget 3.1.3 aria2 3.1.4 他のアプリケーション\n\n- 3.1.1 Powerpill\n- 3.1.2 wget\n- 3.1.3 aria2\n- 3.1.4 他のアプリケーション\n\n- 4.1 グラフィカル\n\n"
    },
    {
      "title": "メンテナンス",
      "level": 2,
      "content": "システムメンテナンスも参照。\n\n"
    },
    {
      "title": "未使用のリポジトリで",
      "level": 4,
      "content": "デフォルトでは、pacman.conf に載っているリポジトリが同期、検索、インストール、アップグレードに使用されます。しかし、リポジトリの使用用途は自由に変更できます。例えば、一部のリポジトリは検索のみに使用するには[1]:\n\n```\n/etc/pacman.conf\n```\n\n```\n...\n[multilib]\nUsage = Sync Search\n...\n```\n\npacman.conf(5) § REPOSITORY SECTIONS を参照。\n\n"
    },
    {
      "title": "バージョンも表示",
      "level": 4,
      "content": "バグを報告したりインストールしたパッケージについて説明するときは、インストール済みのパッケージとそのバージョンのリストを貼り付けると便利です。\n\n- 明示的にインストールしたパッケージを全てリストアップ: pacman -Qe\n- group パッケージグループに含まれるパッケージを全てリストアップ: pacman -Sg group\n- 外部パッケージを全てリストアップ (典型的には、手動でダウンロードしてインストールしたパッケージや、リポジトリから削除されたパッケージです): pacman -Qm\n- ネイティブなパッケージ (同期データベースからインストールしたパッケージ) をリストアップ: pacman -Qn\n- 依存パッケージでも任意の依存パッケージでもない、明示的にインストールしたネイティブパッケージ (同期データベースにあるパッケージ) をリストアップ: pacman -Qent\n- 正規表現にマッチするパッケージをリストアップ: pacman -Qs regex。\n- 正規表現にマッチするパッケージを、カスタムの出力フォーマットでリストアップ (expac が必要です): expac -s \"%-30n %v\" regex\n\n"
    },
    {
      "title": "サイズも表示",
      "level": 4,
      "content": "ハードドライブの容量を空けたい場合に、どのパッケージが最も大きいかを調べられると便利です。方法としては、個々のパッケージのサイズを調べる方法と、パッケージとその依存パッケージのサイズを調べる方法の2つがあります。\n\n次のコマンドは、インストール済みのパッケージをそのサイズとともに表示します:\n\n```\n$ LC_ALL=C.UTF-8 pacman -Qi | awk '/^Name/{name=$3} /^Installed Size/{print $4$5, name}' | LC_ALL=C.UTF-8 sort -h\n```\n\nパッケージのサイズを依存パッケージとともに表示する方法は2つあります:\n\n- expac をインストールして、次のように実行する: expac -H M '%m\\t%n' | sort -h\n- pacgraphAUR で -c オプションを使う。\n\n複数のパッケージのダウンロードサイズをリストアップするには (全パッケージをリストアップするには packages に何も入力しないでください):\n\n```\n$ expac -S -H M '%k\\t%n' packages\n```\n\nbase メタパッケージにも xorg パッケージグループにも属さない、明示的にインストールされたパッケージをサイズと説明とともにリストアップするには:\n\n```\n$ expac -H M \"%011m\\t%-20n\\t%10d\" $(comm -23 <(pacman -Qqen | sort) <({ pacman -Qqg xorg; expac -l '\\n' '%E' base; } | sort -u)) | sort -n\n```\n\nバージョンが古いくなっているパッケージをダウンロードサイズともに表示するには:\n\n```\n$ expac -S -H M '%k\\t%n' $(pacman -Qqu) | sort -sh\n```\n\n任意の依存パッケージのみを表示するには:\n\n```\n$ expac -S \"%o\" package\n```\n\n"
    },
    {
      "title": "日付でソート",
      "level": 4,
      "content": "最も最後にインストールされた20個のパッケージを expac でリストアップするには:\n\n```\n$ expac --timefmt='%Y-%m-%d %T' '%l\\t%n' | sort | tail -n 20\n```\n\nあるいは、エポック秒 (1970-01-01 UTC) を表示するには:\n\n```\n$ expac --timefmt=%s '%l\\t%n' | sort -n | tail -n 20\n```\n\n"
    },
    {
      "title": "指定したグループ、リポジトリ、メタパッケージに含まれないパッケージ",
      "level": 4,
      "content": "明示的にインストールしたパッケージの中で base メタパッケージに含まれないものを一覧表示するには:\n\n```\n$ comm -23 <(pacman -Qqe | sort) <(expac -l '\\n' '%E' base | sort)\n```\n\n明示的にインストールしたパッケージの中で base メタパッケージにも xorg パッケージグループにも含まれていないものを一覧表示するには:\n\n```\n$ comm -23 <(pacman -Qqe | sort) <({ pacman -Qqg xorg; expac -l '\\n' '%E' base; } | sort -u)\n```\n\nインストールしたパッケージの中で、他のどのパッケージからも必要とされておらず、かつ base メタパッケージにも xorg パッケージグループにも含まれていないものを一覧表示するには:\n\n```\n$ comm -23 <(pacman -Qqt | sort) <({ pacman -Qqg xorg; echo base; } | sort -u)\n```\n\n先と同じですが、説明も付けて一覧表示するには:\n\n```\n$ expac -H M '%-20n\\t%10d' $(comm -23 <(pacman -Qqt | sort) <({ pacman -Qqg xorg; echo base; } | sort -u))\n```\n\nインストールしたパッケージの中で、repo_name という名前のリポジトリに含まれていないものを一覧表示するには:\n\n```\n$ comm -23 <(pacman -Qq | sort) <(pacman -Sql repo_name | sort)\n```\n\nインストールしたパッケージの中で、repo_name という名前のリポジトリに含まれているものを一覧表示するには:\n\n```\n$ comm -12 <(pacman -Qq | sort) <(pacman -Sql repo_name | sort)\n```\n\nArch Linux ISO にインストールされているパッケージの中で、base メタパッケージに含まれていないものを一覧表示するには:\n\n```\n$ comm -23 <(curl https://gitlab.archlinux.org/archlinux/archiso/-/raw/master/configs/releng/packages.x86_64) <(expac -l '\\n' '%E' base | sort)\n```\n\n"
    },
    {
      "title": "開発版パッケージ",
      "level": 4,
      "content": "開発版や不安定版のパッケージを一覧表示するには:\n\n```\n$ pacman -Qq | grep -Ee '-(bzr|cvs|darcs|git|hg|svn)$'\n```\n\n"
    },
    {
      "title": "パッケージの依存パッケージ",
      "level": 4,
      "content": "あるパッケージの依存パッケージの一覧を入手したい場合、最も簡単な方法は以下のコマンドの出力を見ることです:\n\n```\n$ pacman -Qi package\n```\n\n自動化させるには、pacman の出力をパースするというエラーの発生しやすい方法を取るのではなく、expac を使ってください:\n\n```\n$ expac -S '%D' package\n```\n\n"
    },
    {
      "title": "任意の依存パッケージも表示",
      "level": 4,
      "content": "明示的にインストールしたパッケージを、その任意の依存パッケージも一緒に一覧表示するには:\n\n```\n$ LC_ALL=C.UTF-8 pacman -Qei | sed '/^[^NO ]/d;/None$/d' | awk 'BEGIN{RS=ORS=\"\\n\\n\";FS=OFS=\"\\n\\\\S\"} /Optional Deps/ {print $1\"\\nO\"$2}'\n```\n\nあるいは、expac を使って:\n\n```\n$ expac -d '\\n\\n' -l '\\n\\t' -Q '%n\\n\\t%O' $(pacman -Qeq)\n```\n\n先とほぼ同じですが、既にインストール済みの任意の依存パッケージを出力から除くには:\n\n```\n$ LC_ALL=C.UTF-8 pacman -Qei | sed '/^[^NO ]/d;/None$/d' | awk 'BEGIN{RS=ORS=\"\\n\\n\";FS=OFS=\"\\n\\\\S\"} /Optional Deps/ {print $1\"\\nO\"$2}' | sed 's/^Optional Deps   ://;/\\[installed\\]$/d;s/\\s\\+/ /'\n```\n\n"
    },
    {
      "title": "パッケージの閲覧",
      "level": 3,
      "content": "インストール済みのパッケージを、プレビューウィンドウを表示してブラウズするには:\n\n```\n$ pacman -Qq | fzf --preview 'pacman -Qil {}' --layout=reverse --bind 'enter:execute(pacman -Qil {} | less)'\n```\n\nこのコマンドは、パッケージの一覧を左のペインに、パッケージの情報を右のペインにそれぞれ表示させるために fzf を使用しています。\n\n表示するパッケージを絞るには文字を入力してください。矢印キーで (または Ctrl-j/Ctrl-k) で移動し、Enter でパッケージの情報を less で表示します。\n\npacman のデータベースに載っているパッケージ (インストールされているものとされていないもの両方) を同じような方法 (fzf) でブラウズするには:\n\n```\n$ pacman -Slq | fzf --preview 'pacman -Si {}' --layout=reverse\n```\n\nカーソルの移動方法は同じです。しかし、Enter キーは先程と同じようには動きません。\n\n"
    },
    {
      "title": "パッケージが所有しているファイルとそのサイズを一覧表示",
      "level": 3,
      "content": "このコマンドは、特定のパッケージが多くの容量を使用していることが分かっていて、そのパッケージのどのファイルが最も大きいかを確認したい場合に便利かもしれません。\n\n```\n$ pacman -Qlq package | grep -v '/$' | xargs -r du -h | sort -h\n```\n\n"
    },
    {
      "title": "どのパッケージにも所有されていないファイルを特定する",
      "level": 3,
      "content": "どのパッケージにも所有されていないファイルがある場合 (ソフトウェアのインストールにパッケージマネージャを使用しなかった場合に起こりえます)、そのようなファイルをクリーンアップするために特定する必要があることがあります。\n\n1つ目の方法は、確認しておきたいファイルのリストから、それらが所有されているかどうかを pacman で調べる方法です:\n\n```\n# (export LC_ALL=C.UTF-8; comm -13 <(pacman -Qlq | sed 's,/$,,' | sort) <(find /etc /usr /opt -path /usr/lib/modules -prune -o -print | sort))\n```\n\n"
    },
    {
      "title": "パッケージによって作成された未所有のファイルを追跡する",
      "level": 3,
      "content": "ほとんどのシステムでは、通常の運用でも状態ファイル、ログ、インデックスなどといったゴーストファイルがゆっくりと蓄積していきます。\n\npacutils パッケージの pacreport を使えば、/etc/pacreport.conf の設定を使用して、そのようなファイルとそれらと関連するパッケージを追跡できます (pacreport(1) § FILES を参照)。\n\n設定ファイルの例としては以下のようなものがあるでしょう (要約):\n\n```\n/etc/pacreport.conf\n```\n\n```\n[Options]\nIgnoreUnowned = usr/share/applications/mimeinfo.cache\n\n[PkgIgnoreUnowned]\nalsa-utils = var/lib/alsa/asound.state\nbluez = var/lib/bluetooth\nca-certificates = etc/ca-certificates/trust-source/*\ndbus = var/lib/dbus/machine-id\nglibc = etc/ld.so.cache\ngrub = boot/grub/*\nlinux = boot/initramfs-linux.img\npacman = var/lib/pacman/local\nupdate-mime-database = usr/share/mime/magic\n```\n\n設定ファイルを作成したら、pacreport --unowned-files を root ユーザーとして実行すれば、関連するパッケージがすでにアンインストールされている場合 (または、新しいファイルが作成された場合)、それに対応する未所有のファイルが一覧表示されます。\n\n加えて、aconfmgr (aconfmgr-gitAUR) は、設定スクリプトを使用して、変更されたファイルや孤立したファイルを追跡できます。\n\n"
    },
    {
      "title": "使用していないパッケージ (孤立したパッケージ) の削除",
      "level": 3,
      "content": "孤立したパッケージ (orphan) とは、依存パッケージとしてインストールされたが、もはやどのパッケージからも必要とされていないパッケージのことです。\n\nパッケージのアンインストール時に pacman -Rs package ではなく pacman -R package を使ったことや、makedepends として設定されているパッケージをインストールしたこと、パッケージの新しいバージョンで依存関係が解消したことが原因で、このようなパッケージは時間と共にシステムに蓄積していく可能性があります。\n\n孤立したパッケージとその設定ファイルを再帰的に削除するには:\n\n```\n# pacman -Qdtq | pacman -Rns -\n```\n\n孤立したパッケージが見つからなかった場合、このコマンドの出力は error: argument '-' specified with empty stdin (エラー: 引数 '-' が指定されましたが標準入力が空です) となります。これは、pacman -Rns に引数が渡されなかった場合の想定通りの動作です。このエラーは、2つ目のコマンドの前に moreutils パッケージの ifne(1) を加えれば出なくなります。\n\n削除したくないパッケージが先のコマンドの出力に載っていた場合は、そのパッケージを明示的にインストールしたものとして登録することで、孤立したパッケージのリストから外すことができます:\n\n```\n# pacman -D --asexplicit package\n```\n\n/usr/bin/bash -c \"/usr/bin/pacman -Qdt || /usr/bin/echo '=> None found.'\"\n\n"
    },
    {
      "title": "より多くの不要なパッケージを検出する",
      "level": 3,
      "content": "上記の方法では、必要とされないパッケージが検出されないことがあります。例えば、依存関係のサイクル (\"循環依存\" とも呼ばれる)、過剰な依存 (複数回、依存関係が発生する)、明示的ではない任意の依存などの場合です。\n\nそのようなパッケージを検出するには:\n\n```\n$ pacman -Qqd | pacman -Rsu --print -\n```\n\n先のコマンドで出力されたパッケージを一度に全て削除したい場合は、--print フラグ無しでコマンドを実行してください。\n\n"
    },
    {
      "title": "必須パッケージ以外の全てのパッケージを削除する",
      "level": 3,
      "content": "必須パッケージを除いて全てのパッケージを削除する必要がある場合、1つの方法は、必須でないパッケージのインストール理由を「依存パッケージ」と設定してから、不要な依存パッケージを全て削除することです。\n\nまず、\"明示的にインストール\" されたパッケージのインストール理由を \"依存関係としてインストール\" に変更します:\n\n```\n# pacman -D --asdeps $(pacman -Qqe)\n```\n\n次に、必須パッケージ (つまり、削除したくないパッケージ) が削除対象にならないようにするために、それらのインストール理由を \"明示的にインストール\" に変更します:\n\n```\n# pacman -D --asexplicit base linux linux-firmware\n```\n\n- 他のパッケージも削除されないようにしたい場合は、上記のコマンドに加えてください。完全に機能するベースシステムに必要となりうる他のパッケージについては インストールガイド#必須パッケージのインストール を参照してください。\n- 上記のコマンドではブートローダーのパッケージも削除対象になります。削除してもシステム自体は起動可能なままであるはずですが、パッケージがないとブートパラメータを変更できないかもしれません。\n\n最後に、#使用していないパッケージ (孤立したパッケージ) の削除 の手順に従って \"依存関係としてインストール\" に指定されたパッケージを削除してください。\n\n"
    },
    {
      "title": "複数のパッケージの依存パッケージリストを取得",
      "level": 3,
      "content": "依存パッケージはアルファベット順にソートされ、重複するパッケージは1つにまとめられます。\n\n```\n$ LC_ALL=C.UTF-8 pacman -Si packages | awk -F'[:<=>]' '/^Depends/ {print $2}' | xargs -n1 | sort -u\n```\n\nあるいは、expac を使って:\n\n```\n$ expac -l '\\n' %E -S packages | sort -u\n```\n\n"
    },
    {
      "title": "変更されたバックアップファイルをリストアップ",
      "level": 3,
      "content": "ユーザーによって変更される可能性のあるファイル (つまり、PKGBUILD の backup 配列に含まれているファイル) として pacman に追跡されていて、かつユーザーによって変更が加えられた設定ファイルを一覧表示するには:\n\n```\n# pacman -Qii | awk '/\\[modified\\]/ {print $(NF - 1)}'\n```\n\nこのコマンドを root 権限で実行することで、root ユーザーからしか読み取れないファイル /etc/sudoers など) も出力に含まれるようになります。\n\nこのコマンドは、システムのバックアップを選択的に行いたい時や、システムの設定をマシンからマシンへ複製する際に使うことができます。\n\n- pacman のデータベースに載っているファイルのうち変更されたもの (バックアップファイル以外も含む) を一覧表示する方法は #パッケージから変更された全てのファイルをリストアップ を見てください。\n- pacman によって追跡されていないファイルを一覧表示する方法は #どのパッケージにも所有されていないファイルを特定する を見てください。\n\n"
    },
    {
      "title": "pacman データベースをバックアップ",
      "level": 3,
      "content": "次のコマンドでローカルの pacman データベースをバックアップできます:\n\n```\n$ tar -cjf pacman_database.tar.bz2 /var/lib/pacman/local\n```\n\nバックアップした pacman データベースファイルは USB スティックや外付けハードドライブ、CD-R など、一つ以上のオフラインメディアに保存してください。\n\npacman_database.tar.bz2 ファイルを / ディレクトリに移動して以下のコマンドを実行することでデータベースを復元できます:\n\n```\n# tar -xjvf pacman_database.tar.bz2\n```\n\n"
    },
    {
      "title": "変更履歴を簡単に確認",
      "level": 3,
      "content": "メンテナがパッケージを更新するとき、大抵の場合コミットにはコメントが付けられます。pacologAUR をインストールすることでコマンドラインからコミットメッセージを素早く確認することができます。pacolog package を実行すると、公式リポジトリのパッケージまたは AUR のパッケージの最近のコミットメッセージの一覧を表示します。\n\n"
    },
    {
      "title": "インストールとリカバリ",
      "level": 2,
      "content": "パッケージを取得・復活させる別の方法。\n\n"
    },
    {
      "title": "パッケージを CD/DVD や USB スティックからインストールする",
      "level": 3,
      "content": "パッケージやパッケージグループをダウンロードするには:\n\n```\n# cd ~/Packages\n# pacman -Syw --cachedir . base base-devel grub-bios xorg gimp\n# repo-add ./custom.db.tar.zst ./*.pkg.tar.zst\n```\n\nPacman はデフォルトでホストのインストール環境を参照するため、既存の依存関係を適切に解決したり、ダウンロードしたりすることができません。すべてのパッケージと依存関係が必要である場合は、一時的な空のデータベースを作成し、そのデータベースを --dbpath オプションで参照すると良いでしょう:\n\n```\n# mkdir /tmp/blankdb\n# pacman -Syw --cachedir . --dbpath /tmp/blankdb base base-devel grub-bios xorg gimp\n# repo-add ./custom.db.tar.zst ./*.pkg.tar.zst\n```\n\n次に、先の \"Packages\" ディレクトリを光学ディスク (CD や DVD など) に焼くか、USB ドライブや外部 HDD などに保存してください。\n\nインストールするには:\n\n1. メディアをマウントする:\n\n光学ディスクドライブの場合は:\n\n```\n# mount --mkdir /dev/sr0 /mnt/repo\n```\n\nUSB ドライブやハードディスクドライブなどの場合は:\n\n```\n# mount --mkdir /dev/sdxY /mnt/repo\n```\n\n2. マウントしたリポジトリを pacman.conf に追加してください。ただし、他のリポジトリより前に置いてください。リポジトリの順番が重要です。pacman.conf の一番下にある、コメントアウトされているリポジトリをアンコメントするだけではいけません。他のリポジトリより前に置くことで、CD/DVD/USB にあるファイルを標準のリポジトリ上にあるものよりも優先させます:\n\n```\n/etc/pacman.conf\n```\n\n```\n[custom]\nSigLevel = PackageRequired\nServer = file:///mnt/repo/Packages\n```\n\n3. 最後に、pacman データベースを同期し、追加した新しいリポジトリを利用できるようにします:\n\n```\n# pacman -Syu\n```\n\n"
    },
    {
      "title": "カスタムローカルリポジトリ",
      "level": 3,
      "content": "pacman に含まれる repo-add スクリプトを使うことで、個人用のリポジトリのデータベースを生成することができます。詳しい使い方は repo-add --help を実行して見て下さい。\n\nパッケージデータベースは tar ファイルです (任意で圧縮できます)。有効な拡張子は、.db か .files の後に、アーカイブ拡張子 .tar、.tar.gz、.tar.bz2、.tar.xz、.tar.zst、.tar.Z のうちどれかを付け加えたものになります。(repo-add を使用する際に) このファイルが存在している必要はありませんが、親ディレクトリはすべて存在していなければなりません。\n\n新しいパッケージをデータベースに追加する、あるいはデータベース内にすでにある古いバージョンのパッケージを置き換えるには、以下を実行してください:\n\n```\n$ repo-add /path/to/repo.db.tar.zst /path/to/package-1.0-1-x86_64.pkg.tar.zst\n```\n\nrepo-add を使用する際は、データベースとパッケージが同一のディレクトリ内に存在している必要はありません。ただし、そのデータベースを pacman で使用する際は、データベースとパッケージが一緒に存在している必要があるので注意してください。また、リポジトリに含めるビルド済みパッケージをすべて1つのディレクトリに入れておけば、シェルのグロブ拡張を使って複数のパッケージを一度に追加/更新することができます:\n\n```\n$ repo-add /path/to/repo.db.tar.zst /path/to/*.pkg.tar.zst\n```\n\n複数のアーキテクチャをサポートしようと考えている場合、エラーが起こらないように注意する必要があります。各アーキテクチャに独自のディレクトリツリーが存在している必要があります:\n\n```\n$ tree ~/customrepo/ | sed \"s/$(uname -m)/arch/g\"\n```\n\n```\n/home/archie/customrepo/\n└── arch\n    ├── customrepo.db -> customrepo.db.tar.zst\n    ├── customrepo.db.tar.zst\n    ├── customrepo.files -> customrepo.files.tar.zst\n    ├── customrepo.files.tar.zst\n    └── personal-website-git-b99cce0-1-arch.pkg.tar.zst\n\n1 directory, 5 files\n```\n\nrepo-add 実行ファイルは、パッケージが適切であるかどうかをチェックします。パッケージが適切でない場合、以下のようなエラーメッセージが出力されます:\n\n```\n==> ERROR: '/home/archie/customrepo/arch/foo-arch.pkg.tar.zst' does not have a valid database archive extension.\n```\n\nrepo-remove はパッケージデータベースからパッケージを削除するために使用されます。パッケージの名前のみをコマンドラインで指定します。\n\n```\n$ repo-remove /path/to/repo.db.tar.zst pkgname\n```\n\nローカルリポジトリを作成できたら、リポジトリを pacman.conf に追加してください。カスタムリポジトリの例は pacman.conf 内にあります。リポジトリ名は、データベースのファイル名からファイル拡張子を除いたものになります。上記の例では、リポジトリ名は単に repo となります。リポジトリの場所を参照するには、file:// URL を使うか、http://localhost/path/to/directory を使って HTTP 経由で行ってください。\n\nもし良ければ、カスタムリポジトリを非公式ユーザリポジトリのリストに追加して、コミュニティがその恩恵を受けられるようにしましょう。\n\n"
    },
    {
      "title": "pacman のキャッシュをネットワークで共有する",
      "level": 3,
      "content": "LAN 上で複数の Arch マシンを使っている場合、パッケージを共有することでダウンロード回数を劇的に減らすことができます。使用しているアーキテクチャが異なるマシン (i686 と x86_64) でキャッシュを共有してはいけません。問題が発生します。\n\n"
    },
    {
      "title": "読み取り専用キャッシュ",
      "level": 4,
      "content": "Pacman 6.1.0 はキャッシュサーバーを直接サポートしています。キャッシュサーバーは、キャッシュでないサーバーよりも前に試行されます。また、キャッシュサーバーはダウンロード時に HTTP 404 エラーが発生してもサーバープールから削除されず、データベースファイルとしては使用されません。\n\n手っ取り早い解決策を探している場合は、他のコンピュータからキャッシュサーバーとしてアクセスできる一時的なシンプルなウェブサーバーを走らせることができます。\n\nPacman のキャッシュディレクトリを共有してみましょう。例えば、Python の http.server モジュールを使う場合は:\n\n```\n$ python -m http.server -d /var/cache/pacman/pkg/\n```\n\n```\n$ python -m http.server -d /var/cache/pacman/pkg/ --bind 127.0.0.1 8080\n```\n\n次に、各クライアントマシンでキャッシュサーバーを追加するように /etc/pacman.d/mirrorlist を編集してください:\n\n```\n/etc/pacman.d/mirrorlist\n```\n\n```\nCacheServer = http://server-ip:port\n```\n\nスタンドアローンな方法としては darkhttpd で最小限のウェブサーバーを立てられます。先の python コマンドを例えば以下のように置き換えてください:\n\n```\n[http]$ darkhttpd /var/cache/pacman/pkg --no-server-id\n```\n\n利便性のために darkhttpd を systemd サービスとして走らせることもできます。Systemd#ユニットファイル を参照してください。\n\nRust で書かれた小規模な Web サーバーである miniserve も使用できます:\n\n```\n$ miniserve /var/cache/pacman/pkg\n```\n\n次に、miniserve へアクセスできる最初の URL を使って、上記のように /etc/pacman.d/mirrorlist を編集してください。\n\nすでに他の目的で Web サーバーを実行している場合は、代わりにそれをローカルリポジトリサーバーとして再利用できます。たとえば、すでに nginx でサイトを提供している場合は、8080 番ポートで待受する nginx サーバーブロックを追加できます:\n\n```\n/etc/nginx/nginx.conf\n```\n\n```\nserver {\n    listen 8080;\n    root /var/cache/pacman/pkg;\n    server_name myarchrepo.localdomain;\n    try_files $uri $uri/;\n}\n```\n\nこの変更を加えた後は、必ず nginx.service の再起動を行ってください。\n\n"
    },
    {
      "title": "読み取り専用キャッシュのオーバーレイマウント",
      "level": 4,
      "content": "ローカルネットワーク上にあるマシンの /var/cache/pacman/pkg ディレクトリをオーバーレイマウントすることで、読み取り専用のパッケージキャッシュとして使うことができます。キャッシュサーバーに他のマシンでも使われている最新のパッケージがある程度包括的にインストールされている場合、このような構成は効果的です。低帯域幅のアップストリーム接続の終端に一定数のマシンが存在する場合、この方法が便利です。\n\n例:\n\n```\n# mkdir /tmp/remote_pkg /mnt/workdir_pkg /tmp/pacman_pkg\n# sshfs remote_username@remote_pkgcache_addr:/var/cache/pacman/pkg /tmp/remote_pkg -C\n# mount -t overlay overlay -o lowerdir=/tmp/remote_pkg,upperdir=/var/cache/pacman/pkg,workdir=/mnt/workdir_pkg /tmp/pacman_pkg\n```\n\nこれで、オプション --cachedir /tmp/pacman_pkg を使用して pacman を実行できます。例:\n\n```\n# pacman -Syu --cachedir /tmp/pacman_pkg\n```\n\n"
    },
    {
      "title": "読み取り専用の分散キャッシュ",
      "level": 4,
      "content": "パッケージキャッシュを提供しているネットワーク上の他のコンピューターを自動的に検出するための Arch 固有のツールがあります。pacredir、pacserve、pkgdistcacheAUR、または paclanAUR を試してください。pkgdistcache は、プレーンな UDP ではなく Avahi を使用します。これは、WiFi とイーサネット間のブリッジではなくルーティングを行う特定のホームネットワークでより適切に機能する可能性があります。\n\n歴史的には、PkgD と multipkg がありましたが、現在はメンテナンスされていません。\n\n"
    },
    {
      "title": "読み書き可能キャッシュ",
      "level": 4,
      "content": "ネットワークベースのマウントプロトコルを使って /var/cache/pacman/ を共有すれば、複数のコンピュータ間でパッケージを共有することができます。このセクションでは、SSHFS を使って、同じローカルネットワーク上にある複数のコンピュータ間でパッケージのキャッシュ及び関連するライブラリディレクトリを共有する方法を説明します。ただし、ネットワーク経由で共有されたキャッシュは、ファイルシステムの選択などの要因によって遅くなる可能性があることを留意しておいてください。\n\nまず、ネットワーク共有をサポートするファイルシステムのパッケージ (sshfs や curlftpfs、samba、nfs-utils のうち一つ) をインストールしてください。\n\n- sshfs を使う場合、SSH 鍵 の記事を読むことを検討してください。\n- デフォルトでは、smbfs はコロンを含むファイル名をサポートしていないため、クライアント側はそのような問題のあるパッケージをいちいちインターネットからダウンロードしてしまいます。これを防ぐには、クライアント側で mapchars マウントオプションを使用してください。\n\n次に、サーバ上の /var/cache/pacman/pkg をすべてのクライアントマシン上の /var/cache/pacman/pkg にマウントすることで実際のパッケージを共有できます。\n\n"
    },
    {
      "title": "rsync や FTP で双方向同期",
      "level": 4,
      "content": "ローカル環境でのもう一つの方法は rsync です。キャッシュを提供するサーバーを選択し、rsync デーモンを有効化してください。クライアント側では、rsync プロトコルを介すことでこの共有ディレクトリと双方向で同期します。Rsync プロトコルにおいては、ファイル名にコロンが含まれていても問題ありません。\n\n以下はクライアント側での例です。共有ディレクトリの名前に uname -m を使うことで、システムのアーキテクチャと同じキャッシュを同期できるようにします:\n\n```\n# rsync ... rsync://server/share_$(uname -m)/ /var/cache/pacman/pkg/ \n# pacman -Syu\n# paccache --remove --keep 3\n# rsync --delete ... /var/cache/pacman/pkg/ rsync://server/share_$(uname -m)/\n```\n\n暗号化されていない rsync デーモンよりもセキュアな方法として rsync over ssh があります。これについては Rsync#SSH を使った自動バックアップ で概説されています。\n\nRsync がローカル環境で利用できない場合は、シンプルな ftp サービスを双方向同期に使用するのも良いでしょう。lftp は、ローカルをリモートストレージと同期するためのオプション --mirror と --delete を提供しています。\n\n"
    },
    {
      "title": "nginx で動的リバースプロキシキャッシュ",
      "level": 4,
      "content": "nginx を使えば、パッケージのリクエストを公式の上流ミラーにプロキシして、ダウンロードしたファイルをローカルのディスクにキャッシュしておくことができます。その後、同じパッケージに対するリクエストはすべてローカルのキャッシュから直接提供されるようになるため、多くのコンピュータが存在する場合に必要になるインターネットトラフィックの量を最小化できます。\n\nこの例では、キャッシュサーバーを http://cache.domain.example:8080/ で実行し、パッケージを /srv/http/pacman-cache/ に保存します。\n\nキャッシュを提供するコンピュータに nginx をインストールしてください。キャッシュ用のディレクトリを作成し、nginx がそのディレクトリへファイルを書き込みできるようにパーミッションの設定を行ってください:\n\n```\n# mkdir /srv/http/pacman-cache\n# chown http:http /srv/http/pacman-cache\n```\n\nこの pacman キャッシュ用の nginx 設定を /etc/nginx/nginx.conf の開始点として使います。resolver ディレクティブの設定はこれでよいかどうかを確認してください。上流のサーバーブロックでは、proxy_pass ディレクティブを公式ミラーのアドレスに設定してください。オプションの形式は先の設定ファイルを参考にしてください。設定ファイルが完成したら、nginx を開始し、有効化してください。\n\nキャッシュを使うには、各 Arch Linux コンピュータ (キャッシュをホストするコンピュータも含む) の mirrorlist ファイルの一番最初に以下の行を追加する必要があります:\n\n```\n/etc/pacman.d/mirrorlist\n```\n\n```\nServer = http://cache.domain.example:8080/$repo/os/$arch\n...\n```\n\n"
    },
    {
      "title": "Pacoloco プロキシキャッシュサーバー",
      "level": 4,
      "content": "Pacoloco は、pacman リポジトリ用の使いやすいプロキシキャッシュサーバーです。キャッシュ済みのパッケージの自動プリフェッチも可能です。\n\npacoloco パッケージでインストールできます。Pacoloco の設定ファイルを開き、pacman ミラーを追加してください:\n\n```\n/etc/pacoloco.yaml\n```\n\n```\nport: 9129\nrepos:\n  mycopy:\n    urls:\n      - http://mirror.lty.me/archlinux\n      - http://mirrors.kernel.org/archlinux\n```\n\npacoloco.service を再起動すると、プロキシリポジトリが http://myserver:9129/repo/mycopy で利用できるようになります。\n\n"
    },
    {
      "title": "Flexo プロキシキャッシュサーバー",
      "level": 4,
      "content": "Flexo は、pacman リポジトリ用のさらに別のプロキシキャッシュサーバーです。Flexo は flexo-gitAUR でインストールできます。インストールしたら、flexo.service ユニットを起動してください。\n\nFlexo はデフォルトでは 7878 番ポートで動作します。pacman に Flexo 経由でパッケージをダウンロードさせるには、/etc/pacman.d/mirrorlist の一番最初に Server = http://myserver:7878/$repo/os/$arch を記述してくだしあ。\n\n"
    },
    {
      "title": "同期プログラムを使用して pacman パッケージキャッシュを同期する",
      "level": 4,
      "content": "Syncthing または Resilio Sync を使用して、pacman キャッシュディレクトリ (つまり、/var/cache/pacman/pkg) を同期します。\n\n"
    },
    {
      "title": "望まないキャッシュ削除を防ぐ",
      "level": 4,
      "content": "デフォルトでは、pacman -Sc は、キャッシュにあるパッケージ tarball のうち、同マシン上にインストールされていないパッケージに対応するものを削除します。pacman は、キャッシュを共有するすべてのマシンにどのようなパッケージがインストールされているかを予測できないため、削除すべきでないファイルを削除してしまうことになります。\n\nキャッシュのクリーンアップ時に 古くなった tarball のみを削除するには:\n\n```\n/etc/pacman.conf\n```\n\n```\n[options]\nCleanMethod = KeepCurrent\n```\n\n"
    },
    {
      "title": "ファイルシステムからパッケージを再構成する",
      "level": 3,
      "content": "ファイルシステム上のインストール済みファイルからパッケージを再構築するには、fakepkgAUR を使用してください。システム上のファイルはそのままパッケージ化されるため、ファイルシステムに加えた変更はすべてパッケージにも受け継がれます。そのため、再構成したパッケージを配布することは推奨されません。代替方法は ABS と Arch Linux Archive を参照してください。\n\n"
    },
    {
      "title": "インストール済みパッケージのリスト",
      "level": 3,
      "content": "明示的にインストールされたすべてのパッケージのリストを保持しておくと、たとえばシステムをバックアップしたり、新しいシステムへのインストールを高速化したりするのに役立ちます:\n\n```\n$ pacman -Qqe > pkglist.txt\n```\n\n- オプション -t を使用すると、他の明示的にインストールされたパッケージによって必要とされているパッケージは列挙されません。作成したリストから再インストールすると、これらのパッケージはインストールされますが、インストール理由は単なる依存関係となります。\n- オプション -n を使用すると、外部パッケージ (AUR など) がリストから省略されます。\n- comm -13 <(pacman -Qqdt | sort) <(pacman -Qqdtt | sort) > optdeplist.txt を使えば、インストール済みの任意の依存関係のリストも作成できます。任意の依存関係は --asdeps フラグで再インストールできます。\n- pacman -Qqem > foreignpkglist.txt を使えば、明示的にインストールされた AUR およびその他の外部パッケージのリストを作成できます。\n\n明示的にインストールされたパッケージの最新リストを保持するために (たとえば、バージョン管理された /etc/ と組み合わせて)、フックを設定できます。例:\n\n```\n[Trigger]\nOperation = Install\nOperation = Remove\nType = Package\nTarget = *\n\n[Action]\nWhen = PostTransaction\nExec = /bin/sh -c '/usr/bin/pacman -Qqe > /etc/pkglist.txt'\n```\n\n"
    },
    {
      "title": "リストからパッケージをインストールする",
      "level": 3,
      "content": "既にインストール済みの最新のパッケージを再インストールせずに、以前保存したパッケージリストからパッケージをインストールするには、以下を実行してください:\n\n```\n# pacman -S --needed - < pkglist.txt\n```\n\nしかし、リストに AUR 由来の外部パッケージやローカルにインストールされた外部パッケージなどが載っていることもあります。リストから外部パッケージを除くには、先のコマンドを以下のように拡張することで可能です:\n\n```\n# pacman -S --needed $(comm -12 <(pacman -Slq | sort) <(sort pkglist.txt))\n```\n\n最後に、システムにインストールされているパッケージがリストと一致していることを確認し、リストに記載されていないパッケージはすべて削除してください:\n\n```\n# pacman -Rsu $(comm -23 <(pacman -Qq | sort) <(sort pkglist.txt))\n```\n\n"
    },
    {
      "title": "パッケージの元の状態から変更された全てのファイルをリストアップ",
      "level": 3,
      "content": "(ソフトウェア/アードウェアの障害によって) ファイルが破損していることが疑われるが、本当に破損しているかどうかはわからない場合は、パッケージ内のファイルのハッシュ値と比較したほうが良いかもしれません。pacutils で比較することができます:\n\n```\n# paccheck --sha256sum --quiet\n```\n\nデータベースの復元方法については、#Pacman のローカルデータベースを復元する を見てください。mtree ファイルはそれぞれのパッケージファイルから .MTREE として抽出することもできます。\n\n"
    },
    {
      "title": "全てのパッケージの再インストール",
      "level": 3,
      "content": "すべてのネイティブなパッケージを再インストールするには、以下のコマンドを使用してください:\n\n```\n# pacman -Qqn | pacman -S -\n```\n\n外部 (AUR) パッケージはまた別に再インストールする必要があります。そのようなパッケージは pacman -Qqm でリストアップできます。\n\nデフォルトでは、Pacman はインストール理由を保持します。\n\n"
    },
    {
      "title": "Pacman のローカルデータベースを復元する",
      "level": 3,
      "content": "pacman/ローカルデータベースの復元を見てください。\n\n"
    },
    {
      "title": "既存のインストールから USB キーを復元する",
      "level": 3,
      "content": "Arch を USB キーにインストールしたが、内部のデータが壊れてしまった場合 (例えば、書き込み途中に USB を抜いてしまった場合など)、すべてのパッケージを再インストールして、再び動かせるようにできる可能性があります (USB キーが /newarch にマウントされている場合):\n\n```\n# pacman -S $(pacman -Qq --dbpath /newarch/var/lib/pacman) --root /newarch --dbpath /newarch/var/lib/pacman\n```\n\n"
    },
    {
      "title": ".pkg ファイル内の特定のファイルの内容を見る",
      "level": 3,
      "content": "例えば、systemd パッケージ内の /etc/systemd/logind.conf の内容を見たい場合:\n\n```\n$ bsdtar -xOf /var/cache/pacman/pkg/systemd-250.4-2-x86_64.pkg.tar.zst etc/systemd/logind.conf\n```\n\nあるいは、アーカイブのブラウズに vim を使うこともできます:\n\n```\n$ vim /var/cache/pacman/pkg/systemd-250.4-2-x86_64.pkg.tar.zst\n```\n\n"
    },
    {
      "title": "古いパッケージのライブラリを使っているアプリケーションを探す",
      "level": 3,
      "content": "既に実行中のプロセスには、システムの更新による変更が自動的に適用されません。その結果、実行中のプロセスは古いライブラリを使い続けます。脆弱性やその他のバグ、あるいはバージョン間での非互換性に関連する問題が発生する可能性があることから、このようなことは望ましくない場合があります。\n\n更新されたライブラリに依存しているプロセスは htop (影響を受けるプログラムの名前をハイライトします) や lsof (これはライブラリの名前も出力します) ベースのスニペットを使って見つけることができます:\n\n```\n# lsof +c 0 | grep -w DEL | awk '1 { print $1 \": \" $NF }' | sort -u\n```\n\nこの方法では、実行中のプロセスによって開かれたままになっているファイルのみを検出します。そのようなファイルは基本的に共有ライブラリ (.so ファイル) だけです。これは、Java や Python アプリケーションのライブラリといった一部の依存関係を見逃してしまうことがあります。\n\n"
    },
    {
      "title": "必要な言語のコンテンツのみをインストールする",
      "level": 3,
      "content": "多くのパッケージは、複数の言語のドキュメントと翻訳をインストールします。中にはそのような不必要のファイルを削除するように設計されたプログラムもあります。例えば、localepurgeAUR はパッケージのインストール後に実行され、不必要なロケールファイルを削除します。より直接的なアプローチは pacman.conf の NoExtract ディレクティブで、これはそのようなファイルをそもそもインストールしないようにできます。\n\nヘルプファイルの翻訳を C ロケールを除いてすべてインストールしないようにするには、以下のディレクティブを追加してください:\n\n```\nNoExtract = usr/share/help/* !usr/share/help/C/*\n```\n\nHTML ドキュメントをすべてインストールしないようにするには、以下を追加してください:\n\n```\nNoExtract = usr/share/gtk-doc/html/*\nNoExtract = usr/share/doc/HTML/*\n```\n\n必要なものを除いて様々なロケールをインストールしないようにするには:\n\n```\nNoExtract = usr/share/locale/* usr/share/X11/locale/*/* usr/share/i18n/locales/* opt/google/chrome/locales/* !usr/share/X11/locale/C/*\nNoExtract = !usr/share/X11/locale/compose.dir !usr/share/X11/locale/iso8859-1/*\nNoExtract = !*locale*/en*/* !usr/share/*locale*/locale.*\nNoExtract = !usr/share/*locales/en_?? !usr/share/*locales/i18n* !usr/share/*locales/iso*\nNoExtract = usr/share/i18n/charmaps/* !usr/share/i18n/charmaps/UTF-8.gz !usr/share/i18n/charmaps/ANSI_X3.4-1968.gz\nNoExtract = !usr/share/*locales/trans*\nNoExtract = !usr/share/*locales/C !usr/share/*locales/POSIX\n```\n\n翻訳された man ページをインストールしないようにするには、以下を追加してください:\n\n```\nNoExtract = usr/share/man/* !usr/share/man/man*\n```\n\nvim-runtime に含まれている言語ファイルをインストールしないようにするには、以下を追加してください:\n\n```\nNoExtract = usr/share/vim/vim*/lang/*\n```\n\nQt アプリケーションの英語コンテンツ以外をインストールしないようにするには、以下を追加してください:\n\n```\nNoExtract = usr/share/*/translations/*.qm usr/share/*/nls/*.qm usr/share/qt/phrasebooks/*.qph usr/share/qt/translations/*.pak !*/en-US.pak\n```\n\nElectron アプリケーションの英語コンテンツ以外をインストールしないようにするには、以下を追加してください:\n\n```\nNoExtract = usr/share/*/locales/*.pak opt/*/locales/*.pak usr/lib/*/locales/*.pak !*/en-US.pak\n```\n\nLibreOffice の英語のヘルプファイルをインストールしないようにするには、以下を追加してください:\n\n```\nNoExtract = usr/lib/libreoffice/help/en-US/*\n```\n\nOnlyOffice の英語コンテンツ以外をインストールしないようにするには、以下を追加してください:\n\n```\nNoExtract = opt/onlyoffice/desktopeditors/dictionaries/* !opt/onlyoffice/desktopeditors/dictionaries/en_US/*\nNoExtract = opt/onlyoffice/desktopeditors/editors/web-apps/apps/*/main/locale/* !*/en.json\nNoExtract = opt/onlyoffice/desktopeditors/editors/web-apps/apps/*/main/resources/help/*/* !*/help/en/*\nNoExtract = opt/onlyoffice/desktopeditors/editors/web-apps/apps/*/main/resources/symboltable/* !*/en.json\nNoExtract = opt/onlyoffice/desktopeditors/editors/web-apps/apps/documenteditor/forms/locale/* !*/en.json\nNoExtract = opt/onlyoffice/desktopeditors/editors/web-apps/apps/spreadsheeteditor/main/resources/formula-lang/* !*/en.json !*/en_desc.json\nNoExtract = opt/onlyoffice/desktopeditors/converter/empty/*/* !opt/onlyoffice/desktopeditors/converter/empty/en-US/*\n```\n\n英語の iBus 絵文字辞書以外をインストールしないようにするには、以下を追加してください:\n\n```\nNoExtract = usr/share/ibus/dicts/emoji-*.dict !usr/share/ibus/dicts/emoji-en.dict\n```\n\n"
    },
    {
      "title": "接続状況が悪い場合でもパッケージをインストールする",
      "level": 3,
      "content": "接続環境が悪い場所でパッケージをインストールする際 (電車で携帯電話を使う場合など)、--disable-download-timeout オプションを使えば以下のようなエラーが発生する可能性を減らすことができます:\n\n```\nerror: failed retrieving file […] Operation too slow. Less than 1 bytes/sec transferred the last 10 seconds\n```\n\nもしくは、\n\n```\nerror: failed retrieving file […] Operation timed out after 10014 milliseconds with 0 out of 0 bytes received\n```\n\n"
    },
    {
      "title": "パフォーマンス",
      "level": 2,
      "content": "Table content:\nこの記事またはセクションは情報が古くなっています。 理由: このページは、pacman が並列ダウンロードをネイティブにサポートする前に書かれました。v6 以降、複数のパッケージを同時にダウンロードするオプションは以下だけではありません。 (Discuss)\n\n"
    },
    {
      "title": "ダウンロード速度",
      "level": 3,
      "content": "パッケージをダウンロードするとき pacman は /etc/pacman.d/mirrorlist に書かれている順番通りにミラーを使用します。リストの一番上のミラーがデフォルトで使用されますが、それが最速のミラーだとは限りません。一番高速なミラーを選択する方法はミラーを見てください。\n\nPacman のダウンロード速度は、並列ダウンロードの有効化や、パッケージのダウンロードに pacman 内蔵のファイルダウンローダー以外のアプリケーションを使うことでも改善することができます。\n\nいずれの場合でも、変更を行う前に最新の pacman を使っていることを確認してください:\n\n```\n# pacman -Syu\n```\n\n"
    },
    {
      "title": "Powerpill",
      "level": 4,
      "content": "Powerpill は pacman のラッパーで、並列で分割ダウンロードを行うことによって pacman のダウンロード速度の向上を図ります。\n\n"
    },
    {
      "title": "wget",
      "level": 4,
      "content": "pacman に初めから入っている機能よりもパワフルなプロキシ設定が必要な場合、wget はとても使い勝手の良い選択肢です。\n\nwget を使うには、まず wget をインストールし、/etc/pacman.conf ファイルの [options] セクションにある以下の行をアンコメントしてください:\n\n```\nXferCommand = /usr/bin/wget --passive-ftp --show-progress -c -q -N %u\n```\n\n/etc/pacman.conf に wget パラメータを記述する代わりに、wget の設定ファイルを直接修正することも可能です (システム全体のファイルは /etc/wgetrc、ユーザー別のファイルは $HOME/.wgetrc)。\n\n"
    },
    {
      "title": "aria2",
      "level": 4,
      "content": "aria2 はレジューム機能と分割 HTTP/HTTPS/FTP ダウンロードをサポートしている軽量なダウンロードユーティリティです。aria2 を使えば、Arch ミラーに対して複数の HTTP/HTTPS/FTP 接続を同時に確立することができ、ファイルやパッケージのダウンロード速度が向上するはずです。\n\naria2 をインストールして、/etc/pacman.conf の [options] セクションに以下の行を追加してください:\n\n```\nXferCommand = /usr/bin/aria2c --allow-overwrite=true --continue=true --file-allocation=none --log-level=error --max-tries=2 --max-connection-per-server=2 --max-file-not-found=5 --min-split-size=5M --no-conf --remote-time=true --summary-interval=60 --timeout=5 --dir=/ --out %o %u\n```\n\n使用されている aria2c のオプションについては aria2c(1) § OPTIONS を見てください。\n\n- -d, --dir: ダウンロードしたファイルを保存するディレクトリ。\n- -o, --out: ダウンロードしたファイルの出力ファイル名。\n- %o: pacman によって指定されるローカルのファイル名を表す変数。\n- %u: pacman によって指定されるダウンロード URL を表す変数。\n\n"
    },
    {
      "title": "他のアプリケーション",
      "level": 4,
      "content": "pacman で利用できるダウンローダーは他にもあります。以下はそのダウンローダーと、利用するための XferCommand 設定を挙げています:\n\n- snarf: XferCommand = /usr/bin/snarf -N %u\n- lftp: XferCommand = /usr/bin/lftp -c pget %u\n- axel: XferCommand = /usr/bin/axel -n 2 -v -a -o %o %u\n- hget: XferCommand = /usr/bin/hget %u -n 2 -skip-tls false (詳細は Github のプロジェクトページのドキュメントを読んでください)\n- saldl: XferCommand = /usr/bin/saldl -c6 -l4 -s2m -o %o %u (詳細は プロジェクトページのドキュメントを読んでください)\n\n"
    },
    {
      "title": "ユーティリティ",
      "level": 2,
      "content": "- isfree — フリーでないパッケージを一覧表示する Bash スクリプト。Parabola のブラックリストをベースとしています。\n\n- Lostfiles — 孤立したファイルを検知するスクリプト。\n\n- pacutils — libalpm ベースのプログラム用のヘルパーライブラリ。\n\n- pkgfile — あるファイルを使っているパッケージが何かを見つけるツール。\n\n- pkgtop — GNU/Linux 用に開発されたインタラクティブなパッケージマネージャ兼リソースモニター。\n\n- Powerpill — aria2 や Reflector を通じて並列分割ダウンロードを行い pacman のダウンロード処理を高速化。\n\n- repoctl — ローカルリポジトリの管理を補助するツール。\n\n- repose — Arch Linux リポジトリ作成ツール。\n\n- snap-pac — openSUSE の YaST のように pacman で自動的に snapper のスナップショットを作成するツール。\n\n- vrms-arch — フリーでないパッケージがインストールされているかどうかを教えてくれるバーチャル Richard M. Stallman。\n\n"
    },
    {
      "title": "グラフィカル",
      "level": 3,
      "content": "- Deepin App Store — DTK で構築された Deepin デスクトップ環境用のサードパーティアプリストア。PackageKit を使用しています。AppStream メタデータ をサポートしています。.\n\n- Discover — C++/QML で書かれた、PackageKit を使用する Qt 5 アプリケーションマネージャ。AppStream メタデータ、Flatpak、ファームウェアの更新をサポートしています。plasma に含まれています。\n\n- GNOME PackageKit — C で書かれた、PackageKit を使用する GTK 3 パッケージマネージャ。\n\n- pcurses — C++ で書かれた、Curses TUI の pacman ラッパー。\n\n- tkPacman — Tcl で書かれた、Tk の pacman ラッパー。\n\n"
    }
  ]
}