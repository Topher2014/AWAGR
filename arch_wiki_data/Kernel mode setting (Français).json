{
  "title": "Kernel mode setting (Français)",
  "url": "https://wiki.archlinux.org/title/Kernel_mode_setting_(Fran%C3%A7ais)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- ATI (Français)\n- Intel graphics (Français)\n- Nouveau (Français)\n\nLe Kernel-based Mode-Setting (KMS) est une procédé permettant de définir la résolution et la profondeur d'affichage dans l'espace du noyau plutôt que dans l'espace utilisateur.\n\nL'implémentation de KMS par le noyau Linux permet une résolution native dans le framebuffer et permet une permutation instantanée vers la console (tty). KMS permet également d'utiliser des technologies plus récentes (telles que DRI2) qui contribuent à réduire les artefacts et à augmenter les performances 3D, et même les économies d'énergie depuis le noyau.\n\n"
    },
    {
      "title": "Contexte",
      "level": 2,
      "content": "Auparavant, la configuration de la carte vidéo était la tâche du serveur X. De ce fait, il n'était pas facile de configurer la carte vidéo. Pour cette raison, il n'était pas facile d'avoir des graphismes sophistiqués dans les consoles virtuelles. De plus, chaque fois que l'on passait de X à une console virtuelle (Ctrl+Alt+F2), le serveur devait donner le contrôle de la carte vidéo au noyau, ce qui était lent et provoquait des scintillements. Le même processus \"douloureux\" se produisait lorsque le contrôle était rendu au serveur X (Alt+F7 lorsque X fonctionne en VT7).\n\nAvec Kernel Mode Setting (KMS), le noyau est maintenant capable de définir le mode de la carte vidéo. Cela rend possible, entre autres, les graphismes sophistiqués pendant le démarrage, la console virtuelle et la permutation rapide avec X.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Tout d'abord, notez que pour toute méthode que vous utilisez, vous devez toujours désactiver :\n\n- Toute option vga= dans votre chargeur d'amorçage car elle entrera en conflit avec la résolution native activée par KMS.\n- Toute ligne video= qui active un framebuffer en conflit avec le pilote.\n- Tout autre pilote de framebuffer (tel que uvesafb).\n\n"
    },
    {
      "title": "Démarrage tardif de KMS",
      "level": 3,
      "content": "Les pilotes Intel, Nouveau, ATI et AMDGPU activent déjà KMS automatiquement pour tous les chipsets, vous n'avez donc pas besoin de l'installer manuellement.\n\nLe pilote propriétaire NVIDIA prend en charge KMS (depuis 364.12), qui doit être activé manuellement.\n\n"
    },
    {
      "title": "Démarrage précoce de KMS",
      "level": 3,
      "content": "KMS est généralement initialisé après l'étape initramfs. Cependant, il est possible d'activer KMS déjà pendant l'étape initramfs. Ajoutez le module requis pour le pilote vidéo au fichier de configuration initramfs :\n\n- amdgpu pour AMDGPU, ou radeon si vous utilisez l'ancien pilote ATI.\n- i915 pour Intel.\n- nouveau pour le pilote open-source Nouveau.\n- nvidia nvidia_modeset nvidia_uvm nvidia_drm pour le pilote nvidia. Consultez NVIDIA (Français)#DRM kernel mode setting pour plus de détails.\n\n- mgag200 pour les cartes Matrox.\n- Selon la sortie vidéo de QEMU (option -vga type de qemu ou libvirt <video><model type='type'>[1]): bochs pour std avec qemu et vga/bochs avec libvirt, virtio-gpu pour virtio, qxl pour qxl, vmwgfx pour vmware avec qemu et vmvga pour libvirt, cirrus pour cirrus.\n- Selon le mode de VirtualBox: vmwgfx pour VMSVGA, vboxvideo pour VBoxVGA ou VBoxSVGA.\n\n- bochs pour std avec qemu et vga/bochs avec libvirt,\n- virtio-gpu pour virtio,\n- qxl pour qxl,\n- vmwgfx pour vmware avec qemu et vmvga pour libvirt,\n- cirrus pour cirrus.\n\n- vmwgfx pour VMSVGA,\n- vboxvideo pour VBoxVGA ou VBoxSVGA.\n\nLes instructions de configuration d'initramfs sont légèrement différentes selon le générateur d'initramfs que vous utilisez.\n\n"
    },
    {
      "title": "mkinitcpio",
      "level": 4,
      "content": "Par exemple, pour activer le KMS précoce pour le pilote graphique Intel :\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nMODULES=(... i915 ...)\n```\n\nSi vous utilisez un fichier EDID personnalisé (non applicable pour les résolutions intégrées), vous devez également l'intégrer dans l'initramfs :\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nFILES=(/usr/lib/firmware/edid/your_edid.bin)\n```\n\nPuis régénérez l'initramfs.\n\n"
    },
    {
      "title": "Booster",
      "level": 4,
      "content": "Si vous utilisez Booster, vous pouvez charger les modules nécessaires avec ce changement de configuration :\n\n```\n/etc/booster.yaml\n```\n\n```\nmodules_force_load : i915\n```\n\nPour ajouter des fichiers supplémentaires à l'image :\n\n```\n/etc/booster.yaml\n```\n\n```\nextra_files : /usr/lib/firmware/edid/your_edid.bin\n```\n\nPuis régénérez les images booster.\n\n"
    },
    {
      "title": "Mes polices sont trop petites",
      "level": 3,
      "content": "Consultez Linux console#Fonts pour savoir comment changer la police de votre console en une grande police. La police Terminus (terminus-font) est disponible en plusieurs tailles, comme ter-132n qui est plus grande.\n\nAlternativement, désactiver modesetting peut passer à une résolution inférieure et faire apparaître les polices plus grandes.\n\n"
    },
    {
      "title": "Problème au démarrage et dans dmesg",
      "level": 3,
      "content": "L'interrogation des périphériques d'affichage connectés sur les anciens systèmes peut être assez coûteuse. L'interrogation se fait périodiquement et peut dans le pire des cas prendre plusieurs centaines de millisecondes, selon le matériel. Cela provoquera des blocages visibles, par exemple dans la lecture vidéo. Ces blocages peuvent se produire même si votre vidéo est sur la sortie HDP mais que vous avez d'autres sorties non HDP dans votre configuration matérielle. Si vous constatez des blocages de la sortie d'affichage toutes les 10 secondes, la désactivation de l'interrogation peut vous aider.\n\nSi vous consultez un code d'erreur de 0x00000010 (2) lors du démarrage (vous obtiendrez environ 10 lignes de texte, la dernière partie indiquant le code d'erreur), utilisez la commande suivante :\n\n```\n/etc/modprobe.d/modprobe.conf\n```\n\n```\noptions drm_kms_helper poll=0\n```\n\n"
    },
    {
      "title": "Forcer les modes et l'EDID",
      "level": 2,
      "content": "Si votre résolution native n'est pas automatiquement configurée ou si aucun affichage n'est détecté, alors votre moniteur peut ne pas envoyer de fichier EDID ou seulement un fichier biaisé. Le noyau essaiera d'appréhender ce cas et définira l'une des résolutions les plus courantes.\n\nSi vous avez le fichier EDID de votre moniteur, il vous suffit de l'appliquer explicitement (consultez ci-dessous). Cependant, le plus souvent, on n'a pas d'accès direct à un fichier sain et il est nécessaire soit d'extraire un fichier existant et de le corriger, soit d'en générer un nouveau.\n\nLa génération de nouveaux binaires EDID pour diverses résolutions et configurations est possible pendant la compilation du noyau en suivant la documentation en amont (consultez également ici pour un petit guide). D'autres solutions sont décrites en détail dans cet article. L'extraction d'un EDID existant est dans la plupart des cas plus facile, par exemple, si votre moniteur fonctionne correctement sous Windows, vous pouvez extraire l'EDID du pilote correspondant, ou si un moniteur similaire fonctionne avec les mêmes paramètres, vous pouvez utiliser get-edid du paquet read-edid. Vous pouvez également essayer de chercher dans /sys/class/drm/*/edid.\n\nAprès avoir préparé votre EDID, placez-le dans un répertoire, par exemple appelé edid sous /usr/lib/firmware et copiez-y votre binaire.\n\nPour le charger au démarrage, spécifiez ce qui suit dans la ligne de commande du noyau :\n\n```\ndrm.edid_firmware=edid/votre_edid.bin\n```\n\nPour les noyaux plus anciens que 4.13, utilisez cette ligne à la place :\n\n```\ndrm_kms_helper.edid_firmware=edid/votre_edid.bin\n```\n\nAfin de l'appliquer uniquement à un connecteur spécifique, utilisez\n\n```\ndrm.edid_firmware=VGA-1:edid/votre_edid.bin\n```\n\nPour les résolutions intégrées, référez-vous au tableau ci-dessous. La colonne Nom spécifie le nom que l'on est supposé utiliser afin d'imposer son usage.\n\nTable content:\nRésolution | Nom\n800x600 | edid/800x600.bin\n1024x768 | edid/1024x768.bin\n1280x1024 | edid/1280x1024.bin\n1600x1200 (kernel 3.10 ou supérieur) | edid/1600x1200.bin\n1680x1050 | edid/1680x1050.bin\n1920x1080 | edid/1920x1080.bin\n\nSi vous faites un démarrage précoce de KMS, vous devez inclure le fichier EDID personnalisé dans l'initramfs, sinon vous rencontrerez des problèmes.\n\nLa valeur du paramètre drm.edid_firmware peut également être modifiée après le démarrage en écrivant dans /sys/module/drm/parameters/edid_firmware :\n\n```\n# echo edid/votre_edid.bin > /sys/module/drm/parameters/edid_firmware\n```\n\nCeci ne prendra effet que pour les écrans nouvellement branchés, les écrans déjà branchés continueront à utiliser leurs paramètres EDID existants. Pour les écrans externes, il suffit de les rebrancher pour consulter l'effet.\n\nDepuis le noyau 3.15, pour charger un EDID après le démarrage, vous pouvez utiliser debugfs au lieu d'un paramètre de ligne de commande du noyau si le noyau n'est pas en mode lockdown. Ceci est très utile si vous échangez les moniteurs sur un connecteur ou simplement pour des tests. Une fois que vous avez un fichier EDID comme ci-dessus, exécutez :\n\n```\n# cat correct-edid.bin > /sys/kernel/debug/dri/0/HDMI-A-2/edid_override\n```\n\nEt pour désactiver :\n\n```\n# echo -n reset > /sys/kernel/debug/dri/0/HDMI-A-2/edid_override\n```\n\n"
    },
    {
      "title": "Forcer les modes",
      "level": 3,
      "content": "Extrait du wiki de nouveau :\n\n- https://docs.kernel.org/fb/modedb.html\n- https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/drivers/gpu/drm/drm_fb_helper.c\n\nLe format est le suivant\n\n```\nvideo=<conn>:<xres>x<yres>[M][R][-<bpp>][@<refresh>][i][m][eDd]\n```\n\n- <conn> : Connecteur, par exemple DVI-I-1, consultez /sys/class/drm/ pour connaître les connecteurs disponibles.\n- <xres> x <yres> : résolution\n- M : calcul d'un mode CVT ?\n- R : réduction du blanking ?\n- -<bpp> : profondeur de couleur\n- @<refresh> : vitesse de rafraîchissement\n- i : entrelacé (mode non-CVT)\n- m : marges ?\n- e : sortie forcée active\n- d : sortie forcée à l'arrêt\n- D : sortie numérique activée de force (par exemple, connecteur DVI-I)\n\nVous pouvez modifier les modes de plusieurs sorties en utilisant plusieurs fois video=, par exemple, pour forcer DVI à 1024x768 à 85 Hz et TV-out à être désactivé :\n\n```\nvideo=DVI-I-1:1024x768@85 video=TV-1:d\n```\n\nPour obtenir le nom et l'état actuel des connecteurs, vous pouvez utiliser le shell suivant oneliner :\n\n```\n$ for p in /sys/class/drm/*/status ; do con=${p%/status} ; echo -n \"${con#*/card?-} : \" ; cat $p ; done\n```\n\n```\nDVI-I-1 : connected\nHDMI-A-1 : disconnected\nVGA-1 : disconnected\n```\n\n"
    },
    {
      "title": "Désactiver modesetting",
      "level": 2,
      "content": "Vous pouvez vouloir désactiver KMS pour diverses raisons. Pour désactiver KMS, ajoutez nomodeset comme paramètre du noyau. Consultez Kernel parameters pour plus d'informations.\n\nEn plus du paramètre du noyau nomodeset, pour les cartes graphiques Intel, vous devez ajouter i915.modeset=0 et pour les cartes graphiques Nvidia, vous devez ajouter nouveau.modeset=0. Pour un système Nvidia Optimus avec deux cartes, vous devez ajouter les trois paramètres du noyau (c'est-à-dire \"nomodeset i915.modeset=0 nouveau.modeset=0\").\n\n"
    }
  ]
}