{
  "title": "GRUB (Türkçe)",
  "url": "https://wiki.archlinux.org/title/GRUB_(T%C3%BCrk%C3%A7e)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- Arch boot process\n- Master Boot Record\n- GUID Partition Table\n- Unified Extensible Firmware Interface\n- GRUB Legacy\n- GRUB/EFI examples\n- GRUB/Tips and tricks\n- Multiboot USB drive\n\nGRUB (Büyük Birleşik Önyükleyici) bir açılış önyükleyicisi'dir. Mevcut GRUB aynı zamanda GRUB 2' olarak da adlandırılmaktadır. Orijinal GRUB veya GRUB Legacy, 0.9x sürümlerine karşılık gelir. Bu sayfa sadece GRUB 2'yi açıklamaktadır.\n\n"
    },
    {
      "title": "Desteklenen dosya sistemleri",
      "level": 2,
      "content": "GRUB, özellikle FAT32, ext4, Btrfs veya XFS gibi çoklu dosya sistemleri için kendi desteğini paketler. Uyarılar için #Desteklenmeyen dosya sistemleri bölümüne bakınız.\n\n"
    },
    {
      "title": "UEFI sistemler",
      "level": 2,
      "content": "- UEFI, GUID Bölüm tabloları ve Arch'da önyükleme süreci sayfalarının okunması ve anlaşılması tavsiye edilir.\n- UEFI kullanmak için kurulum yaparken, yükleme medyasını UEFI modunda olması önemlidir. Aksi takdirde efibootmgr GRUB'a UEFI önyükleme girdisini ekleyemez. Kurulum yedek önyükleme yolu'na yapılırken NVRAM'e dokunmadığı için BIOS modunda bile çalışacaktır.\n- UEFI kullanarak bir diskten önyükleme yapmak için bir EFI sistem bölümü gereklidir. Zaten bir bölümünüz olup olmadığını öğrenmek için Mevcut bir bölüm olup olmadığını kontrol edin seçeneğini izleyin, aksi takdirde sizin oluşturmanız gerekir.\n- Tüm bu makale insmod aracı ile ek GRUB2 modülleri eklemenin mümkün olduğunu varsaymaktadır. #Shim-kilidi bölümünde tartışıldığı gibi, Secure Boot'un etkin olduğu UEFI sistemlerinde durum bu şekilde değildir. Standart GRUB EFI dosyası grubx64.efi içerisinde bulunmayan herhangi bir ek GRUB modülünü Güvenli Önyükleme sisteminde kullanmak istiyorsanız, GRUB EFI grubx64.efi'yi grub-mkstandalone aracı ile yeniden oluşturmanız veya ek GRUB modülleri için dahili grub-install aracını kullanarak GRUB'u yeniden yüklemeniz gerekir.\n\n"
    },
    {
      "title": "Kurulum",
      "level": 3,
      "content": "- UEFI yazılımları, üreticilere göre tutarlı bir şekilde uygulanmamış olabilir. Aşağıda açıklanan prosedür geniş bir UEFI sistemi yelpazesinde çalışması için tasarlanmıştır; ancak bu yöntemi uygulamanıza rağmen sorun yaşayanlar, ayrıntılı bilgileri ve mümkünse bulunan geçici çözümleri paylaşmaları teşvik edilir. Böyle durumlar için bir EFI örnekleri makalesi sağlanmıştır.\n- Bu bölüm, GRUB'u x64 (64-bit) UEFI için kurduğunuzu varsayar. IA32 (32-bit) UEFI (32-bit CPU'larla karıştırılmamalıdır) için uygun yerlerde x86_64-efi yerine i386-efi kullanın. UEFI'nizin bit'ini öğrenmek için Aygıt yazılımı bit'inin kontrolü talimatlarını takip edin.\n\nİlk olarak, grub ve efibootmgr paketlerini yükleyin: GRUB önyükleyicidir, efibootmgr ise GRUB kurulum betiği tarafından NVRAM'e önyükleme girişlerini yazmak için kullanılır.\n\nDaha sonra, GRUB'u diskinize kurmak için aşağıdaki adımları takip edin:\n\n1. EFI sistem bölümünü bağlayın ve bu bölümün geri kalanında esp ile bağlama noktasını değiştirin.\n1. Bir önyükleyici tanımlayıcı seçin, burada GRUB olarak adlandırılmıştır. Bu isimde bir dizin esp/EFI/ içinde oluşturulacak ve EFI ikili dosyasını depolayacaktır ve bu isim UEFI önyükleme menüsünde GRUB önyükleme girişini tanımlamak için görünecektir.\n1. GRUB EFI uygulamasını grubx64.efi esp/EFI/GRUB/ içine kurmak ve modüllerini /boot/grub/x86_64-efi/ içine kurmak için aşağıdaki komutu çalıştırın.\n\n- Paketleri kurduğunuzdan ve grub-install komutunu GRUB'un önyükleyici olarak kurulacağı sistemden çalıştırdığınızdan emin olun. Yani, canlı kurulum ortamından önyükleme yapıyorsanız, grub-install komutunu çalıştırırken chroot içinde olmanız gerekir. Bir nedenle grub-install'i kurulu sistem dışından çalıştırmanız gerekirse, --boot-directory= seçeneğine bağlı /boot dizininin yolunu ekleyin, örneğin --boot-directory=/mnt/boot.\n- Bazı anakartlar, bootloader-id içinde boşluk olan değerleri işleyemez.\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB\n```\n\nYukarıdaki kurulum tamamlandığında, ana GRUB dizini /boot/grub/ içinde bulunur. Alternatif bir konum belirtme hakkında bilgi için Alternatif yükleme yöntemi#ipuçları ve püf noktaları kısmını okuyun. Ayrıca grub-install'in firmware boot yöneticisinde bir giriş oluşturmayı da denediğini unutmayın. Yukarıdaki örnekte GRUB olarak adlandırılmıştır – eğer önyükleme girişleriniz doluysa bu işlem başarısız olacaktır; gereksiz girişleri kaldırmak için efibootmgr kullanın.\n\nKonfigürasyonu tamamladıktan sonra Ana yapılandırma dosyasını oluşturun adımını atlamayın.\n\n- --efi-directory ve --bootloader-id GRUB UEFI'ye özgüdür, --efi-directory --root-directory'yi, artık kullanılmayan bir seçeneği değiştirir.\n- grub-install komutunda bir device_path seçeneğinin (örneğin: /dev/sda) olmamasını fark edebilirsiniz. Aslında, sağlanan herhangi bir device_path GRUB UEFI kurulum betiği tarafından yoksayılır. Gerçekten de, UEFI önyükleyicileri bir MBR önyükleme kodu veya bölüm önyükleme sektörü kullanmaz.\n\nSorun yaşarsanız UEFI sorun giderme kısmına bakın. Ayrıca GRUB/Tips and tricks#UEFI further reading bölümüne göz atın.\n\n"
    },
    {
      "title": "Güvenli Önyükleme Desteği",
      "level": 3,
      "content": "GRUB, CA anahtarları veya shim kullanarak güvenli önyüklemeyi tamamen destekler, ancak hangi yöntemi kullanacağınıza bağlı olarak kurulum komutu farklıdır.\n\n- Güvenli Önyükleme'yi yanlış yapılandırmak sisteminizi önyüklenemez hale getirebilir. Güvenli önyüklemeyi etkinleştirdikten sonra herhangi bir nedenle önyükleme yapamazsanız, firmware'de güvenli önyüklemeyi devre dışı bırakmalı ve sistemi yeniden başlatmalısınız.\n- Önyükleyicinizde gereksiz modüller yüklemek bir güvenlik riski oluşturabilir, bu komutları yalnızca ihtiyacınız varsa kullanın.\n\n"
    },
    {
      "title": "CA Anahtarları",
      "level": 4,
      "content": "CA Anahtarlarını kullanmak için komut şu şekildedir:\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --bootloader-id=GRUB --modules=\"tpm\" --disable-shim-lock\n```\n\n"
    },
    {
      "title": "Shim-lock",
      "level": 4,
      "content": "Shim-lock kullanırken, GRUB'un güvenli önyükleme modunda başarılı bir şekilde önyüklenebilmesi için EFI ikili dosyasının vmlinuz ve initramfs görüntülerini içeren dosya sistemini okumak için gerekli tüm modülleri içermesi gerekir.\n\nGRUB sürüm 2.06.r261.g2f4430cc0'dan itibaren, güvenli önyükleme modunda insmod ile modül yüklemek artık izin verilmemektedir, çünkü bu, rastgele kod eklememe beklentisini ihlal eder. GRUB modülleri EFI ikili dosyasına gömülmemişse ve GRUB bunları eklemeye/insmod'a çalışırsa, GRUB şu mesajla önyükleme yapamayacaktır:\n\n```\nhata: güvenli önyükleme politikası tarafından yasaklandı\n```\n\nUbuntu, resmi derleme betiğine göre, imzalı GRUB EFI ikili dosyasına grubx64.efi aşağıdaki GRUB modüllerini gömer:\n\n- temel modüller, bir CD'den veya basit bir bölümlendirilmiş diskten önyükleme için gerekli olanlar: all_video, boot, btrfs, cat, chain, configfile, echo, efifwsetup, efinet, ext2, fat, font, gettext, gfxmenu, gfxterm, gfxterm_background, gzio, halt, help, hfsplus, iso9660, jpeg, keystatus, loadenv, loopback, linux, ls, lsefi, lsefimmap, lsefisystab, lssal, memdisk, minicmd, normal, ntfs, part_apple, part_msdos, part_gpt, password_pbkdf2, png, probe, reboot, regexp, search, search_fs_uuid, search_fs_file, search_label, sleep, smbios, squash4, test, true, video, xfs, zfs, zfscrypt, zfsinfo\n- platforma özgü modüller, x86_64-efi mimarisi için, örneğin: play: önyükleme sırasında sesleri oynatmak için cpuid: CPU'yu önyükleme sırasında okumak için tpm: Ölçülen Önyükleme / Güvenilir Platform Modülleri desteği için\n- gelişmiş modüller, şu modüllerden oluşur: cryptodisk: düz mod şifrelenmiş disklerden önyükleme yapmak için gcry_algorithm: belirli hash ve şifreleme algoritmalarını desteklemek için luks: LUKS-şifrelenmiş disklerden önyükleme yapmak için lvm: LVM mantıksal hacim disklerinden önyükleme yapmak için mdraid09, mdraid1x, raid5rec, raid6rec: RAID sanal disklerden önyükleme yapmak için\n\n- play: önyükleme sırasında sesleri oynatmak için\n- cpuid: CPU'yu önyükleme sırasında okumak için\n- tpm: Ölçülen Önyükleme / Güvenilir Platform Modülleri desteği için\n\n- cryptodisk: düz mod şifrelenmiş disklerden önyükleme yapmak için\n- gcry_algorithm: belirli hash ve şifreleme algoritmalarını desteklemek için\n- luks: LUKS-şifrelenmiş disklerden önyükleme yapmak için\n- lvm: LVM mantıksal hacim disklerinden önyükleme yapmak için\n- mdraid09, mdraid1x, raid5rec, raid6rec: RAID sanal disklerden önyükleme yapmak için\n\nGRUB modüllerinizin listesini GRUB_MODULES olarak adlandırdığımız bir shell değişkeni biçiminde oluşturmalısınız. En güncel Ubuntu betiğini kullanarak temel alabilir ve sisteminizde gereksiz olan modülleri çıkarabilirsiniz. Modülleri atlamak, önyükleme sürecini nispeten hızlandırır ve ESP bölümünde bazı alan kazandırır.\n\nAyrıca EFI ikili dosyasına, GRUB'un UEFI shim yükleyicisinden başlatıldığında güvenliği artırmak için bir Secure Boot Advanced Targeting (SBAT) dosyası/bölümü eklemeniz gerekir. Bu SBAT dosyası/bölümü, GRUB ikili dosyasının (sürüm, bakıcı, geliştirici, yukarı akış URL'si) meta verilerini içerir ve shim'in, güvenlik açıkları olan belirli GRUB sürümlerini yüklemeyi engellemesini kolaylaştırır [1][2], shim'in UEFI shim önyükleyici güvenli önyükleme yaşam döngüsü iyileştirmeleri belgesinde açıklandığı gibi.\n\nİlk aşama UEFI önyükleyici shim, grubx64.efi'yi başlatmayı başarısız kılacaktır eğer grubx64.efi'den SBAT bölümü eksikse!\n\nGRUB yüklendiyse, örnek bir SBAT .csv dosyası /usr/share/grub/sbat.csv altında sağlanır.\n\nGRUB'u sağlanan /usr/share/grub/sbat.csv dosyası ve gereken tüm GRUB_MODULES ile yeniden yükleyin ve imzalayın:\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --modules=${GRUB_MODULES} --sbat /usr/share/grub/sbat.csv\n# sbsign --key MOK.key --cert MOK.crt --output esp/EFI/GRUB/grubx64.efi esp/EFI/GRUB/grubx64.efi\n# cp esp/EFI/GRUB/grubx64.efi esp/EFI/BOOT/grubx64.efi\n```\n\nYeniden başlatın, MokManager içinde anahtarı seçin ve Güvenli Önyükleme çalışmalıdır.\n\n"
    },
    {
      "title": "Güvenli Önyükleme Kullanımı",
      "level": 4,
      "content": "Kurulumdan sonra Secure Boot#Implementing Secure Boot kısmında güvenli önyüklemeyi etkinleştirme talimatlarını takip edin.\n\nEğer CA Anahtarları yöntemini kullanıyorsanız, anahtar yönetimi, kaydını yapma ve dosya imzalama işlemleri sbctl kullanılarak otomatikleştirilebilir, detaylar için Secure Boot#Assisted process with sbctl kısmına bakın.\n\n"
    },
    {
      "title": "GUID Bölüm Tablosu (GPT) özgü talimatlar",
      "level": 3,
      "content": "Bir BIOS/GPT yapılandırmasında, bir BIOS önyükleme bölümü gereklidir. GRUB, core.img dosyasını bu bölüme gömer.\n\n- Bu yöntemi denemeden önce, tüm sistemlerin bu bölümleme şemasını desteklemeyebileceğini unutmayın. Daha fazla bilgi için Partitioning#GUID Partition Table kısmına bakın.\n- BIOS/GPT yapılandırmasında GRUB'un yalnızca BIOS önyükleme bölümüne ihtiyacı vardır. BIOS/MBR yapılandırmasında, GRUB core.img'yi MBR sonrası boşluk kullanarak gömer. Ancak GPT'de, ilk bölümden önce garanti edilmiş kullanılmayan alan bulunmamaktadır.\n- UEFI sistemleri için bu ekstra bölüme gerek yoktur, çünkü bu durumda önyükleme sektörlerinin gömülmesi gerçekleşmez. Ancak, UEFI sistemleri yine de bir EFI sistem bölümü gerektirir.\n\nBir mebibyte bölümü (+1M fdisk veya gdisk ile) dosya sistemi olmadan ve bölüm türü GUID 21686148-6449-6E6F-744E-656564454649 ile oluşturun.\n\n- fdisk için bölüm türü BIOS boot'u seçin.\n- gdisk için bölüm türü kodu ef02'yi seçin.\n- parted için bölümde bios_grub bayrağını ayarlayın/etkinleştirin.\n\nBu bölüm herhangi bir sıra konumunda olabilir ancak diskin ilk 2 TiB'inde olmalıdır. Bu bölüm, GRUB kurulumu öncesinde oluşturulmalıdır. Bölüm hazır olduğunda, aşağıdaki talimatlara göre önyükleyiciyi kurun.\n\nİlk bölümden önceki boşluk BIOS önyükleme bölümü olarak da kullanılabilir, ancak GPT hizalama spesifikasyonunun dışında olacaktır. Bölüm düzenli olarak erişilmeyeceğinden performans sorunları dikkate alınmayabilir, ancak bazı disk yardımcı programları uyarı verebilir. fdisk veya gdisk içinde, sektörden 34 başlayarak ve 2047'ye kadar genişleyen bir yeni bölüm oluşturun ve türü ayarlayın. Görülebilir bölümlerin tabanda başlaması için bu bölümü en sona eklemeyi düşünebilirsiniz.\n\n"
    },
    {
      "title": "Master Boot Record (MBR) özgü talimatlar",
      "level": 3,
      "content": "Çoğu MBR bölümlendirilmiş sistemlerde, 512 baytlık MBR bölgesinin ardından ve ilk bölümün başlangıcından önceki boşluk genellikle 31 KiB'dir, eğer DOS uyumlu silindir hizalama sorunları bölüm tablosunda çözülmüşse. Ancak, GRUB'un core.img'sini gömmek için yaklaşık 1 ila 2 MiB'lik bir boşluk önerilir (FS#24103). GRUB'un core.img'ini gömmek için bu alanı sağlamak ve diğer 512-bayt sektör sorunlarını karşılamak için 1 MiB bölüm hizalaması destekleyen bir bölümleme aracı kullanmanız tavsiye edilir.\n\n"
    },
    {
      "title": "Kurulum",
      "level": 3,
      "content": "grub paketini Install edin. (Zaten kurulu ise grub-legacyAUR'yi değiştirecektir.) Ardından:\n\n```\n# grub-install --target=i386-pc /dev/sdX\n```\n\nburada i386-pc kasıtlı olarak kullanılır, gerçek mimarinizden bağımsız olarak ve /dev/sdX GRUB'un kurulacağı disk (bölüm değil) olmalıdır. Örneğin /dev/sda veya /dev/nvme0n1, veya /dev/mmcblk0. Blok cihaz adlandırma şeması hakkında daha fazla bilgi için Device file (Türkçe)#Blok aygıt isimleri kısmına bakın.\n\nŞimdi ana yapılandırma dosyasını oluşturmanız gerekiyor.\n\nEğer /boot için LVM kullanıyorsanız, GRUB'u birden fazla fiziksel diske kurabilirsiniz.\n\ngrub-install(8) ve GRUB Kılavuzu üzerinde grub-install komutu hakkında daha fazla detay için bakın.\n\n"
    },
    {
      "title": "Yapılandırma",
      "level": 2,
      "content": "Kurulu bir sistemde, GRUB her önyüklemede /boot/grub/grub.cfg yapılandırma dosyasını yükler. #Üretilmiş grub.cfg kısmını bir araç kullanarak veya #Özel grub.cfg kısmını manuel olarak oluşturmak için takip edebilirsiniz.\n\n"
    },
    {
      "title": "Üretilmiş grub.cfg",
      "level": 3,
      "content": "Bu bölüm yalnızca /etc/default/grub yapılandırma dosyasını düzenlemeyi kapsar. Daha fazla bilgi için GRUB/Tips and tricks kısmına bakın.\n\n"
    },
    {
      "title": "Ana yapılandırma dosyasını oluştur",
      "level": 4,
      "content": "Kurulumdan sonra, ana yapılandırma dosyası /boot/grub/grub.cfg oluşturulmalıdır. Oluşturma süreci, /etc/default/grub ve /etc/grub.d/ dosyalarındaki çeşitli seçeneklerden etkilenebilir. /etc/default/grub içindeki seçeneklerin listesi ve her birinin kısa açıklaması için GNU'nun dokümantasyonuna bakın.\n\nEk bir yapılandırma yapmadıysanız, otomatik oluşturma işlemi, yapılandırma dosyası için sistemin kök dosya sistemini belirleyecektir. Bunun başarılı olması için sistemin ya önyüklenmiş ya da chroot edilmiş olması önemlidir.\n\n- Varsayılan dosya yolu /boot/grub/grub.cfg'dir, /boot/grub/i386-pc/grub.cfg değil.\n- Eğer grub-mkconfig i bir chroot veya systemd-nspawn konteynerinde çalıştırıyorsanız, grub-probe: error: failed to get canonical path of /dev/sdaX hatası alabilirsiniz. Bu durumda, BBS gönderisinde açıklandığı gibi chroot (Türkçe)#arch-chroot'un kullanımı kullanmayı deneyin.\n\ngrub-mkconfig aracını kullanarak /boot/grub/grub.cfg dosyasını oluşturun:\n\n```\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\nVarsayılan olarak, oluşturma betikleri tüm kurulu Arch Linux kernel'leri için menü girişlerini otomatik olarak ekler.\n\n- Bir kernel kurduktan veya kaldırdıktan sonra, yukarıdaki grub-mkconfig komutunu tekrar çalıştırmanız yeterlidir.\n- Birden fazla GRUB girişini yönetme konusunda ipuçları için, örneğin hem linux hem de linux-lts çekirdeklerini kullanıyorsanız, GRUB/Tips and tricks#Multiple entries bölümüne bakın.\n\nDiğer kurulu işletim sistemleri için otomatik olarak giriş eklemek için, #Diğer işletim sistemlerini algılama bölümüne bakın.\n\nEkstra özel menü girişleri eklemek için /etc/grub.d/40_custom dosyasını düzenleyebilir ve /boot/grub/grub.cfg dosyasını yeniden oluşturabilirsiniz. Ya da /boot/grub/custom.cfg dosyasını oluşturup buraya ekleyebilirsiniz. /boot/grub/custom.cfg dosyasındaki değişiklikler grub-mkconfig'i yeniden çalıştırmayı gerektirmez, çünkü /etc/grub.d/41_custom gerekli source ifadesini oluşturulan konfigürasyon dosyasına ekler.\n\nÖzel menü girişi örnekleri için #Önyükleme menüsü girişi örnekleri kısmına bakın.\n\n"
    },
    {
      "title": "Diğer işletim sistemlerini algılama",
      "level": 4,
      "content": "grub-mkconfig'in diğer kurulu sistemleri aramasını ve menüye otomatik olarak eklemesini sağlamak için, os-prober paketini install edin ve diğer sistemlerin önyüklediği bölümleri mount edin. Ardından grub-mkconfig komutunu yeniden çalıştırın. Aşağıdaki çıktıyı alırsanız: Warning: os-prober will not be executed to detect other bootable partitions, /etc/default/grub dosyasını düzenleyin ve ekleyin/yorum satırı haline getirin:\n\n```\nGRUB_DISABLE_OS_PROBER=false\n```\n\nSonra tekrar deneyin.\n\n- Tam bağlama noktası önemli değildir, os-prober mtab'i okuyarak önyüklenebilir girişleri aramak için yerleri tanımlar.\n- Diğer işletim sistemlerini her zaman dahil etmek için grub-mkconfig'i her çalıştırdığınızda bölümleri bağlamayı unutmayın.\n- os-prober bir chroot içinde çalışırken düzgün çalışmayabilir. Bu durumu yaşarsanız, sistemi yeniden başlattıktan sonra tekrar deneyin.\n\nUEFI modunda kurulu Windows için, Windows Boot Manager'ı (bootmgfw.efi) içeren EFI sistem bölümü'nün bağlı olduğundan emin olun. Bunu tespit etmek ve bir giriş oluşturmak için os-prober'i root olarak çalıştırın.\n\nBIOS modunda kurulu Windows için, Windows system partition'ını bağlayın (dosya sistemi etiketi System Reserved veya SYSTEM olmalıdır). Bunu tespit etmek ve bir giriş oluşturmak için os-prober'i root olarak çalıştırın.\n\nNote: **This article or section is out of date.** This article or section is out of date.\n\n- NTFS bölümleri varsayılan Linux sürücüler ile bağlandığında her zaman algılanmayabilir. Eğer GRUB bunu algılamıyorsa, NTFS-3G'yi yüklemeyi ve tekrar bağlamayı deneyin.\n\nNote: **This article or section is out of date.** This article or section is out of date.\n\nThis article or section is out of date.\n\n- Şifrelenmiş Windows bölümlerinin bağlanmadan önce şifrelerinin çözülmesi gerekebilir. BitLocker için, bu cryptsetup veya dislockerAUR ile yapılabilir. Bu, os-prober'in doğru girişi eklemesi için yeterli olmalıdır.\n\n"
    },
    {
      "title": "Ek Argümanlar",
      "level": 4,
      "content": "Linux görüntüsüne özel ek argümanlar geçirmek için, GRUB_CMDLINE_LINUX ve GRUB_CMDLINE_LINUX_DEFAULT değişkenlerini /etc/default/grub dosyasında ayarlayabilirsiniz. İkisi bir araya getirilir ve düzenli önyükleme girişleri oluşturulurken çekirdeğe iletilir. Recovery önyükleme girişi için, yalnızca GRUB_CMDLINE_LINUX kullanılır.\n\nHer ikisini de kullanmak zorunlu değildir, ancak faydalı olabilir. Örneğin, GRUB_CMDLINE_LINUX_DEFAULT=\"resume=UUID=swap-bölümünün-uuid quiet\" şeklinde kullanabilirsiniz, burada swap-bölümünün-uuid swap bölümünüzün UUID'sidir ve uykudan sonra devam etmesini sağlar. Bu, geri yükleme önyükleme girişi oluşturur, ancak devam etmeyi ve quiet'in çekirdek mesajlarını bastırmasını içermez. Diğer (düzenli) menü girişleri ise bu seçenekleri içerebilir.\n\nVarsayılan olarak, grub-mkconfig konfigürasyon için kök dosya sisteminin UUID'sini belirler. Bunu devre dışı bırakmak için, GRUB_DISABLE_LINUX_UUID=true satırını yorum satırından çıkarın.\n\nGRUB geri yükleme girişini oluşturmak için GRUB_DISABLE_RECOVERY'in true olarak ayarlanmadığından emin olun /etc/default/grub dosyasında.\n\nDaha fazla bilgi için Kernel parameters kısmına bakın.\n\n"
    },
    {
      "title": "Üst Düzey Menü Girişini Ayarlama",
      "level": 4,
      "content": "Varsayılan olarak, grub-mkconfig dahil edilen çekirdekleri sort -V kullanarak sıralar ve bu listede ilk çekirdeği üst düzey giriş olarak kullanır. Bu, örneğin, /boot/vmlinuz-linux-lts'nin /boot/vmlinuz-linux'ten önce sıralanmış olması durumunda, hem linux-lts hem de linux kuruluysa, LTS çekirdeğinin üst düzey menü girişi olacağı anlamına gelir ve bu istenmeyebilir. Bunu, GRUB_TOP_LEVEL=path_to_kernel\" ile /etc/default/grub dosyasında belirterek geçersiz kılabilirsiniz. Örneğin, düzenli çekirdeğin üst düzey menü girişi olmasını istiyorsanız, GRUB_TOP_LEVEL=\"/boot/vmlinuz-linux\" kullanabilirsiniz.\n\n"
    },
    {
      "title": "LVM",
      "level": 4,
      "content": "Eğer /boot veya / kök bölümü için LVM kullanıyorsanız, lvm modülünün önceden yüklenmiş olduğundan emin olun:\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_PRELOAD_MODULES=\"... lvm\"\n```\n\n"
    },
    {
      "title": "RAID",
      "level": 4,
      "content": "GRUB, RAID hacimlerinin yönetimini kolaylaştırır. Hacmi yerel olarak adresleyebilmeniz için mdraid09 veya mdraid1x GRUB modüllerini yüklemeniz gerekir:\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_PRELOAD_MODULES=\"... mdraid09 mdraid1x\"\n```\n\nÖrneğin, /dev/md0 şu şekilde olur:\n\n```\nset root=(md/0)\n```\n\nbir bölümlenmiş RAID hacmi (örneğin /dev/md0p1) ise şu şekilde olur:\n\n```\nset root=(md/0,1)\n```\n\nRAID1 olarak /boot bölümünü kullanıyorsanız (veya /boot'ün RAID1 kök bölümünde bulunduğu bir durumda), BIOS sistemlerinde, grub-install komutunu her iki diskte de çalıştırın, örneğin:\n\n```\n# grub-install --target=i386-pc --debug /dev/sda\n# grub-install --target=i386-pc --debug /dev/sdb\n```\n\nBurada RAID 1 dizisi /boot'ü /dev/sda ve /dev/sdb üzerinde barındırmaktadır.\n\n"
    },
    {
      "title": "Şifreli /boot",
      "level": 4,
      "content": "GRUB, şifreli /boot ile önyükleme yapma için özel bir destek sağlar. Bu, bir LUKS blok aygıtını açarak yapılandırmasını okumak ve herhangi bir initramfs ve kernel'i yüklemek için yapılır. Bu seçenek, şifrelenmemiş boot bölümü sorununu çözmeyi amaçlar.\n\nNote: **ayrı bir bölümde** \n\nBu özelliği etkinleştirmek için, /boot'ın bulunduğu bölümü normal şekilde LUKS ile şifreleyin. Ardından /etc/default/grub dosyasına aşağıdaki seçeneği ekleyin:\n\n```\n/etc/default/grub\n```\n\n```\nGRUB_ENABLE_CRYPTODISK=y\n```\n\nBu seçenek, grub core.img'yi oluşturmak için grub-install tarafından kullanılır.\n\nBu seçeneği değiştirdikten veya bölümü şifreledikten sonra GRUB'u yüklediğinizden emin olun.\n\nEk bir değişiklik yapmadan, GRUB'un /boot bağlama noktasını erken önyüklemede açmak için iki kez şifre girilmesini istersiniz; ilki GRUB için, ikincisi ise initramfs tarafından kök dosya sisteminin kendisini açmak içindir. Bunu önlemek için bir anahtar dosyası kullanabilirsiniz.\n\n- Ana yapılandırma dosyasını üretmek istiyorsanız, /boot'ın bağlandığından emin olun.\n- /boot bağlama noktasını içeren sistem güncellemelerini gerçekleştirmek için, güncelleme yapmadan önce şifreli /boot'ın açıldığından ve bağlandığından emin olun. Ayrı bir /boot bölümü ile bu, crypttab kullanılarak ve bir anahtar dosyası kullanılarak önyükleme sırasında otomatik olarak yapılabilir.\n\n- Eğer özel bir tuş haritası kullanıyorsanız, varsayılan GRUB kurulumu bunu bilmez. Bu, LUKS blok aygıtını açmak için şifreyi nasıl gireceğinizle ilgilidir. GRUB/Tips and tricks#Manual configuration of core image for early boot'e bakın.\n- Şifreyi girme isteminin görüntülenmesiyle ilgili sorunlar yaşarsanız (cryptouuid, cryptodisk veya \"cihaz bulunamadı\" hataları), GRUB'u yeniden yüklemeyi ve --modules=\"part_gpt part_msdos\" seçeneğini grub-install komutunuza eklemeyi deneyin.\n\nLUKS desteği ile önyüklenebilir bir GRUB görüntüsü oluşturmak için grub-install'i #Kurulum bölümünde açıklandığı şekilde kullanın. Şu uyarılara dikkat edin:\n\n- İlk LUKS2 desteği GRUB 2.06'ya eklendi, ancak GRUB 2.12rc1'de sadece kısmi sınırlamalarla ele alındı. Daha fazla bilgi için GRUB hata #55093'a bakın.\n- GRUB 2.12rc1'den itibaren, grub-install LUKS2'yi açmak için bir çekirdek görüntüsü oluşturabilir. Ancak, yalnızca PBKDF2'yi destekler, Argon2'yi değil.\n- Argon2id (cryptsetup varsayılanı) ve Argon2i PBKDF'ler desteklenmemektedir (GRUB hata #59409), yalnızca PBKDF2 desteklenir.\n\nBir geçersiz şifre girerseniz ve GRUB kurtarma kabuğuna düşerseniz, cryptomount -a komutunu kullanarak tüm (umarım yalnızca bir) şifreli bölümü bağlamayı veya cryptomount -u $crypto_uuid komutunu kullanarak belirli bir bölümü bağlamayı deneyin. Ardından insmod normal ve normal komutlarını kullanmaya devam edin.\n\nDoğru şifre girerseniz ancak hemen Invalid passphrase hatası alırsanız, doğru kriptografik modüllerin belirtildiğinden emin olun. cryptsetup luksDump /dev/nvme0n1p2 komutunu kullanın ve hash fonksiyonunun (SHA-256, SHA-512) yüklü modüllerle (gcry_sha256, gcry_sha512) eşleşip eşleşmediğini ve PBKDF algoritmasının pbkdf2 olup olmadığını kontrol edin. Hash ve PBKDF algoritmaları mevcut anahtarlar için cryptsetup luksConvertKey --hash sha256 --pbkdf pbkdf2 /dev/nvme0n1p2 komutuyla değiştirilebilir. Normal koşullarda, şifrenin işlenmesi birkaç saniye sürecektir.\n\n"
    },
    {
      "title": "Özel grub.cfg",
      "level": 3,
      "content": "Bu bölüm, grub-mkconfige güvenmeden /boot/grub/grub.cfg'de GRUB önyükleme girişlerinin manuel olarak oluşturulmasını açıklar.\n\nTemel bir GRUB yapılandırma dosyası şu seçenekleri kullanır:\n\n- (hdX,Y) disk Xteki bölüm Yyi belirtir, bölüm numaraları 1'den başlar, disk numaraları 0'dan başlar\n- set default=N zaman aşımından sonra kullanıcı eylemi için seçilen varsayılan önyükleme girişini belirtir\n- set timeout=M varsayılan önyüklemeyi başlatmadan önce kullanıcı seçiminde beklenen M süresini belirtir\n- menuentry \"title\" {entry options} title başlığına sahip bir önyükleme girişini belirtir\n- set root=(hdX,Y) önyükleme bölümünü ayarlar, çekirdek ve GRUB modüllerinin saklandığı yer (boot ayrı bir bölüm olmak zorunda değildir ve basitçe \"kök\" bölümünün altında bir dizin olabilir (/))\n\n"
    },
    {
      "title": "LoaderDevicePartUUID",
      "level": 4,
      "content": "GRUB'un systemd-gpt-auto-generator(8) tarafından GPT bölüm otomatik montajı için gerekli olan LoaderDevicePartUUID UEFI değişkenini ayarlaması için, grub.cfg dosyasına bli modülünü yükleyin:\n\n```\nif [ \"$grub_platform\" = \"efi\" ]; then\n  insmod bli\nfi\n```\n\n"
    },
    {
      "title": "Önyükleme menüsü girişi örnekleri",
      "level": 4,
      "content": "Birden fazla GRUB girişini yönetme ipuçları için, örneğin hem linux hem de linux-lts çekirdeklerini kullanırken, GRUB/Tips and tricks#Multiple entries'e bakın.\n\nArchiso ve Archboot önyükleme menüsü girişleri için Multiboot USB drive#Boot entries'e bakın.\n\n```\nmenuentry \"Sistem kapalı\" {\n\techo \"Sistem kapanıyor...\"\n\thalt\n}\n```\n\n```\nmenuentry \"Sistem yeniden başlat\" {\n\techo \"Sistem yeniden başlatılıyor...\"\n\treboot\n}\n```\n\n```\nif [ ${grub_platform} == \"efi\" ]; then\n\tmenuentry 'UEFI Firmware Settings' --id 'uefi-firmware' {\n\t\tfwsetup\n\t}\nfi\n```\n\nUEFI modunda başlatıldığında, GRUB diğer EFI ikili dosyalarını zincirleyebilir.\n\n```\nif [ ${grub_platform} == \"efi\" ]; then\n\tUEFI'ye özel menü girişlerini buraya ekleyin\nfi\n```\n\nUEFI Kabuk'u EFI sistem bölümünün köküne yerleştirerek ve bu menü girişini ekleyerek başlatabilirsiniz:\n\n```\nmenuentry \"UEFI Shell\" {\n\tinsmod fat\n\tinsmod chain\n\tsearch --no-floppy --set=root --file /shellx64.efi\n\tchainloader /shellx64.efi\n}\n```\n\ngdisk EFI uygulamasını indirin ve gdisk_x64.efi dosyasını esp/EFI/tools/ dizinine kopyalayın.\n\n```\nmenuentry \"gdisk\" {\n\tinsmod fat\n\tinsmod chain\n\tsearch --no-floppy --set=root --file /EFI/tools/gdisk_x64.efi\n\tchainloader /EFI/tools/gdisk_x64.efi\n}\n```\n\nEğer unified kernel image oluşturduysanız ve bunu Secure Boot veya diğer yöntemlerle sağladıysanız, önyükleme menüsüne ekleyebilirsiniz. Örneğin:\n\n```\nmenuentry \"Arch Linux\" {\n\tinsmod fat\n\tinsmod chain\n\tsearch --no-floppy --set=root --fs-uuid FILESYSTEM_UUID\n\tchainloader /EFI/Linux/arch-linux.efi\n}\n```\n\nDiğer dağıtımın sda2 bölümünde olduğunu varsayalım:\n\n```\nmenuentry \"Diğer Linux\" {\n\tset root=(hd0,2)\n\tlinux /boot/vmlinuz (gerektiği gibi diğer seçenekleri ekleyin)\n\tinitrd /boot/initrd.img (diğer çekirdek bir tane kullanıyorsa/gerekiyorsa)\n}\n```\n\nAlternatif olarak GRUB'un doğru bölümü UUID veya dosya sistemi etiketi ile aramasına izin verebilirsiniz:\n\n```\nmenuentry \"Diğer Linux\" {\n        # UUID'nin 763A-9CB6 olduğunu varsayarak\n\tsearch --no-floppy --set=root --fs-uuid 763A-9CB6\n\n        # OTHER_LINUX etiketi ile arama (bölüm etiketinin belirsiz olmadığından emin olun)\n        #search --no-floppy --set=root --label OTHER_LINUX\n\n\tlinux /boot/vmlinuz (gerektiği gibi diğer seçenekleri ekleyin, örneğin: root=UUID=763A-9CB6)\n\tinitrd /boot/initrd.img (diğer çekirdek bir tane kullanıyorsa/gerekiyorsa)\n}\n```\n\nDiğer dağıtımda geçerli bir /boot klasörü, yüklenmiş GRUB, grub.cfg, çekirdek ve initramfs varsa, GRUB'u bu diğer grub.cfg dosyalarını önyükleme sırasında dinamik olarak yüklemesi için talimat verebilirsiniz. Örneğin, hd0 ve dördüncü GPT bölümü için:\n\n```\nmenuentry \"configfile hd0,gpt4\"  {\n        insmod part_gpt\n        insmod btrfs\n        insmod ext2\n        set root='hd0,gpt4'\n        configfile /boot/grub/grub.cfg\n}\n```\n\nBu girişi seçtiğinizde, GRUB diğer bölümden grub.cfg dosyasını yükler ve o menüyü görüntüler. Dosyadaki komutlarla yapılan ortam değişiklikleri configfile döndüğünde korunmaz. İlk GRUB menüsüne dönmek için Esc tuşuna basın.\n\nBu mod, Windows önyükleyicisinin bulunduğu yeri belirler ve menü girişi seçildiğinde GRUB'dan sonra zincirler. Buradaki ana görev EFI sistem bölümünü bulmak ve önyükleyiciyi buradan çalıştırmaktır.\n\n```\nif [ \"${grub_platform}\" == \"efi\" ]; then\n\tmenuentry \"Microsoft Windows Vista/7/8/8.1 UEFI/GPT\" {\n\t\tinsmod part_gpt\n\t\tinsmod fat\n\t\tinsmod chain\n\t\tsearch --no-floppy --fs-uuid --set=root $hints_string $fs_uuid\n\t\tchainloader /EFI/Microsoft/Boot/bootmgfw.efi\n\t}\nfi\n```\n\nBurada $hints_string ve $fs_uuid aşağıdaki iki komutla elde edilir.\n\n$fs_uuid komutu EFI sistem bölümünün UUID'sini belirler:\n\n```\n# grub-probe --target=fs_uuid esp/EFI/Microsoft/Boot/bootmgfw.efi\n```\n\n```\n1ce5-7f28\n```\n\nAlternatif olarak lsblk --fs komutunu çalıştırarak EFI sistem bölümünün UUID'sini buradan okuyabilirsiniz.\n\n$hints_string komutu EFI sistem bölümünün yerini belirler, bu durumda sabit disk 0:\n\n```\n# grub-probe --target=hints_string esp/EFI/Microsoft/Boot/bootmgfw.efi\n```\n\n```\n--hint-bios=hd0,gpt1 --hint-efi=hd0,gpt1 --hint-baremetal=ahci0,gpt1\n```\n\nBu iki komut, Windows'un kullandığı ESP'nin esp dizininde montelenmiş olduğunu varsayar. Windows'un EFI dosyası yolunda büyük/küçük harf farklılıkları olabilir.\n\nNote: **sistem bölümü** \n\nBu bölümde, Windows bölümünüzün /dev/sda1 olduğunu varsayarız. Farklı bir bölüm varsa, her hd0,msdos1 örneğini değiştirin.\n\nHer iki örnekte de XXXX-XXXX dosya sistemi UUID'sidir, lsblk --fs komutu ile bulunabilir.\n\nWindows Vista/7/8/8.1/10 için:\n\n```\nif [ \"${grub_platform}\" == \"pc\" ]; then\n\tmenuentry \"Microsoft Windows Vista/7/8/8.1/10 BIOS/MBR\" {\n\t\tinsmod part_msdos\n\t\tinsmod ntfs\n\t\tinsmod ntldr\n\t\tsearch --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 XXXX-XXXX\n\t\tntldr /bootmgr\n\t}\nfi\n```\n\nWindows XP için:\n\n```\nif [ \"${grub_platform}\" == \"pc\" ]; then\n\tmenuentry \"Microsoft Windows XP\" {\n\t\tinsmod part_msdos\n\t\tinsmod ntfs\n\t\tinsmod ntldr\n\t\tsearch --no-floppy --fs-uuid --set=root --hint-bios=hd0,msdos1 --hint-efi=hd0,msdos1 --hint-baremetal=ahci0,msdos1 XXXX-XXXX\n\t\tntldr /ntldr\n\t}\nfi\n```\n\nNote: **YALNIZCA** Ya da, GRUB'ı silmeden çoğu hatayı düzelten Boot Repair işlevini kullanabilirsiniz. Ayrıca, hem hedef sabit diskinizi hem de önyüklenebilir cihazınızı YALNIZCA takılı tutmanız daha iyidir. Windows genellikle diğer cihazlar bağlıysa önyükleme bilgilerini onaramaz.\n\n```\nX:\\> bootrec.exe /fixboot\nX:\\> bootrec.exe /RebuildBcd\n```\n\n```\nGRUB'ı silmeden Windows'u onaracak olan bootrec.exe /Fixmbr komutunu kullanmayın.\n```\n\nYa da, GRUB'ı silmeden çoğu hatayı düzelten Boot Repair işlevini kullanabilirsiniz. Ayrıca, hem hedef sabit diskinizi hem de önyüklenebilir cihazınızı YALNIZCA takılı tutmanız daha iyidir. Windows genellikle diğer cihazlar bağlıysa önyükleme bilgilerini onaramaz.\n\nDosya sistemi etiketlerini, dosya sistemlerine eklenen insan tarafından okunabilir dizgiler, search komutuna --label seçeneği kullanarak kullanmak mümkündür. Öncelikle, dosya sisteminizin bir etikete sahip olduğundan emin olun.\n\nArdından, etiketler kullanarak bir giriş ekleyin. Bir örnek:\n\n```\nmenuentry \"Arch Linux, session texte\" {\n  search --label --set=root archroot\n  linux /boot/vmlinuz-linux root=/dev/disk/by-label/archroot ro\n  initrd /boot/initramfs-linux.img\n}\n```\n\n"
    },
    {
      "title": "Komut Shell'ini Kullanma",
      "level": 2,
      "content": "MBR, tüm GRUB modüllerini saklamak için çok küçük olduğundan, yalnızca menü ve birkaç temel komut burada bulunur. GRUB'un çoğu işlevi, ihtiyaç duyuldukça eklenen /boot/grub/ içindeki modüllerde bulunur. Hata koşullarında (örneğin, bölümlendirme düzeni değişirse) GRUB önyükleme yapamayabilir. Bu durumda, bir komut shell'i görünebilir.\n\nGRUB, birden fazla shell/komut istemcisi sunar. Menü okunamadığında ancak önyükleyici diski bulabiliyorsa, muhtemelen \"normal\" shell'ine düşersiniz:\n\n```\ngrub>\n```\n\nDaha ciddi bir sorun varsa (örneğin, GRUB gerekli dosyaları bulamazsa), \"rescue\" shell'ine düşebilirsiniz:\n\n```\ngrub rescue>\n```\n\nRescue shell'i, normal shell'in kısıtlı bir alt kümesidir ve çok daha az işlevsellik sunar. Rescue shell'ine düştüğünüzde, önce \"normal\" modülünü eklemeyi, ardından \"normal\" shell'ini başlatmayı deneyin:\n\n```\ngrub rescue> set prefix=(hdX,Y)/boot/grub\ngrub rescue> insmod (hdX,Y)/boot/grub/i386-pc/normal.mod\nrescue:grub> normal\n```\n\n"
    },
    {
      "title": "Pager Desteği",
      "level": 3,
      "content": "GRUB, uzun çıktı veren komutları okumak için pager'ı destekler (örneğin help komutu). Bu sadece normal shell modunda çalışır ve rescue modunda çalışmaz. Pager'ı etkinleştirmek için GRUB komut shell'inde şunu yazın:\n\n```\nsh:grub> set pager=1\n```\n\n"
    },
    {
      "title": "Komut Shell Ortamını Kullanarak İşletim Sistemlerini Önyükleme",
      "level": 3,
      "content": "```\ngrub>\n```\n\nGRUB'un komut shell ortamı, işletim sistemlerini önyüklemek için kullanılabilir. Yaygın bir senaryo, Windows / Linux'u bir sürücü/bölüm üzerinden chainloading ile önyüklemektir.\n\nChainloading, mevcut önyükleyiciden başka bir önyükleyiciyi yüklemek anlamına gelir, yani zincirleme önyükleme.\n\nDiğer önyükleyici, bölümlendirilmiş bir diskin (MBR) başlangıcında, bir bölümün başlangıcında veya bölümsüz bir diskin (VBR) başlangıcında veya UEFI durumunda bir EFI ikili dosyası olarak yer alabilir.\n\n"
    },
    {
      "title": "Bir Bölümün VBR'sini Chainloading",
      "level": 4,
      "content": "```\nset root=(hdX,Y)\nchainloader +1\nboot\n```\n\nX=0,1,2... Y=1,2,3...\n\nÖrneğin, birinci sabit diskin birinci bölümünde depolanan Windows'u chainload etmek için:\n\n```\nset root=(hd0,1)\nchainloader +1\nboot\n```\n\nBenzer şekilde, bir bölüme yüklenmiş GRUB chainloaded olabilir.\n\n"
    },
    {
      "title": "Bir Diskin MBR'sini veya Bölümsüz Bir Diskin VBR'sini Chainloading",
      "level": 4,
      "content": "```\nset root=hdX\nchainloader +1\nboot\n```\n\n"
    },
    {
      "title": "UEFI Modunda Kurulu Windows/Linux'u Chainloading",
      "level": 4,
      "content": "```\ninsmod fat\nset root=(hd0,gpt4)\nchainloader (${root})/EFI/Microsoft/Boot/bootmgfw.efi\nboot\n```\n\ninsmod fat FAT dosya sistemi modülünü yüklemek için kullanılır, Windows önyükleyicisini EFI sistem bölümünde erişmek için. (hd0,gpt4) veya /dev/sda4 bu örnekte EFI sistem bölümüdür. chainloader satırındaki giriş, chainloaded olacak .efi dosyasının yolunu belirtir.\n\n"
    },
    {
      "title": "Normal Yükleme",
      "level": 4,
      "content": "#Rescue Konsolunu Kullanma bölümündeki örneklere bakın.\n\n"
    },
    {
      "title": "Rescue Konsolunu Kullanma",
      "level": 3,
      "content": "Önce #Komut Shell'ini Kullanma kısmına bakın. Standart shell'i etkinleştiremiyorsanız, bir çözüm olarak bir canlı CD veya başka bir kurtarma diski kullanarak yapılandırma hatalarını düzeltip GRUB'ı yeniden yüklemeyi deneyebilirsiniz. Ancak, böyle bir önyükleme diski her zaman mevcut olmayabilir (veya gerekli olmayabilir); rescue konsolu oldukça sağlamdır.\n\nGRUB rescue'de mevcut komutlar insmod, ls, set ve unset'tir. Bu örnek set ve insmod kullanır. set değişkenleri değiştirir ve insmod yeni modüller ekler.\n\nBaşlamadan önce, kullanıcının /boot bölümünün yerini bilmesi gerekir (bu ayrı bir bölüm olabilir veya kök altında bir alt dizin olabilir):\n\n```\ngrub rescue> set prefix=(hdX,Y)/boot/grub\n```\n\nburada X fiziksel sürücü numarasını ve Y bölüm numarasını belirtir.\n\nKonsol yeteneklerini genişletmek için linux modülünü ekleyin:\n\n```\ngrub rescue> insmod i386-pc/linux.mod\n```\n\nveya basitçe\n\n```\ngrub rescue> insmod linux\n```\n\nBu, tanıdık olabilecek linux ve initrd komutlarını tanıtır.\n\nBir örnek, Arch Linux'u önyükleme:\n\n```\nset root=(hd0,5)\nlinux /boot/vmlinuz-linux root=/dev/sda5\ninitrd /boot/initramfs-linux.img\nboot\n```\n\nAyrı bir önyükleme bölümü (örneğin, UEFI kullanırken) ile, satırları uygun şekilde değiştirin:\n\n```\nset root=(hd0,5)\nlinux (hdX,Y)/vmlinuz-linux root=/dev/sda6\ninitrd (hdX,Y)/initramfs-linux.img\nboot\n```\n\nArch Linux kurulumu başarıyla önyüklendikten sonra, kullanıcılar grub.cfg'yi gerektiği şekilde düzeltebilir ve ardından GRUB'ı yeniden yükleyebilirler.\n\nGRUB'ı yeniden yükleyip sorunu tamamen çözmek için, gerekirse /dev/sda'yı değiştirin. Ayrıntılar için #Kurulum kısmına bakın.\n\n"
    },
    {
      "title": "UEFI Sistemleri",
      "level": 3,
      "content": "grubı kaldırmadan önce, başka bir önyükleyicinin kurulu ve devralacak şekilde yapılandırıldığından emin olun.\n\n```\n$ efibootmgr\n```\n\n```\nBootOrder: 0003,0001,0000,0002\nBoot0000* Windows Boot Manager  HD(2,GPT,4dabbedf-191b-4432-bc09-8bcbd1d7dabf,0x109000,0x32000)/File(\\EFI\\Microsoft\\Boot\\bootmgfw.efi)\nBoot0001* GRUB  HD(2,GPT,4dabbedf-191b-4432-bc09-8bcbd1d7dabf,0x109000,0x32000)/File(\\EFI\\GRUB\\grubx64.efi)\nBoot0002* Linux-Firmware-Updater        HD(2,GPT,5dabbedf-191b-4432-bc09-8bcbd1d7dabf,0x109000,0x32000)/File(\\EFI\\arch\\fwupdx64.efi)\nBoot0003* Linux Boot Manager    HD(2,GPT,4dabbedf-191b-4432-bc09-8bcbd1d7dabf,0x109000,0x32000)/File(\\EFI\\systemd\\systemd-bootx64.efi)\n```\n\nEğer BootOrder'da grub ilk giriş olarak yer alıyorsa, onu ön plana almak için başka bir önyükleyici kurun, örneğin yukarıda systemd-boot gibi. grub ardından bootnum kullanılarak kaldırılabilir.\n\n```\n# efibootmgr --delete-bootnum -b 1\n```\n\nAyrıca esp/EFI/grub ve /boot/grub dizinlerini de silin.\n\n"
    },
    {
      "title": "BIOS Sistemleri",
      "level": 3,
      "content": "grubı herhangi bir başka BIOS önyükleyicisiyle değiştirmek için, sadece onları yükleyin; bu, MBR boot code'u üzerine yazar.\n\ngrub-install, /boot/grub dizinini oluşturur ve bu dizinin manuel olarak kaldırılması gerekir. Ancak bazı kullanıcılar bu dizini saklamak isteyebilirler, eğer grubı yeniden yüklemek isterlerse.\n\nUEFI/GPT'ye geçiş yaptıktan sonra, MBR boot code'u dd kullanarak kaldırmak isteyebilirsiniz.\n\n"
    },
    {
      "title": "Desteklenmeyen dosya sistemleri",
      "level": 3,
      "content": "GRUB, kök dosya sistemini desteklemiyorsa, desteklenen bir dosya sistemi ile alternatif bir /boot bölümü oluşturulmalıdır. Bazı durumlarda, GRUB'un geliştirme sürümü grub-gitAUR dosya sistemini yerel olarak destekleyebilir.\n\nGRUB, desteklenmeyen bir dosya sistemi ile kullanıldığında, diskinizin UUID'sini çıkaramadığı için klasik olmayan kalıcı /dev/sdXx adlarını kullanır. Bu durumda, /boot/grub/grub.cfg dosyasını manuel olarak düzenlemeniz ve root=/dev/sdXx'i root=UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX ile değiştirmeniz gerekebilir. Cihazınızın UUID'sini almak için blkid komutunu kullanabilirsiniz, detaylar için Persistent block device naming kısmına bakın.\n\nGRUB, F2FS'i 2.0.4 sürümünden itibaren desteklese de, extra_attr bayrağı etkinleştirilmiş bir F2FS bölümünden önyükleme dosyalarını doğru şekilde okuyamaz.\n\n"
    },
    {
      "title": "Hata Ayıklama Mesajlarını Etkinleştirme",
      "level": 3,
      "content": "Şunları ekleyin:\n\n```\nset pager=1\nset debug=all\n```\n\ngrub.cfg'ye.\n\n"
    },
    {
      "title": "msdos-tarzı Hata Mesajı",
      "level": 3,
      "content": "```\ngrub-setup: warn: This msdos-style partition label has no post-MBR gap; embedding will not be possible!\ngrub-setup: warn: Embedding is not possible. GRUB can only be installed in this setup by using blocklists.\n            However, blocklists are UNRELIABLE and its use is discouraged.\ngrub-setup: error: If you really want blocklists, use --force.\n```\n\nBu hata, GRUB'ı bir VMware konteynerine kurmayı denerken ortaya çıkabilir. Hakkında daha fazla bilgi için buradan okuyabilirsiniz. Bu hata, ilk bölüm MBR'den hemen (blok 63) başladığında, ilk bölümden önce 1 MiB (2048 blok) boşluk bırakılmadığında meydana gelir. #Master Boot Record (MBR) özgü talimatlar kısmına bakın.\n\n"
    },
    {
      "title": "Yaygın Kurulum Hataları",
      "level": 4,
      "content": "- Bazı UEFI cihazlarında karşılaşılabilecek bir hata Could not prepare Boot variable: Read-only file system olabilir. /sys/firmware/efi/efivars'ı okuma-yazma izniyle yeniden bağlamanız gerekir. # mount -o remount,rw,nosuid,nodev,noexec --types efivarfs efivarfs /sys/firmware/efi/efivars Gentoo Wiki'de boot loader'ın nasıl kurulacağı hakkında bilgi edinin.\n- Eğer grub-install çalıştırırken sysfs veya procfs ile bir sorun yaşarsanız ve modprobe efivarfs çalıştırmanız gerekiyorsa, yukarıdaki komut ile efivarfs'ı bağlamayı deneyin.\n- --target veya --directory seçeneği olmadan, grub-install hangi firmware için kurulacağını belirleyemez. Bu durumda, grub-install source_dir does not exist. Please specify --target or --directory mesajını verecektir.\n- Eğer grub-install çalıştırdıktan sonra error: esp doesn't look like an EFI partition hatasını alırsanız, bölüm muhtemelen FAT32 formatında değildir.\n\n```\n# mount -o remount,rw,nosuid,nodev,noexec --types efivarfs efivarfs /sys/firmware/efi/efivars\n```\n\n"
    },
    {
      "title": "Firmware Boot Manager'da GRUB Girişi Oluşturma",
      "level": 4,
      "content": "grub-install otomatik olarak önyükleyici yöneticisinde bir menü girişi oluşturmaya çalışır. Eğer bunu yapmazsa, bir menü girişi oluşturmak için efibootmgr kullanma talimatları için UEFI#efibootmgr kısmına bakın. Ancak, sorun büyük ihtimalle CD/USB'nizi UEFI modunda önyüklemediğinizden kaynaklanıyordur, Installation guide (Türkçe)#Önyükleme modunu doğrulama kısmında açıklandığı gibi.\n\nFirmware boot manager'da bir GRUB girişi oluşturma örneği olarak efibootmgr -c komutunu ele alın. Bu, /dev/sda1'in EFI Sistem Bölümü olduğunu ve /boot/efi'ye bağlı olduğunu varsayar. Bu, efibootmgr'in varsayılan davranışıdır. Bu, \"Linux\" adında yeni bir önyükleme seçeneği oluşturur ve önyükleme sırası listesinde üstteki sıraya koyar. Varsayılan OS Yükleyicisi \\EFI\\arch\\grub.efi'dir.\n\n"
    },
    {
      "title": "Kurtarma kabuğuna geçiş",
      "level": 4,
      "content": "GRUB yükleniyor ancak kurtarma kabuğuna geçiş yapıyorsa ve herhangi bir hata mesajı göstermiyorsa, bu iki nedenden biri olabilir:\n\n- Eksik veya yanlış yerleştirilmiş bir grub.cfg olabilir. Bu, GRUB UEFI --boot-directory ile kurulduysa ve grub.cfg dosyası eksikse meydana gelir,\n- Ayrıca, grubx64.efi dosyasına sert kodlanmış olan önyükleme bölümü değiştiyse de bu durum yaşanabilir.\n\n"
    },
    {
      "title": "GRUB UEFI Yüklenmedi",
      "level": 4,
      "content": "Çalışan bir UEFI örneği:\n\n```\n# efibootmgr -u\n```\n\n```\nBootCurrent: 0000\nTimeout: 3 seconds\nBootOrder: 0000,0001,0002\nBoot0000* GRUB HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\\EFI\\GRUB\\grubx64.efi)\nBoot0001* Shell HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\\shellx64.efi)\nBoot0002* Festplatte BIOS(2,0,00)P0: SAMSUNG HD204UI\n```\n\nEkran sadece bir saniye kararıyorsa ve ardından bir sonraki önyükleme seçeneği deneniyorsa, bu gönderiye göre GRUB'ı bölüm köküne taşımanın yardımcı olabileceği belirtilmiştir. Önyükleme seçeneği silinmeli ve ardından yeniden oluşturulmalıdır. GRUB için giriş şu şekilde görünmelidir:\n\n```\nBoot0000* GRUB HD(1,800,32000,23532fbb-1bfa-4e46-851a-b494bfe9478c)File(\\grubx64.efi)\n```\n\n"
    },
    {
      "title": "Varsayılan/geri dönüş önyükleme yolu",
      "level": 4,
      "content": "Bazı UEFI firmaları, UEFI NVRAM önyükleme girişlerini gösterebilmek için bilinen bir konumda önyüklenebilir bir dosya gerektirir. Bu durumda, grub-install efibootmgr'nin GRUB'u önyükleme girişine eklediğini belirtecek, ancak giriş VisualBIOS önyükleme sırası seçicisinde görünmeyecektir. Çözüm, GRUB'u varsayılan/geri dönüş önyükleme yoluna yüklemektir:\n\n```\n# grub-install --target=x86_64-efi --efi-directory=esp --removable\n```\n\nAlternatif olarak, önceden yüklenmiş bir GRUB EFI çalıştırılabilir dosyasını varsayılan/geri dönüş yoluna taşıyabilirsiniz:\n\n```\n# mv esp/EFI/grub esp/EFI/BOOT\n# mv esp/EFI/BOOT/grubx64.efi esp/EFI/BOOT/BOOTX64.EFI\n```\n\n"
    },
    {
      "title": "Geçersiz imza",
      "level": 3,
      "content": "Windows'u önyüklemeye çalışırken \"geçersiz imza\" hatası alıyorsanız, örneğin bölümleri yeniden yapılandırdıktan veya ek hard diskler ekledikten sonra, (re)GRUB'un cihaz yapılandırmasını kaldırıp yeniden yapılandırmasını sağlayın:\n\n```\n# mv /boot/grub/device.map /boot/grub/device.map-old\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\ngrub-mkconfig artık bulunan tüm önyükleme seçeneklerini, Windows dahil, listelemelidir. Eğer çalışırsa, /boot/grub/device.map-old'yi kaldırın.\n\n"
    },
    {
      "title": "Önyükleme Donmaları",
      "level": 3,
      "content": "GRUB, çekirdek ve başlangıç ramdisk'ini yükledikten sonra herhangi bir hata mesajı olmadan donarsa, add_efi_memmap çekirdek parametresini kaldırmayı deneyin.\n\n"
    },
    {
      "title": "Diğer İşletim Sistemlerinden Arch Bulunamıyor",
      "level": 3,
      "content": "Bazı kullanıcılar, diğer dağıtımların Arch Linux'u otomatik olarak os-prober ile bulmakta sorun yaşadığını bildirmiştir. Bu sorun ortaya çıkarsa, /etc/lsb-release dosyasının varlığı ile algılamanın iyileştirilebileceği bildirilmiştir. Bu dosya ve güncelleme aracı, lsb-release paketi ile kullanılabilir.\n\n"
    },
    {
      "title": "chroot İçinde Kurulumda Uyarı",
      "level": 3,
      "content": "Bir LVM sisteminde chroot ortamında (örneğin sistem kurulumu sırasında) GRUB'ı kurarken, şu tür uyarılar alabilirsiniz:\n\n```\n/run/lvm/lvmetad.socket: connect failed: No such file or directory\n```\n\nveya\n\n```\nWARNING: failed to connect to lvmetad: No such file or directory. Falling back to internal scanning.\n```\n\nBu, /run'ın chroot içinde mevcut olmamasından kaynaklanır. Bu uyarılar, sistemin önyüklenmesini engellemeyecektir, her şey doğru yapıldığında kuruluma devam edebilirsiniz.\n\n"
    },
    {
      "title": "GRUB Yavaş Yükleniyor",
      "level": 3,
      "content": "Disk alanı düşük olduğunda GRUB uzun süre yüklenebilir. Sorun yaşadığınızda /boot veya / bölümünde yeterli boş disk alanı olup olmadığını kontrol edin.\n\n"
    },
    {
      "title": "error: unknown filesystem",
      "level": 3,
      "content": "GRUB, error: unknown filesystem hatası verebilir ve birkaç nedenden ötürü önyükleme yapmayı reddedebilir. Eğer tüm UUID'lerin doğru olduğundan ve tüm dosya sistemlerinin geçerli ve desteklendiğinden eminseniz, bu, BIOS Boot Partition'ın diskin ilk 2 TiB'i dışında bir yerde bulunmasından kaynaklanabilir [4]. Bu bölümü tamamen ilk 2 TiB içinde olacak şekilde bir bölümlendirme aracı kullanarak yerleştirin, ardından GRUB'u yeniden yükleyin ve yeniden yapılandırın.\n\nBu hata, desteklenmeyen özelliklere sahip bir ext4 dosya sisteminden de kaynaklanabilir:\n\n- large_dir - desteklenmiyor.\n- metadata_csum_seed - GRUB 2.11'de desteklenecek (commit).\n\n"
    },
    {
      "title": "grub-reboot Sıfırlanmıyor",
      "level": 3,
      "content": "GRUB'un kök Btrfs bölümlerine yazamadığı görülüyor [5]. Eğer grub-reboot kullanarak başka bir girişe önyükleme yaparsanız, bu yüzden diskteki ortamını güncelleyemez. Ya diğer girişten grub-reboot'u çalıştırın (örneğin çeşitli dağıtımlar arasında geçiş yaparken) ya da farklı bir dosya sistemi kullanmayı düşünün. \"Sticky\" bir girişi sıfırlamak için grub-editenv create komutunu çalıştırın ve GRUB_DEFAULT=0'ı /etc/default/grub dosyanıza ekleyin (grub-mkconfig -o /boot/grub/grub.cfg'yi unutmayın).\n\n"
    },
    {
      "title": "Eski Btrfs Kurulumu Engelliyor",
      "level": 3,
      "content": "Bir sürücü, bir bölüm tablosu oluşturulmadan (örneğin /dev/sdx) Btrfs ile biçimlendirilmişse ve sonra bölüm tablosu yazılırsa, BTRFS formatının bazı bölümleri kalır. Çoğu yardımcı program ve işletim sistemi bunu görmez, ancak GRUB --force ile bile kurulum yapmayı reddeder.\n\n```\n# grub-install: warning: Attempting to install GRUB to a disk with multiple partition labels. This is not supported yet..\n# grub-install: error: filesystem `btrfs' does not support blocklists.\n```\n\nSürücüyü sıfırlayabilirsiniz, ancak verilerinizi bozmadan kolay bir çözüm Btrfs süperblokunu wipefs -o 0x10040 /dev/sdx ile silmektir.\n\n"
    },
    {
      "title": "Windows 8/10 Bulunamıyor",
      "level": 3,
      "content": "Windows 8/10'da bulunan bir \"Hiberboot\", \"Hybrid Boot\" veya \"Fast Boot\" ayarı, Windows bölümünün bağlanmasını engelleyebilir, bu nedenle grub-mkconfig Windows kurulumunu bulamayabilir. Hiberboot'u Windows'ta devre dışı bırakmak, Windows'un GRUB menüsüne eklenmesini sağlayacaktır.\n\n"
    },
    {
      "title": "GRUB Kurtarma ve Şifreli /boot",
      "level": 3,
      "content": "Bir şifreli /boot kullanıyorsanız ve doğru bir şifre girmekte başarısız olduysanız, grub-rescue istemcisine düşersiniz.\n\nBu grub-rescue istemcisinin sınırlı yetenekleri vardır. Önyüklemeyi tamamlamak için şu komutları kullanın:\n\n```\ngrub rescue> cryptomount <partition>\ngrub rescue> insmod normal\ngrub rescue> normal\n```\n\nDaha iyi bir açıklama için bu blog gönderisini[dead link 2023-04-23 ⓘ] inceleyebilirsiniz.\n\n"
    },
    {
      "title": "GRUB Yükleniyor Ancak Menü Görünmüyor",
      "level": 3,
      "content": "/etc/default/grub dosyasını kontrol edin, GRUB_TIMEOUT değeri 0 olarak ayarlandıysa, bunu pozitif bir sayıya ayarlayın: bu, varsayılan GRUB girişinin yüklenmeden önce geçen süreyi belirler. Ayrıca, GRUB_TIMEOUT_STYLE'in hidden olarak ayarlanıp ayarlanmadığını kontrol edin ve bunu menu olarak değiştirin, böylece menü varsayılan olarak gösterilir. Ardından ana yapılandırma dosyasını yeniden oluşturun ve yeniden başlatın.\n\nEğer bu işe yaramazsa, grafiksel terminal ile uyumsuzluk sorunları olabilir. GRUB_TERMINAL_OUTPUT'u console olarak /etc/default/grub dosyasında ayarlayarak GRUB grafiksel terminalini devre dışı bırakabilirsiniz.\n\n"
    },
    {
      "title": "Ayrıca Bakınız",
      "level": 2,
      "content": "- Wikipedia:GNU GRUB\n- Resmi GRUB Kılavuzu\n- Ubuntu GRUB sayfası\n- GRUB wiki sayfası, UEFI sistemler için derleme adımlarını açıklar\n- Wikipedia:BIOS Boot partition\n- GRUB'u Nasıl Yapılandırılır\n\n"
    }
  ]
}