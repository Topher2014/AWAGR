{
  "title": "GPGPU (日本語)",
  "url": "https://wiki.archlinux.org/title/GPGPU_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- Nvidia\n- ハードウェアビデオアクセラレーション\n\nGPGPU は General-purpose computing on graphics processing units; GPUによる汎用計算 の略です。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 OpenCL 1.1 ランタイム 1.1.1 AMD/ATI 1.1.2 NVIDIA 1.1.3 Intel 1.1.4 その他 1.2 32ビットランタイム 1.2.1 AMD/ATI 1.2.2 NVIDIA 1.3 ICD ローダー (libOpenCL.so) 1.4 開発 1.5 実装 1.5.1 Rusticl 1.5.2 言語バインディング\n- 2 SYCL 2.1 実装 2.2 SPIR サポートの確認 2.3 開発\n- 3 CUDA 3.1 開発 3.2 言語バインディング\n- 4 ROCm 4.1 HIP 4.2 OpenMP 4.3 OpenCL 4.3.1 OpenCL image support 4.4 トラブルシューティング 4.4.1 Vega10 GPU 4.4.2 PyTorch\n- 5 GPGPU のアクセラレーションがあるソフトウェア\n- 6 参照\n\n- 1.1 ランタイム 1.1.1 AMD/ATI 1.1.2 NVIDIA 1.1.3 Intel 1.1.4 その他\n- 1.2 32ビットランタイム 1.2.1 AMD/ATI 1.2.2 NVIDIA\n- 1.3 ICD ローダー (libOpenCL.so)\n- 1.4 開発\n- 1.5 実装 1.5.1 Rusticl 1.5.2 言語バインディング\n\n- 1.1.1 AMD/ATI\n- 1.1.2 NVIDIA\n- 1.1.3 Intel\n- 1.1.4 その他\n\n- 1.2.1 AMD/ATI\n- 1.2.2 NVIDIA\n\n- 1.5.1 Rusticl\n- 1.5.2 言語バインディング\n\n- 2.1 実装\n- 2.2 SPIR サポートの確認\n- 2.3 開発\n\n- 3.1 開発\n- 3.2 言語バインディング\n\n- 4.1 HIP\n- 4.2 OpenMP\n- 4.3 OpenCL 4.3.1 OpenCL image support\n- 4.4 トラブルシューティング 4.4.1 Vega10 GPU 4.4.2 PyTorch\n\n- 4.3.1 OpenCL image support\n\n- 4.4.1 Vega10 GPU\n- 4.4.2 PyTorch\n\n"
    },
    {
      "title": "OpenCL",
      "level": 2,
      "content": "OpenCL (Open Computing Language) は、非営利団体である Khronos グループによって開発されている、オープンでロイヤルティフリーの並列プログラミングフレームワークです。\n\nOpenCL の仕様書には一般環境として必要なプログラミング言語と、プログラマがこの環境で呼び出せる C API について規定されています。\n\n"
    },
    {
      "title": "ランタイム",
      "level": 3,
      "content": "OpenCL を使用するプログラムを実行するには、互換性のあるハードウェアランタイムをインストールする必要があります。\n\n"
    },
    {
      "title": "AMD/ATI",
      "level": 4,
      "content": "- opencl-clover-mesa または opencl-rusticl-mesa: clover と rusticl による mesa ドライバ用の OpenCL サポート\n- rocm-opencl-runtime: AMD の ROCm GPU コンピュートスタックの一部。GFX8 およびそれ以降のカード (Fiji, Polaris, Vega) を公式にサポートしており、Navi10 ベースのカードは非公式で部分的なサポートがあります。Vega より古いカードをサポートするには、ラインタイム変数 ROC_ENABLE_PRE_VEGA=1 を設定する必要があります。これは、ubuntu の amdgpu-install に opencl=rocr を指定したものに似てはいますが、全く異なるものです。このパッケージの rocm バージョンは ubuntu のインストーラバージョンとは異なるからです。\n- opencl-legacy-amdgpu-proAUR: AMD の ubuntu リリースから再パッケージングされたレガシーな Orca OpenCL。ubuntu の amdgpu-install に opencl=legacy を指定することと等価です。\n- opencl-amdAUR、opencl-amd-devAUR: AMD の Ubuntu リリースから再パッケージングされた ROCm コンポーネント群。Ubuntu の amdgpu-install で opencl=rocr,legacy を指定することと等価です。\n- amdapp-sdkAUR: AMD CPU ランタイム\n\n"
    },
    {
      "title": "NVIDIA",
      "level": 4,
      "content": "- opencl-clover-mesa または opencl-rusticl-mesa: clover と rusticl による mesa ドライバ向けの OpenCL サポート。\n- opencl-nvidia: 公式の NVIDIA ランタイム\n\n"
    },
    {
      "title": "Intel",
      "level": 4,
      "content": "- intel-compute-runtime: またの名を Neo OpenCL ランタイム。第8世代 (Broadwell) 以降の Intel HD Graphics GPU 用のオープンソース実装です。\n- opencl-clover-mesa または opencl-rusticl-mesa: clover と rusticl による mesa ドライバ用の OpenCL サポート\n- beignetAUR: 第7世代 (Ivy Bridge) 以降の Intel HD Graphics GPU 用のオープンソース実装。これは Intel によって非推奨となっており、NEO OpenCL ドライバが後継です。ただし、古いハードウェアプラットフォーム (例: Ivy Bridge、Haswell) においては推奨されるソリューションです。\n- intel-openclAUR: 第7世代 (Ivy Bridge) 以降の Intel HD Graphics GPU のプロプライエタリな実装。これは Intel によって非推奨となっており、NEO OpenCL ドライバが後継です。ただし、古いハードウェアプラットフォーム (例: Ivy Bridge、Haswell) においては推奨されるソリューションです。\n- intel-opencl-runtimeAUR: Intel Core 及び Xeon プロセッサ用の実装。非 Intel な CPU もサポートしています。\n\n"
    },
    {
      "title": "その他",
      "level": 4,
      "content": "- pocl: LLVM ベースの OpenCL 実装 (ハードウェアとは独立)\n\nVulkan ランタイム上で OpenCL アプリケーションを実行するためのコンパイラとトランスレータがあります。\n\n- clspv-gitAUR: Clspv は OpenCL C のサブセットから Vulkan コンピュートシェーダに変換するためのプロトタイプコンパイラです。\n- clvk-gitAUR: clvk は clspv をコンパイラとして使用する、Vulkan 上で動作する OpenCL 3.0 のプロトタイプ実装です。\n- xrt-binAUR: FPGA xrt のための Xilinx Run Time\n- fpga-runtime-for-opencl: FPGA ランタイムs\n\n"
    },
    {
      "title": "32ビットランタイム",
      "level": 3,
      "content": "OpenCL を使う32ビットプログラムを実行するには、互換性のあるハードウェア32ビットランタイムをインストールする必要があります。\n\n"
    },
    {
      "title": "AMD/ATI",
      "level": 4,
      "content": "- lib32-opencl-clover-mesa または lib32-opencl-rusticl-mesa: AMD/ATI Radeon mesa ドライバの OpenCL サポート (32 ビット)\n\n"
    },
    {
      "title": "NVIDIA",
      "level": 4,
      "content": "- lib32-opencl-nvidia: NVIDIA 用の OpenCL 実装 (32ビット)\n\n"
    },
    {
      "title": "ICD ローダー (libOpenCL.so)",
      "level": 3,
      "content": "OpenCL ICD ローダーはプラットフォームに依存しないライブラリで、OpenCL API 経由で特定のデバイスのドライバをロードするために使われます。 ほとんどの OpenCL ベンダーはそれぞれ独自の OpenCL ICD ローダーを提供しており、他のベンダーの OpenCL 実装でも問題なく動作するはずです。 残念ながら、大抵のベンダーは最新の ICD ローダーを提供していません。そのため、Arch Linux ではこのライブラリを別のプロジェクト (ocl-icd) から提供することで最新の OpenCL API の実装が機能するようにしています。\n\n他の ICD ローダーライブラリは各メーカーの SDK の一部としてインストールされます。確実に ocl-icd パッケージに含まれている ICD ローダーを使用したい場合、/etc/ld.so.conf.d にファイルを作成して /usr/lib を動的プログラムローダーの検索ディレクトリに追加してください:\n\n```\n/etc/ld.so.conf.d/00-usrlib.conf\n```\n\n```\n/usr/lib\n```\n\n全ての SDK は ld.so.conf.d ファイルでランタイムのライブラリディレクトリを検索パスに追加するため上記の設定をする必要があります。\n\n様々な OpenCL ICD を含む利用可能なパッケージは:\n\n- ocl-icd: 推奨、ほぼ最新\n- intel-openclAUR: Intel により提供。OpenCL 2.0 を提供します。これは非推奨となっており、後継は intel-compute-runtime です。\n\n"
    },
    {
      "title": "開発",
      "level": 3,
      "content": "OpenCL を使用して開発するには、最低でも以下のパッケージが必要です:\n\n- ocl-icd: OpenCL ICD ローダ実装。最新の OpenCL 仕様に沿っています。\n- opencl-headers: OpenCL C/C++ API ヘッダーファイル。\n\nベンダーの SDK には様々なツールやサポートライブラリが含まれています:\n\n- intel-opencl-sdkAUR: Intel OpenCL SDK (古いバージョン。新しい OpenCL SDK は INDE と Intel Media Server Studio に含まれています)\n- amdapp-sdkAUR: このパッケージにより /opt/AMDAPP と SDK ファイルの一部がインストールされ、一定数のコードサンプル (/opt/AMDAPP/SDK/samples/) も含まれています。また、システム内に存在する OpenCL プラットフォームとデバイスをリストアップし、それらに関する詳細な情報を表示する clinfo ユーティリティも提供します。SDK 自体に CPU OpenCL ドライバが含まれているため、OpenCL を CPU デバイス上で実行するための追加のドライバは必要ありません (CPU のベンダを問わず)。\n- cuda: OpenCL 3.0 のサポートを含む Nvidia の GPU SDK。\n\n"
    },
    {
      "title": "実装",
      "level": 3,
      "content": "あなたのシステムで現在アクティブになっている OpenCL 実装を確認するには、以下のコマンドを使用してください:\n\n```\n$ ls /etc/OpenCL/vendors\n```\n\nシステムで利用可能な OpenCL プラットフォームとデバイスの利用可能な (既知の) 全プロパティを調べるには、clinfo をインストールしてください。\n\nocl-icd-chooseAUR を使えば、アプリケーションに参照させる実装を指定することができます。例えば:\n\n```\n$ ocl-icd-choose amdocl64.icd:mesa.icd davinci-resolve-checker\n```\n\n"
    },
    {
      "title": "Rusticl",
      "level": 4,
      "content": "Table content:\nこの記事またはセクションの正確性には問題があります。 理由: マニュアルに書かれてあることと異なり、OCL_ICD_VENDORS は単一の icd ファイルを処理することができないようです。https://github.com/OCL-dev/ocl-icd/issues/7#issuecomment-1522941979 を参照してください。 (議論: トーク:GPGPU#)\n\nRusticl は、Rust で記述された新しい OpenCL 実装で、opencl-rusticl-mesa によって提供されています。環境変数 RUSTICL_ENABLE=driver (driver は Gallium ドライバ。radeonsi や iris など) を設定することで有効化できます。\n\n任意で、OpenCL アプリケーションが Rusticl を検出しない場合、以下の環境変数を使用してください:\n\n```\nOCL_ICD_VENDORS=/etc/OpenCL/vendors/rusticl.icd\n```\n\n"
    },
    {
      "title": "言語バインディング",
      "level": 4,
      "content": "- JavaScript/HTML5: WebCL\n- Python: python-pyopencl\n- D: cl4d や DCompute\n- Java: Aparapi や JOCL (JogAmp の一部)\n- Mono/.NET: Open Toolkit\n- Go: Go のための OpenCL バインディング\n- Racket: Racket にはネイティブなインファーフェイス on PLaneT が含まれています。roco を通してインストールできます。\n- Rust: ocl\n- Julia: OpenCL.jl\n\n"
    },
    {
      "title": "SYCL",
      "level": 2,
      "content": "Wikipedia:SYCL によると:\n\n"
    },
    {
      "title": "実装",
      "level": 3,
      "content": "- computecppAUR: Codeplay による SYCL 1.2.1 のプロプライエタリ実装。SPIR、SPIR-V、そして実験的な PTX (NVIDIA) をデバイスターゲットとして対象とすることができます (2023年9月1日でサポート終了、Intel llvm 実装にマージされる予定です 情報)。\n- trisycl-gitAUR: 主に Xilinx によって開発されているオープンソースの実装。\n- hipsycl-cuda-gitAUR と hipsycl-rocm-gitAUR: OpenCL の代わりに AMD の HIP を使用するフリー実装。AMD と NVIDIA の GPU で動作可能。\n- intel-oneapi-dpcpp-cpp: Intel の Data Parallel C++: SYCL の oneAPI 実装。\n\n"
    },
    {
      "title": "SPIR サポートの確認",
      "level": 3,
      "content": "大抵の SYCL 実装はアクセラレータのコードを SPIR あるいは SPIR-V にコンパイルすることができます。どちらも Khronos によって設計された中間言語で、OpenCL ドライバーに渡すことができます。SPIR や SPIR-V に対応しているかどうか確認するには clinfo を使います:\n\n```\n$ clinfo | grep -i spir\n```\n\n```\nPlatform Extensions                             cl_khr_icd cl_khr_global_int32_base_atomics cl_khr_global_int32_extended_atomics cl_khr_local_int32_base_atomics cl_khr_local_int32_extended_atomics cl_khr_byte_addressable_store cl_khr_depth_images cl_khr_3d_image_writes cl_intel_exec_by_local_thread cl_khr_spir cl_khr_fp64 cl_khr_image2d_from_buffer cl_intel_vec_len_hint \n  IL version                                    SPIR-V_1.0\n  SPIR versions                                 1.2\n```\n\nComputeCpp には、関連するシステム情報を要約するツールも同梱されています:\n\n```\n$ computecpp_info\n```\n\n```\nDevice 0:\n\n  Device is supported                     : UNTESTED - Untested OS\n  CL_DEVICE_NAME                          : Intel(R) Core(TM) i7-4770K CPU @ 3.50GHz\n  CL_DEVICE_VENDOR                        : Intel(R) Corporation\n  CL_DRIVER_VERSION                       : 18.1.0.0920\n  CL_DEVICE_TYPE                          : CL_DEVICE_TYPE_CPU\n```\n\nTable content:\nこの記事またはセクションは情報が古くなっています。 理由: このドライバは AMD opencl-legacy-amdgpu-proAUR や opencl-amdAUR 用か? (Discuss)\n\nSPIR や SPIR-V をサポートしている既知のドライバーとして intel-compute-runtime, intel-opencl-runtimeAUR, pocl, amdgpu-pro-openclAUR[リンク切れ: パッケージが存在しません] などが存在します。\n\n"
    },
    {
      "title": "開発",
      "level": 3,
      "content": "SYCL は、機能する C++11 環境がセットアップされている必要があります。いくつかのオープンソースライブラリが存在します:\n\n- ComputeCpp SDK: コード例集、ComputeCpp 用の cmake 統合。\n- SYCL-DNN: ニューラルネットワークパフォーマンスプリミティブ\n- SYCL-BLAS: 線形代数パフォーマンスプリミティブ\n- VisionCpp: コンピュータビジョンライブラリ\n- SYCL Parallel STL: C++17 の並列アルゴリズムお GPU 実装\n\n"
    },
    {
      "title": "CUDA",
      "level": 2,
      "content": "CUDA (Compute Unified Device Architecture) は、NVIDIA のプロプライエタリな、クローズドソースの並列計算アーキテクチャ及びフレームワークです。NVIDIA GPU を必要とします。CUDA は複数のコンポーネントから構成されます:\n\n- 必須: プロプライエタリな NVIDIA カーネルモジュール CUDA \"ドライバ\" と \"ランタイム\" ライブラリ\n- 任意: 追加のライブラリ: CUBLAS、CUFFT、CUSPARSE など CUDA ツールキット。nvcc コンパイラが含まれています。 CUDA SDK。CUDA と OpenCL プログラムの多数のサンプルや例が含まれています。\n\n- プロプライエタリな NVIDIA カーネルモジュール\n- CUDA \"ドライバ\" と \"ランタイム\" ライブラリ\n\n- 追加のライブラリ: CUBLAS、CUFFT、CUSPARSE など\n- CUDA ツールキット。nvcc コンパイラが含まれています。\n- CUDA SDK。CUDA と OpenCL プログラムの多数のサンプルや例が含まれています。\n\nカーネルモジュールと CUDA \"ドライバ\" ライブラリは nvidia と opencl-nvidia に入っています。\"ランタイム\" ライブラリと CUDA ツールキットの残りは cuda パッケージでインストール可能です。cuda-gdb を使うには ncurses5-compat-libsAUR のインストールが必要です。FS#46598 を参照。\n\n"
    },
    {
      "title": "開発",
      "level": 3,
      "content": "cuda パッケージは、すべてのコンポーネントを /opt/cuda ディレクトリにインストールします。スクリプト /etc/profile.d/cuda.sh によって、関連する環境変数が設定され、CUDA をサポートするビルドシステムが CUDA を見つけられるようになります。\n\nインストールが成功したかどうかや、CUDA が動いているかどうかを確かめるには、CUDA samples をコンパイルすることで可能です。インストールをチェックする方法の一つとして、deviceQuery サンプルを実行するというものがあります。\n\n"
    },
    {
      "title": "言語バインディング",
      "level": 3,
      "content": "- Fortran: PGI CUDA Fortran Compiler\n- Haskell: アクセラレートパッケージには利用可能な CUDA バックエンドがあります。\n- Java: JCuda\n- Mathematica: CUDAlink\n- Mono/.NET: CUDAfy.NET、managedCuda\n- Perl: KappaCUDA、CUDA-Minimal\n- Python: python-pycuda\n- Ruby: rbcuda\n- Rust: cuda-sys (bindings) や RustaCUDA (高レベルなラッパ)\n\n"
    },
    {
      "title": "ROCm",
      "level": 2,
      "content": "ROCm (Radeon Open Compute) は、AMD のオープンソースな並列計算アーキテクチャ及びフレームワークです。これは AMD GPU を必要としますが、一部の ROCm ツールはハードウェアに依存しません。詳細は Arch Linux リポジトリ用の ROCm を見てください。\n\n- rocm-hip-sdk: HIP と AMD プラットフォーム用のライブラリを使用するアプリケーションの開発。\n- rocm-opencl-sdk: AMD プラットフォーム用の OpenCL ベースアプリケーションの開発。\n\n"
    },
    {
      "title": "HIP",
      "level": 3,
      "content": "Heterogeneous Interface for Portability (HIP) は、GPU ハードウェア上で高パフォーマンスなカーネルを設計するための、AMD の専用 GPU プログラミング環境です。HIP は、異なるプラットフォーム上でポータブルなアプリケーションを作成できるようにする C++ ランタイム API 及びプログラミング言語です。\n\n- rocm-hip-runtime: ベースランタイム。AMD プラットフォーム上で HIP アプリケーションを実行するためのパッケージ群。\n- hip-runtime-amd: ROCm における AMDGPU 用の Heterogeneous Interface。Polaris アーキテクチャ (RX 500 シリーズ) から AMD の最新 RDNA 2 アーキテクチャ (RX 6000 シリーズ) までの GPU をサポートします。\n- miopen-hip: HIP バックエンドを用いる、AMD のオープンソースのディープラーニングライブラリ。\n- hip-runtime-nvidiaAUR: ROCm における NVIDIA GPU 用 Heterogeneous Interface。\n\n"
    },
    {
      "title": "OpenMP",
      "level": 3,
      "content": "openmp-extrasAUR パッケージは AOMP (AMD GPU における OpenMP API のサポートを追加した、オープンソースの Clang/LLVM ベースコンパイラ) を提供します。\n\n"
    },
    {
      "title": "OpenCL",
      "level": 3,
      "content": "rocm-opencl-runtime パッケージは、OpenCL ランタイムを提供する ROCm フレームワークの一部です。\n\n"
    },
    {
      "title": "OpenCL image support",
      "level": 4,
      "content": "最新の ROCm バージョンには、Darktable などの GPGPU 支援のソフトウェアによって使用される OpenCL Image Support が含まれています。必要なのは AMDGPU オープンソースグラフィックドライバと ROCm だけです。AMDGPU PRO は必要ありません。\n\n```\n$ /opt/rocm/bin/clinfo | grep -i \"image support\"\n```\n\n```\nImage support                                   Yes\n```\n\n"
    },
    {
      "title": "トラブルシューティング",
      "level": 3,
      "content": "まず、GPU が /opt/rocm/bin/rocminfo ディレクトリに現れるか確認してください。現れない場合、ROCm はあなたの GPU をサポートしていないか、あなたの GPU のサポート無しでビルドされている可能性があります。\n\n"
    },
    {
      "title": "Vega10 GPU",
      "level": 4,
      "content": "MI25 (及びその他の gfx900 GPU) は非推奨となっており、公式のサポートは終了しました。これらの GPU は公式には ROCm 4 ではサポートされており、ROCm 5 では非公式ですがサポートされています。ROCm 6 ではサポートされていません。\n\nROCm 5.7.1 のインストールガイドは AMD Radeon Instinct MI25#ROCm を見てください。。\n\n"
    },
    {
      "title": "PyTorch",
      "level": 4,
      "content": "ROCm で PyTorch を使うには、python-pytorch-rocm をインストールしてください。\n\n```\n$ python -c 'import torch; print(torch.cuda.is_available())'\n```\n\n```\nTrue\n```\n\nROCm はまるで CUDA であるかのように振る舞うので、上記のコマンドは True を返すはずです。True を返さない場合、あなたの GPU のサポート無しで PyTorch がコンパイルされているか、依存関係の衝突が発生している可能性があります。ldd /usr/lib/libtorch.so を実行してみることで、どちらの問題が発生しているか確認することができます - 欠落している .so ファイルが無く、かつ同じ .so ファイルに複数のバージョンが存在しない必要があります。\n\n"
    },
    {
      "title": "GPGPU のアクセラレーションがあるソフトウェア",
      "level": 2,
      "content": "- Bitcoin\n- Blender – Nvidia GPU 向けの CUDA のサポートと AMD GPU 向けの OpenCL のサポート。詳細はこちら。\n- BOINC\n- FFmpeg – 詳細はこちら。\n- Folding@home\n- GIMP – 実験段階 – 詳細はこちら。\n- HandBrake\n- Hashcat\n- LibreOffice Calc – 詳細はこちら。\n- mpv - mpv#ハードウェアビデオアクセラレーション を参照。\n- clinfo – システム上で利用可能な OpenCL プラットフォーム及びデバイスの可能な (既知の) 全プロパティを検出。\n- cuda_memtestAUR – GPU メモリテスト。その名前とは裏腹に、CUDA と OpenCL の両方をサポートしています。\n- darktable – OpenCL 機能を使うには GPU に最低でも 1GB のメモリが搭載されていて Image support が必要です (clinfo コマンドの出力で確認できます)。\n- DaVinci Resolve - ノンリニア動画エディタ。OpenCL と CUDA の両方を使えます。\n- imagemagick\n- lc0AUR - ニューラルネットワークの検索に使います (tensorflow、OpenCL、CUDA、そして openblas に対応)。\n- opencv\n- pyritAUR\n- python-pytorch-cuda - CUDA バックエンドの PyTorch\n- tensorflow-cuda - TensorFlow の CUDA への移植\n- tensorflow-computecppAUR - TensorFlow の SYCL への移植\n- whisper.cpp-clblasAUR、whisper.cpp-cublasAUR - OpenCL と CUDA の最適化が施された、OpenAI の Whisper モデルの C/C++ の移植。\n- xmrig - High Perf CryptoNote CPU と GPU (OpenCL, CUDA) マイナー\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- OpenCL 公式ホームページ\n- SYCL 公式ホームページ\n- SPIR 公式ホームページ\n- CUDA Toolkit ホームページ\n- Intel SDK for OpenCL Applications ホームページ\n- ComputeCpp 公式ホームページ\n- 異なる GPU 用に利用可能な OpenCL フレームワークのリスト\n\n"
    }
  ]
}