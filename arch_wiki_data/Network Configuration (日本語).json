{
  "title": "Network Configuration (日本語)",
  "url": "https://wiki.archlinux.org/title/Network_Configuration_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- ドメイン名前解決\n- ファイアウォール\n- インターネット共有\n- ネットワークデバッグ\n- ルーター\n\nこの記事では OSI レイヤ 3 (ネットワーク層) 以上のネットワーク設定を行う方法について説明しています。媒体固有の情報は ネットワーク設定/イーサネット と ネットワーク設定/ワイヤレス で扱っています。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 接続の確認 1.1 Ping\n- 2 ネットワーク管理 2.1 手動 2.1.1 iproute2 2.1.2 固定 IP アドレス 2.1.3 IP アドレス 2.1.4 ルーティングテーブル 2.2 自動 2.2.1 ネットワークマネージャ\n- 3 ネットワークインターフェイス 3.1 ネットワークインターフェイスを表示 3.2 ネットワークインターフェイスを有効化/無効化 3.3 インターフェイス名の変更 3.4 伝統的なインターフェイス名に戻す 3.5 MTU とキューの長さの設定\n- 4 ホスト名の設定 4.1 ローカルネットワークのホストネーム解決\n- 5 ヒントとテクニック 5.1 ボンディングまたは LAG 5.2 IP アドレスエイリアス 5.2.1 サンプル 5.3 プロミスキャスモード 5.4 ソケットの調査\n- 6 トラブルシューティング 6.1 TCP ウィンドウスケーリングの問題 6.1.1 問題の診断方法 6.1.2 修復方法 6.1.2.1 悪い方法 6.1.2.2 良い方法 6.1.2.3 最良の方法 6.1.3 詳細 6.2 接続された2台目の PC がブリッジ LAN を利用できない 6.3 localhost がネットワーク上で解決される\n- 7 参照\n\n- 1.1 Ping\n\n- 2.1 手動 2.1.1 iproute2 2.1.2 固定 IP アドレス 2.1.3 IP アドレス 2.1.4 ルーティングテーブル\n- 2.2 自動 2.2.1 ネットワークマネージャ\n\n- 2.1.1 iproute2\n- 2.1.2 固定 IP アドレス\n- 2.1.3 IP アドレス\n- 2.1.4 ルーティングテーブル\n\n- 2.2.1 ネットワークマネージャ\n\n- 3.1 ネットワークインターフェイスを表示\n- 3.2 ネットワークインターフェイスを有効化/無効化\n- 3.3 インターフェイス名の変更\n- 3.4 伝統的なインターフェイス名に戻す\n- 3.5 MTU とキューの長さの設定\n\n- 4.1 ローカルネットワークのホストネーム解決\n\n- 5.1 ボンディングまたは LAG\n- 5.2 IP アドレスエイリアス 5.2.1 サンプル\n- 5.3 プロミスキャスモード\n- 5.4 ソケットの調査\n\n- 5.2.1 サンプル\n\n- 6.1 TCP ウィンドウスケーリングの問題 6.1.1 問題の診断方法 6.1.2 修復方法 6.1.2.1 悪い方法 6.1.2.2 良い方法 6.1.2.3 最良の方法 6.1.3 詳細\n- 6.2 接続された2台目の PC がブリッジ LAN を利用できない\n- 6.3 localhost がネットワーク上で解決される\n\n- 6.1.1 問題の診断方法\n- 6.1.2 修復方法 6.1.2.1 悪い方法 6.1.2.2 良い方法 6.1.2.3 最良の方法\n- 6.1.3 詳細\n\n- 6.1.2.1 悪い方法\n- 6.1.2.2 良い方法\n- 6.1.2.3 最良の方法\n\n"
    },
    {
      "title": "接続の確認",
      "level": 2,
      "content": "ネットワーク接続のトラブルシューティングを行うには、以下の条件を調べ、満たしていることを確認します。\n\n1. あなたの ネットワークインターフェイス がリストアップされ、有効になっていること。そうでなければ、デバイスドライバを確認してください - ネットワーク設定/イーサネット#デバイスドライバ または ネットワーク設定/ワイヤレス#デバイスドライバ を参照してください。\n1. ネットワークに接続されている。ケーブルが接続されているか、無線LAN に接続されている。\n1. あなたのネットワークインターフェースには IP アドレスがある。\n1. ルーティングテーブル が正しく設定されている。\n1. ローカル IP アドレス (例えばデフォルトゲートウェイ) を ping することができる。\n1. 公開 IP アドレス(例えば 9.9.9.9 は Quad9 の DNS サーバで、テストに便利なアドレスです) を ping することも可能です。\n1. ドメイン名を解決ができるか確認 (例: archlinux.org)\n\n"
    },
    {
      "title": "Ping",
      "level": 3,
      "content": "ping は、ホストに到達できるかどうかをテストする際に用いられます。\n\n```\n$ ping www.example.com\n```\n\n```\nPING www.example.com (93.184.216.34) 56(84) bytes of data.\n64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=1 ttl=56 time=11.632 ms\n64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=2 ttl=56 time=11.726 ms\n64 bytes from 93.184.216.34 (93.184.216.34): icmp_seq=3 ttl=56 time=10.683 ms\n...\n```\n\nホストからの応答を受け取るたびに、ping ユーティリティは上記のような行を出力します。これは、ユーザが実行をインタラクティブに中断(Ctrl+c を押す)するまで続きます。さらなる情報は ping(8) マニュアルを見てください。また、コンピュータは ICMP エコーリクエストに応答しないように設定されている可能性があることに注意してください。[1]\n\nエラーメッセージを受け取った、または応答がなかった場合(ping エラー表示 を見てください)、不完全な設定やデフォルトゲートウェイ、インターネットサービスプロバイダ(ISP)と関連がある場合があります。traceroute を実行することで、ホストまでの経路をさらに診断することができます。\n\n"
    },
    {
      "title": "ネットワーク管理",
      "level": 2,
      "content": "ネットワーク接続の設定を行うには、以下の手順を踏んでください:\n\n1. ネットワークインターフェイスが表示されている、かつ有効化されていることを確認する。\n1. ネットワークに接続する。Ethernet ケーブルを接続するか、ワイヤレス LAN に接続してください。\n1. ネットワーク接続を設定する: ほとんどのネットワークではネットワークの設定に Dynamic Host Configuration Protocol が使用されています。クライアントは、スタンドアローンな DHCP クライアントによって、あるいはネットワークマネージャを使用することで、DHCP サーバから動的 IP アドレスや固定 IP アドレスを自動的に取得することができます。 ネットワークに DHCP サーバが存在しない場合は、それぞれのクライアントに対して固定 IP アドレス、ルーティングテーブル、DNS サーバを手動で設定できます。詳細は #固定 IP アドレス を参照してください。\n\n- ほとんどのネットワークではネットワークの設定に Dynamic Host Configuration Protocol が使用されています。クライアントは、スタンドアローンな DHCP クライアントによって、あるいはネットワークマネージャを使用することで、DHCP サーバから動的 IP アドレスや固定 IP アドレスを自動的に取得することができます。\n- ネットワークに DHCP サーバが存在しない場合は、それぞれのクライアントに対して固定 IP アドレス、ルーティングテーブル、DNS サーバを手動で設定できます。詳細は #固定 IP アドレス を参照してください。\n\n- Ethernet、WLAN、WWAN ネットワークインターフェイス用の DHCP クライアントとして設定された systemd-networkd\n- システム全体の DNS 用に設定された systemd-resolved (systemd-resolved#DNS)\n\n"
    },
    {
      "title": "iproute2",
      "level": 4,
      "content": "iproute2 は base メタパッケージの依存パッケージで、ip(8) コマンドラインインターフェイスを提供します。ip(8) はネットワークインターフェイスやIP アドレス、ルーティングテーブルの管理に使用されます。ip を使用して行った設定は再起動すると失われることに注意してください。設定の永続化は、スクリプトや systemd ユニットを使って ip コマンドを自動化したりすることで可能です。また、ip コマンドでは一般に略式記法を使うことができますが、この記事では分かりやすくするために略さずに明記します。\n\n"
    },
    {
      "title": "固定 IP アドレス",
      "level": 4,
      "content": "固定 IP アドレスはほとんどの標準的なネットワークマネージャやdhcpcdを使って設定できます。\n\n手動で固定 IP アドレスを設定するには、#IP アドレスで説明されているように IP アドレスを追加し、ルーティングテーブルをセットアップし、DNS サーバを設定してください。\n\n"
    },
    {
      "title": "IP アドレス",
      "level": 4,
      "content": "IP アドレスは ip-address(8) を使って管理します。\n\nIP アドレスを一覧表示するには:\n\n```\n$ ip address show\n```\n\nIP アドレスをインターフェイスに追加するには:\n\n```\n# ip address add address/prefix_len broadcast + dev interface\n```\n\n- アドレスは CIDR 表記を使用し、サブネットマスクも与えます。\n- + は、IP アドレスとサブネットマスクからブロードキャストアドレスを ip に導出させる特殊な記号です。\n\nIP アドレスをインターフェイスから削除するには:\n\n```\n# ip address del address/prefix_len dev interface\n```\n\n条件に一致するすべてのアドレスを削除するには(例: 特定のインターフェイスの IP アドレス):\n\n```\n# ip address flush dev interface\n```\n\n"
    },
    {
      "title": "ルーティングテーブル",
      "level": 4,
      "content": "ルーティングテーブルは、ある IP アドレスに直接到達できるか、どのゲートウェイ(ルータ)を使用すべきかを判断するのに使用します。IP アドレスと合致するルートが存在しない場合、デフォルトゲートウェイが使用されます。\n\nルーティングテーブルは ip-route(8) を使用して管理します。\n\nPREFIX は CIDR 表記であるか、デフォルトゲートウェイに対しては default です。\n\nIPv4 ルートを一覧表示するには:\n\n```\n$ ip route show\n```\n\nIPv6 ルートを一覧表示するには:\n\n```\n$ ip -6 route show\n```\n\nルートを追加するには:\n\n```\n# ip route add PREFIX via address dev interface\n```\n\nルートを削除するには:\n\n```\n# ip route del PREFIX via address dev interface\n```\n\n"
    },
    {
      "title": "自動",
      "level": 3,
      "content": "自動的なネットワーク設定は、Dynamic Host Configuration Protocol (DHCP) を用いることで可能になります。ネットワークの DHCP サーバは、IP アドレス、デフォルトゲートウェイの IP アドレスを提供し、さらにオプションで DHCP クライアントからリクエストが送られたときには DNS ネームサーバも提供します。\n\nDHCP サーバの比較表は ルーター#DNS と DHCP を見てください。\n\n"
    },
    {
      "title": "ネットワークマネージャ",
      "level": 4,
      "content": "ネットワークマネージャは、ネットワークプロファイルと呼ばれるものを使ってネットワーク接続の設定を管理して、ネットワークの切り替えを容易にします。\n\nTable content:\nソフトウェア | 接続タイプ | ワイヤレス認証 | IP アドレス、ルート (route)、そして DNS の管理 | インターフェイス\nイーサネット | PPPoE | モバイルブロードバンド | WPA/WPA2 | WPA3 | 固定 IP | DHCP クライアント | ドメイン名前解決 | CLI | TUI | GUI\ndhclient1 | Yes | No | No | No2 | Yes | 内蔵 | Yes (/etc/resolv.conf に書き込み) | No | No | No\ndhcpcd | Yes | No | No | wpa_supplicant を起動3 | Yes | 内蔵 | Yes (resolvconf を使用、または /etc/resolv.conf に書き込み) | No | No | dhcpcd-uiAUR\nConnMan | Yes | [リンク切れ 2023-10-29] No | Yes (ofonoAUR によって) | Yes (wpa_supplicant または iwd によって) | Yes | 内蔵 | Yes (内蔵のリゾルバを実行し、/etc/resolv.conf に書き込み) | connmanctl(1) | Yes | Yes\nnetctl | Yes | Yes (ppp によって) | Yes (ppp によって) | Yes (wpa_supplicant によって) | No | Yes | dhcpcd または dhclient | Yes (resolvconf を使用) | netctl(1) | wifi-menu(1)4 | No\nNetworkManager | Yes | Yes (rp-pppoe によって) | Yes (modemmanager によって) | Yes (wpa_supplicant または iwd によって) | Yes | 内蔵、dhclient、dhcpcd5 のいずれかによって | Yes (systemd-resolved、resolvconf を使用、または /etc/resolv.conf に書き込み) | nmcli(1) | nmtui(1) | Yes\nsystemd-networkd | Yes | No | No | No2 | Yes | 内蔵 | Yes (systemd-resolved を使用) | networkctl(1) | No | No\nwpa_supplicant | IEEE 802.1X | No | No | Yes | Yes | No | wpa_cli(8) | No | wpa_supplicant_guiAUR\niwd | IEEE 802.1X | No | No | Yes | Yes | Yes | 内蔵 | Yes (systemd-resolved または resolvconf を使用) | iwctl(1) | impala | iwgtkAUR\n\n1. 2022 初頭の時点ではもはやメンテナンスされていません。ISC は本番環境で使用することを推奨していません。\n1. ワイヤレス認証は wpa_supplicant または iwd によって別に設定することができます。\n1. ワイヤレス認証は wpa_supplicant によって別に設定しなければなりません。\n1. Wi-Fi 接続のみを管理できます。\n1. NetworkManager は DHCPv6 に dhcpcd を使用しません。NetworkManager#DHCP クライアント を参照してください。\n\n"
    },
    {
      "title": "ネットワークインターフェイス",
      "level": 2,
      "content": "ネットワークインターフェイスは udev によって管理されており、systemd.link(5) ファイルによって設定します。デフォルトの設定では、Predictable Network Interface Names を使ってネットワークインターフェイスコントローラーに名前を割り当てていきます。この命名法では、インターフェイス名の前に en (有線/イーサネット)、wl (無線/WLAN)、ww (モバイルブロードバンド/WWAN) のどれかが付きます。systemd.net-naming-scheme(7) を参照してください。\n\n- 一般に、/usr/lib/systemd/network/99-default.link はほとんどのケースで十分です。\n- インターフェイス名を変更するには、#インターフェイス名の変更 と #伝統的なインターフェイス名に戻す を参照してください。\n- udevadm test-builtin net_setup_link /sys/path/to/network/device を root ユーザーとして実行することで、.link ファイルの問題を診断することができます。\n\n"
    },
    {
      "title": "ネットワークインターフェイスを表示",
      "level": 3,
      "content": "有線インターフェイスと無線インターフェイスの両方の名前は ls /sys/class/net や ip link で見つけることができます。lo は 仮想ループバックインターフェイスであり、ネットワーク接続の際には使用されないことに注意してください。\n\n無線デバイス名は iw dev を使用することでも取得できます。ネットワーク設定/ワイヤレス#インターフェイス名の取得も参照してください。\n\n使用中のネットワークインターフェイスが表示されない場合、デバイスドライバが正しくロードされていることを確認してください。ネットワーク設定/イーサネット#デバイスドライバ や ネットワーク設定/ワイヤレス#デバイスドライバ を参照してください。iwd デーモンが実行されている場合は、iwctl device list でも可能です。\n\n"
    },
    {
      "title": "ネットワークインターフェイスを有効化/無効化",
      "level": 3,
      "content": "ネットワークインターフェイスは ip link set interface up|down を使用することで有効化/無効化できます。ip-link(8) を参照してください。\n\nインターフェイス enp2s0 の状態を確認するには:\n\n```\n$ ip link show dev enp2s0\n```\n\n```\n2: enp2s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master br0 state DOWN mode DEFAULT qlen 1000\n...\n```\n\n<BROADCAST,MULTICAST,UP,LOWER_UP> の部分の UP はインターフェイスが立ち上がっていることを示しています。後ろにある state DOWN は関係ありません。\n\n"
    },
    {
      "title": "インターフェイス名の変更",
      "level": 3,
      "content": "systemd.link(5) ファイルで名前を手動で定義してデバイス名を変更することができます。例:\n\n```\n/etc/systemd/network/10-net0.link\n```\n\n```\n[Match]\nPermanentMACAddress=aa:bb:cc:dd:ee:ff\n\n[Link]\nName=net0\n```\n\nあるいは、udev ルールを使うこともできます:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTR{address}==\"aa:bb:cc:dd:ee:ff\", NAME=\"net0\"\n```\n\n上記のルールは起動時に自動的に適用されます。即座に変更を適用するには、net サブシステムの udev ルールを手動でトリガーしてください:\n\n```\n# udevadm trigger --verbose --subsystem-match=net --action=add\n```\n\n加えた変更をテストしたい場合、udevadm --debug test /sys/class/net/* が役立つでしょう。\n\n- Name の優先順位は NamePolicy よりも低いです。なので、後者が設定されていない/空であるようにするか、名前が変更されないようにしてください。99-default.link は NamePolicy を設定するので、これの前にカスタムの設定が来るようにしなければなりません (つまり、数字の接頭辞を持つということ)。\n- ネットワークインターフェイスの名前を変更する前に、そのインターフェイスを落しておかなければなりません。 [3]\n- 各カードの MAC アドレスを得るには、ip link を実行してください。\n- udev ルールでは小文字の16進数を使用してください。大文字ではいけません。\n\nネットワークカードの MAC アドレスが動的である場合は、Path を使用できます (Path は networkctl status interface_name で確認できます):\n\n```\n/etc/systemd/network/10-net1.link\n```\n\n```\n[Match]\nPath=pci-0000:01:00.0\n\n[Link]\nName=net1\n```\n\nあるいは、udev で DEVPATH を使用できます:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", DEVPATH==\"/devices/pci*/*1c.0/*/net/*\", NAME=\"net1\"\n```\n\n現在接続されているすべてのデバイスの DEVPATH を取得するには、/sys/class/net/ 内のシンボリックリンクがどこにリンクされているかを見てください。例:\n\n```\n$ file /sys/class/net/*\n```\n\n```\n/sys/class/net/enp0s20f0u4u1: symbolic link to ../../devices/pci0000:00/0000:00:14.0/usb2/2-4/2-4.1/2-4.1:1.0/net/enp0s20f0u4u1\n/sys/class/net/enp0s31f6:     symbolic link to ../../devices/pci0000:00/0000:00:1f.6/net/enp0s31f6\n/sys/class/net/lo:            symbolic link to ../../devices/virtual/net/lo\n/sys/class/net/wlp4s0:        symbolic link to ../../devices/pci0000:00/0000:00:1c.6/0000:04:00.0/net/wlp4s0\n```\n\nルールは起動時に複数回実行されることがあるので、デバイスのパスは新しいデバイス名と古いデバイス名両方にマッチする必要があります。例えば、与えられたルールで、\"/devices/pci*/*1c.0/*/net/en*\" と設定すると困ったことになります。名前が net1 に変更されるとマッチしなくなるからです。システムのデフォルトルールだけが再度適用され、名前がに戻ってしまいます。\n\n動的 MAC アドレスのある USB ネットワークデバイス (例: Android phone テザリング) を使用していて、異なる USB ポートを使えるようにしたい場合、ベンダ ID やモデル ID とマッチするルールを代わりに使用することができます:\n\n```\n/etc/systemd/network/20-net2.link\n```\n\n```\n[Match]\nProperty=ID_VENDOR_ID=12ab ID_MODEL_ID=3cd4\n\n[Link]\nName=net2\n```\n\nまたは\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nSUBSYSTEM==\"net\", ACTION==\"add\", ATTRS{idVendor}==\"12ab\", ATTRS{idProduct}==\"3cd4\", NAME=\"net2\"\n```\n\n"
    },
    {
      "title": "伝統的なインターフェイス名に戻す",
      "level": 3,
      "content": "eth0 のような伝統的なインターフェイス名に戻したい場合、udev の net_setup_link ビルトインの NamePolicy のデフォルトを変更することで Predictable Network Interface Names を無効化できます:\n\n```\n/etc/systemd/network/99-default.link.d/traditional-naming.conf\n```\n\n```\n[Link]\nNamePolicy=keep kernel\n```\n\nまたは、net_setup_link を完全に無効化することもできます。対応する udev ルールをマスクするか:\n\n```\n# ln -s /dev/null /etc/udev/rules.d/80-net-setup-link.rules\n```\n\nあるいは、net.ifnames=0 をカーネルパラメータに追加してください。\n\n"
    },
    {
      "title": "MTU とキューの長さの設定",
      "level": 3,
      "content": "systemd.link(5) の設定で手動で定義することで、デバイスの MTU とキューの長さを変更することができます。例えば:\n\n```\n/etc/systemd/network/30-mtu.link\n```\n\n```\n[Match]\nType=wlan\n\n[Link]\nMTUBytes=1500\nTransmitQueueLength=2000\n```\n\nあるいは、udev ルールを使って:\n\n```\n/etc/udev/rules.d/10-network.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"net\", KERNEL==\"wl*\", ATTR{mtu}=\"1500\", ATTR{tx_queue_len}=\"2000\"\n```\n\nMTUBytes: 1500 よりも大きい値を使用することで (ジャンボフレームと呼ばれます)、ネットワークの転送速度を大幅に増加させることができます。すべてのネットワークインターフェイス(ローカルネットワークのスイッチを含む)が、ジャンボフレームを使うために同じ MTU をサポートしなければならないことに注意してください。PPPoE の場合、MTU は 1492 よりも大きくするべきではありません。MTU は systemd.netdev(5) によっても設定することができます。\n\nTransmitQueueLength: モデルリンクや ISDN のような高レイテンシの低速デバイスでは小さい値。インターネット接続が高速で、大量のデータ転送を行うサーバでは大きい値が推奨されます。\n\n"
    },
    {
      "title": "ホスト名の設定",
      "level": 2,
      "content": "ホスト名とは、ネットワーク上でマシンを識別するために作られる唯一の（ユニークな）名前であり、/etc/hostname に設定します (詳しくは hostname(5) と hostname(7) を参照)。このファイルにはシステムのドメイン名を含めることもできます。ホストネームを設定するには /etc/hostname を編集し、yourhostname の1行を書いてください (実際にはあなたの好きな名前を使ってください):\n\n```\n/etc/hostname\n```\n\n```\nyourhostname\n```\n\n上記の方法の代わりに、hostnamectl(1) を使うこともできます:\n\n```\n# hostnamectl hostname yourhostname\n```\n\nhostname を一時的に設定するには、inetutils の hostname(1) を使います (再起動するまで有効):\n\n```\n# hostname yourhostname\n```\n\n\"pretty\" hostname や他のマシンのメタデータを設定する方法は、machine-info(5) を参照してください。\n\n"
    },
    {
      "title": "ローカルネットワークのホストネーム解決",
      "level": 3,
      "content": "マシンがホストネームを使って LAN 内でアクセスできるようにするには、以下の方法を取ることができます:\n\n- LAN 内のすべてのデバイスの /etc/hosts ファイルを編集する、hosts(5) を見てください\n- ホストネームを解決する DNS サーバーをセットアップし、LAN のデバイスにそれを使用させる (例えば、DHCP を使う)\n- または、より簡単な方法を取る: ゼロコンフィグレーションネットワークサービスを使う: NetBIOS によるホストネーム解決。Linux の Samba により提供されています。必要なのは nmb.service だけです。Windows や macOS、nmb が動作している Linux のコンピュータからマシンを見つけられるようになります。 mDNS によるホストネーム解決。nss_mdns と Avahi を使う(セットアップの詳細は Avahi#ホスト名の解決で)か、systemd-resolved を使うことにより可能です。macOS や、Avahi や systemd-resolved が動作している Linux のコンピュータがマシンを見つけられるようになります。古い Win32 API は mDNS をサポートしておらず、一部の古い Windows アプリケーションはデバイスにアクセスできない場合があります。\n\n- NetBIOS によるホストネーム解決。Linux の Samba により提供されています。必要なのは nmb.service だけです。Windows や macOS、nmb が動作している Linux のコンピュータからマシンを見つけられるようになります。\n- mDNS によるホストネーム解決。nss_mdns と Avahi を使う(セットアップの詳細は Avahi#ホスト名の解決で)か、systemd-resolved を使うことにより可能です。macOS や、Avahi や systemd-resolved が動作している Linux のコンピュータがマシンを見つけられるようになります。古い Win32 API は mDNS をサポートしておらず、一部の古い Windows アプリケーションはデバイスにアクセスできない場合があります。\n\n"
    },
    {
      "title": "ボンディングまたは LAG",
      "level": 3,
      "content": "netctl#ボンディング や systemd-networkd#ワイヤード (有線) インターフェイスとワイヤレスインターフェイスのボンディング、ワイヤレスボンディング を見てください。\n\n"
    },
    {
      "title": "IP アドレスエイリアス",
      "level": 3,
      "content": "ひとつのネットワークインターフェースに複数の IP アドレスを加えることを IP エイリアスと呼びます。これをすることで、ネットワークのひとつのノードでネットワークに複数接続することができ、それぞれを別々に使うことができます。基本的に Web・FTP サーバーの仮想ホスティングや、サーバーの再構成 (他のマシンを更新しない、ネームサーバで有用) に使われます。\n\n"
    },
    {
      "title": "サンプル",
      "level": 4,
      "content": "iproute2 ツールを使って NIC のエイリアスを手動で設定するには次を実行:\n\n```\n$ ip addr add 192.168.1.10/24 dev enp1s0 label enp1s0:1\n```\n\n設定したエイリアスを削除するには:\n\n```\n$ ip addr del 192.168.1.10/24 dev enp1s0:1\n```\n\nサブネットへ向かうパケットはデフォルトでプライマリエイリアスを使います。送信先 IP がセカンダリエイリアスのサブネット内のものである場合は、送信元 IP がそれぞれに設定されます。複数の NIC が存在する場合を考えた場合、ip route でデフォルトルートを列挙することができます。\n\n"
    },
    {
      "title": "プロミスキャスモード",
      "level": 3,
      "content": "プロミスキャスモードを有効にすると (無線) NIC は受信したトラフィックを全て OS に転送します。反対に\"ノーマルモード\"では受信されるべきでないとき NIC はフレームをドロップします。プロミスキャスモードは高度なネットワークのトラブルシューティングやパケットスニッフィングなどのために使われます。\n\n```\n/etc/systemd/system/promiscuous@.service\n```\n\n```\n[Unit]\nDescription=Set %i interface in promiscuous mode\nAfter=network.target\n\n[Service]\nType=oneshot\nExecStart=/usr/bin/ip link set dev %i promisc on\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n\nインターフェイス eth0 でプロミスキャスモードを有効にしたい場合、promiscuous@eth0.service を有効化してください。\n\n"
    },
    {
      "title": "ソケットの調査",
      "level": 3,
      "content": "ss はネットワークポートを調査するユーティリティで、iproute2 パッケージの一部です。機能的には非推奨の netstat ユーティリティと似ています。\n\n共通の利用方法は以下のようなものです:\n\nすべての TCP ソケットをサービス名と共に表示する:\n\n```\n$ ss -at\n```\n\nすべての TCP ソケットをポート番号と共に表示する:\n\n```\n$ ss -atn\n```\n\nすべての UDP ソケットを表示する:\n\n```\n$ ss -au\n```\n\nさらなる情報は ss(8) を見てください。\n\n"
    },
    {
      "title": "TCP ウィンドウスケーリングの問題",
      "level": 3,
      "content": "TCP パケットのヘッダには\"ウィンドウ\"値が含まれており、他のホストが返答として送信できるデータの量が示されています。この値は16ビットでしか表現できないので、ウィンドウサイズは最大 64 Kb です。TCP パケットはしばらくの間キャッシュに保存されますが (再度使われます)、メモリの量は(少なくとも昔は)限られているので、すぐに使いきってしまうことがあります。\n\n1992年、利用できるメモリの量が大幅に増えるのにあわせて、この状態を改善するために RFC:1323: ウィンドウスケーリングが書かれました。全てのパケットに含まれている\"ウィンドウ\"の値を、スケールファクタ (Scale Factor) を定義することで、接続の初期段階で変更します。8ビットのスケールファクタなら、ウィンドウは 64Kb の32倍まで増やすことができます。\n\n壊れたルーターやファイアウォールはスケールファクタを 0 に書き換えてしまうためホスト間での不和が発生します。Linux カーネル 2.6.17 ではスケールファクタを上げるための新しい算出方式が導入されましたが、それによってルーターやファイアウォールが壊れているときの影響が増え、極端に接続が遅かったり、全く接続できない状態が生まれています。\n\n"
    },
    {
      "title": "問題の診断方法",
      "level": 4,
      "content": "まず最初に問題をはっきりさせましょう: この問題は少々厄介です。ある条件下では、TCP 接続 (HTTP, FTP, ...) を全く使えないのに、他の条件では、特定の (ごく少数の) ホストとは通信できるというようなことが起こります。\n\nこの問題が発生していても、dmesg の出力に問題はなく、ログに異常は見られず、そして ip addr では通常状態だと報告されます。全てが問題ないように(表面上は)見えるわけです。\n\nウェブサイトが表示できないのに、ping は通る場合、この問題が発生している可能性は十分あるでしょう: ping は TCP の問題に影響されない ICMP を使っているためです。\n\nWireshark を使ってみてください。UDP と ICMP の接続は通るのに (ホストが海外の) TCP 接続は通らないはずです。\n\n"
    },
    {
      "title": "修復方法",
      "level": 4,
      "content": "無理やり修正する方法として、スケールファクタの計算に使われている tcp_rmem の値を変更することができます。ほとんどのホストではこれで問題ありませんが、全てのホストで上手く行くとは保証できません。特にホストが遠い場合に問題が起きやすいです。\n\n```\n# echo \"4096 87380 174760\" > /proc/sys/net/ipv4/tcp_rmem\n```\n\nウィンドウスケーリングを無効化してしまいます。ウィンドウスケーリングは TCP の素晴らしい機能なので、無効化してしまうのは忍びないですが、ルーターを修復できない場合は致し方ありません。ウィンドウスケーリングを無効化する方法は複数存在します。一番安牌の (ほとんどのカーネルで動作する) 方法としては /etc/sysctl.d/99-disable_window_scaling.conf に以下の行を追加してください (sysctl を参照):\n\n```\nnet.ipv4.tcp_window_scaling = 0\n```\n\nこの問題の原因はルーターやファイアウォールの動作がおかしいせいなので、それらを変えてしまいましょう。専用の DSL ルーターを使っている場合に問題になることがあるという報告もあります。\n\n"
    },
    {
      "title": "詳細",
      "level": 4,
      "content": "このセクションは LWN の記事 TCP window scaling and broken routers と Kernel Trap の記事 Window Scaling on the Internet. を基にしています。\n\nまた、LKML に関連するスレッドが複数存在します。\n\n"
    },
    {
      "title": "接続された2台目の PC がブリッジ LAN を利用できない",
      "level": 3,
      "content": "1台目の PC には2つの LAN があります。2台目の PC には1つの LAN があり、1台目の PC に接続されています。2台目の PC が、ブリッジインターフェイスのあとに LAN にアクセスできるようにしましょう:\n\n```\n# sysctl net.bridge.bridge-nf-filter-pppoe-tagged=0\n# sysctl net.bridge.bridge-nf-filter-vlan-tagged=0\n# sysctl net.bridge.bridge-nf-call-ip6tables=0\n# sysctl net.bridge.bridge-nf-call-iptables=0\n# sysctl net.bridge.bridge-nf-call-arptables=0\n```\n\n"
    },
    {
      "title": "localhost がネットワーク上で解決される",
      "level": 3,
      "content": "nss-myhostname(8) は、(systemd によって提供され、/etc/nsswitch.conf でデフォルトで有効になっています) NSS モジュール は、localhost および IP アドレスへの localhost 名を解決します。ただし、一部のソフトウェアは代わりに /etc/hosts を直接読み取る場合があります。例については、[4] [5] を参照してください。\n\nこのようなソフトウェアがネットワーク経由で localhost を安全でない方法で解決しないようにするには、localhost のエントリを hosts(5) ファイルに追加します:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n```\n\nlocalhost を解決できるようにするには、さらに hosts(5) ファイルに追加します:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n127.0.1.1        yourhostname\n```\n\n永続的な IP アドレスを持つシステムの場合、127.0.1.1 をその永続的な IP アドレスに置き換えます。Fully Qualified Domain Name を持つシステムの場合、ホスト名の前に Fully Qualified Domain Name を挿入します (次のリンクを参照 理由) 例えば:\n\n```\n/etc/hosts\n```\n\n```\n127.0.0.1        localhost\n::1              localhost\n203.0.113.45     host1.fqdomain.example host1\n```\n\nその結果、システムは両方のエントリに解決されます:\n\n```\n$ getent hosts\n```\n\n```\n127.0.0.1       localhost\n127.0.0.1       localhost\n127.0.1.1       yourhostname\n```\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Linux Network Administrators Guide\n- Debian リファレンス: ネットワークの設定\n- RHEL7: ネットワークガイド\n- Monitoring and tuning the Linux Networking Stack: Receiving data\n- Monitoring and tuning the Linux Networking Stack: Sending data\n- Tracing a packet journey using tracepoints, perf and eBPF\n\n"
    }
  ]
}