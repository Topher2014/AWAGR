{
  "title": "Maximizing performance (Español)",
  "url": "https://wiki.archlinux.org/title/Maximizing_performance_(Espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **2022-09-28** \n\nArtículos relacionados\n\n- Optimizar el arranque\n- Optimizar pacman\n- Acelerar SSH\n- Openoffice#Speed up OpenOffice\n- Portátil\n- Precarga\n\nEste artículo proporciona información sobre los diagnósticos básicos del sistema relacionados con el rendimiento, así como los pasos que se pueden tomar para reducir el consumo de recursos o para optimizar el sistema con el objetivo final de obtener mejoras percibidas o documentadas en el rendimiento del sistema.\n\n"
    },
    {
      "title": "Conozca su sistema",
      "level": 2,
      "content": "La mejor manera de ajustar un sistema es centrarse en cuellos de botella o subsistemas que limiten la velocidad general. Las especificaciones del sistema pueden ayudar a identificarlos.\n\n- Si la computadora se vuelve lenta cuando se ejecutan aplicaciones grandes (como LibreOffice y Firefox) al mismo tiempo, verifique si la cantidad de RAM es suficiente. Utilice la siguiente orden y marque la columna \"available\" (disponible):\n\n```\n$ free -h\n```\n\n- Si el tiempo de arranque es lento y las aplicaciones tardan mucho en cargarse en el primer inicio (únicamente), es probable que el disco duro sea el culpable. La velocidad de un disco duro se puede medir con la orden hdparm:\n\n```\n# hdparm -t /dev/sdX\n```\n\n- Si la carga de la CPU es constantemente alta incluso con suficiente RAM disponible, intente reducir el uso de la CPU desactivando la ejecución de demonios y/o procesos. Esto se puede monitorear de varias maneras, por ejemplo, con htop, pstree o cualquier otra herramienta monitor del sistema:\n\n```\n$ htop\n```\n\n- Si las aplicaciones que usan renderizado directo son lentas (es decir, aquellas que utilizan la GPU, como reproductores de video, juegos o incluso un administrador de ventanas), entonces mejorar el rendimiento de la GPU debería ayudar. El primer paso es verificar si la renderización directa está realmente activada. Esto se indica mediante la orden glxinfo, parte del paquete mesa-utils:\n\n```\n$ glxinfo | grep \"direct rendering\"\n```\n\n```\ndirect rendering: Yes\n```\n\n- Cuando se ejecuta un entorno de escritorio, la desactivación de los efectos visuales (no utilizados) del escritorio puede reducir el uso de la GPU. Utilice un entorno más ligero o cree un entorno personalizado si el actual no cumple con los requisitos de hardware y/o personales.\n\n"
    },
    {
      "title": "Benchmarking",
      "level": 3,
      "content": "Los efectos de la optimización suelen ser difíciles de juzgar. Sin embargo, pueden medirse mediante herramientas de evaluación.\n\n"
    },
    {
      "title": "Varias rutas de hardware",
      "level": 3,
      "content": "Una ruta de hardware interna es cómo se conecta el dispositivo de almacenamiento a su placa base. Hay diferentes formas de conectarse a la placa base, como TCP/IP a través de una NIC, conectadas directamente mediante PCIe/PCI, Firewire, tarjeta RAID, USB, etc. Al distribuir sus dispositivos de almacenamiento a través de múltiples puntos de conexión, maximiza las capacidades de su placa base, por ejemplo, 6 discos duros conectados a través de USB serían mucho más lentos que 3 a través de USB y 3 a través de Firewire. La razón es que cada ruta de entrada a la placa base es como una tubería, y hay un límite establecido de cuánto puede pasar por dicha tubería en un momento dado. La buena noticia es que la placa base suele tener varios conductos.\n\nMás ejemplos:\n\n1. Directamente a la placa base usando PCI/PCIe/ATA\n1. Mediante una caja externa para alojar el disco a través de USB/Firewire\n1. Convirtiendo el dispositivo en un dispositivo de almacenamiento en red conectándose a través de TCP/IP\n\nTenga en cuenta también que si tiene 2 puertos USB en la parte frontal de su máquina y 4 puertos USB en la parte posterior, y tiene 4 discos, probablemente sería más rápido colocar 2 en la parte frontal/2 en la parte posterior que 3 en la parte posterior/1 en el frente. Esto se debe a que, internamente, los puertos frontales probablemente sean un concentrador raíz separado que el posterior, lo que significa que puede enviar el doble de datos usando ambos que solo 1. Use las siguientes órdenes para determinar las diversas rutas en su máquina.\n\n```\nÁrbol de dispositivos USB\n```\n\n```\n$ lsusb -t\n```\n\n```\nÁrbol de dispositivos PCI\n```\n\n```\n$ lspci -tv\n```\n\n"
    },
    {
      "title": "Particionamiento",
      "level": 3,
      "content": "Asegúrese de que sus particiones estén correctamente alineadas.\n\n"
    },
    {
      "title": "Varias unidades",
      "level": 4,
      "content": "Si tiene varios discos disponibles, puede configurarlos como RAID software para obtener importantes mejoras de velocidad.\n\nLa creación del espacio de intercambio en un disco separado también puede ayudar bastante, especialmente si su máquina la emplea con frecuencia.\n\n"
    },
    {
      "title": "Disposición en discos duros",
      "level": 4,
      "content": "Si utiliza un disco duro mecánico tradicional, el diseño de su partición puede influir en el rendimiento del sistema. Los sectores al principio de la unidad (más cercanos al exterior del disco) son más rápidos que los del final. Además, una partición más pequeña requiere menos movimientos del cabezal de la unidad y, por lo tanto, acelera las operaciones del disco. Por lo tanto, se recomienda crear una partición pequeña (10 GB, más o menos según sus necesidades) solo para su sistema, lo más cerca posible del comienzo de la unidad. Otros datos (imágenes, vídeos) deben mantenerse en una partición separada, y esto generalmente se logra separando el directorio de inicio (/home/usuario) del sistema (/).\n\n"
    },
    {
      "title": "Elegir y ajustar su sistema de archivos",
      "level": 3,
      "content": "Elegir el mejor sistema de archivos para un sistema específico es muy importante porque cada uno tiene sus propios puntos fuertes. El artículo Sistemas de archivos proporciona un breve resumen de los más populares. También puede encontrar artículos relevantes en Category:File systems (Español).\n\n"
    },
    {
      "title": "Opciones de montaje",
      "level": 4,
      "content": "La opción noatime se sabe que mejora el rendimiento del sistema de archivos.\n\nOtras opciones de montaje son específicas del sistema de archivos, por lo tanto, véase los artículos relevantes para los sistemas de archivos:\n\n- Ext3 (Español)\n- Ext4#Improving performance\n- JFS Filesystem#Optimizations\n- XFS#Performance\n- Btrfs (Español)#Desfragmentación, Btrfs (Español)#Compresión y btrfs(5)\n- ZFS#Tuning\n\nLa opción de montaje data=writeback mejora la velocidad, pero puede dañar los datos durante una pérdida de energía. La opción de montaje notail aumenta el espacio utilizado por el sistema de archivos en aproximadamente un 5%, pero también mejora la velocidad en general. También puede reducir la carga del disco colocando el diario (journal) y los datos en unidades independientes. Esto se hace al crear el sistema de archivos:\n\n```\n# mkreiserfs –j /dev/sda1 /dev/sdb1\n```\n\nReemplace /dev/sda1 con la partición reservada para el diario, y /dev/sdb1 con la partición para datos. Puede obtener más información sobre reiserfs con este artículo.\n\n"
    },
    {
      "title": "Ajuste de los parámetros del kernel",
      "level": 3,
      "content": "Hay varios parámetros clave ajustables que afectan el rendimiento de los dispositivos de bloque; véase sysctl#Virtual memory para obtener más información.\n\n"
    },
    {
      "title": "Información de contexto",
      "level": 4,
      "content": "El planificador (scheduler) de entrada/salida (E/S) es el componente del kernel que decide en qué orden se envían las operaciones de E/S de bloque a los dispositivos de almacenamiento. Es útil recordar aquí algunas especificaciones de dos tipos de unidades principales, porque el objetivo del planificador de E/S es optimizar la forma en que estos pueden manejar las solicitudes de lectura:\n\n- Un HDD tiene discos giratorios y un cabezal que se mueve físicamente a la ubicación requerida. Por lo tanto, la latencia aleatoria es bastante alta, oscilando entre 3 y 12ms (ya sea una unidad de servidor de gama alta o una unidad de computadora portátil y sin pasar por el búfer de escritura del controlador de disco) mientras que el acceso secuencial proporciona un rendimiento mucho mayor. El rendimiento típico del disco duro es de aproximadamente 200 operaciones de E/S por segundo (IOPS).\n\n- Un SSD no tiene partes móviles, el acceso aleatorio es tan rápido como el secuencial, por lo general menos de 0,1ms, y puede manejar múltiples solicitudes simultáneas. El rendimiento típico de SSD es superior a 10.000 IOPS, que es más de lo necesario en situaciones de carga de trabajo habituales.\n\nSi hay muchos procesos que realizan solicitudes de E/S a diferentes partes de almacenamiento, se pueden generar miles de IOPS, mientras que un HDD típico solo puede manejar alrededor de 200 IOPS. Hay una cola de solicitudes que deben esperar para acceder al almacenamiento. Aquí es donde los planificadores de E/S juegan un papel de optimización.\n\n"
    },
    {
      "title": "Los algoritmos del planificador",
      "level": 4,
      "content": "Una forma de mejorar el rendimiento es hacer lineal el acceso: ordenando las solicitudes en espera por su dirección lógica y agrupando las más cercanas. Históricamente, este fue el primer planificador de E/S de Linux llamado ascensor.\n\nUn problema con el algoritmo del ascensor es que no es óptimo para un proceso que realiza un acceso secuencial: leer un bloque de datos, procesarlo durante varios microsegundos, leer el siguiente bloque y así sucesivamente. El planificador del ascensor no sabe que el proceso está a punto de leer otro bloque cercano y, por lo tanto, pasa a otra solicitud mediante otro proceso en otra ubicación. El planificador de E/S anticipatoria soluciona el problema: hace una pausa de unos milisegundos en anticipación de otra operación de lectura cercana antes de atender otra solicitud.\n\nSi bien estos planificadores intentan mejorar el rendimiento total, pueden dejar algunas solicitudes esperando durante mucho tiempo. Como ejemplo, imagine que la mayoría de los procesos realizan solicitudes al comienzo del espacio de almacenamiento, mientras que un proceso realiza una solicitud en el otro extremo del almacenamiento. Este aplazamiento potencialmente infinito del proceso se llama inanición. Para mejorar la equidad, se desarrolló el algoritmo fecha límite. Tiene una cola ordenada por dirección, similar al ascensor, pero si alguna solicitud permanece en esta cola durante demasiado tiempo, se mueve a una cola \"expirada\" ordenada por tiempo de expiración. El planificador verifica primero la cola de vencimiento y procesa las solicitudes desde allí y solo luego se mueve a la cola del elevador. Tenga en cuenta que esta equidad tiene un impacto negativo en el rendimiento general.\n\nCompletely Fair Queuing (CFQ) aborda el problema de manera diferente al asignar un intervalo de tiempo y un número de solicitudes permitidas por cola dependiendo de la prioridad del proceso que las envía. Es compatible con cgroup que permite reservar cierta cantidad de E/S para una selección específica de procesos. Es particularmente útil para el alojamiento compartido y en la nube: los usuarios que pagaron por algunas IOPS quieren obtener su parte cuando sea necesario. Además, permanece inactivo al final de la E/S síncrona esperando otras operaciones cercanas, asumiendo esta función del planificador \"anticipatorio\" y aportando algunas mejoras. Tanto el planificador \"anticipatorio\" como el \"ascensor\" fueron retirados del kernel de Linux reemplazados por las alternativas más avanzadas presentadas anteriormente.\n\nBudget Fair Queueing (BFQ)[enlace roto 2024-12-15] se basa en el código CFQ y trae algunas mejoras. No otorga el disco a cada proceso durante un intervalo de tiempo fijo, sino que asigna un \"presupuesto\" medido en número de sectores al proceso y utiliza heurísticas. Es un planificador relativamente complejo, puede estar más adaptado a unidades mecánicas y SSD lentos porque su alta sobrecarga por operación, especialmente si está asociada con una CPU lenta, puede ralentizar los dispositivos rápidos. El objetivo de BFQ en sistemas personales es que, para tareas interactivas, el dispositivo de almacenamiento sea virtualmente tan responsivo (responsive) como si estuviera inactivo. En su configuración predeterminada, se centra en ofrecer la latencia más baja en lugar de lograr el rendimiento máximo.\n\nKyber es un planificador reciente inspirado en las técnicas de administración de colas activas utilizadas para el enrutamiento de la red. La implementación se basa en \"fichas\" (tokens) que sirven como mecanismo para limitar las solicitudes. Se requiere una ficha de cola para asignar una solicitud, esto se usa para evitar la falta de solicitudes. También se necesita una ficha de envío y limita las operaciones de una determinada prioridad en un dispositivo determinado. Finalmente, se define una latencia de lectura de destino y el planificador se sintoniza para alcanzar este objetivo de latencia. La implementación del algoritmo es relativamente simple y se considera eficiente para dispositivos rápidos.\n\n"
    },
    {
      "title": "Planificadores de E/S del kernel",
      "level": 4,
      "content": "Si bien algunos de los primeros algoritmos ahora se han retirado, el kernel oficial de Linux soporta una serie de planificadores de E/S que se pueden dividir en dos categorías:\n\n- Los planificadores de colas múltiples están disponibles por defecto con el kernel. El Multi-Queue Block I/O Queueing Mechanism (blk-mq) asigna consultas de E/S a múltiples colas, las tareas se distribuyen entre subprocesos y, por lo tanto, entre núcleos de CPU. Dentro de este grupo están disponibles los siguientes planificadores: None,donde no se aplica ningún algoritmo de cola. mq-deadline, la adaptación del planificador de fechas límite (ver más abajo) a multihilo. Kyber BFQ\n\n- None,donde no se aplica ningún algoritmo de cola.\n- mq-deadline, la adaptación del planificador de fechas límite (ver más abajo) a multihilo.\n- Kyber\n- BFQ\n\n- Los planificadores de cola única son planificadores heredados: NOOP es el planificador más simple, inserta todas las solicitudes de E/S entrantes en una cola FIFO simple e implementa la combinación de solicitudes. En este algoritmo, no hay ningún reordenamiento de la solicitud en función del número de sector. Por lo tanto, se puede utilizar si la solicitud se gestiona en otra capa, a nivel de dispositivo, por ejemplo, o si no importa, para SSD, por ejemplo. Deadline CFQ\n\n- NOOP es el planificador más simple, inserta todas las solicitudes de E/S entrantes en una cola FIFO simple e implementa la combinación de solicitudes. En este algoritmo, no hay ningún reordenamiento de la solicitud en función del número de sector. Por lo tanto, se puede utilizar si la solicitud se gestiona en otra capa, a nivel de dispositivo, por ejemplo, o si no importa, para SSD, por ejemplo.\n- Deadline\n- CFQ\n\n"
    },
    {
      "title": "Cambiar el planificador de E/S",
      "level": 4,
      "content": "Para enumerar los planificadores disponibles para un dispositivo y el planificador activo (entre paréntesis):\n\n```\n$ cat /sys/block/sda/queue/scheduler\n```\n\n```\nmq-deadline kyber [bfq] none\n```\n\nPara enumerar los planificadores disponibles para todos los dispositivos:\n\n```\n$ grep \"\" /sys/block/*/queue/scheduler\n```\n\n```\n/sys/block/pktcdvd0/queue/scheduler:none\n/sys/block/sda/queue/scheduler:mq-deadline kyber [bfq] none\n/sys/block/sr0/queue/scheduler:[mq-deadline] kyber bfq none\n```\n\nPara cambiar el programador de E/S activo a bfq para el dispositivo sda, utilice:\n\n```\n# echo bfq > /sys/block/sda/queue/scheduler\n```\n\nEl proceso para cambiar el planificador de E/S, dependiendo de si el disco es mecánico o no, puede automatizarse y persistir durante los reinicios. Por ejemplo, la regla udev a continuación establece el planificador en none para NVMe, mq-deadline para SSD/eMMC y bfq para unidades mecánicas:\n\n```\n/etc/udev/rules.d/60-ioschedulers.rules\n```\n\n```\n# establecer planificador para NVMe\nACTION==\"add|change\", KERNEL==\"nvme[0-9]n[0-9]\", ATTR{queue/scheduler}=\"none\"\n# establecer planificador para SSD y eMMC\nACTION==\"add|change\", KERNEL==\"sd[a-z]|mmcblk[0-9]*\", ATTR{queue/rotational}==\"0\", ATTR{queue/scheduler}=\"mq-deadline\"\n# establecer planificador para discos mecánicos\nACTION==\"add|change\", KERNEL==\"sd[a-z]\", ATTR{queue/rotational}==\"1\", ATTR{queue/scheduler}=\"bfq\"\n```\n\nReinicie o fuerce la carga de las nuevas reglas.\n\n"
    },
    {
      "title": "Ajustar el planificador de E/S",
      "level": 4,
      "content": "Cada uno de los planificadores de E/S del kernel tiene sus propios parámetros para optimizar, como el tiempo de latencia, el tiempo de expiración o los parámetros FIFO. Son útiles para ajustar el algoritmo a una combinación particular de dispositivo y carga de trabajo. Por lo general, esto es para lograr un mayor rendimiento o una menor latencia para una utilización determinada. Los parámetros para optimizar y su descripción se pueden encontrar en la documentación del kernel.\n\nPara enumerar los parámetros para optimizar disponibles para un dispositivo, en el siguiente ejemplo sdb que usa deadline, utilice:\n\n```\n$ ls /sys/block/sdb/queue/iosched\n```\n\n```\nfifo_batch  front_merges  read_expire  write_expire  writes_starved\n```\n\nPara mejorar el rendimiento de deadline a costa de la latencia, se puede aumentar fifo_batch con la orden:\n\n```\n# echo 32 > /sys/block/sdb/queue/iosched/fifo_batch\n```\n\n"
    },
    {
      "title": "Configuración de administración de energía",
      "level": 3,
      "content": "Cuando se trata de discos mecánicos tradicionales (HDD), es posible que desee reducir o desactivar las funciones de ahorro de energía por completo.\n\n"
    },
    {
      "title": "Reducir las lecturas/escrituras de disco",
      "level": 3,
      "content": "Evitar el acceso innecesario a unidades de almacenamiento lentas es bueno para el rendimiento y también aumenta la vida útil de los dispositivos, aunque en el hardware moderno la diferencia en la esperanza de vida suele ser insignificante.\n\nNote: **10GB de datos escritos por día** \n\n"
    },
    {
      "title": "Mostrar escrituras de disco",
      "level": 4,
      "content": "El paquete iotop puede ordenar por escrituras de disco y mostrar cuánto y con qué frecuencia los programas escriben en el disco. Véase iotop(8) para obtener más detalles.\n\n"
    },
    {
      "title": "Reubicar archivos en tmpfs",
      "level": 4,
      "content": "Reubique archivos, como el perfil de su navegador, a un sistema de archivos tmpfs, para obtener mejoras en la respuesta de la aplicación, ya que todos los archivos ahora se almacenan en la RAM:\n\n- Consulte Profile-sync-daemon para sincronizar los perfiles del navegador. Algunos navegadores pueden necesitar una atención especial, véase por ejemplo Firefox/Profile on RAM.\n- Consulte Anything-sync-daemon para sincronizar cualquier carpeta específica.\n- Consulte Makepkg (Español)#Mejorar tiempos de compilación para mejorar los tiempos de compilación mediante la creación de paquetes en tmpfs.\n\n"
    },
    {
      "title": "Sistemas de archivos",
      "level": 4,
      "content": "Véase la página del sistema de archivos correspondiente en caso de que haya instrucciones para mejorar el rendimiento, por ejemplo Ext4#Improving performance y XFS#Performance.\n\n"
    },
    {
      "title": "Espacio de intercambio",
      "level": 4,
      "content": "Véase Swap (Español)#Rendimiento.\n\n"
    },
    {
      "title": "Intervalo de escritura diferida y tamaño del búfer",
      "level": 4,
      "content": "Véase Sysctl#Virtual memory para más detalles.\n\n"
    },
    {
      "title": "Planificar la E/S de almacenamiento con ionice",
      "level": 3,
      "content": "Muchas tareas, como las copias de seguridad, no dependen de un corto retraso de E/S de almacenamiento o de un alto ancho de banda de E/S de almacenamiento para cumplir con su tarea; se pueden clasificar como tareas en segundo plano. Por otro lado, las E/S rápidas son necesarias para una buena capacidad de respuesta de la interfaz de usuario en el escritorio. Por lo tanto, es beneficioso reducir la cantidad de ancho de banda de almacenamiento disponible para tareas en segundo plano, mientras que otras tareas necesitan E/S de almacenamiento. Esto se puede lograr haciendo uso del planificador de E/S de Linux CFQ, que permite establecer diferentes prioridades para los procesos.\n\nLa prioridad de E/S de un proceso en segundo plano se puede reducir al nivel \"Inactivo\" (Idle) iniciándola con:\n\n```\n# ionice -c 3 orden\n```\n\nVéase ionice(1) y [2] para más información.\n\n"
    },
    {
      "title": "Overclocking",
      "level": 3,
      "content": "Overclocking mejora el rendimiento computacional de la CPU aumentando su frecuencia de reloj pico. La capacidad de overclock depende de la combinación del modelo de CPU y el modelo de placa base. Se realiza con mayor frecuencia a través de BIOS. El overclocking también tiene desventajas y riesgos. Ni se recomienda ni se desaconseja aquí.\n\nMuchos chips Intel no informarán correctamente su frecuencia de reloj a acpi_cpufreq y a la mayoría de las demás utilidades. Esto resultará en mensajes excesivos en dmesg, que se pueden evitar descargando y poniendo en lista negra el módulo del kernel acpi_cpufreq. Para leer su velocidad de reloj utilice i7z del paquete i7z. Para comprobar el funcionamiento correcto de una CPU overclockeada, se recomienda realizar prueba de estrés.\n\n"
    },
    {
      "title": "Escala de frecuencia",
      "level": 3,
      "content": "Véase CPU frequency scaling (Español).\n\n"
    },
    {
      "title": "Planificadores de CPU alternativos",
      "level": 3,
      "content": "El planificador de CPU predeterminado en el kernel principal de Linux es CFS. Hay planificadores alternativos disponibles.\n\nUn planificador alternativo centrado en la interactividad y la capacidad de respuesta del escritorio es MuQSS, desarrollado por Con Kolivas[enlace roto 2024-10-12]. MuQSS está incluido en el paquete del kernel linux-zen. También está disponible como un parche independiente o como parte del conjunto de parches -ck más amplio. Véase Linux-ck y Linux-pf para obtener más información sobre el conjunto de parches.\n\n"
    },
    {
      "title": "Kernel en tiempo real",
      "level": 3,
      "content": "Algunas aplicaciones, como ejecutar una tarjeta sintonizadora de TV con resolución Full HD (1080p), pueden beneficiarse del uso de un kernel en tiempo real.\n\n"
    },
    {
      "title": "Ajuste de prioridades de procesos",
      "level": 3,
      "content": "Véase nice(1) y renice(1).\n\n"
    },
    {
      "title": "Ananicy",
      "level": 4,
      "content": "Ananicy CPP es un demonio, disponible en el paquete ananicy-cpp, para ajustar automáticamente los niveles nice de ejecutables. El nivel nice representa la prioridad del ejecutable al asignar recursos de CPU.\n\n"
    },
    {
      "title": "cgroups",
      "level": 4,
      "content": "Véase cgroups.\n\n"
    },
    {
      "title": "Cpulimit",
      "level": 4,
      "content": "Cpulimit es un programa para limitar el porcentaje de uso de la CPU de un proceso específico. Después de instalar cpulimitAUR, puede limitar el uso de CPU del PID de un proceso mediante una escala de 0 a 100 veces la cantidad de núcleos de CPU que tiene la computadora. Por ejemplo, con ocho núcleos de CPU, el rango de porcentaje será de 0 a 800. Utilización:\n\n```\n$ cpulimit -l 50 -p 5081\n```\n\n"
    },
    {
      "title": "irqbalance",
      "level": 3,
      "content": "El propósito de irqbalance es distribuir interrupciones de hardware entre procesadores en un sistema multiprocesador para incrementar el rendimiento. Puede ser controlado por el irqbalance.service proporcionado.\n\n"
    },
    {
      "title": "Desactivar las mitigaciones de vulnerabilidades de la CPU",
      "level": 3,
      "content": "Desactivar las mitigaciones de vulnerabilidades de la CPU mejora el rendimiento (a veces hasta un 50%). Utilice el parámetro del kernel indicado a continuación para desactivarlos todos:\n\n```\nmitigations=off\n```\n\nLas explicaciones de todos los conmutadores que alterna se dan en kernel.org. Puede utilizar spectre-meltdown-checkerAUR para comprobar la vulnerabilidad.\n\n"
    },
    {
      "title": "Configuración de Xorg",
      "level": 3,
      "content": "El rendimiento de los gráficos puede depender de la configuración en xorg.conf(5); véase los artículos NVIDIA, AMDGPU e Intel. Una configuración incorrecta puede hacer que Xorg deje de funcionar, por lo que se recomienda precaución.\n\n"
    },
    {
      "title": "Configuración de Mesa",
      "level": 3,
      "content": "El rendimiento de los controladores Mesa se puede configurar a través de drirc. Están disponibles las siguientes herramientas de configuración del GUI:\n\n- adriconf (Advanced DRI Configurator) — Herramienta GUI para configurar los controladores Mesa configurando opciones y escribiéndolas en el archivo drirc estándar.\n\n"
    },
    {
      "title": "Overclocking",
      "level": 3,
      "content": "Al igual que con las CPU, el overclocking puede mejorar directamente el rendimiento, pero generalmente se recomienda no hacerlo. Hay varios paquetes en AUR, como rovclockAUR (tarjetas ATI antiguas), rocm-smi-lib (tarjetas AMD recientes), nvclockAUR (tarjetas NVIDIA antiguas - hasta Geforce 9) y nvidia-utils (tarjetas NVIDIA recientes).\n\nVéase AMDGPU#Overclocking o NVIDIA/Tips and tricks#Enabling overclocking in nvidia-settings.\n\n"
    },
    {
      "title": "Activar BAR redimensionable del PCI",
      "level": 3,
      "content": "La especificación PCI permite utilizar Registros de direcciones base (BAR) más grandes para exponer la memoria de los dispositivos PCI al controlador PCI. Esto puede resultar en un aumento del rendimiento de las tarjetas de vídeo. Tener acceso a la vRAM completa mejora el rendimiento, pero también permite optimizaciones en el controlador de gráficos. La combinación de BAR redimensionable, codificación por encima de 4G y estas optimizaciones de controladores es lo que AMD llama AMD Smart Access Memory[enlace roto 2024-07-30], actualmente disponible en el chipset de placas base AMD Serie 500. Es posible que esta configuración no esté disponible en todas las placas base y se sabe que a veces causa problemas de arranque en ciertas placas.\n\nSi BAR tiene un tamaño de 256M, la función no está activada o no es compatible:\n\n```\n# dmesg | grep BAR=\n```\n\n```\n[drm] Detected VRAM RAM=8176M, BAR=256M\n```\n\nPara activarlo, active la configuración llamada \"Decodificación por encima de 4G\" o \">4GB MMIO\" en la configuración de su placa base. Compruebe que BAR sea ahora más grande:\n\n```\n# dmesg | grep BAR=\n```\n\n```\n[drm] Detected VRAM RAM=8176M, BAR=8192M\n```\n\n"
    },
    {
      "title": "Frecuencia y tiempos de reloj",
      "level": 3,
      "content": "La RAM puede funcionar en diferentes frecuencias de reloj y tiempos, que se pueden configurar en BIOS. El rendimiento de la memoria depende de ambos valores. La selección del valor predeterminado más alto presentado por BIOS generalmente mejora el rendimiento con respecto a la configuración predeterminada. Tenga en cuenta que aumentar la frecuencia a valores no admitidos tanto por la placa base como por el proveedor de RAM es overclocking, y se aplican riesgos y desventajas similares, véase #Overclocking.\n\n"
    },
    {
      "title": "Raíz en una superposición de RAM",
      "level": 3,
      "content": "Si se ejecuta en un medio de escritura lento (USB, discos duros mecánicos) y los requisitos de almacenamiento son bajos, la raíz puede ejecutarse en una superposición de RAM en la parte superior de la raíz de solo lectura (en el disco). Esto puede mejorar enormemente el rendimiento a costa de un espacio de escritura limitado para la raíz. Véase liverootAUR.\n\n"
    },
    {
      "title": "Zram o zswap",
      "level": 3,
      "content": "El módulo del kernel zram (anteriormente llamado compcache) proporciona un dispositivo de bloque comprimido en RAM. Si lo utiliza como dispositivo de intercambio, la RAM puede contener mucha más información pero utiliza más CPU. Aún así, es mucho más rápido que cambiar a un disco duro. Si un sistema a menudo recurre al intercambio (swap), esto podría mejorar la capacidad de respuesta. El uso de zram también es una buena manera de reducir los ciclos de lectura/escritura del disco debido al intercambio en SSD.\n\nSe pueden lograr beneficios similares (a costos similares) utilizando zswap en lugar de zram. Los dos son generalmente similares en intención, aunque no en funcionamiento: zswap opera como una memoria caché de RAM comprimida y no requiere (ni permite) una configuración extensa del espacio de usuario.\n\nPor ejemplo, para configurar un dispositivo zram comprimido lz4 con capacidad de 32GiB y una prioridad superior a la normal (solo para la sesión actual):\n\n```\n# modprobe zram\n# echo lz4 > /sys/block/zram0/comp_algorithm\n# echo 32G > /sys/block/zram0/disksize\n# mkswap --label zram0 /dev/zram0\n# swapon --priority 100 /dev/zram0\n```\n\nPara desactivarlo nuevamente, reinicie o ejecute:\n\n```\n# swapoff /dev/zram0\n# rmmod zram\n```\n\nSe proporciona una explicación detallada de todos los pasos, opciones y problemas potenciales en la documentación oficial del módulo zram.\n\nEl paquete systemd-swapAUR proporciona una unidad systemd-swap.service para inicializar automáticamente los dispositivos zram. Es posible configurarlo en /etc/systemd/swap.conf.\n\nEl paquete zramswapAUR proporciona una secuencia de órdenes automatizada para configurar un espacio de intercambio con una prioridad más alta y un tamaño predeterminado del 20% del tamaño de la RAM de su sistema. Para hacer esto automáticamente en cada inicio active zramswap.service.\n\nAlternativamente, el paquete zramdAUR[enlace roto: package not found] permite configurar zram automáticamente utilizando compresión zstd por defecto, esta configuración puede ser modificada en el archivo /etc/default/zramd. Para que zramd inicie automáticamente, active la unidad zramd.service.\n\n"
    },
    {
      "title": "Espacio de intercambio en zRAM mediante una regla udev",
      "level": 4,
      "content": "El siguiente ejemplo describe cómo configurar el espacio de intercambio en zRAM automáticamente durante el arranque con una sola regla udev. No debería ser necesario ningún paquete adicional para que esto funcione.\n\nPrimero, active el módulo:\n\n```\n/etc/modules-load.d/zram.conf\n```\n\n```\nzram\n```\n\nConfigure la cantidad de nodos /dev/zram que necesita.\n\n```\n/etc/modprobe.d/zram.conf\n```\n\n```\noptions zram num_devices=2\n```\n\nCree la regla udev como se muestra en el ejemplo.\n\n```\n/etc/udev/rules.d/99-zram.rules\n```\n\n```\nKERNEL==\"zram0\", ATTR{disksize}=\"512M\" RUN=\"/usr/bin/mkswap /dev/zram0\", TAG+=\"systemd\"\nKERNEL==\"zram1\", ATTR{disksize}=\"512M\" RUN=\"/usr/bin/mkswap /dev/zram1\", TAG+=\"systemd\"\n```\n\nAñada /dev/zram a su fstab.\n\n```\n/etc/fstab\n```\n\n```\n/dev/zram0 none swap defaults 0 0\n/dev/zram1 none swap defaults 0 0\n```\n\n"
    },
    {
      "title": "Utilizar la RAM de la tarjeta gráfica",
      "level": 3,
      "content": "En el improbable caso de que tenga muy poca RAM y un excedente de RAM de vídeo, puede utilizar esta última como espacio de intercambio. Véase Espacio de intercambio en RAM de vídeo.\n\n"
    },
    {
      "title": "Mejorar la capacidad de respuesta del sistema en condiciones de poca memoria",
      "level": 3,
      "content": "En el sistema GNU/Linux tradicional, especialmente para estaciones de trabajo gráficas, cuando la memoria asignada está sobrecomprometida (overcommitted), la capacidad de respuesta general del sistema puede degradarse a un estado casi inutilizable antes de activar OOM-killer del kernel o de que se libere una cantidad suficiente de memoria (que es poco probable que suceda rápidamente cuando el sistema no responde, ya que difícilmente puede cerrar las aplicaciones que consumen mucha memoria y que pueden continuar asignando más memoria). El comportamiento también depende de configuraciones y condiciones específicas, volver a un estado de respuesta normal puede llevar desde unos segundos hasta más de media hora, lo que podría ser difícil de esperar en un escenario serio, como puede ser durante una presentación en una conferencia.\n\nSi bien el comportamiento del kernel y las cosas del espacio de usuario en condiciones de poca memoria pueden mejorar en el futuro, como se explica en el kernel[3] y en la lista de correo de fedora[4], los usuarios pueden utilizar opciones más factibles y efectivas que un reinicio duro el sistema o ajustar los parámetros sysctl vm.overcommit_*:\n\n- Activar manualmente el OOM-killer del kernel con tacla mágica PetSis (ubicada en ImprPant), es decir, Alt+PetSis+f .\n- Utilizar un demonio OOM en el espacio de usuario para abordarlos de forma automática (o interactiva).\n\nA veces, un usuario puede preferir el demonio OOM a PetSis porque con OOM-killer del kernel no puede priorizar el proceso para (o no) terminar. Para enumerar algunos demonios OOM:\n\n- earlyoom — Implementación simple OOM-Killer en el espacio de usuario escrita en C. Fedora va a tener esto en su instalación de estación de trabajo predeterminada [5].\n\n- oomd — Implementación OOM-killer basada en PSI, requiere la versión del kernel de Linux 4.20+. La configuración está en JSON y es bastante compleja. Confirmado su funcionamiento en el entorno de producción de Facebook.\n\n- nohang — Controlador de OOM sofisticado escrito en Python, con soporte PSI opcional, más configurable que Earlyoom.\n\n- low-memory-monitor — Esfuerzo de los desarrolladores de GNOME que tiene como objetivo proporcionar una mejor comunicación a las aplicaciones del espacio de usuario para indicar el estado de memoria baja, además de que podría configurarse para activar el OOM-killer del kernel. Basado en PSI, requiere Linux 5.2+.\n\n"
    },
    {
      "title": "Red",
      "level": 2,
      "content": "- Red del Kernel: véase Sysctl#Improving performance\n- NIC: véase Network configuration (Español)#Establecer la MTU del dispositivo y la longitud de la cola\n- DNS: considere usar un resolvedor caché de DNS, véase Domain name resolution#DNS servers\n- Samba: véase Samba#Improve throughput\n\n"
    },
    {
      "title": "Perros guardianes",
      "level": 2,
      "content": "De acuerdo con Wikipedia:es:Perro guardián (electrónica):\n\nMuchos usuarios necesitan esto debido a la función crítica de su sistema (es decir, servidores) o debido a la falta de botón de reinicio (es decir, dispositivos integrados). Por lo tanto, esta característica es necesaria para un buen funcionamiento en algunas situaciones. Por otro lado, los usuarios normales (es decir, computadoras de escritorio y portátiles) no necesitan esta función y pueden desactivarla.\n\nPara desactivar los temporizadores (tanto de software como de hardware), añada nowatchdog a sus parámetros de arranque.\n\nPara comprobar la nueva configuración, haga lo siguiente:\n\n```\n# cat /proc/sys/kernel/watchdog\n```\n\nO utilice:\n\n```\n# wdctl\n```\n\nDespués de haber desactivado los temporizadores, también puede opcionalmente evitar la carga del módulo responsable del temporizador hardware. Ponga en la lista negra el módulo relacionado, por ejemplo iTCO_wdt.\n\nCualquiera de las dos acciones acelerará el inicio y el apagado, porque se carga un módulo menos. Además, la desactivación de los temporizadores aumenta el rendimiento y reduce el consumo de energía.\n\nVéase [6], [7], [8], y [9] para más información.\n\n"
    },
    {
      "title": "Véase también",
      "level": 2,
      "content": "- Guía de ajuste de rendimiento de Red Hat\n- Medición de rendimiento de Linux mediante vmstat\n\n"
    }
  ]
}