{
  "title": "Daemons List (日本語)",
  "url": "https://wiki.archlinux.org/title/Daemons_List_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- systemd/ユーザー\n- systemd/タイマー\n- systemd/ジャーナル\n- systemd FAQ\n- init\n- デーモン#デーモン一覧\n- udev\n- パフォーマンスの向上/ブートプロセス\n- ユーザーにシャットダウンを許可\n\nプロジェクトウェブページ より:\n\n歴史的には、systemd が \"サービス\" と呼ぶものは デーモン と呼ばれていました:\"バックグラウンド\" プロセスとして (ターミナルやユーザーインターフェイスなしで) 実行され、一般的にイベントの発生を待ち、サービスを提供するプログラムです。ウェブサーバーがページを配信するリクエストを待ったり、ssh サーバーがログインしようとする人を待ったりするのが良い例です。これらは完全な機能を持つアプリケーションですが、デーモンも存在します。デーモンは、ログファイルにメッセージを書き込んだり (例:syslog、metalog)、システムの時刻を正確に保つ (例:ntpd) といったタスクを実行します。詳しくは daemon(7) を参照してください。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 systemctl の基本的な使い方 1.1 ユニットを使う 1.2 電源管理 1.2.1 ソフトリブート\n- 2 ユニットファイル 2.1 依存関係を解決する 2.2 サービスタイプ 2.3 ユニットファイルの編集 2.3.1 ユニットファイルを置換する 2.3.2 ドロップインファイル 2.3.3 初期状態にリバート 2.3.4 サンプル 2.4 サービスのログレベル 2.4.1 サービスの標準出力を抑制する\n- 3 ターゲット 3.1 現在のターゲットを取得 3.2 カスタムターゲットを作る 3.3 SysV ランレベルと systemd ターゲットの対応表 3.4 現在のターゲットを変更する 3.5 起動するデフォルトターゲットを変更 3.6 デフォルトのターゲット順序\n- 4 systemd の構成要素 4.1 systemd.mount - マウント 4.1.1 GPT パーティションの自動マウント 4.1.1.1 /var 4.2 systemd-sysvcompat 4.3 systemd-tmpfiles - 一時ファイル\n- 5 ヒントとテクニック 5.1 ソケットアクティベーション 5.2 GUI 設定ツール 5.3 ネットワークが稼働した後にサービスを実行する 5.4 インストールされたユニットをデフォルトで有効にする 5.5 アプリケーション環境のサンドボックス化 5.6 サービスの失敗を通知する 5.7 Eメールでの通知 5.8 シャットダウン時に自動で外部 HDD の電源を切る\n- 6 トラブルシューティング 6.1 systemd のエラーを調査する 6.2 ブート問題の診断 6.3 特定のサービスの問題を診断 6.4 シャットダウン/再起動にものすごく時間がかかる 6.5 短いプロセスがログを出力しない 6.6 少しづつ起動時間が長くなっている 6.7 起動時に systemd-tmpfiles-setup.service の実行に失敗する 6.8 リモートマシンで緊急モードを無効化 6.9 サービスは存在しているが \"Unit xxx.service not found\" というエラーが表示される\n- 7 参照\n\n- 1.1 ユニットを使う\n- 1.2 電源管理 1.2.1 ソフトリブート\n\n- 1.2.1 ソフトリブート\n\n- 2.1 依存関係を解決する\n- 2.2 サービスタイプ\n- 2.3 ユニットファイルの編集 2.3.1 ユニットファイルを置換する 2.3.2 ドロップインファイル 2.3.3 初期状態にリバート 2.3.4 サンプル\n- 2.4 サービスのログレベル 2.4.1 サービスの標準出力を抑制する\n\n- 2.3.1 ユニットファイルを置換する\n- 2.3.2 ドロップインファイル\n- 2.3.3 初期状態にリバート\n- 2.3.4 サンプル\n\n- 2.4.1 サービスの標準出力を抑制する\n\n- 3.1 現在のターゲットを取得\n- 3.2 カスタムターゲットを作る\n- 3.3 SysV ランレベルと systemd ターゲットの対応表\n- 3.4 現在のターゲットを変更する\n- 3.5 起動するデフォルトターゲットを変更\n- 3.6 デフォルトのターゲット順序\n\n- 4.1 systemd.mount - マウント 4.1.1 GPT パーティションの自動マウント 4.1.1.1 /var\n- 4.2 systemd-sysvcompat\n- 4.3 systemd-tmpfiles - 一時ファイル\n\n- 4.1.1 GPT パーティションの自動マウント 4.1.1.1 /var\n\n- 4.1.1.1 /var\n\n- 5.1 ソケットアクティベーション\n- 5.2 GUI 設定ツール\n- 5.3 ネットワークが稼働した後にサービスを実行する\n- 5.4 インストールされたユニットをデフォルトで有効にする\n- 5.5 アプリケーション環境のサンドボックス化\n- 5.6 サービスの失敗を通知する\n- 5.7 Eメールでの通知\n- 5.8 シャットダウン時に自動で外部 HDD の電源を切る\n\n- 6.1 systemd のエラーを調査する\n- 6.2 ブート問題の診断\n- 6.3 特定のサービスの問題を診断\n- 6.4 シャットダウン/再起動にものすごく時間がかかる\n- 6.5 短いプロセスがログを出力しない\n- 6.6 少しづつ起動時間が長くなっている\n- 6.7 起動時に systemd-tmpfiles-setup.service の実行に失敗する\n- 6.8 リモートマシンで緊急モードを無効化\n- 6.9 サービスは存在しているが \"Unit xxx.service not found\" というエラーが表示される\n\n"
    },
    {
      "title": "systemctl の基本的な使い方",
      "level": 2,
      "content": "systemd を管理したり内部情報を見るために使うメインのコマンドが systemctl です。システムの状態を確かめたりシステムやサービスを管理するために使うのは使い方の一部です。詳しくは systemctl(1) を見て下さい。\n\n- systemctl コマンドに -H user@host を渡すと、リモートの systemd と対話できます。これは SSH を利用してリモートの systemd インスタンスに接続します。\n- Plasma を使っている場合 systemdgenie をインストールすることで systemctl のグラフィカルフロントエンドを使えます。モジュールをインストールすると System の下に設定が追加されます。\n\n"
    },
    {
      "title": "ユニットを使う",
      "level": 3,
      "content": "ユニットには、例えば、サービス (.service) やマウントポイント (.mount)、デバイス (.device)、ソケット (.socket) などがあります。\n\nsystemctl を使うとき、例えば sshd.socket のように、一般的には拡張子 (suffix) を含むユニットファイルの完全な名前を指定する必要があります。しかし、以下のような場合には省略形が存在します:\n\n- 拡張子が指定されない場合、systemctl は .service とみなします。例えば netctl と netctl.service は同じように扱われます。\n- マウントポイントは自動的に対応する .mount ユニットとして扱われます。例えば、/home を指定することは home.mount の指定と同じです。\n- マウントポイントと同じく、デバイスも自動的に対応する .device ユニットとして扱われます。従って、/dev/sda2 の指定は dev-sda2.device と同じです。\n\n詳細は systemd.unit(5) を見てください。\n\n以下の表のコマンドは、systemctl の暗黙のデフォルトである --system から、system unit を操作するものです。代わりに、ユーザー単位 で操作するには、root 権限なしで systemctl --user を使ってください。全てのユーザーに対してユーザーユニットを有効・無効にするには systemd/ユーザー#基本設定 も見て下さい。\n\n- 以下のコマンドのほとんどは複数のユニットを指定することが可能です、詳しくは systemctl(1) を参照。\n- --now スイッチは enable, disable, mask と一緒に使うことで、それぞれ起動、停止、マスクをリブート後ではなく即座に行うことができます。\n- パッケージには様々な目的のユニットが入っています。パッケージをインストールしたら、pacman -Qql package | grep -Fe .service -e .socket でサービスを確認することができます。\n- 利用可能な場合、unit.socket を unit.service の代わりに有効にすることは有益である可能性があります。なぜなら、ソケットは必要に応じてサービスを開始するからです。詳細については#ソケットアクティベーションを参照してください。\n\nTable content:\nアクション | コマンド | 注意\nシステム状態の分析\nシステムステータスを表示する | systemctl status | \n実行中のユニット リスト | systemctl orsystemctl list-units | \n失敗したユニット 一覧 | systemctl --failed | \nインストールされているユニット 一覧1 | systemctl list-unit-files | \nPID のプロセスステータス を表示 | systemctl status pid | cgroup slice, メモリ と 上位プロセス\nユニットの状態を確認する\nユニットに関連付けられている マニュアルページを表示する | systemctl help unit | ユニットでサポートされています\nユニットの ステータス | systemctl status unit | 実行されているかどうかを含む\nユニットが有効かどうかを チェック する | systemctl is-enabled unit | \n本体の起動、再起動、再読み込み\nユニットを即座に スタート する | systemctl start unit as root | \nユニットを即座に ストップ する | systemctl stop unit as root | \nユニットを 再起動 する | systemctl restart unit as root | \nユニットとその設定を 再読み込み する | systemctl reload unit as root | \nsystemd マネージャーの再読み込み 設定2 | systemctl daemon-reload as root | ユニットスキャン\nユニットの有効化\nブート時に自動的に起動するユニットを 有効 にする | systemctl enable unit as root | \n起動時に自動起動するユニットを 有効 にして、すぐに 起動 する | systemctl enable --now unit as root | \nユニットの自動起動を 無効にする | systemctl disable unit as root | \nユニット3を 再有効化 する | systemctl reenable unit as root | つまり、無効化して新たに有効化する\nユニットのマスキング\nユニットを マスク して起動を禁止する4 | systemctl mask unit as root | \nユニットの マスクを解除 する | systemctl unmask unit as root | \n\n1. 利用可能なユニットファイルがあるディレクトリは systemd.unit(5) § UNIT FILE LOAD PATH を参照してください。\n1. これは変更されたユニットに設定の再読み込みを要求しません (アクション Reload を参照して下さい)。\n1. 例えば、最後に有効化してからその [Install] セクションが変更された場合。\n1. 手動でも依存関係としても、マスクは危険です。既存のマスクされたユニットをチェックします。$ systemctl list-unit-files --state=masked\n\n```\n$ systemctl list-unit-files --state=masked\n```\n\n"
    },
    {
      "title": "電源管理",
      "level": 3,
      "content": "非特権ユーザーでの電源管理には、polkit が必要です。ローカルの systemd-logind ユーザーセッションで、他のセッションがアクティブでない場合、以下のコマンドは root 権限がなくても動作します。そうでない場合(例えば、他のユーザーが tty にログインしているなど)、systemd は自動的に root パスワードを要求します。\n\nTable content:\nアクション | コマンド\nシステムをシャットダウンして再起動する | systemctl reboot\nシステムをシャットダウンして電源を切る | systemctl poweroff\nシステムを一時停止する | systemctl suspend\nシステムをハイバネーションにする | systemctl hibernate\nシステムをハイブリッドスリープ状態にする (または suspend-to-both) にする | systemctl hybrid-sleep\nまずシステムをサスペンドし、設定された時間の経過後にウェイクアップしてシステムを休止状態にする | systemctl suspend-then-hibernate\nユーザースペースのみの再起動を実行するには、#ソフトリブート を使用してください。 | systemctl soft-reboot\n\n"
    },
    {
      "title": "ソフトリブート",
      "level": 4,
      "content": "ソフトリブートは、カーネルを介さないユーザ空間のみの特別なリブート操作です。systemd-soft-reboot.service(8) によって実装されており、systemctl Soft-reboot によって呼び出すことができます。kexec と同様、ファームウェアの再初期化をスキップしますが、さらにシステムはカーネルの初期化と initramfs を通過せず、ロックされていない dm-crypt デバイスは接続されたままになります。\n\n/run/nextroot/ に有効なルートファイルシステム階層が含まれている場合 (例: 別のディストリビューションまたは別のスナップショットのルートマウント)、ソフトリブート によりシステムルートがそこに切り替わり、カーネルによって管理される状態 (ネットワーク設定 など) を失うことなく、別のインストールに切り替えることが出来ます。\n\n"
    },
    {
      "title": "ユニットファイル",
      "level": 2,
      "content": "systemd のユニットファイル (systemd.unit(5)) の構文は XDG の Desktop Entry Specification である .desktop ファイル から影響を受けています。そして .desktop は Microsoft Windows の .ini ファイル からインスパイアされています。ユニットファイルは複数の場所に配置されます (配置場所のリストを確認するには systemctl show --property=UnitPath を実行してください)が、主な場所は (優先度が低い方から説明すると):\n\n- /usr/lib/systemd/system/: インストールしたパッケージに含まれているユニット\n- /etc/systemd/system/: システムの管理者がインストールしたユニット\n\n- ユーザーモードで systemd を動作させたときにロードされるパスは完全に異なります。\n- systemd ユニットの名前に使うことができるのは ASCII 英数字とアンダーバー、ピリオドだけです。他の文字列は C スタイルの \"\\x2d\" エスケープに置き換えるか、事前に定義された方法 ('@' や '-') を使う必要があります。詳しくは systemd.unit(5) や systemd-escape(1) を見て下さい。\n\n例としてパッケージによりインストールされたユニットや systemd.service(5) § EXAMPLES を参照してください。\n\n"
    },
    {
      "title": "依存関係を解決する",
      "level": 3,
      "content": "systemd ではユニットファイルを適切に書くことで依存関係を解決します。一番典型的なケースは、ユニット A が走る前に、ユニット A がユニット B を必要としている場合です。この場合、A の [Unit] セクションに Requires=B と After=B を加えます。依存が必然ではない場合、代わりに Wants=B と After=B を加えます。Wants= と Requires= は After= を含まないことに注意してください、もし After= を明記しなかったときは、2つのユニットは並行して実行されます。\n\n基本的に、依存関係はターゲットではなくサービスに記述します。例えば、network.target はネットワークインターフェースを設定する全てのサービスによって使われるので、カスタムユニットを起動させる順番は network.target が起動し終わってからにする必要があります。\n\n"
    },
    {
      "title": "サービスタイプ",
      "level": 3,
      "content": "カスタムサービスファイルを書くときにどのスタートアップタイプを使うべきか考える必要があります。タイプは [Service] セクションの Type= パラメータで設定します。\n\n- Type=simple (デフォルト): systemd はプロセスを起動した時点でサービスが立ち上がったとみなします。プロセスをフォークすることはできません。ソケットアクティベーション以外で他のサービスが必要な場合に、このタイプを使ってはいけません。\n- Type=forking: 起動したプロセスが一旦フォークし、親プロセス側が終了したときに、 systemd はサービスが立ち上がったとみなします。このタイプでなくてもかまわないとき以外は、古典的なデーモンにはこのタイプを使って下さい。また PIDFile= を指定することで systemd はメインプロセスの情報を追い続けます。\n- Type=oneshot: シングルジョブを行い終了するスクリプト用のタイプです。また RemainAfterExit=yes を設定することで systemd はプロセスが終了した後もサービスがアクティブだとみなします。\n- Type=notify: Type=simple と同じですが、利用可能になったときにデーモンが systemd に信号を送るように条件がつけられます。この通知のリファレンス実装は libsystemd-daemon.so によって提供されています。\n- Type=dbus: 指定の BusName が DBus のシステムバスに乗ったときに使うことができるサービス。\n- Type=idle: ただし、サービスバイナリの実行は全てのジョブが処理されるまで待たされます。それ以外の挙動は Type=simple と非常に似ています。\n\nType の値のより詳しい説明は systemd.service(5) § OPTIONS を見て下さい。\n\n"
    },
    {
      "title": "ユニットファイルの編集",
      "level": 3,
      "content": "pacman との競合を避けるために、パッケージに含まれるユニットファイルは直接編集しないでください。パッケージに入っているユニットファイルを元のファイルに触れずに編集する安全な方法は2つあります: 新しいユニットファイルで完全に置き換えるか、ドロップインファイルを作成して既存のユニットファイルに上書きして適用させるかです。どちらの方法でも、変更を加えた後はユニットをリロードする必要があります。systemctl edit でユニットを編集するか (自動でユニットがリロードされます) または次のコマンドで全てのユニットをリロードしてください:\n\n```\n# systemctl daemon-reload\n```\n\n- systemd-delta を使うことでどのファイルが上書きされ、どこが変更されたのか調べることができます。\n- ユニットファイルや関連するドロップインファイルの中身を見るには systemctl cat unit を使います。\n\n"
    },
    {
      "title": "ユニットファイルを置換する",
      "level": 4,
      "content": "ユニットファイル /usr/lib/systemd/system/unit を置き換えたいときは、/etc/systemd/system/unit ファイルを作成してユニットを 再有効化 することでシンボリックリンクをアップデートします。\n\nもしくは、次を実行:\n\n```\n# systemctl edit --full unit\n```\n\nこのコマンドはテキストエディタで /etc/systemd/system/unit を開いて (ファイルが存在しない場合はインストールされているユニットがコピーされます)、編集を終えた時に自動的にユニットをリロードします。\n\n"
    },
    {
      "title": "ドロップインファイル",
      "level": 4,
      "content": "ユニットファイル /usr/lib/systemd/system/unit のドロップインファイルを作成するには、/etc/systemd/system/unit.d/ という名のディレクトリ (例: /etc/systemd/system/httpd.service.d/) を作成してその中に *.conf を配置します。このファイルを使ってオプションを上書きしたり追加してください。systemd が *.conf ファイルをパースして元のユニットファイルの一番上に設定を適用します。\n\nドロップインファイルを作成する一番簡単な方法は次のコマンドを実行することです:\n\n```\n# systemctl edit unit\n```\n\nテキストエディタで /etc/systemd/system/unit.d/override.conf ファイルが開かれ (必要であればファイルが作成されます)、編集を終えた時に自動でユニットがリロードされます。\n\n"
    },
    {
      "title": "初期状態にリバート",
      "level": 4,
      "content": "systemctl edit を使って変更したユニットを元に戻したい場合、以下のコマンドを実行:\n\n```\n# systemctl revert unit\n```\n\n"
    },
    {
      "title": "サンプル",
      "level": 4,
      "content": "例えば、ユニットに依存するデーモンを追加したい場合、以下のファイルを作成することができます:\n\n```\n/etc/systemd/system/unit.d/customdependency.conf\n```\n\n```\n[Unit]\nRequires=new dependency\nAfter=new dependency\n```\n\noneshot タイプでないユニットの ExecStart ディレクティブを置き換えるには、以下のファイルを作成します:\n\n```\n/etc/systemd/system/unit.d/customexec.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=new command\n```\n\nサービスが自動的に再起動されるようにするには:\n\n```\n/etc/systemd/system/unit.d/restart.conf\n```\n\n```\n[Service]\nRestart=always\nRestartSec=30\n```\n\n"
    },
    {
      "title": "サービスのログレベル",
      "level": 3,
      "content": "journald や syslog に直接ログを送信するサービスの場合、LogLevelMax= パラメータに 0 から 6 までの数値を設定することで、ログの詳細度を制御できます。この設定は、前述の方法を使用して [Service] セクションに記述します。例えば:\n\n```\n/etc/systemd/system/unit.d/override.conf\n```\n\n```\n[Service]\nLogLevelMax=3\n```\n\n標準のログレベルは、 journal でフィルタリングするために使用されるものと同じです。低い数値を設定すると、それより高く、重要度の低いログメッセージがジャーナルから除外されます。\n\n"
    },
    {
      "title": "サービスの標準出力を抑制する",
      "level": 4,
      "content": "サービスが標準出力 (stdout) や標準エラー出力 (stderr) を出力している場合、デフォルトではこれらもジャーナルに記録されます。この動作を抑制するには、[Service] セクションに StandardOutput=null や StandardError=null を設定します。null 以外の値を使用して、この動作をさらに調整することもできます。詳細は systemd.exec(5) § LOGGING_AND_STANDARD_INPUT/OUTPUT を参照してください。\n\n"
    },
    {
      "title": "ターゲット",
      "level": 2,
      "content": "Systemd では ランレベル に似たものとしてターゲットを使っています。ただしその挙動には少し違いがあります。それぞれのターゲットはナンバリングされる代わりに名前がつけられ、ある特定の目的のために作られ、複数のターゲットを同時に有効にできるようになっています。ターゲットによっては、他のターゲットのサービスを全て引継ぎ、そこにサービスを追加するよう実装されています。一般的な SystemVinit ランレベルに擬態する systemd ターゲットもあり、親しみのある telinit RUNLEVEL コマンドを使って使用するターゲットを切り替えることが可能です。\n\n"
    },
    {
      "title": "現在のターゲットを取得",
      "level": 3,
      "content": "systemd では runlevel の代わりに次のコマンドが使われます:\n\n```\n$ systemctl list-units --type=target\n```\n\n"
    },
    {
      "title": "カスタムターゲットを作る",
      "level": 3,
      "content": "sysvinit ではランレベルごとに特定の目的が設定されています; 0, 1, 3, 5, 6 のランレベルには特定の sytemd ターゲットと一対一の対応関係が存在します。残念ながら、ユーザー定義のランレベル (2 や 4 など) で同じことをする良い方法はありません。もしあなたがそうしたいならば、既に存在しているランレベルをベースに新しい systemd ターゲットを /etc/systemd/system/your target として作り (/usr/lib/systemd/system/graphical.target がサンプルになるかもしれません)、/etc/systemd/system/your target.wants ディレクトリを作って、有効にしたいサービスに /usr/lib/systemd/system/ からシンボリックリンクを貼ることが示唆されています。\n\n"
    },
    {
      "title": "SysV ランレベルと systemd ターゲットの対応表",
      "level": 3,
      "content": "Table content:\nSysV ランレベル | systemd ターゲット | 説明\n0 | runlevel0.target, poweroff.target | システムを停止。\n1, s, single | runlevel1.target, rescue.target | シングルユーザーモード。\n2, 4 | runlevel2.target, runlevel4.target, multi-user.target | ユーザー定義・サイト指定ランレベル。デフォルトでは、3 と同一。\n3 | runlevel3.target, multi-user.target | マルチユーザー、非グラフィカル。一般的にマルチコンソールやネットワークを介してログインするのに使われます。\n5 | runlevel5.target, graphical.target | マルチユーザー、グラフィカル。通常、ランレベル 3 の全てのサービスにグラフィカルログインを付加。\n6 | runlevel6.target, reboot.target | 再起動\nemergency | emergency.target | 緊急シェル\n\n"
    },
    {
      "title": "現在のターゲットを変更する",
      "level": 3,
      "content": "systemd ではターゲットは ターゲットユニット を通して扱うことができます。ターゲットを変えるには次のようにします:\n\n```\n# systemctl isolate graphical.target\n```\n\nこれは現在のターゲットを変えるだけで、次の起動時には影響がありません。SysVinit での、telinit 3 や telinit 5 のようなコマンドと同じです。\n\n"
    },
    {
      "title": "起動するデフォルトターゲットを変更",
      "level": 3,
      "content": "標準のターゲットは default.target で、これは graphical.target へのシンボリックリンクです。これは、古いランレベル5にほぼ対応します。\n\nsystemctl を使用して現在のターゲットを確認するには、次の手順に従います。\n\n```\n$ systemctl get-default\n```\n\nブート先のデフォルトターゲットを変更するには、default.target シンボリックリンクを変更します。systemctl の場合\n\n```\n# systemctl set-default multi-user.target\n```\n\n```\nRemoved /etc/systemd/system/default.target.\nCreated symlink /etc/systemd/system/default.target -> /usr/lib/systemd/system/multi-user.target.\n```\n\nまたは、次の カーネルパラメータ のいずれかをブートローダに追加します。\n\n- systemd.unit=multi-user.target (これは、古いランレベル3にほぼ対応しています)\n- systemd.unit=rescue.target (これは、古いランレベル1にほぼ対応しています)\n\n"
    },
    {
      "title": "デフォルトのターゲット順序",
      "level": 3,
      "content": "systemd は、次の順序に従って default.target を選択します。\n\n1. 上記のカーネルパラメータ\n1. /etc/systemd/system/default.target への Symlink\n1. /usr/lib/systemd/system/default.target への Symlink\n\n"
    },
    {
      "title": "systemd の構成要素",
      "level": 2,
      "content": "systemd のコンポーネントをいくつか(網羅的ではない)紹介します。\n\n- kernel-install — カーネルと対応する initramfs イメージを自動的にブートパーティションへ移動するためのツール。\n- systemd-analyze(1) — 起動時間の分析、統計情報の取得、ユニットファイルの検証などを行うツール。高度なデバッグ向けの特別な機能にもアクセス可能。\n- systemd-boot — シンプルな UEFI ブートマネージャー\n- systemd-creds — systemd ユニットで使用する認証情報を安全に保存および取得するためのツール。\n- systemd-cryptenroll — PKCS#11、FIDO2、TPM2 トークン/デバイスを LUKS2 暗号化ボリュームに登録するツール。\n- systemd-firstboot — 初回起動前の基本的なシステム設定を行うツール。\n- systemd-homed — ポータブルなユーザーアカウント管理を提供。\n- systemd-logind(8) — セッション管理を行うデーモン。\n- systemd-networkd — ネットワーク設定管理のためのデーモン。\n- systemd-nspawn — 軽量な名前空間コンテナを提供するツール。\n- systemd-repart — パーティションテーブルの作成、パーティションの追加や拡張を行うツール。\n- systemd-resolved — ネットワークの名前解決を管理するデーモン。\n- systemd-run(1) / run0(1) — 一時的またはインタラクティブに権限を昇格または変更するためのツール。\n- systemd-stub(7) — ユニファイドカーネルイメージを作成するための UEFI ブートスタブ。\n- systemd-sysusers(8) — システムユーザーやグループを作成し、パッケージインストール時やブート時にユーザーをグループへ追加するツール。\n- systemd-timesyncd — ネットワーク経由でシステム時刻を同期するデーモン。\n- systemd/ジャーナル — システムのログ管理。\n- systemd/タイマー — .service ファイルやイベントを制御する単調またはリアルタイムのタイマーを提供。cron の合理的な代替手段。\n\n"
    },
    {
      "title": "systemd.mount - マウント",
      "level": 3,
      "content": "systemd は /etc/fstab で指定されたパーティションとファイルシステムのマウントを担当します。systemd-fstab-generator(8) は /etc/fstab の全てのエントリを systemd ユニットに変換します; これは起動時とシステムマネージャの設定が再ロードされた時に実行されます。\n\nsystemd は通常の fstab 機能を拡張し、追加のマウントオプションを提供します。これらのオプションはマウントユニットの依存関係に影響を与えます。例えば、ネットワークが立ち上がった時だけマウントするようにしたり、他のパーティションがマウントされた時だけマウントするようにすることができます。特定の systemd マウントオプションの完全なリストは、通常 x-systemd. で始まり、 systemd.mount(5) § FSTAB で詳細に説明されています。\n\nこれらのマウントオプションの例として、自動マウントがあります。これは、ブート時に自動的にマウントするのではなく、リソースが必要な時にだけマウントすることを意味します。これは fstab#systemd による自動マウント で提供されています。\n\n"
    },
    {
      "title": "GPT パーティションの自動マウント",
      "level": 4,
      "content": "UEFI で起動するシステムでは、root、home、swap などの GPT パーティションを Discoverable Partitions Specification に従って自動的にマウントできます。これにより、これらのパーティションを fstab に記述する必要がなくなり、ルートパーティションが自動マウントされる場合は、カーネルコマンドラインの root= も省略できます。詳細は systemd-gpt-auto-generator(8) を参照してください。\n\n前提条件:\n\n- mkinitcpio を使用する場合、systemd フック が必要です。\n- 自動マウントするすべてのパーティションは、ESP(EFI System Partition)と同じ物理ディスク上に存在する必要があります。\n- 正しい GPT パーティションタイプを設定する必要があります。詳細は パーティショニング#パーティションスキーム を参照してください。\n- ブートローダーが LoaderDevicePartUUID EFI 変数を設定し、使用する EFI システムパーティションを識別できる必要があります。これに対応しているのは systemd-boot、systemd-stub(7)、GRUB(grub-mkconfig による grub.cfg 生成時)、および rEFInd(デフォルトでは無効) です。これを確認するには、bootctl を実行し、Boot loader sets ESP information または ユニファイドカーネルイメージ での起動時の Stub sets ESP information の状態をチェックしてください。\n\nudev は /dev/gpt-auto-root というシンボリックリンクを作成し、ルートボリュームのブロックデバイスを指します。ルートパーティションが LUKS で暗号化されている場合、/dev/gpt-auto-root は復号されたマップ済みボリュームを指し、/dev/gpt-auto-root-luks は暗号化されたパーティションを指します。\n\n/var の自動マウントが動作するためには、PARTUUID がパーティションタイプの UUID (4d21b016-b534-45c2-a9fb-5c16e091fd2d) の SHA256 HMAC ハッシュにマシン ID でキーを付けたものと一致している必要があります。必要な PARTUUID は、以下の方法で取得できます。\n\n```\n$ systemd-id128 -u --app-specific=4d21b016-b534-45c2-a9fb-5c16e091fd2d machine-id\n```\n\n"
    },
    {
      "title": "systemd-sysvcompat",
      "level": 3,
      "content": "systemd-sysvcompat (base の依存) の主な役割は、伝統的な linux init バイナリを提供することです。systemd により制御されているシステムでは、init はその systemd 実行ファイルへのシンボリックリンクに過ぎません。\n\nさらに、SysVinit のユーザーが慣れ親しんでいるであろう4つの便利なショートカットも提供されています。便利なショートカットは halt(8), poweroff(8), reboot(8), shutdown(8) です。これら4つのコマンドはそれぞれ systemctl へのシンボリックリンクであり、systemd の動作に支配されます。そのため、#電源管理 での議論が適用されます。\n\nsystemd ベースのシステムは init= ブートパラメータ (例えば、/bin/init is in systemd-sysvcompat ?) と systemd ネイティブ systemctl コマンド引数を使うことで、これらの System V 互換の方法を諦めることができます。\n\n"
    },
    {
      "title": "systemd-tmpfiles - 一時ファイル",
      "level": 3,
      "content": "systemd-tmpfiles は揮発性ファイルや一時ファイル、ディレクトリの作成、削除、クリーンアップを行います。systemd-tmpfiles は /etc/tmpfiles.d/ と /usr/lib/tmpfiles.d/ にある設定ファイルを読んで、実行するアクションを決めます。前者のディレクトリにある設定ファイルは後者のディレクトリにある設定ファイルより優先されます。\n\n設定ファイルは通常サービスファイルと一緒に提供され、/usr/lib/tmpfiles.d/program.conf というスタイルで命名されます。例えば、Samba デーモンはディレクトリ /run/samba が存在し、正しいパーミッションを持っていることを期待します。そのため、samba パッケージはこの設定で出荷されます:\n\n```\n/usr/lib/tmpfiles.d/samba.conf\n```\n\n```\nD /run/samba 0755 root root\n```\n\n設定ファイルは、起動時に特定のファイルに値を書き込むために使用することもできます。例えば、/etc/rc.local で USB デバイスからの wakeup を無効にするために echo USBE > /proc/acpi/wakeup を使った場合、代わりに以下の tmpfile を使用することができます:\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Path                  Mode UID  GID  Age Argument\nw    /proc/acpi/wakeup     -    -    -    -   USBE\n```\n\n同じファイルに複数行を書き込むことが可能です。引数内に \\n を含めるか、追記 のために w+ モードを使用して(最初の行を含め)複数行を記述することができます:\n\n```\n/etc/tmpfiles.d/disable-usb-wake.conf\n```\n\n```\n#    Path                  Mode UID  GID  Age Argument\nw+   /proc/acpi/wakeup     -    -    -    -   USBE\nw+   /proc/acpi/wakeup     -    -    -    -   LID0\n```\n\n詳しくは systemd-tmpfiles(8) および tmpfiles.d(5) のマニュアルページを参照してください。\n\n"
    },
    {
      "title": "ソケットアクティベーション",
      "level": 3,
      "content": "一部のパッケージには .socket ユニットが含まれています。例としては、cups パッケージの cups.socket ユニットがあります[2]。cups.socket が有効化されると (なおかつ cups.service を無効化しておくと)、systemd は CUPS を即座には起動せず、適切なソケットをリッスンします。何らかのプログラムがそのソケットに接続しようとした際に初めて systemd が cups.service を起動し、CUPS プロセスへのポートの制御を透過的に橋渡しします。\n\n"
    },
    {
      "title": "GUI 設定ツール",
      "level": 3,
      "content": "- systemadm — systemd ユニット用のグラフィカルブラウザ。ユニットのリストを表示することができ、タイプでフィルタリングすることもできます。\n\n- SystemdGenie — systemd KDE 技術に基づく管理ユーティリティ。\n\n"
    },
    {
      "title": "ネットワークが稼働した後にサービスを実行する",
      "level": 3,
      "content": "ネットワークが立ち上がった後までサービスを遅らせるには、以下の依存関係を .service ファイルに含めます。\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target\n...\n```\n\nネットワークを管理する特定のアプリケーションのネットワーク待ち受けサービスも有効にして、network-online.target がネットワークの状態を適切に反映するようにする必要があります。\n\n- NetworkManager を利用している場合、NetworkManager-wait-online.service は NetworkManager.service と一緒に有効になっています。systemctl is-enabled NetworkManager-wait-online.service で確認してください。有効になっていない場合は、NetworkManager.service を 再有効化 してください。\n- netctl の場合、netctl-wait-online.service を 有効化 して下さい (netctl-auto を使っていない場合。FS#75836 を参照してください)。\n- systemd-networkd を利用している場合、systemd-networkd-wait-online.service は systemd-networkd.service と一緒に有効になっています。systemctl is-enabled systemd-networkd-wait-online.service でこの状態にあるかどうか確認してください。有効になっていない場合は、systemd-networkd.service を 再有効化 してください。\n\nより詳しい説明は ネットワーク設定の同期のポイント の議論をご覧ください。\n\nサービスが DNS クエリを実行する必要がある場合、追加で nss-lookup.target の後に命令する必要があります。\n\n```\n/etc/systemd/system/foo.service\n```\n\n```\n[Unit]\n...\nWants=network-online.target\nAfter=network-online.target nss-lookup.target\n...\n```\n\nsystemd.special(7) § Special Passive System Units を参照してください。\n\nnss-lookup.target が効果を発揮するためには、Wants=nss-lookup.target で実行を要求して、Before=nss-lookup.target で事前に実行されているように指定してあるサービスが必要です。通常、これはローカルの DNSリゾルバ によって行われます。\n\nどのアクティブなサービスが nss-lookup.target で実行を要求しているのかを確認してください。\n\n```\n$ systemctl list-dependencies --reverse nss-lookup.target\n```\n\n"
    },
    {
      "title": "インストールされたユニットをデフォルトで有効にする",
      "level": 3,
      "content": "Arch Linux の /usr/lib/systemd/system-preset/99-default.preset には disable * と記述されています。systemctl プリセットがデフォルトで全てのユニットを無効化するようになり、新しいパッケージがインストールされたときも、ユーザーが手動でユニットを有効化する必要があります。\n\n自動的に有効化させたい場合、/etc/systemd/system-preset/99-default.preset から /dev/null にシンボリックリンクを作成して設定ファイルを上書きしてください。systemctl プリセットの設定ディレクトリで指定しないかぎり、インストールされた全てのユニットが、ユニットのタイプに関わらず有効化されるようになります。詳しくは systemd.preset(5) の man ページを参照。\n\n"
    },
    {
      "title": "アプリケーション環境のサンドボックス化",
      "level": 3,
      "content": "ユニットファイルをサンドボックスとして作成して堅牢な仮想環境にアプリケーションやプロセスを分離させることが可能です。systemd は名前空間や、許可・拒否された ケイパビリティ のリスト、Cgroups を活用して実行環境を設定しプロセスをコンテナ化します—systemd.exec(5)。\n\n既存の systemd ユニットファイルを使ってアプリケーションをサンドボックス化するには strace, stderr, journalctl などでエラーや出力を確認しながら試行錯誤が必要です。まずは上流のドキュメントを検索して先例がないか確認すると良いでしょう。堅牢にし得る選択肢の出発点を探すには、以下のコマンドを実行します。\n\n```\n$ systemd-analyze security unit\n```\n\nsystemd をサンドボックス化するいくつかの例は以下にあります。\n\n- CapabilityBoundingSet は、ユニットに許可または拒否された capabilities(7) のリストを定義します。systemd.exec(5) § CAPABILITIES を参照してください。 例えば、安全なサンドボックスのゴール の1つである CAP_SYS_ADM ケイパビリティ: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n- 例えば、安全なサンドボックスのゴール の1つである CAP_SYS_ADM ケイパビリティ: CapabilityBoundingSet=~ CAP_SYS_ADM\n\n"
    },
    {
      "title": "サービスの失敗を通知する",
      "level": 3,
      "content": "サービス障害を通知するためには、OnFailure= ディレクティブを、例えば ドロップイン設定ファイル を使用して、該当するサービスファイルに追加する必要があります。このディレクティブを各サービスユニットに追加するには、トップレベルのドロップイン設定ファイルを使用します。トップレベルのドロップインについて詳しくは systemd.unit(5) を参照してください。\n\nサービス用のトップレベルのドロップインを作成します。\n\n```\n/etc/systemd/system/service.d/toplevel-override.conf\n```\n\n```\n[Unit]\nOnFailure=failure-notification@%n\n```\n\nこれにより、すべてのサービスファイルに OnFailure=failure-notification@%n が追加されます。some_service_unit が失敗すると、failure-notification@some_service_unitが開始されて通知(または実行するよう設定された任意のタスク)を処理するようになります。\n\nテンプレートユニット failure-notification@ を作成します。\n\n```\n/etc/systemd/system/failure-notification@.service\n```\n\n```\n[Unit]\nDescription=Send a notification about a failed systemd unit\nAfter=network.target\n\n[Service]\nType=simple\nExecStart=/path/to/failure-notification.sh %i\n```\n\nfailure-notification.sh スクリプトを作成し、何をするか、どのように通知するか(メール、gotify、xmpp など)を定義します。%i は失敗したサービスユニットの名前で、スクリプトの引数として渡されます。\n\n起動に失敗した場合に、何度も failure-notification@.service のインスタンスを起動する再帰を防ぐために、トップレベルのドロップインと同じ名前の空のドロップイン設定ファイルを作成します(空のサービスレベルのドロップイン設定ファイルはトップレベルのドロップインより優先され、後者をオーバーライドします。)\n\n```\n# mkdir -p /etc/systemd/system/failure-notification@.service.d\n# touch /etc/systemd/system/failure-notification@.service.d/toplevel-override.conf\n```\n\n"
    },
    {
      "title": "Eメールでの通知",
      "level": 3,
      "content": "systemd を設定して、ユニットが失敗した際に Eメールを送信することができます。Cron はジョブの出力が標準出力 (stdout) または標準エラー (stderr) にある場合に MAILTO にメールを送信しますが、多くのジョブはエラー時のみ出力するように設定されています。\n\nまず、メールを送信するための実行ファイルと、それを起動する .service ファイルの 2 つが必要です。この例では、実行ファイルは単なるシェルスクリプトであり、smtp-forwarder を提供するパッケージに含まれる sendmail を使用します。\n\n```\n/usr/local/bin/systemd-email\n```\n\n```\n#!/bin/sh\n\n/usr/bin/sendmail -t <<ERRMAIL\nTo: $1\nFrom: systemd <root@$HOSTNAME>\nSubject: $2\nContent-Transfer-Encoding: 8bit\nContent-Type: text/plain; charset=UTF-8\n\n$(systemctl status --full \"$2\")\nERRMAIL\n```\n\nどの実行ファイルを使用する場合でも、このシェルスクリプトのように少なくとも 2 つの引数(送信先アドレスと、ステータスを取得するユニットファイル)を受け取るようにするのが望ましいです。作成する .service は、これらの引数を渡すように設定します。\n\n```\n/etc/systemd/system/status_email_user@.service\n```\n\n```\n[Unit]\nDescription=status email for %i to user\n\n[Service]\nType=oneshot\nExecStart=/usr/local/bin/systemd-email address %i\nUser=nobody\nGroup=systemd-journal\n```\n\nここで、user はメールを受信するユーザー、address はそのユーザーのメールアドレスを指します。受信者のアドレスは固定されていますが、通知対象のユニットファイルはインスタンスパラメータとして渡されるため、この 1 つのサービスで他の多くのユニットに対してメールを送信できます。この時点で、status_email_user@dbus.service を 起動 して、メールを正しく受信できるか確認してください。\n\n次に、メール通知を受け取りたいサービスを編集し、[Unit] セクションに OnFailure=status_email_user@%n.service を追加します。%n はユニットの名前をテンプレートに渡します。\n\n- sSMTP#セキュリティ に従って sSMTP のセキュリティを設定すると、ユーザー nobody は /etc/ssmtp/ssmtp.conf へのアクセス権を持たず、systemctl start status_email_user@dbus.service コマンドが失敗します。一つの解決策として、status_email_user@.service ユニットの User を root に設定する方法があります。\n- メールスクリプト内で mail -s somelogs address を使用すると、mail がフォークし、スクリプトが終了した際に systemd により mail プロセスが強制終了される可能性があります。これを防ぐには、フォークしないように mail -Ssendwait -s somelogs address を使用してください。\n\n最新の systemd では、User=nobody の使用は推奨されておらず、代わりに DynamicUser=true を使用することが推奨されています。詳しくは GitHub issue 428 を参照してください。\n\n"
    },
    {
      "title": "シャットダウン時に自動で外部 HDD の電源を切る",
      "level": 3,
      "content": "こちらを参照、Udisks#シャットダウン時に自動で外部 HDD の電源を切る\n\n"
    },
    {
      "title": "systemd のエラーを調査する",
      "level": 3,
      "content": "起動に失敗している systemd サービスを探すには以下のコマンドを実行します。\n\n```\n$ systemctl --state=failed\n```\n\n失敗している理由を探すには、ログ出力を調べてください。詳細は systemd/ジャーナル#フィルタリング を参照してください。\n\n"
    },
    {
      "title": "ブート問題の診断",
      "level": 3,
      "content": "systemd は、ブートプロセスの問題を診断するためのいくつかのオプションを提供しています。一般的な手順や、systemd が ブートプロセス を引き継ぐ前のブートメッセージを残す方法については ブートデバッグ を参照してください。freedesktop.org の systemd デバッグドキュメント も参照してください。\n\n"
    },
    {
      "title": "特定のサービスの問題を診断",
      "level": 3,
      "content": "ある systemd サービスが上手く動作せず、どうなっているのか詳しい情報が欲しい場合、環境変数 SYSTEMD_LOG_LEVEL を debug に設定してください。以下は systemd-networkd デーモンをデバッグモードで動かす例です:\n\nサービスに ドロップインファイル を追加して、次の2行を追記してください。\n\n```\n[Service]\nEnvironment=SYSTEMD_LOG_LEVEL=debug\n```\n\nあるいは、環境変数を手動でセットしても同じです。\n\n```\n# SYSTEMD_LOG_LEVEL=debug /lib/systemd/systemd-networkd\n```\n\nその後 systemd-networkd を リスタート して、サービスのジャーナルを -f/--follow オプションで監視してください。\n\n"
    },
    {
      "title": "シャットダウン/再起動にものすごく時間がかかる",
      "level": 3,
      "content": "シャットダウンに非常に長い時間がかかる(もしくはフリーズする)場合、サービスが存在していないことが問題かもしれません。Systemd はサービスを kill する前に終了するのを待ちます。該当しているか確認するには、systemd wiki の Shutdown completes eventually を参照してください。\n\n一般的な問題は、シャットダウンやサスペントのプロセスが停止することです。該当するかどうか確かめるには、以下のどちらかのコマンドを実行して、出力を確認してください。\n\n```\n# systemctl poweroff\n```\n\n```\nFailed to power off system via logind: There's already a shutdown or sleep operation in progress\n```\n\n```\n# systemctl list-jobs\n```\n\n```\nJOB UNIT                    TYPE  STATE  \n...\n21593 systemd-suspend.service start running\n21592 suspend.target          start waiting\n..\n```\n\nこれの 解決策 は、以下を実行してそれらのジョブをキャンセルすることです。\n\n```\n# systemctl cancel\n# systemctl stop systemd-suspend.service\n```\n\nすると、シャットダウンやリブートをまた再開します。\n\n"
    },
    {
      "title": "短いプロセスがログを出力しない",
      "level": 3,
      "content": "journalctl -u foounit が短いプロセスについてなにも表示しない場合、かわりに PID を見て下さい。例えば、systemd-modules-load.service が失敗したとき、systemctl status systemd-modules-load によってそれが PID 123 として動いているとわかったら、その PID の journal の出力を見ることができます、journalctl -b _PID=123。journal の _SYSTEMD_UNIT や _COMM などのメタデータは非同期に収集され /proc ディレクトリにプロセスが存在している時だけ表示されます。これを修正するには、SCM_CREDENTIALS のように、ソケット接続を使ってデータを流すようカーネルを変更する必要があります。簡単に言うと、これは バグ です。systemd の設計によって、即座に失敗するサービスはジャーナルに何も出力しない場合があることを覚えておいてください。\n\n"
    },
    {
      "title": "少しづつ起動時間が長くなっている",
      "level": 3,
      "content": "systemd-analyze を使用して、以前と比べて起動時間が明らかに伸びていると複数のユーザーが報告しています。systemd-analyze blame を使って NetworkManager が起動するのに異常に長い時間かかるようになったという報告もあります。\n\n問題の原因として /var/log/journal が巨大になりすぎている可能性があります。そのような場合、フォルダ内のファイルを全て削除して journal のファイルサイズをここに書かれているように制限するよう設定すれば解決します(できればファイルを削除する前に、どこかに一時的にバックアップしてください)。\n\n"
    },
    {
      "title": "起動時に systemd-tmpfiles-setup.service の実行に失敗する",
      "level": 3,
      "content": "systemd 219 から、/usr/lib/tmpfiles.d/systemd.conf は /var/log/journal 下のディレクトリに対して ACL 属性を指定しており、それによって、ジャーナルが存在するファイルシステムで ACL のサポートを有効にしなくてはならなくなっています。\n\n/var/log/journal が存在するファイルシステムで ACL を有効化する方法はアクセス制御リスト#ACL の有効化を見て下さい。\n\n"
    },
    {
      "title": "リモートマシンで緊急モードを無効化",
      "level": 3,
      "content": "リモートマシン、例えば Azure や Google Cloud でホストされている仮想マシンで緊急モードを無効にしたい場合があるかもしれません。緊急モードがトリガーされると、ネットワークへの接続がブロックされるためです。\n\nこれを無効にするには、mask を使用して emergency.service と emergency.target を無効化します。\n\n"
    },
    {
      "title": "サービスは存在しているが \"Unit xxx.service not found\" というエラーが表示される",
      "level": 3,
      "content": "ユーザーユニットをシステムユニットとして開始または有効化しようとしている可能性があります。systemd.unit(5) には、どのユニットがどこに存在するかが示されています。デフォルトでは、systemctl はシステムサービスに対して操作を行います。\n\n詳細については、Systemd/ユーザー を参照してください。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Wikipedia:systemd\n- 公式ウェブサイト systemd の最適化 systemd FAQ systemd のヒントとテクニック\n- systemd(1)\n- その他のディストリビューション Gentoo:Systemd Fedora:Systemd Fedora:How to debug Systemd problems Fedora:SysVinit to Systemd Cheatsheet Debian:systemd\n- Lennart's blog story, update 1, update 2, update 3, summary\n- Systemd サービスのデバッグ\n- 管理者向け systemd (PDF)\n- Systemctl を使用して Systemd サービスとユニットを管理する方法\n- systemd-logind によるセッション管理\n- Emacs Systemd ファイルの構文強調表示\n- Two part The H Open 誌の紹介記事。\n\n- systemd の最適化\n- systemd FAQ\n- systemd のヒントとテクニック\n\n- Gentoo:Systemd\n- Fedora:Systemd\n- Fedora:How to debug Systemd problems\n- Fedora:SysVinit to Systemd Cheatsheet\n- Debian:systemd\n\n"
    }
  ]
}