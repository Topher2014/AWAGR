{
  "title": "Rsync (Français)",
  "url": "https://wiki.archlinux.org/title/Rsync_(Fran%C3%A7ais)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Related articles\n\n- System backup\n- Synchronization and backup programs\n\nrsync est un utilitaire open source permettant des transferts de fichiers rapides et incrémentés.\n\n"
    },
    {
      "title": "Installation",
      "level": 2,
      "content": "Installez le paquet rsync\n\nrsync doit être présent sur les deux machines, source et destination.\n\n"
    },
    {
      "title": "Interfaces",
      "level": 3,
      "content": "- Grsync — Une interface GTK+.\n\n- JotaSync — Application graphique en Java Swing avec planificateur intégré.\n\n- luckyBackup — Interface Qt écrite en C++.\n\nD'autres outils utilisant rsync sont rdiff-backupAUR, osyncAUR et yarsyncAUR.\n\n"
    },
    {
      "title": "Comme alternative à cp/mv",
      "level": 2,
      "content": "rsync peut être utilisé comme alternative avancée aux commandes cp oumv , particulièrement le transfert de de fichiers volumineux:\n\n```\n$ rsync -P source destination\n```\n\nL'option -P, soit --partial --progress garde les fichiers partiellement transférés et affiche une barre de progression.\n\nPour copier récursivement les sous-répertoires l'option est -r --recursive .\n\nLes fichiers peuvent être copiés localement comme avec la commande cp, mais le but essentiel de rsync est la copie à distance, c.a.d.. d'un hôte à un autre. L'emplacement distant sera signifié par la syntaxe deux-points : , ex:\n\n```\n$ rsync source host:destination\n```\n\nou\n\n```\n$ rsync host:source destination\n```\n\nLes transferts par le réseau utilisent le protocole SSH par défaut et host peut être un nom réel d'hôte existant ou un profil/alias prédéfini dans .ssh/config.\n\nQu'il s'agisse d'un transfert de fichiers en local ou à distance, Rsync crée d'abord une liste des fichiers avec leurs données (par défaut, taille du fichier et dernier horodatage de modification) qui sera ensuite utilisée pour déterminer si un fichier doit être construit. Pour chaque fichier à construire, une somme de contrôle faible et forte est trouvée pour tous les blocs de sorte que chaque bloc est de longueur S octets, sans chevauchement, et ait un décalage divisible par S. En utilisant cette information, rsync peut construire un fichier de grande taille sans avoir à le transférer en entier. Pour une explication pratique et mathématique détaillée, reportez-vous respectivement au fonctionnement de rsync et à l'algorithme de rsync.\n\nPour utiliser rapidement des valeurs par défaut sensées, vous pouvez utiliser des alias :\n\n```\ncpr() {\n rsync --archive -hh --partial --info=stats1 --info=progress2 --modify-window=1 \"$@\"\n} \nmvr() {\n rsync --archive -hh --partial --info=stats1 --info=progress2 --modify-window=1 --remove-source-files \"$@\"\n}\n```\n\n- -hh : affiche les chiffres dans un format lisible humainement\n- --info=stats1,progress2 : stats1 affiche les statistiques de transfert rsync avec un niveau de verbosité de 1. progress2 imprime la progression totale du transfert par opposition à la progression du transfert par fichier (progress1).\n- --modify-window=1 : lorsque vous comparez les horodatages de deux fichiers, traitez leurs horodatages comme étant équivalents si leur différence est inférieure à 1 seconde.\n- --remove-source-files : supprime les fichiers du répertoire source après qu'ils aient été synchronisés avec succès.\n\nNote: **n'est pas** \n\n"
    },
    {
      "title": "Mise en garde sur la terminaison par slash",
      "level": 3,
      "content": "Arch Linux utilise par défaut la convention GNU de la commande cp (du paquet coreutils). Tandis que rsync suit la convention BSD de cp, qui accorde un traitement spécial aux répertoires sources avec barre oblique \"/\" finale (trailing slash). Ainsi la commande:\n\n```\n$ rsync -r source destination\n```\n\ncréera le répertoire \"destination/source\" avec le contenu de \"source\", alors que la commande:\n\n```\n$ rsync -r source/ destination\n```\n\nne copie que les fichiers de \"source/\" directement dans \"destination\", sans créer le sous-répertoire \"destination/source\" - comme si vous aviez lancé:\n\n```\n$ rsync -r source/. destination\n```\n\nCe comportement est différent de celui de GNU/cp, qui traite \"source\" et \"source/\" de la même façon (mais non \"source/.\"). De plus certains shells ajoutent automatiquement la barre oblique aux noms des répertoires en cas de complétion par touche <Tab>. En conséquence cette somme de facteurs pourraient amener des utilisateurs nouveaux ou occasionnels de rsync, oubliant ce comportement différent, à désorganiser ou même écraser des répertoires importants par le maintien d'une barre oblique en fin de la <source> dans la commande.\n\nAussi il peut être prudent d'envelopper la commande par un script enlevant automatiquement cette barre avant le lancement de rsync:\n\n```\n#!/bin/bash\nnew_args=()\nfor i in \"${@}\"; do\n    case \"${i}\" in\n        /)\n            i=\"/\"\n        ;;\n        */)\n            i=\"${i%/}\"\n        ;;\n        esac\n    new_args+=(\"${i}\")\ndone\nexec rsync \"${new_args[@]}\"\n```\n\nCe script peut être placé quelque part dans le chemin, et aliasé à rsync dans le fichier de démarrage du shell.\n\n"
    },
    {
      "title": "Comme un utilitaire de sauvegarde",
      "level": 2,
      "content": "Le protocole rsync est facile à utiliser pour les tâches de sauvegarde, ne transférant que les fichiers modifiés depuis la précédente sauvegarde. Ce paragraphe décrit une sauvegarde programmée très simple avec un script utilisant rsync, typiquement utilisé lors de copies sur un support amovible.\n\n"
    },
    {
      "title": "Sauvegardes automatisées",
      "level": 3,
      "content": "Pour les besoins de cet exemple, le script est créé dans le répertoire /etc/cron.daily, pour se lancer chaque jour si le daemon cron est installé et correctement configuré. Configurer et utiliser cron n'appartient pas à cet article.\n\nD'abord, créer un script avec les options de commande appropriées:\n\n```\n/etc/cron.daily/backup\n```\n\n```\n#!/bin/sh\nrsync -a --delete --quiet /path/to/backup /location/of/backup\n```\n\n- -a : indique quels fichiers doivent être archivés, entendu que la plupart de leurs attributs soient préservés (mais non les ACLs, liens matériels (hard links), ni attributs étendus tels les capabilités.\n- --delete : signifie que les fichiers supprimés sur la source doivent également être supprimés sur la sauvegarde.\n\nIci, /path/to/backup sera remplacé par le chemin des données à sauvegarder (/home, par exemple) et /location/of/backup sera le chemin de destination de la sauvegarde (/media/disk, par exemple).\n\nTerminer en rendant le script exécutable\n\n"
    },
    {
      "title": "Sauvegarde automatique avec SSH",
      "level": 3,
      "content": "Si vous sauvegardez sur un hôte distant en utilisant SSH, utilisez ce script à la place :\n\n```\n/etc/cron.daily/backup\n```\n\n```\n#!/bin/bash\nrsync -a --delete --quiet -e ssh /folder/to/backup remoteuser@remotehost:/location/of/backup\n```\n\n- -e ssh : indique à rsync d'utiliser SSH\n- remoteuser : est le nom de l'hôte distant remotehost\n- -a : regroupe les options -rlptgoD (recursive, links, perms, times, group, owner, devices)\n\n"
    },
    {
      "title": "Sauvegarde automatique avec NetworkManager",
      "level": 3,
      "content": "Ce script démarre une sauvegarde après connexion au réseau.\n\nD'abord, créez un script avec les options de commande appropriées:\n\n```\n/etc/NetworkManager/dispatcher.d/backup\n```\n\n```\n#!/bin/bash\n\nif [ x\"$2\" = \"xup\" ] ; then\n        rsync --force --ignore-errors -a --delete --bwlimit=2000 --files-from=files.rsync /path/to/backup /location/of/backup\nfi\n```\n\n- -a : groupe toutes les options -rlptgoD recursive, links, perms, times, group, owner, devices\n- --files-from : lire le chemin relatif de /path/to/backup à partir de ce fichier\n- --bwlimit : limite la bande passante E/S; Kilo-octets par seconde\n\nLe script doit appartenir à root (consultez NetworkManager (Français)#Services réseau avec le répartiteur NetworkManager pour plus de détails).\n\n"
    },
    {
      "title": "Sauvegarde automatique avec systemd et inotify",
      "level": 3,
      "content": "- Du fait des limitations de systemd et inotify (voir cette question et réponse), la surveillance récursive du système de fichiers n'est pas possible. Bien que vous puissiez surveiller un répertoire et son contenu, il n'effectuera pas de récursion dans les sous-répertoires et ne surveillera pas leur contenu ; vous devez spécifier explicitement chaque répertoire à surveiller, même si ce répertoire est l'enfant d'un répertoire déjà surveillé.\n- Cette configuration est basée sur une instance de systemd (Français)/User (Français).\n\n- Au lieu d'exécuter des sauvegardes avec une programmation basée sur des intervalles temporels, comme avec cron, il est possible d'exécuter une sauvegarde à chaque modification d'un des fichiers à sauvegarder.\n\nLes unités de chemin systemd.path utilisent inotify pour surveiller le système de fichiers, en conjonction avec des fichiers systemd.service pour démarrer n'importe quel processus (dans ce cas, votre sauvegarde rsync) basé alors sur un événement dans le système de fichiers.\n\nD'abord, créez l'unité de chemin systemd.path, lançant la surveillance des fichiers à sauvegarder:\n\n```\n~/.config/systemd/user/backup.path\n```\n\n```\n[Unit]\nDescription=Vérification dans les chemins de changements dans les répertoires à sauvegarder\n\n[Path]\nPathChanged=%h/documents\nPathChanged=%h/music\n\n[Install]\nWantedBy=default.target\n```\n\nPuis le service systemd.service qui sera activé par toute modification. Par défaut, un fichier de service du même nom que l'unité path (dans ce cas backup.path) sera activé, mais avec l'extension .service au lieu de .path (dans notre cas backup.service).\n\n```\n~/.config/systemd/user/backup.service\n```\n\n```\n[Unit]\nDescription=Sauvagarde les fichiers\n\n[Service]\nExecStart=/usr/bin/rsync %h/./documents %h/./music -CERrltm --delete ubuntu:\n```\n\nMaintenant activez et démarrez simplement backup.path comme un service systemd normal et il commencera à surveiller les changements de fichiers et démarrera automatiquement backup.service.\n\n"
    },
    {
      "title": "Sauvegarde différentielle sur une semaine",
      "level": 3,
      "content": "Autre possibilité utile des option de rsync, qui permet d'obtenir une sauvegarde complète (à chaque exécution) et de conserver une copie de sauvegarde différentielle des fichiers modifiés uniquement dans un répertoire distinct pour chaque jour de la semaine.\n\nD'abord, créez un script avec les options de commande appropriées:\n\n```\n/etc/cron.daily/backup\n```\n\n```\n#!/bin/bash\n\nDAY=$(date +%A)\n\nif [ -e /location/to/backup/incr/$DAY ] ; then\n  rm -fr /location/to/backup/incr/$DAY\nfi\n\nrsync -a --delete --quiet --inplace --backup --backup-dir=/location/to/backup/incr/$DAY /folder/to/backup/ /location/to/backup/full/\n```\n\nL'option --inplace implique --partial et met à jour les fichiers en place dans le répertoire de destination.\n\n"
    },
    {
      "title": "Sauvegardes par instantanés (Snapshots)",
      "level": 3,
      "content": "La même démarche peut servir au maintien d'un arbre d'instantanés de vos fichiers. Autrement dit, un répertoire avec des copies des fichiers rangées par date. Ces copies seront faites par utilisation de liens matériels (hard links, attribution d'un seul i-nœud) ce qui signifie que seuls les fichiers modifiés occuperont un espace supplémentaire. D'une manière générale, c'est l'idée qui sous-tend les TimeMachine d'Apple.\n\nCe script de base est facile à implémenter, il crée des snapshots incrémentaux rapides en utilisant l'option --link-dest pour lier des fichiers non modifiés:\n\n```\n/usr/local/bin/snapbackup.sh\n```\n\n```\n#!/bin/sh\n\n# Basic snapshot-style rsync backup script \n\n# Configurer\nOPT=\"-aPh\"\nLINK=\"--link-dest=/snapshots/username/last/\" \nSRC=\"/home/username/files/\"\nSNAP=\"/snapshots/username/\"\nLAST=\"/snapshots/username/last\"\ndate=`date \"+%Y-%b-%d:_%T\"`\n\n# Lancement de rsync pour créer un instantanét\nrsync $OPT $LINK $SRC ${SNAP}$date\n\n# Suppression du lien symbolique vers l'instantané précédent\nrm -f $LAST\n\n# Création d'un nouveau lien symbolique vers le dernier instantané pour le lien matériel vers la prochaine sauvegarde \nln -s ${SNAP}$date $LAST\n```\n\nIl doit y avoir un lien symbolique vers une sauvegarde complète déjà existante en tant que cible pour --link-dest. En cas d'effacement du plus récent des instantanés il faut recréer un lien symbolique vers le plus récent suivant. Si --link-dest ne trouve pas de lien symbolique fonctionnel, rsync devra re-copier la source entière au lieu des seuls fichiers modifiés.\n\nUne version plus sophistiquée conserve une sauvegarde complète à jour $SNAP/latest et dans le cas où un certain nombre de fichiers ont été modifiés depuis la dernière sauvegarde complète, elle crée un instantané $SNAP/$DATETAG de la sauvegarde complète actuelle en utilisant cp -al pour lier les fichiers inchangés :\n\n```\n/usr/local/bin/rsnapshot.sh\n```\n\n```\n#!/bin/sh\n\n## my own rsync-based snapshot-style backup procedure\n## (cc) marcio rps AT gmail.com\n\n# config vars\n\nSRC=\"/home/username/files/\" #ne PAS oublier la barre oblique finale !\nSNAP=\"/snapshots/username\"\nOPTS=\"-rltgoi --delay-updates --delete --chmod=a-w\"\nMINCHANGES=20\n\n# lancer le processus avec une priorité vraiment basse\n\nionice -c 3 -p $$\nrenice +12  -p $$\n\n# synchronisation\n\nrsync $OPTS $SRC $SNAP/latest >> $SNAP/rsync.log\n\n# test d'un nombre suffisant de fichiers modifiés\n# création d'une copie en lien matériel nommée avec la date\n\nCOUNT=$( wc -l $SNAP/rsync.log|cut -d\" \" -f1 )\nif [ $COUNT -gt $MINCHANGES ] ; then\n        DATETAG=$(date +%Y-%m-%d)\n        if [ ! -e $SNAP/$DATETAG ] ; then\n                cp -al $SNAP/latest $SNAP/$DATETAG\n                chmod u+w $SNAP/$DATETAG\n                mv $SNAP/rsync.log $SNAP/$DATETAG\n               chmod u-w $SNAP/$DATETAG\n         fi\nfi\n```\n\nPour faire très très simple ce script peut-être lancé depuis une unité systemd/Timers.\n\n"
    },
    {
      "title": "Sauvegarde système complète",
      "level": 3,
      "content": "Cette section concerne l'utilisation de rsync pour transférer une copie de l'arborescence / entière, à l'exception de quelques répertoires sélectionnés. Cette approche est considérée comme meilleure que le clonage de disque avec dd car elle permet d'utiliser une taille, une table de partition et un système de fichiers différents, et meilleure que la copie avec cp -a également, car elle permet un meilleur contrôle des permissions de fichiers, des attributs, des listes de contrôle des accès (ACL) et des attributs étendus.\n\nrsync fonctionnera même lorsque le système est en cours d'exécution, mais les fichiers modifiés pendant le transfert peuvent ou non être transférés, ce qui peut entraîner un comportement indéfini de certains programmes utilisant les fichiers transférés.\n\nCette approche fonctionne bien pour migrer une installation existante vers un nouveau disque dur ou SSD.\n\nExécutez la commande suivante en tant que root pour vous assurer que rsync peut accéder à tous les fichiers système et en préserver la propriété :\n\n```\n# rsync -aAXv --exclude={\"/dev/*\",\"/proc/*\",\"/sys/*\",\"/tmp/*\",\"/run/*\",\"/mnt/*\",\"/media/*\",\"/home/*\",\"/lost+found\"} / /path/to/backup/directory\n```\n\nLes options -aAX, définissent un transfert en mode archive avec conservation des liens symboliques, des périphériques rattachés, autorisations et propriétés, dates de modification, ACLs et attributs étendus (à condition que le système de fichiers cible prenne en charge ces fonctions. L'option -H préserve les liens matériels mais consomme plus de mémoire.\n\nL'option --exclude définit les fichiers à exclure, correspondant aux motifs définis. Les répertoires /dev, /proc, /sys, /tmp, et /run sont inclus dans la commande ci-dessus, mais le contenu de ces répertoires est exclu. Cela est dû au fait qu'ils sont remplis au démarrage, mais que les répertoires eux-mêmes ne sont pas créés. /lost+found est spécifique au système de fichiers. La commande ci-dessus dépend de l'expansion des accolades disponible dans les shells bash et zsh. Si vous utilisez un autre shell, les motifs --exclude doivent être répétés manuellement. Citer les motifs d'exclusion évitera l'expansion par le shell, ce qui est nécessaire, par exemple, lors de la sauvegarde via SSH. Terminer les chemins exclus par * garantit que les répertoires eux-mêmes sont créés s'ils n'existent pas déjà.\n\n- Si vous prévoyez de sauvegarder votre système ailleurs que dans /mnt ou /media, n'oubliez pas de l'ajouter à la liste des motifs d'exclusion pour éviter une boucle infinie.\n- S'il y a des montages bind dans le système, ils doivent être exclus également afin que le contenu du montage bind ne soit copié qu'une seule fois.\n- Si vous utilisez un fichier d'échange, assurez-vous de l'exclure également.\n- Réfléchissez si vous voulez sauvegarder le répertoire /home/. S'il contient vos données, il peut être considérablement plus grand que le système. Sinon, pensez à exclure les sous-répertoires sans importance tels que /home/*/.thumbnails/*, /home/*/.cache/mozilla/*, /home/*/.cache/chromium/*, et /home/*/.local/share/Trash/*, en fonction des logiciels installés sur le système.\n- Si GVFS est installé, /home/*/.gvfs doit être exclu pour éviter les erreurs de rsync.\n- Si Dhcpcd ≥ 9.0.0 est installé, excluez le répertoire /var/lib/dhcpcd/* car il y monte plusieurs répertoires système en tant que sous-répertoires.\n\nVous pouvez inclure des options rsync supplémentaires, ou en supprimer certaines, comme les suivantes. Consultez rsync(1) pour la liste complète.\n\n- Si vous travaillez sur un système avec très peu de mémoire, envisagez de supprimer l'option -H ; cependant, cela ne devrait pas poser de problème sur la plupart des machines modernes. Il peut y avoir de nombreux liens durs sur le système de fichiers en fonction du logiciel utilisé (par exemple, si vous utilisez Flatpak). De nombreux liens durs résident dans le répertoire /usr/.\n- Vous pouvez ajouter l'option --delete de rsync si vous l'exécutez plusieurs fois dans le même répertoire de sauvegarde. Dans ce cas, assurez-vous que le chemin d'accès à la source ne se termine pas par /*, ou cette option n'aura d'effet que sur les fichiers situés dans les sous-répertoires du répertoire source, mais elle n'aura aucun effet sur les fichiers résidant directement dans le répertoire source.\n- Si vous utilisez des fichiers épars, tels que des disques virtuels, des images Docker et autres, vous devez ajouter l'option -S.\n- L'option --numeric-ids désactivera le mappage des noms d'utilisateurs et de groupes ; à la place, les ID numériques des groupes et des utilisateurs seront transférés. Ceci est utile lors de la sauvegarde via SSH ou lors de l'utilisation d'un système actif pour sauvegarder un disque système différent.\n- Choisir l'option --info=progress2 au lieu de -v montrera l'information de progression globale et la vitesse de transfert au lieu de la liste des fichiers en cours de transfert.\n- Pour éviter de traverser une frontière de système de fichiers lors d'une récursion, ajoutez l'option -x/--one-file-system. Ceci empêchera la sauvegarde de tout point de montage dans la hiérarchie.\n\n"
    },
    {
      "title": "Restauration de la sauvegarde",
      "level": 3,
      "content": "Si vous souhaitez restaurer la sauvegarde, utilisez la même commande rsync que précédemment, mais en inversant source et destination.\n\n"
    },
    {
      "title": "Clonage du système de fichiers",
      "level": 2,
      "content": "rsync fournit le moyen de copier toutes les données d'un système de fichiers en préservant autant d'information que possible, y compris les metadata du système. C'est une procédure de clonage de données au niveau du système de fichiers où les systèmes de fichiers source et destination n'ont pas besoin d'être du même type. Il peut être utilisé pour la sauvegarde, la migration de systèmes de fichiers ou la récupération de données.\n\nLe mode archive de rsync (option -a) est presque adapté à cette tâche, sauf qu'il ne sauvegarde pas les métadonnées spéciales du système de fichiers telles que les listes de contrôle d'accès, les attributs étendus ou les propriétés de fichiers éparses. Pour un clonage réussi au niveau du système de fichiers, certaines options supplémentaires doivent être fournies:\n\n```\nrsync -qaHAXS SOURCE_DIR DESTINATION_DIR\n```\n\nCe qui signifie (selon la page de manuel):\n\n```\n-H, --hard-links      preserve hard links\n-A, --acls            preserve ACLs (implies --perms)\n-X, --xattrs          preserve extended attributes\n-S, --sparse          handle sparse files efficiently\n```\n\nDe plus, utilisez -x si vous avez d'autres systèmes de fichiers montés sous l'arbre que vous voulez exclure de la copie. La copie produite peut être simplement relue et vérifiée (par exemple après une tentative de récupération de données) au niveau du système de fichiers avec l'option récursive de diff:\n\n```\ndiff -r SOURCE_DIR DESTINATION_DIR\n```\n\nIl est possible d'effectuer une migration réussie du système de fichiers en utilisant rsync comme décrit ici puis en mettant à jour les paramètres fstab et chargeur d'amorçage comme décrit dans Migrer une installation vers un nouveau matériel (en). Ceci fournit essentiellement un moyen de convertir n'importe quel système de fichiers racine à un autre.\n\n"
    },
    {
      "title": "Comme un daemon",
      "level": 2,
      "content": "rsync peut-être lancé en tant que daemon sur un serveur, à l'écoute du port 873.\n\nEditez le modèle /etc/rsyncd.conf, configurez un partage et démarrez le rsyncd.service.\n\nUtilisation depuis le client, par exemple lister le contenu du serveur:\n\n```\n$ rsync rsync://server/share\n```\n\ntransférer le fichier du client au serveur:\n\n```\n$ rsync local-file rsync://server/share/\n```\n\nPenser à ouvrir le port 873 dans iptables et l'authentification utilisateur.\n\n"
    },
    {
      "title": "Partage à partir d'une liste de fichiers",
      "level": 4,
      "content": "```\n/etc/rsyncd.conf\n```\n\n```\n...\n\n# Nécessaire pour traverser les frontières du système de fichiers.\n#use chroot = no\nread only = oui\n\n...\n\n[sync]\n    path = /\n# Liste des fichiers à copier.\n    include from = /backup.list\n# Exclure le reste.\n    exclude = *\n```\n\nDans la liste de fichiers, tous les chemins intermédiaires sont nécessaires, sauf lorsque le caractère générique *** est utilisé :\n\n```\n/backup.list\n```\n\n```\n/etc/\n/etc/conf.d/\n/etc/conf.d/hwclock\n/etc/fonts/***\n```\n\n"
    },
    {
      "title": "Voir aussi",
      "level": 2,
      "content": "- D'autres exemples d'utilisation peuvent être trouvées sur la page du projet, dans les Community Contributions, et General Programming forums\n- Howto – local and remote snapshot backup using rsync with hard links Inclut la déduplication des fichiers avec des liens matériels, la vérification d'intégrité par somme-MD5 et integrité de signature, protection par 'chattr' , règles de filtrage, quota de disques, politique de rétention avec une distribution exponentielle (rotation des sauvegardes tout en sauvegardant des sauvegardes plus récentes que les anciennes)\n- Usage des fichiers/clés d'identification SSH avec rsync\n- Fil de discussion du forum international sur les Sauvegardes\n\n"
    }
  ]
}