{
  "title": "Maximizing Performance (日本語)",
  "url": "https://wiki.archlinux.org/title/Maximizing_Performance_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- パフォーマンスの向上/ブートプロセス\n- Pacman ヒント#パフォーマンス\n- OpenSSH#SSH の高速化\n- OpenOffice#OpenOffice の高速化\n- ノートパソコン\n- Preload\n\nこの記事では、知覚または計測できるシステムパフォーマンスの向上を最終目的として、パフォーマンスに関連する基本的なシステム診断、及び、リソース消費量の削減やシステム最適化のための手順に関する情報を提供しています。ゲーミングおよび低レイテンシに特有のその他のアドバイスは ゲーム#パフォーマンスを向上させる も参照してください。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 基本 1.1 システムを知る 1.2 ベンチマーク\n- 2 ストレージデバイス 2.1 セクタサイズ 2.2 パーティショニング 2.2.1 複数のドライブ 2.2.1.1 SSD を HDD のキャッシュとして使う 2.2.2 HDD でのレイアウト 2.3 ファイルシステムの選択とチューニング 2.3.1 マウントオプション 2.4 カーネルパラメータの調整 2.5 I/O スケジューラの設定 2.5.1 背景情報 2.5.2 スケジューリングアルゴリズム 2.5.3 カーネルの I/O スケジューラ 2.5.4 I/O スケジューラの変更 2.5.5 IO スケジューラの調整 2.6 電源管理設定とライトキャッシュ 2.7 ディスクの読み書きを減らす 2.7.1 ディスクの書き込みを表示する 2.7.2 ファイルを tmpfs に再配置する 2.7.3 ファイルシステム 2.7.4 スワップ領域 2.7.5 ライトバックの間隔とバッファサイズ 2.7.6 コアダンプを無効化する 2.8 ionice によるストレージ I/O スケジューリング 2.9 トリム\n- 3 CPU 3.1 オーバークロック 3.2 周波数スケーリング 3.3 CPU スケジューラ 3.4 リアルタイムカーネル 3.5 プロセスの優先順位を設定 3.5.1 Ananicy 3.5.2 cgroups 3.5.3 Cpulimit 3.6 irqbalance 3.7 CPU の脆弱性の緩和策をオフにする\n- 4 グラフィック 4.1 Xorg の設定 4.2 Mesa の設定 4.3 ハードウェアビデオアクセラレーション 4.4 オーバークロック 4.5 PCIe resizable BAR を有効化する\n- 5 RAM、スワップ、OOM 処理 5.1 クロック周波数とタイミング 5.2 RAM オーバーレイ上に root を置く 5.3 Zram または zswap 5.4 グラフィックカードの RAM を使う 5.5 メモリ不足の状況におけるシステムのレスポンスを改善する\n- 6 ネットワーク\n- 7 ウォッチドッグ 7.1 Systemd ウォッチドッグ 7.1.1 ウォッチドッグを有効化することの利点 7.1.2 Systemd でウォッチドッグを設定する 7.1.3 ハードウェアのウォッチドッグサポートを確認する 7.2 リファレンス\n- 8 参照\n\n- 1.1 システムを知る\n- 1.2 ベンチマーク\n\n- 2.1 セクタサイズ\n- 2.2 パーティショニング 2.2.1 複数のドライブ 2.2.1.1 SSD を HDD のキャッシュとして使う 2.2.2 HDD でのレイアウト\n- 2.3 ファイルシステムの選択とチューニング 2.3.1 マウントオプション\n- 2.4 カーネルパラメータの調整\n- 2.5 I/O スケジューラの設定 2.5.1 背景情報 2.5.2 スケジューリングアルゴリズム 2.5.3 カーネルの I/O スケジューラ 2.5.4 I/O スケジューラの変更 2.5.5 IO スケジューラの調整\n- 2.6 電源管理設定とライトキャッシュ\n- 2.7 ディスクの読み書きを減らす 2.7.1 ディスクの書き込みを表示する 2.7.2 ファイルを tmpfs に再配置する 2.7.3 ファイルシステム 2.7.4 スワップ領域 2.7.5 ライトバックの間隔とバッファサイズ 2.7.6 コアダンプを無効化する\n- 2.8 ionice によるストレージ I/O スケジューリング\n- 2.9 トリム\n\n- 2.2.1 複数のドライブ 2.2.1.1 SSD を HDD のキャッシュとして使う\n- 2.2.2 HDD でのレイアウト\n\n- 2.2.1.1 SSD を HDD のキャッシュとして使う\n\n- 2.3.1 マウントオプション\n\n- 2.5.1 背景情報\n- 2.5.2 スケジューリングアルゴリズム\n- 2.5.3 カーネルの I/O スケジューラ\n- 2.5.4 I/O スケジューラの変更\n- 2.5.5 IO スケジューラの調整\n\n- 2.7.1 ディスクの書き込みを表示する\n- 2.7.2 ファイルを tmpfs に再配置する\n- 2.7.3 ファイルシステム\n- 2.7.4 スワップ領域\n- 2.7.5 ライトバックの間隔とバッファサイズ\n- 2.7.6 コアダンプを無効化する\n\n- 3.1 オーバークロック\n- 3.2 周波数スケーリング\n- 3.3 CPU スケジューラ\n- 3.4 リアルタイムカーネル\n- 3.5 プロセスの優先順位を設定 3.5.1 Ananicy 3.5.2 cgroups 3.5.3 Cpulimit\n- 3.6 irqbalance\n- 3.7 CPU の脆弱性の緩和策をオフにする\n\n- 3.5.1 Ananicy\n- 3.5.2 cgroups\n- 3.5.3 Cpulimit\n\n- 4.1 Xorg の設定\n- 4.2 Mesa の設定\n- 4.3 ハードウェアビデオアクセラレーション\n- 4.4 オーバークロック\n- 4.5 PCIe resizable BAR を有効化する\n\n- 5.1 クロック周波数とタイミング\n- 5.2 RAM オーバーレイ上に root を置く\n- 5.3 Zram または zswap\n- 5.4 グラフィックカードの RAM を使う\n- 5.5 メモリ不足の状況におけるシステムのレスポンスを改善する\n\n- 7.1 Systemd ウォッチドッグ 7.1.1 ウォッチドッグを有効化することの利点 7.1.2 Systemd でウォッチドッグを設定する 7.1.3 ハードウェアのウォッチドッグサポートを確認する\n- 7.2 リファレンス\n\n- 7.1.1 ウォッチドッグを有効化することの利点\n- 7.1.2 Systemd でウォッチドッグを設定する\n- 7.1.3 ハードウェアのウォッチドッグサポートを確認する\n\n"
    },
    {
      "title": "システムを知る",
      "level": 3,
      "content": "システムをチューンするには、全体のスピードを下げているボトルネックやサブシステムに狙いを定めるがベストな方法です。システムの仕様を知ることは、それらを特定することに役立ちます。\n\n- (LibreOffice や Firefox などの) 巨大なアプリケーションを同時に動作させたときにコンピュータが遅くなる場合、RAM の容量が十分であるか確認してください。以下のコマンドを使って、\"available\" 列の値を確認してください: $ free -h\n- 起動時間が長い場合、または、アプリケーションを初めて起動するとき (だけ) にロードに長い時間が掛かる場合、おそらくハードドライブが遅過ぎます。ハードドライブの速度を計測するには hdparm コマンドを使うことができます: # hdparm -t /dev/sdX ノート: hdparm で出力されるのはハードドライブの純粋な読み込み速度なので、有効なベンチマークとは言えませんが、平均的なコンピュータでは (アイドル状態のときに) 40MB/s より高い数値が出るのが妥当です。\n- 十分な RAM が利用できる時でも CPU 負荷が一貫して高い場合、不要なデーモンやプロセスを無効化するなどして CPU 使用量を減らすことを試みてください。htop や pstree などのシステム監視ツールで CPU 負担をモニタすることができます: $ htop\n- ダイレクトレンダリングを使うアプリケーション (つまり、ビデオプレイヤ、ゲーム、ウィンドウマネージャなどの GPU を使うアプリケーション) が遅い場合、GPU パフォーマンスを向上させることで解決するはずです。まず初めにダイレクトレンダリングが有効になっているかどうか確認しましょう。glxinfo コマンドを使うことで確認できます (mesa-utils パッケージに含まれています)。次のコマンドを実行すると direct rendering: Yes と表示される必要があります: $ glxinfo | grep \"direct rendering\"\n- デスクトップ環境を動かしている場合、(不要な) 視覚デスクトップ効果を無効化することで GPU 使用率を削減できる場合があります。現在使用しているものがハードウェアや個人の要件に合わない場合、より軽量な環境を使用するか、カスタムの環境を作成しましょう。\n- 最適化されたカーネルを使用することでパフォーマンスを向上できます。一般に linux-zen が良い選択肢です。しかし、この記事の特定の部分で説明されているように、デフォルトのカーネルを調節することで良いパフォーマンスを得られます。\n\n```\n$ free -h\n```\n\n```\n# hdparm -t /dev/sdX\n```\n\n```\n$ htop\n```\n\n```\n$ glxinfo | grep \"direct rendering\"\n```\n\n"
    },
    {
      "title": "ベンチマーク",
      "level": 3,
      "content": "最適化の効果を判断できないことがたびたびあります。そういった場合はベンチマークツールで計測することができます。\n\n"
    },
    {
      "title": "セクタサイズ",
      "level": 4,
      "content": "NVMe ドライブや Advanced Format ハードディスクが適切な論理セクタサイズを使用していることを確認してください。\n\n"
    },
    {
      "title": "パーティショニング",
      "level": 3,
      "content": "パーティションが適切にアライメントされていることを確認してください。\n\n"
    },
    {
      "title": "複数のドライブ",
      "level": 4,
      "content": "複数のドライブを持っているのであれば、ソフトウェア RAID を組んでパフォーマンスを劇的に向上させることができます。\n\nスワップを別のディスク上に作成することでもパフォーマンスを多少向上させることができます。特に、スワップが頻繁に発生する場合です。\n\nハードディスクから移行することができない場合、ソリッドステートドライブをキャッシュレイヤとして使うことで読み書き速度を向上させ、ランダムアクセスによるパフォーマンスの低下を減らすことができます。方法としては、LVM#キャッシュ、Bcache、Bcachefs#SSD キャッシング があります。\n\n"
    },
    {
      "title": "HDD でのレイアウト",
      "level": 4,
      "content": "従来の回転式 HDD を使用している場合、パーティションのレイアウトがシステムのパフォーマンスに影響を与える可能性があります。ドライブの最初のセクター（ディスクの外周の近く）は最後のセクターよりも高速です。また、パーティションを小さくすれば必要なドライブヘッドの移動が少なくなり、ディスク操作をスピードアップできます。従って、システムのために作るパーティションは小さく (15~20GiB、必要に応じて調節) して、できるだけドライブの最初に配置することが推奨されます。他のデータ（画像・動画など）は別のパーティションに置くべきです。通常、システム (/) から home ディレクトリ (/home) を分割することでこれを達成できます。\n\n"
    },
    {
      "title": "ファイルシステムの選択とチューニング",
      "level": 3,
      "content": "ファイルシステムごとに強みが異なるのでシステムごとにファイルシステムを選ぶことはとても重要です。ファイルシステムの記事に人気のあるファイルシステムの簡単な説明がされています。カテゴリ:ファイルシステムから関連記事も見ることができます。\n\n"
    },
    {
      "title": "マウントオプション",
      "level": 4,
      "content": "様々な *atime オプションが、strictatime のパフォーマンスのペナルティを軽減することができます。\n\n他のマウントオプションはファイルシステム固有なので、ファイルシステムの関連記事を参照してください:\n\n- Ext3\n- Ext4#パフォーマンスの向上\n- JFS#最適化\n- XFS#パフォーマンス\n- Btrfs#デフラグメンテーション、Btrfs#圧縮、btrfs(5)\n- ZFS#チューニング\n- NTFS#パフォーマンスの向上\n\n"
    },
    {
      "title": "カーネルパラメータの調整",
      "level": 3,
      "content": "ブロックデバイスのパフォーマンスに影響するキーが複数存在します、詳しくは sysctl#仮想メモリ を見て下さい。\n\n"
    },
    {
      "title": "背景情報",
      "level": 4,
      "content": "入出力 (I/O) スケジューラはストレージデバイスにブロック I/O の操作を送信するときの順番を決めるカーネルコンポーネントです。I/O スケジューラの目的は読み込みリクエストを最適な方法で扱うことであるため、以下の2つのドライブの特徴を押さえておくことが重要です:\n\n- HDD は回転ディスクでありヘッドが物理的に必要な場所に移動します。そのため、ランダムアクセスは 3〜12ms と非常に遅くなります (ハイエンドサーバーのドライブなのかノートパソコンのドライブなのか、あるいはディスクコントローラの書き込みバッファを迂回するかなどで速度は変わります)。逆に連続アクセスなら高いスループットを得ることが可能です。連続アクセスならヘッドはほとんど動かなくてよいためです。典型的な HDD は毎秒200回ほどの I/O リクエストを処理することができます (IOPS)。\n\n- SSD には物理的に移動する部品がありません。ランダムアクセスはシーケンシャルアクセスと同じ速度が出ます (0.1ms 未満)。SSD は複数のリクエストを一度にこなすこともできます。典型的な SSD のスループットは 10,000 IOPS を超えるため、大抵の場合は必要な仕事量を上回ります。\n\nプロセスを大量に実行してストレージの様々な場所の I/O リクエストを発生させているとき (つまりランダムアクセスをしている状態)、数千の IOPS が生成されますが、普通の HDD では 200 IOPS までしか対応できません。ストレージにアクセスできるまで待機するリクエストの待ち行列が作られることになります。I/O スケジューラはこの待ち行列を最適化します。\n\n"
    },
    {
      "title": "スケジューリングアルゴリズム",
      "level": 4,
      "content": "スループットを改善する方法の一つとして、待機リクエストの順番を論理アドレスで並び替えてできるだけ一番近いリクエストを通すことで、アクセスをリニア化する方法があります。これが elevator スケジューラと呼ばれる Linux の最初の I/O スケジューラでした。\n\nエレベータアルゴリズムの問題点はシーケンシャルアクセスをするプロセスが上手く動かなくなることです。そのようなプロセスは、データブロックを読み取って数マイクロ秒で処理してから次のブロックを読み出します。エレベータスケジューラはプロセスが近くのブロックを呼びだそうとしていることを知らないため、他の場所のリクエストに移ってしまいます。anticipatory IO スケジューラはこの問題を解決します。このスケジューラは、他のリクエストを処理する前に、近くで別の読み取り操作が発生することを予測して、数ミリ秒待機します。\n\n上述のスケジューラはどちらも全体のスループットを改善することを目指していましたが、それによって不幸にも長い間待たされてしまうリクエストも発生していました。例えば、プロセスの多くがストレージ領域の最初の部分をリクエストしていて、不幸なプロセスはストレージの末端付近をリクエストしているような状況を考えて下さい。そのため、開発者は公平なアルゴリズムを作成することを決めて deadline スケジューラが追加されました。deadline スケジューラはアドレスによってキューの順番を決めますが (エレベーターアルゴリズムと同じ)、一定期間、リクエストがキューの中で待機した場合、リクエストを (経過時間によって順番が付けられる) \"expired\" キューに移動します。スケジューラは先に expired キューをチェックして、リクエストを処理してからエレベーターキューに移動します。このアルゴリズムは公平性のために全体のスループットを犠牲にしているわけです。\n\nCompletely Fair Queuing (CFQ) は別のアプローチで問題に取り組みました。CFQ はプロセスの優先度に基づくキューを使ってタイムスライスと許容するリクエストの数を割り当てます。さらに cgroups のサポートを追加することで特定のプロセスグループに一定の IO を予約できるようにしました。これは共有・クラウドサーバーで特に役立ちます。ユーザーはリソースが必要なときに料金を払って IOPS を得られるのです。また、同期 I/O で近くの操作を待機するという anticipatory スケジューラの機能を改良して取り入れています。anticipatory と elevator スケジューラは Linux カーネルから外され、下記のより高度な代替スケジューラに置き換えられました。\n\nBudget Fair Queuing (BFQ) は CFQ のコードをベースにいくつか改善を加えています。各プロセスに固定長のタイムスライスを与えるかわりに、プロセスのセクタ数から計算した \"budget\" を割り当ててヒューリスティックを用います。BFQ は想定的に複雑なスケジューラであるため、オーバーヘッドが大きく、回転ドライブや低速 SSD に適しています。特に遅い CPU と組み合わせたときに高速なデバイスの足を引っ張ってしまうような場合に有用です。BFQ は個人用のシステムでインタラクティブな作業を行うときに、ストレージデバイスがまるで待機状態のときのように素早く反応することを目標としています。デフォルト設定ではスループットの最大化よりもレイテンシの最小化が優先されているのが特徴です。これにより、ハードドライブにおいてアプリケーションの起動を劇的に加速化させられる場合があります。\n\nKyber はネットワークルーティングで用いられている積極的なキュー管理テクニックから生まれた新しいスケジューラです。リクエストを制限するメカニズムとして「トークン」を基に実装されています。 リクエストの割当を受けるにはキューイングトークンを必要とすることで、リクエストのスタベーションを防ぎます。ディスパッチトークンによってデバイスの特定の優先度の操作に制限されます。さらに、ターゲットの読み込みレイテンシを定義して、レイテンシ目標を達成するためにスケジューラ自身がチューニングを行います。アルゴリズムの実装は比較的シンプルなので高速なデバイスでも効率的に機能します。\n\n"
    },
    {
      "title": "カーネルの I/O スケジューラ",
      "level": 4,
      "content": "初期のアルゴリズムには既にメインラインから外されているものもあります。公式の Linux カーネルはいくつかの I/O スケジューラをサポートしています。Multi-Queue Block I/O Queuing Mechanism (blk-mq) は I/O クエリを複数のキューに割り当てて、複数のスレッドおよび CPU コアにタスクを分散させます。このフレームワークでは以下のスケジューラが使えます:\n\n- None、キューイングアルゴリズムは適用されません。\n- mq-deadline は deadline スケジューラ (下記を参照) をマルチスレッドに対応させたスケジューラです。\n- Kyber\n- BFQ\n\n"
    },
    {
      "title": "I/O スケジューラの変更",
      "level": 4,
      "content": "特定のデバイスで利用可能なスケジューラとアクティブなスケジューラを表示するには (アクティブなスケジューラは角括弧の中):\n\n```\n$ cat /sys/block/sda/queue/scheduler\n```\n\n```\nmq-deadline kyber [bfq] none\n```\n\n全デバイスで利用可能なスケジューラを表示するには:\n\n```\n$ grep \"\" /sys/block/*/queue/scheduler\n```\n\n```\n/sys/block/pktcdvd0/queue/scheduler:none\n/sys/block/sda/queue/scheduler:mq-deadline kyber [bfq] none\n/sys/block/sr0/queue/scheduler:[mq-deadline] kyber bfq none\n```\n\nデバイス sda のアクティブな I/O スケジューラを bfq に変更するには:\n\n```\n# echo bfq > /sys/block/sda/queue/scheduler\n```\n\nI/O スケジューラの変更プロセスは、ディスクが回転式か否かに応じて自動化することができ、起動毎に永続化させることができます。例えば、以下の udev ルールは、回転ドライブに対しては bfq を、SSD/eMMC ドライブに対しては bfq を、NVMe に対しては none を設定します:\n\n```\n/etc/udev/rules.d/60-ioschedulers.rules\n```\n\n```\n# HDD\nACTION==\"add|change\", KERNEL==\"sd[a-z]*\", ATTR{queue/rotational}==\"1\", ATTR{queue/scheduler}=\"bfq\"\n\n# SSD\nACTION==\"add|change\", KERNEL==\"sd[a-z]*|mmcblk[0-9]*\", ATTR{queue/rotational}==\"0\", ATTR{queue/scheduler}=\"bfq\"\n\n# NVMe SSD\nACTION==\"add|change\", KERNEL==\"nvme[0-9]*\", ATTR{queue/rotational}==\"0\", ATTR{queue/scheduler}=\"none\"\n```\n\n再起動するか、強制的に新しいルールをロードしてください。\n\n"
    },
    {
      "title": "IO スケジューラの調整",
      "level": 4,
      "content": "カーネルの I/O スケジューラには遅延・期限時間や FIFO パラメータなどそれぞれ設定項目が存在します。特定のデバイスとワークロードの組み合わせにあわせてアルゴリズムを調整することが可能です。スループットを高めたり遅延を少なくしたりするときに用います。 設定項目と説明は カーネルドキュメント で確認できます。\n\n特定のデバイスで設定可能なパラメータを確認するには (以下の例では sdb は deadline を使用しています):\n\n```\n$ ls /sys/block/sdb/queue/iosched\n```\n\n```\nfifo_batch  front_merges  read_expire  write_expire  writes_starved\n```\n\nレイテンシを犠牲に deadline のスループットを高めるには以下のコマンドで fifo_batch を増やします:\n\n```\n# echo 32 > /sys/block/sdb/queue/iosched/fifo_batch\n```\n\n"
    },
    {
      "title": "電源管理設定とライトキャッシュ",
      "level": 3,
      "content": "従来の回転ディスク (HDD) を使用する場合は、省電力機能を完全に無効にするか下げるかし、書き込みキャッシュが有効になっているかどうかを確認すると良いかもしれません。\n\nHdparm#電源管理の設定 と Hdparm#ライトキャッシュ を参照してください。\n\n後で、起動時にこれらを適用する udev ルール を作成することができます。\n\n"
    },
    {
      "title": "ディスクの読み書きを減らす",
      "level": 3,
      "content": "遅いストレージデバイスへの不必要なアクセスを避けることはパフォーマンスを向上にとって良いことであり、デバイスの寿命を伸ばすことにも繋がります。ただし最近のハードウェアでは寿命への影響はわずかです。\n\n"
    },
    {
      "title": "ディスクの書き込みを表示する",
      "level": 4,
      "content": "iotop パッケージはプログラムをディスクの書き込み数でソートして、どれくらいの頻度でどれだけディスクに書き込んでいるか表示します。詳しくは iotop(8) を見てください。\n\n"
    },
    {
      "title": "ファイルを tmpfs に再配置する",
      "level": 4,
      "content": "ブラウザプロファイルなどのファイルを tmpfs ファイルシステムに再配置してメモリ内に保存することで、アプリケーションのレスポンスを向上させることができます:\n\n- ブラウザプロファイルを同期させる方法については Profile-sync-daemon を参照してください。特定のブラウザには注意が必要な場合があります。例えば Firefox Ramdisk を参照してください。\n- 任意の指定されたフォルダを同期させる方法については Anything-sync-daemon を参照してください。\n- tmpfs 内でパッケージをビルドすることでコンパイル時間を減らす方法については Makepkg#ビルド時間を短縮する を参照してください。\n\n"
    },
    {
      "title": "ファイルシステム",
      "level": 4,
      "content": "対応するファイルシステムページを参照して、パフォーマンス改善に関する指示があるか見てください。#ファイルシステムの選択とチューニング に挙げられているファイルシステムのリストも参照してください。\n\n"
    },
    {
      "title": "スワップ領域",
      "level": 4,
      "content": "詳細は スワップ#パフォーマンス を見てください。\n\n"
    },
    {
      "title": "ライトバックの間隔とバッファサイズ",
      "level": 4,
      "content": "詳細は Sysctl#仮想メモリ を見てください。\n\n"
    },
    {
      "title": "コアダンプを無効化する",
      "level": 4,
      "content": "コアダンプ#自動的なコアダンプの無効化 を見てください。\n\n"
    },
    {
      "title": "ionice によるストレージ I/O スケジューリング",
      "level": 3,
      "content": "バックアップなど多くのタスクにおいては、そのタスクを実行するために、ストレージ I/O の遅延が短かったり、ストレージ I/O の帯域が大きかったりする必要はありません。そのようなタスクはバックグラウンドタスクに分類することができます。一方、デスクトップにおいて高速な I/O は UI の応答性を高める上で必須です。ゆえに、他のタスクがストレージ I/O を必要としている間は、バックグラウンドタスクによって利用できるストレージ帯域幅を減らすことが有益です。これは、プロセスごとに異なる優先度を設定できる Linux I/O スケジューラ CFQ を使用することで実現できます。\n\n以下のようにバックグラウンドプロセスを実行することで、プロセスの I/O 優先度 \"Idle\" レベルまで落とすことができます:\n\n```\n# ionice -c 3 command\n```\n\n詳細は a short introduction to ionice や ionice(1) を参照してください。\n\n"
    },
    {
      "title": "トリム",
      "level": 3,
      "content": "最適なパフォーマンスを得るには、SSD の空きブロックを定期的に discard (トリム) してランダム書き込みの速度を最適化するべきです。詳細は ソリッドステートドライブ#TRIM を参照してください。\n\n"
    },
    {
      "title": "オーバークロック",
      "level": 3,
      "content": "オーバークロックは、CPU クロック周波数の上限を上げることにより、CPU の計算パフォーマンスを向上させます。オーバークロックできるかどうかは、CPU モデルとマザーボードモデルの組み合わせに依存します。オーバークロックは BIOS を介して行うのが最も一般的です。オーバークロックには欠点とリスクもあります。ここでは推奨も非推奨もしないでおきましょう。\n\nIntel 製のチップの多くは acpi_cpufreq などや他のほとんどのユーティリティに正しいクロック周波数を伝えません。この結果、dmesg は極端なメッセージを表示します (これは、acpi_cpufreq カーネルモジュールをアンロードしてブラックリスト化することで回避可能です)。クロック速度を読むには、i7z パッケージの i7z を使用してください。オーバークロックされた CPU が正しく動作していることを確認する方法として、ストレステストが推奨されます。\n\n"
    },
    {
      "title": "周波数スケーリング",
      "level": 3,
      "content": "CPU 周波数スケーリングを見てください。\n\n"
    },
    {
      "title": "CPU スケジューラ",
      "level": 3,
      "content": "メインライン Linux カーネルのデフォルトの CPU スケジューラは EEVDF です。\n\n- MuQSS — Multiple Queue Skiplist Scheduler。Con Kolivas によって開発されている -ck パッチセットにより利用可能。\n\n- Project C — BMQ を Project C にリファクタリングするためのクロスプロジェクト。Project C コードベースに基づいて PSD を再作成します。よって、これは2つのプロジェクトのマージであり、その後 PDS が Project C として更新されます。より最近の開発として推奨されます。\n\n- BORE — BORE スケジューラは、対話型タスクにおいてある程度の公平性を犠牲にして低レイテンシを実現することに焦点を当てています。CFS の上に構築されており、vruntime コード更新だけに調整されています。なので、他の非公式 CPU スケジューラと比較して、全体的な変更は非常に小さいです。\n\n"
    },
    {
      "title": "リアルタイムカーネル",
      "level": 3,
      "content": "(TV チューナーカードをフル HD 解像度 (1080p) で実行するなど) 一部の使用用途では、リアルタイムカーネルを使うと利益を得られる場合があります。\n\n"
    },
    {
      "title": "プロセスの優先順位を設定",
      "level": 3,
      "content": "nice(1) と renice(1) も参照してください。\n\n"
    },
    {
      "title": "Ananicy",
      "level": 4,
      "content": "Ananicy CPP は動的に実行可能ファイルの nice レベルを調整するためのデーモンで、ananicy-cpp や ananicy-cpp-gitAUR パッケージで利用可能です。nice レベルとは、CPU リソースを配分するときの実行可能ファイルの優先度を表すものです。\n\n"
    },
    {
      "title": "cgroups",
      "level": 4,
      "content": "cgroups を見てください。\n\n"
    },
    {
      "title": "Cpulimit",
      "level": 4,
      "content": "Cpulimit は特定のプロセスの CPU 使用率を制限するプログラムです。cpulimitAUR をインストールすれば、プロセスの PID で CPU 使用率を 0 から 100 までの値にコンピュータに搭載されている CPU コア数をかけた数字の範囲で制限することができます。例えば、CPU コアが8個であれば利用可能な値は 0 から 800 です。使用例:\n\n```\n$ cpulimit -l 50 -p 5081\n```\n\n"
    },
    {
      "title": "irqbalance",
      "level": 3,
      "content": "irqbalance はマルチプロセッサシステムでパフォーマンスを向上させるためにプロセッサ間でハードウェア割り込みを分散させます。irqbalance.service で操作することが可能です。\n\n"
    },
    {
      "title": "CPU の脆弱性の緩和策をオフにする",
      "level": 3,
      "content": "CPU の脆弱性の緩和策をオフにすることで、パフォーマンスが向上する場合があります。以下のカーネルパラメータですべての緩和策が無効になります:\n\n```\nmitigations=off\n```\n\nこのパラメータによって切り替えられるすべてのスイッチについての説明は、kernel.org で見られます。spectre-meltdown-checkerAUR や lscpu(1) (util-linux に同梱) を使うことで、脆弱性チェックを行うことができます。\n\n"
    },
    {
      "title": "Xorg の設定",
      "level": 3,
      "content": "グラフィックパフォーマンスは xorg.conf(5) の設定に依存している場合があります。NVIDIA、AMDGPU、Intel の記事を参照してください。不適切な設定は Xorg が動作しなくなる原因になるため、注意しましょう。\n\n"
    },
    {
      "title": "Mesa の設定",
      "level": 3,
      "content": "Mesa ドライバのパフォーマンスは drirc で設定できます。adriconf (Advanced DRI Configurator) はオプションを設定して標準の drirc ファイルに書き込むことで MESA ドライバを設定する GUI ツールです。\n\n"
    },
    {
      "title": "ハードウェアビデオアクセラレーション",
      "level": 3,
      "content": "ハードウェアビデオアクセラレーションにより、ビデオカードに動画のデコード/エンコードをさせることができます。\n\n"
    },
    {
      "title": "オーバークロック",
      "level": 3,
      "content": "CPU と同様に、(GPU の) オーバークロックは直接的にパフォーマンスを向上できますが、一般には推奨されません。いくつかのパッケージがあります: rovclockAUR (ATI カード)、rocm-smi-lib (最近の AMD カード)、nvclockAUR (古い NVIDIA カード - Geforce 9 まで)、nvidia-utils (最近の NVIDIA カード)。\n\nAMDGPU#オーバークロック や NVIDIA/ヒントとテクニック#オーバークロックを有効化する を参照してください。\n\n"
    },
    {
      "title": "PCIe resizable BAR を有効化する",
      "level": 3,
      "content": "- 一部のシステムでは、PCIe resizable BAR を有効化するとパフォーマンスが大幅に劣化する可能性があります。システムのベンチマークを行って、PCI resizable BAR がパフォーマンスを向上させていることを確認してください。\n- 効果を発揮させるには、Compatibility Support Module (CSM) を無効化しなければなりません。\n\nPCI の仕様では、PCI デバイスのメモリを PCI コントローラに公開するために、より大きい基底アドレスレジスタ (BAR) を使用できます。そうすることで、ビデオカードのパフォーマンスを向上できる可能性があります。ビデオメモリ全体にアクセスすることでパフォーマンスを向上できますし、グラフィックドライバの最適化も可能になります。Resizable BAR、above 4G decoding、そしてドライバ最適化の組み合わせを、AMD は AMD Smart Access Memory と呼んでおり、初期は AMD Series 500 チップセットマザーボードで利用できましたが、後に UEFI アップデートを通して AMD Series 400 と Intel Series 300 以降に拡張されました。この設定はすべてのマザーボードで利用できるわけではなく、特定のボードではブート問題を引き起こすことが知られています。\n\nBAR のサイズが 256M の場合、この機能は有効化されていないか、サポートされていません:\n\n```\n# dmesg | grep BAR=\n```\n\n```\n[drm] Detected VRAM RAM=8176M, BAR=256M\n```\n\n有効化するには、マザーボード設定で \"Above 4G Decode\" か \">4GB MMIO\" という名前の設定を有効化してください。BAR が大きくなっていることを確認するには:\n\n```\n# dmesg | grep BAR=\n```\n\n```\n[drm] Detected VRAM RAM=8176M, BAR=8192M\n```\n\n"
    },
    {
      "title": "クロック周波数とタイミング",
      "level": 3,
      "content": "RAM は BIOS で設定することで、クロック周波数とタイミングを別々にすることができます。メモリのパフォーマンスは両方の値によって変わります。BIOS に用意されている最高速のプリセットを選択することでデフォルト設定よりも性能を上げることができます。マザーボードやメモリのメーカーがサポートしていない周波数まで値を高めると、CPU のオーバークロックと同じようなリスクがあるので注意してください。#オーバークロックを参照。\n\n"
    },
    {
      "title": "RAM オーバーレイ上に root を置く",
      "level": 3,
      "content": "Table content:\nこの記事またはセクションは情報が古くなっています。 理由: liveroot スクリプトはメンテナンスされていないようです。しかし、このアプローチは依然として機能するはずです。 (Discuss)\n\n書き込みが遅いメディア (USB や 回転 HDD) を使う場合、(ディスク上の) 読み取り専用の root の上で RAM オーバーレイを作って root を動作させることができます。root に書き込みできる領域が制限されるかわりにパフォーマンスが劇的に改善します。liverootAUR を見て下さい。\n\n"
    },
    {
      "title": "Zram または zswap",
      "level": 3,
      "content": "zswap や zram を使うことで、同様の利点を (同様のコストで) 得られます。これら2つは一般に意図が似ていますが、動作が異なります。zswap は、圧縮 RAM キャッシュとして機能し、高コストなユーザ空間の設定を要求しません (そして、許可もしません)。zram は、RAM 内に圧縮ブロックデバイスを作成するために使用できるカーネルモジュールです。zswap はスワップデバイスと組み合わさって機能するのに対し、zram は補助スワップデバイスを必要としません。\n\n"
    },
    {
      "title": "グラフィックカードの RAM を使う",
      "level": 3,
      "content": "稀なケースとして、RAM 容量が非常に小さいが、ビデオ RAM に余りがある場合、後者をスワップとして使用できます。ビデオメモリにスワップ を参照してください。\n\n"
    },
    {
      "title": "メモリ不足の状況におけるシステムのレスポンスを改善する",
      "level": 3,
      "content": "従来の GNU/Linux システム (特にグラフィカルワークステーション) では、割り当てられたメモリがオーバーコミットすると、カーネル内の OOM killer がトリガーされるか、十分な量のメモリが開放される (システムが応答しない場合、メモリを大量消費するアプリケーションを閉じることは難しいため、これはすぐには起こり得ないでしょう) まで、システム全体のレスポンスがほぼ使用不能な状態まで低下します。挙動は特定の環境や条件に依存しており、通常のレスポンス状態に戻るまでには数秒から30分以上かかる場合があります。会議でのプレゼンテーションなどのような重要な状況においては、待つのが苦痛になるでしょう。\n\nカーネルとFedora のメーリングリストで議論されている通り、メモリ不足の状況におけるカーネルとユーザ空間の挙動は将来的に改善されるかもしれませんが、ユーザは、システムのハードリセットや vm.overcommit_* sysctl パラメータの調整よりも実行可能で効果的なオプションを使うことができます:\n\n- Magic SysRq キー (Alt+SysRq+f) で手動でカーネルの OOM killer をトリガーする。\n- ユーザ空間の OOM デーモンを使ってこれに自動的 (または対話的) に対処する。\n\nカーネルの OOM killer では終了する (しない) プロセスに優先順位を付けられないので、SysRq よりも OOM デーモンのほうが好ましい場合もあります。いくつかの OOM デーモンをリストアップしました:\n\n- systemd-oomd — systemd によって systemd-oomd.service として提供されています。cgroups-v2 と pressure stall information (PSI) を使用してプロセスを監視し、カーネル空間で OOM が発生する前にアクションを取ります。\n\n- earlyoom — C で書かれた、シンプルなユーザ空間の OOM killer 実装です。\n\n- oomd — PSI ベースの OOM killer 実装です。Linux カーネルバージョン 4.20+ を必要とします。設定は JSON で行い、非常に複雑です。Facebook の本番環境において動作確認済み。\n\n- nohang — Python で書かれた、洗練された OOM ハンドラ。オプションで PSI サポートあり。earlyoom よりも設定可能です。\n\n- low-memory-monitor — GNOME 開発者の取り組み。ユーザ空間のアプリケーションにメモリ不足の状態を伝えるためのより良いコミュニケーションを提供することを目的としており、さらにカーネルの OOM killer をトリガーするように設定することができます。PSI ベースで、Linux 5.2+ を必要とします。\n\n- uresourced — アクティブなグラフィカルユーザセッションに対して、cgroup ベースのリソース保護を有効化する小さなデーモン。\n\n"
    },
    {
      "title": "ネットワーク",
      "level": 2,
      "content": "- カーネルネットワーキング: Sysctl#パフォーマンスを向上させる を参照\n- NIC: ネットワーク設定#MTU とキューの長さの設定 を参照\n- DNS: キャッシュ付きの DNS リゾルバの使用を検討してください。ドメイン名前解決#DNS サーバ を参照\n- Samba: Samba#スループットを向上させる を参照\n\n"
    },
    {
      "title": "ウォッチドッグ",
      "level": 2,
      "content": "Wikipedia:Watchdog timer (日本語版) より:\n\n"
    },
    {
      "title": "Systemd ウォッチドッグ",
      "level": 3,
      "content": "Systemd にはウォッチドッグのリセット機構が内蔵されています。これは、適切なカーネルモジュールがロードされている場合に (以下を参照)、/dev/watchdog として公開されているハードウェアウォッチドッグと対話します。システムが応答しなくなった場合、ハードウェアウォッチドッグがシステムリセットをトリガーします。\n\n"
    },
    {
      "title": "ウォッチドッグを有効化することの利点",
      "level": 4,
      "content": "- シャットダウンの無限遅延を防止 ウォッチドッグが無いと、特定のサービスがシャットダウン中に無限にハングしてしまった場合に、シャットダウンが長く遅延してしまいます。 適切にウォッチドッグを設定すれば、systemd は事前に定義されたタイムアウト内にリセットを強制します。これにより、シャットダウンを早くできます。\n\n- ウォッチドッグが無いと、特定のサービスがシャットダウン中に無限にハングしてしまった場合に、シャットダウンが長く遅延してしまいます。\n- 適切にウォッチドッグを設定すれば、systemd は事前に定義されたタイムアウト内にリセットを強制します。これにより、シャットダウンを早くできます。\n\n- 深刻なサービスのフリーズを防止 重要なシステムサービス (ネットワーク、ファイルシステム、ACPI など) が応答しなくなった場合、ウォッチドッグはそれを検出し、即座に再起動をトリガーします。 これにより、永遠にフリーズしたままになってしまうようなサービスによって起動速度が遅くなってしまうことを防止します。\n\n- 重要なシステムサービス (ネットワーク、ファイルシステム、ACPI など) が応答しなくなった場合、ウォッチドッグはそれを検出し、即座に再起動をトリガーします。\n- これにより、永遠にフリーズしたままになってしまうようなサービスによって起動速度が遅くなってしまうことを防止します。\n\n- カーネルの回復を最適化 RuntimeWatchdogSec という閾値を超えてカーネルが応答しなかった場合、ウォッチドッグは自動的に再起動をトリガーすることで、システムのロックアップを防止します。 これにより、ランダムなブート時のフリーズを防止することに役立ち、システムの安定性を保ちます。\n\n- RuntimeWatchdogSec という閾値を超えてカーネルが応答しなかった場合、ウォッチドッグは自動的に再起動をトリガーすることで、システムのロックアップを防止します。\n- これにより、ランダムなブート時のフリーズを防止することに役立ち、システムの安定性を保ちます。\n\n- リソース管理を強化 リソースを大量に消費するプロセスがシステムのフリーズを引き起こした場合、ウォッチドッグは、システムが完全に応答しなくなる前に、再起動を強制します。 これにより、システムの応答性が保たれ、CPU/RAM 使用率が高くなる状況でパフォーマンスを維持することに役立ちます。\n\n- リソースを大量に消費するプロセスがシステムのフリーズを引き起こした場合、ウォッチドッグは、システムが完全に応答しなくなる前に、再起動を強制します。\n- これにより、システムの応答性が保たれ、CPU/RAM 使用率が高くなる状況でパフォーマンスを維持することに役立ちます。\n\n"
    },
    {
      "title": "Systemd でウォッチドッグを設定する",
      "level": 4,
      "content": "デフォルトでは、RuntimeWatchdogSec は無効化されています。システムのウォッチドッグを有効化するには、以下のような systemd-system.conf(5) ドロップインファイルを作成してください:\n\n```\n/etc/systemd/system.conf.d/watchdog.conf\n```\n\n```\n[Manager]\nRuntimeWatchdogSec=10s\nRebootWatchdogSec=45s\n```\n\n- RuntimeWatchdogSec=10s: systemd が 10 秒より長く応答しなかった場合、システムを再起動します。\n- RebootWatchdogSec=45s: システムが再起動中にハングした場合、ウォッチドッグは 45 秒後にリセットを強制します。\n\n以下のコマンドで適用します:\n\n```\n# systemctl daemon-reexec\n```\n\nウォッチドッグがアクティブであることを確認してください:\n\n```\n$ systemctl show | grep Watchdog\n```\n\n```\nRuntimeWatchdogUSec=10000000\nRebootWatchdogUSec=45000000\n```\n\n"
    },
    {
      "title": "ハードウェアのウォッチドッグサポートを確認する",
      "level": 4,
      "content": "多くのシステムで、ハードウェアウォッチドッグのサポートは異なるカーネルモジュール (例: 一部の Intel チップセットでは iTCO_wdt、特定の AMD プラットフォームでは sp5100_tco) によって提供されている場合があります。ハードウェアウォッチドッグのモジュールを確認するには、以下を実行してください:\n\n```\n$ lsmod | grep wdt\n```\n\n関連するウォッチドッグモジュール (例: iTCO_wdt、sp5100_tco) を見つけたら、以下のようなファイルを作成してモジュールがブート時にロードされるようにしてください:\n\n```\n/etc/modules-load.d/watchdog.conf\n```\n\n```\nmodule_name\n```\n\n```\n# modprobe module_name\n```\n\nmodule_name の部分は、あなたのハードウェアにおける実際のモジュール名に置き換えてください。\n\n"
    },
    {
      "title": "リファレンス",
      "level": 3,
      "content": "- systemd-system.conf(5)\n- Linux カーネルウォッチドッグのドキュメント\n- Arch Wiki – Systemd Boot\n- Lennart Poettering による systemd ウォッチドッグに関するブログ記事\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- Red Hat Performance Tuning Guide\n- Linux Performance Measurements using vmstat\n\n"
    }
  ]
}