{
  "title": "Syslog-ng (日本語)",
  "url": "https://wiki.archlinux.org/title/Syslog-ng_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- rsyslog\n\nsyslog-ng は、強力なフィルターディレクティブに基づいて、ソースからログメッセージを取得し、宛先に転送できる syslog 実装です。その起源は syslog ですが、これは非常に汎用的なログ管理ツールであり、構造化および非構造化ログメッセージを使用し、必要に応じて解析および変換することができます。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 概要\n- 2 インストール 2.1 systemd/ジャーナルとの統合\n- 3 Source 3.1 syslog-ng と systemd journal\n- 4 Destination\n- 5 メッセージのフィルターを作成\n- 6 ログのパス\n- 7 ヒントとテクニック‎ 7.1 syslog-ng に設定ファイルをリロードさせる 7.2 ログ出力をリモートホストにフェイルオーバー 7.3 ログを別のファイルに移動 7.4 loghost として設定 7.5 パフォーマンスの向上 7.5.1 ときどき書き込ませる 7.5.2 ソースのバッチ処理制限を増やす 7.5.3 処理やディスク領域の重複を避ける 7.6 PostgreSQL の宛先 7.7 ISO 8601 タイムスタンプ 7.8 RFC 3339 タイムスタンプ 7.9 ログレベル 7.10 マクロと変数 7.11 一般的な syslog メッセージを受信して​​解析する 7.12 関連項目\n- 8 外部リンク\n\n- 2.1 systemd/ジャーナルとの統合\n\n- 3.1 syslog-ng と systemd journal\n\n- 7.1 syslog-ng に設定ファイルをリロードさせる\n- 7.2 ログ出力をリモートホストにフェイルオーバー\n- 7.3 ログを別のファイルに移動\n- 7.4 loghost として設定\n- 7.5 パフォーマンスの向上 7.5.1 ときどき書き込ませる 7.5.2 ソースのバッチ処理制限を増やす 7.5.3 処理やディスク領域の重複を避ける\n- 7.6 PostgreSQL の宛先\n- 7.7 ISO 8601 タイムスタンプ\n- 7.8 RFC 3339 タイムスタンプ\n- 7.9 ログレベル\n- 7.10 マクロと変数\n- 7.11 一般的な syslog メッセージを受信して​​解析する\n- 7.12 関連項目\n\n- 7.5.1 ときどき書き込ませる\n- 7.5.2 ソースのバッチ処理制限を増やす\n- 7.5.3 処理やディスク領域の重複を避ける\n\n"
    },
    {
      "title": "概要",
      "level": 2,
      "content": "syslog-ng は定義済みの 'source' からのメッセージを受け取って、強力な filter ディレクティブに基づいて、適当な destination に転送します。標準的なシンプルな設定だと、syslog-ng は3つの source からメッセージを読み取ります:\n\n1. デフォルトの /dev/log デバイス (ほとんどのログはここに送られます)\n1. syslog-ng の\"内部的な\"ログメッセージ\n1. /proc/kmsg カーネルメッセージ\n\n受信元は \"source\" ディレクティブを使って定義します。受信されたメッセージは次に定義済みのフィルター (\"filter\" キーワード) によってフィルタリングされ、送信元のプログラムやログレベルにあわせて、適当な \"destination\" に送信されます。送信先としてはログファイル (例: /var/log/messages.log) や、コンソールやリモートサーバーにメッセージを表示するなどが考えられます。中心的な関数は log です。この関数は特定の source に対してどのフィルターを適用し、作成されたメッセージをどこに送信すればいいのか定義します。\n\nsyslog-ng.service サービスファイルを使って syslog-ng を有効化します。systemd 216 から、メッセージはデフォルトでは syslog に転送されなくなりました。syslog-ng 3.6 のリリースまで Syslog-ng は journald に対応していませんでした。systemd 216 以上で syslog-ng を使用するには /etc/systemd/journald.conf を編集して ForwardToSyslog=yes オプションを設定する必要があったのです。\n\n最新の syslog-ng を使っている場合は、オプションを変更する必要はありません。syslog-ng が journal からメッセージを引っ張ってきてくれます。ForwardToSyslog=yes と設定していた場合は ForwardToSyslog=no に戻してください。ソケットの関連付けによるオーバーヘッドと ログに無駄なエラーメッセージが残る のを防ぐためです。一方で、ログを二度保存したくなく journald を Storage=none にする場合、ForwardToSyslog=yes を設定する必要があります。これによって syslog-ng は 'journald' の journal ファイルに従うようになります。\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "syslog-ng パッケージを インストール してください。syslog-ng を使用開始するには、syslog-ng@default.service を 起動・有効化 してください。\n\n"
    },
    {
      "title": "systemd/ジャーナルとの統合",
      "level": 3,
      "content": "syslog-ng は、デフォルトで systemd ジャーナルからメッセージを取得します。ソケットに関連するオーバーヘッドを回避し、ログに不要なエラーメッセージが記録されるために、/etc/systemd/journald.conf で ForwardToSyslog=no を維持することをお勧めします。一方、ログを 2 回保存したくない場合、journald の Storage=none を設定する場合は、syslog-ng が journald ジャーナルファイルをたどろうとするため、ForwardToSyslog=yes が必要になります。\n\n詳細については、syslog-ng#syslog-ng と systemd journal を参照してください。\n\n"
    },
    {
      "title": "Source",
      "level": 2,
      "content": "syslog-ng は source からログメッセージを受信します。source を定義するときは以下の構文に従う必要があります:\n\n```\nsource <identifier> { source-driver(params); source-driver(params); ... };\n```\n\nidentifier と source-driver については 公式マニュアル で読むことができます。マニュアルにしたがって上記の設定ファイルを説明します。unix-stream() source-driver は指定された AF_UNIX ソケットを開いてメッセージが来るのを待ちます。internal() source-driver は syslog-ng によって生成されたメッセージを取得します。\n\nしたがって、以下の設定の意味は: src は /dev/log ソケットと syslog-ng からのメッセージを取得する、となります。\n\n```\nsource src { unix-stream(\"/dev/log\"); internal(); };\n```\n\nカーネルはログメッセージを /proc/kmsg に送信して file() ドライバーはファイルからログメッセージを読み取ります。したがって、以下の設定の意味は: kernsrc は /proc/kmsg ファイルからメッセージを取得する、となります。\n\n```\nsource kernsrc { file(\"/proc/kmsg\"); };\n```\n\nデフォルト設定では syslog-ng の後に、以下のように source が定義されています:\n\n```\nsource src { unix-stream(\"/dev/log\"); internal(); pipe(\"/proc/kmsg\"); };\n```\n\npipe(\"/proc/kmsg\") によってメッセージを読み込むことでパフォーマンスには良い影響がありますが、読み書きモードで開くのでセキュリティ上問題になります。このことは syslog-ng admin guide のセクション 3.3.3 で触れられています:\n\n\"パイプは file() ドライバーとよく似ていますが、多少の違いがあり、例えば pipe() は読み書きモードで開くので、/proc/kmsg などの特殊なファイルで使用するのは推奨されません\" (この議論については ここの投稿 で読むことができます)。\n\nリモートサーバーからデータを読み取るためにポートを開けるには、以下の構文の source を定義します。UDP の場合:\n\n```\nsource s_net { udp(); };\n```\n\nもしくは TCP によってログメッセージを受信するには:\n\n```\nsource s_net { tcp(); };\n```\n\nどちらも514番ポートを listen します。\n\n"
    },
    {
      "title": "syslog-ng と systemd journal",
      "level": 3,
      "content": "syslog-ng バージョン 3.6.1 から systemd を使用する Linux 環境ではデフォルトの system() で journald が使われます。\n\njournald と syslog-ng 両方のファイルを使用したい場合、次のように設定を行って下さい。systemd-journald 側は、/etc/systemd/journald.conf ファイルで、Storage= を auto に設定するかオプションの設定を削除してください (デフォルトで auto に設定されます)。また、ForwardToSyslog= を no に設定するか設定を削除してください (デフォルトで no に設定されます)。/etc/syslog-ng/syslog-ng.conf で、以下の source を使って下さい:\n\n```\nsource src {\n  system();\n  internal();\n};\n```\n\nまた、syslog-ng のテキストログは維持しつつ journald のログを残したくない場合、/etc/systemd/journald.conf で Storage=volatile と ForwardToSyslog=yes を設定してください。この設定を行うと journald はメモリに保存されます。syslog-ng 3.6.3 現在、syslog-ng は journald を system(); ソースとして使用するため Storage=none と設定してしまうと、systemd ジャーナルは全てのメッセージを消去してしまい syslog-ng にメッセージが転送されません。\n\n変更を行った後は systemd-journald.service と syslog-ng.service デーモンを再起動してください。\n\n"
    },
    {
      "title": "Destination",
      "level": 2,
      "content": "syslog-ng では、ログメッセージはファイルに送信されます。構文は source とよく似ています:\n\n```\ndestination <identifier> {destination-driver(params); destination-driver(params); ... };\n```\n\n通常はファイルにログを出力することになりますが、他にも様々な destination-driver にログを書き出すことが可能です: パイプ, Unix ソケット, TCP-UDP ポート, ターミナルまたは特定のプログラムなど。したがって、以下の設定は authlog メッセージを /var/log/auth.log に送信します:\n\n```\ndestination authlog { file(\"/var/log/auth.log\"); };\n```\n\n(ユーザーがログインしているとき) usertty() は指定されたユーザーのターミナルにメッセージを送信します。root のターミナルにコンソールメッセージを送りたい場合:\n\n```\ndestination console { usertty(\"root\"); };\n```\n\npipe() を使えばメッセージをパイプに送信することができます。以下の設定は xconsole メッセージを /dev/xconsole パイプに送信します。\n\n```\ndestination xconsole { pipe(\"/dev/xconsole\"); };\n```\n\nネットワーク上にメッセージを送信するには、udp() を使います。以下の destination はログデータを別のサーバーに送信します。\n\n```\ndestination remote_server { udp(\"10.0.0.2\" port(514)); };\n```\n\n"
    },
    {
      "title": "メッセージのフィルターを作成",
      "level": 2,
      "content": "filter ステートメントの構文は:\n\n```\nfilter <identifier> { expression; };\n```\n\nexpression には関数を使うことができます。例えばファシリティコードによってメッセージを選り分ける facility() 関数などです。Linux カーネルには少数ながらログに使うことができる facility がいくつかあります。それぞれの facility にはログレベルが存在します。debug は最も情報量が多く、panic は深刻なエラーのみを表示します。facility, ログレベル, プライオリティの名前は /usr/include/sys/syslog.h で確かめることができます。May 11 23:42:31 mimosinnet su(pam_unix)[18569]: session opened for user root by (uid=1000) のような authorization からのメッセージを取り出すには、以下を使います:\n\n```\nfilter f_auth { facility(auth); };\n```\n\nfacility には論理演算子 and, or, not を使うことが可能です。例えば以下のフィルターは authorization, network news, mail からではないメッセージを選択します:\n\n```\nfilter f_debug { not facility(auth, authpriv, news, mail); };\n```\n\nlevel() 関数はプライオリティレベルによってメッセージを選択します。informational レベルを選択したい場合は:\n\n```\nfilter f_info { level(info); };\n```\n\n関数と論理演算子は組み合わせて複雑な条件を作成することができます。以下のフィルターはプライオリティレベルが informational から warning の間で facility が auth, authpriv, mail, news ではないメッセージを抜き出します:\n\n```\nfilter f_messages { level(info..warn) and not facility(auth, authpriv, mail, news); };\n```\n\nmatch(\"regex\" value(\"TEMPLATE\")) 関数を使って正規表現にメッセージをマッチさせて選択することも可能です。例えば:\n\n```\nfilter f_failed { match(\"failed\" value(\"MESSAGE\")); };\n```\n\n以下はテンプレートのリストです:\n\n```\n\"AMPM\", \"BSDTAG\", \"DATE, C_DATE, R_DATE, S_DATE\", \"DAY, C_DAY, R_DAY, S_DAY\", \"FACILITY\", \"FACILITY_NUM\", \"FULLDATE, C_FULLDATE, R_FULLDATE, S_FULLDATE\", \"FULLHOST\", \"FULLHOST_FROM\", \"HOUR, C_HOUR, R_HOUR, S_HOUR\", \"HOUR12, C_HOUR12, R_HOUR12, S_HOUR12\", \"HOST\", \"HOST_FROM\", \"ISODATE, C_ISODATE, R_ISODATE, S_ISODATE\", \"LEVEL_NUM\", \"LOGHOST\", \"MIN, C_MIN, R_MIN, S_MIN\", \"MONTH, C_MONTH, R_MONTH, S_MONTH\", \"MONTH_ABBREV, C_MONTH_ABBREV, R_MONTH_ABBREV, S_MONTH_ABBREV\", \"MONTH_NAME, C_MONTH_NAME, R_MONTH_NAME, S_MONTH_NAME\", \"MONTH_WEEK, C_MONTH_WEEK, R_MONTH_WEEK, S_MONTH_WEEK\", \"MSEC, C_MSEC, R_MSEC, S_MSEC\", \"MSG or MESSAGE\", \"MSGHDR\", \"MSGID\", \"MSGONLY\", \"PID\", \"PRI\", \"PRIORITY or LEVEL\", \"PROGRAM\", \"SDATA, .SDATA.SDID.SDNAME\", \"SEC, C_SEC, R_SEC, S_SEC\", \"SOURCEIP\", \"SEQNUM\", \"STAMP, R_STAMP, S_STAMP\", \"SYSUPTIME\", \"TAG\", \"TAGS\", \"TZ, C_TZ, R_TZ, S_TZ\", \"TZOFFSET, C_TZOFFSET, R_TZOFFSET, S_TZOFFSET\", \"UNIXTIME, C_UNIXTIME, R_UNIXTIME, S_UNIXTIME\", \"USEC, C_USEC, R_USEC, S_USEC\", \"YEAR, C_YEAR, R_YEAR, S_YEAR\", \"WEEK, C_WEEK, R_WEEK, S_WEEK\", \"WEEK_ABBREV, C_WEEK_ABBREV, R_WEEK_ABBREV, S_WEEK_ABBREV\", \"WEEK_DAY, C_WEEK_DAY, R_WEEK_DAY, S_WEEK_DAY\", \"WEEKDAY, C_WEEKDAY, R_WEEKDAY, S_WEEKDAY\", \"WEEK_DAY_NAME, C_WEEK_DAY_NAME, R_WEEK_DAY_NAME, S_WEEK_DAY_NAME\".\n```\n\n特定のリモートホストから受信したメッセージをフィルタリングする場合は、host() 関数を使って下さい:\n\n```\nfilter f_host { host( \"192.168.1.1\" ); };\n```\n\n"
    },
    {
      "title": "ログのパス",
      "level": 2,
      "content": "syslog-ng は source, filter, destination を log ステートメントで接続します。構文は:\n\n```\nlog {source(s1); source(s2); ...\nfilter(f1); filter(f2); ...\ndestination(d1); destination(d2); ...\nflags(flag1[, flag2...]); };\n```\n\n以下は src source からのメッセージを f_info filter でフィルターにかけて mailinfo destination に送信する例です:\n\n```\nlog { source(src); filter(f_mail); filter(f_info); destination(mailinfo); };\n```\n\n"
    },
    {
      "title": "ヒントとテクニック‎",
      "level": 2,
      "content": "syslog-ng の背後にあるロジックを理解したら、様々な設定、複雑な設定をすることが可能になります。以下はほんの一例です。\n\n"
    },
    {
      "title": "syslog-ng に設定ファイルをリロードさせる",
      "level": 3,
      "content": "syslog-ng に設定ファイルを再評価させることが可能です。プロセスに SIGHUP を手動で送信するか、systemctl の reload 関数を呼び出して下さい:\n\n```\n# systemctl reload syslog-ng\n```\n\n"
    },
    {
      "title": "ログ出力をリモートホストにフェイルオーバー",
      "level": 3,
      "content": "以下の設定は標準ポート (514) と代替ポートを使って、TCP と UDP プロトコル両方でデフォルトの暗号化されていない syslog パケットを送信します。同一の出力を同一のマシンに4回試行して、確実にパケットを送信します。再起動できないリモートサーバーをデバッグするときに特に便利です。様々なポートとプロトコルを使うことで、ファイアウォールフィルターなどのネットワークの問題を通過できるようにしています。また、ポートフォワーディングやトンネルを使う場合にも有用です。このような設定は、逆接続で開始される ssh 接続のトンネルにうってつけでしょう。\n\n```\n#sending to a remote syslog server on TCP and UDP ports (not encrypted)\ndestination askapache_failover_loghost {\n    tcp(\"208.86.158.195\" port(25214));\n    udp(\"208.86.158.195\" port(25214));\n    udp(\"mysyslog1.dyndns.org\" port(514));\n};\nlog { \n    source(src); \n    destination(askapache_failover_loghost);\n};\n```\n\nそして loghost 側ではログを受信します:\n\n```\n#a USB redirected console for flexible viewing\ndestination debugging_console {\n    file(\"/dev/ttyU1\");\n};\n\n# listens on IP addresses and ports, sets the incoming settings\nsource prone_to_failover_host {\n    tcp(ip(208.86.158.195),port(25214));\n    udp(ip(208.86.158.195) port(25214));\n\n    udp(default-facility(syslog) default-priority(emerg));\n    tcp(default-facility(syslog) default-priority(emerg));\n}\n\n# log it\nlog {\n    source(prone_to_failover_host); \n    destination(debugging_console);\n};\n```\n\n"
    },
    {
      "title": "ログを別のファイルに移動",
      "level": 3,
      "content": "ログを /var/log/messages から他のファイルに移動するには:\n\n```\n#sshd configuration\ndestination ssh { file(\"/var/log/ssh.log\"); };\nfilter f_ssh { program(\"sshd\"); };\nlog { source(src); filter(f_ssh); destination(ssh); };\n```\n\n"
    },
    {
      "title": "loghost として設定",
      "level": 3,
      "content": "システムを loghost として設定することはとても簡単です。設定に以下のように記述を行い、必要なディレクトリを作成してください。このシンプルな設定では、ログのファイル名はリモートホストの FQDN に基づいて名付けられ、/var/log/remote/ にファイルが配置されます。remote ディレクトリを作成した後、syslog-ng の設定をリロードしてください。\n\n```\nsource net { udp(); };\ndestination remote { file(\"/var/log/remote/${FULLHOST}-log\"); };\nlog { source(net); destination(remote); };\n```\n\n"
    },
    {
      "title": "パフォーマンスの向上",
      "level": 3,
      "content": "いくつかの方法を使って syslog-ng のパフォーマンスを上げることができます:\n\n"
    },
    {
      "title": "ときどき書き込ませる",
      "level": 4,
      "content": "旧 sync(X) オプションは現在 flush_lines(X) と呼ばれるようになっており、これによってファイルへの書き込みを X 行にバッファします。デフォルトは0です (バッファしません)。\n\n"
    },
    {
      "title": "ソースのバッチ処理制限を増やす",
      "level": 4,
      "content": "syslog-ng は、さまざまなソース メカニズムを使用してメッセージのストリームを受信するため、メッセージ処理を並行して実行します。一方のソース接続が他方のソース接続に対して枯渇することを避けるために、syslog-ng はスレッドを使用し、単一のソース接続から一度に処理するメッセージの量に制限を課します。\n\nこれは、ソースアプリケーションがタイトなループで 1000 個のメッセージを送信したとしても、syslog-ng は一度に 100 個のメッセージを処理することを意味します (正確な制限は log-fetch-limit() で指定されます) 100 回ごとに、他の接続も処理が必要かどうかを再チェックします。これにはある程度のオーバーヘッドがあり、log-fetch-limit() を増やすことで syslog-ng のパフォーマンスを大幅に向上させることができます。\n\n特定のユースケースに基づいて調整を使用できるもう 1 つのメカニズムは、バックプレッシャーの伝播に使用されるウィンドウサイズ設定です。これは、宛先が確認応答するまでに送信可能なメッセージの数を制御する log-iw-size() パラメータです。log-iw-size() を増やすことで、送信先がメッセージを消費できるよう停止する前に、より多くのメッセージを処理できるようになります。\n\nlog-iw-size() を増やすと、syslog-ng がメッセージをどこかに置く必要があるため、メモリ/ディスクバッファの使用量が増加します。\n\n"
    },
    {
      "title": "処理やディスク領域の重複を避ける",
      "level": 4,
      "content": "一つのログメッセージが別々のログファイルに複数回送信されるということがあります。例えば、初期設定では、以下のような定義があります:\n\n```\ndestination cron { file(\"/var/log/cron.log\"); };\ndestination messages { file(\"/var/log/messages\"); };\nfilter f_cron { facility(cron); };\nfilter f_messages { level(info..warn) \n       and not facility(auth, authpriv, mail, news); };\nlog { source(src); filter(f_cron); destination(cron); };\nlog { source(src); filter(f_messages); destination(messages); };\n```\n\ncron 機能からの同じメッセージは、cron.log と messages の両方のファイルに保存されます。この動作を変更するには、final フラグを使用します。 最終的にはメッセージのさらなる処理が終了します。したがって、この例では、cron 機能からのメッセージが メッセージファイルでは、cron のログ文を次のように変更する必要があります:\n\n```\nlog { source(src); filter(f_cron); destination(cron); flags(final); };\n```\n\n別の方法は、f_messages フィルタから cron 機能を除外することです:\n\n```\nfilter f_messages { level(info..warn) and not facility(cron, auth, authpriv, mail, news); };\n```\n\n"
    },
    {
      "title": "PostgreSQL の宛先",
      "level": 3,
      "content": "このセクションでは2つのロールを使います: syslog と logwriter です。syslog は syslog データベースの管理者であり、logwriter だけが logs テーブルにレコードを追加することができることにします。\n\nログ用にテーブルを作成する必要はありません。syslog-ng が自動的に作成します。\n\n```\npsql -U postgres\n```\n\n```\npostgres=# CREATE ROLE syslog WITH LOGIN;\npostgres=# \\password syslog    # Using the \\password function is secure because\npostgres=# CREATE ROLE logwriter WITH LOGIN;\npostgres=# \\password logwriter # the password is not saved in history.\npostgres=# CREATE DATABASE syslog OWNER syslog;\npostgres=# \\q # You are done here for the moment\n```\n\npg_hba.conf を編集して syslog と logwriter が PostgreSQL への接続を確立できるようにします。\n\n```\n/var/lib/postgres/data/pg_hba.conf\n```\n\n```\n# TYPE  DATABASE    USER        CIDR-ADDRESS          METHOD\n\nhost    syslog      logwriter   192.168.0.1/24        md5\nhost    syslog      syslog      192.168.0.10/32       md5\n```\n\nPostgreSQL に設定ファイルをリロードさせてください:\n\n```\n# systemctl reload postgresql\n```\n\n/etc/syslog-ng/syslog-ng.conf を編集して PostgreSQL に書き込む場所と方法を設定します。syslog-ng は logwriter ロールを利用します。\n\n```\n...\n#\n# SQL logging support\n#\n\ndestination d_pgsql {\n  sql(type(pgsql)\n  host(\"127.0.0.1\") username(\"logwriter\") password(\"password\")\n  database(\"syslog\")\n  table(\"logs_${HOST}_${R_YEAR}${R_MONTH}${R_DAY}\") #or whatever you want, example ${HOST}\" for hosts, ${LEVEL}\" for levels.. etc\n  columns(\"datetime timestamp with time zone\", \"host varchar(32)\", \"program varchar(16)\", \"pid varchar(16)\", \"message varchar(200)\")\n  values(\"$R_ISODATE\", \"$HOST\", \"$PROGRAM\", \"$PID\", \"$MSG\")\n  indexes(\"datetime\", \"host\", \"program\", \"pid\", \"message\"));\n};\n\nlog { source(src); destination(d_pgsql); };\n```\n\n最後に、syslog-ng を再起動してください。\n\n```\n# systemctl restart syslog-ng\n```\n\nちゃんとログが記録されているか確認もしましょう。\n\n```\npsql -U logwriter -d syslog\nsyslog=> SELECT * FROM <your table name> ORDER BY datetime DESC LIMIT 10;\n```\n\n"
    },
    {
      "title": "ISO 8601 タイムスタンプ",
      "level": 3,
      "content": "ビフォー:\n\n```\n#logger These timestamps are not optimal.\n#tail -n 1 /var/log/messages.log\nFeb 18 14:25:01 hostname logger: These timestamps are not optimal.\n#\n```\n\nts_format(iso); を /etc/syslog-ng/syslog-ng.conf の options セクションに追加。例:\n\n```\noptions {\n  stats_freq (0);\n  flush_lines (0);\n  time_reopen (10);\n  log_fifo_size (1000);\n  long_hostnames(off); \n  use_dns (no);\n  use_fqdn (no);\n  create_dirs (no);\n  keep_hostname (yes);\n  perm(0640);\n  group(\"log\");\n  ts_format(iso);      #make ISO-8601 timestamps\n};\n```\n\nそして:\n\n```\n# systemctl reload syslog-ng\n```\n\nアフター:\n\n```\n#logger Now THAT is a timestamp!\n#tail -n 2 /var/log/messages.log\nFeb 18 14:25:01 hostname logger: These timestamps are not optimal.\n2010-02-18T20:23:58-05:00 electron logger: Now THAT is a timestamp!\n#\n```\n\n"
    },
    {
      "title": "RFC 3339 タイムスタンプ",
      "level": 3,
      "content": "上記と同じように編集。ただし ts_format には iso の代わりに rfc3339 を使用。\n\n"
    },
    {
      "title": "ログレベル",
      "level": 3,
      "content": "ログレベルは、syslog-ng config でログに記録される機能ごとに個別に定義されます。利用可能なログレベルは /usr/include/sys/syslog.h にリストされています:\n\n```\ndefine LOG_EMERG       0       /* system is unusable */\ndefine LOG_ALERT       1       /* action must be taken immediately */\ndefine LOG_CRIT        2       /* critical conditions */\ndefine LOG_ERR         3       /* error conditions */\ndefine LOG_WARNING     4       /* warning conditions */\ndefine LOG_NOTICE      5       /* normal but significant condition */\ndefine LOG_INFO        6       /* informational */\ndefine LOG_DEBUG       7       /* debug-level messages */\n```\n\n"
    },
    {
      "title": "マクロと変数",
      "level": 3,
      "content": "マクロは、テンプレートと宛先ファイル名の両方で使用できます。syslog-ng OSE のマクロ\n\n以下のコードは macroname=value@ の形式でログを /var/log/test.log に書き出します。\n\n```\ntemplate t_test { template(\"PROGRAM=$PROGRAM@PID=$PID@BSDTAG=$BSDTAG@TAG=$TAG@TAGS=$TAGS@FACILITY=$FACILITY@FACILITY_NUM=$FACILITY_NUM@LEVEL=$LEVEL@LEVEL_NUM=$LEVEL_NUM@PRI=$PRI@PRIORITY=$PRIORITY@FULLHOST=$FULLHOST@FULLHOST_FROM=$FULLHOST_FROM@HOST=$HOST@HOST_FROM=$HOST_FROM@LOGHOST=$LOGHOST@MSGHDR=$MSGHDR@MSGID=$MSGID@MSGONLY=$MSGONLY@MSG=$MSG@MESSAGE=$MESSAGE@SOURCE=$SOURCE@SOURCEIP=$SOURCEIP@SOURCE_IP=$SOURCE_IP@SEQNUM=$SEQNUM@UNIXTIME=$UNIXTIME@FULLDATE=$FULLDATE@ISODATE=$ISODATE@DATE=$DATE@STAMP=$STAMP@TZ=$TZ@TZOFFSET=$TZOFFSET@SEC=$SEC@MIN=$MIN@HOUR=$HOUR@HOUR12=$HOUR12@DAY=$DAY@WEEK=$WEEK@WEEK_DAY=$WEEK_DAY@WEEK_DAY_ABBREV=$WEEK_DAY_ABBREV@WEEK_DAY_NAME=$WEEK_DAY_NAME@MONTH=$MONTH@MONTH_ABBREV=$MONTH_ABBREV@MONTH_NAME=$MONTH_NAME@MONTH_WEEK=$MONTH_WEEK@YEAR=$YEAR@YEAR_DAY=$YEAR_DAY\n\\n\"); template_escape(no); };\n\ndestination d_test { file(\"/var/log/test.log\" template(t_test)); };\n\nlog { source(s_local); destination(d_test); flags(final); };\n```\n\nsyslog-ng を再起動すると、次のように独自の値リストを作成できます: tail /var/log/test.log|tr \"@\" \"\\n\"\n\n```\nPROGRAM=kernel\nPID=\nBSDTAG=4A\nTAG=04\nTAGS=.source.s_local\nFACILITY=kern\nFACILITY_NUM=0\nLEVEL=warning\nLEVEL_NUM=4\nPRI=4\nPRIORITY=warning\nFULLHOST=www.askapache.com\nFULLHOST_FROM=www.askapache.com\nHOST=www.askapache.com\nHOST_FROM=www.askapache.com\nLOGHOST=\nMSGHDR=kernel: \nMSGID=\nMSGONLY=Firewall: *INVALID* IN=eth0 OUT= MAC=00:00 SRC=x.x.x.x DST=198.101.159.98 LEN=40 TOS=0x00 PREC=0x00 TTL=113 ID=7730 DF PROTO=TCP SPT=52369 DPT=80 WINDOW=0 RES=0x00 ACK RST URGP=0 \nMSG=Firewall: *INVALID* IN=eth0 OUT= MAC=00:00 SRC=x.x.x.x DST=198.101.159.98 LEN=40 TOS=0x00 PREC=0x00 TTL=113 ID=7730 DF PROTO=TCP SPT=52369 DPT=80 WINDOW=0 RES=0x00 ACK RST URGP=0 \nMESSAGE=Firewall: *INVALID* IN=eth0 OUT= MAC=00:00 SRC=x.x.x.x DST=198.101.159.98 LEN=40 TOS=0x00 PREC=0x00 TTL=113 ID=7730 DF PROTO=TCP SPT=52369 DPT=80 WINDOW=0 RES=0x00 ACK RST URGP=0 \nSOURCE=s_local\nSOURCEIP=127.0.0.1\nSOURCE_IP=\nUNIXTIME=1369742458\nFULLDATE=2013 May 28 08:00:58\nISODATE=2013-05-28T08:00:58-04:00\nDATE=May 28 08:00:58\nSTAMP=2013-05-28T08:00:58-04:00\nTZ=-04:00\nTZOFFSET=-04:00\nSEC=58\nMIN=00\nHOUR=08\nHOUR12=\nDAY=28\nWEEK=21\nWEEK_DAY=3\nWEEK_DAY_ABBREV=Tue\nWEEK_DAY_NAME=Tuesday\nMONTH=05\nMONTH_ABBREV=May\nMONTH_NAME=May\nMONTH_WEEK=4\nYEAR=2013\nYEAR_DAY=148\n```\n\n"
    },
    {
      "title": "一般的な syslog メッセージを受信して​​解析する",
      "level": 3,
      "content": "バージョン 3.16 以降、syslog-ng は、最も一般的なパーサーを使用して、最も一般的なポートでメッセージを受信して​​解析できます。 default-network-drivers() ソースドライバ\n\n- デフォルトのリスニングポート: 514 (TCP と UDP の両方)、RFC3164 (BSD-syslog) 形式のトラフィックの場合 601 TCP、RFC5424 (IETF-syslog) 形式のトラフィック用 6514 TCP、TLS 暗号化トラフィック用\n- 自動パーサー: RFC3164 メッセージパーサー RFC5424 メッセージパーサー Cisco パーサー 構造化された EWMM パーサー その他のアプリケーションアダプター (Splunk Common Information Model (CIM)、iptables、または sudo)\n\n- 514 (TCP と UDP の両方)、RFC3164 (BSD-syslog) 形式のトラフィックの場合\n- 601 TCP、RFC5424 (IETF-syslog) 形式のトラフィック用\n- 6514 TCP、TLS 暗号化トラフィック用\n\n- RFC3164 メッセージパーサー\n- RFC5424 メッセージパーサー\n- Cisco パーサー\n- 構造化された EWMM パーサー\n- その他のアプリケーションアダプター (Splunk Common Information Model (CIM)、iptables、または sudo)\n\n"
    },
    {
      "title": "関連項目",
      "level": 3,
      "content": "- Netconsole ユーザー空間 (syslogd など) を介さずに、すべてのカーネルログメッセージ (つまり dmesg) をネットワーク経由で別のコンピューターに送信するカーネルモジュール。\n\n"
    },
    {
      "title": "外部リンク",
      "level": 2,
      "content": "- syslog-ng Project Page on GitHub\n- syslog-ng OSE Main Page from syslog-ng.com\n- syslog-ng Documentation\n- syslog-ng Documentation GitHub page\n- syslog-ng Blogs\n- Axoflow Blogs about syslog-ng\n- syslog-ng Project Page on Freecode\n- Gentoo:syslog-ng\n- Gentoo:Security Handbook/Logging\n- What is Syslog? Logging with PostgreSQL HOWTO\n- Wikipedia:ISO 8601\n- RFC 3164 - BSD syslog プロトコル\n- RFC 5424 - The Syslog プロトコル RFC 5425 - Syslog のトランスポート層セキュリティ (TLS) トランスポートマッピング RFC 5426 - UDP を介した Syslog メッセージの送信 RFC 5427 - Syslog 管理のテキスト表記規則 RFC 5428 - PacketCable および IPCablecom 準拠デバイスの MIB\n- RFC 3339 - インターネット上の日付と時刻: タイムスタンプ\n\n- RFC 5425 - Syslog のトランスポート層セキュリティ (TLS) トランスポートマッピング\n- RFC 5426 - UDP を介した Syslog メッセージの送信\n- RFC 5427 - Syslog 管理のテキスト表記規則\n- RFC 5428 - PacketCable および IPCablecom 準拠デバイスの MIB\n\n"
    }
  ]
}