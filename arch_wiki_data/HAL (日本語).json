{
  "title": "HAL (日本語)",
  "url": "https://wiki.archlinux.org/title/HAL_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- udisks\n\nudev は、オペレーティングシステムの管理者がユーザー空間のイベントハンドラを登録できるようにする、ユーザー空間のシステムです。udev のデーモンによって捕捉されたイベントは主に、周辺機器関連の物理イベントに応答して (Linux) カーネルによって生成されたものです。そのため、udev の主な使用目的は、(カーネルモジュールやデバイスファームウェアのロードなど) カーネルに制御が戻るようなアクションを含む、周辺機器の検出やホットプラグです。また、周辺機器の検出においては、デバイス (ファイル) のパーミッションを調整して非 root ユーザーや非 root グループからアクセス可能にするなども行われます。\n\nudev は、devfsd と hotplug の後継として、/dev ディレクトリ内のデバイスノードの追加、シンボリックリンクの作成、名称変更などの管理も行います。udev は hotplug と hwdetect の両方の機能を置き換えます。\n\nudev は、別々のイベントを同時に (並列に) 処理します。それにより、古いシステムよりも高いパフォーマンスが得られる可能性があります。しかし、カーネルモジュールのロード順がブート毎に同じであることが保証されないなどの理由により、この機構はシステムの管理を複雑化させてしまう可能性もはらんでいます。マシンに複数のブロックデバイスが搭載されている場合、再起動するとデバイスノードの名称が変化してしまう場合があります。例えば、マシンに 2 つのハードドライブが存在する場合、/dev/sda は次回の起動時に /dev/sdb となってしまうかもしれません。これに関する詳細は、下記を見てください。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール\n- 2 udev ルールについて 2.1 udev ルールの例 2.2 デバイスの属性を一覧表示する 2.3 ロードする前にルールをテストする 2.4 新しいルールをロードする\n- 3 Udisks\n- 4 ヒントとテクニック 4.1 ルールの中でドライブをマウントする 4.2 長時間稼働するプロセスを生成する 4.3 通常ユーザーにデバイスの使用を許可する 4.4 HDMI ケーブルの抜き差し時に実行する 4.5 VGA ケーブルの接続時に実行する 4.6 新しい eSATA を検知する 4.7 内部 SATA ポートを eSATA として認識させる 4.8 固定デバイス名を設定する 4.8.1 ビデオデバイス 4.8.2 プリンタ 4.9 ディスクをシリアル番号で識別する 4.10 USB デバイスでサスペンドから復帰させる 4.11 イベントをトリガーする 4.12 Udev ルールからデスクトップ通知をトリガーする\n- 5 トラブルシューティング 5.1 モジュールをブラックリストに追加する 5.2 デバッグ出力 5.3 起動時に udevd が止まる 5.4 リムーバブルデバイスとして扱われなくてはならないデバイスがそう扱われない 5.5 一部のモジュールが自動でロードされず、サウンドの問題が発生する 5.6 光学ドライブのグループ ID が \"disk\" に設定されている場合 5.7 X サーバーが存在しない場合に RUN ルールの X プログラムがハングする\n- 6 参照\n\n- 2.1 udev ルールの例\n- 2.2 デバイスの属性を一覧表示する\n- 2.3 ロードする前にルールをテストする\n- 2.4 新しいルールをロードする\n\n- 4.1 ルールの中でドライブをマウントする\n- 4.2 長時間稼働するプロセスを生成する\n- 4.3 通常ユーザーにデバイスの使用を許可する\n- 4.4 HDMI ケーブルの抜き差し時に実行する\n- 4.5 VGA ケーブルの接続時に実行する\n- 4.6 新しい eSATA を検知する\n- 4.7 内部 SATA ポートを eSATA として認識させる\n- 4.8 固定デバイス名を設定する 4.8.1 ビデオデバイス 4.8.2 プリンタ\n- 4.9 ディスクをシリアル番号で識別する\n- 4.10 USB デバイスでサスペンドから復帰させる\n- 4.11 イベントをトリガーする\n- 4.12 Udev ルールからデスクトップ通知をトリガーする\n\n- 4.8.1 ビデオデバイス\n- 4.8.2 プリンタ\n\n- 5.1 モジュールをブラックリストに追加する\n- 5.2 デバッグ出力\n- 5.3 起動時に udevd が止まる\n- 5.4 リムーバブルデバイスとして扱われなくてはならないデバイスがそう扱われない\n- 5.5 一部のモジュールが自動でロードされず、サウンドの問題が発生する\n- 5.6 光学ドライブのグループ ID が \"disk\" に設定されている場合\n- 5.7 X サーバーが存在しない場合に RUN ルールの X プログラムがハングする\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "udev は systemd の一部なので、デフォルトでインストールされます。詳細は systemd-udevd.service(8) を見てください。\n\n"
    },
    {
      "title": "udev ルールについて",
      "level": 2,
      "content": "管理者が書いた udev ルールは /etc/udev/rules.d/ 内に配置することになっており、そのファイル名は .rules で終わらなければなりません。様々なパッケージに同梱されている udev ルールは /usr/lib/udev/rules.d/ に格納されています。もし /usr/lib と /etc に同じ名前のファイルがあった場合、/etc にあるファイルが優先されます。\n\nudev ルールについて学ぶには、udev(7) マニュアルを参照してください。また、Writing udev rules も参照してください。このガイドには、実践的な例 (Writing udev rules - Examples) がいくつか挙げられています。\n\n"
    },
    {
      "title": "udev ルールの例",
      "level": 3,
      "content": "以下は、ウェブカメラが接続された時に /dev/video-cam シンボリックリンクを作成するルールの例です。\n\nここで、カメラは既に接続されていて、/dev/video2 というデバイス名でロードされているとします。そして、以下の udev ルールを書く理由は、次回のブート時にデバイスファイルが別の名前 (例えば /dev/video0 など) になってしまうかもしれないからです (なので、/dev/video-cam という固定のファイル名で参照できるようにしようというのが目的です)。\n\n```\n$ udevadm info --attribute-walk --path=$(udevadm info --query=path --name=/dev/video2)\n```\n\n```\nUdevadm info starts with the device specified by the devpath and then walks up the chain of parent devices.\nIt prints for every device found, all possible attributes in the udev rules key format.\nA rule to match, can be composed by the attributes of the device and the attributes from one single parent device.\n\nlooking at device '/devices/pci0000:00/0000:00:04.1/usb3/3-2/3-2:1.0/video4linux/video2':\n  KERNEL==\"video2\"\n  SUBSYSTEM==\"video4linux\"\n   ...\nlooking at parent device '/devices/pci0000:00/0000:00:04.1/usb3/3-2/3-2:1.0':\n  KERNELS==\"3-2:1.0\"\n  SUBSYSTEMS==\"usb\"\n  ...\nlooking at parent device '/devices/pci0000:00/0000:00:04.1/usb3/3-2':\n  KERNELS==\"3-2\"\n  SUBSYSTEMS==\"usb\"\n  ATTRS{idVendor}==\"05a9\"\n  ATTRS{manufacturer}==\"OmniVision Technologies, Inc.\"\n  ATTRS{removable}==\"unknown\"\n  ATTRS{idProduct}==\"4519\"\n  ATTRS{bDeviceClass}==\"00\"\n  ATTRS{product}==\"USB Camera\"\n  ...\n```\n\n対象のウェブカメラを識別するために、video4linux デバイスからは KERNEL==\"video2\" と SUBSYSTEM==\"video4linux\" という条件式が使用されています。それより 2 階層上を見ると、USB 親デバイス SUBSYSTEMS==\"usb\" からはベンダー ID ATTRS{idVendor}==\"05a9\" とプロダクト ID ATTRS{idProduct}==\"4519\" を使ってウェブカメラをマッチさせています。\n\n以上から、以下のようにこのデバイスにマッチするルールを作成することができます:\n\n```\n/etc/udev/rules.d/83-webcam.rules\n```\n\n```\nKERNEL==\"video[0-9]*\", SUBSYSTEM==\"video4linux\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"05a9\", ATTRS{idProduct}==\"4519\", SYMLINK+=\"video-cam\"\n```\n\nここで、SYMLINK+=\"video-cam\" を使ってシンボリックリンクを作成していますが、OWNER=\"john\" でデバイスの所有者を、GROUP=\"video\" でデバイスの所有グループを設定することもできますし、MODE=\"0660\" でパーミッションも設定できます。\n\nデバイスが取り除かれた時に何かを行うルールを記述したい場合は、デバイスの属性にはアクセスできないことに注意してください (とっくにデバイスは取り除かれているからです)。この場合、事前に定義されたデバイスの環境変数を使う必要があります。そのような環境変数を監視するには、デバイスが取り除かれた状態で以下のコマンドを実行してください:\n\n```\n$ udevadm monitor --property --udev\n```\n\nこのコマンドでは、ID_VENDOR_ID と ID_MODEL_ID というような値のペアが出力されます。これらは、上記の属性 idVendor と idProduct に対応します。デバイスの属性の代わりにデバイスの環境変数を使うルールは以下のようになります:\n\n```\n/etc/udev/rules.d/83-webcam-removed.rules\n```\n\n```\nACTION==\"remove\", SUBSYSTEM==\"usb\", ENV{ID_VENDOR_ID}==\"05a9\", ENV{ID_MODEL_ID}==\"4519\", RUN+=\"/path/to/your/script\"\n```\n\n"
    },
    {
      "title": "デバイスの属性を一覧表示する",
      "level": 3,
      "content": "ルールを書く際に使用できるデバイスの属性のリストを全て一覧表示するには、以下のコマンドを実行してください:\n\n```\n$ udevadm info --attribute-walk --name=device_name\n```\n\ndevice_name の部分は、システムに存在しているデバイス (/dev/sda、/dev/ttyUSB0 など) に置き換えてください。\n\nデバイス名が分からない場合は、特定のシステムパスの全属性をリストアップすることもできます:\n\n```\n$ udevadm info --attribute-walk --path=/sys/class/backlight/acpi_video0\n```\n\nデバイスを絞り込むには、まずデバイスのクラスを調べて、以下のコマンドを実行してください:\n\n```\n$ ls /dev/class/by-id\n```\n\n--name 引数には、単にデバイスのシンボリックリンクを使うこともできますし、シンボリックリンクの指す実際のアイルを使うこともできます。例えば:\n\n```\n$ udevadm info --attribute-walk --name=/dev/input/by-id/usb-foostan_Corne-event-kbd\n```\n\n下位デバイスを持たない裸のUSBデバイスのパスを取得するには、 USB デバイスのフルパスを使用する必要があります。udevadm のモニターモードを開始し、対象の USB デバイスを接続すれば、デバイスへのパスを得ることができます:\n\n```\n$ udevadm monitor\n```\n\n```\n...\nKERNEL[26652.638931] add      /devices/pci0000:00/0000:00:01.2/0000:02:00.0/0000:03:05.0/0000:05:00.0/usb1/1-3 (usb)\nKERNEL[26652.639153] add      /devices/pci0000:00/0000:00:01.2/0000:02:00.0/0000:03:05.0/0000:05:00.0/usb1/1-3/1-3:1.0 (usb)\n...\n```\n\n一番深いパスを選択し、--attribute-walk を使えば、親デバイスの全属性を出力することができます:\n\n```\n$ udevadm info --attribute-walk --path=/devices/pci0000:00/0000:00:01.2/0000:02:00.0/0000:03:05.0/0000:05:00.0/usb1/1-3/1-3:1.0\n```\n\n"
    },
    {
      "title": "ロードする前にルールをテストする",
      "level": 3,
      "content": "```\n# udevadm test $(udevadm info --query=path --name=device_name) 2>&1\n```\n\nこのコマンドは、ルールの全てのアクションを実行しませんが、既存のデバイスに対するシンボリックリンクのルールは処理します。ルールをロードできない場合に役立つかもしれません。また、テストしたい udev ルールのデバイスへのパスを直接指定することも可能です:\n\n```\n# udevadm test /sys/class/backlight/acpi_video0/\n```\n\n"
    },
    {
      "title": "新しいルールをロードする",
      "level": 3,
      "content": "udev はルールファイルの変更を自動的に検出するので、udev を再起動せずとも変更は即座に有効になります。しかし、既に存在するデバイスに対しては、ルールが自動的に再トリガーされません。USB デバイスなどのホットプラグ可能なデバイスは、新しいルールを有効にするために再接続するか、少なくともカーネルモジュール ohci-hcd と ehci-hcd を再ロードして全ての USB ドライバを再読み込みする必要があります。\n\nルールが自動的に再読み込みされない場合は、以下を実行してください:\n\n```\n# udevadm control --reload\n```\n\n手動でルールを強制的にトリガーするには:\n\n```\n# udevadm trigger\n```\n\n"
    },
    {
      "title": "Udisks",
      "level": 2,
      "content": "Udisks を見て下さい。\n\n"
    },
    {
      "title": "ルールの中でドライブをマウントする",
      "level": 3,
      "content": "リムーバブルディスクをマウントする際に udev ルールから mount コマンドを実行しないでください。これは以下の 2 つの理由により賢明ではありません:\n\n1. デフォルトで systemd は、分離された \"mount 名前空間\" 内で systemd-udevd.service を実行します (namespaces(7) を参照)。つまり、この名前空間外からはデバイスが不可視になります。\n1. この問題を解決するために (PrivateMounts と MountFlags の行をコメントアウトして) サービスのパラメータを変更したとしても、udev から起動されたプロセスは数秒後に終了させられてしまうという問題があります。NTFS-3G などの FUSE ファイルシステムにおいては、mount はファイルシステムを管理するためにユーザー空間のプロセスを起動します。このプロセスが終了されると、そのファイルシステムにアクセスしようとした時に Transport endpoint not connected (通信端点が接続されていません) というエラーが発生します。\n\nうまく行く方法もいくつかあります:\n\n- Udev ルールからカスタムの systemd サービスを起動する。カスタムの systemd サービスでは、長時間動作させるプロセス (FUSE など) を開始するスクリプトを開始するなどができます。USB ディスクを自動的に /media 内にマウントする簡単な例は udev-media-automount です。似たようなアイディアはこのブログ記事でも説明されています。\n- Udev ルールで mount の代わりに systemd-mount を使う。これは、systemd の開発者達によって推奨されている方法です。例えば、以下の udev ルールは USB ディスクを /media 内にマウントします:\n\n```\nACTION==\"add\", SUBSYSTEMS==\"usb\", SUBSYSTEM==\"block\", ENV{ID_FS_USAGE}==\"filesystem\", RUN{program}+=\"/usr/bin/systemd-mount --no-block --automount=yes --collect $devnode /media\"\n```\n\n- udisks や udiskie といったパッケージを使う。このようなパッケージは非常に強力ですが、セットアップが難しいです。また、これらのパッケージは一部のファイルシステムの所有者を、アクティブなセッションを現在持っている非特権ユーザーに設定するので、シングルユーザーのセッションで使用されることを意図しています。\n\n"
    },
    {
      "title": "長時間稼働するプロセスを生成する",
      "level": 3,
      "content": "udev によって開始されるプログラムは対象となるデバイスからのイベントをブロックしてしまう上、udev ルールから生成されたタスクはイベント処理が完了するとキルされてしまいます。長時間稼働するプロセスを udev で生成する必要があるのであれば、コマンドの実行を処理する systemd ユニットと、そのユニットの実行させるシグナルを発する udev ルールを作るのが、意図された方法です。しかし、udev ルール内で systemctl を使うのは推奨されていません。なぜなら、このユーティリティはユーザーとの対話用に作られており、処理の実行をブロックしてしまう可能性があるからです。\n\n正しい方法は、次のとおりです。まず、ルール内で TAG+=\"systemd\" を使うことで、systemd デバイスユニット (systemd.device(5) を参照) を必要とするという意味のタグを対象のデバイスに付けます。次に、ENV{SYSTEMD_WANTS}= (systemctl --system で実行するようなサービス用) か ENV{SYSTEMD_USER_WANTS}= (systemctl --user で実行するようなサービス用) のどちらか一方のサービスプロパティを追加します。例えば:\n\n```\nSUBSYSTEM==\"tty\" ACTION==\"add\" ATTRS{manufacturer}==\"Pulse-Eight\" ATTRS{product}==\"CEC Adapter\" TAG+=\"systemd\" ENV{SYSTEMD_WANTS}=\"inputattach-cec@$devnode.service\"\n```\n\n```\n/etc/systemd/system/inputattach-cec@.service\n```\n\n```\n[Unit]\nDescription=Configure USB serial device at %I\n\n[Service]\nType=simple\nExecStart=/usr/bin/inputattach --pulse8-cec %I\n```\n\nSYSTEMD_WANTS は、systemd における Wants= ディレクティブと等価です。つまり、そのサービスが失敗した、存在しない、任意の時点で成功して完了した場合に、デバイスには影響しないことを意味します。\n\n"
    },
    {
      "title": "通常ユーザーにデバイスの使用を許可する",
      "level": 3,
      "content": "カーネルドライバがデバイスを初期化する際に、デフォルト状態ではデバイスノードは root:root によって所有され、パーミッションは 600 に設定されます。[1] よって、ドライバがこのデフォルトを変更するか、ユーザー空間の udev ルールがパーミッションを変更しない限り、通常ユーザーはデバイスにアクセスできません。\n\nUdev 値 OWNER、GROUP、MODE を使って、アクセス権を付与することができます。しかし、全てのユーザーがデバイスを利用できるようにし、なおかつデバイスファイルのモードを過度に寛容にしないようにするのは困難です。Ubuntu では、plugdev というグループを作成して、このグループにデバイスが追加されます。しかし、このアプローチは systemd の開発者達によって推奨されていない [2] だけでなく、Arch の udev ルールに追加されたときにはバグとみなされました (FS#35602)。歴史的に採用されていたもう一つのアプローチは、デバイスのカテゴリ毎に対応する別々のグループを使用するというものです (ユーザーとグループ#systemd 以前のグループ で説明されています)。\n\nSystemd システムにおける最近の推奨されるアプローチは、MODE を 660 に設定してグループがデバイスを使用できるようにし、uaccess という TAG を付けることです [3]。この特殊なタグにより、udev は動的なユーザー ACL をデバイスノードに適用するようになり、systemd-logind(8) と連携してログイン中のユーザーがデバイスにアクセスできるようにします。以下は、このアプローチを実装する udev ルールの例です:\n\n```\n/etc/udev/rules.d/71-device-name.rules\n```\n\n```\nSUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"vendor_id\", ATTRS{idProduct}==\"product_id\", MODE=\"0660\", TAG+=\"uaccess\"\n```\n\n"
    },
    {
      "title": "HDMI ケーブルの抜き差し時に実行する",
      "level": 3,
      "content": "以下の内容でルール /etc/udev/rules.d/95-hdmi-plug.rules を作成してください:\n\n```\nACTION==\"change\", SUBSYSTEM==\"drm\", ENV{DISPLAY}=\":0\", ENV{XAUTHORITY}=\"/home/username/.Xauthority\", RUN+=\"/path/to/script.sh\"\n```\n\n"
    },
    {
      "title": "VGA ケーブルの接続時に実行する",
      "level": 3,
      "content": "VGA モニターのケーブルが接続された時に arandr を実行するには、以下の内容でルール /etc/udev/rules.d/95-monitor-hotplug.rules を作成してください:\n\n```\nKERNEL==\"card0\", SUBSYSTEM==\"drm\", ENV{DISPLAY}=\":0\", ENV{XAUTHORITY}=\"/home/username/.Xauthority\", RUN+=\"/usr/bin/arandr\"\n```\n\n一部のディスプレイマネージャは .Xauthority をユーザーのホームディレクトリ外に保存します。なので、ENV{XAUTHORITY} の値は適宜変更する必要があります。例として、GNOME Display Manager の場合は以下のようになります:\n\n```\n$ printenv XAUTHORITY\n```\n\n```\n/run/user/1000/gdm/Xauthority\n```\n\n"
    },
    {
      "title": "新しい eSATA を検知する",
      "level": 3,
      "content": "eSATA ドライブが挿入された時に検出されない場合、問題を解決できるかもしれない方法がいくつかあります。1つ目は、eSATA が挿入されている状態で再起動することです。あるいは、以下のコマンドを試してみることもできます:\n\n```\n# echo 0 0 0 | tee /sys/class/scsi_host/host*/scan\n```\n\nあるいは、scsiaddAUR をインストールし、以下を実行してみることもできます:\n\n```\n# scsiadd -s\n```\n\nうまく行けば、ドライブが /dev 内に出現します。出現しない場合は、以下のコマンドを実行し、出力されるログを見ながら上記のコマンドをもう一度試してください:\n\n```\n# udevadm monitor\n```\n\n"
    },
    {
      "title": "内部 SATA ポートを eSATA として認識させる",
      "level": 3,
      "content": "eSATA ベイや他の eSATA アダプタを接続すると、システムはこのディスクを内部 SATA ドライブとして認識します。GNOME や KDE では毎回 root のパスワードが要求されます。以下のルールは、指定した SATA ポートを外部 eSATA ポートとしてマークします。これにより、GNOME の通常ユーザーでも root のパスワード無しで eSATA ドライブを USB ドライブのようにポートに接続できるようになります。\n\n```\n/etc/udev/rules.d/10-esata.rules\n```\n\n```\nDEVPATH==\"/devices/pci0000:00/0000:00:1f.2/host4/*\", ENV{UDISKS_SYSTEM}=\"0\"\n```\n\n```\n$ udevadm info --query=path /dev/sdb\n```\n\n```\n/devices/pci0000:00/0000:00:1f.2/host4/target4:0:0/4:0:0:0/block/sdb\n```\n\n```\n$ find /sys/devices/ -name sdb\n```\n\n```\n/sys/devices/pci0000:00/0000:00:1f.2/host4/target4:0:0/4:0:0:0/block/sdb\n```\n\n"
    },
    {
      "title": "固定デバイス名を設定する",
      "level": 3,
      "content": "udev は全てのモジュールを非同期でロードするので、モジュールは毎回異なる順番で初期化される可能性があります。これにより、デバイス名がランダムに変わってしまいます。udev ルールを用いることで、固定デバイス名を使用することができます。 ブロックデバイスに関しては 永続的なブロックデバイスの命名 も、ネットワークデバイスに関しては ネットワーク設定#インターフェイス名の変更 も参照してください。\n\n"
    },
    {
      "title": "ビデオデバイス",
      "level": 4,
      "content": "ウェブカメラのセットアップに関しては ウェブカメラ設定 を参照してください。\n\n複数のウェブカメラを使用すると、それぞれのビデオデバイスはブート時に /dev/video* としてランダムに割り当てられます。推奨される解決策は、#udev ルールの例 章にあるような udev ルールを使ってシンボリックリンクを作成することです:\n\n```\n/etc/udev/rules.d/83-webcam.rules\n```\n\n```\nKERNEL==\"video[0-9]*\", SUBSYSTEM==\"video4linux\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"05a9\", ATTRS{idProduct}==\"4519\", SYMLINK+=\"video-cam1\"\nKERNEL==\"video[0-9]*\", SUBSYSTEM==\"video4linux\", SUBSYSTEMS==\"usb\", ATTRS{idVendor}==\"046d\", ATTRS{idProduct}==\"08f6\", SYMLINK+=\"video-cam2\"\n```\n\n"
    },
    {
      "title": "プリンタ",
      "level": 4,
      "content": "複数のプリンタを使用すると、それぞれのプリンタはブート時に /dev/lp[0-9] としてランダムに割り当てられます。これにより、CUPS の設定などが機能しなくなります。\n\nディレクトリ /dev/lp/by-id と /dev/lp/by-path 内に永続的なブロックデバイスの命名規則に似たシンボリックリンクを作成する以下のルールを作成することができます:\n\n```\n/etc/udev/rules.d/60-persistent-printer.rules\n```\n\n```\nACTION==\"remove\", GOTO=\"persistent_printer_end\"\n# これは必須では無いはずです\n#KERNEL!=\"lp*\", GOTO=\"persistent_printer_end\"\n\nSUBSYSTEMS==\"usb\", IMPORT{builtin}=\"usb_id\"\nENV{ID_TYPE}!=\"printer\", GOTO=\"persistent_printer_end\"\n\nENV{ID_SERIAL}==\"?*\", SYMLINK+=\"lp/by-id/$env{ID_BUS}-$env{ID_SERIAL}\"\n\nIMPORT{builtin}=\"path_id\"\nENV{ID_PATH}==\"?*\", SYMLINK+=\"lp/by-path/$env{ID_PATH}\"\n\nLABEL=\"persistent_printer_end\"\n```\n\n"
    },
    {
      "title": "ディスクをシリアル番号で識別する",
      "level": 3,
      "content": "特定のディスクデバイス /dev/sdX に対して何らかのアクションを実行する際、udevadm info /dev/sdX コマンドで出力されるユニークかつ永続的なシリアル番号 ID_SERIAL_SHORT を使ってデバイスを指定するには、以下のようなルールを使うことができます。以下はその例です:\n\n```\n/etc/udev/rules.d/69-disk.rules\n```\n\n```\nACTION==\"add\", KERNEL==\"sd[a-z]\", ENV{ID_SERIAL_SHORT}==\"serial_number\", RUN+=\"/path/to/script /dev/%k\"\n```\n\n"
    },
    {
      "title": "USB デバイスでサスペンドから復帰させる",
      "level": 3,
      "content": "udev ルールを用いることで、マウスやキーボードといった USB デバイスの復帰トリガーを有効化して、そのデバイスを使ってシステムをスリープから復帰させることができます。\n\nまず、対象の USB デバイスのベンダー ID とプロダクト ID を調べてください。これらの ID は udev ルール内でデバイスを識別するために使用します。例えば:\n\n```\n$ lsusb | grep Logitech\n```\n\n```\nBus 007 Device 002: ID 046d:c52b Logitech, Inc. Unifying Receiver\n```\n\n次に、以下のコマンドを使ってデバイスの接続先を調べてください:\n\n```\n$ grep c52b /sys/bus/usb/devices/*/idProduct\n```\n\n```\n/sys/bus/usb/devices/1-1.1.1.4/idProduct:c52b\n```\n\n最後に、USB デバイス自体と、USB デバイスの接続先である USB コントローラの power/wakeup 属性をデバイスの接続時に変更するルールを作成してください:\n\n```\n/etc/udev/rules.d/50-wake-on-device.rules\n```\n\n```\nACTION==\"add\", SUBSYSTEM==\"usb\", DRIVERS==\"usb\", ATTRS{idVendor}==\"046d\", ATTRS{idProduct}==\"c52b\", ATTR{power/wakeup}=\"enabled\", ATTR{driver/1-1.1.1.4/power/wakeup}=\"enabled\"\n```\n\n"
    },
    {
      "title": "イベントをトリガーする",
      "level": 3,
      "content": "udev イベントをトリガーすると便利である場合があります。例えば、リモートマシン上の USB デバイスの切断をシミュレートしたい場合などです。そのような場合は udevadm trigger を使ってください:\n\n```\n# udevadm trigger --verbose --type=subsystems --action=remove --subsystem-match=usb --attr-match=\"idVendor=abcd\"\n```\n\nこのコマンドは、ベンダー ID が abcd の全 USB デバイスに対して USB リモートイベントをトリガーします。\n\n"
    },
    {
      "title": "Udev ルールからデスクトップ通知をトリガーする",
      "level": 3,
      "content": "udev ルールからデスクトップ通知をトリガーするには、デスクトップ通知#他のユーザーに通知を送る で説明されているように systemd-run(1) を使用してください:\n\n以下のファイルを作成してください:\n\n```\n/etc/udev/rules.d/99-powersupply_notification.rules\n```\n\n```\n# Rule for when switching to battery\nACTION==\"change\", SUBSYSTEM==\"power_supply\", ATTRS{type}==\"Mains\", ATTRS{online}==\"0\", RUN+=\"/usr/bin/systemd-run --machine=target_user@.host --user notify-send 'Changing Power States' 'Using battery power'\"\n# Rule for when switching to AC\nACTION==\"change\", SUBSYSTEM==\"power_supply\", ATTRS{type}==\"Mains\", ATTRS{online}==\"1\", RUN+=\"/usr/bin/systemd-run --machine=target_user@.host --user notify-send 'Changing Power States' 'Using AC power'\"\n```\n\n複数あるいは長いコマンドを実行するには、実行可能なスクリプトを systemd-run に与えることで可能です:\n\n```\n/usr/local/bin/from_battery.sh\n```\n\n```\n#!/bin/sh\n\npaplay /usr/share/sounds/freedesktop/stereo/power-unplug.oga\nnotify-send --icon=/usr/share/icons/Adwaita/symbolic/legacy/battery-good-symbolic.svg 'Changing Power States' 'Using battery power' --expire-time=4000\n```\n\n"
    },
    {
      "title": "モジュールをブラックリストに追加する",
      "level": 3,
      "content": "稀なケースですが、udev が間違って、誤ったモジュールをロードしてしまうことがあります。間違ったモジュールをロードしないようにするには、モジュールをブラックリストに追加することができます。ブラックリストに追加すると、起動時にも、ホットプラグイベントが発生したとき (USB フラッシュドライブを挿入したときなど) にも、udev はそのモジュールをロードしなくなります。\n\n"
    },
    {
      "title": "デバッグ出力",
      "level": 3,
      "content": "ハードウェアのデバッグ情報を表示するには、udev.log-priority=debug カーネルパラメータを使ってください。あるいは、以下の設定を行うこともできます:\n\n```\n/etc/udev/udev.conf\n```\n\n```\nudev_log=\"debug\"\n```\n\nこのオプションは、mkinitcpio の FILES 配列にこの設定ファイルを追加することで、initramfs 内に組み込むことも可能です:\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nFILES=(... /etc/udev/udev.conf)\n```\n\nmkinitcpio.conf を変更した後は、initramfs を再生成してください。\n\n"
    },
    {
      "title": "起動時に udevd が止まる",
      "level": 3,
      "content": "LDAP に移行したり LDAP を使っているシステムを更新した後 udevd が起動時 \"Starting UDev Daemon\" というメッセージを出したときに止まることがあります。これは通常 udevd が LDAP にある名前を検索しようとして、ネットワークがまだ立ち上がっておらず、失敗していることが原因です。解決方法は全てのシステムグループの名前をローカルで存在させることです。\n\nudev ルールで参照されているグループ名とシステム上に実際に存在しているグループ名を抽出してください:\n\n```\n# grep -Fr GROUP /etc/udev/rules.d/ /usr/lib/udev/rules.d/ | sed 's:.*GROUP=\"\\([-a-z_]\\{1,\\}\\)\".*:\\1:' | sort -u >udev_groups\n# cut -d: -f1 /etc/gshadow /etc/group | sort -u >present_groups\n```\n\n違いを確認するために、side-by-side の diff を実行してください:\n\n```\n# diff -y present_groups udev_groups\n...\nnetwork\t\t\t\t\t\t\t      <\nnobody\t\t\t\t\t\t\t      <\nntp\t\t\t\t\t\t\t      <\noptical\t\t\t\t\t\t\t\toptical\npower\t\t\t\t\t\t\t      |\tpcscd\nrfkill\t\t\t\t\t\t\t      <\nroot\t\t\t\t\t\t\t\troot\nscanner\t\t\t\t\t\t\t\tscanner\nsmmsp\t\t\t\t\t\t\t      <\nstorage\t\t\t\t\t\t\t\tstorage\n...\n```\n\nこの場合、何らかの理由で pcscd グループがシステム上に存在していないことがわかります。欠けているグループを追加してください。また、LDAP よりも前にローカルのリソースを参照するように設定してください。/etc/nsswitch.conf には以下の行が含まれている必要があります:\n\n```\ngroup: files ldap\n```\n\n"
    },
    {
      "title": "リムーバブルデバイスとして扱われなくてはならないデバイスがそう扱われない",
      "level": 3,
      "content": "問題のリムーバブルデバイスに対してカスタムの udev ルールを作成する必要があります。デバイスの不変な情報 (そのデバイスを識別するために利用できる情報) としては、ID_SERIAL や ID_SERIAL_SHORT が使えます (以下の /dev/sdb の部分は必要に応じて変更してください):\n\n```\n$ udevadm info /dev/sdb | grep ID_SERIAL\n```\n\n次に、デバイスが自動マウントされるようにするために UDISKS_AUTO=\"1\" を、デバイスを \"リムーバブル\" として指定するために UDISKS_SYSTEM=\"0\" を設定します。詳細は udisks(8) を見てください。\n\n```\n/etc/udev/rules.d/99-removable.rules\n```\n\n```\nENV{ID_SERIAL_SHORT}==\"serial_number\", ENV{UDISKS_AUTO}=\"1\", ENV{UDISKS_SYSTEM}=\"0\"\n```\n\nudevadm control --reload を実行して udev ルールを再読み込みするのを忘れないでください。次回デバイスを挿入すると、外部ドライブとして扱われます。\n\n"
    },
    {
      "title": "一部のモジュールが自動でロードされず、サウンドの問題が発生する",
      "level": 3,
      "content": "一部のユーザーは、この問題は /etc/modprobe.d/sound.conf の古いエントリが原因であることを突き止めているようです。このファイルの古いエントリをクリーンアップして、問題が発生しないか確かめてください。\n\n"
    },
    {
      "title": "光学ドライブのグループ ID が \"disk\" に設定されている場合",
      "level": 3,
      "content": "光学ドライブのグループIDが disk に設定されており、optical に設定したい場合は、カスタムの udev ルールを作成する必要があります。\n\n```\n/etc/udev/rules.d\n```\n\n```\n# permissions for SCSI CD devices\nSUBSYSTEMS==\"scsi\", KERNEL==\"s[rg][0-9]*\", ATTRS{type}==\"5\", GROUP=\"optical\"\n```\n\n"
    },
    {
      "title": "X サーバーが存在しない場合に RUN ルールの X プログラムがハングする",
      "level": 3,
      "content": "xrandr や他の X ベースのプログラムが X サーバに接続する際に失敗すると、TCP 接続にフォールバックします。しかし、systemd-udev サービスの設定ファイルで IPAddressDeny が設定されているため、ハングしてしまいます。最終的には、プログラムは kill され、イベントの処理が再開されます。\n\n対象のルールが drm デバイスに対するものであり、X サーバが開始されるとハングによってイベントの処理が終わってしまう場合、failed to authenticate magic エラーで 3D アクセラレーションが機能しなくなってしまう可能性があります。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- udev(7)\n- An Introduction to udev\n- Udev メーリングリストの情報\n- Scripting with udev\n- Writing udev rules (日本語訳: udevルールの書き方)\n- LFS 環境のデバイスとモジュールの扱いについて\n- Udev ルールからの GUI の実行とディスプレイ変数へのアクセス\n- openSUSE の udev ドキュメント\n\n"
    }
  ]
}