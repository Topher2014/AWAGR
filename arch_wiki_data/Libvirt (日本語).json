{
  "title": "Libvirt (日本語)",
  "url": "https://wiki.archlinux.org/title/Libvirt_(%E6%97%A5%E6%9C%AC%E8%AA%9E)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- カテゴリ:ハイパーバイザ\n- OVMF による PCI パススルー\n\nLibvirt は、仮想マシンや、ストレージやネットワークインターフェイスの管理などの他の仮想化機能を管理する便利な方法を提供するソフトウェアのコレクションです。これらのソフトウェアには、長期的に安定した C API、デーモン (libvirtd)、およびコマンドラインユーティリティ (virsh) が含まれます。libvirt の主な目標は、KVM/QEMU, Xen, LXC, OpenVZ, VirtualBox ハイパーバイザーなど、複数の異なる仮想化プロバイダー/ハイパーバイザーを管理する単一の方法を提供することです。\n\n- VM 管理: 起動・停止・一時停止・保存・復旧・移行などの様々なドメイン操作。ディスク・ネットワークインターフェイス・メモリ・CPU など多数のデバイスのホットプラグ制御。\n- リモートマシンのサポート: libvirt デーモンが走ってるマシンなら libvirt の機能は全て使うことができます。リモートマシンも例外ではありません。リモートで接続するための様々なネットワーク転送をサポートしています。一番シンプルなのは SSH で、細かい設定を必要としません。\n- ストレージ管理: libvirt デーモンを動かしているホストを使って様々なタイプのストレージを管理できます: 様々なフォーマットのファイルイメージを作成 (qcow2, vmdk, raw, ...)、NFS 共有のマウント、既存の LVM ボリュームグループの列挙、新しい LVM ボリュームグループや論理ボリュームの作成、ディスクデバイスのパーティション、iSCSI 共有のマウントなど。\n- ネットワークインターフェイス管理: libvirt デーモンを動かしているホストを使って物理・論理ネットワークインターフェイスを管理できます。既存のインターフェイスを列挙するだけでなく、インターフェイス・ブリッジ・仮想 LAN・ボンドデバイスを設定 (作成) できます。\n- 仮想 NAT とルートベースネットワーク: libvirt デーモンを動かしているホストを使って仮想ネットワークを管理・作成できます。Libvirt の仮想ネットワークはファイアウォールのルールを使うことでルーターとして動作し、VM からホストマシンのネットワークに透過的にアクセスすることを可能にします。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 インストール 1.1 サーバー 1.2 クライアント\n- 2 設定 2.1 認証を設定 2.1.1 libvirt グループの使用 2.1.2 polkit を使う 2.1.3 ファイルベースのパーミッションで認証 2.2 デーモンを起動 2.3 TCP/IP ソケットの暗号化の解除 2.4 ホストネームを使って仮想マシンにアクセス\n- 3 テスト\n- 4 管理 4.1 virsh 4.2 ストレージプール 4.2.1 virsh を使って新しいプールを作成 4.2.2 virt-manager を使って新しいプールを作成 4.3 ストレージボリューム 4.3.1 virsh を使って新しいボリュームを作成 4.4 ドメイン 4.4.1 virt-install を使って新しいドメインを作成 4.4.2 virt-manager を使って新しいドメインを作成 4.4.3 ドメインの管理 4.5 ネットワーク 4.5.1 ネットワークの管理と変更 4.5.2 IPv6 4.5.3 Macvtap 4.6 スナップショット 4.6.1 スナップショットの作成 4.7 他の管理\n- 5 フック 5.1 フックを作成する 5.1.1 サンプル\n- 6 ホストとゲストの間でデータを共有する 6.1 Virtio-FS 6.2 9p 6.3 Samba / SMB\n- 7 UEFI サポート\n- 8 ヒントとテクニック 8.1 Python 接続コード 8.2 Advanced Format 4K ネイティブディスク 8.3 QEMU のコマンド 8.3.1 QEMU 用の VM XML スキーマを変更する 8.3.2 QEMU コマンドライン引数\n- 9 トラブルシューティング 9.1 システムインスタンスの PulseAudio 9.2 ハイパーバイザーの CPU 使用率 9.3 virt-manager で仮想マシンの一時停止を解除できない 9.4 リダイレクト USB デバイスが virt-manager でグレー表示される 9.5 Error starting domain: Requested operation is not valid 9.6 仮想マネージャーのエラー 'Virt Manager doesn't have search permissions'\n- 10 参照\n\n- 1.1 サーバー\n- 1.2 クライアント\n\n- 2.1 認証を設定 2.1.1 libvirt グループの使用 2.1.2 polkit を使う 2.1.3 ファイルベースのパーミッションで認証\n- 2.2 デーモンを起動\n- 2.3 TCP/IP ソケットの暗号化の解除\n- 2.4 ホストネームを使って仮想マシンにアクセス\n\n- 2.1.1 libvirt グループの使用\n- 2.1.2 polkit を使う\n- 2.1.3 ファイルベースのパーミッションで認証\n\n- 4.1 virsh\n- 4.2 ストレージプール 4.2.1 virsh を使って新しいプールを作成 4.2.2 virt-manager を使って新しいプールを作成\n- 4.3 ストレージボリューム 4.3.1 virsh を使って新しいボリュームを作成\n- 4.4 ドメイン 4.4.1 virt-install を使って新しいドメインを作成 4.4.2 virt-manager を使って新しいドメインを作成 4.4.3 ドメインの管理\n- 4.5 ネットワーク 4.5.1 ネットワークの管理と変更 4.5.2 IPv6 4.5.3 Macvtap\n- 4.6 スナップショット 4.6.1 スナップショットの作成\n- 4.7 他の管理\n\n- 4.2.1 virsh を使って新しいプールを作成\n- 4.2.2 virt-manager を使って新しいプールを作成\n\n- 4.3.1 virsh を使って新しいボリュームを作成\n\n- 4.4.1 virt-install を使って新しいドメインを作成\n- 4.4.2 virt-manager を使って新しいドメインを作成\n- 4.4.3 ドメインの管理\n\n- 4.5.1 ネットワークの管理と変更\n- 4.5.2 IPv6\n- 4.5.3 Macvtap\n\n- 4.6.1 スナップショットの作成\n\n- 5.1 フックを作成する 5.1.1 サンプル\n\n- 5.1.1 サンプル\n\n- 6.1 Virtio-FS\n- 6.2 9p\n- 6.3 Samba / SMB\n\n- 8.1 Python 接続コード\n- 8.2 Advanced Format 4K ネイティブディスク\n- 8.3 QEMU のコマンド 8.3.1 QEMU 用の VM XML スキーマを変更する 8.3.2 QEMU コマンドライン引数\n\n- 8.3.1 QEMU 用の VM XML スキーマを変更する\n- 8.3.2 QEMU コマンドライン引数\n\n- 9.1 システムインスタンスの PulseAudio\n- 9.2 ハイパーバイザーの CPU 使用率\n- 9.3 virt-manager で仮想マシンの一時停止を解除できない\n- 9.4 リダイレクト USB デバイスが virt-manager でグレー表示される\n- 9.5 Error starting domain: Requested operation is not valid\n- 9.6 仮想マネージャーのエラー 'Virt Manager doesn't have search permissions'\n\n"
    },
    {
      "title": "インストール",
      "level": 2,
      "content": "デーモン・クライアントアーキテクチャをとっているため、libvirt をインストールする必要があるのは仮想化システムをホストするマシンだけです。サーバーとクライアントは同じ物理マシンにすることができます。\n\n"
    },
    {
      "title": "サーバー",
      "level": 3,
      "content": "libvirt パッケージと、どれか一つハイパーバイザをインストールしてください:\n\n- libvirt KVM/QEMU ドライバー は基本の libvirt ドライバーなので KVM が有効になっていれば、完全に仮想化された、ハードウェアによる支援を受けたゲストを使うことができます。詳しくは QEMU の記事を見て下さい。\n\n- その他の サポートされるハイパーバイザー には、LXC、VirtualBox、および Xen が含まれます。インストール手順については、それぞれの記事を参照してください。libvirtd のインストールに関するメモ: libvirt LXC ドライバー は、lxc が提供する LXC ユーザー空間ツールに依存していないため、パッケージをインストールする必要はありません。ドライバーの使用を計画している場合。 libvirt-lxc 接続を使用するには、libvirtd が実行されている必要があります。 Xen サポートは利用可能ですが、デフォルトでは利用できません (FS#27356) ABS を使用して libvirt の PKGBUILD を変更し、-Ddriver_libxl=disabled オプションを使用せずにビルドする必要があります。\n\n- libvirt LXC ドライバー は、lxc が提供する LXC ユーザー空間ツールに依存していないため、パッケージをインストールする必要はありません。ドライバーの使用を計画している場合。 libvirt-lxc 接続を使用するには、libvirtd が実行されている必要があります。\n- Xen サポートは利用可能ですが、デフォルトでは利用できません (FS#27356) ABS を使用して libvirt の PKGBUILD を変更し、-Ddriver_libxl=disabled オプションを使用せずにビルドする必要があります。\n\nネットワーク接続のために、以下をインストールします:\n\n- デフォルト NAT/DHCP ネットワーキングの iptables-nft および dnsmasq\n- SSH 経由のリモート管理用の openbsd-netcat\n\n他のオプションの依存関係は、DMI システム情報サポート用の dmidecode など、必要な機能または拡張機能を提供する場合があります。libvirt に対する pacman の出力を読んだ後、必要と思われるものを 依存関係として インストールします。\n\n"
    },
    {
      "title": "クライアント",
      "level": 3,
      "content": "クライアントは仮想マシンを管理するために使用するユーザーインターフェイスです。\n\n- virsh はドメインを管理・設定するためのコマンドラインプログラムです。libvirt パッケージに含まれています。\n- virt-manager は仮想マシンを管理するためのグラフィカルユーザーインターフェイスです。\n- virt-viewer は仮想化されたゲスト OS のグラフィカルな画面を操作するための軽量なインターフェイスです。\n- gnome-boxes はリモートや仮想システムにアクセスするためのシンプルな GNOME 3 アプリケーションです。\n- qt-virt-managerAUR仮想マシンを管理するための Qt アプリケーション。\n- libvirt-sandboxAUR はアプリケーションのサンドボックスツールキットです。\n- cockpit-machines 仮想マシンを管理するためのプラグインを備えた Web ベースのシステム管理ツール。\n\nlibvirt に対応しているソフトウェアのリストは こちら にあります。\n\n"
    },
    {
      "title": "設定",
      "level": 2,
      "content": "システムレベルの管理をする場合、少なくとも、認証を設定して、デーモンを起動する必要があります。\n\n"
    },
    {
      "title": "認証を設定",
      "level": 3,
      "content": "libvirt: Connection authentication より:\n\nlibvirt は依存パッケージとして polkit をインストールするので、unix_sock_auth パラメータのデフォルト値としては polkit が使われます (ソース)。また、ファイルベースのパーミッションを使うこともできます。\n\n"
    },
    {
      "title": "libvirt グループの使用",
      "level": 4,
      "content": "ユーザーが libvirt デーモンにアクセスできるようにする最も簡単な方法は、メンバーを libvirt ユーザーグループ に追加することです。\n\nlibvirt グループのメンバーは、デフォルトで RW デーモンソケットにパスワードなしでアクセスできます。\n\n"
    },
    {
      "title": "polkit を使う",
      "level": 4,
      "content": "libvirt デーモンは /usr/share/polkit-1/actions/org.libvirt.unix.policy で2つの polkit アクションを提供します:\n\n- 完全なアクセス管理のための org.libvirt.unix.manage (RW デーモンソケット)\n- アクセスの監視のための org.libvirt.unix.monitor (読み取り専用ソケット).\n\nRW デーモンソケットのデフォルトポリシーを使うには管理者として認証する必要があります。sudo 認証と似ていますが、クライアントアプリケーションを root で動かす必要があるというわけではありません。また、デフォルトポリシーではどんなアプリケーションでも RO ソケットに接続することはできます。\n\nArch では wheel グループのユーザーを管理者として認識します: これは /etc/polkit-1/rules.d/50-default.rules で定義されています (Polkit#管理者の識別 を参照)。そのためユーザーを wheel グループに追加さえすれば、新しいグループやルールファイルを作成する必要はありません。(virt-manager などで) RW ソケットに接続する時にユーザーのパスワードを入力するように求められます。\n\nlibvirt 1.2.16 から libvirt グループのメンバーはデフォルトで RW デーモンソケットにパスワードを入力しなくてもアクセスすることができます [1]。libvirt グループを作成してユーザーをグループに追加するのが一番簡単です。RW デーモンソケットにアクセスするときに認証するグループを変更したい場合、以下のファイルを作成:\n\n```\n/etc/polkit-1/rules.d/50-libvirt.rules\n```\n\n```\n/* Allow users in kvm group to manage the libvirt\ndaemon without authentication */\npolkit.addRule(function(action, subject) {\n    if (action.id == \"org.libvirt.unix.manage\" &&\n        subject.isInGroup(\"kvm\")) {\n            return polkit.Result.YES;\n    }\n});\n```\n\nそしてユーザーを kvm グループに追加して再ログインしてください。kvm は好きなグループに置き換えることができます。グループが存在することと、ユーザーがグループに属していることを確認してください (詳しくはユーザーとグループを参照) グループの変更を適用するには再ログインが必要です。\n\n"
    },
    {
      "title": "ファイルベースのパーミッションで認証",
      "level": 4,
      "content": "libvirt グループのユーザーが仮想マシンを管理できるようにファイルベースのパーミッションを定義するには、以下の行をアンコメントします:\n\n```\n/etc/libvirt/libvirtd.conf\n```\n\n```\n#unix_sock_group = \"libvirt\"\n#unix_sock_ro_perms = \"0777\"  # set to 0770 to deny non-group libvirt users\n#unix_sock_rw_perms = \"0770\"\n#auth_unix_ro = \"none\"\n#auth_unix_rw = \"none\"\n```\n\nガイドによっては libvirtd の特定のディレクトリのパーミッションを変更すると管理がしやすくなると書かれていることがありますが、パッケージをアップデートする際に変更したパーミッションは元に戻ってしまうので注意してください。システムディレクトリを編集するときは、root ユーザーを使うようにしてください。\n\n"
    },
    {
      "title": "デーモンを起動",
      "level": 3,
      "content": "systemd を使って libvirtd.service と virtlogd.service を起動してください。任意で libvirtd.service を有効化してください。libvirtd.service が有効化された場合、virtlogd.socket と virtlockd.socket も有効化されるため、virtlogd.service を有効化する必要はありません。\n\n"
    },
    {
      "title": "TCP/IP ソケットの暗号化の解除",
      "level": 3,
      "content": "/etc/libvirt/libvirtd.conf を編集:\n\n```\n/etc/libvirt/libvirtd.conf\n```\n\n```\nlisten_tls = 0\nlisten_tcp = 1\nauth_tcp=none\n```\n\nまた、/etc/conf.d/libvirtd を編集してサーバーをリスニングモードで起動する必要があります:\n\n```\n/etc/conf.d/libvirtd\n```\n\n```\nLIBVIRTD_ARGS=\"--listen\"\n```\n\n"
    },
    {
      "title": "ホストネームを使って仮想マシンにアクセス",
      "level": 3,
      "content": "ブリッジネットワークを使ってホストからゲストにアクセスするには、libvirt に含まれている libvirt NSS モジュールを有効にしてください。\n\n/etc/nsswitch.conf を編集:\n\n```\n/etc/nsswitch.conf\n```\n\n```\nhosts: files libvirt dns myhostname\n```\n\n"
    },
    {
      "title": "テスト",
      "level": 2,
      "content": "システムレベルでデーモンが正しく動作しているかテスト:\n\n```\n$ virsh -c qemu:///system\n```\n\nユーザーセッションで libvirt が正しく動作するかテスト:\n\n```\n$ virsh -c qemu:///session\n```\n\n"
    },
    {
      "title": "管理",
      "level": 2,
      "content": "Libvirt の管理は3つのツールで行うことができます: 一つは GUI virt-manager で、二つはコマンドラインツールです: virsh と guestfish (libguestfs に含まれています)。\n\n"
    },
    {
      "title": "virsh",
      "level": 3,
      "content": "virsh はゲストドメイン (仮想マシン) の管理のためのプログラムですが、仮想化管理のスクリプトにも使えます。ほとんどの virsh コマンドは実行するのに root 権限を必要とします。ただしドメインの作成や実行などは (VirtualBox と同じように) 通常ユーザーで実行することができます。\n\nVirsh にはインタラクティブなターミナルが含まれており、コマンドを何も指定しないで実行したときに起動します (オプションは指定することができます): virsh。インタラクティブターミナルはタブ補完をサポートしています。\n\nコマンドラインから:\n\n```\n$ virsh [option] <command> [argument]...\n```\n\nインタラクティブターミナルから:\n\n```\nvirsh # <command> [argument]...\n```\n\nヘルプを見るには:\n\n```\n$ virsh help [option*] or [group-keyword*]\n```\n\n"
    },
    {
      "title": "ストレージプール",
      "level": 3,
      "content": "プールはストレージボリュームを保存しておく場所です。libvirt におけるボリュームは、他のハイパーバイザでは\"仮想ディスク\"または\"仮想マシンイメージ\"と定義されていることがあります。プールの場所はディレクトリでも、ネットワークファイルシステムでも、パーティションでもかまいません (LVM を含む)。プールは有効・無効を切り替えたり領域を予約することができます。\n\nシステムレベルでは、デフォルトで /var/lib/libvirt/images/ が有効になります。ユーザーセッションでは virt-manager は $HOME/VirtualMachines を作成します。\n\n有効または無効なストレージプールを確認:\n\n```\n$ virsh pool-list --all\n```\n\n"
    },
    {
      "title": "virsh を使って新しいプールを作成",
      "level": 4,
      "content": "ストレージプールを追加したい場合、以下がコマンド形式、ディレクトリの追加、LVM ボリュームの追加の例です:\n\n```\n$ virsh pool-define-as name type [source-host] [source-path] [source-dev] [source-name] [<target>] [--source-format format]\n$ virsh pool-define-as poolname dir - - - - /home/username/.local/libvirt/images\n$ virsh pool-define-as poolname fs - -  /dev/vg0/images - mntpoint\n```\n\n上記のコマンドはプールの情報を定義します。ビルドするには:\n\n```\n$ virsh pool-build     poolname\n$ virsh pool-start     poolname\n$ virsh pool-autostart poolname\n```\n\n削除するには:\n\n```\n$ virsh pool-undefine  poolname\n```\n\n- ボリュームグループはストレージプール専用にするほうが良いでしょう。\n- LVM ボリュームグループの名前はプールの名前と変えて下さい。ストレージプールを削除したときに LVM グループも削除されてしまいます。\n\n"
    },
    {
      "title": "virt-manager を使って新しいプールを作成",
      "level": 4,
      "content": "まず、既存のサーバーに接続してください。そこで、右クリックして Details を選んで下さい。Storage に行き左下の + アイコンを押して下さい。それからはウィザードに従って下さい。\n\n"
    },
    {
      "title": "ストレージボリューム",
      "level": 3,
      "content": "プールを作成したら、プールの中にボリュームを作成することができます。新しいドメイン (仮想マシン) を作成する場合、ドメインの作成時にボリュームを作成できるのでこの手順はスキップできます。\n\n"
    },
    {
      "title": "virsh を使って新しいボリュームを作成",
      "level": 4,
      "content": "ボリュームの作成、確認、リサイズ、削除:\n\n```\n$ virsh vol-create-as      poolname volumename 10GiB --format aw|bochs|raw|qcow|qcow2|vmdk\n$ virsh vol-upload  --pool poolname volumename volumepath\n$ virsh vol-list           poolname\n$ virsh vol-resize  --pool poolname volumename 12GiB\n$ virsh vol-delete  --pool poolname volumename\n$ virsh vol-dumpxml --pool poolname volumename  # for details\n```\n\n"
    },
    {
      "title": "ドメイン",
      "level": 3,
      "content": "libvirt では仮想マシンはドメインと呼ばれます。コマンドラインから使う場合、virsh でドメインを確認・作成・停止・シャットダウンできます。virt-viewer を使って virsh で起動したドメインを確認することも可能です。ドメインの作成は virt-manager でグラフィカルに行うか virt-install (virt-install パッケージに含まれているコマンドラインプログラム) を使います。\n\n新しいドメインを作成するときは、インストールメディアを使用します。ドメインの作成後にロードします。ストレージプールから .iso を参照したり、光学ドライブを参照することができます。\n\n有効または無効なドメインを確認:\n\n```\n# virsh list --all\n```\n\n"
    },
    {
      "title": "virt-install を使って新しいドメインを作成",
      "level": 4,
      "content": "ドメイン (仮想マシン) を細かく設定したい場合、virt-manager を使って新しいドメインを作成する方が簡単です。しかしながら、基本的な設定は virt-install で行うことができます。最低でも指定する必要があるのは --name, --memory, ゲストストレージ (--disk, --filesystem または --nodisks), インストール方法 (.iso または CD) です。オプションについて詳しくは virt-install(1) を見てください。\n\nArch Linux のインストール (2GiB, qcow2 フォーマットのボリューム作成; ユーザーネットワーク):\n\n```\n$ virt-install  \\\n  --name arch-linux_testing \\\n  --memory 1024             \\ \n  --vcpus=2,maxvcpus=4      \\\n  --cpu host                \\\n  --cdrom $HOME/Downloads/arch-linux_install.iso \\\n  --disk size=2,format=qcow2 \\\n  --network user            \\\n  --virt-type kvm\n```\n\nFedora testing (Xen ハイパーバイザ, 非デフォルトのプール, オリジナルの表示を使わない):\n\n```\n$ virt-install  \\\n  --connect xen:///     \\\n  --name fedora-testing \\\n  --memory 2048         \\\n  --vcpus=2             \\\n  --cpu=host            \\\n  --cdrom /tmp/fedora20_x84-64.iso      \\\n  --os-type=linux --os-variant=fedora20 \\\n  --disk pool=testing,size=4            \\\n  --network bridge=br0                  \\\n  --graphics=vnc                        \\\n  --noautoconsole\n$ virt-viewer --connect xen:/// fedora-testing\n```\n\nWindows:\n\n```\n$ virt-install \\\n  --name=windows7           \\\n  --memory 2048             \\\n  --cdrom /dev/sr0          \\\n  --os-variant=win7         \\\n  --disk /mnt/storage/domains/windows7.qcow2,size=20GiB \\\n  --network network=vm-net  \\\n  --graphics spice\n```\n\n既存のボリュームをインポート:\n\n```\n$ virt-install  \\\n  --name demo  \\\n  --memory 512 \\\n  --disk /home/user/VMs/mydisk.img \\\n  --import\n```\n\n"
    },
    {
      "title": "virt-manager を使って新しいドメインを作成",
      "level": 4,
      "content": "まずハイパーバイザに接続します (例: QEMU/KVM システムまたはユーザーセッション)。接続を右クリックして New を選択して、ウィザードに従って下さい。\n\n- ステップ4 で、Allocate entire disk now のチェックを外すことができます -- VM がディスクの全てを使用していないときに容量を節約します。ただし、ディスクのフラグメンテーションが増加する可能性があるので、VM ホストのディスクの合計空き容量に注意してください、VM にディスク容量を追加で割り当てるほうが簡単だからです。\n\n- ステップ5 では、Advanced options を開いて Virt Type を kvm に設定してください。追加のハードウェア設定が必要な場合、Customize configuration before install オプションを選んで下さい。\n\n"
    },
    {
      "title": "ドメインの管理",
      "level": 4,
      "content": "ドメインを起動:\n\n```\n$ virsh start domain\n$ virt-viewer --connect qemu:///session domain\n```\n\nドメインを上品にシャットダウン、または強制的にオフにする:\n\n```\n$ virsh shutdown domain\n$ virsh destroy  domain\n```\n\nlibvirtd の起動時にドメインを自動実行:\n\n```\n$ virsh autostart domain\n$ virsh autostart domain --disable\n```\n\nホストのシャットダウン時にドメインもシャットダウン:\n\nドメインの設定を編集:\n\n```\n$ virsh edit domain\n```\n\n"
    },
    {
      "title": "ネットワーク",
      "level": 3,
      "content": "デフォルトでは、libvirtd systemd サービスが起動すると、default という名前の NAT ブリッジが作成されて外部ネットワークに接続できるようになります。\n\n他のネットワーク接続が必要な場合、ドメインとの接続を作成することができる4つのネットワークタイプが存在します:\n\n- bridge — 仮想デバイス。物理インターフェイスと直接データを共有します。ホストで固定ネットワークを使う場合や他のドメインに接続する必要がない場合、またはドメインに完全なインバウンドとアウトバウンドの通信が必要な場合やドメインをシステムレベルで動作させる場合、ブリッジを使って下さい。ブリッジを追加する方法はネットワークブリッジを参照。作成後、ゲストの .xml 設定ファイルで指定する必要があります。\n- network — 仮想ネットワーク。他のドメインと共有することができます。ホストが動的ネットワーク (例: NetworkManager) やワイヤレスを使う場合仮想ネットワークを使って下さい。\n- macvtap — ホストの物理インターフェイスに直接接続。\n- user — ローカルのネットワーク。ユーザーセッションの場合に使って下さい。\n\nvirsh にはネットワークを作成するための様々なオプションが存在していますが、(virt-manager などの) グラフィカルユーザーインターフェイスを使ったり virt-install でドメインを作成するときにネットワーク接続を作成する方が簡単です。\n\n- libvirt は dnsmasq で DHCP や DNS を管理し、仮想ネットワークごとにインスタンスを起動します。また、適切なルーティングが行われるように iptables ルールを追加して、ip_forward カーネルパラメータを有効\n\nにします。libvirt を使うのにホストで dnsmasq を実行する必要はありません (libvirt の dnsmasq インスタンスと干渉する可能性があります)\n\n- デフォルトのネットワークを起動できない場合は、iptables-nft と dnsmasq がインストールされていることを確認してください。\n\nVM の IP アドレスは、次の方法で取得できます (default ネットワークに接続し、dhcp 経由で IP アドレスを受信する場合):\n\n```\n$ virsh net-dhcp-leases default\n```\n\nコマンド (default を VM が接続しているネットワーク名に置き換えます)、または VM で qemu-guest-agent が実行されている場合は、次のようにします:\n\n```\n$ virsh domifaddr --source agent $vm\n```\n\n$vm を実際の仮想マシン名 (またはドメイン ID) に置き換えます。\n\n"
    },
    {
      "title": "ネットワークの管理と変更",
      "level": 4,
      "content": "仮想ネットワークを変更するには、仮想ネットワークの基本的なコマンドラインの使用法 ガイドを読むことを強くお勧めします。 libvirt wiki から。使用方法の詳細については、libvirt Networking wiki を読むことをお勧めします。\n\n"
    },
    {
      "title": "IPv6",
      "level": 4,
      "content": "設定ツールを使って IPv6 アドレスを追加した際に、以下のようなエラーが表示されることがあります:\n\n```\nCheck the host setup: enabling IPv6 forwarding with RA routes without accept_ra set to 2 is likely to cause routes loss. Interfaces to look at: eth0\n```\n\n以下のファイルを作成することで問題を解決できます (eth0 は物理インターフェイスの名前に置き換えてください):\n\n```\n/etc/sysctl.d/libvirt-bridge.conf\n```\n\n```\nnet.ipv6.conf.eth0.accept_ra = 2\n```\n\n設定したらマシンを再起動してください。\n\n"
    },
    {
      "title": "Macvtap",
      "level": 4,
      "content": "macvtap ネットワークを設定するには、まず次のファイルを作成します。\n\n```\nmacvtap.xml\n```\n\n```\n<network>\n  <name>macvtap-net</name>\n  <forward mode='bridge'>\n    <interface dev='eth0'/>\n  </forward>\n</network>\n```\n\n次に、ネットワークを定義して有効にします。\n\n```\n$ virsh net-define macvtap.xml\n$ virsh net-autostart macvtap-net\n$ virsh net-start macvtap-net\n```\n\nこれで、ネットワーク macvtap-net が利用可能になり、再起動しても維持されます。eth0 を介して外部ネットワークにブリッジされます。\n\n"
    },
    {
      "title": "スナップショット",
      "level": 3,
      "content": "スナップショットは現時点でのドメインのディスク・メモリ・デバイスの状態を取得して、将来のために保存します。OS の\"クリーン\"なコピーを保存することから、ドメインが破壊される前にドメインの状態を保存することまで、様々な理由で使われます。スナップショットは一意な名前で識別されます。\n\nスナップショットはボリュームの中に保存されるためボリュームが次の形式である必要があります: qcow2 または raw。スナップショットは差分を使用するので大量の容量を使用することはありません。\n\n"
    },
    {
      "title": "スナップショットの作成",
      "level": 4,
      "content": "スナップショットが取得されると新しいブロックデバイスとして保存されオリジナルのスナップショットはオフラインになります。スナップショットは他のスナップショットから選択したりマージすることができます (ドメインをシャットダウンする必要はありません)。\n\n動作中のドメインのボリュームを確認 (動作中のドメインは virsh list で確認できます):\n\n```\n# virsh domblklist domain\n```\n\n```\nTarget     Source\n ------------------------------------------------\n vda        /vms/domain.img\n```\n\nボリュームの物理プロパティを確認するには:\n\n```\n# qemu-img info /vms/domain.img\n```\n\n```\nimage: /vms/domain.img\n file format: qcow2\n virtual size: 50G (53687091200 bytes)\n disk size: 2.1G\n cluster_size: 65536\n```\n\ndisk-only スナップショットを作成 (--atomic オプションはスナップショットの作成が失敗した場合にボリュームに変更が加わっていないことを確認します):\n\n```\n# virsh snapshot-create-as domain snapshot1 --disk-only --atomic\n```\n\nスナップショットを確認:\n\n```\n# virsh snapshot-list domain\n```\n\n```\nName                 Creation Time             State\n ------------------------------------------------------------\n snapshot1           2012-10-21 17:12:57 -0700 disk-snapshot\n```\n\ncp -sparse=true や rsync -S を使ってオリジナルのイメージをコピーしてオリジナルのイメージをスナップショットにマージできます:\n\n```\n# virsh blockpull --domain domain --path /vms/domain.snapshot1\n```\n\ndomain.snapshot1 が新しいボリュームになります。マージが完了したらオリジナルのボリューム (domain.img とスナップショットのメタデータは削除できます。virsh blockcommit が blockpull と反対の動作をするようになる予定ですが現在開発中です (snapshot-revert 機能を含む、来年リリース予定)。\n\n"
    },
    {
      "title": "他の管理",
      "level": 3,
      "content": "非デフォルトのハイパーバイザに接続:\n\n```\n$ virsh --connect xen:///\nvirsh # uri\nxen:///\n```\n\nSSH で QEMU ハイパーバイザに接続してログイン:\n\n```\n$ virsh --connect qemu+ssh://username@host/system\n$ LIBVIRT_DEBUG=1 virsh --connect qemu+ssh://username@host/system\n```\n\nSSH でグラフィカルコンソールに接続:\n\n```\n$ virt-viewer  --connect qemu+ssh://username@host/system domain\n$ virt-manager --connect qemu+ssh://username@host/system domain\n```\n\nVirtualBox ハイパーバイザに接続 (libvirt における VirtualBox のサポートはまだ安定していないため libvirtd がクラッシュする可能性があります):\n\n```\n$ virsh --connect vbox:///system\n```\n\nネットワークの設定:\n\n```\n$ virsh -c qemu:///system net-list --all\n$ virsh -c qemu:///system net-dumpxml default\n```\n\n"
    },
    {
      "title": "フック",
      "level": 2,
      "content": "フックは、libvirt デーモンの起動および実行中に発生するさまざまなイベントによってトリガーされるスクリプトです。 これらは、ネットワークのセットアップやメモリの予約など、ゲストの起動の準備に必要なコマンドを実行するために使用できます。\n\n次のフックが存在します:\n\n- daemon - トリガー: 開始、シャットダウン、リロード\n- qemu - トリガー: 準備、準備、開始、開始、停止、リリース、移行、復元、再接続、接続\n- lxc - トリガー: 準備、開始、開始、停止、解放、再接続\n- libxl - トリガー: 準備、開始、開始、停止、リリース移行、再接続\n- network - トリガー: 開始、開始、停止、ポート作成、更新、ポート削除\n\n各フックとトリガーの詳細については、libvirt ドキュメント を参照してください。\n\n"
    },
    {
      "title": "フックを作成する",
      "level": 3,
      "content": "フックは、/etc/libvirt/hooks にあるスクリプトによって表されます。フォルダーが存在しない場合は、作成する必要があります。 各フックは、同じ名前のこのフォルダー (例: /etc/libvirt/hooks/qemu) またはサブフォルダー (例: /etc/libvirt/hooks/qemu.d/) 後者にはさまざまなスクリプトを含めることができ、それらはすべてトリガーポイントで実行されます。スクリプトは他のスクリプトと同様に実行されるため、使用するコマンドインタープリタの宣言から開始する必要があります (例: #!/bin/bash) スクリプトは libvirt ユーザー (chown +x /etc/libvirt/hooks/qemu) によって実行可能である必要があります。\n\nトリガー ポイントが満たされるたびに、スクリプトが実行されます。たとえば、デーモンスクリプトは、システムの起動/停止サイクルで、起動時とシャットダウン時に少なくとも 2 回実行されます。特定の時点でのみコマンドを実行するには、スクリプトに条件を実装する必要があります。これを行うために、libvirt は現在のトリガー条件を識別するために使用できるパラメーターを渡します。\n\nlibvirt のドキュメントによると、これらのパラメータは次のように定義されています:\n\n- パラメータ 1: 操作に関与するオブジェクトの名前\n- パラメータ 2: 実行される操作の名前\n- パラメータ 3: サブオペレーションに名前を付ける場合に使用されます\n- パラメータ 4: 必要に応じて追加の引数\n\n引数のいずれかが適用できない場合は、ダッシュが渡されます。\n\n"
    },
    {
      "title": "サンプル",
      "level": 4,
      "content": "qemu ゲストを起動するたびに、リソースが割り当てられる前にコマンドを実行するには、qemu フックを使用します。この時点で、libvirt は次のようにフックを実行します: /etc/libvirt/hooks/qemu <guest_name> prepare begin - このスクリプトは次のようになります:\n\n```\n/etc/libvirt/hooks/qemu\n```\n\n```\n#!/bin/bash\nguest_name=\"$1\"\nlibvirt_task=\"$2\"\nif [ \"$libvirt_task\" = \"prepare\" ]; then\n\t<run some important code here>\nfi\n```\n\nゲストが停止している場合、同じスクリプトが実行されますが、今回はデーモンが次のようなコマンドを開始します: /etc/libvirt/hooks/qemu <guest_name> stop end -\n\n"
    },
    {
      "title": "Virtio-FS",
      "level": 3,
      "content": "ここでは、hugepages を使用して共有フォルダーを利用できるようにする方法を説明します。Virtio-FS とのファイル共有 には、ゲストとのファイル共有を有効にするためにサポートされているオプションの概要がリストされています。\n\nまず、仮想マシンで使用される Hugepages を有効にする 必要があります:\n\n```\n/etc/sysctl.d/40-hugepage.conf\n```\n\n```\nvm.nr_hugepages = nr_hugepages\n```\n\n必要なヒュージページの数を決定するには、hugepage のサイズを確認します:\n\n```\n$ grep Hugepagesize /proc/meminfo\n```\n\nhugepage の数は 仮想マシンのメモリサイズ / Hugepagesize です。この値にいくつかのページを追加します。hugepage が割り当てられるように、この手順の後に再起動する必要があります。\n\n次に、仮想マシンの設定を準備する必要があります:\n\n```\n# virsh edit name_of_virtual_machine\n```\n\n```\n<domain>\n...\n  <memoryBacking>\n    <hugepages/>\n  </memoryBacking>\n...\n  <cpu ...>\n    <numa>\n      <cell memory='memory size of virtual machine' unit='KiB' memAccess='shared'/>\n    </numa>\n  </cpu>\n...\n  <devices>\n    ...\n    <filesystem type='mount' accessmode='passthrough'>\n      <driver type='virtiofs'/>\n      <source dir='path to source folder on host'/>\n      <target dir='mount_tag'/>\n    </filesystem>\n    ...\n  </devices>\n</domain>\n```\n\nメモリアクセスを共有として宣言できるように、NUMA 定義を追加する必要があります。NUMA の id および cpus 値は、virsh によって挿入されます。\n\nこれで、共有マシンにフォルダーをマウントできるようになります:\n\n```\n# mount -t virtiofs mount_tag /mnt/mount/path\n```\n\n次の fstab エントリを追加して、起動時にフォルダーを自動的にマウントします:\n\n```\n/etc/fstab\n```\n\n```\n...\nmount_tag /mnt/mount/path virtiofs rw,noatime,_netdev 0 0\n```\n\n"
    },
    {
      "title": "9p",
      "level": 3,
      "content": "ファイルシステムディレクトリは、9P プロトコル を使用して共有できます。詳細は QEMU の 9psetup ドキュメント で参照できます。\n\n次のように仮想マシンを設定します。\n\n```\n<domain>\n...\n  <devices>\n    ...\n    <filesystem type=\"mount\" accessmode=\"mapped\">\n      <source dir=\"/path/on/host\"/>\n      <target dir=\"mount_tag\"/>\n    </filesystem>\n  </devices>\n</domain>\n```\n\nゲストを起動し、次のコマンドを使用してゲストから共有ディレクトリを マウント します:\n\n```\n# mount -t 9p -o trans=virtio,version=9p2000.L mount_tag /path/to/mount_point/on/guest\n```\n\nその他のマウントオプションについては、https://docs.kernel.org/filesystems/9p.html を参照してください。\n\n起動時にマウントするには、ゲストの fstab に追加します:\n\n```\n/etc/fstab\n```\n\n```\n...\nmount_tag\t/path/to/mount_point/on/guest\t9p\ttrans=virtio,version=9p2000.L\t0 0\n```\n\n9p トランスポートのモジュール (つまり、trans=virtio の 9pnet_virtio) は自動的にロードされないため、ファイルシステムを /etc/fstab からのマウントすると失敗し、9pnet: Could not find request Transport: virtio のようなエラーが発生します。解決策は、ブート中にモジュールをプリロード することです:\n\n```\n/etc/modules-load.d/9pnet_virtio.conf\n```\n\n```\n9pnet_virtio\n```\n\n"
    },
    {
      "title": "Samba / SMB",
      "level": 3,
      "content": "ゲストとホスト間でデータを共有するもう 1 つの簡単な方法は、smb プロトコルを使用することです。パフォーマンスと遅延は、説明されている他の方法ほど良くないかもしれませんが、画像やドキュメントなどの単純なファイルをゲストとの間で転送するなどの単純なタスクには十分です。\n\nsmb サーバーは、Samba などを使用してホストまたはゲストのいずれかに直接セットアップできるため、専用のファイルサーバーは必要ありません。Windows ゲストには、インストール直後に含まれる SMB 共有を作成する機能があります (Microsoft サポートページ)\n\nLinux で (サーバーをインストールした場所に応じてホストまたはゲストから) 共有にアクセスする方法の 1 つは、fstab にエントリを作成することです。samba パッケージが必要です。\n\n```\n/etc/fstab\n```\n\n```\n#Accessing a samba share on my vm from the host\n//my_vm/my_share /home/archuser/my_vm cifs _netdev,noauto,nofail,user,credentials=/home/archuser/.config/my_vm.key,gid=1000,uid=984 0 0\n```\n\n_netdev,noauto,nofail は、VM が起動していない場合でも問題が発生することなく、必要な場合にのみ共有がマウントされるようにします。user,credentials=/home/user/.config/my_vm.key,gid=1000,uid=984 を使用すると、パスワードを必要とせず 最初にアクセスするときにオンザフライで共有をマウントできます。\n\n"
    },
    {
      "title": "UEFI サポート",
      "level": 2,
      "content": "Libvirt は QEMU と OVMF で UEFI 仮想マシンをサポートしています。\n\nedk2-ovmf パッケージをインストールしてください。\n\nその後 libvirtd を再起動してください。\n\nこれで UEFI 仮想マシンを作成する準備が整いました。virt-manager で新しい仮想マシンを作成してください。'新しい仮想マシンの作成' ウィザードの最後のページで、以下のようにしてください:\n\n- 'インストールの前に設定をカスタマイズする' をクリックして '完了' を選択してください。\n- '概要' タブで 'ファームウェア' フィールドを変更して 'UEFI x86_64' オプションを選択してください。\n- 'インストールの開始' をクリックしてください。\n- 起動画面で linuxefi コマンドによってインストーラーが起動され、システムの中で efibootmgr を実行することで UEFI OS が実行していることが確認できます。\n\n詳しくは fedora の wiki ページ を参照。\n\n"
    },
    {
      "title": "Python 接続コード",
      "level": 3,
      "content": "libvirt-python パッケージによって /usr/lib/python2.7/site-packages/libvirt.py に python2 API が提供されます。\n\n一般的なサンプルは /usr/share/doc/libvirt-python-your_libvirt_version/examples/ にあります。\n\nqemu と openssh を使う非公式のサンプル:\n\n```\n#! /usr/bin/env python2\n# -*- coding: utf-8 -*-\nimport socket\nimport sys\nimport libvirt\nif (__name__ == \"__main__\"):\n   conn = libvirt.open(\"qemu+ssh://xxx/system\")\n   print \"Trying to find node on xxx\"\n   domains = conn.listDomainsID()\n   for domainID in domains:\n       domConnect = conn.lookupByID(domainID)\n       if domConnect.name() == 'xxx-node':\n           print \"Found shared node on xxx with ID \" + str(domainID)\n           domServ = domConnect\n           break\n```\n\n"
    },
    {
      "title": "Advanced Format 4K ネイティブディスク",
      "level": 3,
      "content": "ディスクを Advanced Format 4Kn ディスクにするには、物理​​セクターサイズと論理セクターサイズの両方を 4 KiB に設定する必要があります。virtio-blk および virtio-scsi の場合、これは、<blockio> element 例えば:\n\n```\n# virsh edit name_of_virtual_machine\n```\n\n```\n<domain>\n  ...\n  <devices>\n    ...\n    <disk type='file' device='disk'>\n      ..\n      <blockio logical_block_size='4096' physical_block_size='4096'/>\n    </disk>\n    ...\n  </devices>\n</domain>\n```\n\n"
    },
    {
      "title": "QEMU のコマンド",
      "level": 3,
      "content": "Libvirt は、VM を実行している基盤となる QEMU インスタンスに QEMU コマンド ライン引数を渡すことができます。 この機能は、libvirt が QEMU 機能 を (まだ) 提供していない場合に非常に役立ちます。例については、Intel GVT-g の記事全体を参照してください。\n\n"
    },
    {
      "title": "QEMU 用の VM XML スキーマを変更する",
      "level": 4,
      "content": "これは、QEMU 固有の要素を有効にするために機能します。\n\n```\n$ virsh edit vmname\n```\n\n```\n<domain type='kvm'>\n```\n\nから\n\n```\n$ virsh edit vmname\n```\n\n```\n<domain xmlns:qemu='http://libvirt.org/schemas/domain/qemu/1.0' type='kvm'>\n```\n\n"
    },
    {
      "title": "QEMU コマンドライン引数",
      "level": 4,
      "content": "libvirt では、空白で区切られた QEMU コマンドライン引数を個別に指定する必要があります。\n\nそれらを挿入する正しい場所は、<domain> 要素の最後、つまり </domain> 終了タグの真上です。\n\n```\n-display gtk,gl=es,zoom-to-fit=off\n```\n\nになります。\n\n```\n$ virsh edit vmname\n```\n\n```\n...\n  </devices>\n  <qemu:commandline>\n    <qemu:arg value=\"-display\"/>\n    <qemu:arg value=\"gtk,gl=es,zoom-to-fit=off\"/>\n  </qemu:commandline>\n</domain>\n```\n\n"
    },
    {
      "title": "システムインスタンスの PulseAudio",
      "level": 3,
      "content": "PulseAudio デーモンは通常のユーザーアカウントで動作し、同じユーザーからの接続だけを許可します。libvirt を使って root で QEMU を動作させた場合は困ることになります。通常ユーザーで QEMU を動作させるには /etc/libvirt/qemu.conf を編集して user オプションでユーザー名を指定してください:\n\n```\nuser = \"dave\"\n```\n\nまた、PulseAudio バックエンドを使用してサーバーに接続するように QEMU を設定する必要があります。virsh edit を使ってデーモンの設定に以下のセクションを追加してください:\n\n```\n<qemu:commandline>\n   <qemu:env name='QEMU_AUDIO_DRV' value='pa'/>\n   <qemu:env name='QEMU_PA_SERVER' value='/run/user/1000/pulse/native'/>\n </qemu:commandline>\n```\n\n1000 はあなたのユーザー ID に置き換えてください。\n\n遅延設定 (マイクロ秒単位) は省略できますが、デフォルトを使用するとパチパチ音が発生する可能性があります。\n\n"
    },
    {
      "title": "ハイパーバイザーの CPU 使用率",
      "level": 3,
      "content": "virt-manager によって生成されたデフォルトの VM 構成では、QEMU プロセスによって CPU 使用率がかなり高くなる (10 〜 20%) 可能性があります。 VM をヘッドレスモードで実行する予定がある場合は、不要なデバイスの一部を削除することを検討してください。\n\n"
    },
    {
      "title": "virt-manager で仮想マシンの一時停止を解除できない",
      "level": 3,
      "content": "qcow2 などのディスクイメージ形式を使用している場合は、指定された仮想容量があり、必要なものだけを保存するため、ホストパーティションにイメージ用のスペースが必要です。VM を起動しようとしたときに I/O 関連のエラーが発生した場合は、仮想ディスクイメージを保持するホストパーティションがいっぱいである可能性があります。ホスト上で df -h を実行すると、利用可能な空き領域の量を確認できます。\n\nこの場合、スペースを解放する方法については、システムメンテナンス#ファイルシステムの掃除を参照してください。\n\n"
    },
    {
      "title": "リダイレクト USB デバイスが virt-manager でグレー表示される",
      "level": 3,
      "content": "USB デバイスのリダイレクト メニュー項目がグレー表示されている場合は、次のハードウェアが VM 用に設定されていることを確認してください:\n\n- USB コントローラー\n- 1 つ以上の USB リダイレクタ\n\n"
    },
    {
      "title": "Error starting domain: Requested operation is not valid",
      "level": 3,
      "content": "仮想マシンを開こうとすると、このエラーがポップアップ表示される場合があります。これは、既存の仮想マシンを開こうとすると、libvirt が使用できないデフォルトのネットワークを検索しようとするためです。これを利用できるようにするには、ネットワークインターフェイスを自動起動して、コンピュータを再起動するたびにネットワークインターフェイスが常にアクティブになるようにする必要があります。libvirt ネットワーキングページ を参照してください。\n\n次のコマンドを使用して、ネットワークインターフェイスの名前を確認します:\n\n```\n# virsh net-list --all\n```\n\nネットワークインターフェースを自動起動するには:\n\n```\n# virsh net-autostart name_of_the_network\n```\n\nネットワークインターフェースを起動するには:\n\n```\n# virsh net-start name_of_the_network\n```\n\n"
    },
    {
      "title": "仮想マネージャーのエラー 'Virt Manager doesn't have search permissions'",
      "level": 3,
      "content": "仮想マシンファイルとインストール ISO が含まれるフォルダーが libvirt-qemu グループによって所有されていることを確認してください。\n\n```\n$ sudo chown -R $USER:libvirt-qemu /path/to/virtual/machine\n```\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- libvirt 公式ウェブサイト\n- Red Hat の仮想化の導入および管理ガイド\n- Red Hat の仮想化のチューニングと最適化ガイド\n- Slackware KVM and libvirt\n- IBM KVM\n- libvirt Networking Handbook\n\n"
    }
  ]
}