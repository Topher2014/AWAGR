{
  "title": "Dependência",
  "url": "https://wiki.archlinux.org/title/Depend%C3%AAncia",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Artigos relacionados\n\n- Diretrizes de empacotamento do Arch\n- Criando pacotes\n- .SRCINFO\n- Arch User Repository\n- Category:Package development (Português)\n- Sistema de compilação do Arch\n- makepkg\n\nEsse artigo discute variáveis definíveis pelo mantenedor em um PKGBUILD. Para informações sobre funções do PKGBUILD e criação de pacotes em geral, veja Criando pacotes. Leia também PKGBUILD(5).\n\nUm PKGBUILD é um script shell contendo as informações de compilação necessárias por pacotes do Arch Linux.\n\nPacotes no Arch Linux são compilados usando o utilitário makepkg. Quando makepkg é executado, ele pesquisa por um arquivo PKGBUILD no diretório atual e segue as instruções dele para compilar ou obter os arquivos para compilar um pacote (pkgname.pkg.tar.zst). O pacote resultante contém arquivos binários e instruções de instalação, prontos para serem instalados com pacman.\n\nVariáveis obrigatórias são pkgname, pkgver, pkgrel e arch. license não é estritamente necessária para compilar um pacote, mas é recomendada para qualquer PKGBUILD compartilhado com outras pessoas, já que makepkg vai produzir um aviso se não estiver presente.\n\nÉ uma prática comum definir as variáveis no PKGBUILD da mesma forma dadas aqui. Porém, isso não é obrigatório, desde que a sintaxe Bash correta seja usada.\n\n- Use namcap para verificar PKGBUILDs por erros comuns de empacotamento.\n- termux-language-serverAUR fornece um servidor de idiomas para PKGBUILD, makepkg.conf, etc.\n\n"
    },
    {
      "title": "pkgbase",
      "level": 3,
      "content": "Ao compilar pacotes comuns, esta variável não deve ser explicitamente declarada no PKGBUILD: seu valor é padronizado para o do #pkgname.\n\nAo criar um pacote dividido (split package, em inglês), essa variável pode ser usada para especificar explicitamente o nome a ser usado para se referir ao grupo de pacotes na saída de makepkg e na nomeação de tarballs somente de origem. O valor não é permitido para começar com um hífen. Se não for especificado, o valor será o padrão para o primeiro elemento no vetor pkgname.\n\nTodas opções e diretivas para pacotes divididos têm como padrão os valores globais definidos no PKGBUILD. Mesmo assim, os seguintes podem ser sobrescritos dentro de cada função de empacotameto do pacote dividido: #pkgdesc, #arch, #url, #license, #groups, #depends, #optdepends, #provides, #conflicts, #replaces, #backup, #options, #install e #changelog.\n\n"
    },
    {
      "title": "pkgname",
      "level": 3,
      "content": "O nome do pacote (por exemplo, pkgname='foo') ou, para pacotes divididos, um vetor de nomes (por exemplo, pkgname=('foo' 'bar')). Nomes não podem iniciar com hífenes. Por uma questão de consistência, pkgname deve corresponder ao nome do tarball fonte do software: por exemplo, se o software está em foobar-2.5.tar.gz, use pkgname=foobar.\n\n"
    },
    {
      "title": "pkgver",
      "level": 3,
      "content": "A versão do pacote. Ela deve ser a mesma que a versão publicada pelo autor do software upstream. Ela pode conter letras, números, pontos e sublinhados, mas não um hífen (-). Se o autor do software usa um hífen, substitua-o com um sublinhado (_). Se a variável pkgver é usada posteriormente no PKGBUILD, então o sublinhado pode ser facilmente substituído por um hífen, ex.: source=(\"$pkgname-${pkgver//_/-}.tar.gz\").\n\n- A ordem de valores incomuns pode ser testada com vercmp, que é fornecido pelo pacote pacman.\n- makepkg pode atualizar automaticamente essa variável definindo uma função pkgver() no PKGBUILD. Veja Diretrizes de pacotes VCS#A função pkgver() para detalhes.\n\n"
    },
    {
      "title": "pkgrel",
      "level": 3,
      "content": "O número de lançamento. Geralmente é um número inteiro positivo que permite diferenciar entre compilações consecutivas da mesma versão de um pacote. Na medida em que correções e funcionalidades adicionais são adicionadas ao PKGBUILD que influencie no pacote resultante, pkgrel deve ser incrementado em 1. Quando uma nova versão do software é lançada, esse valor deve ser redefinido para 1. Em casos excepcionais, outros formatos podem ser encontrados em uso, como em maior.menor.\n\n"
    },
    {
      "title": "epoch",
      "level": 3,
      "content": "Usado para forçar o pacote a ser visto como mais novo do que uma versão anterior com um epoch menor. Esse valor tem que ser um inteiro não negativo; o padrão é 0. É usado quando o esquema de numeração de versão de um pacote muda (ou é alfanumérico), quebrando a lógica de comparação de versão normal. Por exemplo:\n\n```\npkgver=5.13\npkgrel=2\nepoch=1\n```\n\n```\n1:5.13-2\n```\n\nVeja pacman(8) para mais informações sobre comparações de versão.\n\n"
    },
    {
      "title": "pkgdesc",
      "level": 3,
      "content": "A descrição do pacote. É recomendado no máximo 80 caracteres e não deve incluir o nome do pacote em uma forma autorreferenciativa, a menos que o nome do aplicativo seja diferente do nome do pacote. Por exemplo, use pkgdesc=\"Text editor for X11\" em vez de pkgdesc=\"Nedit is a text editor for X11\".\n\nTambém é importante usar palavras-chaves com sabedoria para aumentar as chances de aparecer em consultas de pesquisas relevantes.\n\n"
    },
    {
      "title": "arch",
      "level": 3,
      "content": "Um vetor de arquiteturas nas quais o PKGBUILD deve poder ser compilado e funcionar. Arch oferece suporte oficialmente apenas x86_64, mas outros projetos podem oferecer suporte a outras arquiteturas. Por exemplo, Arch Linux 32 fornece suporte a i686 e pentium4, e Arch Linux ARM fornece suporte a armv7h (armv7 hardfloat) e aarch64 (armv8 64-bit).\n\nHá dois tipos de valores que o vetor pode usar:\n\n- arch=('any') indica que o pacote pode ser compilado em uma arquitetura e, após compilado, independe da arquitetura em seu estado compilado (geralmente shell scripts, fontes, tema, muitos tipos de extensões etc.).\n- arch=(...) com uma ou mais arquiteturas (exceto any) indica que o pacote pode ser compilado para qualquer uma das arquiteturas especificadas, mas é específico da arquitetura depois de compilado. Para esses pacotes, especifique todas as arquiteturas as quais o PKGBUILD oficialmente possui suporte. Para repositórios oficiais e pacotes AUR, isso significa arch=('x86_64'). Opcionalmente, os pacotes AUR podem optar por ter suporte adicional a outras arquiteturas que sabe-se que funcionam.\n\nA arquitetura alvo pode ser acessada com a variável $CARCH durante uma compilação.\n\n"
    },
    {
      "title": "url",
      "level": 3,
      "content": "A URL do site oficial do software sendo empacotado.\n\n"
    },
    {
      "title": "license",
      "level": 3,
      "content": "A licença sob a qual o software é distribuído. Arch Linux usa Identificadores de licença SPDX. Cada licença deve ter uma entrada correspondente em /usr/share/licenses/.\n\nPara licenças comuns (como 'GPL-3-or-later'), o pacote licenses entrega todos os arquivos correspondentes. O pacote é instalado por padrão, pois é uma dependência do metapacote base, e os arquivos podem ser encontrados em /usr/share/licenses/common/. Basta consultar a licença usando seu identificador de licença SPDX na lista de identificadores SPDX.\n\nFamílias de licenças como BSD ou MIT não são, estritamente falando, uma única licença e cada instância requer um arquivo de licença separado. Na variável license, consulte-as usando um identificador SPDX comum (por exemplo, 'BSD-3-Clause' ou 'MIT'), mas depois forneça o arquivo correspondente como se fosse uma licença personalizada.\n\nPara licenças personalizadas, o identificador deve ser LicenseRef-license-name ou custom:license-name, se não estiverem cobertos pelas famílias comuns mencionadas acima. O texto da licença correspondente deve ser colocado no diretório /usr/share/licenses/pkgname. Para instalar o arquivo, um trecho de código a seguir pode ser usado na seção package():\n\n```\ninstall -Dm644 LICENSE \"$pkgdir/usr/share/licenses/$pkgname/LICENSE\"\n```\n\nCombinar várias licenças ou adicionar exceções deve seguir a sintaxe SPDX. Por exemplo, um pacote lançado sob a GNU/GPL 2.0 ou GNU/LGPL 2.1 poderia usar 'GPL-2.0-or-later OR LGPL-2.1-or-later', enquanto um pacote lançado no Apache 2.0 com exceção LLVM: 'Apache-2.0 WITH LLVM-exception'. Observe que esta deve ser uma única string, portanto, toda a expressão deve ser colocada entre aspas. Até novembro de 2023, lista de exceções SPDX é limitada, então geralmente a rota de licença personalizada deve ser usada.\n\nSe forem encontrados problemas com identificadores SPDX, durante o período de transição usar identificadores antigos – nomes dos diretórios em /usr/share/licenses/common – é aceitável.\n\nVeja também Diretrizes de pacotes de aplicativos não livres (nonfree).\n\nInformações e perspectivas adicionais sobre licenças de software aberto e livre podem ser encontradas nas seguintes páginas:\n\n- Wikipedia:pt:Licença de software livre\n- Wikipedia:Comparison of free and open-source software licenses\n- A Legal Issues Primer for Open Source and Free Software Projects\n- Projeto GNU - Várias licenças e comentários sobre elas\n- Debian - License information\n- Open Source Initiative - Licenses by Name\n\n"
    },
    {
      "title": "groups",
      "level": 3,
      "content": "O grupo ao qual o pacote pertence. Por exemplo, ao instalar o plasma, ele instala todos os pacotes pertencentes àquele grupo.\n\n"
    },
    {
      "title": "depends",
      "level": 3,
      "content": "Um vetor de pacotes que devem ser instalados para o software compilar e executar. Dependências definidas dentro da função package() são necessárias apenas para executar o software.\n\nRestrições de versões podem ser especificadas com operadores de comparação, como, por exemplo, depends=('foobar>=1.8.0'); se múltiplas restrições forem necessárias, a dependência pode ser repetida para cada uma, como, por exemplo, depends=('foobar>=1.8.0' 'foobar<2.0.0').\n\nNote: **This article or section is a candidate for merging with Diretrizes de pacotes do Arch.** This article or section is a candidate for merging with Diretrizes de pacotes do Arch.\n\nThis article or section is a candidate for merging with Diretrizes de pacotes do Arch.\n\nO vetor depends deve listar todas as dependências diretas de primeiro nível, mesmo quando algumas já são declaradas transitivamente. Por exemplo, se um pacote foo depende de tanto bar quanto baz, e o pacote bar depende de baz também, acabará levando a um comportamento indesejado se bar parar de depender de baz. O pacman não aplicará a instalação de baz em sistemas que instalaram recentemente o pacote foo ou limparam pacotes órfãos, e o foo falhará durante a execução ou se comportará mal.\n\nEm alguns casos, isso não é necessário e pode ou não estar listado, por exemplo, glibc não pode ser desinstalado, pois todo sistema precisa de alguma biblioteca C ou python para um pacote que já depende de outro módulo python-, pois o segundo módulo deve, por definição, depender de python e não pode parar de puxá-lo como uma dependência.\n\nAs dependências normalmente devem incluir os requisitos para criar todos os recursos opcionais de um pacote. Como alternativa, qualquer recurso cujas dependências não estejam incluídas deve ser explicitamente desabilitado por meio de uma opção de configuração. A falha em fazer isso pode levar a pacotes com recursos opcionais em tempo de compilação por \"dependências automágicas\" que são imprevisivelmente ativados devido a dependências transitivas ou softwares não relacionados instalados na máquina de compilação, mas que não são refletidas nas dependências do pacote.\n\nSe o nome da dependência parece ser uma biblioteca, como, por exemplo, depends=('libfoobar.so'), makepkg vai tentar localizar um binário que depende da biblioteca no pacote compilado e anexar a versão de soname necessária pelo binário. Anexar você mesmo a versão desabilita a detecção automática, como, por exemplo, depends=('libfoobar.so=2').\n\n"
    },
    {
      "title": "makedepends",
      "level": 3,
      "content": "Um vetor de pacotes que são necessários apenas para compilar o pacote. A versão mínima de dependência pode ser especificada no mesmo formato que no vetor depends. Os pacotes no vetor depends são implicitamente necessários para compilar o pacote, então eles não devem ser duplicados aqui.\n\nNote: **não devem** \n\n- Presume-se que o pacote base-devel já esteja instalado ao compilar com makepkg. As dependências deste pacote não devem ser incluídas no vetor makedepends.\n- Se estiver usando Fontes VCS, não se esqueça de incluir a ferramenta VCS apropriada (git, subversion, cvs , ...).\n\n"
    },
    {
      "title": "checkdepends",
      "level": 3,
      "content": "Um vetor de pacotes dos quais o software depende para executar sua suíte de testes, mas que não são necessários em tempo de execução. Pacotes nesta lista seguem o mesmo formato que depends. Essas dependências são consideradas apenas quando a função check() estiver presente e for ser executada pelo makepkg.\n\nNote: **não devem** \n\n"
    },
    {
      "title": "optdepends",
      "level": 3,
      "content": "Um vetor de pacotes que não são necessários pelo software para funcionar, mas fornecem funcionalidades adicionais. Isso pode implicar em nem todos os executáveis fornecidos por um pacote funcionarem sem a respectiva optdepends. [1] Se o software funciona em múltiplas dependências alternativas, todas elas podem ser listadas aqui, em vez de no vetor depends.\n\nUma descrição curta da funcionalidade extra de cada optdepend também deve ser anotado:\n\n```\noptdepends=('cups: printing support'\n            'sane: scanners support'\n            'libgphoto2: digital cameras support'\n            'alsa-lib: sound support'\n            'giflib: GIF images support'\n            'libjpeg: JPEG images support'\n            'libpng: PNG images support')\n```\n\n"
    },
    {
      "title": "provides",
      "level": 3,
      "content": "Um vetor de pacotes adicionais dos quais o software fornece as funcionalidades, incluindo pacotes virtuais como cron ou sh e todas as bibliotecas externas compartilhadas. Pacotes fornecendo o mesmo item podem ser instalados lado a lado, a menos que um deles use um vetor conflicts.\n\n"
    },
    {
      "title": "conflicts",
      "level": 3,
      "content": "Um vetor de pacotes que conflitam com, ou causam problemas com o pacote, se instalados. Todos esses pacotes e pacotes fornecendo este item precisarão ser removidos. As propriedades da versão dos pacotes conflitantes também podem ser especificados no mesmo formato que o vetor depends.\n\nObserve que os conflitos são verificados em relação a pkgname, bem como os nomes especificados no vetor provides. Portanto, se seu pacote fornecer um recurso foo, especificar foo no vetor conflicts causará um conflito entre seu pacote e todos os outros pacotes que contenham foo em seu vetor provides (ou seja, você não precisa especificar todos esses nomes de pacotes conflitantes em seu vetor conflicts). Vejamos um exemplo concreto:\n\n- netbeans fornece implicitamente netbeans como o pkgname em si\n- netbeans-cppAUR[link quebrado: package not found] fornece netbeans e conflita com netbeans\n- netbeans-phpAUR[link quebrado: package not found] fornece netbeans e conflita com netbeans, mas não precisa explicitamente conflitar com netbeans-cppAUR[link quebrado: package not found] já que os pacotes fornecendo os mesmos recursos estão implicitamente em conflito\n\nQuando os pacotes fornecem o mesmo recurso por meio do vetor provides, há uma diferença entre adicionar explicitamente o pacote alternativo ao vetor conflicts e não adicioná-lo. Se o vetor conflicts for declarado explicitamente, os dois pacotes que fornecem o mesmo recurso serão considerados como alternativa; se o vetor conflicts estiver faltando, os dois pacotes que fornecem o mesmo recurso serão considerados como possivelmente coabitando. Os empacotadores devem sempre ignorar o conteúdo da variável provides ao decidir se devem ou não declarar uma variável conflicts.\n\n"
    },
    {
      "title": "replaces",
      "level": 3,
      "content": "Um vetor de pacotes obsoletos que são substituídos pelo pacote, como, por exemplo, wireshark-qt usa replaces=('wireshark'). Ao sincronizar, o pacman vai imediatamente substituir um pacote instalado ao encontrar outro pelo replaces correspondente nos repositórios. Se estiver fornecendo uma versão alternativa de um pacote já existente ou enviando para o AUR, use os vetores conflicts e provides, que são avaliados apenas ao instalar o pacote conflitante.\n\n"
    },
    {
      "title": "backup",
      "level": 3,
      "content": "Um vetor de arquivos que contêm alterações feitas pelo usuário e, portanto, devem ser preservados durante a atualização ou remoção de um pacote, destinado principalmente para arquivos em /etc.\n\nArquivos neste vetor devem usar caminhos relativos sem a barra inicial (/) (ex.: etc/pacman.conf, em vez de /etc/pacman.conf).\n\nAo atualizar, novas versões podem ser salvadas como arquivo.pacnew para evitar sobrescrever um arquivo que já existe e foi previamente modificado pelo usuário. De forma similar, quando o pacote é removido, os arquivos modificados pelo usuário serão preservados como arquivo.pacsave a menos que o pacote tenha sido removido com o comando pacman -Rn.\n\nVeja também os arquivos Pacnew e Pacsave.\n\n"
    },
    {
      "title": "options",
      "level": 3,
      "content": "Esse vetor permite sobrescrever alguns dos comportamentos padrões do makepkg, definidos no /etc/makepkg.conf. Para definir uma opção, inclua o nome no vetor. Para inverter o comportamento, coloque um ! na frente.\n\nA lista completa das opções disponíveis podem ser localizadas em PKGBUILD(5) § OPTIONS AND DIRECTIVES.\n\n"
    },
    {
      "title": "install",
      "level": 3,
      "content": "O nome do script .install a ser incluído no pacote.\n\npacman possui a capacidade de armazenar e executar um script específico por pacote durante a instalação, remoção ou atualização de um pacote. O script contém as seguintes funções que são executadas em momentos diferentes:\n\n- pre_install — O script é executado logo antes dos arquivos serem extraídos. Um argumento é passado: nova versão do pacote.\n- post_install — O script é executado logo após os arquivos serem extraídos. Um argumento é passado: nova versão do pacote.\n- pre_upgrade — O script é executado logo antes dos arquivos serem extraídos. Dois argumentos são passados na seguinte ordem: nova versão do pacote, versão antiga do pacote.\n- post_upgrade — O script é executado logo após os arquivos serem extraídos. Dois argumentos são passados na seguinte ordem: nova versão do pacote, versão antiga do pacote.\n- pre_remove — O script é executado logo antes dos arquivos serem removidos. Um argumento é passado: versão antiga do pacote.\n- post_remove — O script é executado logo após os arquivos serem removidos. Um argumento é passado: versão antiga do pacote.\n\nCada função é executada em chroot dentro do diretório de instalação do pacman. Veja esse tópico.\n\n- Um protótipo de .install é fornecido em /usr/share/pacman/proto.install.\n- Hooks do pacman fornecem funcionalidade similar.\n\n"
    },
    {
      "title": "changelog",
      "level": 3,
      "content": "O nome do changelog do pacote. Para ver os registros de alterações de pacotes instalados (que tenha esse arquivo):\n\n```\n$ pacman -Qc pkgname\n```\n\n"
    },
    {
      "title": "source",
      "level": 3,
      "content": "Um vetor de arquivos necessários para compilar o pacote. Deve conter a localização do fonte do software, que na maioria dos casos é uma URL HTTP ou FTP completa. As variáveis anteriormente definidas pkgname e pkgver podem ser usadas efetivamente aqui como, por exemplo, source=(\"https://exemplo.com/$pkgname-$pkgver.tar.gz\").\n\nOs arquivos também podem ser fornecidos no mesmo diretório onde o PKGBUILD está localizado, e seus nomes adicionados a este vetor. Antes do processo de compilação iniciar, todos os arquivos referenciados neste vetor serão baixados ou verificados pela existência, e o makepkg não dará continuidade, se algum deles estiver faltando.\n\nArquivos .install são reconhecidos automaticamente pelo makepkg e não devem ser incluídos no vetor source. Arquivos no vetor source com extensões .sig, .sign ou .asc são reconhecidos pelo makepkg como assinaturas PGP e serão usados automaticamente para verificar a integridade do arquivo fonte correspondente.\n\nNote: **::** \n\n- Vetores extras específicos por arquitetura podem ser adicionados anexando um sublinhado e o nome da arquitetura, ex.: x86_64=(). Deve haver um vetor de integridade correspondente com somas de verificação (checksums), ex.: sha256sums_x86_64=().\n- Alguns servidores restringem download filtrando a string \"User-Agent\" do cliente ou com outros tipos de restrições, o que pode ser alterado com DLAGENTS.\n- Você pode usar a URL file:// para apontar para um diretório ou arquivo no sistema de arquivos do seu computador. Por exemplo, um repositório Git local pode ser especificado como \"$pkgname\"::\"git+file:///caminho/para/o/repositório\".\n- Suporte para link magnético pode ser adicionado usando transmission-dlagentAUR como DLAGENT e usando o prefixo uri magnet:// em vez do prefixo uri canônico magnet:?.\n- Consulte PKGBUILD(5) § USING VCS SOURCES e Diretrizes de pacotes VCS#Fontes VCS para obter detalhes sobre opções específicas de VCS, como direcionar um branch ou commit específico do Git.\n\n"
    },
    {
      "title": "noextract",
      "level": 3,
      "content": "Um vetor de arquivos listados sob source que não devem ser extraídos de seu formato empacotado pelo makepkg. Isso pode ser usado com pacotes que não podem ser tratados pelo /usr/bin/bsdtar ou aqueles que precisam ser instalado como estão. Se uma ferramenta alternativa de extração for usada (e.g. lrzip), ela deve ser adicionada no vetor makedepends e a primeira linha da função prepare() deve extrair manualmente o pacote fonte; por exemplo:\n\n```\nprepare() {\n  lrzip -d source.tar.lrz\n}\n```\n\nNote que enquanto o vetor source aceita URLs, noextract é apenas a porção de nome do arquivo:\n\n```\nsource=(\"http://foo.org/bar/foobar.tar.xz\")\nnoextract=('foobar.tar.xz')\n```\n\nPara extrair nada, você pode fazer alguma coisa como:\n\n- Se source contém apenas URLs planas sem nomes de arquivos personalizados, remova do vetor source antes da última barra:\n\n```\nnoextract=(\"${source[@]##*/}\")\n```\n\n- Se source contiver apenas entradas com nomes de arquivos personalizados, remova do vetor source o conteúdo após o separador :: (retirado do PKGBUILD do firefox-i18n):\n\n```\nnoextract=(\"${source[@]%%::*}\")\n```\n\n"
    },
    {
      "title": "validpgpkeys",
      "level": 3,
      "content": "Um vetor de impressões digitais PGP. Se usado, makepkg só aceitará assinaturas das chaves listadas aqui e vai ignorar os valores de confiança do chaveiro. Se o arquivo fonte foi assinado com uma subchave, makepkg ainda vai usar a chave primária para comparação.\n\nApenas impressões digitais completas são aceitas. Elas devem estar em caixa alta e não devem conter caracteres em branco.\n\nPor favor, leia makepkg (Português)#Verificação de assinatura para mais informações.\n\n"
    },
    {
      "title": "Integridade",
      "level": 2,
      "content": "Essas variáveis são vetores cujos itens são strings de checksums (soma de verificação) que serão usadas para verificar a integridade dos respectivos arquivos no vetor source. Você também pode inserir SKIP para um arquivo em particular e seu checksum não será testado.\n\nO tipo e os valores da soma de verificação (checksum) devem ser sempre aqueles fornecidos pelo upstream, como nos anúncios de lançamento. Quando vários tipos estão disponíveis, a soma de verificação mais forte deve ser preferida: b2 à sha512, sha512 à sha384, sha384 à sha256, sha256 à sha224, sha224 à sha1, sha1 à md5 e md5 à ck. Isso garante a integridade dos arquivos baixados, desde o anúncio do upstream até o desenvolvimento de pacotes.\n\nOs valores para essas variáveis podem ser geradas automaticamente pela opção -g/--geninteg do makepkg e, então, anexado com makepkg -g >> PKGBUILD. O comando updpkgsums(8) do pacman-contrib é capaz de atualizar as variáveis onde quer que elas estejam no PKGBUILD. Ambas ferramentas usarão a variável que já está definida no PKGBUILD, ou voltarão para md5sums se nada estiver definido.\n\nAs verificações de integridade de arquivo a serem usadas podem ser configuradas com a opção INTEGRITY_CHECK no /etc/makepkg.conf. Veja makepkg.conf(5).\n\n"
    },
    {
      "title": "cksums",
      "level": 3,
      "content": "Um vetor de checksums CRC32 (do cksum padrão do UNIX) de arquivos listados no vetor source.\n\n"
    },
    {
      "title": "md5sums",
      "level": 3,
      "content": "Um vetor de checksums de MD5 de 128 bits dos arquivos listados no vetor source.\n\n"
    },
    {
      "title": "sha1sums",
      "level": 3,
      "content": "Um vetor de checksums de SHA-1 de 160 bits dos arquivos listados no vetor source.\n\n"
    },
    {
      "title": "sha256sums",
      "level": 3,
      "content": "Um vetor de checksums de SHA-2 com tamanho de digest de 256 bits.\n\n"
    },
    {
      "title": "sha224sums, sha384sums, sha512sums",
      "level": 3,
      "content": "Um vetor de checksums de SHA-2 com tamanhos de digest 224, 384 e 512 bits, respectivamente. Essas são alternativas mais comuns a sha256sums.\n\n"
    },
    {
      "title": "b2sums",
      "level": 3,
      "content": "Um vetor de checksums de BLAKE2 com tamanho de digest de 512 bits.\n\n"
    },
    {
      "title": "Veja também",
      "level": 2,
      "content": "- PKGBUILD(5) - página de manual do PKGBUILD\n- Exemplo de arquivo PKGBUILD\n\n"
    }
  ]
}