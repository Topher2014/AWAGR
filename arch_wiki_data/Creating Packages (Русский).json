{
  "title": "Creating Packages (Русский)",
  "url": "https://wiki.archlinux.org/title/Creating_Packages_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Система сборки Arch\n- Стандарты создания пакетов для Arch\n- Пользовательский репозиторий Arch\n- Creating packages for other distributions\n- makepkg (Русский)\n- pacman (Русский)\n- Patching packages\n- PKGBUILD (Русский)\n- .SRCINFO (Русский)\n- DeveloperWiki:Building in a clean chroot\n\nЭта статья призвана помочь пользователям в создании собственных пакетов с помощью «портоподобной» системы сборки, в том числе для публикации в AUR. В ней рассказывается о создании файла описания сборки пакета — PKGBUILD, используемого утилитой makepkg для создания бинарного пакета из исходного кода. Если у вас уже есть PKGBUILD, смотрите статью makepkg (Русский). Инструкции относительно существующих правил и способов улучшения качества пакетов описаны в статье Стандарты создания пакетов для Arch.\n\n"
    },
    {
      "title": "Обзор",
      "level": 2,
      "content": "Пакеты в Arch Linux собираются с помощью утилиты makepkg и информации, хранящейся в файле PKGBUILD. При запуске makepkg ищет PKGBUILD в текущем каталоге и выполняет записанные в нём инструкции для получения необходимых файлов и/или их компиляции для упаковки в файл пакета (pkgname.pkg.tar.zst). Полученный пакет содержит двоичные файлы и инструкции по установке, готовые к установке с помощью pacman.\n\nПакет Arch — это не более чем tar-архив, или «tarball», сжатый с помощью zstd(1), который содержит следующие созданные утилитой makepkg файлы:\n\n- Бинарные файлы для установки.\n- .PKGINFO: содержит все метаданные, необходимые pacman для работы с пакетами, зависимостями и т.д.\n- .BUILDINFO: содержит информацию, необходимую для воспроизводимых сборок. Этот файл присутствует, только если пакет собран с помощью pacman 5.1 или более новой версии. См. BUILDINFO(5).\n- .MTREE: содержит хэши и временные метки файлов, которые включаются в локальную базу данных, чтобы pacman мог проверить целостность пакета.\n- .INSTALL: необязательный файл, используемый для выполнения команд после этапа установки/обновления/удаления. (Этот файл присутствует, только если он указан в PKGBUILD).\n- .Changelog: необязательный файл, хранящийся у сопровождающего пакета и документирующий изменения пакета. (Он присутствует не во всех пакетах).\n\n"
    },
    {
      "title": "Необходимое программное обеспечение",
      "level": 3,
      "content": "Сперва убедитесь, что необходимые инструменты установлены: мета-пакета base-devel должно быть достаточно; он подтягивает make и дополнительные инструменты, необходимые для компиляции из исходного кода.\n\nКлючевым инструментом для сборки пакетов является makepkg (предоставляется пакетом pacman), который делает следующее:\n\n1. Проверяет, установлены ли зависимости пакета.\n1. Загружает исходные файлы с указанного сервера(ов).\n1. Распаковывает исходные файлы.\n1. Компилирует программу и устанавливает её в окружении fakeroot.\n1. Удаляет символы из двоичных файлов и библиотек.\n1. Генерирует метафайл пакета, который включается в каждый пакет.\n1. Сжимает окружение fakeroot в файл пакета.\n1. Сохраняет файл пакета в настроенном каталоге назначения, который по умолчанию является текущим рабочим каталогом.\n\n"
    },
    {
      "title": "Загрузка и тестирование установки",
      "level": 3,
      "content": "Загрузите исходный tarball программы, которую хотите упаковать, распакуйте его и следуйте указаниям автора для установки программы. Запишите все команды и/или шаги, необходимые для компиляции и установки. Вы будете повторять эти же команды в файле PKGBUILD.\n\nБольшинство авторов программ придерживаются трёхэтапного цикла сборки:\n\n```\n./configure\nmake\nmake install\n```\n\nЭто подходящее время, чтобы убедиться, что программа работает правильно.\n\n"
    },
    {
      "title": "Установка в чистый chroot",
      "level": 3,
      "content": "Рекомендуется следовать DeveloperWiki:Building in a clean chroot, чтобы убедиться, что пакеты и конфигурация вашей системы не приведут к ошибкам в PKGBUILD. Это более надёжный и корректный способ сборки пакетов, позволяющий обнаружить отсутствующие зависимости, о необходимости которых вы не подозревали, поскольку они уже присутствовали в вашей системе.\n\n"
    },
    {
      "title": "Создание PKGBUILD",
      "level": 2,
      "content": "При запуске makepkg ищет в текущем рабочем каталоге файл PKGBUILD. Если он найден, то загружает исходный код программы и компилирует его в соответствии с инструкциями, указанными в файле PKGBUILD. Инструкции должны быть полностью интерпретируемы оболочкой Bash. После успешного завершения результирующие двоичные файлы и метаданные пакета, то есть версия пакета и зависимости, упаковываются в файл пакета pkgname.pkg.tar.zst. Получившийся пакет можно установить, просто используя makepkg --install, который вызовет pacman в фоновом режиме, или непосредственно используя pacman -U pkgname.pkg.tar.zst.\n\nЧтобы начать сборку нового пакета, сначала создайте новый каталог для пакета и измените текущий каталог на него. Затем необходимо создать файл PKGBUILD: можно использовать прототип PKGBUILD, находящийся в /usr/share/pacman/, или начать с файла PKGBUILD из другого пакета. Последний вариант может оказаться удобным, если уже существует похожий пакет.\n\n"
    },
    {
      "title": "Определение переменных PKGBUILD",
      "level": 3,
      "content": "Примеры PKGBUILD находятся в /usr/share/pacman/. Объяснение возможных переменных PKGBUILD можно найти в статье PKGBUILD (Русский).\n\nmakepkg определяет две переменные, которые следует использовать в процессе сборки и установки:\n\nОни содержат абсолютные пути — это означает, что при правильном использовании этих переменных вам не нужно беспокоиться о своём рабочем каталоге.\n\n"
    },
    {
      "title": "Функции PKGBUILD",
      "level": 3,
      "content": "При сборке пакета makepkg будет вызывать следующие пять функций, если они определены в PKGBUILD. Функция package() является обязательной в каждом PKGBUILD и будет вызываться всегда. Если какая-либо из других функций не определена, то makepkg просто пропустит вызов этой функции.\n\nВо время сборки функции вызываются в том порядке, в котором они перечислены здесь.\n\n"
    },
    {
      "title": "prepare()",
      "level": 4,
      "content": "С помощью этой функции выполняются команды, используемые для подготовки исходных текстов к сборке, например применение патчей. Эта функция запускается сразу после извлечения пакета, перед pkgver() и функцией сборки. Если извлечение пропущено (makepkg --noextract), то prepare() не выполняется.\n\nКогда неясно, куда поместить ту или иную функцию — в prepare() или build(), можно воспользоваться эмпирическим правилом: помещать в prepare() те шаги, которые должны выполняться ровно один раз после извлечения исходных текстов, а в build() — те шаги, которые имеет смысл повторно выполнять после внесения любых ручных правок в извлечённые файлы.\n\n"
    },
    {
      "title": "pkgver()",
      "level": 4,
      "content": "pkgver() запускается после извлечения исходных текстов, их распаковки и выполнения prepare(). Таким образом, переменную pkgver можно обновить на этапе makepkg.\n\nЭто особенно полезно при создании пакетов git/svn/hg/etc., когда процесс сборки может оставаться неизменным, но исходники могут обновляться каждый день, а то и каждый час. Старый способ сделать это заключался в том, чтобы поместить дату в поле pkgver, но тогда даже если если программа не обновлялась, то makepkg все равно пересобирал её из-за изменившегося номера версии. Некоторые полезные команды для этого — git describe, hg identify -ni и т. д. Пожалуйста, проверяйте их перед отправкой PKGBUILD, так как сбой в функции pkgver() может остановить сборку на корню.\n\n"
    },
    {
      "title": "build()",
      "level": 4,
      "content": "Теперь необходимо реализовать функцию build() в файле PKGBUILD. Эта функция использует обычные команды оболочки в синтаксисе Bash для автоматической компиляции программ и создания каталога pkg для их установки. Она позволяет makepkg упаковывать файлы без необходимости рыться в файловой системе.\n\nПервым шагом в функции build() является переход в каталог, созданный в результате распаковки архива с исходным кодом. makepkg изменит текущий каталог на $srcdir перед выполнением функции build(). Поэтому в большинстве случаев, как это предлагается в /usr/share/pacman/PKGBUILD.proto, первая команда будет выглядеть следующим образом:\n\n```\ncd \"$pkgname-$pkgver\"\n```\n\nТеперь необходимо прописать те же команды, которые использовались при ручной компиляции программы. Функция build(), по сути, автоматизирует всё, что вы делали вручную, и компилирует программу в среде сборки fakeroot. Если в упаковываемом программном обеспечении используется скрипт configure, то при сборке пакетов для pacman рекомендуется использовать --prefix=/usr. Многие программы устанавливают файлы относительно каталога /usr/local, что следует делать только в случае ручной сборки из исходных текстов. Все пакеты Arch Linux должны использовать каталог /usr. Как видно из файла /usr/share/pacman/PKGBUILD.proto, следующие две строки часто выглядят следующим образом:\n\n```\n./configure --prefix=/usr\nmake\n```\n\n"
    },
    {
      "title": "check()",
      "level": 4,
      "content": "Место для вызовов make check и аналогичных процедур проверки. Настоятельно рекомендуется иметь check(), так как проверка помогает убедиться в том, что программа правильно и хорошо работает с зависимостями.\n\nПользователи, которым она не нужна (а иногда и сопровождающие, которые не могут исправить пакет для её прохождения), могут отключить её, добавив !check в массив options в PKGBUILD/makepkg.conf(5) или вызвать makepkg с флагом --nocheck.\n\n"
    },
    {
      "title": "package()",
      "level": 4,
      "content": "Последним шагом является помещение скомпилированных файлов в каталог, из которого makepkg сможет получить их для создания пакета. По умолчанию это каталог pkg — простая среда fakeroot. Каталог pkg повторяет иерархию корневой файловой системы путей установки программного обеспечения. Если вам приходится вручную размещать файлы в корне вашей файловой системы, то их следует устанавливать в каталог pkg в той же структуре каталогов. Например, если вы хотите установить файл в /usr/bin, то вместо этого его следует поместить в $pkgdir/usr/bin. Лишь немногие процедуры установки требуют от пользователя копирования десятков файлов вручную. Вместо этого для большинства программ достаточно вызвать команду make install. Для корректной установки программы в каталог pkg последняя строка должна выглядеть следующим образом:\n\n```\nmake DESTDIR=\"$pkgdir/\" install\n```\n\nmakepkg --repackage запускает только функцию package(), то есть создаёт пакет без сборки. Это может сэкономить время, например, если вы изменили только переменную depends пакета.\n\n"
    },
    {
      "title": "Тестирование PKGBUILD и пакета",
      "level": 2,
      "content": "В процессе написания функции build() необходимо часто тестировать изменения, чтобы убедиться в отсутствии ошибок. Это можно сделать с помощью команды makepkg в каталоге, содержащем файл PKGBUILD. При правильно оформленном PKGBUILD makepkg создаст пакет; при неработающем или незавершённом PKGBUILD она выдаст ошибку.\n\nПри успешном завершении работы makepkg поместит в рабочий каталог файл с именем pkgname-pkgver.pkg.tar.zst. Этот пакет может быть установлен командой pacman -U. Однако то, что файл пакета был собран, не означает, что он полностью работоспособен. Он может содержать только каталог и ни одного файла, если, например, неправильно указан префикс. С помощью функций запроса pacman можно вывести список файлов, содержащихся в пакете, и зависимостей, которые он требует, с помощью pacman -Qlp [package file] и pacman -Qip [package file] соответственно.\n\nЕсли пакет выглядит нормально, то все готово! Однако если вы планируете опубликовать файл PKGBUILD, то обязательно проверьте и перепроверьте содержимое массива depends.\n\nТакже убедитесь, что двоичные файлы пакета действительно работают безупречно! Очень неприятно выпускать пакет, содержащий все необходимые файлы, но аварийно завершающий работу из-за непонятной опции конфигурации, которая не совсем корректно работает с остальной частью системы. Впрочем, если вы собираете пакеты только для себя, то можно об этом не слишком беспокоиться, ведь в конце концов от своих ошибок будете страдать только вы.\n\n"
    },
    {
      "title": "Проверка целостности пакета",
      "level": 3,
      "content": "После тестирования работоспособности пакета проверьте его на наличие ошибок с помощью namcap:\n\n```\n$ namcap PKGBUILD\n$ namcap <имя файла пакета>.pkg.tar.zst\n```\n\nNamcap выполнит:\n\n1. Проверку содержимого PKGBUILD на наличие типичных ошибок и иерархию файлов пакета на наличие ненужных или неправильно размещённых файлов\n1. Сканирование всех ELF-файлов пакета с помощью ldd, автоматически сообщая, какие пакеты с необходимыми разделяемыми библиотеками отсутствуют в depends, а какие могут быть опущены как транзитивные зависимости\n1. Эвристический поиск отсутствующих и избыточных зависимостей\n\nи многое другое.\n\nВозьмите за привычку проверять свои пакеты с помощью namcap во избежание необходимости исправлять простейшие ошибки после отправки пакета.\n\n"
    },
    {
      "title": "Использование pkgctl для сборки в чистом chroot-окружении",
      "level": 3,
      "content": "Вы можете использовать pkgctl из devtools для проверки возможно ли собрать пакет там, где ещё не установлены другие пакеты. Находясь в каталоге PKGBUILD выполнить:\n\n```\n$ pkgctl build\n```\n\nИ проверьте вывод на наличие возможных ошибок или предупреждений. Если пакет зависит от других пакетов AUR, эти пакеты должны быть собраны и перенесены в окружение chroot:\n\n```\n$ pkgctl build -I path/to/somepkg.tar.gz -I ...\n```\n\nДополнительные опции см. в pkgctl-build(1).\n\n"
    },
    {
      "title": "Отправка пакетов в AUR",
      "level": 2,
      "content": "Пожалуйста, прочитайте правила отправки пакетов в AUR, где подробно описан процесс отправки.\n\n"
    },
    {
      "title": "Резюме",
      "level": 2,
      "content": "1. Загрузите исходный архив программы, для которой создаётся пакет.\n1. Попробуйте скомпилировать пакет и установить его в произвольный каталог.\n1. Скопируйте прототип /usr/share/pacman/PKGBUILD.proto и переименуйте его в PKGBUILD во временный рабочий каталог.\n1. Отредактируйте PKGBUILD в соответствии с потребностями вашего пакета.\n1. Запустите makepkg и проверьте, правильно ли собран пакет.\n1. Если нет - повторите два предыдущих шага.\n\n"
    },
    {
      "title": "Предупреждения",
      "level": 3,
      "content": "- Прежде чем автоматизировать процесс сборки пакета, необходимо хотя бы раз выполнить его вручную, если только вы не знаете точно, что делаете, заранее, но в этом случае вы бы не читали эту статью. К сожалению, хотя многие авторы программ придерживаются трёхэтапного цикла сборки \"./configure; make; make install\", он не всегда таков, и ситуация может стать очень неприятной, если придётся применять патчи, чтобы вообще заставить всё работать. Правило: если вы не можете заставить программу скомпилироваться из исходного архива и установить себя в определённый временный подкаталог — не стоит даже пытаться упаковать её. В makepkg нет волшебной пыльцы фей, избавляющей от проблем.\n- В некоторых случаях пакеты вообще недоступны в виде исходных текстов, и для того, чтобы заставить их работать, приходится использовать что-то вроде sh installer.run. Вам придётся провести довольно много исследований (прочитать README, инструкции INSTALL, man-страницы, возможно, ebuild'ы от Gentoo или других программ установки пакетов, возможно, даже MAKEFILE или исходный код), чтобы заставить их работать. В некоторых очень запущенных случаях приходится редактировать исходные файлы, чтобы заставить их работать. Однако makepkg должен отработать полностью автономно, без участия пользователя. Поэтому если необходимо отредактировать make-файлы, то, возможно, придётся дополнить PKGBUILD патчем и применять его в функции prepare(), либо выполнить несколько команд sed внутри функции prepare().\n\n"
    },
    {
      "title": "Более подробные руководства",
      "level": 2,
      "content": "32-bit – CLR – CMake – Cross – DKMS – Eclipse – Electron – Font – Free Pascal – GNOME – Go – Haskell – Java – KDE – Kernel – Lisp – Meson – MinGW – Node.js – Nonfree – OCaml – Perl – PHP – Python – R – Ruby – Rust – Shell – VCS – Web – Wine\n\n"
    },
    {
      "title": "Контрольные суммы",
      "level": 3,
      "content": "Процесс обновления контрольных сумм для новых выпусков программ может быть автоматизирован с помощью инструмента updpkgsums; подробнее об этом см. в разделе makepkg (Русский)#Вычисление новых контрольных сумм.\n\n"
    },
    {
      "title": "Генераторы PKGBUILD",
      "level": 3,
      "content": "PKGBUILD для некоторых пакетов могут быть созданы автоматически.\n\n- Haskell: cblrepo, arch-hs\n- Node.js: nodejs-npm2archAUR\n- Perl: perl-cpanplus-dist-archAUR\n- Python: pipman-gitAUR, pip2arch-gitAUR, python-pypi2pkgbuildAUR\n- Ruby: gem2archAUR, pacgemAUR\n- Rust: cargo-pkgbuildAUR\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- How to correctly create a patch file.\n- Arch Linux Classroom IRC Logs of classes about creating PKGBUILDs.\n- Fakeroot approach for package installation\n\n"
    }
  ]
}