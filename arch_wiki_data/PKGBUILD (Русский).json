{
  "title": "PKGBUILD (Русский)",
  "url": "https://wiki.archlinux.org/title/PKGBUILD_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Arch package guidelines\n- Создание пакетов\n- .SRCINFO\n- Пользовательский репозиторий Arch\n- Category:Package development (Русский)\n- Система сборки Arch\n- makepkg (Русский)\n\nВ статье рассмотрены определяемые сопроводителем пакета переменные файла PKGBUILD. Если вы ищете информацию об используемых в PKGBUILD функциях или о создании пакетов в целом, изучите статью Создание пакетов. Также стоит прочитать руководство PKGBUILD(5).\n\nPKGBUILD — сценарий оболочки, содержащий информацию, необходимую для сборки пакета Arch Linux.\n\nВ Arch Linux пакеты собираются утилитой makepkg. При запуске makepkg находит в рабочем каталоге файл PKGBUILD и выполняет содержащиеся в нём указания по получению необходимых файлов, их компиляции и сборке архива пакета название_пакета.pkg.tar.zst. Итоговый пакет состоит из двоичных файлов и инструкций по установке; с помощью pacman его можно установить в систему.\n\nОбязательными являются переменные pkgname, pkgver, pkgrel и arch. Параметр license можно не указывать, но в этом случае makepkg выдаст предупреждение. Если вы планируете распространять PKGBUILD среди других пользователей, лучше его всё-таки добавить.\n\nКак правило, переменные в файле PKGBUILD объявляются в том порядке, в каком перечислены здесь, но требованием это не является. Главное — соблюдать синтаксис Bash.\n\n"
    },
    {
      "title": "pkgbase",
      "level": 3,
      "content": "При сборке обычных пакетов эту переменную указывать не нужно: она по умолчанию принимает значение #pkgname.\n\nПри сборке разделённого пакета в ней указывают значение, которым обозначается данная группа пакетов и которое используется в имени tar-архива с исходниками. Значение не должно начинаться с дефиса. Если никакое значение не указано, то берётся первый элемент массива pkgname.\n\nВсе параметры и указания для разделённых пакетов по умолчанию используют глобальные значения из PKGBUILD. Тем не менее, следующие параметры могут быть переопределены в функциях упаковки каждого из разделённых пакетов: #pkgdesc, #arch, #url, #license, #groups, #depends, #optdepends, #provides, #conflicts, #replaces, #backup, #options, #install и #changelog.\n\n"
    },
    {
      "title": "pkgname",
      "level": 3,
      "content": "Либо название пакета (например, pkgname='foo'), либо, в случае разделённых пакетов, массив названий (например, pkgname=('foo' 'bar')). Название пакета должно состоять из латинских букв в нижнем регистре, цифр и символов @._+- (\"собака\", точка, подчёркивание, плюс, дефис). Название не может начинаться с дефиса или точки. Для удобства принято за правило, что pkgname должен совпадать с названием tar-архива исходников программы. Так, если код программы упакован в архив foobar-2.5.tar.gz, то используйте pkgname=foobar.\n\n"
    },
    {
      "title": "pkgver",
      "level": 3,
      "content": "Версия пакета. Должна совпадать с номером версии, который используется автором программы в апстриме. Состоит из букв, чисел, точек и подчёркиваний, но дефис использовать нельзя. Если автор программы использовал в номере версии дефис, замените его на символ подчёркивания. При дальнейшем использовании этой переменной в PKGBUILD подчёркивание можно легко изменить обратно на дефис, например: source=(\"$pkgname-${pkgver//_/-}.tar.gz\").\n\n- Относительный порядок для нестандартных значений можно протестировать утилитой vercmp(8) из пакета pacman.\n- makepkg может автоматически обновлять значение данной переменной с помощью функции pkgver() файла PKGBUILD. Подробнее см. VCS package guidelines#The pkgver() function.\n\n"
    },
    {
      "title": "pkgrel",
      "level": 3,
      "content": "Номер релиза. Обычно положительное целое число. Позволяет различать последовательные сборки одной и той же версии пакета. Каждый раз, когда в PKGBUILD вносятся исправления или дополнения, влияющие на итоговый пакет, значение этой переменной необходимо увеличить на 1. Когда выходит новая версия программы, pkgrel сбрасывается до значения 1. В исключительных случаях могут использоваться некоторые другие форматы, вроде старший.младший.\n\n"
    },
    {
      "title": "epoch",
      "level": 3,
      "content": "Позволяет сделать версию пакета более новой по отношению ко всем предыдущим версиям более низких \"эпох\". Может принимать неотрицательные значения; по умолчанию равна 0. Применяется в случаях, когда изменилась схема нумерации версий пакета (или используется буквенно-цифровая нумерация), что ломает обычную логику сравнения версий. Пример:\n\n```\npkgver=5.13\npkgrel=2\nepoch=1\n```\n\n```\n1:5.13-2\n```\n\nО сравнении версий см. pacman(8).\n\n"
    },
    {
      "title": "pkgdesc",
      "level": 3,
      "content": "Описание пакета. Рекомендованная длина — не более 80 символов. Описание не должно содержать названия самого пакета в явном виде, за исключением случаев, когда название приложения от него отличается. Например, вместо pkgdesc=\"Nedit is a text editor for X11\" (\"Nedit — текстовый редактор для X11\") лучше указать просто pkgdesc=\"Text editor for X11\" (\"Текстовый редактор для X11\").\n\nТакже не забывайте использовать в описании пакета ключевые слова, чтобы его было проще найти с помощью поиска.\n\n"
    },
    {
      "title": "arch",
      "level": 3,
      "content": "Массив названий архитектур, под которые пакет может быть собран по данному PKGBUILD. Arch официально поддерживает только x86_64, но существуют сторонние проекты для других архитектур. Например, Arch Linux 32 работает с i686 и pentium4, а Arch Linux ARM предоставляет поддержку для arm (armv5), armv6h (armv6 hardfloat), armv7h (armv7 hardfloat) и aarch64 (armv8 64-bit).\n\nВ параметре используются два типа значений:\n\n- arch=('any') — пакет соберётся на любой архитектуре и в откомпилированном состоянии будет архитектурно-независимым (пакеты со сценариями оболочки, шрифтами, темами, многими типами расширений и т.п.).\n- arch=('x86_64') — пакет соберётся только на указанной(-ых) архитектуре(-ах). После компиляции пакет становится архитектурно-зависимым. В параметре указываются все архитектуры, для которых будет работать данный PKGBUILD. Для пакетов из официальных репозиториев и AUR в параметре arch указывается значение x86_64, хотя пакеты из AUR могут также поддерживать дополнительные архитектуры.\n\nВ процессе сборки значение целевой архитектуры хранится в переменной $CARCH.\n\n"
    },
    {
      "title": "url",
      "level": 3,
      "content": "Адрес официального сайта той программы, которая собирается в пакет.\n\n"
    },
    {
      "title": "license",
      "level": 3,
      "content": "Лицензия, под которой распространяется программа. В пакете licenses (зависимость мета-пакета base) собраны наиболее распространённые лицензии; при установке они размещаются в каталоге /usr/share/licenses/common/. Если программа распространяется под одной из этих лицензий, то в параметре необходимо указать значение, совпадающее с названием соответствующего подкаталога (например, license=('GPL')). Если используется лицензия, отсутствующая в licenses, необходимо сделать следующее:\n\n1. Укажите в параметре license значение custom (либо custom:лицензия). Когда некая лицензия используется в двух или более пакетах из официальных репозиториев, её добавляют в пакет licenses.\n1. Скопируйте файл лицензии в каталог /usr/share/licenses/пакет/, например, /usr/share/licenses/foobar/LICENSE. Проще всего это сделать командой install -Dm644 LICENSE \"$pkgdir/usr/share/licenses/$pkgname/LICENSE\"\n1. Если лицензию можно найти только на веб-сайте, то её придётся включить в пакет отдельно.\n\n```\ninstall -Dm644 LICENSE \"$pkgdir/usr/share/licenses/$pkgname/LICENSE\"\n```\n\n- Лицензии BSD, ISC, MIT, zlib/png, Python и OFL являются особыми случаями и не включены в пакет licenses. В массиве license они указываются так же, как и обычные лицензии (license=('BSD'), license=('ISC'), license=('MIT'), license=('ZLIB'), license=('Python') и license=('OFL')), но технически это custom-лицензии из-за особых правил в отношении авторских прав. Файл любой из этих лицензий должен храниться в каталоге /usr/share/licenses/пакет/.\n- Некоторые пакеты могут распространяться сразу под несколькими лицензиями. В этом случае их все нужно указать в массиве license, например: license=('GPL' 'custom:лицензия').\n- У лицензии (L)GPL есть разные версии и варианты. Приняты следующие соглашения: (L)GPL — (L)GPLv2 или более поздняя (L)GPL2 — только (L)GPL2 (L)GPL3 — (L)GPL3 или более поздняя\n- Если необходимый тип лицензии определить не удаётся, в соответствии с рекомендациями из PKGBUILD.proto можно использовать unknown. Тем не менее, стоит отправить запрос разработчикам и уточнить условия, под которыми программа (не) распространяется.\n\n- (L)GPL — (L)GPLv2 или более поздняя\n- (L)GPL2 — только (L)GPL2\n- (L)GPL3 — (L)GPL3 или более поздняя\n\nNote: **This software** \n\nСм. также Nonfree applications package guidelines.\n\nИнформацию о лицензиях свободного ПО и их перспективах можно найти в следующих статьях:\n\n- Википедия:Лицензия свободного программного обеспечения\n- Википедия:Сравнение лицензий свободного ПО с открытым исходным кодом (англ.)\n- Правовые вопросы для проектов свободного ПО (англ.)\n- GNU Project - Различные лицензии с комментариями\n- Debian - Информация о лицензиях\n- Open Source Initiative - Список лицензий по названию (англ.)\n\n"
    },
    {
      "title": "groups",
      "level": 3,
      "content": "Группа, к которой принадлежит пакет. Например, при установке группы plasma устанавливаются все пакеты, которые в неё входят.\n\n"
    },
    {
      "title": "depends",
      "level": 3,
      "content": "Список пакетов, которые необходимы для сборки и работы программы. Зависимости, определяемые в функции package(), нужны только для работы.\n\nВерсию пакета-зависимости можно ограничить операторами сравнения, например, depends=('foobar>=1.8.0'); если ограничений несколько, то они указываются по отдельности (depends=('foobar>=1.8.0' 'foobar<2.0.0')).\n\nВ массиве depends указываются все зависимости верхнего уровня, в том числе и те, которые теоретически могут установиться неявно. Представьте, что пакет foo зависит от bar и baz, причём bar тоже зависит от baz. Если не указать baz как зависимость foo, положившись на \"неявную\" установку, это однозначно приведёт к проблемам, если в какой-то момент bar откажется от использования baz. Pacman не установит baz при чистой установке foo, или же удалит baz из системы как пакет-сироту, в результате чего foo упадёт при работе или будет работать некорректно.\n\nВ некоторых особых случаях определённые пакеты всё же можно не указывать. Так, glibc не может быть удалён, так как в системе всегда должна быть стандартная библиотека Си, а python будет в любом случае установлен, если ваш пакет зависит хотя бы от одного python-модуля, так как для последнего python по определению является зависимостью.\n\nВ число зависимостей должны быть включены пакеты, необходимые для сборки дополнительных возможностей. В противном случае такие возможности должны быть явно отключены в настройках сборки. Если этого не сделать, то будет иметь место \"автомагия зависимостей\", когда либо внезапно оказывается работающей какая-то возможность из-за наличия \"неявных\" зависимостей, либо в системе, где производилась сборка, появляются лишние пакеты, которых не было в списке зависимостей.\n\nЕсли зависимость представляет собой библиотеку (например, depends=('libfoobar.so')), то makepkg найдёт двоичный файл, которому она нужна, и определит необходимую версию библиотеки. Если указать версию явно (depends=('libfoobar.so=2')), то автоматический поиск версии выполняться не будет.\n\n"
    },
    {
      "title": "makedepends",
      "level": 3,
      "content": "Список пакетов, которые нужны только для сборки пакета. Версия пакета обозначается так же, как и в массиве depends. Если пакеты из depends неявно используются при сборке, указывать их повторно в makedepends не нужно.\n\n```\n$ LC_ALL=C pacman -Si $(pactree -rl package) 2>/dev/null | grep -q \"^Groups *:.*base-devel\"\n```\n\nNote: **не нужно** \n\n"
    },
    {
      "title": "optdepends",
      "level": 3,
      "content": "Список пакетов, которые не являются необходимыми для работы программы, но могут расширить её функционал. Иногда это означает, что некоторые исполняемые файлы, предоставляемые пакетом, откажутся работать без соответствующих опциональных зависимостей [1]. Если программа может работать с помощью нескольких альтернативных зависимостей, их все нужно указать здесь, а не в массиве depends.\n\nРядом с названием опциональной зависимости необходимо указать краткое описание дополнительной функциональности, которую она предоставляет:\n\n```\noptdepends=('cups: printing support'\n            'sane: scanners support'\n            'libgphoto2: digital cameras support'\n            'alsa-lib: sound support'\n            'giflib: GIF images support'\n            'libjpeg: JPEG images support'\n            'libpng: PNG images support')\n```\n\n"
    },
    {
      "title": "checkdepends",
      "level": 3,
      "content": "Список пакетов, которые необходимы программе для различных проверок, но не во время выполнения. Формат описания пакетов тот же, что и в параметре depends. Эти зависимости нужны только для функции check() (если она есть), вызываемой makepkg в процессе работы.\n\nNote: **не нужно** \n\n"
    },
    {
      "title": "provides",
      "level": 3,
      "content": "Список программ, функциональность которых предоставляется данным пакетом (или виртуальные пакеты вроде cron или sh). В системе могут быть установлены несколько пакетов с одинаковыми пунктами в provides, если они не конфликтуют (массив conflicts).\n\n"
    },
    {
      "title": "conflicts",
      "level": 3,
      "content": "Список программ, которые, будучи установленными, создают проблемы в работе пакета. Такие пакеты (как и пакеты, \"предоставляющие\" их) должны быть удалены. Версии конфликтующих пакетов указываются в формате, принятом в массиве depends.\n\nОбратите внимание, что на конфликты проверяются и pkgname, и массив provides пакета. Следовательно, если ваш пакет предоставляет какую-то функциональность и другой пакет предоставляет её же, указывать этот конфликтующий пакет в conflicts не нужно. Например:\n\n- netbeans неявно предоставляет функциональность netbeans (самого себя).\n- netbeans-cppAUR[ссылка недействительна: package not found] предоставляет netbeans и конфликтует с netbeans.\n- netbeans-phpAUR[ссылка недействительна: package not found] предоставляет netbeans и конфликтует с netbeans; пакет netbeans-cppAUR[ссылка недействительна: package not found] в conflicts не указывается, поскольку предоставляющие одинаковую функциональность пакеты и так неявно конфликтуют друг с другом.\n\n"
    },
    {
      "title": "replaces",
      "level": 3,
      "content": "Список устаревших программ, которые пакет должен заменить. Например, для пакета wireshark-qt используется параметр replaces=('wireshark'). При синхронизации баз данных pacman немедленно переустанавливает пакет, если в официальных репозиториях обнаружена подходящая замена с нужным пуктом в массиве replaces. Если вы хотите всего лишь создать альтернативную версию существующего пакета или собираетсь загрузить пакет в AUR, то лучше использовать массивы conflicts и provides, которые проверяются только при явной попытке установить конфликтующий пакет.\n\n"
    },
    {
      "title": "backup",
      "level": 3,
      "content": "Список файлов, которые могут изменяться пользователем и по этой причине должны сохраняться во время обновления или удаления пакета. Чаще всего здесь указывают файлы настроек из каталога /etc.\n\nВ качестве значений backup используются относительные пути без ведущего слэша (/). Так, вместо /etc/pacman.conf необходимо указать etc/pacman.conf.\n\nВо время обновления пакета новые версии файлов будут сохраняться с расширением .pacnew (например, file.pacnew), чтобы избежать перезаписи существующего, изменённого пользователем файла. При удалении пакета (кроме случая, когда удаление производится командой pacman -Rn) происходит аналогичная операция — изменённые пользователем файлы сохраняются с суффиксом .pacsave (file.pacsave).\n\nПодробнее см. Файлы Pacnew и Pacsave.\n\n"
    },
    {
      "title": "options",
      "level": 3,
      "content": "Позволяет переопределить стандартное поведение makepkg, определённое файлом /etc/makepkg.conf. Чтобы задать новый параметр, укажите его в данном массиве. Чтобы отключить параметр, добавьте перед ним символ !.\n\nСписок доступных параметров можно найти в руководстве PKGBUILD(5).\n\n"
    },
    {
      "title": "install",
      "level": 3,
      "content": "Название входящего в пакет установочного сценария .install. pacman может сохранять и выполнять различные специфичные для пакета сценарии при установке, удалении и обновлении пакета. Сценарий содержит следующие функции, выполняемые на разных этапах:\n\n- pre_install — выполняется перед извлечением файлов. Передаётся один аргумент: новая версия пакета.\n- post_install — выполняется после извлечения файлов. Передаётся один аргумент: новая версия пакета.\n- pre_upgrade — выполняется перед извлечением файлов. Передаётся два аргумента в следующем порядке: новая версия пакета, прежняя версия пакета.\n- post_upgrade — выполняется после извлечения файлов. Передаётся два аргумента в следующем порядке: новая версия пакета, прежняя версия пакета.\n- pre_remove — выполняется перед удалением файлов. Передаётся один аргумент: прежняя версия пакета.\n- post_remove — выполняется после удаления файлов. Передаётся один аргумент: прежняя версия пакета.\n\nКаждая функция выполняется в chroot-окружении внутри установочного каталога pacman. Подробнее см. это обсуждение.\n\n- Прототип .install-сценария находится в файле /usr/share/pacman/proto.install.\n- pacman#Хуки работают схожим образом.\n\n"
    },
    {
      "title": "changelog",
      "level": 3,
      "content": "Название файла журнала изменений пакета. Следующая команда позволяет просмотреть журнал установленного пакета (при условии, что соответствующий файл существует):\n\n```\n$ pacman -Qc пакет\n```\n\n"
    },
    {
      "title": "source",
      "level": 3,
      "content": "Массив со списком необходимых для сборки пакета файлов. Как правило, описывает местонахождение файлов с исходным кодом, чаще всего в виде HTTP- или FTP-ссылки. В этом параметре часто находят применение установленные ранее значения pkgname и pkgver (например, source=(\"https://example.com/$pkgname-$pkgver.tar.gz\")).\n\nФайлы также могут находиться в одном каталоге с PKGBUILD, в этом случае их имена напрямую добавляются в массив. Перед началом процесса сборки все указанные в source файлы загружаются или проверяются на наличие, и если какие-то из них найдены не будут, то makepkg прекратит работу.\n\nФайлы .install распознаются makepkg автоматически и включать их в source не нужно. Файлы с суффиксами .sig, .sign и .asc makepkg опознаёт как PGP-подписи и проверяет с их помощью целостность соответствующих файлов.\n\nNote: **::** \n\n- Можно указать массив source для конкретной архитектуры, добавив к названию символ подчёркивания и архитектуру (например, source_x86_64=()). Каждому такому массиву должен соответствовать массив проверки целостности по контрольным суммам, например, sha256sums_x86_64=().\n- Некоторые серверы ограничивают загрузку, фильтруя запросы по строке User-Agent; это можно обойти с помощью DLAGENTS.\n- С помощью URL типа file:// можно указать в source название находящегося на вашем компьютере файла или каталога. Так, ссылка на локальный git-репозиторий будет иметь вид \"$pkgname\"::\"git+file:///путь/к/репозиторию\".\n- Подробнее об VCS-опциях (вроде работы с отдельной веткой git или коммитом) см. PKGBUILD(5) § USING VCS SOURCES и VCS package guidelines#VCS sources .\n\n"
    },
    {
      "title": "noextract",
      "level": 3,
      "content": "Массив со списком файлов из source, которые makepkg не должен извлекать из архива. Используется, если архив не может быть распакован стандартной утилитой /usr/bin/bsdtar или же устанавливается \"как есть\". Если используется другая утилита для разархивации (например, lrzip), добавьте её в массив makedepends, а в первой строке функции prepare() извлеките исходники вручную, например:\n\n```\nprepare() {\n  lrzip -d исходник.tar.lrz\n}\n```\n\nОбратите внимание, что хотя source принимает в качестве значений ссылки, в noextract могут указываться только имена файлов:\n\n```\nsource=(\"http://foo.org/bar/foobar.tar.xz\")\nnoextract=('foobar.tar.xz')\n```\n\nЧтобы не извлекать вообще ничего, можно сделать следующее:\n\n- Если source содержит только URL-ссылки без каких либо имён файлов, обрежьте всё до последнего символа слэша включительно:\n\n```\nnoextract=(\"${source[@]##*/}\")\n```\n\n- Если source содержит только имена файлов, обрежьте часть после разделителя :: (взято из файла PKGBUILD firefox-i18n):\n\n```\nnoextract=(\"${source[@]%%::*}\")\n```\n\n"
    },
    {
      "title": "validpgpkeys",
      "level": 3,
      "content": "Массив с PGP-отпечатками. Если указать этот параметр, makepkg будет принимать подписи только от указанных в нём ключей, игнорируя связку ключей (keyring). Если файл исходников подписан подключом, makepkg будет по прежнему использовать основной ключ для сравнения.\n\nВ качестве значений принимаются только полные отпечатки в верхнем регистре. Пробельные символы недопустимы.\n\nПодробнее см. makepkg#Проверка цифровых подписей.\n\n"
    },
    {
      "title": "Целостность",
      "level": 2,
      "content": "Перечисленные ниже переменные представляют собой массивы строк контрольных сумм, которые используются для проверки на целостность соответствующих файлов из массива source. Если вместо контрольной суммы указать значение SKIP, то соответствующий файл проверяться не будет.\n\nТипы и значения контрольных сумм должны предоставляться разработчиками программы, например, в объявлении о релизе. Если доступны несколько типов сумм, следует выбирать более надёжную: sha256 вместо sha1, а sha1 вместо md5. Целостность файлов лучше проверять сразу после загрузки.\n\nЗначения переменных можно сгенерировать опцией makepkg -g/--geninteg; как правило, они добавляются командой makepkg -g >> PKGBUILD. Утилита updpkgsums из пакета pacman-contrib позволяет обновить значения переменных, когда они уже заданы в файле PKGBUILD. Оба инструмента используют те типы контрольных сумм, которые уже указаны в PKGBUILD, или md5sums, если ни одна переменная не задана.\n\nМетод проверки целостности можно задать опцией INTEGRITY_CHECK в файле /etc/makepkg.conf. Подробнее см. makepkg.conf(5).\n\n"
    },
    {
      "title": "md5sums",
      "level": 3,
      "content": "Массив 128-битных контрольных сумм MD5 для файлов из массива source.\n\n"
    },
    {
      "title": "sha1sums",
      "level": 3,
      "content": "Массив 160-битных контрольных сумм SHA-1 для файлов из массива source.\n\n"
    },
    {
      "title": "sha256sums",
      "level": 3,
      "content": "Массив контрольных сумм SHA-2 с размером дайджеста 256 битов.\n\n"
    },
    {
      "title": "sha224sums, sha384sums, sha512sums",
      "level": 3,
      "content": "Массив контрольных сумм SHA-2 с размерами дайджеста 224, 384 и 512 битов соответственно. Редко используемые альтернативы sha256sums.\n\n"
    },
    {
      "title": "b2sums",
      "level": 3,
      "content": "Массив контрольных сумм BLAKE2 с размером дайджеста 512 битов.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Руководство PKGBUILD(5).\n- Пример файла PKGBUILD.\n\n"
    }
  ]
}