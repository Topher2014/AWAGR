{
  "title": "カーネルモジュール",
  "url": "https://wiki.archlinux.org/title/%E3%82%AB%E3%83%BC%E3%83%8D%E3%83%AB%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "関連記事\n\n- ブートデバッグ\n- カーネル\n- カーネルパラメータ\n- カーネルモジュールのコンパイル\n\nカーネルモジュール は、要求に応じてカーネルにロードおよびアンロードできるコードの一部です。これにより、システムを再起動する必要なく、カーネルの機能を拡張することができます。\n\nカーネルモジュールを作成するには、The Linux Kernel Module Programming Guide を参照してください。モジュールは、ビルトインまたはロード可能として設定できます。モジュールを動的にロードまたは削除するには、カーネルの設定でそのモジュールをロード可能なモジュールとして設定する必要があります（そのモジュールに関連する行には M という文字が表示されます）。\n\n新しいカーネルがインストールされるときにカーネルモジュールを自動的に再構築するには、Dynamic Kernel Module Support (DKMS) を参照してください。\n\n"
    },
    {
      "title": "目次",
      "level": 2,
      "content": "- 1 情報を取得\n- 2 モジュールの自動ロード 2.1 モジュールの早期ロード 2.2 systemd\n- 3 手動でモジュールを扱う\n- 4 モジュールオプションを設定する 4.1 ロード時に modprobe を使って手動で行う 4.2 /etc/modprobe.d/ 内のファイルを使用する 4.3 カーネルコマンドラインを使う\n- 5 エイリアス\n- 6 ブラックリスト 6.1 /etc/modprobe.d/ 内のファイルを使う 6.2 カーネルコマンドラインを使う 6.3 インストールしない\n- 7 トラブルシューティング 7.1 モジュールがロードされない\n- 8 参照\n\n- 2.1 モジュールの早期ロード\n- 2.2 systemd\n\n- 4.1 ロード時に modprobe を使って手動で行う\n- 4.2 /etc/modprobe.d/ 内のファイルを使用する\n- 4.3 カーネルコマンドラインを使う\n\n- 6.1 /etc/modprobe.d/ 内のファイルを使う\n- 6.2 カーネルコマンドラインを使う\n- 6.3 インストールしない\n\n- 7.1 モジュールがロードされない\n\n"
    },
    {
      "title": "情報を取得",
      "level": 2,
      "content": "モジュールは /usr/lib/modules/kernel_release に保存されます。uname -r コマンドを使うことで現在のカーネルのリリースバージョンを表示できます。\n\n現在ロードされているカーネルモジュールを表示する:\n\n```\n$ lsmod\n```\n\nモジュールについての情報を表示する:\n\n```\n$ modinfo module_name\n```\n\nロードされたモジュールに設定されたオプションを一覧する:\n\n```\n$ systool -v -m module_name\n```\n\n全てのモジュールの全ての設定を表示する:\n\n```\n$ modprobe -c | less\n```\n\n特定のモジュールの設定を表示する:\n\n```\n$ modprobe -c | grep module_name\n```\n\nモジュール自身を含む、モジュール（やエイリアス）の依存関係を一覧する:\n\n```\n$ modprobe --show-depends module_name\n```\n\n"
    },
    {
      "title": "モジュールの自動ロード",
      "level": 2,
      "content": "今日、必要なモジュールのロードはすべて udev によって自動的に処理されます。したがって、ツリー外のカーネルモジュールを使用する必要がない場合は、ブート時にロードする必要のあるモジュールを設定ファイルに記述する必要はありません。ただし、ブートプロセスで追加のモジュールをロードしたり、コンピューターを正しく機能させるために他のモジュールをブラックリストに入れるなどのケースが考えられます。\n\n"
    },
    {
      "title": "モジュールの早期ロード",
      "level": 3,
      "content": "initramfs イメージには、 /etc/modules-load.d/ で要求されたカーネルモジュールが含まれていない場合があります。また、そのフォルダに設定されているファイルが不足している場合もあります。モジュールの早期ロードは使用する initramfs ジェネレータに依存します。\n\n- mkinitcpio: Mkinitcpio#MODULES を参照してください。\n- dracut: Dracut#カーネルモジュールの早期ロード を参照してください。\n- booster: Booster#モジュールの早期ロード を参照してください。\n\n"
    },
    {
      "title": "systemd",
      "level": 3,
      "content": "カーネルモジュールを /etc/modules-load.d/ 配下のファイルに明示的にリストアップして、systemd が起動時にロードできるようにすることができます。各設定ファイルの名前の形式は /etc/modules-load.d/program.conf です。設定ファイルにはロードするカーネルモジュール名のリストが改行で区切られて含まれています。空行と最初の非空白文字が # または ; である行は無視されます。\n\n```\n/etc/modules-load.d/virtio-net.conf\n```\n\n```\n# 起動時に virtio_net.ko をロード\nvirtio_net\n```\n\n詳しくは modules-load.d(5) を参照してください。\n\n"
    },
    {
      "title": "手動でモジュールを扱う",
      "level": 2,
      "content": "カーネルモジュールは kmod パッケージによって提供されるツールを使って管理します。これらのツールは手動で使用できます。\n\nモジュールをロードするには:\n\n```\n# modprobe module_name\n```\n\nファイル名でモジュールをロードするには（つまり、/usr/lib/modules/$(uname -r)/ にインストールされていないモジュール）:\n\n```\n# insmod filename [args]\n```\n\nモジュールをアンロードするには:\n\n```\n# modprobe -r module_name\n```\n\nもしくは:\n\n```\n# rmmod module_name\n```\n\n"
    },
    {
      "title": "モジュールオプションを設定する",
      "level": 2,
      "content": "カーネル モジュールにパラメータを渡すには、modprobe を使用してパラメータを手動で渡すか、modprobe 設定ファイルまたはカーネルコマンド ラインを使用して特定のパラメータが常に適用されるようにすることができます。モジュールがカーネルに組み込まれている場合は、カーネル コマンド ラインを使用する必要があり、他の方法は機能しません。\n\n"
    },
    {
      "title": "ロード時に modprobe を使って手動で行う",
      "level": 3,
      "content": "モジュールにパラメータを渡す基本的な方法は、modprobe コマンドを使用することです。パラメータはコマンドラインで単純な key=value の代入で指定します。\n\n```\n# modprobe module_name parameter_name=parameter_value\n```\n\n"
    },
    {
      "title": "/etc/modprobe.d/ 内のファイルを使用する",
      "level": 3,
      "content": "/etc/modprobe.d/ ディレクトリ内のファイルは、udev にモジュール設定を渡すために使用できます。これにより、システムの起動時に modprobe を使用してモジュールのロードを管理します。このディレクトリ内の設定ファイルは、.conf 拡張子で終わる任意の名前を持つことができます。構文は次のとおりです:\n\n```\n/etc/modprobe.d/myfilename.conf\n```\n\n```\noptions module_name parameter_name=parameter_value\n```\n\n複数のモジュールパラメータはスペースで区切られ、パラメータにはカンマで区切られた値のリストを指定できます:\n\n```\n/etc/modprobe.d/myfilename.conf\n```\n\n```\noptions module_name param1=value1 param2=value2a,value2b …\n```\n\n例:\n\n```\n/etc/modprobe.d/thinkfan.conf\n```\n\n```\n# ThinkPad では、'thinkfan' デーモンがファンの速度を制御できるようにします\noptions thinkpad_acpi fan_control=1\n```\n\n"
    },
    {
      "title": "カーネルコマンドラインを使う",
      "level": 3,
      "content": "モジュールがカーネルに組み込まれている場合、モジュールにオプションを設定するのにカーネルコマンドラインを使うこともできます。一般的なブートローダでは次の構文を使って下さい:\n\n```\nmodname.parametername=parametercontents\n```\n\n例:\n\n```\nthinkpad_acpi.fan_control=1\n```\n\nカーネルパラメータのページで説明されているようにして、あなたのブートローダのカーネルラインにこれを追加するだけです。\n\n"
    },
    {
      "title": "エイリアス",
      "level": 2,
      "content": "エイリアスによってモジュールに代わりの名前を付けることができます。例: alias my-mod really_long_modulename で modprobe really_long_modulename の代わりに modprobe my-mod を使うことができるようになります。シェルのようにワイルドカードを使うこともできます。alias my-mod* really_long_modulename で modprobe my-mod-something が modprobe really_long_modulename と同じ意味になります。エイリアスを作るには:\n\n```\n/etc/modprobe.d/myalias.conf\n```\n\n```\nalias mymod really_long_module_name\n```\n\nモジュールによっては、アプリケーションがモジュールを必要としたときに自動でロードするためにエイリアスが設定されているものもあります。こういったエイリアスを無効化すると自動ロードも止まります。ただし手動でモジュールをロードすることはできます。\n\n```\n/etc/modprobe.d/modprobe.conf\n```\n\n```\n# Prevent Bluetooth autoload\n\nalias net-pf-31 off\n```\n\n"
    },
    {
      "title": "ブラックリスト",
      "level": 2,
      "content": "カーネルモジュールで、ブラックリストとはカーネルモジュールをロードしないようにすることを指します。ブラックリストが役にたつのは、例えば、関連するハードウェアが必要ない場合や、モジュールをロードすると問題が発生する場合: 2つのカーネルモジュールが同じハードウェアをコントロールしようとして、互いにコンフリクトを生じる場合などです。\n\nいくつかのモジュールは initramfs の一部としてロードされます。mkinitcpio -M ですべての自動検出したモジュールを表示します: initramfs のモジュールのロードを止めるには、/etc/modprobe.d/ 中に .conf ファイルを作成してモジュールをブラックリストに登録します。mkinitcpio -v を実行することで様々なフック（例: ファイルシステムフック、SCSI フックなど）によって使われている全てのモジュールを一覧できます。モジュールをブラックリスト入りさせたら、イメージを生成し、それから再起動してください。\n\n"
    },
    {
      "title": "/etc/modprobe.d/ 内のファイルを使う",
      "level": 3,
      "content": "/etc/modprobe.d/ 内に .conf ファイルを作成し、blacklist キーワードを使って一行ずつブラックリスト入りさせたいモジュールを追加します。例えば pcspkr モジュールをロードさせたくない場合:\n\n```\n/etc/modprobe.d/nobeep.conf\n```\n\n```\n# Do not load the 'pcspkr' module on boot\nblacklist pcspkr\n```\n\nしかしながら、この挙動を変えることが可能です; install コマンドを使って、modprobe に通常通りカーネルでモジュールを挿入する代わりにカスタムコマンドを実行させることで、いつでもモジュールのロードが失敗するように強制することができます:\n\n```\n/etc/modprobe.d/blacklist.conf\n```\n\n```\n...\ninstall module_name /bin/true\n...\n```\n\n"
    },
    {
      "title": "カーネルコマンドラインを使う",
      "level": 3,
      "content": "ブートローダでモジュールをブラックリスト入りさせることもできます。\n\nカーネルパラメータのページで説明されているようにして、あなたのブートローダのカーネルラインに module_blacklist=modname1,modname2,modname3 を追加するだけです。\n\n- 複数のモジュールをブラックリスト入りさせるときは、カンマで分割することを覚えておいて下さい。スペースなどを使うとシンタックスを破壊してしまうおそれがあります。\n- module_blacklist を使用すると、カーネルはそのモジュールのロードを完全に拒否します。暗黙のロードを防ぎたいだけで、後で手動でモジュールをロードする可能性がある場合は、正しいパラメータは modprobe.blacklist=modname1,modname2,modname3 です。ただし、これでは、たとえばsystemd や他のモジュールによる起動中の明示的なロードを防ぐことはできません。\n\n"
    },
    {
      "title": "インストールしない",
      "level": 3,
      "content": "pacman#インストールさせないファイルを設定を使えます。\n\n```\n/etc/pacman.conf\n```\n\n```\nNoExtract=usr/lib/modules/*/kernel/drivers/md/*\n```\n\nこれが最も確実な方法です。\n\n"
    },
    {
      "title": "モジュールがロードされない",
      "level": 3,
      "content": "特定のモジュールがロードされない場合、起動ログ (journalctl -b で見れます) にモジュールがブラックリストに入っていると書かれているのに /etc/modprobe.d/ ディレクトリには該当するエントリが存在しないとき、/usr/lib/modprobe.d/ にある他の modprobe ソースファイルにブラックリストのエントリがないか確認してください。\n\nカーネルモジュールに含まれている \"vermagic\" 文字列が、現在実行中のカーネルの値と一致しない場合もモジュールはロードされません。カーネルとモジュールの互換性に問題がないという確証があるときは modprobe --force-vermagic で \"vermagic\" のチェックを無視させることができます。\n\n"
    },
    {
      "title": "参照",
      "level": 2,
      "content": "- PC スピーカーのビープ音の無効化\n- Writing a WMI driver - an LWM introduction\n\n"
    }
  ]
}