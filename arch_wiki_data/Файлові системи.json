{
  "title": "Файлові системи",
  "url": "https://wiki.archlinux.org/title/%D0%A4%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2%D1%96_%D1%81%D0%B8%D1%81%D1%82%D0%B5%D0%BC%D0%B8",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "З Wikipedia:\n\n"
    },
    {
      "title": "Типи файлових систем",
      "level": 2,
      "content": "Дивіться filesystems(5) для загального огляду, і порівняння файлових систем (англійська) для детального порівняння функцій. Файлові системи, що підтримуються ядром, перелічені в /proc/filesystems.\n\nTable content:\nФайлова система | Команда створення | Утиліти користувацького простору | Archiso [1] | Документація до ядра [2] | Нотатки\nBtrfs | mkfs.btrfs(8) | btrfs-progs | Так | btrfs.html | Статус стабільності\nVFAT | mkfs.fat(8) | dosfstools | Так | vfat.html | файлова система Windows 9x\nexFAT | mkfs.exfat(8) | exfatprogs | Так |  | Нативна файлова система в Linux 5.4. [3]\nmkexfatfs(8) | exfat-utils | Ні | Не застосовується (На основі FUSE) | \nF2FS | mkfs.f2fs(8) | f2fs-tools | Так | f2fs.html | Пристрої на основі Flash\next3 | mke2fs(8) | e2fsprogs | Так | ext3.html | \next4 | mke2fs(8) | e2fsprogs | Так | ext4.html | \nHFS | mkfs.hfsplus(8) | hfsprogsAUR | Ні | hfs.html | Файлова система класичного Mac OS\nHFS+ | mkfs.hfsplus(8) | hfsprogsAUR | Ні | hfsplus.html | Файлова система macOS (8–10.12)\nJFS | mkfs.jfs(8) | jfsutils | Так | jfs.html | \nNILFS2 | mkfs.nilfs2(8) | nilfs-utils | Так | nilfs2.html | RAW flash пристрої, наприклад SD card\nNTFS |  |  | Ні | ntfs.html[мертве посилання 2024-07-30 ⓘ] | Файлова система Windows NT. Вбудований драйвер ядра має дуже обмежену підтримку запису. офіційно підтримувані ядра не побудовані з CONFIG_NTFS_FS тому цей драйвер недоступний.\nmkfs.ntfs(8) | ntfs-3g | Так | Не застосовується (На основі FUSE) | Драйвер FUSE з розширеними можливостями.\nReiserFS | mkfs.reiserfs(8) | reiserfsprogsAUR | Так |  | \nUDF | mkfs.udf(8) | udftools | Так | udf.html | \nXFS | mkfs.xfs(8) | xfsprogs | Так | xfs.html xfs-delayed-logging-design.html[мертве посилання 2024-03-03 ⓘ] xfs-self-describing-metadata.html[мертве посилання 2024-03-03 ⓘ] | \n\nxfs.html xfs-delayed-logging-design.html[мертве посилання 2024-03-03 ⓘ] xfs-self-describing-metadata.html[мертве посилання 2024-03-03 ⓘ]\n\nTable content:\nФайлова система | Команда створення | Патчсет ядра | Утиліти користувацького простору | Нотатки\nAPFS | mkapfs(8) | linux-apfs-rw-dkms-gitAUR | apfsprogs-gitAUR | Файлова система macOS (10.13 і вище). Лише для читання, експериментальний.\nBcachefs | bcachefs(8) | linux-bcachefs-gitAUR | bcachefs-tools-gitAUR | \nNTFS3 |  | ntfs3-dkmsAUR[пакет відсутній: package not found] |  | питання щодо Paragon NTFS3\nReiser4 | mkfs.reiser4(8) |  | reiser4progsAUR | \nZFS |  | zfs-linuxAUR, zfs-dkmsAUR | zfs-utilsAUR | OpenZFS порт\n\n"
    },
    {
      "title": "Журналювання",
      "level": 3,
      "content": "Усі вищезазначені файлові системи, за винятком exFAT, ext2, FAT16/32, Reiser4 (необов’язково), Btrfs та ZFS, використовують журналювання (англійська). Ведення журналу забезпечує стійкість до несправностей, реєструючи зміни, перш ніж вони будуть передані у файлову систему. У випадку збою системи або збою живлення такі файлові системи швидше повертаються в Інтернет і рідше пошкоджуються. Ведення журналу відбувається у виділеній області файлової системи. Не всі методи ведення журналу однакові. Ext3 та ext4 пропонують ведення журналу даних у режимі даних, який реєструє як дані, так і метадані, а також можливість реєструвати лише зміни метаданих. Ведення журналу в режимі даних передбачає обмеження швидкості і за замовчуванням не вмикається. У тому ж ключі Reiser4 пропонує так звані \"моделі транзакцій\" які не тільки змінюють функції, які ця файлова система надає, але і в режимі ведення журналу. Вона використовує різні техніки ведення журналу: спеціальна модель, яка називається мандрівними журналами, що позбавляє від необхідності писати на диск двічі, запис будь-де - підхід копіювання водночас зі записом (переважно еквівалентний за замовчуванням btrfs, але з принципово іншим дизайном \"дерева\") та комбінований підхід, що називається гібридним, який евристично чергується між двома попередніми.\n\nNote: **node41** \n\nІнші файлові системи забезпечують ведення журналу в упорядкованому режимі, який реєструє лише метадані. Хоча всі журнали повертають файлову систему до дійсного стану після збою, журнал у режимі даних пропонує найбільший захист від втрати даних. Однак у продуктивності системи є один мінус, оскільки ведення журналу в режимі даних виконує дві операції запису: спочатку в журнал, а потім на диск (чого Reiser4 уникає за допомогою функції \"мандрівних журналів\"). При виборі типу файлової системи слід враховувати компроміс між швидкістю системи та безпекою даних. Reiser4 є єдиною файловою системою, яка за задумом працює з повною атомністю, а також забезпечує контрольні суми як для метаданих, так і для вбудованих даних (операції виконуються повністю, або вони повністю не пошкоджують або не руйнують дані внаслідок половинних операцій) і тому набагато менш схильний до втрати даних, ніж інші файлові системи, такі як Btrfs.\n\nФайлові системи, засновані на копіюванні водночас зі записом (також відомі як запис будь-де), такі як Reiser4, Btrfs та ZFS, не мають потреби використовувати традиційний журнал для захисту метаданих, оскільки вони ніколи не оновлюються на місці. Незважаючи на те, що Btrfs все ще має журналоподібне дерево журналів, воно використовується лише для прискорення fdatasync/fsync.\n\n"
    },
    {
      "title": "Файлові системи засновані на FUSE",
      "level": 3,
      "content": "Дивіться FUSE.\n\n"
    },
    {
      "title": "Файлові системи, які не зберігають дані самі",
      "level": 3,
      "content": "- eCryptfs — The Enterprise Cryptographic Filesystem - це пакет програмного забезпечення для шифрування дисків для Linux. Він реалізований як рівень шифрування на рівні файлової системи, сумісний з POSIX, маючи на меті запропонувати функціональність, подібну до функцій GnuPG на рівні операційної системи.\n\n- mergerfs — файлова система об'єднання на основі FUSE.\n\n- mhddfs — Файлова система FUSE для декількома дисків, об’єднана файлова система на основі FUSE.\n\n- overlayfs — OverlayFS - це служба файлової системи для Linux, яка реалізує об'єднання для інших файлових систем.\n\n- Unionfs — Unionfs - це служба файлової системи для Linux, FreeBSD та NetBSD, яка реалізує з'єднання для інших файлових систем.\n\n- unionfs-fuse — Реалізація Unionfs в просторі користувача.\n\n"
    },
    {
      "title": "Файлові системи лише для читання",
      "level": 3,
      "content": "- EROFS — Enhanced Read-Only File System - це легка файлова система, призначена лише для читання.\n\n- SquashFS — SquashFS - це стисла файлова система лише для читання. SquashFS стискає файли, вузли та каталоги й підтримує розміри блоків до 1 МБ для більшої стиснення.\n\n"
    },
    {
      "title": "Розподілені файлові системи",
      "level": 3,
      "content": "- Ceph — Уніфікована розподілена система зберігання, розроблена для чудової продуктивності, надійності та масштабованості.\n\n- Glusterfs — Кластерна файлова система, здатна масштабувати до кількох петабайт.\n\n- IPFS — Гіпермедіа-протокол однорангової мережі, робить Інтернет швидшим, безпечнішим та відкритішим. Цілі IPFS замінюють HTTP та створюють кращу мережу для всіх нас. Використовує блоки для зберігання частин файлу, кожен вузол мережі зберігає лише той вміст, який його цікавить, забезпечує дедуплікацію, розподіл, масштабовану систему, обмежену лише користувачами. (в даний час в альфа-версії)\n\n- MooseFS — MooseFS - це відмовостійка, високодоступна та високопродуктивна масштабована мережева розподілена файлова система.\n\n- OpenAFS — Реалізація розподіленої файлової системи з відкритим кодом AFS.\n\n- OrangeFS — OrangeFS - це масштабована мережева файлова система, розроблена для паралельного прозорого доступу до мультисерверного дискового сховища. Оптимізована підтримка MPI-IO для паралельних та розподілених додатків. Спрощує використання паралельного сховища не тільки для клієнтів Linux, але і Windows, Hadoop та WebDAV. Сумісний з POSIX. Є частиною ядра Linux з версії 4.6.\n\n- Sheepdog — Розподілена система зберігання об'єктів для служб обсягу та контейнерів та інтелектуально управляє дисками та вузлами.\n\n- Tahoe-LAFS — Файлова система Tahoe Least-Authority - це безкоштовна та відкрита, безпечна, децентралізована, відмовостійка, однорангова розподілена база даних та розподілена файлова система.\n\n"
    },
    {
      "title": "Файлові системи на спільному диску",
      "level": 3,
      "content": "- GFS2 — GFS2 дозволяє всім членам кластера мати прямий одночасний доступ до одного спільного сховища блоків.\n\n- OCFS2 — Кластерна файлова система Oracle 2 (The Oracle Cluster File System) - це спільна дискова файлова система, розроблена корпорацією Oracle і випущена під GNU General Public License.\n\n- VMware VMFS — VMware VMFS (файлова система віртуальної машини) використовується флагманським пакетом віртуалізації серверів компанії vSphere.\n\n"
    },
    {
      "title": "Ідентифікація існуючих файлових систем",
      "level": 2,
      "content": "Щоб ідентифікувати існуючі файлові системи, ви можете використати команду lsblk:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE LABEL     UUID                                 MOUNTPOINT\nsdb                                                          \n└─sdb1 vfat   Transcend 4A3C-A9E9\n```\n\nІснуюча файлова система, якщо є, буде відображена в колонці FSTYPE. Якщо файлова система змонтована на жорсткий диск, вона буде відображена в колонці MOUNTPOINT.\n\n"
    },
    {
      "title": "Створення файлової системи",
      "level": 2,
      "content": "Файлові системи зазвичай створюються на розділі, всередині логічних контейнерів, таких як LVM, RAID та dm-crypt, або на звичайному файлі (див. loop device). У цьому розділі описано випадок розділів.\n\nNote: **Створіть резервну копію будь-яких даних, які ви хочете зберегти** \n\n- Після створення нової файлової системи, дані, які раніше зберігались у цьому розділі, навряд чи можуть бути відновлені. Створіть резервну копію будь-яких даних, які ви хочете зберегти.\n- Призначення даного розділу може обмежити вибір файлової системи. Наприклад, розділ системи EFI повинен містити файлову систему FAT32, а файлова система, що містить каталог boot, повинна підтримуватися завантажувачем.\n\nПерш ніж продовжувати, визначте пристрій, де буде створена файлова система, і чи вона змонтована. Наприклад:\n\n```\n$ lsblk -f\n```\n\n```\nNAME   FSTYPE   LABEL       UUID                                 MOUNTPOINT\nsda\n├─sda1                      C4DA-2C4D                            \n├─sda2 ext4                 5b1564b2-2e2c-452c-bcfa-d1f572ae99f2 /mnt\n└─sda3                      56adc99b-a61e-46af-aab7-a6d07e504652\n```\n\nПеред продовженням змонтовані файлові системи треба демонтувати. У наведеному вище прикладі існуюча файлова система знаходиться на /dev/sda2 і монтується на /mnt. Її можна демонтувати за допомогою:\n\n```\n# umount /dev/sda2\n```\n\nЩоб знайти щойно змонтовані файлові системи, дивіться #Перелік змонтованих файлових систем.\n\nЩоб створити нову файлову систему, використовуйте mkfs(8). Дивіться #Типи файлових систем для точного типу, а також утиліти користувацького простору, які ви можете встановити для певної файлової системи.\n\nНаприклад, для створення нової файлової системи типу ext4 (загальної для розділів даних Linux) на /dev/sda1, введіть:\n\n```\n# mkfs.ext4 /dev/sda1\n```\n\n- Використовуйте аргумент -L для mkfs.ext4, щоб вказати мітку файлової системи. e2label можна використовувати для зміни мітки в існуючій файловій системі.\n- File systems may be resized after creation, with certain limitations. For example, an XFS filesystem's size can be increased, but it cannot reduced. See Wikipedia:Comparison of file systems#Resize capabilities and the respective file system documentation for details.\n\n- Файлові системи можуть бути змінені в розмірі після створення, з певними обмеженнями. Наприклад, розмір файлової системи XFS можна збільшити, але його не можна зменшити. Детальніше дивіться У розділі Можливості змінення розміру та відповідної документації щодо файлової системи для деталей.}}\n\nНова файлова система може бути змонтована на будь-яку директорію.\n\n"
    },
    {
      "title": "Монтування файлової системи",
      "level": 2,
      "content": "Щоб вручну змонтувати файлову систему на пристрої (наприклад розділу диска), ви можете використати команду mount(8). Наступна команда змонтує /dev/sda1 на /mnt:\n\n```\n# mount /dev/sda1 /mnt\n```\n\nЦе прикріплює файлову систему на /dev/sda1 у директорії /mnt, тим самим робить усе на файловій системі видним. Будь-які дані, які були в /mnt до цієї команди були невидимі. fstab має інформацію щодо того, як автоматично монтувати пристрої якщо вони є. Дивіться fstab для отримання додаткової інформації щодо модифікування цієї поведінки.\n\nЯкщо пристрій є в /etc/fstab і також визначена директорія або інший пристрій, ця інформація буде використана для монтування. Наприклад, якщо /etc/fstab має строку яка вказує що /dev/sda1 має бути змонтованим на /mnt, воно автоматично змонтує цей пристрій на цю директорію.\n\nmount має декілька опцій, багато з яких залежать від визначеної файлової системи.\n\nОпції можуть бути змінитися:\n\n- використання аргументів в командному рядку з mount\n- редагування fstab\n- creating udev rules\n- створення правил udev\n- самостійна компіляція ядра\n- або використання специфічних для файлової системи скриптів (розташовані в /usr/bin/mount.*).\n\nДля отримання додаткової інформації, дивіться пов’язані статті та статтю конкретної файлової системи.\n\n"
    },
    {
      "title": "Перелік змонтованих файлових систем",
      "level": 3,
      "content": "Для переліку всіх змонтованих файлових систем, використовуйте findmnt(8):\n\n```\n$ findmnt\n```\n\nfindmnt бере безліч аргументів, які можуть фільтрувати вихідні дані та показувати додаткову інформацію. Наприклад, findmnt може взяти пристрій або точку монтування як аргумент, щоб показати лише інформацію про те, що вказано:\n\n```\n$ findmnt /dev/sda1\n```\n\nfindmnt збирає інформацію з /etc/fstab, /etc/mtab та /proc/self/mounts.\n\n"
    },
    {
      "title": "Демонтування файлової системи",
      "level": 3,
      "content": "Для демонтажу файлової системи використовуйте umount(8). Можна вказати пристрій, що містить файлову систему (наприклад, /dev/sda1), або точку монтування (наприклад, /mnt):\n\n```\n# umount /dev/sda1\n```\n\nабо\n\n```\n# umount /mnt\n```\n\n"
    },
    {
      "title": "Дивіться також",
      "level": 2,
      "content": "- filesystems(5)\n- systemd-mount(1)\n- Документація файлових систем, що підтримуються Linux\n- Wikipedia:uk:Файлова система\n- Wikipedia:uk:mount\n\n"
    }
  ]
}