{
  "title": "Readline (Русский)",
  "url": "https://wiki.archlinux.org/title/Readline_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Readline — библиотека GNU Project, которую Bash и другие программы с CLI-интерфейсом используют для взаимодействия с командной строкой. Подробнее см. readline(3).\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Вероятнее всего, пакет readline уже установлен как зависимость Bash.\n\n"
    },
    {
      "title": "Режим редактирования",
      "level": 2,
      "content": "По умолчанию Readline использует для взаимодействия с командной строкой комбинации клавиш в стиле Emacs. Чтобы выбрать стиль vi, добавьте следующую строку в файл ~/.inputrc:\n\n```\n~/.inputrc\n```\n\n```\nset editing-mode vi\n```\n\nЕсли вы хотите задать этот режим только для Bash, отредактируйте ~/.bashrc:\n\n```\n~/.bashrc\n```\n\n```\nset -o vi\n```\n\n"
    },
    {
      "title": "Индикатор режима в приглашении",
      "level": 3,
      "content": "Редактирование в стиле vi имеет два режима: командный и вставки. Настроить отображение индикатора режима можно следующей опцией:\n\n```\n~/.inputrc\n```\n\n```\nset show-mode-in-prompt on\n```\n\nТеперь в вашем приглашении будет отображаться строка-индикатор (по умолчанию — (cmd)/(ins)), которую можно модифицировать переменными vi-ins-mode-string и vi-cmd-mode-string.\n\n"
    },
    {
      "title": "Разные формы курсора для режимов",
      "level": 3,
      "content": "Форма курсора выбирается с помощью escape-последовательностей \"\\1 .. \\2\":\n\n```\n~/.inputrc\n```\n\n```\nset vi-ins-mode-string \\1\\e[6 q\\2\nset vi-cmd-mode-string \\1\\e[2 q\\2\n```\n\nЗдесь для командного режима выбран курсор-блок, а для режима вставки — вертикальная линия. Чтобы это работало, необходимо включить индикатор режима редактирования (см. #Индикатор режима в приглашении).\n\nВ виртуальной консоли используются другие коды управляющих последовательностей, так что сначала необходимо проверить, какой терминал используется:\n\n```\n~/.inputrc\n```\n\n```\n$if term=linux\n\tset vi-ins-mode-string \\1\\e[?0c\\2\n\tset vi-cmd-mode-string \\1\\e[?8c\\2\n$else\n\tset vi-ins-mode-string \\1\\e[6 q\\2\n\tset vi-cmd-mode-string \\1\\e[2 q\\2\n$endif\n```\n\nПодробнее см. документацию о программном курсоре для VGA.\n\n"
    },
    {
      "title": "Быстрое перемещение по словам",
      "level": 2,
      "content": "Xterm поддерживает перемещение по словам клавишами Ctrl+Left и Ctrl+Right по умолчанию. Чтобы настроить этот эффект в других эмуляторах, выберите подходящие коды терминала и присвойте их переменным backward-word и forward-word в файле ~/.inputrc.\n\nНапример, для urxvt:\n\n```\n~/.inputrc\n```\n\n```\n\"\\e[1;5D\": backward-word\n\"\\e[1;5C\": forward-word\n```\n\n"
    },
    {
      "title": "История команд",
      "level": 2,
      "content": "Обычно нажатие клавиши \"стрелка вверх\" выводит последнюю команду вне зависимости от того, что было (частично) введено на данный момент. Более практично будет искать только те прошлые команды, которые совпадают с текущим вводом.\n\nНапример, пользователь вводил следующие команды:\n\n- ls /usr/src/linux-2.6.15-ARCH/kernel/power/Kconfig\n- who\n- mount\n- man mount\n\nЕсли в этой ситуации набрать ls и нажать стрелку, текущий ввод будет заменён на man mount, последнюю выполненную команду. Если поиск по истории включён, то показываться будут только прошлые команды, начинающиеся с ls (текущий ввод), в данном случае — ls /usr/src/linux-2.6.15-ARCH/kernel/power/Kconfig.\n\nВключить режим поиска по истории можно следующими строками в /etc/inputrc или ~/.inputrc:\n\n```\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n```\n\nЕсли вы используете режим vi, то добавьте следующие строки в ~/.inputrc (из этого сообщения):\n\n```\nset editing-mode vi\n$if mode=vi\nset keymap vi-command\n# для командного режима vi\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\nj: history-search-forward\nk: history-search-backward\nset keymap vi-insert\n# для режима вставки vi\n\"\\e[A\": history-search-backward\n\"\\e[B\": history-search-forward\n$endif\n```\n\nЕсли вы настраивали файл ~/.inputrc, то рекомендуется добавить в него ещё одну строку, чтобы избежать странных вещей вроде этой:\n\n```\n$include /etc/inputrc\n```\n\nВ качестве альтернативы можно использовать инкрементный поиск по комбинации Ctrl+R. В этом случае поиск будет вестись не по последним командам, а по похожим. Повторное нажатие Ctrl+R при работе в этом режиме отобразит предыдущую строку в буфере, совпадающую с текущей строкой поиска, а Ctrl+G отменит поиск и восстановит текущий ввод. Так, чтобы поиск шёл среди ранее выполненных команд mount, нажмите Ctrl+R, введите 'mount' и продолжайте нажимать Ctrl+R, пока не дойдёте до нужной команды.\n\nОбратный (вперёд) эквивалент этого режима называется forward-search-history и привязан к комбинации Ctrl+S. Правда, в большинстве терминалов комбинация Ctrl+S переопределена на приостановку выполнения програмы до нажатия Ctrl+Q (т.н. управление выполнением XON/XOFF). Для активации forward-search-history либо отключите управление потоком выполнения:\n\n```\n$ stty -ixon\n```\n\nлибо назначьте в inputrc другую комбинацию. Например, можно использовать Alt+S:\n\n```\n\"\\es\": forward-search-history\n```\n\n"
    },
    {
      "title": "Быстрое завершение",
      "level": 2,
      "content": "При автодополнении (tab completion) одиночное нажатие клавиши tab пытается дополнить команду. Если частичное дополнение невозможно, двукратное нажатие покажет все возможные завершения.\n\nМожно изменить двойное нажатие на одиночное:\n\n```\n~/.inputrc\n```\n\n```\nset show-all-if-unmodified on\n```\n\nЛибо же можно настроить, чтобы такое одиночное нажатие выполняло оба действия: дополнение слова и показ всех возможных завершений, если полное дополнение невозможно:\n\n```\n~/.inputrc\n```\n\n```\nset show-all-if-ambiguous on\n```\n\n"
    },
    {
      "title": "Цветное завершение",
      "level": 2,
      "content": "Включить цветное отображение имён файлов можно опцией colored-stats. При желании можно настроить подсветку одинакового префикса в списке возможных завершений опцией colored-completion-prefix. Например:\n\n```\n~/.inputrc\n```\n\n```\n# Цвет файла в зависимости от типа\n# Может вызвать мерцание текста в некоторых терминалах (например, xterm)\nset colored-stats On\n# Добавление символа для обозначения типа\nset visible-stats On\n# Пометить каталоги-ссылки\nset mark-symlinked-directories On\n# Цветовое выделение общего префикса\nset colored-completion-prefix On\n# Цветовое выделение общего префикса и завершение с помощью меню\nset menu-complete-display-prefix On\n```\n\n"
    },
    {
      "title": "Макросы",
      "level": 2,
      "content": "Readline позволяет привязывать клавиатурные макросы на клавиши. Например, выполните эту команду в Bash:\n\n```\nbind '\"\\ew\": \"\\C-e # macro\"'\n```\n\nили добавьте строку внутри одиночных кавычек в inputrc:\n\n```\n\"\\ew\": \"\\C-e # macro\"\n```\n\nТеперь введите любую строку и нажмите Alt+W. Readline будет действовать как при нажатии Ctrl+E (end-of-line) с добавлением в конце строки \" # macro\".\n\nМакросы позволяют автоматизировать часто используемые идиомы. Например, добавление \"| less\" к строке и \"нажатие\" Ctrl+M (эквивалент Enter) по комбинации Ctrl+Alt+L:\n\n```\n\"\\e\\C-l\": \"\\C-e | less\\C-m\"\n```\n\nДобавление префикса 'yes |' по нажатию Ctrl+Alt+Y, в результате чего программа получит утвердительный ответ на любой вопрос \"да/нет\":\n\n```\n\"\\e\\C-y\": \"\\C-ayes | \\C-m\"\n```\n\nДобавление префикса su -c '' по нажатию Alt+S:\n\n```\n\"\\es\": \"\\C-a su -c '\\C-e'\\C-m\"\n```\n\nДобавление префикса sudo по нажатию Alt+S. Несколько безопаснее, чем предыдущий пример, потому что не происходит нажатия Enter:\n\n```\n\"\\es\": \"\\C-asudo \\C-e\"\n```\n\nНаконец, быстрый перевод программы в фоновый режим выполнения с удалением всего вывода по комбинации Ctrl+Alt+B.\n\n```\n\"\\e\\C-b\": \"\\C-e > /dev/null 2>&1 &\\C-m\"\n```\n\n"
    },
    {
      "title": "Отключение отображения клавиши control",
      "level": 2,
      "content": "Readline выдаёт в терминал строку ^C при нажатия Ctrl+C. Чтобы это отключить, просто добавьте следующие строки в ~/.inputrc:\n\n```\nset echo-control-characters off\n```\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Редактирование в режиме vi\n- Редактирование в режиме emacs\n\n"
    }
  ]
}