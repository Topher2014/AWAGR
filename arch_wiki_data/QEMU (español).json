{
  "title": "QEMU (español)",
  "url": "https://wiki.archlinux.org/title/QEMU_(espa%C3%B1ol)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Note: **La traducción de este artículo o sección no refleja el texto original.** La traducción de este artículo o sección no refleja el texto original.\n\nLa traducción de este artículo o sección no refleja el texto original.\n\nNote: **2017-01-12** \n\nArtículos relacionados\n\n- Category:Hypervisors\n- Libvirt\n\nDe acuerdo con la wiki de QEMU, \"QEMU es un emulador genérico y de código abierto de máquinas virtuales.\"\n\nCuando se utiliza como un emulador de máquina, QEMU puede correr sistemas operativos y programas hechos para una máquina en particular (por ej. una placa ARM) en una máquina diferente (e.j. tu PC x86). Usando la traducción dinámica, se consigue un rendimiento muy bueno.\n\nQEMU puede usar hipervisores como Xen o KVM para utilizar las extensiones del procesador para la virtualización. Cuando se utiliza como virtualizador, QEMU alcanza un rendimiento cercano a el nativo ejecutando el código de invitado directamente en el CPU host.\n\n"
    },
    {
      "title": "Instalación",
      "level": 2,
      "content": "Instale el paquete qemu-full (ó qemu-base para la versión sin GUI y qemu-desktop para la versión con solo emulación x86_64 por defecto) y los paquetes opcionales para tus necesidades:\n\n- qemu-block-gluster - Soporte para bloque Glusterfs\n- qemu-block-iscsi - Soporte para bloque iSCSI\n- samba - Soporte para servidor SMB/CIFS\n\n"
    },
    {
      "title": "Front-ends para QEMU",
      "level": 2,
      "content": "A diferencia de otros programas de virtualización como VirtualBox y VMware, QEMU no proporciona una interfaz gráfica de usuario para administrar máquinas virtuales (a parte de la ventana que aparece cuando se ejecuta una máquina virtual), tampoco proporciona una forma de crear una máquina virtual persistente con valores guardados. Todos los parámetros para ejecutar una máquina virtual deben especificarse en la línea de comandos en cada puesta en marcha, a menos que haga un script personalizadp para iniciar su máquina(s) virtual. Sin embargo, hay varios front-end GUI para QEMU:\n\n- qemu-launcherAUR\n- qtemuAUR\n- aqemuAUR\n\nfront-ends con soporte para QEMU están disponibles por libvirt.\n\n"
    },
    {
      "title": "Creando una imagen de disco duro",
      "level": 3,
      "content": "Para ejecutar QMEU necesitarás una imagen de disco duro, a menos que estés cargando un sistema en vivo desde el CD-ROM ó la red (y no para instalar un sistema operativo en una imagen de disco duro). Una imagen de disco es un archivo que almacena los contenidos del disco duro emulado.\n\nUna imagen de disco puede ser en \"crudo\", de manera que, literalemte, byte por byte es lo mismo que el cliente ve, y siempre utilizará toda la capacidad del disco duro del disco duro invitado en el host. Este método proporciona la menor sobrecarga de Entrada / Salida, pero puede desperdiciar una gran cantidad de espacio, ya que el espacio no utilizado por el invitado no se puede utilizar en el host.\n\nPor otra parte, la imagen de disco duro puede estar en un formato tal como el de qcow2 el cuál únicamente asigna espacio a el archivo de la imagen cuando el SO invitado está escribiendo en los sectores del disco virtual. La imagen aparece como el tamaño total del sistema operativo huésped, a pesar que puede tomar hasta una cantidad muy pequeña de espacio en el sistema host. El uso de este formato en lugar de el \"crudo\" probablemente afecte el rendimiento.\n\nQEMU proporciona el qemu-img comando para crear imagenes de disco. Por ejemplo, para crear una imagen de 4GB en formato \"crudo\":\n\n```\n$ qemu-img create -f raw image_file 4G\n```\n\nSe puede uiltizar -f qcow2 para crear un disco qcow2 en su lugar.\n\n"
    },
    {
      "title": "Superposición de imágenes de almacenamiento",
      "level": 4,
      "content": "Puede crear una imagen de almacenamiento una vez (la imagen de respaldo) y hacer que QEMU mantenga mutaciones a esta imagen en una imagen de superposición. Esto le permite volver a un estado anterior de esta imagen de almacenamiento. Puede volver a crear una nueva imagen de superposición en el momento en que desea revertir en función de la imagen de respaldo original.\n\nPara crear una imagen de superposición, ingrese el comando:\n\n```\n$ qemu-img create -o backing_file=img1.raw,backing_fmt=raw -f qcow2 img1.cow\n```\n\nDespués de eso, puede ejecutar su máquina virtual como de costumbre (ver #Ejecución del sistema virtualizado):\n\n```\n$ qemu-system-x86_64 img1.cow\n```\n\nLa imagen de respaldo se dejará intacta y se registrarán mutaciones en este almacenamiento en el archivo de imagen de superposición.\n\nCuando cambia la ruta de acceso a la imagen de respaldo, se requiere reparación.\n\nAsegúrese de que la ruta de la imagen de respaldo original sigue conduciendo a esta imagen. Si es necesario, haga un enlace simbólico en la ruta original a la nueva ruta. A continuación, emita un comando como:\n\n```\n$ qemu-img rebase -b /new/img1.raw /new/img1.cow\n```\n\nA su discreción, usted puede alternativamente realizar un rebase 'inseguro' donde no se comprueba la ruta anterior a la imagen de respaldo:\n\n```\n$ qemu-img rebase -u -b /new/img1.raw /new/img1.cow\n```\n\n"
    },
    {
      "title": "Cambiar el tamaño de una imagen",
      "level": 4,
      "content": "Note: **no arrancable** \n\nEl ejecutable qemu-img tiene la opción resize, que permite redimensionar fácilmente una imagen de disco duro. Funciona tanto para raw como para qcow2. Por ejemplo, para aumentar el espacio de imagen en 10GB, ingresa:\n\n```\n$ qemu-img resize disk_image +10G\n```\n\nDespués de ampliar la imagen de disco, debe utilizar el sistema de archivos y las herramientas de particionamiento dentro de la máquina virtual para comenzar a utilizar el nuevo espacio. Al reducir una imagen de disco, primero debe reducir los sistemas de archivos y los tamaños de partición asignados usando el sistema de archivos y las herramientas de partición dentro de la máquina virtual y luego reducir la imagen del disco en consecuencia, de lo contrario reducir la imagen del disco resultará en ¡pérdida de datos!\n\n"
    },
    {
      "title": "Preparando el medio de instalación",
      "level": 3,
      "content": "Para instalar un sistema operativo en su imagen de disco, necesita el medio de instalación (por ejemplo, disco óptico, unidad USB o imagen ISO) para el sistema operativo. El soporte de instalación no debe montarse porque QEMU accede directamente al medio.\n\n```\n$ dd if=/dev/cdrom of=Cd_image.iso\n```\n\n"
    },
    {
      "title": "Instalando el sistema operativo",
      "level": 3,
      "content": "Esta es la primera vez que necesitará iniciar el emulador. Para instalar el sistema operativo en la imagen de disco, debe adjuntar la imagen de disco y el medio de instalación a la máquina virtual y hacer que arranque desde el soporte de instalación.\n\nPor ejemplo, en invitados i386, para instalar desde un archivo ISO de arranque como CD-ROM y una imagen de disco sin formato:\n\n```\n$ qemu-system-x86_64 -cdrom iso_image -boot order=d -drive file=disk_image,format=raw\n```\n\nConsulte qemu (1) para obtener más información sobre cómo cargar otros tipos de medios (como disquetes, imágenes de disco o unidades físicas) y #Ejecución del sistema virtualizado para otras opciones útiles.\n\nUna vez que el sistema operativo haya finalizado de instalar, la imagen de QEMU se puede iniciar directamente (ver #Ejecución del sistema virtualizado).\n\n- En lugar de especificar -boot order = x, algunos usuarios pueden sentirse más cómodos usando un menú de arranque: -boot menu = on, al menos durante la configuración y la experimentación.\n- Si necesita reemplazar disquetes o CD como parte del proceso de instalación, puede usar el monitor de la máquina QEMU (presione Ctrl + Alt + 2 en la ventana de la máquina virtual) para quitar y conectar dispositivos de almacenamiento a un máquina virtual. Escriba info block para ver los dispositivos de bloque y use el comando change para intercambiar un dispositivo. Pulse Ctrl + Alt + 1 para volver a la máquina virtual.\n\n"
    },
    {
      "title": "Ejecución del sistema virtualizado",
      "level": 2,
      "content": "Los binarios qemu-system-* (por e.j. qemu-system-i386 ó qemu-system-x86_64, dependiendo de la arquitectura del huésped) se usan para ejecutar el sistema virtualizado. El uso es:\n\n```\n$ qemu-system-x86_64 options disk_image\n```\n\nLas opciones son las mismas para todos los binarios qemu-system-*, mira qemu(1) para más información sobre todas las opciones.\n\nPor defecto, QEMU mostrará la salida de video de la máquina virtual en una ventana. Una cosa a considerar: al hacer click dentro de la ventana de QMEU, el puntero del cursor será capturado. Para liberarlo presione Ctrl+Alt+g.\n\n"
    },
    {
      "title": "Activar KVM",
      "level": 3,
      "content": "KVM debe ser soportado por su procesador y kernel, y necesariamente los módulos del kernel deben ser cargados. Mira KVM para más información.\n\nPara iniciar QEMU en modo KVM, adjunta -enable-kvm a las opciones de inicio adicionales. Para verificar si KVM está activado para ejecutar una máquina virtual, ingresa a la wiki de QEMU Monitor, usando Ctrl+Alt+Shift+2, e ingresando info kvm.\n\n- Si inicia su máquina virtual con una herramienta GUI y experimenta un rendimiento muy malo, debe verificar el soporte adecuado de KVM.\n- KVM necesita activarse en orden de iniciar adecuadamente Windows 7 y Windows 8 sin pantallazo azul.\n\n"
    },
    {
      "title": "Habilitar soporte IOMMU (Intel VT-d/AMD-Vi)",
      "level": 3,
      "content": "Usando IOMMU (unidad de gestión de memoria de entrada y salida) se abre a las caraterísticas como el paso del PCI y la protección de la memoria de dispositivos defectuosos o maliciosos, mira wikipedia:Input-output memory management unit#Advantages y Memory Management (computer programming): Could you explain IOMMU in plain English?.\n\nPara habilitar IOMMU:\n\n1. Asegure que AMD-Vi/Intel VT-d es soportado por el CPU y es habilitado en la configuración de BIOS.\n1. Agregue intel_iommu=on si tienes un procesador Intel ó amd_iommu=on si tienes un procesador AMD en los parámetros del kernel (kernel parameters)\n1. Reinicie y asegure que IOMMU está habilitado verificando dmesg para DMAR: [0.000000] DMAR: IOMMU enabled\n1. Añade -device intel-iommu para crear el dispositivo IOMMU:\n\n```\n$ qemu-system-x86_64 -enable-kvm -machine q35 -device intel-iommu -cpu host ..\n```\n\n"
    },
    {
      "title": "Red",
      "level": 3,
      "content": "Los datos pueden compartirse entre el host y el sistema operativo huésped usando cualquier protocolo de red que pueda transferir archivos, como NFS, SMB, NBD, HTTP, FTP, ó SSH, siempre que haya configurado la red apropiadamente y haya habilitado los servicios apropiados.\n\nLa red por defecto del modo de usuario permite al huésped acceder al sistema operativo host en la dirección IP 10.0.2.2. Todos los servidores que se estén ejecutando en el sistema operativo anfitrión, como un servidor SSH o un servidor SMB, estarán accesibles en esta dirección IP. Así que en los invitados, puede montar los directorios exportados en el host a través de SMB o NFS, o puede acceder al servidor HTTP del host, etc. No será posible que el sistema operativo anfitrión acceda a los servidores que se ejecutan en el sistema operativo invitado, pero esto puede hacerse con otras configuraciones de red (consulte #Tap de red con QEMU).\n\n"
    },
    {
      "title": "Servidor SMB incorporado de QEMU",
      "level": 3,
      "content": "La documentación de QEMU dice que tiene un servidor SMB \"incorporado\", pero en realidad acaba de iniciar Samba con un archivo smb.conf generado automáticamente ubicado en /tmp/qemu- Smb.Pid-0/smb.conf y lo hace accesible para el invitado en una dirección IP diferente (10.0.2.4 por defecto). Esto sólo funciona para la red de usuarios, y esto no es necesariamente muy útil ya que el invitado también puede acceder al servicio normal Samba en el host si ha configurado acciones en él.\n\nPara habilitar esta característica, inicie QEMU con un comando como:\n\n```\n$ qemu-system-x86_64 -nic user,id=nic0,smb=shared_dir_path disk_image\n```\n\ndonde shared_dir_path es un directorio que quieres compartir entre huésped y el host.\n\nLuego, en el invitado, podrá acceder al directorio compartido del host 10.0.2.4 con el nombre de recurso \"qemu\". Por ejemplo, en el Explorador de Windows iría a \\\\ 10.0.2.4 \\ qemu.\n\n- Si estás usando opciones de compartir varias veces como -net user, smb= shared_dir_path1 -net user, smb= shared_dir_path2 ó -net user , Smb = shared_dir_path1 , smb = shared_dir_path2 entonces solo compartirá el último definido.\n- Si no puede acceder a la carpeta compartida y el sistema invitado es Windows, compruebe que está habilitado el protocolo NetBIOS [enlace roto 2023-05-06] Y que un cortafuegos no bloquea los puertos [2] utilizados por el protocolo NetBIOS.\n\n"
    },
    {
      "title": "Montaje de una partición dentro de una imagen de disco raw",
      "level": 3,
      "content": "Cuando la máquina virtual no se está ejecutando, es posible montar las particiones que están dentro de un archivo de imagen de disco sin formato configurándolas como dispositivos de bucle invertido. Esto no funciona con imágenes de disco en formatos especiales, como qcow2, aunque se pueden montar usando qemu-nbd.\n\n"
    },
    {
      "title": "Con la especificación manual del desplazamiento de bytes",
      "level": 4,
      "content": "Una forma de montar una partición de imagen de disco es montar la imagen de disco en un cierto desplazamiento usando un comando como el siguiente:\n\n```\n$ mount -o loop, offset = 32256 disk_image mountpoint\n```\n\nLa opción offset = 32256 se pasa realmente al programa losetup para configurar un dispositivo de bucle invertido que empieza en el desplazamiento de byte 32256 del archivo y continúa hasta el final. A continuación, se monta este dispositivo de bucle invertido. También puede utilizar la opción sizelimit para especificar el tamaño exacto de la partición, pero esto normalmente no es necesario.\n\nDependiendo de la imagen del disco, la partición necesaria no se puede iniciar en el desplazamiento 32256. Ejecute fdisk -l disk_image para ver las particiones de la imagen. Fdisk da las compensaciones de inicio y fin en sectores de 512 bytes, así que multiplique por 512 para obtener el desplazamiento correcto para pasar a mount.\n\n"
    },
    {
      "title": "Con las particiones autodetecting del módulo de bucle (loop)",
      "level": 4,
      "content": "El controlador de bucle de Linux realmente admite particiones en dispositivos de bucle invertido, pero está desactivado de forma predeterminada. Para habilitarlo, haga lo siguiente:\n\n- Deshacerse de todos los dispositivos de bucle invertido (desmontar todas las imágenes montadas, etc.).\n- Descargar el módulo del kernel loop y cargarlo con el conjunto de parámetros max_part = 15. Además, el número máximo de dispositivos de bucle puede controlarse con el parámetro max_loop.\n\nConfigure su imagen como un dispositivo de bucle invertido:\n\n```\n$ losetup -f -P disk_image\n```\n\nEntonces, si el dispositivo creado fue /dev/loop0, se habrán creado automáticamente dispositivos adicionales /dev/loop0pX, donde X es el número de la partición. Estos dispositivos de loopback de partición se pueden montar directamente. Por ejemplo:\n\n```\n$ mount /dev/loop0p1 punto de montaje\n```\n\nPara montar la imagen de disco con udisksctl , vea Udisks#Mount loop devices.\n\n"
    },
    {
      "title": "Con kpartx",
      "level": 4,
      "content": "'Kpartx' del paquete multipath-tools puede leer una tabla de particiones en un dispositivo y crear un nuevo dispositivo para cada partición. Por ejemplo: # Kpartx -a disk_image\n\nEsto configurará el dispositivo de bucle invertido y creará los dispositivos de partición necesarios en /dev/mapper/.\n\n"
    },
    {
      "title": "Montar una partición dentro de una imagen qcow2",
      "level": 3,
      "content": "Puede montar una partición dentro de una imagen qcow2 usando qemu-nbd. Mira Wikibooks.\n\n"
    },
    {
      "title": "Utilizar cualquier partición real como la única partición primaria de una imagen de disco duro",
      "level": 3,
      "content": "A veces, puede que desee utilizar una de las particiones del sistema desde dentro de QEMU. El uso de una partición sin procesar para una máquina virtual mejorará el rendimiento, ya que las operaciones de lectura y escritura no pasan por la capa del sistema de archivos del host físico. Esta partición también proporciona una forma de compartir datos entre el host y el invitado.\n\nEn Arch Linux, los archivos de dispositivo para las particiones sin procesar son, por defecto, propiedad de root y del grupo disk . Si desea que un usuario no root pueda leer y escribir en una partición en bruto, debe cambiar el propietario del archivo de dispositivo de la partición para ese usuario.\n\n- Aunque es posible, no se recomienda permitir que las máquinas virtuales alteren los datos críticos en el sistema host, como la partición raíz.\n- No debe montar un sistema de archivos en una partición de lectura-escritura en el host y el invitado al mismo tiempo. De lo contrario, se producirá corrupción de datos.\n\nDespués de hacerlo, puede adjuntar la partición a una máquina virtual QEMU como un disco virtual.\n\nSin embargo, las cosas son un poco más complicadas si desea tener la máquina virtual completa contenida en una partición. En ese caso, no habría ningún archivo de imagen de disco para arrancar realmente la máquina virtual, ya que no se puede instalar un cargador de arranque en una partición que está formateada como un sistema de archivos y no como un dispositivo particionado con un MBR. Una máquina virtual de este tipo se puede iniciar especificando el kernel y el initramfs manualmente o simulando un disco con un MBR usando RAID lineal.\n\n"
    },
    {
      "title": "Especificar el kernel y el initrd manualmente",
      "level": 4,
      "content": "QEMU es compatible con cargar Linux kernels e init ramdisks directamente, evitando así los cargadores de arranque como GRUB. A continuación, se puede iniciar con la partición física que contiene el sistema de archivos raíz como el disco virtual, que no parecen ser particionados. Esto se hace emitiendo un comando similar al siguiente:\n\nNote: **host** \n\n```\n$ Qemu-system-i386 -kernel /boot/vmlinuz-linux -initrd /boot/initramfs-linux.img -append root=/dev/sda/dev/sda3\n```\n\nEn el ejemplo anterior, la partición física que se utiliza para el sistema de archivos raíz del huésped es /dev/sda3 en el host, pero aparece como /dev/sda en el invitado.\n\nPor supuesto, puede especificar cualquier kernel e initrd que desee, y no sólo los que vienen con Arch Linux.\n\nCuando hay varios kernel parameters que se pasan a la opción -append, necesitan ser citados usando comillas simples o dobles. Por ejemplo:\n\n```\n$ ... -append 'root=/dev/sda1 console=ttyS0'\n```\n\n"
    },
    {
      "title": "Simular disco virtual con MBR usando RAID lineal",
      "level": 4,
      "content": "Una forma más complicada de tener una máquina virtual usar una partición física, mientras que mantener esa partición formateada como un sistema de archivos y no sólo tener la partición invitado la partición como si fuera un disco, es simular un MBR para que pueda Arranque utilizando un gestor de arranque tal como GRUB.\n\nPuede hacerlo utilizando el RAID del software en modo lineal (necesita el controlador de kernel linear.ko) y un dispositivo de loopback: el truco consiste en añadir previamente un registro maestro de arranque (MBR) Real que desea incrustar en una imagen de disco RAEM QEMU.\n\nSuponga que tiene una partición simple / con algún sistema de archivos en la que desea formar parte de una imagen de disco QEMU. En primer lugar, crear un pequeño archivo para mantener el MBR:\n\n```\n$ dd if=/dev/zero of=/path/to/mbr count=32\n```\n\nAquí, se crea un archivo de 16 KB (32 * 512 bytes). Es importante no hacerlo demasiado pequeño (incluso si el MBR sólo necesita un bloque de 512 bytes), ya que cuanto menor sea, menor será el tamaño del chasis del dispositivo RAID de software, lo que podría tener un impacto En el rendimiento. A continuación, configura un dispositivo de bucle invertido en el archivo MBR:\n\n```\n# losetup -f /path/to/mbr\n```\n\nSupongamos que el dispositivo resultante es /dev/loop0, porque ya no habríamos estado usando otros bucle. El siguiente paso es crear la imagen de disco \"fusionada\" MBR + /dev/hdaN utilizando RAID de software:\n\n```\n# modprobe lineal\n```\n\n```\n# mdadm --build --verbose /dev/md0 --chunk=16 --level=linear --raid-devices=2 /dev/loop0/dev/hdaN\n```\n\nEl resultante /dev/md0 es lo que utilizará como una imagen de disco cruda QEMU (no olvide establecer los permisos para que el emulador pueda acceder a él). El último paso (y algo complicado) es configurar la configuración del disco (geometría del disco y tabla de particiones) para que el punto de inicio de la partición primaria en el MBR coincida con el de /dev/hdaN} Dentro /dev/md0 (un desplazamiento de exactamente 16 * 512 = 16384 bytes en este ejemplo). Hacer esto usando fdisk en la máquina host, no en el emulador: la rutina de detección de disco crudo predeterminada de QEMU a menudo da lugar a offsets redondeados no kilobyte (como 31.5 KB, como en la sección anterior) que No puede ser administrado por el código RAID de software. Por lo tanto, desde el anfitrión:\n\n```\n$ fdisk /dev/md0\n```\n\nPulse X para entrar en el menú de expertos. Establezca el número de sectores por pista para que el tamaño de un cilindro coincida con el tamaño de su archivo MBR. Para dos cabezas y un tamaño de sector de 512, el número de sectores por pista debe ser 16, por lo que obtenemos cilindros de tamaño 2x16x512 = 16k.\n\nAhora, presione R para regresar al menú principal.\n\nPresione P y compruebe que el tamaño del cilindro es ahora 16k.\n\nAhora, cree una única partición primaria correspondiente a /dev/hdaN. Debe comenzar en el cilindro 2 y terminar en el extremo del disco (tenga en cuenta que el número de cilindros ahora difiere de lo que era cuando se introdujo fdisk.\n\nFinalmente, escribe el resultado al archivo: ya está. Ahora tiene una partición que puede montar directamente desde su host, así como parte de una imagen de disco QEMU:\n\n```\n$ Qemu-system-i386 -hdc /dev/md0 [...]\n```\n\nPor supuesto, puede configurar con seguridad cualquier cargador de arranque en esta imagen de disco utilizando QEMU, siempre que la partición original /dev/hdaN contenga las herramientas necesarias.\n\n"
    },
    {
      "title": "Redes",
      "level": 2,
      "content": "El rendimiento de la red virtual debería ser mejor con los dispositivos de derivación (tap) y puentes que con la red en modo de usuario o vde porque los dispositivos de derivación y los puentes se implementan en el kernel.\n\nAdemás, el rendimiento de la red se puede mejorar asignando a las máquinas virtuales un dispositivo de red virtio en lugar de la emulación predeterminada de una NIC e1000. Consulte #Instalación de controladores virtio para obtener más información.\n\n"
    },
    {
      "title": "Advertencia de dirección a nivel de enlace",
      "level": 3,
      "content": "Al asignar el argumento -net nic a QEMU, asignará por defecto a una máquina virtual una interfaz de red con la dirección de enlace 52:54:00:12:34:56. Sin embargo, cuando se utiliza la creación de redes puenteadas con varias máquinas virtuales, es esencial que cada máquina virtual tenga una dirección única de nivel de enlace (MAC) en el lado de la máquina virtual del dispositivo de derivación. De lo contrario, el puente no funcionará correctamente, ya que recibirá paquetes de varias fuentes que tienen la misma dirección de nivel de enlace. Este problema se produce incluso si los propios dispositivos de derivación tienen direcciones de nivel de enlace únicas porque la dirección de nivel de enlace de origen no se vuelve a escribir a medida que los paquetes pasan a través del dispositivo de derivación.\n\nAsegúrese de que cada máquina virtual tiene una dirección única de nivel de enlace, pero siempre debe comenzar con 52:54:. Utilice la opción siguiente, reemplazar X por un dígito hexadecimal arbitrario:\n\n```\n$ qemu-system-i386 -net nic,macaddr=52:54:XX:XX:XX:XX -net vde disk_image\n```\n\nGenerar direcciones únicas de nivel de enlace se puede realizar de varias maneras:\n\n1. Especificar manualmente la dirección única de nivel de enlace para cada NIC. El beneficio es que el servidor DHCP asignará la misma dirección IP cada vez que se ejecute la máquina virtual, pero es inutilizable para un gran número de máquinas virtuales.\n1. Generar dirección de nivel de enlace aleatoria cada vez que se ejecuta la máquina virtual. Prácticamente cero probabilidad de colisiones, pero la desventaja es que el servidor DHCP asignará una dirección IP diferente cada vez. Puede utilizar el siguiente comando en una secuencia de comandos para generar una dirección de nivel de enlace aleatoria en una variable macaddr: printf -v macaddr \"52:54:%02x:%02x:%02x:%02x\" $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff )) qemu-system-i386 -net nic,macaddr=\"$macaddr\" -net vde disk_image\n1. Utilice el siguiente script qemu-mac-hasher.py para generar la dirección de nivel de enlace desde el nombre de la máquina virtual mediante una función de hash. Dado que los nombres de las máquinas virtuales son únicos, este método combina los beneficios de los métodos antes mencionados: genera la misma dirección de nivel de enlace cada vez que se ejecuta el script, aunque preserva la probabilidad prácticamente nula de colisiones. qemu-mac-hasher.py #!/usr/bin/env python import sys import zlib if len(sys.argv) != 2: print(\"usage: %s <VM Name>\" % sys.argv[0]) sys.exit(1) crc = zlib.crc32(sys.argv[1].encode(\"utf-8\")) & 0xffffffff crc = str(hex(crc))[2:] print(\"52:54:%s%s:%s%s:%s%s:%s%s\" % tuple(crc)) En un script, puede utilizar por ejemplo: vm_name=\"VM Name\" qemu-system-i386 -name \"$vm_name\" -net nic,macaddr=$(qemu-mac-hasher.py \"$vm_name\") -net vde disk_image\n\n```\nprintf -v macaddr \"52:54:%02x:%02x:%02x:%02x\" $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff ))\nqemu-system-i386 -net nic,macaddr=\"$macaddr\" -net vde disk_image\n```\n\n```\nqemu-mac-hasher.py\n```\n\n```\n#!/usr/bin/env python\n\nimport sys\nimport zlib\n\nif len(sys.argv) != 2:\n    print(\"usage: %s <VM Name>\" % sys.argv[0])\n    sys.exit(1)\n\ncrc = zlib.crc32(sys.argv[1].encode(\"utf-8\")) & 0xffffffff\ncrc = str(hex(crc))[2:]\nprint(\"52:54:%s%s:%s%s:%s%s:%s%s\" % tuple(crc))\n```\n\nEn un script, puede utilizar por ejemplo:\n\n```\nvm_name=\"VM Name\"\nqemu-system-i386 -name \"$vm_name\" -net nic,macaddr=$(qemu-mac-hasher.py \"$vm_name\") -net vde disk_image\n```\n\n"
    },
    {
      "title": "Redes en modo de usuario",
      "level": 3,
      "content": "De forma predeterminada, sin ningún argumento -netdev, QEMU utilizará la red en modo usuario con un servidor DHCP incorporado. A sus máquinas virtuales se les asignará una dirección IP cuando ejecuten su cliente DHCP, y podrán acceder a la red del host físico a través de la mascarada de IP realizada por QEMU.\n\nEsta configuración predeterminada permite que sus máquinas virtuales accedan fácilmente a Internet, siempre que el host esté conectado a él, pero las máquinas virtuales no estarán directamente visibles en la red externa ni las máquinas virtuales podrán comunicarse entre sí si empieza Más de uno simultáneamente.\n\nLa red de usuario en modo QEMU puede ofrecer más capacidades, como servidores TFTP o SMB incorporados, redirigir los puertos del host al huésped (por ejemplo, para permitir conexiones SSH al invitado) o conectar invitados a las VLAN para que puedan hablar entre sí. Consulte la documentación de QEMU en el indicador -net user para obtener más detalles.\n\nSin embargo, la conexión en red en modo usuario tiene limitaciones tanto en la utilidad como en el rendimiento. Las configuraciones de red más avanzadas requieren el uso de dispositivos de derivación u otros métodos.\n\n"
    },
    {
      "title": "Tap de red con QEMU",
      "level": 3,
      "content": "Los dispositivos tap Son una característica del kernel de Linux que le permite crear interfaces de red virtuales que aparecen como interfaces de red reales. Los paquetes enviados a una interfaz de derivación se entregan a un programa de espacio de usuario, tal como QEMU, que se ha enlazado a la interfaz.\n\nQEMU puede utilizar la red de derivación para una máquina virtual de modo que los paquetes enviados a la interfaz de derivación se envíen a la máquina virtual y aparezcan como procedentes de una interfaz de red (normalmente una interfaz Ethernet) en la máquina virtual. Por el contrario, todo lo que la máquina virtual envía a través de su interfaz de red aparecerá en la interfaz de tap.\n\nLos dispositivos de toque son soportados por los controladores de puente de Linux, por lo que es posible conectar entre sí los dispositivos entre sí y posiblemente con otras interfaces de host como eth0. Esto es deseable si desea que sus máquinas virtuales puedan hablar entre sí, o si desea que otras máquinas en su LAN puedan hablar con las máquinas virtuales.\n\nComo se indica en la sección de conexión en red de modo de usuario, los dispositivos de derivación ofrecen un rendimiento de red más alto que el modo de usuario. Si el OS invitado admite el controlador de red virtio, el rendimiento de la red se incrementará considerablemente también. Suponiendo el uso del dispositivo tap0, que el controlador virtio se utiliza en el invitado, y que no se utilizan scripts para ayudar a iniciar / detener la creación de redes, a continuación es parte del comando qemu se debe ver:\n\n```\n-net nic, model=virtio -net tap, ifname=tap0, script=no, downscript=no\n```\n\nPero si ya está utilizando un dispositivo de tap con virtio controlador de red, uno puede incluso aumentar el rendimiento de la red mediante la activación de vhost, como:\n\n```\n-net nic, model=virtio -net tap, ifname=tap0, script=no, downscript=no, vhost=on\n```\n\nVer http://www.linux-kvm.com/content/how-maximize-virtio-net-performance-vhost-net para obtener más información.\n\n"
    },
    {
      "title": "Red de host solamente",
      "level": 4,
      "content": "Si al puente se le da una dirección IP y se permite el tráfico destinado a ello, pero no hay una interfaz real (por ejemplo, eth0) conectada al puente, las máquinas virtuales podrán hablar entre sí y la Sistema anfitrión. Sin embargo, no podrán hablar con nada en la red externa, siempre y cuando no configure IP enmascarada en el host físico. Esta configuración se llama red de host solamente por otro software de virtualización como VirtualBox.\n\n- Si desea configurar IP masquerading, ej. NAT para máquinas virtuales, consulte la página Internet sharing#Enable NAT.\n- Es posible que desee tener un servidor DHCP que se ejecute en la interfaz de puente para dar servicio a la red virtual. Por ejemplo, para usar la subred 172.20.0.1/16 con dnsmasq como servidor DHCP:\n\n```\n# ip addr add 172.20.0.1/16 dev br0\n# ip link set br0 up\n# dnsmasq --interface=br0 --bind-interfaces --dhcp-range=172.20.0.2,172.20.255.254\n```\n\n"
    },
    {
      "title": "Red interna",
      "level": 4,
      "content": "Si no le da al puente una dirección IP y agrega una regla iptables para eliminar todo el tráfico al puente en la cadena INPUT, las máquinas virtuales podrán hablar entre sí, pero no con el host físico ó la red exterior. Esta configuración se llama \"red interna\" por otro software de virtualización como VirtualBox. Deberá asignar direcciones IP estáticas a las máquinas virtuales o ejecutar un servidor DHCP en una de ellas.\n\nDe forma predeterminada, iptables eliminaría los paquetes de la red de bridge. Es posible que necesite utilizar dicha regla iptables para permitir paquetes en una red puenteada:\n\n```\n# iptables -I FORWARD -m physdev --physdev-is-bridged -j ACCEPT\n```\n\n"
    },
    {
      "title": "Redes puenteadas usando qemu-bridge-helper",
      "level": 4,
      "content": "Este método no requiere una secuencia de comandos de inicio y acepta fácilmente múltiples tomas y puentes múltiples. Utiliza el binario /usr/lib/qemu/qemu-bridge-helper, que permite crear dispositivos de derivación en un puente existente.\n\nEn primer lugar, cree un archivo de configuración que contenga los nombres de todos los puentes que QEMU utilizará:\n\n```\n/etc/qemu/bridge.conf\n```\n\n```\nallow bridge0\nallow bridge1\n...\n```\n\nAhora inicie la VM. El uso más básico sería:\n\n```\n$ qemu-system-i386 -net nic -net bridge,br=bridge0 [...]\n```\n\nCon múltiples taps, el uso más básico requiere especificar la VLAN para todos los NIC adicionales:\n\n```\n$ qemu-system-i386 -net nic -net bridge,br=bridge0 -net nic,vlan=1 -net bridge,vlan=1,br=bridge1 [...]\n```\n\n"
    },
    {
      "title": "Creación manual del puente",
      "level": 4,
      "content": "A continuación se describe cómo conectar una máquina virtual con una interfaz de host como eth0, que es probablemente la configuración más común. Esta configuración hace que parezca que la máquina virtual está ubicada directamente en la red externa, en el mismo segmento Ethernet que la máquina host física.\n\nVamos a reemplazar el adaptador Ethernet normal con un adaptador de puente y enlazar el adaptador Ethernet normal a él.\n\n- Instale bridge-utils, que proporciona brctl para manipular puentes.\n\n- Habilitar el reenvío IPv4:\n\n```\n# sysctl net.ipv4.ip_forward=1\n```\n\nPara hacer el cambio permanente, cambie net.ipv4.ip_forward = 0 a net.ipv4.ip_forward = 1 en /etc/sysctl.d/99-sysctl.conf.\n\n- Cargue el módulo tun y configurelo para cargarlo en el arranque. Véase Kernel modules (Español) para más detalles.\n\n- Ahora cree el puente. Ver Bridge with netctl para más detalles. Recuerde nombrar su puente como br0, o modifique lo scripts a continuación del nombre del puente.\n\n- Cree el script que QEMU utiliza para abrir el adaptador de toma con los permisos root:kvm 750:\n\n```\n/etc/qemu-ifup\n```\n\n```\n#!/bin/sh\n\necho \"Executing /etc/qemu-ifup\"\necho \"Bringing up $1 for bridged mode...\"\nsudo /usr/bin/ip link set $1 up promisc on\necho \"Adding $1 to br0...\"\nsudo /usr/bin/brctl addif br0 $1\nsleep 2\n```\n\n- Cree el guión que QEMU utiliza para derribar el adaptador de toma en /etc/qemu-ifdown con los permisos root:kvm 750:\n\n```\n/etc/qemu-ifdown\n```\n\n```\n#!/bin/sh\n\necho \"Executing /etc/qemu-ifdown\"\nsudo /usr/bin/ip link set $1 down\nsudo /usr/bin/brctl delif br0 $1\nsudo /usr/bin/ip link delete dev $1\n```\n\n- Use visudo para añadir lo siguiente a el archivo sudoers:\n\n```\nCmnd_Alias      QEMU=/usr/bin/ip,/usr/bin/modprobe,/usr/bin/brctl\n%kvm     ALL=NOPASSWD: QEMU\n```\n\n- Se inicia QEMU con el siguiente script run-qemu:\n\n```\nrun-qemu\n```\n\n```\n#!/bin/bash\nUSERID=$(whoami)\n\n# Get name of newly created TAP device; see https://bbs.archlinux.org/viewtopic.php?pid=1285079#p1285079\nprecreationg=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)\nsudo /usr/bin/ip tuntap add user $USERID mode tap\npostcreation=$(/usr/bin/ip tuntap list | /usr/bin/cut -d: -f1 | /usr/bin/sort)\nIFACE=$(comm -13 <(echo \"$precreationg\") <(echo \"$postcreation\"))\n\n# This line creates a random MAC address. The downside is the DHCP server will assign a different IP address each time\nprintf -v macaddr \"52:54:%02x:%02x:%02x:%02x\" $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff )) $(( $RANDOM & 0xff)) $(( $RANDOM & 0xff ))\n# Instead, uncomment and edit this line to set a static MAC address. The benefit is that the DHCP server will assign the same IP address.\n# macaddr='52:54:be:36:42:a9'\n\nqemu-system-i386 -net nic,macaddr=$macaddr -net tap,ifname=\"$IFACE\" $*\n\nsudo ip link set dev $IFACE down &> /dev/null\nsudo ip tuntap del $IFACE mode tap &> /dev/null\n```\n\nPara ejecutar una VM, haz algo como esto:\n\n```\n$ run-qemu -hda myvm.img -m 512 -vga std\n```\n\n- Se recomienda, por motivos de rendimiento y seguridad, deshabilitar el firewall en el puente:\n\n```\n/etc/sysctl.d/10-disable-firewall-on-bridge.conf\n```\n\n```\nnet.bridge.bridge-nf-call-ip6tables = 0\nnet.bridge.bridge-nf-call-iptables = 0\nnet.bridge.bridge-nf-call-arptables = 0\n```\n\nEjecute sysctl -p /etc/sysctl.d/10-disable-firewall-on-bridge.conf para aplicar los cambios inmediatamente.\n\nVer libvirt wiki y Fedora bug 512206. Si obtiene errores de sysctl durante el inicio de archivos no existentes, haga que el módulo bridge se cargue al arrancar. Véase Kernel module (Español)#systemd.\n\nComo alternativa, puede configurar iptables para permitir que todo el tráfico se reenvíe a través del puente mediante la adición de una regla como esta:\n\n```\n-I FORWARD -m physdev --physdev-is-bridged -j ACCEPT\n```\n\n"
    },
    {
      "title": "Compartición de red entre dispositivo físico y un dispositivo de toque a través de iptables",
      "level": 4,
      "content": "La conexión en puente funciona bien entre una interfaz cableada (por ejemplo, eth0), y es fácil de configurar. Sin embargo, si el host se conecta a la red a través de un dispositivo inalámbrico, el puente no es posible.\n\nConsulte Network bridge#Wireless interface on a bridge como referencia.\n\nUna forma de superar esto es configurar un dispositivo de derivación con una IP estática, haciendo que linux maneje automáticamente el enrutamiento para ella y, a continuación, reenvíe el tráfico entre la interfaz de derivación y el dispositivo conectado a la red a través de las reglas de iptables.\n\nConsulte Internet sharing como referencia.\n\nAllí puede encontrar lo que se necesita para compartir la red entre dispositivos, incluidos los de tap y tun. Lo siguiente sólo indica algunas de las configuraciones de host requeridas. Como se indica en la referencia anterior, el cliente debe configurarse para una IP estática, utilizando la IP asignada a la interfaz de derivación como puerta de enlace. La advertencia es que los servidores DNS del cliente pueden necesitar ser editados manualmente si cambian al cambiar de un dispositivo host conectado a la red a otro.\n\nPara permitir el reenvío de IP en cada inicio, es necesario agregar las siguientes líneas al archivo de configuración de sysctl dentro de /etc/sysctl.d:\n\n```\nnet.ipv4.ip_forward = 1\nnet.ipv6.conf.default.forwarding = 1\nnet.ipv6.conf.all.forwarding = 1\n```\n\nLas reglas de iptables pueden verse así:\n\n```\n# Forwarding from/to outside\niptables -A FORWARD -i ${INT} -o ${EXT_0} -j ACCEPT\niptables -A FORWARD -i ${INT} -o ${EXT_1} -j ACCEPT\niptables -A FORWARD -i ${INT} -o ${EXT_2} -j ACCEPT\niptables -A FORWARD -i ${EXT_0} -o ${INT} -j ACCEPT\niptables -A FORWARD -i ${EXT_1} -o ${INT} -j ACCEPT\niptables -A FORWARD -i ${EXT_2} -o ${INT} -j ACCEPT\n# NAT/Masquerade (network address translation)\niptables -t nat -A POSTROUTING -o ${EXT_0} -j MASQUERADE\niptables -t nat -A POSTROUTING -o ${EXT_1} -j MASQUERADE\niptables -t nat -A POSTROUTING -o ${EXT_2} -j MASQUERADE\n```\n\nEl anterior supone que hay 3 dispositivos conectados a la red compartiendo tráfico con un dispositivo interno, donde por ejemplo:\n\n```\nINT=tap0\nEXT_0=eth0\nEXT_1=wlan0\nEXT_2=tun0\n```\n\nEl anterior muestra un reenvío que permitiría compartir conexiones cableadas e inalámbricas con el dispositivo de derivación (tap).\n\nLas reglas de reenvío que se muestran son apátridas y para el reenvío puro. Se podría pensar en restringir el tráfico específico, poniendo un cortafuegos en el lugar para proteger al huésped y otros. Sin embargo, esto reduciría el rendimiento de la red, mientras que un simple puente no incluye nada de eso.\n\nBonus: Si la conexión es cableada o inalámbrica, si se conecta a través de VPN a un sitio remoto con un dispositivo tun, suponiendo que el dispositivo tun abierto para esa conexión es tun0, y las reglas iptables anteriores se aplican, entonces la conexión remota se obtiene también Compartido con el huésped. Esto evita la necesidad de que el invitado también abra una conexión VPN. Una vez más, como la red de invitados debe ser estática, entonces si la conexión del host de forma remota de esta manera, uno probablemente tendrá que editar los servidores DNS en el invitado.\n\n"
    },
    {
      "title": "¿Qué es VDE?",
      "level": 4,
      "content": "VDE significa Virtual Distributed Ethernet. Comenzó como una mejora del interruptor uml _. Es una caja de herramientas para administrar redes virtuales.\n\nLa idea es crear interruptores virtuales, que son básicamente sockets, y \"conectar\" tanto máquinas físicas como máquinas virtuales en ellas. La configuración que mostramos aquí es bastante simple; Sin embargo, VDE es mucho más potente que esto, puede conectar conmutadores virtuales juntos, ejecutarlos en diferentes hosts y supervisar el tráfico en los switches. Usted está invitado a leer la documentación del proyecto.\n\nLa ventaja de este método es que no tienes que agregar privilegios de sudo a tus usuarios. No se debe permitir que los usuarios regulares ejecuten modprobe.\n\n"
    },
    {
      "title": "Basics",
      "level": 4,
      "content": "El soporte de VDE puede ser instalado a través del paquete vde2 en los repositorios oficiales.\n\nEn nuestra configuración, usamos tun/tap para crear una interfaz virtual en el host. Cargue el módulo tun (véase kernel modules (Español) para obtener más detalles):\n\n```\n# modprobe tun\n```\n\nAhora crea el conmutador virtual:\n\n```\n# vde_switch -tap tap0 -daemon -mod 660 -group users\n```\n\nEsta línea crea el switch, crea tap0, lo \"enchufa\" y permite a los usuarios del grupo users usarlo.\n\nLa interfaz está conectada pero no está configurada todavía. Para configurarlo, ejecute este comando:\n\n```\n# ip addr add 192.168.100.254/24 dev tap0\n```\n\nAhora, sólo tiene que ejecutar KVM con estas opciones -net como usuario normal:\n\n```\n$ qemu-system-i386 -net nic -net vde -hda [...]\n```\n\nConfigure la red para su invitado como lo haría en una red física.\n\n"
    },
    {
      "title": "Startup scripts",
      "level": 4,
      "content": "Ejemplo de script principal que inicia VDE:\n\n```\n/etc/systemd/scripts/qemu-network-env\n```\n\n```\n#!/bin/sh\n# Preparación del entorno de red QEMU/VDE\n\n# La configuración IP del dispositivo de derivación que se utilizará para\n# La red de la máquina virtual:\n\nTAP_DEV=tap0\nTAP_IP=192.168.100.254\nTAP_MASK=24\nTAP_NETWORK=192.168.100.0\n\n# Host interface\nNIC=eth0\n\ncase \"$1\" in\n  start)\n        echo -n \"Starting VDE network for QEMU: \"\n\n        # If you want tun kernel module to be loaded by script uncomment here\n\t#modprobe tun 2>/dev/null\n\t## Wait for the module to be loaded\n \t#while ! lsmod | grep -q \"^tun\"; do echo \"Waiting for tun device\"; sleep 1; done\n\n        # Start tap switch\n        vde_switch -tap \"$TAP_DEV\" -daemon -mod 660 -group users\n\n        # Bring tap interface up\n        ip address add \"$TAP_IP\"/\"$TAP_MASK\" dev \"$TAP_DEV\"\n        ip link set \"$TAP_DEV\" up\n\n        # Start IP Forwarding\n        echo \"1\" > /proc/sys/net/ipv4/ip_forward\n        iptables -t nat -A POSTROUTING -s \"$TAP_NETWORK\"/\"$TAP_MASK\" -o \"$NIC\" -j MASQUERADE\n        ;;\n  stop)\n        echo -n \"Stopping VDE network for QEMU: \"\n        # Delete the NAT rules\n        iptables -t nat -D POSTROUTING \"$TAP_NETWORK\"/\"$TAP_MASK\" -o \"$NIC\" -j MASQUERADE\n\n        # Bring tap interface down\n        ip link set \"$TAP_DEV\" down\n\n        # Kill VDE switch\n        pgrep -f vde_switch | xargs kill -TERM\n        ;;\n  restart|reload)\n        $0 stop\n        sleep 1\n        $0 start\n        ;;\n  *)\n        echo \"Usage: $0 {start|stop|restart|reload}\"\n        exit 1\nesac\nexit 0\n```\n\nEjemplo de servicio systemd utilizando el script anterior:\n\n```\n/etc/systemd/system/qemu-network-env.service\n```\n\n```\n[Unit]\nDescription=Manage VDE Switch\n\n[Service]\nType=oneshot\nExecStart=/etc/systemd/scripts/qemu-network-env start\nExecStop=/etc/systemd/scripts/qemu-network-env stop\nRemainAfterExit=yes\n\n[Install]\nWantedBy=multi-user.target\n```\n\nCambiar permisos de qemu-network-env para ser ejecutable\n\n```\n# chmod u+x /etc/systemd/scripts/qemu-network-env\n```\n\nPuede iniciar qemu-network-env.service como de costumbre.\n\n"
    },
    {
      "title": "Método alternativo",
      "level": 4,
      "content": "Si el método anterior no funciona o no quiere meterse con las configuraciones del kernel, TUN, dnsmasq e iptables, puede hacer lo siguiente para obtener el mismo resultado.\n\n```\n# vde_switch -daemon -mod 660 -group users\n# slirpvde --dhcp --daemon\n```\n\nA continuación, para iniciar la VM con una conexión a la red del host:\n\n```\n$ qemu-system-i386 -net nic,macaddr=52:54:00:00:EE:03 -net vde disk_image\n```\n\n"
    },
    {
      "title": "Puente VDE2",
      "level": 3,
      "content": "Basado en quickhowto: qemu networking using vde, tun/tap, and bridge gráfico. Cualquier máquina virtual conectada a vde está expuesta externamente. Por ejemplo, cada máquina virtual puede recibir la configuración DHCP directamente desde su enrutador ADSL.\n\n"
    },
    {
      "title": "Conceptos básicos",
      "level": 4,
      "content": "Recuerde que necesita el módulo tun y el paquete bridge-utils.\n\nCree el dispositivo vde2/tap:\n\n```\n# vde_switch -tap tap0 -daemon -mod 660 -group users\n# ip link set tap0 up\n```\n\nCree el puente:\n\n```\n# brctl addbr br0\n```\n\nAgregue dispositivos:\n\n```\n# brctl addif br0 eth0\n# brctl addif br0 tap0\n```\n\nY configure la interfaz del puente:\n\n```\n# dhcpcd br0\n```\n\n"
    },
    {
      "title": "Startup scripts",
      "level": 4,
      "content": "Todos los dispositivos deben estar configurados. Y sólo el puente necesita una dirección IP. Para dispositivos físicos en el puente (por ejemplo, eth0), esto puede hacerse con netctl utilizando un perfil Ethernet personalizado con:\n\n```\n/etc/netctl/ethernet-noip\n```\n\n```\nDescription='A more versatile static Ethernet connection'\nInterface=eth0\nConnection=ethernet\nIP=no\n```\n\nEl siguiente servicio systemd personalizado puede utilizarse para crear y activar una interfaz de toma VDE2 para su uso en el grupo de usuarios users.\n\n```\n/etc/systemd/system/vde2@.service\n```\n\n```\n[Unit]\nDescription=Network Connectivity for %i\nWants=network.target\nBefore=network.target\n\n[Service]\nType=oneshot\nRemainAfterExit=yes\nExecStart=/usr/bin/vde_switch -tap %i -daemon -mod 660 -group users\nExecStart=/usr/bin/ip link set dev %i up\nExecStop=/usr/bin/ip addr flush dev %i\nExecStop=/usr/bin/ip link set dev %i down\n\n[Install]\nWantedBy=multi-user.target\n```\n\nY, por último, puede crear el puente interfaz con netctl.\n\n"
    },
    {
      "title": "Gráficos",
      "level": 2,
      "content": "QEMU puede utilizar las siguientes salidas gráficas diferentes: std, qxl, vmware, virtio, cirrus y none.\n\n"
    },
    {
      "title": "std",
      "level": 3,
      "content": "Con -vga std puede obtener una resolución de hasta 2560 x 1600 píxeles sin necesidad de controladores invitados. Este es el valor predeterminado desde QEMU 2.2.\n\n"
    },
    {
      "title": "qxl",
      "level": 3,
      "content": "QXL Es un controlador de gráficos paravirtual con soporte 2D. Para usarlo, pase la opción -vga qxl e instale los controladores en el invitado. Es posible que desee utilizar SPICE para mejorar el rendimiento gráfico al utilizar QXL.\n\nEn los invitados de Linux, los módulos del kernel qxl y bochs_drm deben ser inicializados para poder tener un rendimiento decente.\n\n"
    },
    {
      "title": "SPICE",
      "level": 4,
      "content": "El proyecto SPICE tiene como objetivo proporcionar una solución completa de código abierto para el acceso remoto a máquinas virtuales de una manera transparente.\n\nSPICE sólo se puede utilizar cuando se utiliza QXL como la salida gráfica.\n\nEl siguiente es un ejemplo de arranque con SPICE como protocolo de escritorio remoto:\n\n```\n$ qemu-system-i386 -vga qxl -spice port=5930,disable-ticketing -chardev spicevm\n```\n\nConéctese al invitado utilizando un cliente SPICE. En este momento se recomienda spice-gtk, sin embargo otros clientes, incluyendo otras plataformas, están disponibles:\n\n```\n$ spicy -h 127.0.0.1 -p 5930\n```\n\nEl uso de Unix sockets en lugar de los puertos TCP no implica el uso de pila de red en el sistema host, por lo que es Sockets-vs-tcp-ports según se informa mejor para el rendimiento. Ejemplo:\n\n```\n$ qemu-system-x86_64 -vga qxl -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent -spice unix,addr=/tmp/vm_spice.socket,disable-ticketing\n$ spicy --uri=\"spice+unix:///tmp/vm_spice.socket\"\n```\n\nPara una mejor compatibilidad con varios monitores, compartir el portapapeles, etc., los paquetes siguientes deben estar instalados en el invitado:\n\n- spice-vdagent: Spice agent xorg cliente que permite copiar y pegar entre el cliente y X-session y más\n- xf86-video-qxl xf86-video-qxl-gitAUR: Xorg X11 qxl controlador de vídeo\n- Para otros sistemas operativos, mire la sección Guest de la página SPICE-Space download.\n\n"
    },
    {
      "title": "vmware",
      "level": 3,
      "content": "Aunque tiene pocos errores, tiene mejor rendimiento que std y cirrus. Instale los controladores de VMware xf86-video-vmware y xf86-input-vmmouse para los invitados de Arch Linux.\n\n"
    },
    {
      "title": "virtio",
      "level": 3,
      "content": "virtio-vga / virtio-gpu Es un controlador de gráficos 3D paravirtual basado en virgl. Actualmente un trabajo en curso, que sólo admite a invitados Linux (>= 4.4) con mesa (>= 11.2) compilados con la opción --with-gallium-drivers=virgl.\n\nPara activar la aceleración 3D en el sistema invitado, seleccione vga con -vga virtio y habilitar el contexto opengl en el dispositivo de visualización con -display sdl,gl=on ó -display gtk,gl=on Para la salida de pantalla sdl y gtk respectivamente. La configuración correcta se puede confirmar mirando el registro del kernel en el invitado:\n\n```\n# dmesg | grep drm\n```\n\n```\n[drm] pci: virtio-vga detected\n[drm] virgl 3d acceleration enabled\n```\n\nA partir de septiembre de 2016, el soporte para el protocolo de especias está en desarrollo y se puede probar la instalación de la versión de desarrollo de spice (>= 0.13.2) y la recompilación de qemu.\n\nPara más información visite blog de kraxel.\n\n"
    },
    {
      "title": "cirrus",
      "level": 3,
      "content": "El adaptador gráfico cirrus fue el predeterminado before 2.2. no debería utilizarse en sistemas modernos.\n\n"
    },
    {
      "title": "none",
      "level": 3,
      "content": "Esto es como un PC que no tiene tarjeta VGA en absoluto. Ni siquiera podrías acceder a ella con la opción -vnc. Además, esto es diferente de la opción -nographic que permite a QEMU emular una tarjeta VGA, pero deshabilita la visualización SDL.\n\n"
    },
    {
      "title": "vnc",
      "level": 3,
      "content": "Dado que usó la opción -nographic, puede agregar la opción -vnc display para que QEMU escuche en display y redirigir la pantalla VGA a la sesión VNC . Hay un ejemplo de esto en las configuraciones de ejemplo de la sección #Inicio de las máquinas virtuales QEMU en el arranque.\n\n```\n$ qemu-system-i386 -vga std -nographic -vnc :0\n$ gvncviewer :0\n```\n\nAl usar VNC, puede experimentar problemas de teclado descritos (en detalles gory) aquí. La solución es \"no\" usar la opción -k en QEMU y usar gvncviewer de gtk-vnc. Ver también este mensaje publicado en la lista de correo de libvirt.\n\n"
    },
    {
      "title": "Host",
      "level": 3,
      "content": "El controlador de audio utilizado por QEMU se establece con la variable de entorno QEMU_AUDIO_DRV:\n\n```\n$ export QEMU_AUDIO_DRV=pa\n```\n\nEjecute el siguiente comando para obtener las opciones de configuración de QEMU relacionadas con PulseAudio:\n\n```\n$ qemu-system-x86_64 -audio-help | awk '/Name: pa/' RS=\n```\n\nLas opciones listadas se pueden exportar como variables de entorno, por ejemplo:\n\n```\n$ export QEMU_PA_SINK=alsa_output.pci-0000_04_01.0.analog-stereo.monitor\n$ export QEMU_PA_SOURCE=input\n```\n\n"
    },
    {
      "title": "Invitado",
      "level": 3,
      "content": "Para obtener la lista de los controladores de audio de emulación compatibles:\n\n```\n$ qemu-system-x86_64 -soundhw help\n```\n\nPara usar (ej. hda) para el invitado utilice el comando -soundhw hda con QEMU.\n\n"
    },
    {
      "title": "VirtIO sound",
      "level": 3,
      "content": "VirtIO sound está disponible desde la versión 8.2.0 de QEMU. El uso es:\n\n```\n-device virtio-sound-pci,audiodev=my_audiodev -audiodev alsa,id=my_audiodev\n```\n\nPara más información, consulte la documentación de QEMU.\n\n"
    },
    {
      "title": "Instalación de controladores virtio",
      "level": 2,
      "content": "QEMU ofrece a los clientes la posibilidad de utilizar dispositivos bloqueados y de red paravirtualizados utilizando los controladores virtio, que proporcionan un mejor rendimiento y menores gastos generales.\n\nUn dispositivo virtio bloque requiere la opción -drive en lugar del simple -hd * más if=virtio:\n\n```\n$ qemu-system-i386 -boot order=c -drive file=disk_image,if=virtio\n```\n\n- Casi de la misma manera para la red:\n\n```\n$ qemu-system-i386 -net nic,model=virtio\n```\n\n"
    },
    {
      "title": "Preparando a Arch Linux como invitado",
      "level": 3,
      "content": "Para utilizar los dispositivos virtio después de instalar un invitado de Arch Linux, se deben cargar en el invitado los siguientes módulos: virtio, virtio_pci, virtio_blk, Virtio_net, y virtio_ring. Para los huéspedes de 32 bits, no es necesario el módulo \"virtio\" específico.\n\nSi desea arrancar desde un disco virtio, el disco ramd inicial debe contener los módulos necesarios. De forma predeterminada, esto es manejado por el gancho autodetect de mkinitcpio. De lo contrario, utilice la matriz MODULES en /etc/mkinitcpio.conf para incluir los módulos necesarios y reconstruir el disco ramd inicial.\n\n```\n/etc/mkinitcpio.conf\n```\n\n```\nMODULES=\"virtio virtio_blk virtio_pci virtio_net\"\n```\n\nLos discos Virtio se reconocen con el prefijo v (ej. v da, v db, etc.); Por lo tanto, los cambios deben realizarse al menos en /etc/fstab y /boot/grub/grub.cfg al arrancar desde un disco virtio.\n\nSe puede encontrar más información sobre la paravirtualización con KVM aquí.\n\nTambién puede instalar qemu-guest-agent para implementar la compatibilidad con los comandos QMP que mejorarán las capacidades de administración del hipervisor. Después de instalar el paquete, puedes habilitar e iniciar el qemu-ga.service.\n\n"
    },
    {
      "title": "Bloquear controladores de dispositivo",
      "level": 4,
      "content": "Windows no viene con los controladores virtio. Por lo tanto, tendrá que cargarlos durante la instalación. Hay básicamente dos maneras de hacer esto: vía disco blando o vía archivos de ISO. Ambas imágenes se pueden descargar desde el repositorio Fedora.\n\nLa opción del disquete es difícil porque necesitará presionar F6 (Shift-F6 en Windows más reciente) al inicio de la alimentación del QEMU. Esto es difícil ya que necesitas tiempo para conectar tu ventana de consola VNC. Puede intentar agregar un retardo a la secuencia de arranque. Consulte man qemu-system para obtener más detalles sobre la aplicación de un retardo en el arranque.\n\nLa opción ISO para cargar los controladores es la forma preferida, pero está disponible sólo en Windows Vista y Windows Server 2008 y versiones posteriores. El procedimiento consiste en cargar la imagen con controladores virtio en un dispositivo de cdrom adicional junto con el dispositivo de disco principal y el instalador de Windows:\n\n```\n$ qemu-system-i386 ... \\\n-drive file=/path/to/primary/disk.img,index=0,media=disk,if=virtio \\\n-drive file=/path/to/installer.iso,index=2,media=cdrom \\\n-drive file=/path/to/virtio.iso,index=3,media=cdrom \\\n...\n```\n\nDurante la instalación, el instalador de Windows le pedirá su clave de producto y realizará algunas comprobaciones adicionales. Cuando llegue a la \"¿Dónde desea instalar Windows?\" Pantalla, dará una advertencia de que no se encuentran discos. Siga las instrucciones de ejemplo siguientes (basadas en Windows Server 2012 R2 con Actualización).\n\n- Seleccione la opción Load Drivers.\n- Desactive la casilla de \"Ocultar los controladores que no son compatibles con el hardware de este equipo\".\n- Haga clic en el botón Examinar y abra el CDROM para la virtio iso, normalmente llamada \"virtio-win-XX\".\n- Ahora vaya a E:\\viostor\\[your-os]\\amd64, seleccione y pulse OK.\n- Click Next\n\nAhora debería ver sus discos virtio listados aquí, listos para ser seleccionados, formateados e instalados.\n\nModificar un invitado de Windows existente para arrancar desde disco virtio es un poco difícil.\n\nPuede descargar el controlador de disco virtio desde el repositorio de Fedora.\n\nAhora necesita crear una nueva imagen de disco, que llene la fuerza de Windows para buscar el controlador. Por ejemplo:\n\n```\n$ qemu-img create -f qcow2 fake.qcow2 1G\n```\n\nEjecute el invitado original de Windows (con el disco de inicio todavía en modo IDE) con el disco falso (en modo virtio) y un CD-ROM con el controlador.\n\n```\n$ qemu-system-i386 -m 512 -vga std -drive file=windows_disk_image,if=ide -drive file=fake.qcow2,if=virtio -cdrom virtio-win-0.1-81.iso\n```\n\nWindows detectará el disco falso y tratará de encontrar un controlador para ello. Si falla, vaya al Administrador de dispositivos , busque la unidad SCSI con un icono de signo de exclamación (debe estar abierto), haga clic en Actualizar controlador y seleccione el CD-ROM virtual. No olvide seleccionar la casilla de verificación que dice que debe buscar directorios recursivamente.\n\nCuando la instalación se realiza correctamente, puede apagar la máquina virtual y volver a iniciarla, ahora con el disco de arranque conectado en modo virtio:\n\n```\n$ qemu-system-i386 -m 512 -vga std -drive file=windows_disk_image,if=virtio\n```\n\n"
    },
    {
      "title": "Controladores de red",
      "level": 4,
      "content": "La instalación de los controladores de red virtio es un poco más fácil, simplemente agregue el argumento -net como se explicó anteriormente.\n\n```\n$ qemu-system-i386 -m 512 -vga std -drive file=windows_disk_image,if=virtio -net nic,model=virtio -cdrom virtio-win-0.1-74.iso\n```\n\nWindows detectará el adaptador de red y tratará de encontrar un controlador para ello. Si falla, vaya al Administrador de dispositivos, localice el adaptador de red con un icono de signo de exclamación (debe estar abierto), haga clic en Actualizar controlador y seleccione el CD-ROM virtual. No olvide seleccionar la casilla de verificación que dice que debe buscar directorios recursivamente.\n\n"
    },
    {
      "title": "Preparación de FreeBSD como invitado",
      "level": 3,
      "content": "Instale el puerto emulators/virtio-kmod si está utilizando FreeBSD 8.3 o posterior hasta 10.0-CURRENT donde están incluidos en el kernel. Después de la instalación, añada lo siguiente a su archivo /boot/loader.conf:\n\n```\nvirtio_loader=\"YES\"\nvirtio_pci_load=\"YES\"\nvirtio_blk_load=\"YES\"\nif_vtnet_load=\"YES\"\nvirtio_balloon_load=\"YES\"\n```\n\nA continuación, modifique su /etc/fstab haciendo lo siguiente:\n\n```\nsed -i bak \"s/ada/vtbd/g\" /etc/fstab\n```\n\nY verificar que /etc/fstab es consistente. Si algo sale mal, sólo arranque en un CD de rescate y copie /etc/fstab.bak de vuelta a /etc/fstab.\n\n"
    },
    {
      "title": "Con libvirt",
      "level": 4,
      "content": "Si se configura una máquina virtual con libvirt, se puede configurar a través de la interfaz gráfica de usuario de virt-manager para iniciar en el arranque de host, accediendo a las Opciones de arranque de la máquina virtual y seleccionando \"Inicio de la máquina virtual en el arranque del host\".\n\n"
    },
    {
      "title": "Script personalizado",
      "level": 4,
      "content": "Para ejecutar QEMU VMs al arrancar, puede usar las siguientes unidades systemd y config.\n\n```\n/etc/systemd/system/qemu@.service\n```\n\n```\n[Unit]\nDescription=QEMU virtual machine\n\n[Service]\nEnvironment=\"type=system-x86_64\" \"haltcmd=kill -INT $MAINPID\"\nEnvironmentFile=/etc/conf.d/qemu.d/%i\nExecStart=/usr/bin/env qemu-${type} -name %i -nographic $args\nExecStop=/bin/sh -c ${haltcmd}\nTimeoutStopSec=30\nKillMode=none\n\n[Install]\nWantedBy=multi-user.target\n```\n\nA continuación, cree archivos de configuración por-VM, denominados /etc/conf.d/qemu.d/vm_name, con las siguientes variables establecidas:\n\nEjemplo de configuración:\n\n```\n/etc/conf.d/qemu.d/one\n```\n\n```\ntype=\"system-x86_64\"\n\nargs=\"-enable-kvm -m 512 -hda /dev/mapper/vg0-vm1 -net nic,macaddr=DE:AD:BE:EF:E0:00 \\\n -net tap,ifname=tap0 -serial telnet:localhost:7000,server,nowait,nodelay \\\n -monitor telnet:localhost:7100,server,nowait,nodelay -vnc :0\"\n\nhaltcmd=\"echo 'system_powerdown' | nc localhost 7100\" # or netcat/ncat\n\n# You can use other ways to shut down your VM correctly\n#haltcmd=\"ssh powermanager@vm1 sudo poweroff\"\n```\n\n```\n/etc/conf.d/qemu.d/two\n```\n\n```\nargs=\"-enable-kvm -m 512 -hda /srv/kvm/vm2.img -net nic,macaddr=DE:AD:BE:EF:E0:01 \\\n -net tap,ifname=tap1 -serial telnet:localhost:7001,server,nowait,nodelay \\\n -monitor telnet:localhost:7101,server,nowait,nodelay -vnc :1\"\n\nhaltcmd=\"echo 'system_powerdown' | nc localhost 7101\"\n```\n\nPara establecer qué máquinas virtuales se iniciarán al arrancar, habilite la unidad de systemd qemu@vm_name.service.\n\n"
    },
    {
      "title": "Integración del ratón",
      "level": 3,
      "content": "Para evitar que el ratón sea agarrado al hacer clic en la ventana del sistema operativo invitado, agregue la opción -usbdevice tablet. Esto significa que QEMU puede reportar la posición del ratón sin tener que agarrar el ratón. Esto también anula la emulación de ratón PS/2 cuando se activa. Por ejemplo:\n\n```\n$ qemu-system-i386 -hda disk_image -m 512 -vga std -usbdevice tablet\n```\n\nIf that does not work, try the tip at #El cursor del ratón está nervioso o errático.\n\n"
    },
    {
      "title": "Dispositivo USB del host de paso",
      "level": 3,
      "content": "Para acceder al dispositivo físico USB conectado al host desde la VM, puede utilizar la opción: -usbdevice host:vendor_id:product_id.\n\nPuedes encontrar vendor_id y product_id de tu dispositivo con el comando lsusb.\n\nPuesto que el chipset I440FX por defecto emulado por qemu cuentan con un solo controlador UHCI (USB 1), la opción -usbdevice intentará conectar su dispositivo físico a él. En algunos casos esto puede causar problemas con los dispositivos más nuevos. Una posible solución es emular el chipset ICH9, que ofrece un controlador EHCI que soporta hasta 12 dispositivos, usando la opción -machine type=q35.\n\nUna solución menos invasiva es emular un controlador EHCI (USB 2) o XHCI (USB 3) con la opción -device usb-ehci, id = ehci o -device nec -usb-xhci, id=xhci respectivamente y luego adjuntar su dispositivo físico con la opción -device usb-host,.. como sigue:\n\n```\n-device usb-host,bus=controller_id.0,vendorid=0xvendor_id,productid=0xproduct_id\n```\n\nTambién puede agregar la configuración ..., port =<n> a la opción anterior para especificar en qué puerto físico del controlador virtual que desea conectar su dispositivo, útil en El caso que desea agregar varios dispositivos usb a la VM.\n\n"
    },
    {
      "title": "Habilitar KSM",
      "level": 3,
      "content": "Kernel Samepage Merging (KSM) es una característica del kernel de Linux que permite que una aplicación se registre con el kernel para que sus páginas se combinen con otros procesos que también se registren para que sus páginas se fusionen. El mecanismo KSM permite a las máquinas virtuales invitadas compartir páginas entre sí. En un entorno donde muchos de los sistemas operativos invitados son similares, esto puede resultar en ahorros significativos de memoria.\n\nPara activar KSM, simplemente ejecute:\n\n```\n# echo 1 > /sys/kernel/mm/ksm/run\n```\n\nPara hacerlo permanente, puede utilizar archivos temporales de systemd:\n\n```\n/etc/tmpfiles.d/ksm.conf\n```\n\n```\nw /sys/kernel/mm/ksm/run - - - - 1\n```\n\nSi KSM está en ejecución y hay páginas que se van a fusionar (es decir, al menos dos máquinas virtuales similares se están ejecutando), entonces /sys/kernel/mm/ksm/pages_shared debería ser distinto de cero. Consulte https://docs.kernel.org/vm/ksm.html[enlace roto 2022-09-22] para obtener más información.\n\n```\n$ grep./Sys/kernel/mm/ksm/*\n```\n\n"
    },
    {
      "title": "Multi-monitor support",
      "level": 3,
      "content": "El controlador QXL de Linux soporta cuatro cabezas (pantallas virtuales) de forma predeterminada. Esto se puede cambiar a través del parámetro kernel qxl.heads = N.\n\nEl tamaño de memoria VGA predeterminado para los dispositivos QXL es de 16M (el tamaño de la VRAM es de 64M). Esto no es suficiente si desea habilitar dos monitores 1920x1200 ya que requiere 2 × 1920 × 4 (profundidad de color) × 1200 = 17.6 MiB memoria VGA. Esto se puede cambiar reemplazando -vga qxl por -vga none -device qxl-vga, vgamem_mb=32. Si alguna vez incrementas vgamem_mb más allá de 64M, también debes aumentar la opción vram_size_mb.\n\n"
    },
    {
      "title": "Copiar y pegar",
      "level": 3,
      "content": "Para poder copiar y pegar entre el host y el invitado, debe habilitar el canal de comunicación del agente de especias. Requiere agregar un dispositivo virtio-serial al huésped, y abrir un puerto para el vdagent de la especia. También es necesario instalar el spice vdagent en invitado (spice-vdagent para invitados de Arch, Herramientas para invitados de Windows para invitados de Windows). Asegúrese de que el agente se está ejecutando (y para el futuro, se iniciará automáticamente).\n\nInicie QEMU con las siguientes opciones:\n\n```\n$ qemu-system-i386 -vga qxl -spice port=5930,disable-ticketing -device virtio-serial-pci -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 -chardev spicevmc,id=spicechannel0,name=vdagent\n```\n\nLa opción -device virtio-serial-pci añade el dispositivo virtio-serial, -device virtserialport, chardev=spicechannel0, nombre=com.redhat.spice.0 abre un puerto Para spice vdagent en ese dispositivo y -chardev spicevmc, id=spicechannel0, nombre=vdagent añade un spicevmc chardev para ese puerto.\n\nEs importante que la opción chardev= del dispositivo virtserialport coincida con la opción id= dada a la opción chardev (spicechannel0 en este ejemplo). También es importante que el nombre del puerto sea com.redhat.spice.0, ya que es el espacio de nombres donde vdagent está buscando en el invitado. Y finalmente, especifique name=vdagent para que spice sepa para qué sirve este canal.\n\n"
    },
    {
      "title": "Notas específicas de Windows",
      "level": 3,
      "content": "QEMU puede ejecutar cualquier versión de Windows desde Windows 95 a través de Windows 10.\n\nEs posible ejecutar Windows PE en QEMU.\n\n"
    },
    {
      "title": "Inicio rápido",
      "level": 4,
      "content": "Para invitados de Windows 8 (o posteriores), es mejor desactivar \"Activar inicio rápido (recomendado)\" en Opciones de energía del Panel de control, ya que hace que el invitado se bloquee durante cada arranque.\n\nEl inicio rápido también puede necesitar deshabilitarse para que los cambios en la opción -smp se apliquen correctamente.\n\n"
    },
    {
      "title": "Protocolo de escritorio remoto",
      "level": 4,
      "content": "Si utiliza un invitado de MS Windows, puede utilizar RDP para conectarse a su VM invitada. Si está utilizando una VLAN o no está en la misma red que el invitado, utilice:\n\n```\n$ qemu-system-i386 -nographic -net user,hostfwd=tcp::5555-:3389\n```\n\nA continuación, conéctese con rdesktop ó freerdp al invitado. Por ejemplo:\n\n```\n$ xfreerdp -g 2048x1152 localhost:5555 -z -x lan\n```\n\n"
    },
    {
      "title": "La máquina virtual virtual corre muy lento",
      "level": 3,
      "content": "Hay algunas técnicas que se pueden usar para implementar rendimiento en la máquina virtual, por ejemplo:\n\n- Use la opción -cpu host para hacer que QEMU emule la CPU del host. Si no se hace esto, podría intentar emular un CPU más genérico.\n- Especialmente para los invitados de Windows, habilite Iluminaciones de Hyper-V: -Host de la CPU, hv_relaxed, hv_spinlocks=0x1fff, hv_vapic, hv_time.\n- Si la máquina host tiene varias CPUs, asigne al invitado más CPUs usando la opción -smp.\n- Asegúrese de haber asignado a la máquina virtual suficiente memoria. De forma predeterminada, QEMU sólo asigna 128 MiB de memoria a cada máquina virtual. Utilice la opción -m para asignar más memoria. Por ejemplo, -m 1024 ejecuta una máquina virtual con 1024 MiB de memoria.\n- Utilice KVM si es posible: agregue -machine type=pc, accel=kvm al comando de arranque QEMU que utilice.\n- Si es compatible con los controladores del sistema operativo invitado, utilice virtio para dispositivos de red y/o bloque. Por ejemplo:\n\n```\n$ qemu-system-i386 -net nic, model=virtio -net tap, if=tap0, script=no-drive file=disk_image,media=disco, if=virtio\n```\n\n- Utilizar dispositivos TAP en lugar de redes en modo usuario. Consulte #Tap de red con QEMU.\n- Si el sistema operativo invitado está haciendo escritura pesada en su disco, puede beneficiarse de ciertas opciones de montaje en el sistema de archivos del host. Por ejemplo, puede montar un sistema de archivos ext4 con la opción barrier=0. Debe leer la documentación de las opciones que cambie porque a veces las opciones de mejora de rendimiento para los sistemas de archivos tienen el costo de integridad de los datos.\n- Si tiene una imagen de disco sin procesar, puede deshabilitar la caché:\n\n```\n$ qemu-system-i386 -drive file=disk_image, if=virtio, cache=none\n```\n\n- Utilice el nativo Linux AIO:\n\n```\n$ qemu-system-i386 -drive file=disk_image, if=virtio, aio=native\n```\n\n- Si utiliza una imagen de disco qcow2, el rendimiento de E/S se puede mejorar considerablemente al garantizar que el caché L2 es de tamaño suficiente. La fórmula [4] para calcular La caché L2 es: l2_cache_size = disk_size * 8 / cluster_size. Suponiendo que la imagen qcow2 se creó con el tamaño de clúster predeterminado de 64 K, esto significa que para cada 8 GB de tamaño de la imagen qcow2, 1 MB de caché L2 es mejor para el rendimiento. QEMU utiliza sólo 1 MB por defecto; Especificar una caché más grande se hace en la línea de comandos QEMU. Por ejemplo, para especificar 4 MB de caché (adecuado para un disco de 32 GB con un tamaño de clúster de 64 KB):\n\n```\n$ qemu-system-i386 -drive file=disk_image,format=qcow2, l2-cache-size=4M\n```\n\n- Si está ejecutando varias máquinas virtuales al mismo tiempo que todas tienen el mismo sistema operativo instalado, puede ahorrar memoria al habilitar kernel de la misma página de fusión. Consulte #Habilitar KSM.\n- En algunos casos, la memoria se puede recuperar de correr máquinas virtuales ejecutando un controlador de globo de memoria en el sistema operativo invitado y lanzando QEMU con la opción -balloon virtio.\n- Es posible utilizar una capa de emulación para un controlador ICH-9 AHCI (aunque puede ser inestable). La emulación AHCI soporta NCQ, por lo que varias peticiones de lectura o escritura pueden estar pendientes al mismo tiempo:\n\n```\n$ qemu-system-i386 -drive id=disc, file=disk_image, if=none -device ich9-ahci, id=ahci -device ide-drive, drive=disk, bus=ahci.0\n```\n\nMira https://www.linux-kvm.org/page/Tuning_KVM para más información.\n\n"
    },
    {
      "title": "El cursor del ratón está nervioso o errático",
      "level": 3,
      "content": "Si el cursor \"brinca\" descontroladamente, podría ayudar ingresar este comando en la terminal antes de iniciar QEMU\n\n```\n$ export SDL_VIDEO_X11_DGAMOUSE=0\n```\n\nSi funciono, puedes agregarlo a tu ~/.bashrc archivo.\n\n"
    },
    {
      "title": "El cursor no es visible",
      "level": 3,
      "content": "Añade -show-cursor a las opciones de QEMU para poder ver el cursor.\n\nSi persiste, asegurate de configurar la pantalla apropiadamente\n\nPor ejemplo: -vga qxl\n\n"
    },
    {
      "title": "No se puede mover / adjuntar el cursor",
      "level": 3,
      "content": "Reemplaza -usbdevice tablet con -usb como opción en QEMU.\n\n"
    },
    {
      "title": "El teclado parece roto ó las teclas de flecha no funcionan",
      "level": 3,
      "content": "Probablemente notarás que algunas de tus teclas no funcionan ó \"presionan\" la tecla equivocada (en particular, las flechas), preferentemente, necesitas especificar la distribución de tu teclado como una opción. La distribución del teclado puede encontrarse en /usr/share/qemu/keymaps.\n\n```\n$ qemu-system-i386 -k keymap disk_image\n```\n\n"
    },
    {
      "title": "Pantalla de invitado estirada en el tamaño de la ventana",
      "level": 3,
      "content": "Para restarurar el tamaño por defecto de la ventanta, presiona Ctrl+Alt+u.\n\n"
    },
    {
      "title": "ioctl(KVM_CREATE_VM) failed: 16 Device or resource busy",
      "level": 3,
      "content": "Si un mensaje de error como este es listado en el arranque de QEMU con la opción -enable-kvm:\n\n```\nioctl(KVM_CREATE_VM) failed: 16 Device or resource busy\nfailed to initialize KVM: Device or resource busy\n```\n\nSignifica que otro hypervisor está actualmente activo. No se recomienda ó no es poible correr varios hypervisores en paralelo.\n\n"
    },
    {
      "title": "Mensaje de error libgfapi",
      "level": 3,
      "content": "El mensaje de error listado en el arranque:\n\n```\nFailed to open module: libgfapi.so.0: cannot open shared object file: No such file or directory\n```\n\nNo es un problema, sólo significa que hace falta la dependencia opcional de GlusterFS\n\n"
    },
    {
      "title": "Kernel panic en entornos live",
      "level": 3,
      "content": "Si inicia un sistema en vivo (ó bootea uno) podría encontrar esto:\n\n```\nend Kernel panic - not syncing: VFS: Unable to mount root fs on unknown block(0,0)\n```\n\nÓ algún otro proceso de arranque (ej. no se puede desempaquetar initramfs, no puede iniciar un servicio foo).\n\nIntente iniciar la Máquina Virtual con el -m VALOR switch y un tamaño apropiado de RAM, si la RAM es muy poca probablemente encontrará problemas similares a los anteriores.\n\n"
    },
    {
      "title": "Ver también",
      "level": 2,
      "content": "- Sitio web oficial de QEMU\n- Sitio web oficial de KVM\n- Documentación para el usuario del emulador QEMU (en inglés)\n- Wikilibro de QEMU (en inglés)\n- [http://alien.slackbook.org/dokuwiki/doku.php?id=slackware:qemu Virtualización de hardware con QEMU por AlienBOB (última actualización en 2008) (en inglés)\n- Construyendo un ejército virtual por Falconindy (en inglés)\n- Últimos documentos\n- QEMU en Windows\n- Wikipedia\n- QEMU - Wiki de Debian (en inglés)\n- QEMU Networking on gnome.org[enlace roto 2022-09-22]\n- Red virtual de QEMU en sistemas BSD (en inglés)\n- QEMU on gnu.org\n- QEMU en FreeBSD como host (en inglés)\n\n"
    }
  ]
}