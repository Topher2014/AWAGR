{
  "title": "Systemd-networkd (Русский)",
  "url": "https://wiki.archlinux.org/title/Systemd-networkd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- systemd (Русский)\n- systemd-resolved (Русский)\n- systemd-nspawn\n- Network bridge\n- Настройка сети\n- Настройка беспроводной сети\n- Category:Network configuration (Русский)\n\nsystemd-networkd — системный демон для управления сетевыми настройками. Его задачей является обнаружение и настройка сетевых устройств по мере их появления, а также создание виртуальных сетевых устройств. Эта служба особенно полезна при работе со сложными сетевыми настройками контейнера systemd-nspawn или виртуальной машины, но вполне подойдёт и для простых соединений.\n\n"
    },
    {
      "title": "Основы использования",
      "level": 2,
      "content": "Пакет systemd входит в базовую установку Arch. В нём содержится всё необходимое для работы с проводной сетью. Беспроводные сетевые интерфейсы настраиваются специализированными утилитами вроде wpa_supplicant или iwd.\n\n"
    },
    {
      "title": "Службы и настройки",
      "level": 3,
      "content": "Чтобы включить systemd-networkd, запустите/включите службу systemd-networkd.service.\n\nПри необходимости можно также настроить systemd-resolved, который будет выполнять разрешение сетевых имён для прикладных приложений:\n\n- Некоторые пояснения насчёт того, как systemd-resolved работает с файлом resolv.conf, можно найти в статье systemd-resolved.\n- systemd-resolved необходим, если в .network-файлах заданы связанные с DNS параметры.\n- systemd-resolved необходим, если DNS-адреса будут выдаваться DHCP-сервером или через IPv6 router advertisements (параметры DHCP= и/или IPv6AcceptRA= в разделе [Network], а также UseDNS=yes (задано по умолчанию) в разделах [DHCPv4], [DHCPv6], [IPv6AcceptRA], см. systemd.network(5)).\n- Кроме того, systemd-resolved может использоваться и без systemd-networkd.\n\n"
    },
    {
      "title": "systemd-networkd-wait-online",
      "level": 3,
      "content": "Cлужба systemd-networkd-wait-online.service запускается автоматически при включении службы systemd-networkd.service. Это служба типа \"oneshot\", которая ожидает конфигурации доступа в сеть и начинает работу только после выполнения цели network-online.target (параметр WantedBy=network-online.target). См. также systemd#Запуск сервисов после подключения к сети.\n\nПо умолчанию systemd-networkd-wait-online.service ожидает получения информации о состоянии всех интерфейсов под управлением systemd-networkd, причем минимум на одном интерфейсе должно быть установлено рабочее подключение.\n\nЕсли в вашей системе несколько интерфейсов, но некоторые не смогли подключиться к сети (например, Ethernet-интерфейс с двумя портами, но кабель воткнут только в один), запуск systemd-networkd-wait-online.service завершится неудачно по истечении тайм-аута в 2 минуты. Это может стать причиной неприятной паузы во время загрузки системы. Чтобы служба ожидала подключения любого интерфейса, а не всех, отредактируйте файл службы, добавив параметр --any к строке ExecStart:\n\n```\n/etc/systemd/system/systemd-networkd-wait-online.service.d/wait-for-only-one-interface.conf\n```\n\n```\n[Service]\nExecStart=\nExecStart=/usr/lib/systemd/systemd-networkd-wait-online --any\n```\n\nТакже можно настроить и другие параметры, например, ожидание включения конкретных интерфейсов и режим работы. Подробнее см. systemd-networkd-wait-online(8).\n\n"
    },
    {
      "title": "Примеры настроек",
      "level": 3,
      "content": "Настройки должны храниться в каталоге /etc/systemd/network в файлах с суффиксом .network. Подробнее смотрите #Файлы настроек и systemd.network(5).\n\nsystemd/udev автоматически назначает постоянные имена для обнаруженных Ethernet, WLAN и WWAN интерфейсов. Перечень интерфейсов можно увидеть командой networkctl list.\n\nЧтобы изменения настроек вступили в силу необходимо будет перезапустить демон systemd-networkd.service.\n\n- Параметры в файлах настроек чувствительны к регистру.\n- В примерах ниже enp1s0 — проводной интерфейс, а wlp2s0 — беспроводной. Названия интерфейсов на вашей системе могут отличаться. Подробнее об именах интерфейсов см. Настройка сети#Сетевые интерфейсы.\n- Можно использовать подстановочные символы (wildcards), например Name=en* или Name=wl*.\n- Можно искать устройства по типу. Например, Type=ether для Ethernet, Type=wlan для Wi-Fi и Type=wwan для WWAN. Учтите, что Type=ether включает также виртуальные Ethernet-интерфейсы (veth*), что может оказаться нежелательно.\n- Если вы хотите отключить IPv6, то изучите статью IPv6#systemd-networkd.\n\n"
    },
    {
      "title": "Проводной интерфейс с DHCP",
      "level": 4,
      "content": "```\n/etc/systemd/network/20-wired.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Network]\nDHCP=yes\n```\n\n"
    },
    {
      "title": "Проводной интерфейс со статическим IP-адресом",
      "level": 4,
      "content": "```\n/etc/systemd/network/20-wired.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Network]\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.1\n```\n\nПараметр Address= можно указать несколько раз, если необходимо настроить несколько IPv4 и IPv6 адресов. Подробнее смотрите #Файлы network и systemd.network(5).\n\n"
    },
    {
      "title": "Беспроводной интерфейс",
      "level": 4,
      "content": "Беспроводной сетевой интерфейс нужно предварительно настроить приложением вроде wpa_supplicant или iwd. После этого можно подключиться к беспроводной сети посредством systemd-networkd:\n\n```\n/etc/systemd/network/25-wireless.network\n```\n\n```\n[Match]\nName=wlp2s0\n\n[Network]\nDHCP=yes\n```\n\nЕсли беспроводному интерфейсу назначен статический IP-адрес, то настройка полностью (за исключением названия интерфейса) совпадает с настройкой проводного интерфейса.\n\nДля аутентификации в беспроводной сети можно использовать wpa_supplicant или iwd.\n\n"
    },
    {
      "title": "Проводные и беспроводные интерфейсы на одной машине",
      "level": 4,
      "content": "Когда в системе есть и проводной, и беспроводной интерфейсы, настройте директиву ядра metric, чтобы оно могло \"на лету\" определять, какой из интерфейсов использовать. В этом случае при отключении проводного соединения полного обрыва связи не произойдёт.\n\nЯдро использует настройки метрик при выборе одного из возможных маршрутов для исходящих пакетов — например, при двух включённых сетевых интерфесах, проводном и беспроводном. Если вдруг одно из соединений прерывается, то второй вариант автоматически объявляется победителем. При этом полного разрыва соединения не происходит. Правда, для текущих процессов передачи данных не всегда всё так гладко, но, сторого говоря, это проблема другого уровня сетевой модели OSI.\n\n```\n/etc/systemd/network/20-wired.network\n```\n\n```\n[Match]\nName=enp1s0\n\n[Network]\nDHCP=yes\n\n[DHCP]\nRouteMetric=10\n```\n\n```\n/etc/systemd/network/25-wireless.network\n```\n\n```\n[Match]\nName=wlp2s0\n\n[Network]\nDHCP=yes\n\n[DHCP]\nRouteMetric=20\n```\n\n"
    },
    {
      "title": "Переименование интерфейса",
      "level": 4,
      "content": "Файлы .link можно использовать для назначения интерфейсу нового имени вместо редактирования правил udev. Например, можно задать постоянное имя интерфейса для USB-to-Ethernet адаптера на основе его MAC-адреса, т.к. имена таким адаптерам обычно назначаются в зависимости от того, к какому USB-порту они подключены.\n\n```\n/etc/systemd/network/10-ethusb0.link\n```\n\n```\n[Match]\nMACAddress=12:34:56:78:90:ab\n\n[Link]\nDescription=USB to Ethernet Adapter\nName=ethusb0\n```\n\n"
    },
    {
      "title": "Файлы настроек",
      "level": 2,
      "content": "Файлы настроек могут находиться в следующих каталогах (в порядке увеличения приоритета):\n\n- /usr/lib/systemd/network/ — системный сетевой каталог.\n- /run/systemd/network/ — runtime-каталог сетевых программ.\n- /etc/systemd/network/ — локальный каталог системного администрирования.\n\nСуществуют три типа файлов настройки.\n\n- Файлы .network — настройки (профили) сетевых интерфейсов.\n- Файлы .netdev — настройки (профили) виртуальных сетевых интерфейсов.\n- Файлы .link — настройки, которые использует менеджер устройств udev при обнаружении нового интерфейса.\n\nДля этих файлов действуют следующие правила:\n\n- Профиль активируется, если совпали все условия в разделе [Match].\n- Если в разделе [Match] не указано ничего, то профиль применяется для всех устройств (можно сравнить с подстановочным символом *).\n- Файлы настроек сортируются по названиям и обрабатываются в лексическом порядке, независимо от каталога, в котором они расположены.\n- Файлы с одинаковыми названиями заменяют друг друга — в порядке приоритета каталогов, в которых они находятся.\n\n- Файлы в каталоге /etc/systemd/network/ имеют приоритет перед системными файлами в /usr/lib/systemd/network/. Создайте в этом каталоге символическую ссылку на /dev/null, чтобы \"замаскировать\" системный файл.\n- systemd понимает значения 1, true, yes, on как логическое true, а 0, false, no, off — как false.\n\n"
    },
    {
      "title": "Файлы network",
      "level": 3,
      "content": "В network-файлах задаются сетевые настройки, чаще всего — для серверов и контейнеров.\n\nФайлы .network могут содержать разделы [Match], [Link], [Network], [Address], [Route] и [DHCP]. Ниже приведены основные параметры для каждого раздела. Подробнее смотрите systemd.network(5).\n\n"
    },
    {
      "title": "[Match]",
      "level": 4,
      "content": "Наиболее распространенные ключи для поиска совпадающего устройства:\n\nTable content:\nПараметр | Описание | Возможные значения | Значение по умолчанию\nName= | Поиск интерфейса по названию, например: en*. Символ ! в начале инвертирует результаты поиска. | Разделённые пробелами названия интерфейсов (можно указывать шаблоны с подстановочными символами в стиле командной оболочки), логическое отрицание (!). | \nMACAddress= | Поиск интерфейса по MAC-адресу, например: MACAddress=01:23:45:67:89:ab 00-11-22-33-44-55 AABB.CCDD.EEFF | Разделённые пробелами MAC-адреса в шестнадцатеричном формате; в качестве внутреннего разделителя в адресах можно использовать двоеточия, дефисы и точки. | \nHost= | Поиск по имени хоста или machine ID. | Имя хоста (в том числе в виде шаблона), machine-id(5) | \nVirtualization= | Проверка на работу в виртуальном окружении. Virtualization=false — для хост-системы, Virtualization=true — для работы в контейнере или виртуальной машине. Есть возможность проверить тип виртуализации и пространство имён пользователя (параметр private-users). | булевские, логическое отрицание (!), тип (vm и container), реализация (qemu, kvm, zvm, vmware, microsoft, oracle, powervm, xen, bochs, uml, bhyve, qnx, openvz, lxc, lxc-libvirt, systemd-nspawn, docker, podman, rkt, wsl, proot, pouch, acrn), private-users | \n\n"
    },
    {
      "title": "[Link]",
      "level": 4,
      "content": "Table content:\nПараметр | Описание | Допустимые значения | Значение по умолчанию\nMACAddress= | Привязка аппаратного адреса к устройству. Полезно при подмене MAC-адреса. | Полный MAC-адрес с двоеточием, дефисом или точкой в качестве разделителя | \nMTUBytes= | Максимальный размер передаваемого пакета данных для данного интерфейса. Имейте в виду, что если для интерфейса включён IPv6 и задано значение MTU ниже 1280 (минимальный MTU для IPv6), то оно будет автоматически увеличено до этого значения. Большее значение MTU (например, при использовании jumbo frames) может повысить скорость передачи данных. | Целое число; возможны суффиксы K, M, G для указания размерности (основание 1024) | \nMulticast= | групповая передача для интерфейса(-ов). | булевское | ? не задокументировано ?\n\n"
    },
    {
      "title": "[Network]",
      "level": 4,
      "content": "Table content:\nПараметр | Описание | Допустимые значения | Значение по умолчанию\nDHCP= | Поддержка DHCPv4- и/или DHCPv6-клиента. | булевское, ipv4, ipv6. | false\nDHCPServer= | Запуск сервера DHCPv4. | булевское | false\nMulticastDNS= | Поддержка multicast DNS. Если задать значение resolve, то включится только разрешение имён, но не регистрация и объявление хостов/служб. | булевское, resolve | false\nDNSSEC= | Поддержка DNSSEC. Если задать значение allow-downgrade, то DNSSEC будет автоматически отключаться в не-DNSSEC сетях, что повысит совместимость. | булевское, allow-downgrade | false\nDNS= | Адрес DNS-сервера. Может указываться больше одного раза. | inet_pton(3) | \nDomains= | Список доменов, которые должны разрешаться с использованием DNS-сервера (systemd.network(5) § [NETWORK] SECTION OPTIONS). | имя домена (в том числе с символом (~) в начале) | \nIPForward= | Пересылка входящих пакетов на другой интерфейс в соответствии с таблицей маршрутизации. Подробнее см. Раздача интернета#Разрешите пересылку пакетов. | булевское, ipv4, ipv6 | false\nIPMasquerade= | Если опция включена, то при пересылке пакетов IP-адрес источника подменяется адресом локального сетевого интерфейса. Неявно подразумевает IPForward=ipv4, IPForward=ipv6 или IPForward=yes. | ipv4, ipv6, both, no | no\nIPv6PrivacyExtensions= | Использование временных IPv6-адресов в соответствии с RFC 4941. Если задать значение prefer-public, то privacy extensions включатся, но предпочтение будет отдаваться использованию публичных адресов, а не временных. Если задать значение kernel, то будут использоваться настройки ядра. | булевское, prefer-public, kernel | false\n\n"
    },
    {
      "title": "[Address]",
      "level": 4,
      "content": "Table content:\nПараметр | Описание | Допустимые значения | Значение по умолчанию\nAddress= | Можно настроить несколько адресов, указав этот ключ несколько раз. Опция обязательна, если не используется DHCP. Если указать значение 0.0.0.0 (для IPv4) или :: (для IPv6), то будет выделен неиспользуемый блок адресов заданного размера. | сатические адреса IPv4 и IPv6 с длиной префикса (см. inet_pton(3)) | \n\n"
    },
    {
      "title": "[Route]",
      "level": 4,
      "content": "- Gateway= — адрес шлюза. Если не используется DHCP, то эта опция обязательна.\n- Destination= — префикс сети назначения.\n\nЕсли параметр Destination не задан, то используется маршрут по умолчанию.\n\n"
    },
    {
      "title": "[DHCP]",
      "level": 4,
      "content": "Table content:\nПараметр | Описание | Допустимые значения | Значение по умолчанию\nUseDNS= | Объявление DNS-сервера при работе DHCP-сервера. | булевское | true\nAnonymize= | Если задать значение true, посылаемые DHCP-серверу параметры будут соответствовать RFC:7844 (Anonymity Profiles for DHCP Clients) для сокрытия идентифицирующей информации. | булевское | false\nUseDomains= | Использование полученного от DHCP-сервера домена в качестве адреса для DNS-поиска. Если задать значение route, полученное доменное имя будет использоваться только для маршрутизации DNS-запросов, но не для поиска. Эта опция может повлиять на локальное разрешение имён с помощью systemd-resolved. | булевское, route | false\n\n"
    },
    {
      "title": "[DHCPServer]",
      "level": 4,
      "content": "Ниже приведён пример настройки DHCP-сервера с hostapd, выступающего в качестве беспроводной точки доступа. Параметр IPMasquerade включает правила межсетевого экрана для NAT, а также автоматически включает IPForward=ipv4, что разрешает пересылку пакетов.\n\n```\n/etc/systemd/network/wlan0.network\n```\n\n```\n[Match]\nName=wlan0\n\n[Network]\nAddress=10.1.1.1/24\nDHCPServer=true\nIPMasquerade=true\n\n[DHCPServer]\nPoolOffset=100\nPoolSize=20\nEmitDNS=yes\nDNS=9.9.9.9\n```\n\n"
    },
    {
      "title": "Файлы netdev",
      "level": 3,
      "content": "В файлах netdev описывается создание виртуальных сетевых интерфейсов. В нём два раздела, [Match] и [NetDev]. Ниже приведены некоторые важные параметры. Подробнее смотрите systemd.netdev(5).\n\n"
    },
    {
      "title": "[Match]",
      "level": 4,
      "content": "- Host= — поиск по имени хоста.\n- Virtualization= — проверка на работу в виртуальном окружении.\n\n"
    },
    {
      "title": "[Netdev]",
      "level": 4,
      "content": "Наиболее распространенные ключи:\n\n- Name= — имя интерфейса. Опция обязательна.\n- Kind= — вид интерфейса. Например, bridge, bond, vlan, veth, sit и т.д. Опция обязательна.\n\n"
    },
    {
      "title": "Файлы link",
      "level": 3,
      "content": "Файлы link выступают в качестве альтернативы пользовательским правилам udev и применяются при обнаружении менеджером нового устройства. Файл состоит из двух разделов, [Match] и [Link]. Ниже приведены основные параметры обоих разделов. Подробнее смотрите systemd.link(5).\n\n"
    },
    {
      "title": "[Match]",
      "level": 4,
      "content": "- MACAddress= — поиск по MAC-адресу.\n- Host= — поиск по имени хоста.\n- Virtualization= — проверка на виртуализацию.\n- Type= — поиск по типу интерфейса (например, vlan).\n\n"
    },
    {
      "title": "[Link]",
      "level": 4,
      "content": "- MACAddressPolicy= — использование постоянных или же случайных адресов.\n- MACAddress= — использование конкретного адреса.\n- NamePolicy= — политики выбора и назначения имён интерфейсов, например, kernel, keep и т.д.\n\n"
    },
    {
      "title": "Использование с контейнерами",
      "level": 2,
      "content": "systemd-networkd предоставляет полную сетевую конфигурацию для контейнеров systemd-nspawn, запущенных как на хостовой системе, так и внутри другого контейнера. Подробнее см. systemd-nspawn#Networking\n\nВ примерах ниже:\n\n- вывод команды ip a будет ограничен только рассматриваемыми интерфейсами.\n- хост будет означать вашу основную ОС, а контейнер — гостевую виртуальную машину.\n- все названия сетевых интерфейсов и IP-адреса приведены в качестве примера.\n\n"
    },
    {
      "title": "Интерфейс моста",
      "level": 4,
      "content": "Первым делом необходимо создать виртуальный интерфейс моста. С помощью systemd создаём устройство-мост br0:\n\n```\n/etc/systemd/network/мой_мост.netdev\n```\n\n```\n[NetDev]\nName=br0\nKind=bridge\n```\n\nПерезапустите systemd-networkd.service, чтобы настройки вступили в силу.\n\nЧтобы увидеть новый мост на хосте или в контейнере, выполните:\n\n```\n$ ip a\n```\n\n```\n3: br0: <BROADCAST,MULTICAST> mtu 1500 qdisc noop state DOWN group default \n    link/ether ae:bd:35:ea:0c:c9 brd ff:ff:ff:ff:ff:ff\n```\n\nОбратите внимание, что интерфейс br0 обнаружен, но он всё ещё выключен (DOWN).\n\n"
    },
    {
      "title": "Привязка Ethernet к мосту",
      "level": 4,
      "content": "Следующий шаг — выполнить привязку реального сетевого интерфейса к виртуальному мосту. В примере ниже мы привязываем любой интерфейс, название которого совпадает с шаблоном en*.\n\n```\n/etc/systemd/network/привязка.network\n```\n\n```\n[Match]\nName=en*\n\n[Network]\nBridge=br0\n```\n\nВыбранному проводному интерфейсу не должно быть назначено никакого IP-адреса, поскольку для привязки необходим интерфейс без оного. Если необходимо, отредактируйте файл /etc/systemd/network/мой_Eth.network соответствующим образом.\n\n"
    },
    {
      "title": "Сеть моста",
      "level": 4,
      "content": "Теперь, поскольку мост создан и привязан к существующему сетевому интерфейсу, необходимо создать настройки IP. Это определяется в файле .network:\n\n```\n/etc/systemd/network/мой_мост.network\n```\n\n```\n[Match]\nName=br0\n\n[Network]\nDHCP=ipv4\n```\n\n"
    },
    {
      "title": "Настройка контейнера",
      "level": 4,
      "content": "Используйте параметр --networkd-bridge=br0 при запуске контейнера. Подробнее см. systemd-nspawn#Use a network bridge.\n\n"
    },
    {
      "title": "Результат",
      "level": 4,
      "content": "- для хоста\n\n```\n$ ip a\n```\n\n```\n3: br0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default \n    link/ether 14:da:e9:b5:7a:88 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.87/24 brd 192.168.1.255 scope global br0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::16da:e9ff:feb5:7a88/64 scope link \n       valid_lft forever preferred_lft forever\n6: vb-мой_контейнер: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast master br0 state UP group default qlen 1000\n    link/ether d2:7c:97:97:37:25 brd ff:ff:ff:ff:ff:ff\n    inet6 fe80::d07c:97ff:fe97:3725/64 scope link \n       valid_lft forever preferred_lft forever\n```\n\n- для контейнера\n\n```\n$ ip a\n```\n\n```\n2: host0: <BROADCAST,MULTICAST,ALLMULTI,AUTOMEDIA,NOTRAILERS,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000\n    link/ether 5e:96:85:83:a8:5d brd ff:ff:ff:ff:ff:ff\n    inet 192.168.1.73/24 brd 192.168.1.255 scope global host0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::5c96:85ff:fe83:a85d/64 scope link \n       valid_lft forever preferred_lft forever\n```\n\n"
    },
    {
      "title": "Замечания",
      "level": 4,
      "content": "- теперь задан один IP-адрес для интерфейса br0 на хосте, и один для интерфейса host0 в контейнере.\n- появилось два новых интерфейса: vb-мой_контейнер на хосте и host0 в контейнере. Это результат опции --network-bridge=br0 (см. systemd-nspawn#Use a network bridge).\n- DHCP-адрес интерфейса host0 был выдан на основании файла /usr/lib/systemd/network/80-container-host0.network.\n\n- на хосте\n\n```\n$ brctl show\n```\n\n```\nbridge name\tbridge id\t\tSTP enabled\tinterfaces\nbr0\t\t8000.14dae9b57a88\tno\t\tenp7s0\n\t\t\t\t\t\t\tvb-мой_контейнер\n```\n\nВыше показано, что в системе есть мост с двумя связанными интерфейсами.\n\n- на хосте\n\n```\n$ ip route\n```\n\n```\ndefault via 192.168.1.254 dev br0 \n192.168.1.0/24 dev br0  proto kernel  scope link  src 192.168.1.87\n```\n\n- на контейнере\n\n```\n$ ip route\n```\n\n```\ndefault via 192.168.1.254 dev host0 \n192.168.1.0/24 dev host0  proto kernel  scope link  src 192.168.1.73\n```\n\nА здесь видно, что были активированы интерфейсы br0 и host0 с отдельными IP-адресами и шлюзом по умолчанию 192.168.1.254. Адрес шлюза был автоматически назначен systemd-networkd.\n\n"
    },
    {
      "title": "Сетевой мост со статическими IP-адресами",
      "level": 3,
      "content": "Настройка статического IP-адреса может быть удобной в случае развёртывания веб-сервисов (например, FTP, http, SSH). Если в файле /usr/lib/systemd/network/99-default.link задан параметр MACAddressPolicy=persistent (значение по умолчанию), то устройствам будут назначены постоянные MAC-адреса. Следовательно, будет несложно настроить маршрутизацию сервисов от шлюза на разные интерфейсы.\n\nВыполните следующие настройки:\n\n- на хосте\n\nНастройка очень похожа на настройку #Сетевой мост с DHCP. Во-первых, нужно создать виртуальный мост и привязать к нему физический интерфейс. Эта делается с помощью двух файлов настроек, содержание которых аналогично файлам из раздела о DHCP.\n\n```\n/etc/systemd/network/мой_мост.netdev\n/etc/systemd/network/мой_Eth.network\n```\n\nДалее, необходимо настроить IP и DNS для моста. Пример настройки:\n\n```\n/etc/systemd/network/мой_мост.network\n```\n\n```\n[Match]\nName=br0\n\n[Network]\nDNS=192.168.1.254\nAddress=192.168.1.87/24\nGateway=192.168.1.254\n```\n\n- на контейнере\n\nЧтобы настроить статический IP-адрес для контейнера, необходимо заместить системный файл /usr/lib/systemd/network/80-container-host0.network, который содержит настройки DHCP для сетевого интерфейса host0 контейнера. Для этого нужно поместить настройки в файл /etc/systemd/network/80-container-host0.network. Например:\n\n```\n/etc/systemd/network/80-container-host0.network\n```\n\n```\n[Match]\nName=host0\n\n[Network]\nDNS=192.168.1.254\nAddress=192.168.1.94/24\nGateway=192.168.1.254\n```\n\nНе забудьте проверить, что служба systemd-networkd.service в контейнере включена.\n\n"
    },
    {
      "title": "Интеграция сетевого интерфейса и рабочего стола",
      "level": 3,
      "content": "Systemd-networkd не имеет встроенной функциональности для интерактивного управления сетевыми интерфейсами, ни через графическое приложение, ни через командную оболочку. Тем не менее, существует ряд утилит для отображения состояния сети, изменения настроек или получения уведомлений.\n\n- Утилита командной строки networkctl позволяет вывести информацию о сетевых интерфейсах.\n- Когда networkd настраивается с помощью wpa_supplicant, утилитами wpa_cli и wpa_gui можно динамически настраивать WLAN-интерфейсы.\n- Плагин networkd-notify-gitAUR выводит уведомления при изменениях в работе интерфейса (например, при установлении соединения или его завершении).\n- Демон networkd-dispatcherAUR позволяет выполнять сценарии при изменении состояния интерфейса. Работает схожим образом с NetworkManager-dispatcher.\n- Отобразить информацию о DNS-сервере для systemd-resolved можно командой resolvectl status.\n\n"
    },
    {
      "title": "Назначение IP-адреса на основании SSID",
      "level": 3,
      "content": "Может возникнуть ситуация, когда дома вы используете беспроводную сеть с DHCP, а на работе — беспроводную же сеть, но со статическим IP-адресом. Пример смешанных настроек приведён ниже.\n\n```\n/etc/systemd/network/24-wireless-office.network\n```\n\n```\n# отдельные настройки для сети WiFi на работе\n[Match]\nName=wlp2s0\nSSID=название_точки_доступа\n#BSSID=aa:bb:cc:dd:ee:ff\n\n[Network]\nAddress=10.1.10.9/24\nGateway=10.1.10.1\nDNS=10.1.10.1\n#DNS=8.8.8.8\n```\n\n```\n/etc/systemd/network/25-wireless-dhcp.network\n```\n\n```\n# для остальных сетей используется DHCP\n[Match]\nName=wlp2s0\n\n[Network]\nDHCP=ipv4\n```\n\n"
    },
    {
      "title": "Объединение проводного и беспроводного интерфейсов",
      "level": 3,
      "content": "См. также Wireless bonding.\n\nОбъединение интерфейсов (bonding) позволяет использовать для одного Интернет-соединения несколько сетевых интерфейсов. Если затем, например, проводной сетевой интерфейс по какой-то причине отключится, соединение будет перенаправлено на беспроводной.\n\nСоздайте объединённый интерфейс. В качестве режима работы необходимо указать active-backup, чтобы пакеты направлялись на запасной сетевой интерфейс, если основной будет отключён.\n\n```\n/etc/systemd/network/30-bond0.netdev\n```\n\n```\n[NetDev]\nName=bond0\nKind=bond\n\n[Bond]\nMode=active-backup\nPrimaryReselectPolicy=always\nMIIMonitorSec=1s\n```\n\nУкажите проводной интерфейс в качестве основного:\n\n```\n/etc/systemd/network/30-ethernet-bond0.network\n```\n\n```\n[Match]\nName=enp0s25\n\n[Network]\nBond=bond0\nPrimarySlave=true\n```\n\nБеспроводной интерфейс будет запасным:\n\n```\n/etc/systemd/network/30-wifi-bond.network\n```\n\n```\n[Match]\nName=wlan0\n\n[Network]\nBond=bond0\n```\n\nОбъединённый интрефейс необходимо настроить так же, как настраивается обычный сетевой интерфейс:\n\n```\n/etc/systemd/network/30-bond0.network\n```\n\n```\n[Match]\nName=bond0\n\n[Network]\nDHCP=ipv4\n```\n\nТеперь, если Ethernet-интерфейс будет отключён, соединение сохранится по беспроводной сети:\n\n```\n$ networkctl\n```\n\n```\nIDX LINK    TYPE     OPERATIONAL      SETUP     \n  1 lo      loopback carrier          unmanaged \n  2 enp0s25 ether    no-carrier       configured\n  3 bond0   bond     degraded-carrier configured\n  5 wlan0   wlan     enslaved         configured\n\n4 links listed.\n```\n\n"
    },
    {
      "title": "Ускорение TCP Slow Start",
      "level": 3,
      "content": "В сетях с большой пропускной способностью и значительной величиной задержки (для домашнего интернета — выше 10 Мбит/с) стандартные значения для алгоритма TCP Slow Start являются довольно консервативными. Это приводит к тому, что загрузки начинаются медленно и проходит несколько секунд, прежде чем будет задействована вся доступная пропускная способность. Особенно это заметно при обновлениях пакетов в pacman, когда загрузка каждого отдельного пакета успевает завершиться до достижения максимальной скорости для данного соединения.\n\nНастройки TCP позволяют увеличить начальный размер окна, в результате чего соединения будут \"ускоряться\" быстрее [1]. Для медленных соединений это часто приводит к замедлению передачи, поскольку приходится передавать заново большое количество потерянных пакетов, но при наличии достаточной пропускной способности производительность вырастет.\n\nОчень важно провести тестовые замеры до и после изменения значений, чтобы убедиться, что вы повысили скорость, а не уменьшили её. Если вы не замечаете, что ваши загрузки начинаются медленно, то скорее всего, текущие значения являются оптимальными для вашего соединения. При тестах следует использовать как быстрый, так и медленный удалённый сервер, чтобы убедиться, что вы не ускорили доступ к быстрым машинам, при этом сделав доступ к медленным серверам ещё медленнее.\n\nОтредактируйте .network-файл для соединения:\n\n```\n/etc/systemd/network/eth0.network\n```\n\n```\n[Match]\nName=eth0\n\n#[Network]\n#Gateway=...  <-- Удалите это значение, если оно задано, и поместите в строку Gateway= ниже\n\n[Route]\n# Применяется только к шлюзам с DHCP. Если вы вручную выбрали шлюз,\n# то укажите его.\nGateway=_dhcp4\n\n# Стандартное значение — 10. Это множитель для MSS (1460 байт).\nInitialCongestionWindow=10\nInitialAdvertisedReceiveWindow=10\n```\n\nСтандартное значение 10 хорошо работает для сетей меньше 10 Мбит/с. Для соединений 100 Мбит/с подойдёт значение 30. Если верить systemd.network(5) § [ROUTE] SECTION OPTIONS, значение 100 будет уже чрезмерным.\n\nЕсли параметр sysctl net.ipv4.tcp_slow_start_after_idle включён, то соединение будет возвращаться к этим начальным настройкам после некоторого простоя (иногда довольно небольшого). Если этот параметр отключён, соединение будет работать с большим размером окна, если оно было согласовано при передаче пакетов. Вне зависимости от значения этого параметра, каждое TCP-соединение будет начинать со значений в параметрах Initial*.\n\nПараметр sysctl net.ipv4.tcp_congestion_control не относится напрямую к этим значениям, но он управляет перегрузками и размером окна получателя, особенно при перегрузке канала связи, что обычно выливается в уменьшение пропускной способности. Значения Initial* задают стандартные значения окна для каждого соединения, до того, как алгоритм управления перегрузками возьмет управление на себя и изменит их под текущие потребности. Более высокие значения позволят ускорить процесс согласования, пока алгоритм перегрузок пытается найти оптимальное значение. Наоборот, задание неправильных значений усложняет согласование и работу алгоритма управления перегрузками, замедляя каждое TCP-соединение на несколько дополнительных секунд.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- systemd-networkd(8)\n- Tom Gundersen posts on Core OS blog\n- How to set up systemd-networkd with wpa_supplicant (WonderWoofy's walkthrough on Arch forums)\n\n"
    }
  ]
}