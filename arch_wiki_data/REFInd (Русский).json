{
  "title": "REFInd (Русский)",
  "url": "https://wiki.archlinux.org/title/REFInd_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- Процесс загрузки Arch\n- Загрузчик\n- Unified Extensible Firmware Interface (Русский)\n- EFISTUB (Русский)\n- booster\n\nrEFInd - UEFI-загрузчик, способный запускать ядра EFISTUB. Это форк более не поддерживаемого rEFIt, и в нем исправлены многие проблемы, касающиеся загрузки UEFI вне Mac-устройств. Он построен вокруг идеи кроссплатформенности и упрощения загрузки нескольких операционных систем.\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Установите пакет refind.\n\n"
    },
    {
      "title": "Установка загрузчика rEFInd",
      "level": 2,
      "content": "rEFInd поставляется с драйверами UEFI, которые реализуют поддержку в режиме \"только чтение\" ReiserFS (устарел), Ext2, Ext4, Btrfs, ISO-9660 и HFS+. Вдобавок rEFInd имеет доступ к любой файловой системе, к которой имеет доступ сам UEFI, включая FAT (как указано в спецификации UEFI), HFS+ на Mac и ISO-9660 на некоторых системах.\n\nСм. The rEFInd Boot Manager: Using EFI Drivers: Finding Additional EFI Drivers для поиска дополнительных драйверов.\n\nЧтобы использовать rEFInd, Вам нужно установить его в системный раздел EFI или используя скрипт refind-install или копированием файлов и выставлением загрузочной записи вручную.\n\n"
    },
    {
      "title": "Установка при помощи refind-install",
      "level": 3,
      "content": "Пакет rEFInd включает скрипт refind-install для упрощения процесса выставления rEFInd загрузочной записью EFI по умолчанию. Скрипт имеет несколько опций для работы с различными реализациями UEFI. См. refind-install(8) или комментарии в скрипте для объяснений различных опций установки.\n\nДля большинства систем будет достаточно запустить:\n\n```\n# refind-install\n```\n\nЭтот скрипт постарается найти и примонтировать Ваш ESP, скопировать файлы rEFInd в esp/EFI/refind/, и применить efibootmgr, чтобы сделать rEFInd загрузчиком EFI по умолчанию.\n\nВы также можете установить rEFInd в стандартный/запасной путь загрузки esp/EFI/BOOT/bootx64.efi. Это полезно для загрузочных USB-устройств или в системах с проблемами, связанными с изменениями в NVRAM, произведенными efibootmgr:\n\n```\n# refind-install --usedefault /dev/sdXY\n```\n\nГде /dev/sdXY - ваш системный раздел EFI (устройство, а не точка его монтирования).\n\nПосле установки файлов rEFInd в ESP убедитесь, что rEFInd создал файл refind_linux.conf, содержащий параметры ядра в том же каталоге, где и Ваше ядро. Этот конфигурационный файл не будет создан, если Вы использовали опцию --usedefault - запустите mkrlconf с правами root, чтобы создать его.\n\nПо умолчанию, rEFInd просканирует все Ваши устройства (для которых у него есть драйвера) и добавит загрузочные записи для всех EFI загрузчиков, что сможет найти, что должно включать Ваше ядро (т. к. в Arch EFISTUB включен по умолчанию). Таким образом, у Вас уже должна быть система, способная к загрузке.\n\n"
    },
    {
      "title": "Безопасная загрузка (Secure Boot)",
      "level": 4,
      "content": "См. Managing Secure Boot для поддержки безопасной загрузки в rEFInd.\n\nСм. Secure Boot#Set up PreLoader для получения подписанных бинарных файлов PreLoader.efi и HashTool.efi.\n\nВыполните refind-install с опцией --preloader /путь/к/прелоадеру\n\n```\n# refind-install --preloader /usr/share/preloader-signed/PreLoader.efi\n```\n\nВ следующий раз, когда Вы будете загружаться с включенной безопасной загрузкой, HashTool запустится, и Вам нужно будет зарегистрировать хэши rEFInd (loader.efi), драйверов rEFInd (напр. ext4_x64.efi) и ядра (напр. vmlinuz-linux).\n\nСм. refind-install(8) для дополнительной информации.\n\nУстановите shim-signedAUR. См. Secure Boot#shim (пропустите этап копирования файлов).\n\nЧтобы использовать лишь хэши при помощи shim, запустите refind-install с опцией --shim /путь/к/shim.\n\n```\n# refind-install --shim /usr/share/shim-signed/shimx64.efi\n```\n\nВ следующий раз, когда Вы будете загружаться с включенной безопасной загрузкой, MokManager запустится, и Вам нужно будет зарегистрировать хэши rEFInd (loader.efi), драйверов rEFInd (напр. ext4_x64.efi) и ядра (напр. vmlinuz-linux).\n\nЧтобы подписать rEFInd при помощи Machine Owner Key (MOK), установите sbsigntools.\n\nВыполните refind-install с опциями --shim /путь/к/shim и --localkeys:\n\n```\n# refind-install --shim /usr/share/shim-signed/shimx64.efi --localkeys\n```\n\nrefind-install создаст ключи за Вас и подпишет сам себя и свои драйвера. Вам нужно будет подписать ядро тем же ключом, например:\n\n```\n# sbsign --key /etc/refind.d/keys/refind_local.key --cert /etc/refind.d/keys/refind_local.crt --output /boot/vmlinuz-linux /boot/vmlinuz-linux\n```\n\nВ MokManager добавьте refind_local.cer в MoKList. refind_local.cer может быть найден внутри каталога, называющегося keys в каталоге установки rEFInd, напр. esp/EFI/refind/keys/refind_local.cer.\n\nСм. refind-install(8) для дополнительной информации.\n\nСледуйте Secure Boot#Using your own keys, чтобы создать ключи.\n\nСоздайте каталог /etc/refind.d/keys и поместите ключ подписи базы данных (db) и сертификаты в него. Назовите файлы: refind_local.key (приватный ключ в формате PEM), refind_local.crt (сертификат в формате PEM) и refind_local.cer (сертификат в формате DER).\n\nПри запуске скрипта установки укажите опцию --localkeys, т.е.:\n\n```\n# refind-install --localkeys\n```\n\nБинарные файлы EFI rEFInd будут подписаны предоставленным ключом и сертификатом.\n\n"
    },
    {
      "title": "Ручная установка",
      "level": 3,
      "content": "Если скрипт refind-install для Вас не работает, rEFInd можно установить вручную.\n\nПрежде всего, скопируйте бинарный файл в ESP:\n\n```\n# mkdir -p esp/EFI/refind\n# cp /usr/share/refind/refind_x64.efi esp/EFI/refind/\n```\n\nЕсли Вы хотите установить rEFInd в стандартный/запасной путь загрузки, замените esp/EFI/refind/ на esp/EFI/BOOT/ и скопируйте бинарный файл EFI rEFInd в esp/EFI/BOOT/bootx64.efi:\n\n```\n# mkdir -p esp/EFI/BOOT\n# cp /usr/share/refind/refind_x64.efi esp/EFI/BOOT/bootx64.efi\n```\n\nЗатем используйте efibootmgr, чтобы создать загрузочную запись в NVRAM UEFI, где /dev/sdX и Y - устройство и номер раздела для вашего системного раздела EFI. Если Вы устанавливаете rEFInd в стандартный/запасной загрузочный путь esp/EFI/BOOT/bootx64.efi, Вы также можете пропустить этот шаг.\n\n```\n# efibootmgr --create --disk /dev/sdX --part Y --loader /EFI/refind/refind_x64.efi --label \"rEFInd Boot Manager\" --unicode\n```\n\nНа данном этапе Вы должны быть способны загрузиться в rEFInd, но он не загрузит ваше ядро. Если ядро не находится в вашем ESP, rEFInd может примонтировать разделы, чтобы найти его - учитывая, что у него есть необходимые драйверы.\n\nrEFInd автоматически загружает все драйвера из подкаталогов drivers и drivers_arch (например, drivers_x64) в своем установочном каталоге.\n\n```\n# mkdir esp/EFI/refind/drivers_x64\n# cp /usr/share/refind/drivers_x64/drivername_x64.efi esp/EFI/refind/drivers_x64/\n```\n\nТеперь rEFInd должен иметь загрузочную запись для Вашего ядра, но он не передаст необходимые параметры ядра. См. #Передача параметров ядра. Теперь Вы должны иметь возможность загрузить Ваше ядро при помощи rEFInd. Если Вы все еще не можете загрузить ядро или Вам нужно отредактировать настройки rEFInd, многие параметры могут быть изменены при помощи конфигурационного файла:\n\n```\n# cp /usr/share/refind/refind.conf-sample esp/EFI/refind/refind.conf\n```\n\nПример конфигурационного файла хорошо закомментирован и не требует дополнительных разъяснений.\n\nЕсли Вы не выставили параметр textonly в конфигурационном файле, Вам стоит скопировать иконки rEFInd, чтобы избавиться от уродливых стандартных плейсхолдеров:\n\n```\n# cp -r /usr/share/refind/icons esp/EFI/refind/\n```\n\nВы можете попробовать различные шрифты, копируя их и изменяя параметр font в refind.conf:\n\n```\n# cp -r /usr/share/refind/fonts esp/EFI/refind/\n```\n\n"
    },
    {
      "title": "Обновление",
      "level": 3,
      "content": "Pacman обновляет файлы rEFInd в /usr/share/refind/, но копировать новые файлы в ESP не будет. Если refind-install для Вашей изначальной установки rEFInd сработал, Вы можете запустить его заново, чтобы скопировать новые файлы. Новый конфигурационный файл будет скопирован как refind.conf-sample, так что Вы сможете внести изменения в существующий файл при помощи утилиты diff. Если Вашему rEFInd требуется #Ручная установка, Вам потребуется самим выяснить, какие файлы нужно скопировать.\n\n"
    },
    {
      "title": "Хук Pacman",
      "level": 4,
      "content": "Вы можете автоматизировать процесс хуком pacman:\n\n```\n/etc/pacman.d/hooks/refind.hook\n```\n\n```\n[Trigger]\nOperation=Upgrade\nType=Package\nTarget=refind\n\n[Action]\nDescription = Updating rEFInd on ESP\nWhen=PostTransaction\nExec=/usr/bin/refind-install\n```\n\nГде Exec=, возможно, потребуется изменить на корректную команду обновления для Вашей системы. Если была выполнена #Ручная установка, Вы можете создать собственный скрипт обновления, чтобы она вызывалась вместе с хуком.\n\n"
    },
    {
      "title": "Настройка",
      "level": 2,
      "content": "Конфигурация rEFInd refind.conf находится в том же разделе, что и EFI-приложение rEFInd (обычно esp/EFI/refind или esp/EFI/BOOT). Стандартный конфигурационный файл содержит обширные комментарии, объясняющие все его параметры, см. Configuring the Boot Manager для дополнительных объяснений.\n\n"
    },
    {
      "title": "Передача параметров ядра",
      "level": 3,
      "content": "Есть два метода задания параметров ядра, которые rEFInd передаст в ядро.\n\n"
    },
    {
      "title": "Для ядер, автоматически найденных rEFInd",
      "level": 4,
      "content": "Для автоматически найденных ядер Вы можете или указать параметры ядра напрямую в /boot/refind_linux.conf, или полагаться на способность rEFInd определять корневой раздел и параметры ядра. См. Methods of Booting Linux: For Those With Foresight or Luck: The Easiest Method для дополнительной информации.\n\n- rEFInd автоматически выберет иконку Arch Linux (os_arch.png) для загрузочной опции, когда /etc/os-release находится в том же разделе, что и ядро. Если Ваш /boot находится в отдельном разделе, см. Configuring the Boot Manager: Setting OS Icons.\n- rEFInd не поддерживает унифицированные образы ядер. Чтобы у Вас была иконка для унифицированного образа ядра, скопируйте /usr/share/refind/icons/os_arch.png в esp/EFI/Linux/ и убедитесь, что имена файлов совпадают. Т. е., если у Вас есть esp/EFI/Linux/arch-linux.efi, то назовите иконку esp/EFI/Linux/arch-linux.png.\n\nЧтобы rEFInd поддерживал формат имен ядер Arch Linux и мог сопоставить их с их образами initramfs, раскомментируйте и отредактируйте параметр extra_kernel_version_strings в refind.conf, например:\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nextra_kernel_version_strings linux-hardened,linux-rt-lts,linux-zen,linux-lts,linux-rt,linux\n...\n```\n\n- rEFInd поддерживает лишь обнаружение одного образа initramfs на ядро, а значит, он не будет обнаруживать запасные initramfs или образы микрокода. Они должны быть обозначены вручную.\n- Без строчки extra_kernel_version_strings, переменная %v в refind_linux.conf не будет работать для ядер Arch Linux.\n\nЕсли rEFInd автоматически находит Ваше ядро, Вы можете поместить файл refind_linux.conf, содержащий параметры ядра, в тот же каталог, где и Ваше ядро. Вы можете использовать /usr/share/refind/refind_linux.conf-sample в качестве отправной точки. Первая раскомментированная строчка refind_linux.conf и будет параметрами ядра по умолчанию. Последующие строчки будут определять пункты в подменю, доступные при помощи +, F2, или Insert.\n\nИначе, попробуйте запустить mkrlconf с root-правами. Он попытается найти Ваше ядро в /boot и автоматически сгенерировать refind_linux.conf. Скрипт назначит лишь самые базовые параметры ядра, так что убедитесь в корректности файла.\n\nЕсли Вы не укажете параметр initrd=, rEFInd автоматически добавит его при помощи поиска общих имен файлов RAM-диска в том же каталоге, где и ядро. Если Вам требуется несколько параметров initrd=, указать их нужно вручную в refind_linux.conf. Например, микрокод, передающийся перед initramfs:\n\n```\n/boot/refind_linux.conf\n```\n\n```\n\"Boot using default options\"     \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\intel-ucode.img initrd=boot\\amd-ucode.img initrd=boot\\initramfs-%v.img\"\n\"Boot using fallback initramfs\"  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\intel-ucode.img initrd=boot\\amd-ucode.img initrd=boot\\initramfs-%v-fallback.img\"\n\"Boot to terminal\"               \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\intel-ucode.img initrd=boot\\amd-ucode.img initrd=boot\\initramfs-%v.img systemd.unit=multi-user.target\"\n```\n\n- Путь initrd относителен к корню файловой системы, в которой лежит ядро. Это может быть initrd=\\boot\\initramfs-%v.img, или же, если /boot - отдельный раздел (т. е. ESP), initrd=initramfs-%v.img .\n- Используйте обратные слэши (\\) в качестве разделителей пути в параметре initrd, иначе ядро не сможет найти образ(ы) initramfs: EFI stub: ERROR: Failed to open file: /boot/intel-ucode.img.\n- При использовании образов initramfs, сгенерированных Booster, замените initramfs на booster в имени файлов initramfs. Т. е. initrd=\\boot\\booster-%v.img.\n\nNote: **acpi_osi=\"\"Windows 2015\"\"** \n\n- Кавычки экранируются повторением (т. е. \"\" - экранированная версия \"). Например, чтобы передать параметр acpi_osi=\"Windows 2015\" в первую загрузочную запись вышеуказанного refind_linux.conf: \"Boot using default options\" \"... initrd=boot\\initramfs-%v.img acpi_osi=\"\"Windows 2015\"\" \"\n- rEFInd заменяет %v в refind_linux.conf версией ядра (извлекая ее из имени файла). Чтобы rEFInd поддерживал ядра Arch Linux, параметр extra_kernel_version_strings должен быть отредактирован как описано в разделе #Для ядер, автоматически найденных rEFInd.\n\n```\n\"Boot using default options\"     \"... initrd=boot\\initramfs-%v.img acpi_osi=\"\"Windows 2015\"\" \"\n```\n\nЕсли Вы просто установите rEFInd в ESP и запустите без каких-либо дополнительных телодвижений (скажем, при помощи консоли UEFI или KeyTool, или напрямую из встроенного ПО), Вы все еще получите меню загрузки, созданное при помощи автообнаружения, без какой-либо требуемой конфигурации.\n\nЭто работает, поскольку у rEFInd есть запасной механизм, который может:\n\n- Определить корневой раздел (параметр root=) при помощи спецификации обнаруживаемых разделов или /etc/fstab.\n- Находить опции ядра (ro или rw) из атрибутов GPT-разделов (используя атрибут 60 \"только-чтение\") или /etc/fstab.\n\n"
    },
    {
      "title": "Для строф загрузки, заданных вручную",
      "level": 4,
      "content": "Если Ваше ядро не обнаружено автоматически, или же Вы просто хотите больше контроля над опциями в пунктах меню, Вы можете вручную создавать пункты меню используя строфы в refind.conf. Убедитесь, что scanfor включает manual, иначе эти пункты не появятся в меню rEFInd. Параметры ядра задаются при помощи ключевого слова options. rEFInd добавит параметр initrd=, используя файл, указанный ключевым словом initrd в строфе. Если Вам нужны дополнительные initrd (например, для микрокода), Вы можете указать их в options (и тот, что указан ключевым словом initrd, будет добавлен в конец).\n\nСтрофы, заданные вручную, объясняются в Creating Manual Boot Stanzas.\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\n\nmenuentry \"Arch Linux\" {\n\ticon     /EFI/refind/icons/os_arch.png\n\tvolume   \"Arch Linux\"\n\tloader   /boot/vmlinuz-linux\n\tinitrd   /boot/initramfs-linux.img\n\toptions  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw add_efi_memmap initrd=boot\\intel-ucode.img initrd=boot\\amd-ucode.img\"\n\tsubmenuentry \"Boot using fallback initramfs\" {\n\t\tinitrd /boot/initramfs-linux-fallback.img\n\t}\n\tsubmenuentry \"Boot to terminal\" {\n\t\tadd_options \"systemd.unit=multi-user.target\"\n\t}\n}\n```\n\nСкорее всего, Вам потребуется изменить volume, чтобы этот параметр соответствовал LABEL файловой системы, или PARTLABEL/PARTUUID того раздела, где находится образ ядра. PARTUUID должен быть в верхнем регистре. Смотрите раздел Постоянные имена для блочных устройств#by-label для примеров присваивания метки тома. Если volume не указан, он по умолчанию равняется тому, из которого запускается rEFInd (обычно системный раздел EFI).\n\n- Пути loader и initrd относительны к корню volume. Если /boot - отдельный раздел (напр. ESP), пути loader и initrd должны быть /vmlinuz-linux и /initramfs-linux.img, соответственно.\n- Используйте обратные слэши (\\) в качестве разделителей пути в параметре initrd, иначе ядро не сможет найти образ(ы) initramfs: EFI stub: ERROR: Failed to open file: /boot/intel-ucode.img.\n- При использовании образов initramfs, сгенерированных Booster, замените initramfs на booster в имени файлов initramfs. Т. е. initrd /boot/booster-linux.img.\n\nNote: **acpi_osi=\"\"Windows 2015\"\"** \n\n- Кавычки экранируются повторением (т. е. \"\" - экранированная версия \"). Например, чтобы передать параметр acpi_osi=\"Windows 2015\" в загрузочную запись \"Arch Linux\": options \"... initrd=boot\\amd-ucode.img acpi_osi=\"\"Windows 2015\"\" \"\n\n```\noptions  \"... initrd=boot\\amd-ucode.img acpi_osi=\"\"Windows 2015\"\" \"\n```\n\n"
    },
    {
      "title": "Установка параллельно уже существующему UEFI Windows",
      "level": 2,
      "content": "rEFInd совместим с системным разделом EFI, созданным установкой UEFI Windows, так что нет нужды создавать или форматировать еще один раздел FAT32, когда Вы устанавливаете Arch Linux вместе с Windows. Просто примонтируйте уже существующий ESP и установите rEFInd, как обычно. По умолчанию, функция автообнаружения rEFInd должна опознать любые существующие загрузчики Windows.\n\n"
    },
    {
      "title": "Инструменты",
      "level": 2,
      "content": "rEFInd поддерживает запуск различных инструментов. Они должны быть установлены отдельно. Отредактируйте showtools в refind.conf, чтобы выбрать, какие инструменты должны показываться.\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nshowtools shell, memtest, mok_tool, gdisk, fwupdate ...\n...\n```\n\n"
    },
    {
      "title": "Консоль UEFI",
      "level": 3,
      "content": "Смотрите Unified Extensible Firmware Interface (Русский)#UEFI Shell.\n\nСкопируйте shellx64.efi в корень системного раздела EFI.\n\n"
    },
    {
      "title": "Memtest86+",
      "level": 3,
      "content": "Установите пакет memtest86+-efi и скопируйте его в esp/EFI/tools/.\n\n```\n# cp /boot/memtest86+/memtest.efi esp/EFI/tools/memtest86.efi\n```\n\n"
    },
    {
      "title": "Средства управления ключами",
      "level": 3,
      "content": "rEFInd может обнаружить средства управления ключами безопасной загрузки, если они помещены в каталог rEFInd в ESP, esp/ или esp/EFI/tools/.\n\n"
    },
    {
      "title": "HashTool",
      "level": 4,
      "content": "Следуйте #Использование прелоадера и HashTool.efi будет помещен в каталог rEFInd.\n\n"
    },
    {
      "title": "MokManager",
      "level": 4,
      "content": "Следуйте #Использование shim и MokManager будет помещен в каталог rEFInd.\n\n"
    },
    {
      "title": "KeyTool",
      "level": 4,
      "content": "Установите efitools.\n\nПоместите бинарный файл EFI KeyTool в esp/ или esp/EFI/tools/ с именем KeyTool.efi или KeyTool-signed.efi.\n\nСм. Secure Boot#Using KeyTool для инструкций по подписыванию KeyTool.efi.\n\n"
    },
    {
      "title": "GPT fdisk (gdisk)",
      "level": 3,
      "content": "Загрузите GPT fdisk (Русский)#EFI-приложение gdisk и скопируйте gdisk_x64.efi в esp/EFI/tools/.\n\n"
    },
    {
      "title": "fwupd",
      "level": 3,
      "content": "Установите fwupd-efi и настройте fwupd.\n\nСкопируйте fwupdx64.efi и файлы firmware в esp/EFI/tools/:\n\n```\n# cp /usr/lib/fwupd/efi/fwupdx64.efi esp/EFI/tools/\n```\n\n"
    },
    {
      "title": "Выключение или перезагрузка",
      "level": 3,
      "content": "rEFInd имеет встроенные пункты меню выключения и перезагрузки. Так как список инструментов, находящийся здесь, самый обширный в своем роде на всей вики, пользователи консоли UEFI или иных менеджеров загрузки UEFI, например, systemd-boot, могут быть заинтересованы в powerofforreboot.efiAUR.\n\n"
    },
    {
      "title": "Использование драйверов в консоли UEFI",
      "level": 3,
      "content": "Чтобы использовать драйверы rEFInd в консоли UEFI, загрузите их командой load и обновите диски при помощи map -r.\n\n```\nShell> load FS0:\\EFI\\refind\\drivers\\ext4_x64.efi\nShell> map -r\n```\n\nТеперь Вы можете получить доступ к своей файловой системе из консоли UEFI.\n\n"
    },
    {
      "title": "Указание разрешения efifb",
      "level": 3,
      "content": "Если разрешение в refind.conf выставлено на неверное значение, на всех системах, кроме Mac, rEFInd будет отображать список поддерживаемых разрешений. На Mac он просто будет втихую использовать разрешение по умолчанию.\n\nЧтобы определить разрешения фреймбуфера, поддерживаемые efifb, скопируйте /usr/share/gnu-efi/apps/x86_64/modelist.efi из gnu-efi в корень ESP. Зайдите в консоль UEFI и запустите modelist.efi.\n\n```\nShell> FS0:\\modelist.efi\n```\n\n```\nGOP reports MaxMode 3\n 0: 640x480 BGRR pitch 640\n*1: 800x600 BGRR pitch 800\n 2: 1024x768 BGRR pitch 1024\n```\n\nВыберите одно в refind.conf. Перезагрузитесь и убедитесь, что настройки были применены, запустив dmesg | grep efifb с правами root.\n\n"
    },
    {
      "title": "Автообнаружение",
      "level": 4,
      "content": "Чтобы разрешить автоопределение ядер на подтоме Btrfs, раскомментируйте и отредактируйте also_scan_dirs в refind.conf.\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nalso_scan_dirs +,subvolume/boot\n...\n```\n\nДалее, добавьте subvol=subvolume к rootflags в refind_linux.conf и затем присоедините subvolume к пути initrd.\n\n```\n/boot/refind_linux.conf\n```\n\n```\n\"Boot using standard options\"  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw rootflags=subvol=subvolume initrd=subvolume\\boot\\initramfs-%v.img\"\n```\n\n"
    },
    {
      "title": "Загрузочная строфа, заданная вручную",
      "level": 4,
      "content": "Если Вы загружаете подтом btrfs как корень, присоедините путь до подтома к путям loader и initrd, и дополните строку options rootflags=subvol=root_subvolume. В примере ниже в качестве корня монтируется подтом btrfs, названный 'ROOT' (например, mount -o subvol=ROOT /dev/sdxY /mnt):\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nmenuentry \"Arch Linux\" {\n        icon     /EFI/refind/icons/os_arch.png\n        volume   \"[bootdevice]\"\n        loader   /ROOT/boot/vmlinuz-linux\n        initrd   /ROOT/boot/initramfs-linux.img\n        options  \"root=PARTUUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX rw rootflags=subvol=ROOT\"\n...\n}\n```\n\nЕсли этого не сделать, Вы получите следующее сообщение об ошибке: ERROR: Root device mounted successfully, but /sbin/init does not exist.\n\n"
    },
    {
      "title": "LoaderDevicePartUUID",
      "level": 3,
      "content": "С версии 0.13.1, rEFInd поддерживает задание переменной UEFI LoaderDevicePartUUID. Это позволяет systemd-gpt-auto-generator(8) примонтировать ESP без необходимости указывать его в /etc/fstab. Смотрите раздел systemd (Русский)#Автомонтирование GPT-раздела.\n\nЧтобы указать LoaderDevicePartUUID в случае rEFInd, отредактируйте refind.conf и раскомментируйте write_systemd_vars true:\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\nwrite_systemd_vars true\n...\n```\n\nВы можете убедиться, что она задана, проверив ее значение при помощи cat /sys/firmware/efi/efivars/LoaderDevicePartUUID-4a67b082-0a4c-41cf-b6c7-440b29bb8c4f, или посмотрев на состояние \"Boot loader sets ESP information\" в выводе bootctl.\n\n"
    },
    {
      "title": "Apple Mac",
      "level": 3,
      "content": "mactel-bootAUR[ссылка недействительна: package not found] - экспериментальная утилита bless для Linux. Если это не сработает, используйте bless из OSX, чтобы установить rEFInd, как загрузочную запись по умолчанию:\n\n```\n# bless --setBoot --folder esp/EFI/refind --file esp/EFI/refind/refind_x64.efi\n```\n\n"
    },
    {
      "title": "Пустой экран меню rEFInd",
      "level": 3,
      "content": "Если Ваша папка drivers_x64 содержит несколько драйверов файловых систем (см. #Установка загрузчика rEFInd для разъяснений), это может привести к неправильному функционированию rEFInd из-за бага драйвера файловой системы, где отображается только пустой экран с логотипом rEFInd (для кастомных тем это будет фоновое изображение). Чтобы исправить это, уберите все драйвера, кроме того, что отвечает за файловую систему с ядром.\n\nДругой потенциальный пустой экран случается при двойной загрузке с Windows, когда rEFInd не может просканировать ESP на других дисках. Чтобы исправить это, используйте blkid, чтобы определить разделы Windows, и добавьте PARTUUID каждого раздела Windows, как отделенную запятой запись в переменную dont_scan_volumes в refind.conf. Например:\n\n```\n# blkid\n```\n\n```\n/dev/nvme0n1p1: LABEL=\"SYSTEM\" UUID=\"4CE7-C215\" BLOCK_SIZE=\"512\" TYPE=\"vfat\" PARTLABEL=\"EFI system partition\" PARTUUID=\"13aa9955-1234-5678-9098-006c334b5088\"\n/dev/nvme0n1p5: LABEL=\"Windows RE Tools\" BLOCK_SIZE=\"512\" UUID=\"08C4E6C5C4E6B45A\" TYPE=\"ntfs\" PARTLABEL=\"Basic data partition\" PARTUUID=\"4eced110-0987-6543-2123-b0ab8576869b\"\n```\n\n```\nesp/EFI/refind/refind.conf\n```\n\n```\n...\ndont_scan_volumes 13aa9955-1234-5678-9098-006c334b5088,4eced110-0987-6543-2123-b0ab8576869b\n...\n```\n\n"
    },
    {
      "title": "Не используется логотип дистрибутива",
      "level": 3,
      "content": "Если Вы видите Такса вместо логотипа Arch, возможно, Вас затронула эта проблема (тип вашего корневого раздела - Linux x86-64 root (/) вместо Linux filesystem).\n\nВы можете исправить это, изменив тип раздела.\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- The rEFInd Boot Manager от Roderick W. Smith.\n- Wikipedia:rEFInd\n- /usr/share/refind/docs/README.txt\n- Обсуждение rEFInd на Sourceforge\n\n"
    }
  ]
}