{
  "title": "GNU Screen (Русский)",
  "url": "https://wiki.archlinux.org/title/GNU_Screen_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)",
  "sections": [
    {
      "title": "Introduction",
      "level": 1,
      "content": "Ссылки по теме\n\n- tmux\n- Ratpoison\n- Xpra\n\nGNU Screen — это полноэкранный оконный менеджер для терминала, который мультиплексирует его между несколькими процессами, обычно интерактивными оболочками. Программы, запущенные в Screen, продолжают работать, когда их окно в данный момент скрыто, и даже когда весь сеанс screen отсоединён от пользовательского терминала.\n\nОбзор возможностей можно почитать в документации GNU Screen.\n\n"
    },
    {
      "title": "Установка",
      "level": 2,
      "content": "Установите пакет screen.\n\n"
    },
    {
      "title": "Использование",
      "level": 2,
      "content": "Для ввода команд нужно нажать escape-комбинацию (по умолчанию Ctrl+a) и затем нужное сочетание клавиш.\n\nНекоторым пользователям Ctrl+a кажется неудобным. Можно назначить другое сочетание клавиш, как описано в разделе #Изменение escape-комбинации.\n\n"
    },
    {
      "title": "Стандартные команды",
      "level": 3,
      "content": "- ctrl+a ? Отображает список команд и их параметры по умолчанию\n- ctrl+a : Ввод команды для screen\n- ctrl+a \" Список окон\n- ctrl+a 0 Открыть окно 0\n- ctrl+a A Переименовать текущее окно\n- ctrl+a a Отправить ctrl+a в текущее окно\n- ctrl+a c Создать новое окно\n- ctrl+a S Разделить текущий регион на два по горизонтали\n- Ctrl+a | Разделить текущий регион на два по вертикали\n- ctrl+a tab Переключить фокус ввода на следующий регион\n- ctrl+a ctrl+a Переключение между текущим и предыдущим регионами\n- ctrl+a Esc Перейти в режим копирования (используйте enter для выделения текста)\n- ctrl+a ] Вставка текста\n- ctrl+a Q Закрыть все регионы кроме текущего\n- ctrl+a X Закрыть текущий регион\n- ctrl+a d Отключиться от текущего сеанса screen, оставив его работающим в фоне. Для переподключения используйте screen -r\n\n"
    },
    {
      "title": "Вводимые команды",
      "level": 3,
      "content": "- Ctrl+a :quit Закрывает все окна и завершает сеанс screen\n- Ctrl+a :source ~/.screenrc Перезагружает файл настроек screenrc (также можно использовать /etc/screenrc)\n\n"
    },
    {
      "title": "Именованные сеансы",
      "level": 3,
      "content": "Создание сеанса с определённым названием:\n\n```\n$ screen -S название_сеанса\n```\n\nПереименование текущего сеанса:\n\nCtrl+a :sessionname название_сеанса\n\nСписок всех существующих сеансов текущего пользователя:\n\n```\n$ screen -list\n```\n\nПодключение к существующему сеансу по его имени:\n\n```\n$ screen -x название_сеанса\n```\n\nили\n\n```\n$ screen -r название_сеанса\n```\n\n"
    },
    {
      "title": "Настройка Screen",
      "level": 3,
      "content": "Вы можете изменить настройки Screen по умолчанию в соответствии с вашими предпочтениями в файле .screenrc, который содержит команды, которые выполнятся при запуске (например, ~/.screenrc или на лету с помощью ввода команд (например, Ctrl+a :vbell off).\n\n"
    },
    {
      "title": "Автозапуск с помощью systemd",
      "level": 3,
      "content": "Эта служба автоматически запускает screen для указанного пользователя (например, systemctl enable screen@florian). Важно запускать эту службу как системную, так как systemd --user может не запуститься, а также будет завершён после закрытия последнего сеанса пользователя.\n\n```\n/etc/systemd/system/screen@.service\n```\n\n```\n[Unit]\nDescription=screen\nAfter=network.target\n\n[Service]\nType=simple\nUser=%i\nExecStart=/usr/bin/screen -DmS autoscreen\nExecStop=/usr/bin/screen -S autoscreen -X quit\n\n[Install]\nWantedBy=multi-user.target\n```\n\n"
    },
    {
      "title": "Изменение escape-комбинации",
      "level": 3,
      "content": "Изменение стандартной escape-комбинации может быть хорошей идеей не только потому, что «a» обычно набирается левым мизинцем, но также и потому, что Ctrl+a часто используется как команда beginning-of-line в GNU Readline и bash-совместимых командных оболочках.\n\nЕё можно изменить с помощью опции escape в ~/.screenrc или параметра -e для команды screen.\n\nНапример, если вы заметите, что редко используете Ctrl+j в своей оболочке или редакторе, вы можете использовать escape ^Jj для изменения escape-последовательности на Ctrl+j. Второй \"j\" означает, что литерал Ctrl+j может быть отправлен на терминал путём нажатия Ctrl+j j. Для пользователей Dvorak более удобным может быть сочетание клавиш Ctrl+t (escape ^Tt).\n\nБолее экзотические варианты: escape ``, который задаёт клавишу `, или escape ^^^, который задаёт Ctrl+^.\n\nEscape-комбинация также называется \"командным символом\" (\"command character\") в документации Screen.\n\n"
    },
    {
      "title": "Запуск в окне 1",
      "level": 3,
      "content": "По умолчанию, первое окно screen имеет номер 0. Возможно, вы предпочтете начать с нумерацию с единицы, добавьте это в ~/.screenrc:\n\n```\n~/.screenrc\n```\n\n```\nbind c screen 1\nbind ^c screen 1\nbind 0 select 10\nscreen 1\n```\n\n"
    },
    {
      "title": "Вложенные сеансы Screen",
      "level": 3,
      "content": "Можно случайно застрять во вложенном сеансе screen. Частый сценарий: вы запускаете сеанс SSH внутри сеанса screen. В сеансе SSH вы запускаете screen. По умолчанию первый сеанс screen будет перехватывать команды Ctrl+a. Чтобы отправить команду второму сеансу screen, используйте Ctrl+a a и затем свою команду. Например:\n\n- Ctrl+a a d Отсоединяется от внутреннего сеанса screen.\n- Ctrl+a a K Завершает (kill) внутренний сеанс screen.\n\n"
    },
    {
      "title": "Запуск Screen во всех командных оболочках",
      "level": 3,
      "content": "Для Bash и Zsh добавьте следующий фрагмент в ваш .bashrc or .zshrc перед псевдонимами:\n\n```\n~/.bashrc or ~/.zshrc\n```\n\n```\nif [[ -z \"$STY\" ]]; then\n   screen -xRR название_сеанса\nfi\n```\n\n"
    },
    {
      "title": "Использование 256 цветов",
      "level": 3,
      "content": "По умолчанию Screen использует эмулятор 8-цветного терминала. Чтобы включить больше цветов, вам нужно использовать терминал, который их поддерживает, и установить правильное значение term. Будет использоваться terminfo для описания того, как будут интерпретироваться управляющие коды ANSI. Запись в структуре базы данных terminfo должна существовать, ncurses предоставляет много описаний в /usr/share/terminfo/.\n\nСначала попробуйте общее значение:\n\n```\n~/.screenrc\n```\n\n```\nterm screen-256color\n```\n\nЕсли это не работает, попробуйте установить значение, соответствующее вашему текущему терминалу. Например, при использовании терминала на основе xterm:\n\n```\n~/.screenrc\n```\n\n```\nterm xterm-256color\n```\n\nДля rxvt-unicode:\n\n```\n~/.screenrc\n```\n\n```\nterm rxvt-unicode-256color\n```\n\nВ крайнем случае попробуйте использовать termcapinfo:\n\n```\n~/.screenrc\n```\n\n```\nattrcolor b \".I\"    # allow bold colors - necessary for some reason\ntermcapinfo xterm 'Co#256:AB=\\E[48;5;%dm:AF=\\E[38;5;%dm'   # tell screen how to set colors. AB = background, AF=foreground\ndefbce on    # use current bg color for erased chars\n```\n\n"
    },
    {
      "title": "Информативный статус-бар",
      "level": 3,
      "content": "Стандартный статус бар немного пустоват. Вы можете посчитать это полезным:\n\n```\n~/.screenrc\n```\n\n```\nhardstatus off\nhardstatus alwayslastline\nhardstatus string '%{= kG}[ %{G}%H %{g}][%= %{= kw}%?%-Lw%?%{r}(%{W}%n*%f%t%?(%u)%?%{r})%{w}%?%+Lw%?%?%= %{g}][%{B} %m-%d %{W} %c %{g}]'\n```\n\nЕщё вариант из frodfrog's blog[устаревшая ссылка 2023-04-23 ⓘ]:\n\n```\n~/.screenrc\n```\n\n```\nhardstatus alwayslastline '%{= G}[ %{G}%H %{g}][%= %{= w}%?%-Lw%?%{= R}%n*%f %t%?%{= R}(%u)%?%{= w}%+Lw%?%= %{= g}][ %{y}Load: %l %{g}][%{B}%Y-%m-%d %{W}%c:%s %{g}]'\n```\n\nВ Screen версии 5 (master-ветка) escape-коды изменились:\n\n```\n~/.screenrc\n```\n\n```\ntruecolors on\nhardstatus off\nbacktick 0 5 5 \"/bin/date\" '+%Y-%m-%d'\nbacktick 1 5 5 \"/bin/date\" '+%H:%M'\nhardstatus alwayslastline '%{#00ff00}[ %H ][%{#ffffff}%= %{7}%?%-Lw%?%{1;0}%{1}(%{15}%n%f%t%?(%u)%?%{1;0}%{1})%{7}%?%+Lw%?%? %=%{#00ff00}][ %{#00a5ff}%{6}%0` %{#ffffff}%{7}%1`%{#00ff00} ]'\n```\n\nСтатус-бар наверху:\n\n```\n~/.screenrc\n```\n\n```\nhardstatus firstline\n```\n\n"
    },
    {
      "title": "Отключение приветственного сообщения",
      "level": 3,
      "content": "```\n~/.screenrc\n```\n\n```\nstartup_message off\n```\n\n"
    },
    {
      "title": "Использование hardstatus в качестве динамического заголовка окна терминала",
      "level": 3,
      "content": "Это довольно просто: переделайте текущий hardstatus на caption с уведомлением и отредактируйте соответствующим образом:\n\n```\n~/.screenrc\n```\n\n```\nbacktick 1 5 5 true\ntermcapinfo rxvt* 'hs:ts=\\E]2;:fs=\\007:ds=\\E]2;\\007'\nhardstatus string \"screen (%n: %t)\"\ncaption string \"%{= kw}%Y-%m-%d;%c %{= kw}%-Lw%{= kG}%{+b}[%n %t]%{-b}%{= kw}%+Lw%1`\"\ncaption always\n```\n\nЭто отобразит что-то вроде screen (0 bash) в заголовке окна вашего терминала. Caption содержит дату, текущее время и раскрашивает коллекцию экранных окон.\n\n"
    },
    {
      "title": "Использование механизма прокрутки X",
      "level": 3,
      "content": "Доступ к буферу прокрутки GNU Screen можно получить с помощью Ctrl+a [. Однако это очень неудобно. Чтобы использовать полосу прокрутки эмулятора терминала (например, в xterm или Konsole), добавьте следующую строку [1]:\n\n```\n~/.screenrc\n```\n\n```\ntermcapinfo xterm*|rxvt*|kterm*|Eterm* ti@:te@\n```\n\n"
    },
    {
      "title": "Перемещение работающий программы в Screen",
      "level": 3,
      "content": "Если вы запустили программу вне Screen, но теперь хотите поместить её внутрь Screen, вы можете использовать reptyr, чтобы переназначить процесс с его текущего TTY на Screen.\n\nУстановите пакет reptyr.\n\nНайдите PID нужного процесса (например с помощью ps ax) и используйте его как аргумент для команды reptyr внутри нужного окна screen:\n\n```\n$ reptyr pid\n```\n\n"
    },
    {
      "title": "Использование другой строки приглашения bash внутри screen",
      "level": 3,
      "content": "Добавьте в .bashrc[2]:\n\n```\nif [ -z $STY ]\nthen\n        PS1=\"ОБЫЧНЫЙ PROMPT\"\nelse  \n        PS1=\"PROMPT ДЛЯ SCREEN\"\nfi\n```\n\n"
    },
    {
      "title": "Отключение визуального сигнала",
      "level": 3,
      "content": "По умолчанию при получении ASCII-символа Bell Screen некрасиво мерцает. Можно отключить это и вернуть звуковой сигнал с помощью этой опции:\n\n```\n~/.screenrc\n```\n\n```\nvbell off\n```\n\n"
    },
    {
      "title": "Избавление от вертикальных и горизонтальных полос",
      "level": 3,
      "content": "Чтобы скрыть вертикальные полосы:\n\n```\n$ ~/.screenrc\n```\n\n```\nrendition so =00\n```\n\nЧтобы скрыть горизонтальные полосы, установите в caption основной и фоновый цвета в default (d) и выведите пустоту (\" \"):\n\n```\n~/.screenrc\n```\n\n```\ncaption string \"%{03} \"\n```\n\nЕсли это не сработает, попробуйте caption string \"%{00} \". Для стандартного чёрно-белого caption используйте caption string \"%{00}%3n %t\".\n\n"
    },
    {
      "title": "Исправление остатков текста после редактора",
      "level": 3,
      "content": "После открытия и последующего закрытия текстового редактора внутри screen (например nano) текст может оставаться видимым в терминале. Исправление:\n\n```\n~/.screenrc\n```\n\n```\naltscreen on\n```\n\n"
    },
    {
      "title": "Исправление столбца Name в windowlist, который отображает только \"bash\"",
      "level": 3,
      "content": "Добавьте в ~/.screenrc:\n\n```\n~/.screenrc\n```\n\n```\nwindowlist string \"%4n %h%=%f\"\n```\n\n"
    },
    {
      "title": "Смотрите также",
      "level": 2,
      "content": "- Wikipedia:GNU Screen\n- GNU Screen User's Manual\n- Gentoo:Screen\n- Arch Forums - коллекция настроек .screenrc со скриншотами\n- Arch Forums - Про проблему с 256 цветами в urxvt\n- MacOSX Hints - Automatically using screen in your shell[устаревшая ссылка 2023-06-17 ⓘ]\n\n"
    }
  ]
}